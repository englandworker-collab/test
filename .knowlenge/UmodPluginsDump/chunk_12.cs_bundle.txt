fied to be 0 to avoid conflicts with other plugins
                if (powerAmount > 0 && !HasConnectedInput(ioEntity, inputSlot))
                {
                    TryProvidePower(ioEntity, inputSlot, powerAmount);
                }
            }
        }

        private static T GetChildEntity<T>(BaseEntity entity) where T : BaseEntity
        {
            foreach (var child in entity.children)
            {
                var childOfType = child as T;
                if (childOfType != null)
                    return childOfType;
            }

            return null;
        }

        private static bool HasConnectedInput(IOEntity ioEntity, int inputSlot)
        {
            return inputSlot < ioEntity.inputs.Length
                && ioEntity.inputs[inputSlot].connectedTo.Get() != null;
        }

        private static void TryProvidePower(IOEntity ioEntity, int inputSlot, int powerAmount)
        {
            if (ioEntity.inputs.Length > inputSlot && !InputUpdateWasBlocked(ioEntity, inputSlot, powerAmount))
            {
                ioEntity.UpdateFromInput(powerAmount, inputSlot);
            }
        }

        private void ProcessIOEntity(IOEntity ioEntity, bool delay)
        {
            if (ioEntity == null)
                return;

            var entityConfig = GetEntityConfig(ioEntity);

            // Entity not supported
            if (entityConfig is not { Enabled: true })
                return;

            if (!EntityOwnerHasPermission(ioEntity, entityConfig))
                return;

            if (delay)
            {
                var ioEntity2 = ioEntity;
                var entityConfig2 = entityConfig;

                NextTick(() =>
                {
                    if (ioEntity2 == null)
                        return;

                    MaybeProvidePower(ioEntity2, entityConfig2);
                });
            }
            else
            {
                MaybeProvidePower(ioEntity, entityConfig);
            }
        }

        private bool EntityOwnerHasPermission(IOEntity ioEntity, EntityConfig entityConfig)
        {
            if (!entityConfig.RequirePermission)
                return true;

            var ownerEntity = GetOwnerEntity(ioEntity);
            if (ownerEntity.OwnerID == 0)
                return false;

            var ownerIdString = ownerEntity.OwnerID.ToString();
            return permission.UserHasPermission(ownerIdString, PermissionAll)
                || permission.UserHasPermission(ownerIdString, entityConfig.PermissionName);
        }

        #endregion

        #region Configuration

        private EntityConfig GetEntityConfig(IOEntity ioEntity)
        {
            return _config.Entities.TryGetValue(ioEntity.ShortPrefabName, out var entityConfig) ? entityConfig : null;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            private static readonly string[] IgnoredEntities =
            {
                // Has inputs to move the lift but does not consume power (elevatorioentity is the right one).
                "elevator",

                // Has inputs to toggle on/off but does not consume power.
                "small_fuel_generator.deployed",

                // Has audio input only
                "connectedspeaker.deployed",
                "soundlight.deployed",

                // Static entity
                "caboose_xorswitch",

                // Has no power input
                "fogmachine",
                "spookyspeaker",
                "snowmachine",
                "strobelight",
            };

            private static bool HasElectricalInput(IOEntity ioEntity)
            {
                foreach (var input in ioEntity.inputs)
                {
                    if (input.type == IOEntity.IOType.Electric)
                        return true;
                }

                return false;
            }

            [JsonProperty("Entities")]
            public Dictionary<string, EntityConfig> Entities = new()
            {
                ["andswitch.entity"] = new EntityConfig
                {
                    InputSlots = new[] { 0, 1 },
                    PowerAmounts = new[] { 0, 0 },
                },

                ["electrical.combiner.deployed"] = new EntityConfig
                {
                    InputSlots = new[] { 0, 1 },
                    PowerAmounts = new[] { 0, 0 },
                },

                // Has no pickup entity.
                ["electrical.modularcarlift.deployed"] = new EntityConfig(),

                // Has no pickup entity.
                ["elevatorioentity"] = new EntityConfig(),

                ["fluidswitch"] = new EntityConfig
                {
                    InputSlots = new[] { 2 },
                },

                ["industrialconveyor.deployed"] = new EntityConfig
                {
                    InputSlots = new[] { 1 },
                },

                ["industrialcrafter.deployed"] = new EntityConfig
                {
                    InputSlots = new[] { 1 },
                },

                // Has no pickup entity.
                ["microphonestandio.entity"] = new EntityConfig(),
                ["electricfurnace.io"] = new EntityConfig(),

                ["orswitch.entity"] = new EntityConfig
                {
                    InputSlots = new[] { 0, 1 },
                    PowerAmounts = new[] { 0, 0 },
                },

                ["poweredwaterpurifier.deployed"] = new EntityConfig
                {
                    InputSlots = new[] { 1 },
                },

                ["xorswitch.entity"] = new EntityConfig
                {
                    InputSlots = new[] { 0, 1 },
                    PowerAmounts = new[] { 0, 0 },
                },
            };

            public List<string> AddMissingPrefabs()
            {
                var addedPrefabs = new List<string>();

                foreach (var prefab in GameManifest.Current.entities)
                {
                    var ioEntity = GameManager.server.FindPrefab(prefab.ToLower())?.GetComponent<IOEntity>();
                    if (ioEntity == null || string.IsNullOrEmpty(ioEntity.ShortPrefabName))
                        continue;

                    if (Entities.TryGetValue(ioEntity.ShortPrefabName, out _))
                        continue;

                    if (!HasElectricalInput(ioEntity)
                        || ioEntity.pickup.itemTarget == null
                        || ioEntity.ShortPrefabName.ToLower().Contains("static")
                        || IgnoredEntities.Contains(ioEntity.ShortPrefabName.ToLower()))
                        continue;

                    addedPrefabs.Add(ioEntity.ShortPrefabName);
                }

                if (addedPrefabs.Count == 0)
                    return null;

                foreach (var shortPrefabName in addedPrefabs)
                {
                    Entities[shortPrefabName] = new EntityConfig();
                }

                SortEntities();

                addedPrefabs.Sort();
                return addedPrefabs;
            }

            public void GeneratePermissionNames()
            {
                foreach (var entry in Entities)
                {
                    // Make the permission name less redundant
                    entry.Value.PermissionName = string.Format(PermissionEntityFormat, entry.Key)
                        .Replace("electric.", string.Empty)
                        .Replace("electrical.", string.Empty)
                        .Replace(".deployed", string.Empty)
                        .Replace("_deployed", string.Empty)
                        .Replace(".entity", string.Empty);
                }
            }

            private void SortEntities()
            {
                var shortPrefabNames = Entities.Keys.ToList();
                shortPrefabNames.Sort();

                var newEntities = new Dictionary<string, EntityConfig>();
                foreach (var shortName in shortPrefabNames)
                {
                    newEntities[shortName] = Entities[shortName];
                }

                Entities = newEntities;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        internal class EntityConfig
        {
            private static readonly int[] StandardInputSlot = { 0 };

            [JsonProperty("RequirePermission")]
            public bool RequirePermission = false;

            // Hidden from config when it's using the default value
            [JsonProperty("InputSlots")]
            public int[] InputSlots = StandardInputSlot;

            public bool ShouldSerializeInputSlots() =>
                !InputSlots.SequenceEqual(StandardInputSlot);

            // Hidden from config when the plural form is used
            [JsonProperty("PowerAmount")]
            public int PowerAmount = 0;

            public bool ShouldSerializePowerAmount() =>
                PowerAmounts == null;

            // Hidden from config when null
            [JsonProperty("PowerAmounts", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int[] PowerAmounts;

            public string PermissionName;

            public bool Enabled
            {
                get
                {
                    foreach (var slot in InputSlots)
                    {
                        if (GetPowerForSlot(slot) > 0)
                            return true;
                    }

                    return false;
                }
            }

            public int GetPowerForSlot(int slotNumber)
            {
                var index = Array.IndexOf(InputSlots, slotNumber);

                // We can't power an input slot that we don't know about
                if (index == -1)
                    return 0;

                // Allow plural array form to take precedence if present
                if (PowerAmounts == null)
                    return PowerAmount;

                // InputSlots and PowerAmounts are expected to be parallel arrays
                return index < PowerAmounts.Length ? PowerAmounts[index] : 0;
            }
        }

        private Configuration GetDefaultConfig() => new();

        #region Configuration Helpers

        [JsonObject(MemberSerialization.OptIn)]
        private class BaseConfiguration
        {
            public bool UsingDefaults;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                _config.UsingDefaults = true;
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion
    }
}


// --- End of file: PowerlessElectronics.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/puzzle-points ---
// --- Original File Path: P/PuzzlePoints/PuzzlePoints.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using UnityEngine;
using System;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using System.Linq;
using Oxide.Core.Libraries;


namespace Oxide.Plugins
{
    [Info("Puzzle Points", "Rustonauts", "1.6.3")]
    [Description("Rewards players with scrap, economics, or RP for swiping puzzle cards and completing missions. Broadcasting this is defaulted true.")]
    class PuzzlePoints : RustPlugin
    {

        #region Fields

        [PluginReference]
        private Plugin Economics, ServerRewards, MonumentLock, MonumentNames, SuperCard;

        private Dictionary<int, string> CardTypes = new Dictionary<int, string>();
        private List<Dictionary<string, object>> _monuments;


        #endregion


        #region Init
        
        private void Init()
        {
            //Puts("-- init()");
        }

        private void OnServerInitialized()
        {     
            //Puts("-- server init()");
            LoadData();

            CardTypes.Add(1, "green");
            CardTypes.Add(2, "blue");
            CardTypes.Add(3, "red");
            CardTypes.Add(0, "super");
        }

        #endregion


        #region Configuration

        public Configuration _config;
        
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            
            try
            {
                _config = Config.ReadObject<Configuration>();        
            
                if(_config == null) {
                    Puts("-- no config, creating new");
                    LoadDefaultConfig();
                }                


                if (_config.Version < Version) {                                                             
                    UpdateConfigValues();
                }
					
                SaveConfig();

                if (_config == null) throw new Exception();
                Puts("Config loaded");                
            }
            catch(Exception e)
            {              
                Puts($"-- Error: " + e.GetBaseException().ToString());                 
            }
        }

    
        protected override void LoadDefaultConfig()
        {
            Configuration c = new Configuration();

            LoadDefaultRewards(c);

            SaveConfig();
        }


        protected void LoadDefaultRewards(Configuration config)
        {
            //economics
            config.rewards.Add(new SwipeReward(1, 50, "", "economics"));
            config.rewards.Add(new SwipeReward(2, 150, "", "economics"));
            config.rewards.Add(new SwipeReward(3, 300, "", "economics"));

            //rp
            config.rewards.Add(new SwipeReward(1, 1, "", "rp"));
            config.rewards.Add(new SwipeReward(2, 2, "", "rp"));
            config.rewards.Add(new SwipeReward(3, 3, "", "rp"));

            //dog tags
            config.rewards.Add(new SwipeReward(1, 1, "dogtags", null, 1223900335));
            config.rewards.Add(new SwipeReward(2, 1, "dogtags", null, 1036321299));
            config.rewards.Add(new SwipeReward(3, 1, "dogtags", null, -602717596));

            //scrap
            config.rewards.Add(new SwipeReward(1, 25,  "", "scrap", -932201673));
            config.rewards.Add(new SwipeReward(2, 100, "", "scrap", -932201673));
            config.rewards.Add(new SwipeReward(3, 300, "", "scrap", -932201673)); 

            //lowgradefuel
            config.rewards.Add(new SwipeReward(1, 25, "hq", "metal.refined", 0, false));
            config.rewards.Add(new SwipeReward(2, 50, "hq", "metal.refined", 0, false));
            config.rewards.Add(new SwipeReward(3, 100, "hq", "metal.refined", 0, false));
        }



        private void UpdateConfigValues()
        {            
            if (_config.Version == null || _config.Version == default(VersionNumber) || _config.Version < new VersionNumber(1,5,9))
            {
                Puts("-- ancient config found:  updating..");
                Configuration c = new Configuration();
                LoadDefaultRewards(c); 

                // config v 1.5.7
                if(_config.Version == null) UpdateConfigValues157(c);
                
                if(_config.Version < new VersionNumber(1,5,9)) UpdateConfigValues157(c);

                _config = c;
                _config.Version = new VersionNumber(1, 5, 9);
                SaveConfig();
            }
        }


        private void UpdateConfigValues157(Configuration c)
        {
            c.consoleMessages = _config.consoleMessages;
            c.broadcastSwipe = _config.broadcastSwipe;
            c.cooldown = _config.cooldown;             

            foreach(SwipeReward reward in c.rewards) {
                
                if(reward.reward_item_shortname == "economics") {
                    reward.is_active = _config.useEconomics ?? false;
                    if(reward.access_level == 1) reward.amount = _config.greenCardMoney ?? 0;
                    if(reward.access_level == 2) reward.amount = _config.blueCardMoney ?? 0;
                    if(reward.access_level == 3) reward.amount = _config.redCardMoney ?? 0;                    
                } 

                if(reward.reward_item_shortname == "rp") {
                    reward.is_active = _config.useServerRewards ?? false;
                    if(reward.access_level == 1) reward.amount = _config.greenCardRP ?? 0;
                    if(reward.access_level == 2) reward.amount = _config.blueCardRP ?? 0;
                    if(reward.access_level == 3) reward.amount = _config.redCardRP ?? 0;  
                }

                if(reward.reward_item_shortname == "scrap") {
                    reward.is_active = _config.useScrap ?? false;
                    if(reward.access_level == 1) reward.amount = _config.greenCardScrap ?? 0;
                    if(reward.access_level == 2) reward.amount = _config.blueCardScrap ?? 0;
                    if(reward.access_level == 3) reward.amount = _config.redCardScrap ?? 0;  
                }                
                
            }

            _config = c;
        }


        private void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }


        public class SwipeReward
        {
            public int access_level = 1;
            public string? reward_item_shortname;
            public int reward_item_id;
            public double amount;
            public bool is_active = true;
            public string name;


            public SwipeReward(int cardAccess, double _amount, string _name="", string shortname=null, int id=0, bool _is_active=true)
            {
                access_level = cardAccess;                
                reward_item_shortname = shortname;                                
                reward_item_id = id;
                amount = _amount;
                is_active = _is_active;
                name = _name;
                if(_name.Length < 2) name = shortname;
            }

            public SwipeReward()
            {

            }


        }


        public class Configuration
        {   [JsonIgnore]            
            public bool? useEconomics;
            [JsonIgnore]
            public bool? useServerRewards;
            [JsonIgnore]
            public bool? useScrap;
            [JsonIgnore]
            public int? redCardScrap = 300;
            [JsonIgnore]
            public int? blueCardScrap = 100;
            [JsonIgnore]
            public int? greenCardScrap = 25;
            [JsonIgnore]
            public int? redCardRP = 3;     
            [JsonIgnore]       
            public int? blueCardRP = 2;
            [JsonIgnore]
            public int? greenCardRP = 1;
            [JsonIgnore]
            public double? redCardMoney = 300.00;            
            [JsonIgnore]
            public double? blueCardMoney = 150.00;            
            [JsonIgnore]
            public double? greenCardMoney = 50.00;

            [JsonProperty(PropertyName = "Show Console Messages")]
            public bool consoleMessages = true;

            [JsonProperty(PropertyName = "Show Global Chat Monument Messages (eg. Player swipped card at Launch)")]
            public bool broadcastSwipe = true;

            [JsonIgnore]
            public bool? debugMode = false;
            
            [JsonProperty(PropertyName = "Cooldown: Amount of time (secs) a player must wait before getting rewarded to avoid swipe spam")]
            public int cooldown = 600;

            [JsonProperty(PropertyName = "Swipe Rewards")]
            public List<SwipeReward> rewards = new List<SwipeReward>();

            public VersionNumber Version;


            public Configuration()
            {
                Version = new VersionNumber(1, 5, 7);
            }
        }

   
        #endregion Configuration


        #region DataFile

        private StoredData storedData;

        public class MSession
        {
            [JsonProperty("Player Id")]
            public string player_id;

            [JsonProperty("Monument ShortName")]
            public string monument_shortname;

            [JsonProperty("Card Access Level")]
            public int access_level;

            [JsonProperty("Session started_at")]
            private string started_at;            


            public MSession(string _player_id, int _access_level, string _monument_shortname)
            {
                player_id = _player_id;
                access_level = _access_level;
                started_at = DateTime.Now.ToString();
                monument_shortname = _monument_shortname;
            }

            
            public string GetPlayerId() {return player_id;}
            public BasePlayer GetPlayer(string _player_id){return BasePlayer.FindAwakeOrSleeping(_player_id);}


            public bool InCooldown(int _cooldown)
            {                
                DateTime dt1 = DateTime.Now;
                DateTime dt2 = DateTime.Parse(started_at);
                TimeSpan lock_time = dt1-dt2;
                
                if(Math.Truncate(lock_time.TotalSeconds) < _cooldown) return true;

                return false;
            }
            

        }


        private class StoredData
        { 
            public List<MSession> m_sessions  { get; set; } = new List<MSession>();


            public StoredData()
            {   

            }

            public StoredData(List<MSession> _sessions)
            {
                m_sessions = _sessions;
            }
        }


        private void LoadData()
        {
            try
            {
                Puts("loading datafile..{0}", Name.ToString());
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
                Puts("Datafile loaded");
            }
            catch
            {
                storedData = null;
            }
            if (storedData == null)
            {
                Puts("-- no datafile, creating new..");
                ClearData();
            }
        }


        private void SaveData(bool show_console=false)
        { 
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

            if(show_console) Puts("-- data saved!");
        }


        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        #endregion


        #region Oxide Hooks

        object OnCardSwipe(CardReader cardReader, Keycard card, BasePlayer player)
        {                   
            if(IsInCooldown(player, card)) return null;            

            var gridPosition = GetGridPosition(player.ServerPosition);                        
            string _shortName = "";
            Item item = card.GetItem();

            if(UseMonumentNames()) _shortName = GetClosestMonument(player);               
            
            if((!cardReader.IsOn() && item.conditionNormalized > 0f) )
            { 
                //make sure the card reader and card are the same access levels
                if (cardReader.accessLevel == card.accessLevel || card.accessLevel == 0)
                {                         
                    //if we're not using MonumentLock, or if we are and cardswipe passes, value is null
                    if (Interface.Call("OnPPSwipe", player, CardTypes[card.accessLevel], cardReader, _shortName, gridPosition) != null)
                    {                        
                        return 1;
                    }
                    
                    Reward(player, card);           
                }
            }

            return null;
        }

        #endregion Oxide Hooks


        #region Core

        private bool IsInCooldown(BasePlayer player, Keycard card)
        {
            MSession _session = GetSession(player, card);
            if(_session != null && _session.InCooldown(_config.cooldown)) return true;
            if(_session != null) storedData.m_sessions.Remove(_session);
            SaveData();
            
            return false;
        }


        private void Reward(BasePlayer player, Keycard card)
        {          
            foreach(SwipeReward reward in _config.rewards) {
                if(card.accessLevel == reward.access_level && reward.is_active) {

                    //economics specific reward
                    if(reward.reward_item_shortname == "economics") {

                        //are we using economics and has it been turned on
                        if (UseEconomics()) 
                        {
                            //api call to economics
                            bool isDeposit = (bool) Economics.Call("Deposit", player.UserIDString, (double)reward.amount);
                            
                            if(_config.consoleMessages && isDeposit)
                            {
                                SendReply(player, GetLang("EconomicsAwarded", player.UserIDString, (double)reward.amount, CardTypes[card.accessLevel]));
                            }
                        }
                    }

                    //rp specific reward
                    else if(reward.reward_item_shortname == "rp") {                        
                        if (UseRewards())
                        {
                            //api call to server rewards
                            bool isAdd = (bool) ServerRewards.Call("AddPoints", player.UserIDString, (int)reward.amount); 

                            if(_config.consoleMessages && isAdd)
                            {
                                SendReply(player, GetLang("PointsAwarded", player.UserIDString, (int)reward.amount, CardTypes[card.accessLevel]));
                            }                          
                        }
                    }

                    //use basic item giving from shortname
                    else {
                        Item item;

                        if(reward.reward_item_id != 0) 
                            item = ItemManager.CreateByItemID(reward.reward_item_id, (int)reward.amount);                            
                        
                        else {
                            if(reward.reward_item_shortname == null) return;
                            item = ItemManager.CreateByName(reward.reward_item_shortname, (int)reward.amount);
                        }


                        if(!player.inventory.GiveItem(item))
                                item.Drop(player.eyes.position, player.eyes.BodyForward() *2);


                        if(_config.consoleMessages)
                        {
                            SendReply(player, GetLang("ItemAwarded", player.UserIDString, item.info.shortname, (int)reward.amount, CardTypes[card.accessLevel]));
                        }
                    }
                }
            }
            
            

            //all good, so lets add a new session
            storedData.m_sessions.Add(new MSession(player.UserIDString, card.accessLevel, GetClosestMonument(player)));
            SaveData();
            
            BroadcastSwipe(player, CardTypes[card.accessLevel]);
        }



        private void BroadcastSwipe(BasePlayer player, string cardType)
        {
            var gridPosition = GetGridPosition(player.ServerPosition);

            var _shortName = GetClosestMonument(player);
            

            if (_config.broadcastSwipe && MonumentLock == null)
            {
                BroadcastToChat("CardSwipedAtName", player.displayName, cardType, GetDisplayName(_shortName), gridPosition);                    
            }

            if(_config.consoleMessages)
            {
                Puts(GetLang("CardSwipedAtName", null, player.displayName, cardType, GetDisplayName(_shortName), gridPosition));
            }
        }



        private string GetClosestMonument(BasePlayer _player)
        {
            foreach(MonumentInfo info in TerrainMeta.Path.Monuments) {
                if(GetGridPosition(_player.transform.position) == GetGridPosition(info.transform.position)) return GetShortName(info.name);
            }
            //var monument = MonumentNames.Call("API_ClosestMonument", _player.transform.position) as string;
            
            return null;
        }



        #endregion Core


        #region Helpers


        private string GetShortName(string prefab_name) => prefab_name.ToString().Split("/").Last().Split(".prefab").First();


        private MSession GetSession(BasePlayer player, Keycard card)
        {
            string shortname = "";

            foreach(MonumentInfo info in TerrainMeta.Path.Monuments) {
                if(GetGridPosition(player.transform.position) == GetGridPosition(info.transform.position))  shortname = GetShortName(info.name.ToString());                                                                                                           
            }


            foreach(MSession _session in storedData.m_sessions) {
                if((_session.player_id == player.UserIDString) && (_session.access_level == card.accessLevel) && _session.monument_shortname == shortname) return _session;
            }

            return null;
        }



        private void BroadcastToChat(string langkey, params object[] args)
        {
            for (int i=0; i < BasePlayer.activePlayerList.Count; i++)
            {
                BasePlayer player = BasePlayer.activePlayerList[i];
                player.ChatMessage(GetLang(langkey, player.UserIDString, args));
            }
        }



        private string GetDisplayName(string _shortName)
        {
            if(UseMonumentNames()) return MonumentNames.Call("GetDisplayName", _shortName) as string;
            return _shortName;
        }


        private bool UseMonumentNames()
        {           
            if(MonumentNames == null) return false;
            if(!MonumentNames.IsLoaded) return false;

            return true;
        }


        private bool UseEconomics()
        {
            if(Economics == null) return false;
            if(!Economics.IsLoaded) return false;

            return true;
        }

        private bool UseRewards()
        {
            if(ServerRewards == null) return false;
            if(!ServerRewards.IsLoaded) return false;

            return true;
        }


        //copied from DiscordLogger
        private string GetGridPosition(Vector3 position) => MapHelper.PositionToString(position); // PhoneController.PositionToGridCoord(position);


        //copied from Give
        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }


        #endregion Helpers
    

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["EconomicsAwarded"] = "${0} awarded for {1} card swipe!",
                ["PointsAwarded"] = "{0} Reward Points awarded for {1} card swipe!",
                ["ItemAwarded"] = "{0} rewarded ({1}) for {2} card swipe!",
                ["CardSwipedAtName"] = "{0} swiped a {1} card at {2} ({3})!",
                ["CardSwipedAt"] = "{0} swiped a {1} card at {3}!",
                ["GreenCardLabel"] = "green",
                ["BlueCardLabel"] = "blue",
                ["RedCardLabel"] = "red",
            }, this);
        }

        #endregion Localization
    }
}

// --- End of file: PuzzlePoints.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-report ---
// --- Original File Path: P/PlayerReport/PlayerReport.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Player Report", "hoppel", "1.0.8")]
    [Description("GUI reporting for players after being killed")]
    public class PlayerReport : RustPlugin
    {
        #region Fields

        [PluginReference]
        private Plugin DiscordMessages;

        private List<string> openUI = new List<string>();
        private HashSet<ulong> cooldowns = new HashSet<ulong>();

        private const string Permname = "playerreport.use";
        private const string Permnameblock = "playerreport.block";

        #endregion Fields

        #region Hooks/Functions

        private void Cooldownhandling(BasePlayer player)
        {
            if (cooldowns.Contains(player.userID))
                return;

            cooldowns.Add(player.userID);
            timer.Once(Cooldown, () => cooldowns.Remove(player.userID));
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            var victim = entity?.ToPlayer();
            var killer = info?.Initiator?.ToPlayer();
            if (victim == null || killer == null || killer == victim)
                return;

            if (!permission.UserHasPermission(victim.UserIDString, Permname) || permission.UserHasPermission(victim.UserIDString, Permnameblock))
                return;

            var killername = killer.displayName.Replace(" ", "_");
            var weaponName = "Unknown";
            if (info.Weapon != null)
            {
                var usedItem = info.Weapon.GetItem();
                if (usedItem != null)
                    weaponName = usedItem.info.displayName.english.Replace(" ", "_");
            }
            var distance = Mathf.Round(info.ProjectileDistance).ToString();
            if (string.IsNullOrEmpty(distance) || cooldowns.Contains(victim.userID))
                return;

            DeathReportUI(victim, killer.UserIDString, distance, killername, weaponName);
            openUI.Add(victim.UserIDString);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (player == null)
                return;

            if (openUI.Contains(player.UserIDString))
                DestroyUI(player);
        }

        private void Loaded() => storedData = new StoredData();

        private void Unload()
        {
            storedData.Save();
            foreach (var entry in openUI)
            {
                var player = BasePlayer.Find(entry);
                if (player == null)
                    continue;

                DestroyUI(player);
            }
        }

        #endregion Hooks/Functions

        #region Commands

        [ConsoleCommand("ReportHacking")]
        private void cmdReportHacking(ConsoleSystem.Arg arg)
        {
            var killer = arg.Args[0];
            var distance = arg.Args[1];
            var killername = arg.Args[2].Replace("_", " ");
            var weapon = arg.Args[3].Replace("_", " ");
            var player = arg.Player();
            if (player == null)
                return;

            if (!storedData.PlayerInformation.ContainsKey(player.UserIDString))
                storedData.PlayerInformation.Add(player.UserIDString, new ReportInfo { Reported = 0, Reports = 0 });
            if (!storedData.PlayerInformation.ContainsKey(killer))
                storedData.PlayerInformation.Add(killer, new ReportInfo { Reported = 0, Reports = 0 });
            storedData.PlayerInformation[killer].Reported++;
            storedData.PlayerInformation[player.UserIDString].Reports++;
            storedData.Save();
            if (storedData.PlayerInformation[killer].Reported < requiredReports)
            {
                DestroyUI(player);
                return;
            }

            Cooldownhandling(player);
            if (enableTickets)
                player.SendConsoleCommand("ticket create " + msg("Button1Re", null, killer, distance, killername));
            if (enableDiscordMessages)
                DiscordMessage(player.displayName, player.UserIDString, msg("DiscordButton1Field2"), killername, killer, distance, weapon, storedData.PlayerInformation[killer].Reported, storedData.PlayerInformation[killer].Reports);
            if (openUI.Contains(player.UserIDString))
                DestroyUI(player);
        }

        [ConsoleCommand("ReportGroupLimit")]
        private void cmdReportGroupLimit(ConsoleSystem.Arg arg)
        {
            var killer = arg.Args[0];
            var distance = arg.Args[1];
            var killername = arg.Args[2].Replace("_", " ");
            var weapon = arg.Args[3].Replace("_", " ");
            var player = arg.Player();
            if (player == null)
                return;

            if (!storedData.PlayerInformation.ContainsKey(player.UserIDString))
                storedData.PlayerInformation.Add(player.UserIDString, new ReportInfo { Reported = 0, Reports = 0 });
            if (!storedData.PlayerInformation.ContainsKey(killer))
                storedData.PlayerInformation.Add(killer, new ReportInfo { Reported = 0, Reports = 0 });
            storedData.PlayerInformation[killer].Reported++;
            storedData.PlayerInformation[player.UserIDString].Reports++;
            storedData.Save();
            if (storedData.PlayerInformation[killer].Reported < requiredReports)
            {
                DestroyUI(player);
                return;
            }

            Cooldownhandling(player);
            if (enableTickets)
                player.SendConsoleCommand("ticket create " + msg("Button2Re", null, killer, distance, killername));
            if (enableDiscordMessages)
                DiscordMessage(player.displayName, player.UserIDString, msg("DiscordButton2Field2"), killername, killer, distance, weapon, storedData.PlayerInformation[killer].Reported, storedData.PlayerInformation[killer].Reports);
            if (openUI.Contains(player.UserIDString))
                DestroyUI(player);
        }

        [ConsoleCommand("ReportBugAbuse")]
        private void cmdReportBugAbuse(ConsoleSystem.Arg arg)
        {
            var killer = arg.Args[0];
            var distance = arg.Args[1];
            var killername = arg.Args[2].Replace("_", " ");
            var weapon = arg.Args[3].Replace("_", " ");
            var player = arg.Player();
            if (player == null)
                return;

            if (!storedData.PlayerInformation.ContainsKey(player.UserIDString))
                storedData.PlayerInformation.Add(player.UserIDString, new ReportInfo { Reported = 0, Reports = 0 });
            if (!storedData.PlayerInformation.ContainsKey(killer))
                storedData.PlayerInformation.Add(killer, new ReportInfo { Reported = 0, Reports = 0 });
            storedData.PlayerInformation[killer].Reported++;
            storedData.PlayerInformation[player.UserIDString].Reports++;
            storedData.Save();
            if (storedData.PlayerInformation[killer].Reported < requiredReports)
            {
                DestroyUI(player);
                return;
            }

            Cooldownhandling(player);
            if (enableTickets)
                player.SendConsoleCommand("ticket create " + msg("Button3Re", null, killer, distance, killername));
            if (enableDiscordMessages)
                DiscordMessage(player.displayName, player.UserIDString, msg("DiscordButton3Field2"), killername, killer, distance, weapon, storedData.PlayerInformation[killer].Reported, storedData.PlayerInformation[killer].Reports);
            if (openUI.Contains(player.UserIDString))
                DestroyUI(player);
        }

        private void DiscordMessage(string displayName, string userId, string reportFunction, string killerName,
            string killerUserId, string distance, string weapon, int reported, int reports)
        {
            var fields = new List<Fields>();
            fields.Add(new Fields(msg("DiscordButton1FieldName1"), $"[{displayName}](https://steamcommunity.com/profiles/{userId}) ({reports})", true));
            fields.Add(new Fields(msg("DiscordButton1FieldName2"), msg(reportFunction), true));
            fields.Add(new Fields(msg("DiscordButton1FieldName3"), $"[{killerName}](https://steamcommunity.com/profiles/{killerUserId})", true));
            fields.Add(new Fields(msg("DiscordButton1FieldName6"), $"{reported}", true));
            fields.Add(new Fields(msg("DiscordButton1FieldName4"), $"{distance}m", true));
            fields.Add(new Fields(msg("DiscordButton1FieldName5"), $"{weapon}", true));
            var serializedObject = JsonConvert.SerializeObject(fields);
            DiscordMessages?.Call("API_SendFancyMessage", webhookURL, Servername, serializedObject);
            if (Alert)
                DiscordMessages?.Call("API_SendTextMessage", webhookURL, "@here");
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        #endregion Commands

        #region UI

        private void DeathReportUI(BasePlayer player, string killer, string distance, string killername, string weaponName)
        {
            var container = new CuiElementContainer();
            var ReportUI = container.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0.0",
                },
                RectTransform =
                {
                    AnchorMin = "0.25 0.861",
                    AnchorMax = "0.771 1"
                },
                CursorEnabled = false
            }, "Overlay", "ReportUI");

            if (Button1Enabled)
            {
                container.Add(new CuiButton
                {
                    Button =
                {
                Command = $"global.ReportHacking {killer} {distance} {killername} {weaponName}",
                Color = Button1Color
                },
                    RectTransform =
                {
                AnchorMin = Button1AnchMin,
                AnchorMax = Button1AnchMax
                },
                    Text =
                {
                Text = msg("Button1"),
                    FontSize = 15,
                    Align = TextAnchor.MiddleCenter
                }
                }, ReportUI);
            }

            if (Button2Enabled)
            {
                container.Add(new CuiButton
                {
                    Button =
                {
                Command = $"global.ReportGroupLimit {killer} {distance} {killername} {weaponName}",
                Color = Button2Color
                },
                    RectTransform =
                {
                AnchorMin = Button2AnchMin,
                    AnchorMax = Button2AnchMax
                },
                    Text =
                {
                Text = msg("Button2"),
                    FontSize = 15,
                    Align = TextAnchor.MiddleCenter
                }
                }, ReportUI);
            }

            if (Button3Enabled)
            {
                container.Add(new CuiButton
                {
                    Button =
                {
                Command = $"global.ReportBugAbuse {killer} {distance} {killername} {weaponName}",
                Color = Button3Color
                },
                    RectTransform =
                {
                AnchorMin = Button3AnchMin,
                    AnchorMax = Button3AnchMax
                },
                    Text =
                {
                Text = msg("Button3"),
                    FontSize = 15,
                    Align = TextAnchor.MiddleCenter
                }
                }, ReportUI);
            }

            var Text = container.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0"
                },
                RectTransform =
                {
                    AnchorMin = "0 0.028",
                    AnchorMax = "1 0.290"
                },
                CursorEnabled = false
            }, ReportUI);

            container.Add(new CuiLabel
            {
                Text =
                {
                    Text = msg("InfoMessage"),
                    FontSize = 14,
                    Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                }
            }, Text);

            CuiHelper.AddUi(player, container);
        }

        private void DestroyUI(BasePlayer player)
        {
            if (player == null)
                return;

            CuiHelper.DestroyUi(player, "ReportUI");
            CuiHelper.DestroyUi(player, "Report_Info");
            openUI.Remove(player.UserIDString);
        }

        #endregion UI

        #region Config

        private int requiredReports = 1;
        private string Servername = "Servername";
        private float Cooldown = 50;
        private string webhookURL = "DISCORD WEBHOOK URL";
        private bool Alert = true;
        private bool enableTickets = true;
        private bool enableDiscordMessages = true;
        private bool Button1Enabled = true;
        private string Button1Color = "0.41 0.5 0.25 1";
        private string Button1AnchMin = "0 0.283";
        private string Button1AnchMax = "0.25 0.75";
        private bool Button2Enabled = true;
        private string Button2Color = "0.12 0.38 0.57 1";
        private string Button2AnchMin = "0.375 0.283";
        private string Button2AnchMax = "0.625 0.75";
        private bool Button3Enabled = true;
        private string Button3Color = "0.57 0.21 0.11 1";
        private string Button3AnchMin = "0.75 0.283";
        private string Button3AnchMax = "1 0.75";

        private new void LoadConfig()
        {
            GetConfig(ref requiredReports, "Settings", "Reports needed to send a Report");
            GetConfig(ref Alert, "Settings", "Enable @here Message in Discord");
            GetConfig(ref Servername, "Settings", "Your servername (for discord messages)");
            GetConfig(ref enableTickets, "Settings", "Enable Ticket Reports");
            GetConfig(ref Cooldown, "Settings", "GUI Cooldown");
            GetConfig(ref webhookURL, "Settings", "Discord Webhook URL");
            GetConfig(ref enableDiscordMessages, "Settings", "Enable DiscordMessages");
            GetConfig(ref Button1Enabled, "Button 1", "Button 1 Enabled");
            GetConfig(ref Button1Color, "Button 1", "Button 1 Color");
            GetConfig(ref Button1AnchMin, "Button 1", "Button 1 AnchorMin");
            GetConfig(ref Button1AnchMax, "Button 1", "Button 1 AnchorMax");
            GetConfig(ref Button2Enabled, "Button 2", "Button 2 Enabled");
            GetConfig(ref Button2Color, "Button 2", "Button 2 Color");
            GetConfig(ref Button2AnchMin, "Button 2", "Button 2 AnchorMin");
            GetConfig(ref Button2AnchMax, "Button 2", "Button 2 AnchorMax");
            GetConfig(ref Button3Enabled, "Button 3", "Button 3 Enabled");
            GetConfig(ref Button3Color, "Button 3", "Button 3 Color");
            GetConfig(ref Button3AnchMin, "Button 3", "Button 3 AnchorMin");
            GetConfig(ref Button3AnchMax, "Button 3", "Button 3 AnchorMax");
            SaveConfig();
        }

        private void Init()
        {
            LoadConfig();
            permission.RegisterPermission(Permname, this);
            permission.RegisterPermission(Permnameblock, this);
        }

        private void GetConfig<T>(ref T variable, params string[] path)
        {
            if (path.Length == 0)
                return;

            if (Config.Get(path) == null)
            {
                Config.Set(path.Concat(new object[] { variable }).ToArray());
            }

            variable = (T)Convert.ChangeType(Config.Get(path), typeof(T));
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file...");

        #endregion Config

        #region Lang

        public string RemoveFormatting(string source)
        {
            return source.Contains(">") ? Regex.Replace(source, "<.*?>", string.Empty) : source;
        }

        public string msg(string key, string id = null, params object[] args)
        {
            string message = id == null ? RemoveFormatting(lang.GetMessage(key, this, id)) : lang.GetMessage(key, this, id);

            return args.Length > 0 ? string.Format(message, args) : message;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["InfoMessage"] = "Abusing this system will result in a ban!",
                ["Button1"] = "Report: Hacking ",
                ["Button2"] = "Report: Group Limit ",
                ["Button3"] = "Report: Bug Abusing ",
                ["Button1Re"] = "reported {2} ({0}) for hacking distance {1}m",
                ["Button2Re"] = "reported {2} ({0}) for exceeding the Group Limit",
                ["Button3Re"] = "reported {2} ({0}) for Bug Abusing distance {1}m",
                ["DiscordButton1FieldName1"] = "Player",
                ["DiscordButton1FieldName2"] = "Reason",
                ["DiscordButton1FieldName3"] = "Reported",
                ["DiscordButton1FieldName4"] = "Distance",
                ["DiscordButton1FieldName5"] = "Weapon",
                ["DiscordButton1FieldName6"] = "Reported",
                ["DiscordButton1FieldName7"] = "Reporter Reports",
                ["DiscordButton1Field2"] = "Hacking",
                ["DiscordButton2FieldName1"] = "Player",
                ["DiscordButton2FieldName2"] = "Reason",
                ["DiscordButton2FieldName3"] = "Reported",
                ["DiscordButton2FieldName4"] = "Distance",
                ["DiscordButton2FieldName5"] = "Weapon",
                ["DiscordButton2FieldName6"] = "Reported",
                ["DiscordButton2FieldName7"] = "Reporter Reports",
                ["DiscordButton2Field2"] = "Group Limit",
                ["DiscordButton3FieldName1"] = "Player",
                ["DiscordButton3FieldName2"] = "Reason",
                ["DiscordButton3FieldName3"] = "Reported",
                ["DiscordButton3FieldName4"] = "Distance",
                ["DiscordButton3FieldName5"] = "Weapon",
                ["DiscordButton3FieldName6"] = "Reported",
                ["DiscordButton3FieldName7"] = "Reporter Reports",
                ["DiscordButton3Field2"] = "Bug Abuse",
            }, this);
        }

        #endregion Lang

        #region Data

        private StoredData storedData;

        private class StoredData
        {
            public Dictionary<string, ReportInfo> PlayerInformation = new Dictionary<string, ReportInfo>();

            public StoredData()
            {
                Read();
            }

            public void Read() => PlayerInformation = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, ReportInfo>>("PlayerReport");

            public void Save() => Interface.Oxide.DataFileSystem.WriteObject("PlayerReport", PlayerInformation);
        }

        private class ReportInfo
        {
            public int Reports;
            public int Reported;
        }

        #endregion Data
    }
}


// --- End of file: PlayerReport.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/prefab-limit ---
// --- Original File Path: P/PrefabLimit/PrefabLimit.cs ---

using Oxide.Core;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Prefab Limit", "HoverCatz", "1.0.2")]
    [Description("Limit spawning of prefabs using percentages")]
    class PrefabLimit : RustPlugin
    {

        readonly string PluginName = "PrefabLimit";
        Dictionary<string, int> spawnChances = new Dictionary<string, int>();

        void OnServerInitialized()
        {
            ReLoadConfig();
            Puts($"Successfully initialized. Loaded {spawnChances.Count} config values.");
        }

        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject(PluginName, spawnChances);
        }

        void ReLoadConfig()
        {
            spawnChances = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, int>>(PluginName) ?? spawnChances;

            if (spawnChances == null)
                spawnChances = new Dictionary<string, int>();

            if (spawnChances.Count <= 0)
                AddDefaultConfig();

            Interface.Oxide.DataFileSystem.WriteObject(PluginName, spawnChances);
        }

        private void AddDefaultConfig()
        {
            spawnChances.Add("assets/bundled/prefabs/autospawn/resource/ores/metal-ore.prefab", 100);       // 100% chance to spawn
            spawnChances.Add("assets/bundled/prefabs/autospawn/resource/ores/stone-ore.prefab", 100);       // 100% chance to spawn
            spawnChances.Add("assets/bundled/prefabs/autospawn/resource/ores/sulfur-ore.prefab", 100);      // 100% chance to spawn
            spawnChances.Add("assets/bundled/prefabs/autospawn/resource/ores_sand/metal-ore.prefab", 100);  // 100% chance to spawn
            spawnChances.Add("assets/bundled/prefabs/autospawn/resource/ores_sand/stone-ore.prefab", 100);  // 100% chance to spawn
            spawnChances.Add("assets/bundled/prefabs/autospawn/resource/ores_sand/sulfur-ore.prefab", 100); // 100% chance to spawn
            spawnChances.Add("assets/bundled/prefabs/autospawn/resource/ores_snow/metal-ore.prefab", 100);  // 100% chance to spawn
            spawnChances.Add("assets/bundled/prefabs/autospawn/resource/ores_snow/stone-ore.prefab", 100);  // 100% chance to spawn
            spawnChances.Add("assets/bundled/prefabs/autospawn/resource/ores_snow/sulfur-ore.prefab", 100); // 100% chance to spawn

            // Add more prefabs here if you want
            // https://www.corrosionhour.com/rust-prefab-list/
        }

        [ConsoleCommand("prefablimitreload")] /* /prefabLimitReload */
        void ReloadConfigCommand(ConsoleSystem.Arg arg)
        {
            ReLoadConfig();
            arg.ReplyWith($"Successfully reloaded {spawnChances.Count} config values.");
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {

            int intChance;
            if (!spawnChances.TryGetValue(entity.name, out intChance))
                return; // Doesn't exist in our list? 100% chance to spawn

            if (intChance == 100)
                return; // 100% chance, spawn.
            else
            if (intChance == 0)
            {
                entity.AdminKill(); // Destroy the Prefab! No chance check.
                return;
            }

            float fChance = intChance / 100f;
            float rnd = UnityEngine.Random.value;

            if (rnd > fChance)
                entity.AdminKill(); // Destroy the Prefab!

        }

    }
}

// --- End of file: PrefabLimit.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-list ---
// --- Original File Path: P/PlayerList/PlayerList.cs ---

﻿/*
 * TODO:
 * Add pagination to handle large amounts of players
 * Figure out limit for showing in a single message
 */

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("PlayerList", "Wulf/lukespragg", "0.3.2", ResourceId = 2126)]
    [Description("Shows a list and count of all online, non-hidden players")]

    class PlayerList : CovalencePlugin
    {
        #region Initialization

        const string permAllow = "playerlist.allow";
        const string permHide = "playerlist.hide";

        bool adminSeparate;
        string adminColor;

        protected override void LoadDefaultConfig()
        {
            Config["Admin List Separate (true/false)"] = adminSeparate = GetConfig("Admin List Separate (true/false)", false);
            Config["Admin Color (Hex Format or Name)"] = adminColor = GetConfig("Admin Color (Hex Format or Name)", "e68c17");

            // Cleanup
            Config.Remove("SeparateAdmin");
            Config.Remove("AdminColor");

            SaveConfig();
        }

        void Init()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();
            permission.RegisterPermission(permAllow, this);
            permission.RegisterPermission(permHide, this);
        }

        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AdminCount"] = "{0} admin online",
                ["AdminList"] = "Admin online ({0}): {1}",
                ["NobodyOnline"] = "No players are currently online",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["OnlyYou"] = "You are the only one online!",
                ["PlayerCount"] = "{0} player(s) online",
                ["PlayerList"] = "Players online ({0}): {1}"
            }, this);

            // French
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AdminCount"] = "{0} administrateurs en ligne",
                ["AdminList"] = "Administrateurs en ligne ({0}) : {1}",
                ["NobodyOnline"] = "Aucuns joueurs ne sont actuellement en ligne",
                ["NotAllowed"] = "Vous n’êtes pas autorisé à utiliser la commande « {0} »",
                ["OnlyYou"] = "Vous êtes la seule personne en ligne !",
                ["PlayerCount"] = "{0} joueur(s) en ligne",
                ["PlayerList"] = "Joueurs en ligne ({0}) : {1}"
            }, this, "fr");

            // German
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AdminCount"] = "{0} Administratoren online",
                ["AdminList"] = "Administratoren online ({0}): {1}",
                ["NobodyOnline"] = "Keine Spieler sind gerade online",
                ["NotAllowed"] = "Sie sind nicht berechtigt, verwenden Sie den Befehl '{0}'",
                ["OnlyYou"] = "Du bist der einzige Online!",
                ["PlayerCount"] = "{0} Spieler online",
                ["PlayerList"] = "Spieler online ({0}): {1}"
            }, this, "de");

            // Russian
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AdminCount"] = "{0} администраторы онлайн",
                ["AdminList"] = "Администраторы онлайн ({0}): {1}",
                ["NobodyOnline"] = "Ни один из игроков онлайн",
                ["NotAllowed"] = "Нельзя использовать команду «{0}»",
                ["OnlyYou"] = "Вы являетесь единственным онлайн!",
                ["PlayerCount"] = "{0} игрока (ов) онлайн",
                ["PlayerList"] = "Игроков онлайн ({0}): {1}"
            }, this, "ru");

            // Spanish
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AdminCount"] = "{0} administradores en línea",
                ["AdminList"] = "Los administradores en línea ({0}): {1}",
                ["NobodyOnline"] = "No hay jugadores están actualmente en línea",
                ["NotAllowed"] = "No se permite utilizar el comando '{0}'",
                ["OnlyYou"] = "Usted es el único en línea!",
                ["PlayerCount"] = "{0} jugadores en línea",
                ["PlayerList"] = "Jugadores en línea ({0}): {1}"
            }, this, "es");
        }

        #endregion

        #region Commands

        [Command("online")]
        void OnlineCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAllow))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            var adminCount = players.Connected.Count(p => p.IsAdmin && !p.HasPermission(permHide));
            var playerCount = players.Connected.Count(p => !p.IsAdmin && !p.HasPermission(permHide));

            player.Reply($"{Lang("AdminCount", player.Id, adminCount)}, {Lang("PlayerCount", player.Id, playerCount)}");
        }

        [Command("players", "who")]
        void PlayersCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAllow))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            var adminCount = players.Connected.Count(p => p.IsAdmin && !p.HasPermission(permHide));
            var playerCount = players.Connected.Count(p => !p.IsAdmin && !p.HasPermission(permHide));
            var totalCount = adminCount + playerCount;

            if (totalCount == 0) player.Reply(Lang("NobodyOnline", player.Id));
            else if (totalCount == 1 && player.Id != "server_console") player.Reply(Lang("OnlyYou", player.Id));
            else
            {
                var adminList = string.Join(", ", players.Connected.Where(p => p.IsAdmin && !p.HasPermission(permHide)).Select(p => covalence.FormatText($"[#{adminColor}]{p.Name.Sanitize()}[/#]")).ToArray());
                var playerList = string.Join(", ", players.Connected.Where(p => !p.IsAdmin && !p.HasPermission(permHide)).Select(p => p.Name.Sanitize()).ToArray());

                if (adminSeparate && !string.IsNullOrEmpty(adminList)) player.Reply(Lang("AdminList", player.Id, adminCount, adminList.TrimEnd(' ').TrimEnd(',')));
                else
                {
                    playerCount = adminCount + playerCount;
                    playerList = string.Concat(adminList, ", ", playerList);
                }
                if (!string.IsNullOrEmpty(playerList)) player.Reply(Lang("PlayerList", player.Id, playerCount, playerList.TrimEnd(' ').TrimEnd(',')));
            }
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}

// --- End of file: PlayerList.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/puzzle-chain-repair ---
// --- Original File Path: P/PuzzleChainRepair/PuzzleChainRepair.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Facepunch;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("PuzzleChainRepair", "bazuka5801/Misstake", "1.1.0")]
    public class PuzzleChainRepair : RustPlugin
    {
        /*
        public void PuzzlePrefabRespawn(ConsoleSystem.Arg arg)
        {
            foreach (BaseNetworkable baseNetworkable in BaseNetworkable.serverEntities.Where<BaseNetworkable>((Func<BaseNetworkable, bool>)(x =>
            {
                if (x is IOEntity)
                    return (PrefabAttribute)PrefabAttribute.server.Find<Construction>(x.prefabID) == (PrefabAttribute)null;
                return false;
            })).ToList<BaseNetworkable>())
                baseNetworkable.Kill(BaseNetworkable.DestroyMode.None);
            foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
            {
                GameObject prefab = GameManager.server.FindPrefab(monument.gameObject.name);
                if (!((UnityEngine.Object)prefab == (UnityEngine.Object)null))
                {
                    Dictionary<IOEntity, IOEntity> dictionary = new Dictionary<IOEntity, IOEntity>();
                    foreach (IOEntity componentsInChild in prefab.GetComponentsInChildren<IOEntity>(true))
                    {
                        Quaternion rot = monument.transform.rotation * componentsInChild.transform.rotation;
                        Vector3 pos = monument.transform.TransformPoint(componentsInChild.transform.position);
                        BaseEntity newEntity = GameManager.server.CreateEntity(componentsInChild.PrefabName, pos, rot, true);
                        IOEntity ioEntity = newEntity as IOEntity;
                        if ((UnityEngine.Object)ioEntity != (UnityEngine.Object)null)
                        {
                            dictionary.Add(componentsInChild, ioEntity);
                            DoorManipulator doorManipulator = newEntity as DoorManipulator;
                            if ((UnityEngine.Object)doorManipulator != (UnityEngine.Object)null)
                            {
                                List<Door> list = Facepunch.Pool.GetList<Door>();
                                global::Vis.Entities<Door>(newEntity.transform.position, 10f, list, -1, QueryTriggerInteraction.Collide);
                                Door door = list.OrderBy<Door, float>((Func<Door, float>)(x => x.Distance(newEntity.transform.position))).FirstOrDefault<Door>();
                                if ((UnityEngine.Object)door != (UnityEngine.Object)null)
                                    doorManipulator.targetDoor = door;
                                Facepunch.Pool.FreeList<Door>(ref list);
                            }
                            CardReader cardReader1 = newEntity as CardReader;
                            if ((UnityEngine.Object)cardReader1 != (UnityEngine.Object)null)
                            {
                                CardReader cardReader2 = componentsInChild as CardReader;
                                if ((UnityEngine.Object)cardReader2 != (UnityEngine.Object)null)
                                {
                                    cardReader1.accessLevel = cardReader2.accessLevel;
                                    cardReader1.accessDuration = cardReader2.accessDuration;
                                }
                            }
                            TimerSwitch timerSwitch1 = newEntity as TimerSwitch;
                            if ((UnityEngine.Object)timerSwitch1 != (UnityEngine.Object)null)
                            {
                                TimerSwitch timerSwitch2 = componentsInChild as TimerSwitch;
                                if ((UnityEngine.Object)timerSwitch2 != (UnityEngine.Object)null)
                                    timerSwitch1.timerLength = timerSwitch2.timerLength;
                            }
                        }
                    }
                    foreach (KeyValuePair<IOEntity, IOEntity> keyValuePair in dictionary)
                    {
                        IOEntity key = keyValuePair.Key;
                        IOEntity ioEntity = keyValuePair.Value;
                        for (int index = 0; index < key.outputs.Length; ++index)
                        {
                            if (!((UnityEngine.Object)key.outputs[index].connectedTo.ioEnt == (UnityEngine.Object)null))
                            {
                                ioEntity.outputs[index].connectedTo.ioEnt = dictionary[key.outputs[index].connectedTo.ioEnt];
                                ioEntity.outputs[index].connectedToSlot = key.outputs[index].connectedToSlot;
                            }
                        }
                    }
                    foreach (BaseNetworkable baseNetworkable in dictionary.Values)
                        baseNetworkable.Spawn();
                }
            }
        }*/

        [ConsoleCommand("puzzlerepair")]
        void cmdPuzzleFix(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                SendReply(arg, "NotAllowed");
                return;
            }

            Server.Command("debug.puzzleprefabrespawn");
        }
    }
}

// --- End of file: PuzzleChainRepair.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-activity ---
// --- Original File Path: P/PlayerActivity/PlayerActivity.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Libraries;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins {
  [Info("Player Activity", "RayMods", "0.3.2")]
  [Description("A plugin API for player's total and session play time, AFK time, and connection times.")]
  class PlayerActivity : CovalencePlugin {
    private Dictionary<string, ActivityData> _activityDataCache = new Dictionary<string, ActivityData>();
    private Dictionary<string, SessionData> _playerSessions = new Dictionary<string, SessionData>();
    private Dictionary<string, Timer> _playerTimers = new Dictionary<string, Timer>();
    private Dictionary<string, PlayerLocation> _playerLoc = new Dictionary<string, PlayerLocation>();
    private DynamicConfigFile _playerData;
    private PluginConfig _config;
    private Timer _saveTimer;


    #region Hooks

    private void Init() {
      _playerData = Interface.Oxide.DataFileSystem.GetFile("PlayerActivity");
    }

    private void OnServerInitialized() {
      Puts(_config.SAVE_INTERVAL.ToString());
      _saveTimer = timer.Repeat(_config.SAVE_INTERVAL, 0, SaveActivityData);
    }
    
    private void OnUserConnected(IPlayer player) {
      InitPlayer(player);
      _activityDataCache[player.Id].LastConnection = DateTime.UtcNow;
    }

    private void OnUserDisconnected(IPlayer player) {
      _playerSessions.Remove(player.Id);
      _playerTimers[player.Id].Destroy();
      _playerTimers.Remove(player.Id);
    }

    private void Loaded() {
      BootstrapPlayerData();
      foreach (IPlayer player in players.Connected) {
        InitPlayer(player);
      }
    }

    private void Unload() {
      _saveTimer.Destroy();
      foreach (Timer playerTimer in _playerTimers.Values) {
        playerTimer.Destroy();
      }
      foreach (IPlayer player in players.Connected) {
        UpdatePlayerSession(player);
      }
      SaveActivityData();

      _playerTimers.Clear();
      _playerSessions.Clear();
      _activityDataCache.Clear();
    }

    protected override void LoadConfig() {
      base.LoadConfig();
      try {
        _config = Config.ReadObject<PluginConfig>();
      } catch {
        PrintWarning("Configuration file is invalid, reverting to defaul.t");
        LoadDefaultConfig();
      }
    }

    protected override void LoadDefaultConfig() {
      Config.WriteObject(GetDefaultConfig(), true);
    }

    #endregion


    #region DataMgmt

    private void InitPlayer(IPlayer player) {
      InitCache(player);
      InitSession(player);

      Timer playerTimer = timer.Repeat(_config.STATUS_CHECK_INTERVAL, 0, () => UpdatePlayerSession(player));
      _playerTimers.Add(player.Id, playerTimer);
    }

    private void InitSession(IPlayer player) {
       if (!_playerSessions.ContainsKey(player.Id)) {
        _playerSessions.Add(player.Id, new SessionData {
          PlayTime = 0,
          IdleTime = 0,
          ConnectionTime = DateTime.UtcNow,
          LastUpdateTime = DateTime.UtcNow
        });
      }
    }

    private void InitCache(IPlayer player) {
      if (!_activityDataCache.ContainsKey(player.Id)) {
        _activityDataCache.Add(player.Id, new ActivityData {
          FirstConnection = DateTime.UtcNow,
          IdleTime = 0,
          LastConnection = DateTime.UtcNow,
          PlayTime = 0
        });
      }
    }

    private void BootstrapPlayerData() {
      RawActivityData rawData = _playerData.ReadObject<RawActivityData>();
      _activityDataCache = rawData.PlayerActivityData;
    }

    private void SaveActivityData() {
      RawActivityData rawDataForSave = new RawActivityData {
        PlayerActivityData = _activityDataCache,
      };
      _playerData.WriteObject(rawDataForSave);
    }

    private bool IsAfk(IPlayer player) {
      UpdatePosition(player);
      double timeSinceMoved = DateTime.UtcNow.Subtract(_playerLoc[player.Id].LastMoved).TotalSeconds;
      return timeSinceMoved > _config.AFK_TIMEOUT;
    }

    private void UpdatePosition(IPlayer player) {
      if (!_playerLoc.ContainsKey(player.Id)) {
        _playerLoc.Add(player.Id, new PlayerLocation {
          Location = player.Position(),
          LastMoved = DateTime.UtcNow
        });
      } else {
        GenericPosition currentLoc = player.Position();
        bool hasMoved = !currentLoc.Equals(_playerLoc[player.Id].Location);
        if (hasMoved) {
          _playerLoc[player.Id] = new PlayerLocation {
            Location = player.Position(),
            LastMoved = DateTime.UtcNow
          };
        }
      }
    }

    private void UpdatePlayerSession(IPlayer player) {
      bool isAfk = player.IsConnected && IsAfk(player);
      DateTime lastUpdate = _playerSessions[player.Id].LastUpdateTime;
      double secondsSinceLastUpdate = DateTime.UtcNow.Subtract(lastUpdate).TotalSeconds;

      if (isAfk) {
        _activityDataCache[player.Id].IdleTime += secondsSinceLastUpdate;
        _playerSessions[player.Id].IdleTime += secondsSinceLastUpdate;
      } else {
        _activityDataCache[player.Id].PlayTime += secondsSinceLastUpdate;
        _playerSessions[player.Id].PlayTime += secondsSinceLastUpdate;
      }
      _playerSessions[player.Id].LastUpdateTime = DateTime.UtcNow;
    }

    #endregion


    #region API

    private Nullable<DateTime> GetFirstConnectionDate(string playerId) {
      if (_activityDataCache.ContainsKey(playerId)) {
        return _activityDataCache[playerId].FirstConnection;
      }
      return null;
    }

    private Nullable<DateTime> GetLastConnectionDate(string playerId) {
      if (_activityDataCache.ContainsKey(playerId)) {
        return _activityDataCache[playerId].LastConnection;
      };
      return null;
    }

    private Nullable<double> GetTotalPlayTime(string playerId) {
      if (_activityDataCache.ContainsKey(playerId)) {
        return _activityDataCache[playerId].PlayTime;
      }
      return null;
    }

    private Nullable<double> GetTotalIdleTime(string playerId) {
      if (_activityDataCache.ContainsKey(playerId)) {
        return _activityDataCache[playerId].IdleTime;
      }
      return null;
    }

    private Nullable<double> GetSessionPlayTime(string playerId) {
      if (_playerSessions.ContainsKey(playerId)) {
        return _playerSessions[playerId].PlayTime;
      }
      return null;
    }

    private Nullable<double> GetSessionIdleTime(string playerId) {
      if (_playerSessions.ContainsKey(playerId)) {
        return _playerSessions[playerId].IdleTime;
      }
      return null;
    }

    private Nullable<DateTime> GetSessionStartTime(string playerId) {
      if (_playerSessions.ContainsKey(playerId)) {
        return _playerSessions[playerId].ConnectionTime;
      }
      return null;
    }

    private bool GetIsAfk(string playerId) {
      IPlayer player = players.FindPlayerById(playerId);
      if (player.IsConnected) {
        return IsAfk(player);
      }
      return false;
    }

    #endregion


    #region Utilities

    private PluginConfig GetDefaultConfig() {
      return new PluginConfig {
        AFK_TIMEOUT = 300,
        SAVE_INTERVAL = 900,
        STATUS_CHECK_INTERVAL = 60
      };
    }

    #endregion


    private class PluginConfig {
      public int AFK_TIMEOUT;
      public int SAVE_INTERVAL;
      public int STATUS_CHECK_INTERVAL;
    }

    private class RawActivityData {
      public Dictionary<string, ActivityData> PlayerActivityData = new Dictionary<string, ActivityData>();
    }

    private class ActivityData {
      public double PlayTime;
      public double IdleTime;
      public DateTime FirstConnection;
      public DateTime LastConnection;
    }

    private class SessionData {
      public double PlayTime;
      public double IdleTime;
      public DateTime ConnectionTime;
      public DateTime LastUpdateTime;
    }

    private class PlayerLocation {
      public GenericPosition Location;
      public DateTime LastMoved;
    }
  }
}


// --- End of file: PlayerActivity.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/punish-friendly-fire ---
// --- Original File Path: P/PunishFF/PunishFF.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;

// Requires: FriendlyFire

namespace Oxide.Plugins
{
    [Info("Punish Friendly Fire", "collect_vood", "1.2.1")]
    [Description("Punish player by X% of the damage done to friends.")]

/*======================================================================================================================= 
*
*   
*   17th november 2018
*
*	THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
*
*
*********************************************
*   Original author :   Vliek on versions <1.1.0
*   Maintainer(s)   :   BuzZ 20181116 from v1.1.0
                        collect_vood since 20190926 from v1.2.0
*********************************************   
*=======================================================================================================================*/

    public class PunishFF : CovalencePlugin
    {
        [PluginReference]
        private Plugin FriendlyFire;

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                { "PunishFriendlyFire", "Friendly fire punishment damage: {0}" },
            }, this);
        }
        #endregion

        #region Config     
        
        private ConfigurationFile Configuration;

        private class ConfigurationFile
        {    
            [JsonProperty(PropertyName = "Percentage of damage to punish")]
            public int PercentagePunish = 50;
            [JsonProperty(PropertyName = "Only punish damage on players with permission")]
            public bool OnlyPunishPermission = false;
            [JsonProperty(PropertyName = "Give damage permission")]
            public string GivePermission = "punishff.give";
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Configuration = new ConfigurationFile();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigurationFile>();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration);

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(Configuration.GivePermission, this);
        }

        private void OnFriendAttacked(IPlayer attacker, IPlayer victim, HitInfo info)
        {
            //So damage is correct (armor values etc applied)
            NextTick(() =>
            {
                if (attacker == null || victim == null || info == null) return;

                float amount = info.damageTypes.Total();
                float scale = Configuration.PercentagePunish / 100f;
                float dmgAmount = amount * scale;
                if (!Configuration.OnlyPunishPermission)
                {
                    attacker.Hurt(dmgAmount);
                    attacker.Reply(GetMessage("PunishFriendlyFire", attacker, dmgAmount.ToString()));
                }
                else
                {
                    if (!HasPermission(victim)) return;
                    attacker.Hurt(dmgAmount);
                    attacker.Reply(GetMessage("PunishFriendlyFire", attacker, dmgAmount.ToString()));
                }
            });
        }

        #endregion

        #region Helpers

        private string GetMessage(string key, IPlayer player, params string[] args) => String.Format(lang.GetMessage(key, this, player.Id), args);

        private bool HasPermission(IPlayer player) => permission.UserHasPermission(player.Id, Configuration.GivePermission);

        #endregion
    }
}

// --- End of file: PunishFF.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-tracker ---
// --- Original File Path: P/PlayerTracker/PlayerTracker.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("PlayerTracker", "redBDGR", "1.0.1", ResourceId = 2584)]
    [Description("Easily track the movements of players")]

    class PlayerTracker : RustPlugin
    {
        private static PlayerTracker plugin;
        private bool Changed;

        private float intervalTime = 1f;
        private float drawLength = 120f;
        private bool clearPositionsOnCheck = true;
        private bool trackAllPlayers;
        private float startDeleteTime = 600f;

        // Arrows
        private float arrowHead = 0.5f;

        private const string permissionName = "playertracker.admin";

        private void Init()
        {
            plugin = this;
            LoadVariables();
            permission.RegisterPermission(permissionName, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                //chat
                ["No Permission"] = "You are not allowed to use this command",
                ["Invalid Syntax"] = "Invalid Syntax! /track <start | stop | show> <playername | id> <length>",
                ["Starttrack Invalid Syntax"] = "Invalid Syntax! /starttrack <playername | id>",
                ["Tracker Started"] = "You have started tracking {0}",
                ["Tracker Stopped"] = "You have stopped tracking {0}",
                ["Not Being Tracked"] = "This player is not currently being tracked",
                ["No Player Found"] = "No players were found with this name/id",
                ["Already Being Tracked"] = "This player is already being tacked",
            }, this);

            if (!trackAllPlayers) return;
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                Tracker tracker = player.GetComponent<Tracker>();
                if (tracker)
                    return;
                player.gameObject.AddComponent<Tracker>();
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        void LoadVariables()
        {
            // General Settings
            intervalTime = Convert.ToSingle(GetConfig("Settings", "Position Interval Time", 2f));
            trackAllPlayers = Convert.ToBoolean(GetConfig("Settings", "Track All Players", false)); // Can cause lag on larger servers, especially when viewing a players locations
            startDeleteTime = Convert.ToSingle(GetConfig("Settings", "Remove Entries after x seconds", 600f)); // Can help reduce lag by shrinking list sizes

            // Arrow Settings
            arrowHead = Convert.ToSingle(GetConfig("Arrow Settings", "Arrow Head Size", 0.5f));
            drawLength = Convert.ToSingle(GetConfig("Arrow Settings", "Default Display Length", 120f));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                Tracker tracker = player.GetComponent<Tracker>();
                if (tracker)
                    UnityEngine.Object.Destroy(tracker);
                return;
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!trackAllPlayers) return;
            Tracker tracker = player.GetComponent<Tracker>();
            if (!tracker)
                player.gameObject.AddComponent<Tracker>();
        }

        [ChatCommand("track")]
        private void TrackCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
            {
                player.ChatMessage(msg("No Permission", player.UserIDString));
                return;
            }
            switch (args.Length)
            {
                case 0:
                {
                    player.ChatMessage(msg("Invalid Syntax", player.UserIDString));
                    return;
                }
                case 1:
                {
                    player.ChatMessage(msg("Invalid Syntax", player.UserIDString));
                    break;
                }
                case 2:
                {
                    BasePlayer target = BasePlayer.Find(args[1]);
                    if (target == null)
                    {
                        player.ChatMessage(msg("No Player Found", player.UserIDString));
                        return;
                    }
                    switch (args[0])
                    {
                        case "start":
                        {
                            Tracker tracker = target.GetComponent<Tracker>();
                            if (!tracker)
                            {
                                target.gameObject.AddComponent<Tracker>();
                                player.ChatMessage(string.Format(msg("Tracker Started", player.UserIDString), target.displayName));
                            }
                            break;
                        }
                        case "stop":
                        {
                            Tracker tracker = target.GetComponent<Tracker>();
                            if (tracker)
                            {
                                UnityEngine.Object.Destroy(tracker);
                                player.ChatMessage(string.Format(msg("Tracker Stopped", player.UserIDString), target.displayName));
                                return;
                            }
                            player.ChatMessage(msg("Not Being Tracked", player.UserIDString));
                            break;
                        }
                        case "show":
                        {
                            Tracker tracker = target.GetComponent<Tracker>();
                            if (!tracker)
                            {
                                player.ChatMessage(msg("Not Being Tracked", player.UserIDString));
                                return;
                            }
                            for (int i = 0; i < tracker.locationList.Count - 1; i++)
                                DoDraws(player, drawLength, tracker.locationList[i], tracker.locationList[i + 1]);
                            if (clearPositionsOnCheck)
                                tracker.locationList.Clear();
                            break;
                        }
                        default:
                        {
                            player.ChatMessage(msg("Invalid Syntax", player.UserIDString));
                            return;
                        }
                    }
                    break;
                    }
                case 3:
                {
                    BasePlayer target = BasePlayer.Find(args[1]);
                    if (target == null)
                    {
                        player.ChatMessage(msg("No Player Found", player.UserIDString));
                        return;
                    }
                    switch (args[0])
                    {
                        case "start":
                        {
                            Tracker tracker = target.GetComponent<Tracker>();
                            if (!tracker)
                            {
                                target.gameObject.AddComponent<Tracker>();
                                player.ChatMessage(msg("Tracker Started", player.UserIDString));
                            }
                        }
                            break;
                        case "stop":
                        {
                            Tracker tracker = target.GetComponent<Tracker>();
                            if (tracker)
                            {
                                UnityEngine.Object.Destroy(tracker);
                                player.ChatMessage(string.Format(msg("Tracker Stopped", player.UserIDString), target.displayName));
                                return;
                            }
                            player.ChatMessage(msg("Not Being Tracked", player.UserIDString));
                        }
                            break;
                        case "show":
                        {
                            Tracker tracker = target.GetComponent<Tracker>();
                            if (!tracker)
                            {
                                player.ChatMessage(msg("Not Being Tracked", player.UserIDString));
                                return;
                            }
                            for (int i = 0; i < tracker.locationList.Count - 1; i++)
                                DoDraws(player, Convert.ToSingle(args[1]), tracker.locationList[i], tracker.locationList[i + 1]);
                            if (clearPositionsOnCheck)
                                tracker.locationList.Clear();
                        }
                            break;
                        default:
                        {
                            player.ChatMessage(msg("Invalid Syntax", player.UserIDString));
                            return;
                        }
                    }
                    break;
                }
                default:
                {
                    player.ChatMessage(msg("No Player Found", player.UserIDString));
                    return;
                }
            }
        }

        private class Tracker : MonoBehaviour
        {
            private BasePlayer player;
            private float nextTime;
            private readonly float intervalTime = plugin.intervalTime;
            public List<Vector3> locationList = new List<Vector3>();
            private float startDeleteTime;
            private Vector3 lastPos;

            private void Awake()
            {
                player = gameObject.GetComponent<BasePlayer>();
                lastPos = player.transform.position;
                if (plugin.startDeleteTime == 0)
                    startDeleteTime = Mathf.Infinity;
                else
                    startDeleteTime = Time.time + plugin.startDeleteTime;
            }

            private void Update()
            {
                if (Time.time < nextTime) return;
                if (locationList.Count > 0)
                {
                    if (Vector3.Distance(lastPos, player.transform.position) < 1f)
                        return;
                }
                lastPos = player.transform.position;
                locationList.Add(player.transform.position + new Vector3(0f, 0.6f, 0f));
                nextTime = Time.time + intervalTime;
                if (!(Time.time > startDeleteTime)) return;
                locationList.Remove(locationList[0]);
            }
        }

        private void DoDraws(BasePlayer player, float length, Vector3 pos1, Vector3 pos2)
        {
            if (player.IsAdmin)
            {
                player.SendConsoleCommand("ddraw.arrow", length, Color.red, pos1, pos2, arrowHead);
            }
            else
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                player.SendNetworkUpdateImmediate();
                player.SendConsoleCommand("ddraw.arrow", length, Color.red, pos1, pos2, arrowHead);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                player.SendNetworkUpdateImmediate();
            }
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (data.TryGetValue(datavalue, out value)) return value;
            value = defaultValue;
            data[datavalue] = value;
            Changed = true;
            return value;
        }

        string msg(string key, string id = null) => lang.GetMessage(key, this, id);
    }
}

// --- End of file: PlayerTracker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/premium-quarry ---
// --- Original File Path: P/PremiumQuarry/PremiumQuarry.cs ---

﻿using System.Collections.Generic;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Premium Quarry", "Mevent", "1.0.1")]
    [Description("Use of quarries by permission")]
    public class PremiumQuarry : CovalencePlugin
    {
        #region Fields

        [PluginReference] private Plugin UINotify;
        
        private const string Permission = "premiumquarry.use";

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(Permission, this);
        }
        
        private void OnQuarryToggled(MiningQuarry quarry, BasePlayer player)
        {
            if (quarry == null || player == null || player.IPlayer.HasPermission(Permission)) return;
            
            quarry.SetOn(!quarry.IsOn());
            
            SendNotify(player, NoPermission, 1);
        }

        #endregion

        #region Lang

        private const string
            NoPermission = "NoPermission";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [NoPermission] = "You can't use the quarry, you don't have permission!"
            }, this);
        }
        
        private string Msg(BasePlayer player, string key, params object[] obj)
        {
            return string.Format(lang.GetMessage(key, this, player.UserIDString), obj);
        }

        private void Reply(BasePlayer player, string key, params object[] obj)
        {
            player.ChatMessage(Msg(player, key, obj));
        }

        private void SendNotify(BasePlayer player, string key, int type, params object[] obj)
        {
            if (UINotify)
                UINotify?.Call("SendNotify", player, type, Msg(player, key, obj));
            else
                Reply(player, key, obj);
        }

        #endregion
    }
}

// --- End of file: PremiumQuarry.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-entity-remover ---
// --- Original File Path: P/PlayerEntityRemover/PlayerEntityRemover.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;


namespace Oxide.Plugins
{

    [Info("Player Entity Remover", "Zeeuss", "0.1.6")]
    [Description("Removes certain player's entities")]
    public class PlayerEntityRemover : CovalencePlugin
    {

        #region Initialization
        const string entRemoveUse = "playerentityremover.use";
        const string entRemoveBypass = "playerentityremover.bypass";

        void Init()
        {
            permission.RegisterPermission(entRemoveUse, this);
            permission.RegisterPermission(entRemoveBypass, this);
            if (!LoadConfigVariables())
            {
                return;
            }

        }

        void Loaded()
        {
            if(configData.removeOnBan != true)
            {
                Unsubscribe("OnPlayerBanned");
            }
            else
            {
                Subscribe("OnPlayerBanned");
            }

            if(configData.removeOnDeath != true)
            {
                Unsubscribe("OnPlayerDeath");
            }
            else
            {
                Subscribe("OnPlayerDeath");
            }
        }
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                //FORMAT: {0} = playerName, {1} = number of removed entities
                ["NoPerms"] = "You don't have permission to use this command!",
                ["Syntax"] = "Syntax: /entremove playerName",
                ["NoPlayer"] = "Player not found!",
                ["RemoveMessage"] = "Removing {0}'s entities...({1})",
                ["NoEnts"] = "No entities found for this player."

            }, this);
        }
        #endregion

        #region Command
        [Command("entremove")]
        private void entityRemoveCmnd(IPlayer player, string command, string[] args)
        {

            if(!player.HasPermission(entRemoveUse))
            {
                player.Message(String.Format(lang.GetMessage("NoPerms", this, player.Id)));
                return;
            }

            if(args.Length < 1)
            {
                player.Message(String.Format(lang.GetMessage("Syntax", this, player.Id)));
                return;
            }

            var target = players.FindPlayer(args[0]);
            if(target == null)
            {
                player.Message(String.Format(lang.GetMessage("NoPlayer", this, player.Id)));
                return;
            }

            List<BaseEntity> ents = new List<BaseEntity>();

            foreach (var ent in BaseNetworkable.serverEntities)
            {
                BaseEntity entity = ent as BaseEntity;

                if (entity == null || entity.OwnerID.ToString() != target.Id)
                {
                    continue;
                }

                ents.Add(entity);

            }
            
            if(ents.Count <= 0)
            {
                player.Message(lang.GetMessage("NoEnts", this, player.Id));
                return;
            }
            // Thanks to nivex  for teaching me new things
            ServerMgr.Instance.StartCoroutine(KillEntities(ents));

            player.Message(String.Format(lang.GetMessage("RemoveMessage", this, player.Id), target.Name, ents.Count));

        }
        #endregion

        #region Hooks
        void OnPlayerBanned(string name, ulong id, string address, string reason)
        {
            if (permission.UserHasPermission(id.ToString(), entRemoveBypass))
                return;

            List<BaseEntity> ents = new List<BaseEntity>();

            foreach (var ent in BaseNetworkable.serverEntities)
            {
                BaseEntity entity = ent as BaseEntity;

                if (entity == null || entity.OwnerID.ToString() != id.ToString())
                {
                    continue;
                }

                ents.Add(entity);

            }

            if (ents.Count <= 0)
            {
                return;
            }
            ServerMgr.Instance.StartCoroutine(KillEntities(ents));


        }

        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (permission.UserHasPermission(player.UserIDString, entRemoveBypass))
                return;

            List<BaseEntity> ents = new List<BaseEntity>();

            foreach (var ent in BaseNetworkable.serverEntities)
            {
                BaseEntity entity = ent as BaseEntity;

                if (entity == null || entity.OwnerID.ToString() != player.UserIDString)
                {
                    continue;
                }

                ents.Add(entity);

            }

            if (ents.Count <= 0)
            {
                return;
            }
            ServerMgr.Instance.StartCoroutine(KillEntities(ents));

        }

        #endregion

        #region Config
        private ConfigData configData;
        class ConfigData
        {

            [JsonProperty(PropertyName = "Remove player's entities if banned")]
            public bool removeOnBan = false;

            [JsonProperty(PropertyName = "Remove player's entities on death")]
            public bool removeOnDeath = false;

        }

        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConfig(configData);
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData();
            SaveConfig(configData);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        #endregion

        #region Helpers
        IEnumerator KillEntities(List<BaseEntity> entities)
        {
            var checks = 0;
            var instruction = CoroutineEx.waitForSeconds(0.025f);
            foreach (var entity in entities)
            {
                if (++checks % 100 == 0) yield return instruction;
                if (entity == null || entity.IsDestroyed) continue;
                entity.Kill();

            }

        }
        #endregion

    }

}

// --- End of file: PlayerEntityRemover.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pirate-insults ---
// --- Original File Path: P/PirateInsults/PirateInsults.cs ---

using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;
using Newtonsoft.Json.Linq;

namespace Oxide.Plugins
{
    [Info("PirateInsults", "Baron Von Finchus", "1.0.5")]
    [Description("Send insults to yourself or other players.")]

    class PirateInsults : CovalencePlugin
    {
        void Init()
        {
            SetupLanguage();
            permission.RegisterPermission("pirateinsults.use", this);
        }

        void SetupLanguage()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You do not have permission to use this command.",
                ["InvalidSyntax"] = "Invalid syntax. Syntax: /insult [me|playername].",
                ["NoPlayersFound"] = "No players were found with that name.",
                ["MultiplePlayersFound"] = "Multiple players were found with that name.",
                ["WebRequestFailed"] = "WebRequest to {0} failed!",
                ["YouInsultedYourself"] = "[PirateInsult:] Ye burned yer own jolly roger by mumbling t' yourself:\n<color=yellow>{0}</color>",
                ["YouInsultedPlayer"] = "[PirateInsult:] Ye shouted <color=yellow>{1}</color> at <color=yellow>{0}</color>, the scurvy dog will rue the day they crossed ye!",
                ["PlayerInsultedYou"] = "[PirateInsult:] Avast! <color=yellow>{0}</color> fired a shot accross yer bow by shouting:\n<color=yellow>{1}</color>"
            }, this, "en");
        }

        [Command("pirateinsult")]
        void cmdInsult(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("pirateinsults.use"))
            {
                player.Reply(lang.GetMessage("NoPermission", this, player.Id));
                return;
            }

            if (args == null || args.Length == 0)
            {
                player.Reply(lang.GetMessage("InvalidSyntax", this, player.Id));
                return;
            }

            IPlayer targetPlayer;

            if (args[0] == "me")
                targetPlayer = player;
            else
            {
                IEnumerable<IPlayer> targetList = players.FindPlayers(args[0]);

                if (targetList.Count() < 1)
                {
                    player.Reply(lang.GetMessage("NoPlayersFound", this, player.Id));
                    return;
                }

                if (targetList.Count() > 1)
                {
                    player.Reply(lang.GetMessage("MultiplePlayersFound", this, player.Id));
                    return;
                }

                targetPlayer = players.FindPlayer(args[0]);
            }

            string insultURL = "https://pirate.monkeyness.com/api/insult";
            webrequest.Enqueue(insultURL, null, (code, response) =>
            {

                if (code != 200 || response == null)
                {
                    player.Reply(string.Format(lang.GetMessage("WebRequestFailed", this, player.Id), insultURL));
                    return;
                }

                //JObject joResponse = JObject.Parse(response);                   
                //var returnedinsult = joResponse["insult"];
                if (targetPlayer == player)
                {
                    player.Reply(string.Format(lang.GetMessage("YouInsultedYourself", this, player.Id), response));
                    return;
                }

                player.Reply(string.Format(lang.GetMessage("YouInsultedPlayer", this, player.Id), targetPlayer.Name, response));
                targetPlayer.Reply(string.Format(lang.GetMessage("PlayerInsultedYou", this, targetPlayer.Id), player.Name, response));


            }, this);

        }
    }
}

// --- End of file: PirateInsults.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/public-quarry-lock ---
// --- Original File Path: P/PublicQuarryLock/PublicQuarryLock.cs ---

﻿#define _DEBUG
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Networking;
using Oxide.Core.Libraries.Covalence;
using System.Text;
using Facepunch;

//
// rev 1.0.0
//    Initial release
// rev 1.0.1
//    Fix plugin Info not properly formatted
// rev 1.0.2
//    Fix plugin Info not properly formatted
//    cleanup messsage log
// rev 1.0.4
//    bug fix relatuve to player quarry
// rev 1.0.5
//    bug fix relatuve to player quarry
// rev 1.0.6
//    Unlock quarry when player / team / clan goes offline for too long
//    bug fix relative to player quarry
// rev 1.0.7
//    bug fix relative to Clear quarry lock when going offline
// rev 1.0.8
//    log quarry location
// rev 1.0.9
//    Bug fix related to cooldown and /quarry command
// rev 1.0.10
//    Bug fix related to cooldown
// rev 1.0.11
//    separate permission for quarry and pumpjack usage 
//    fix Lang for "MiningQuarry" and "Pumpjack" not translating for broadcast
//    add loot qty to message when looting
// rev 1.0.11
//    correction to lang file
// rev 1.0.15
//    bug fix where some parameter affected player deployed quarrys
//    Option to support clan table 


namespace Oxide.Plugins
{
    [Info("Public Quarry Lock", "Lorenzo", "1.0.29")]
    [Description("Lock public Quarry and pumpjack to a player/team/clan when it run")]
    class PublicQuarryLock : CovalencePlugin
    {
        [PluginReference] private Plugin Clans;
        [PluginReference] private Plugin ZoneManager;
        [PluginReference] private Plugin DynamicPVP;
        [PluginReference] private Plugin Notify;

        #region Variables

        private static PublicQuarryLock _instance =null;
        private static DiscordComponent _discord = null;

        private const string PREFAB_ITEM_DROP = "assets/prefabs/misc/item drop/item_drop.prefab";
        private readonly Vector3 DropVect = new Vector3(0f, 1f, 2f);

        string TraceFile = "Trace";     // file name in log directory

        private const string ReadableNameQuarry = "Mining Quarry";
        private const string ReadableNamePump = "Pump Jack";

        private const uint FuelStoragePumpID  = 4260630588;
        private const uint OutputHopperPumpID = 70163214;

        private const uint FuelStorageQuarryID  = 362963830;
        private const uint OutputHopperQuarryID = 875142383;

        private int QuarryDefaultDieselStack = 0;
        private int QuarryDefaultFuelCapacity = 6;
        private int QuarryDefaultHopperSlots = 18;

        private int PumpDefaultDieselStack = 0;
        private int PumpDefaultFuelCapacity = 6;
        private int PumpDefaultHopperSlots = 18;

        private float workPerFuelRestore = -1;
        private float workToAddRestore = -1;
        private float processRateRestore = -1;

#if CARBON
        const char Platform = 'C';
#else
        const char Platform = 'O';
#endif

        #endregion

#region Configuration

    private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Use permission")]
            public bool UsePermission = false;      // use permission or grant access to every players

            [JsonProperty(PropertyName = "PermissionAdmin")]
            public string PermissionAdmin = "publicquarrylock.admin";   // name of permission

            [JsonProperty(PropertyName = "Permission for quarry only")]
            public string PermissionUseQuarry = "publicquarrylock.quarryonly";   // name of permission

            [JsonProperty(PropertyName = "Permission for pumpjack only")]
            public string PermissionUsePump = "publicquarrylock.pumpjackonly";   // name of permission

            [JsonProperty(PropertyName = "Permission bypass global cooldown")]
            public string PermissionBypassCooldown = "publicquarrylock.bypassglobalcooldown";
			
            [JsonProperty(PropertyName = "Allow access to quarry without permission (will not lock)")]
            public bool UseQuarryWithoutPermission = false;			
                                                                                  
            [JsonProperty(PropertyName = "Enable for mining quarry")]
            public bool enableMiningQuarry = true;

            [JsonProperty(PropertyName = "Enable for pump jack")]
            public bool enablePumpJack = true;

            [JsonProperty(PropertyName = "Enable player quarry")]
            public bool enablePlayerQuarry = false;

            [JsonProperty(PropertyName = "Enable player pumpjack")]
            public bool enablePlayerPump = false;

            [JsonProperty(PropertyName = "CoolDown before releasing mining quarry (min)")]
            public float CoolDown = 5;      // 5 minute cooldown after quarry finish and anybody can loot

            [JsonProperty(PropertyName = "Send quarry available message to all")]
            public bool MessageAll = true;

            [JsonProperty(PropertyName = "Enable engine loot after it is started, to add fuel")]
            public bool engineloot = true;

            // In case clans pluginis installed but you dont want to use it with this plugin
            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams = true;

            // In case clans pluginis installed but you dont want to use it with this plugin
            [JsonProperty(PropertyName = "Use Clans plugin")]
            public bool UseClans = false;

            [JsonProperty(PropertyName = "Use clan table")]
            public bool UseClanTable = false;

            // option to use the dynamicPVP plugin to exclude quarrys
            [JsonProperty(PropertyName = "Use DynamicPVP to disable lock in PVP zones")]
            public bool UseDynamicPVP = false;

            [JsonProperty(PropertyName = "CoolDown in min. before a player or team can restart the quarry (0 is disabled)")]
            public float PlayerCoolDown = 30;      // 60 minute cooldown after quarry finish and anybody can loot

            [JsonIgnore]
            public float _PlayerCoolDown = 30;      // internal value

            [JsonProperty(PropertyName = "Usage cooldown to all quarry")]
            public bool CoolDownGlobal = true;      // 60 minute cooldown after quarry finish and anybody can loot
		
            [JsonProperty(PropertyName = "Maximum stack size for diesel engine (-1 to disable function)")]
            public int DieselFuelMaxStackSize = -1;

            [JsonProperty(PropertyName = "Number of slots for diesel storage (-1 to disable function)")]
            public int FuelSlots = -1;

            [JsonProperty(PropertyName = "Number of slots for output storage (-1 to disable function)")]
            public int HopperSlots = -1;

            [JsonProperty(PropertyName = "Time per barrel of diesel in second (-1 to disable function, default time 125 sec)")]
            public int TimePerBarrel = -1;

            [JsonProperty(PropertyName = "quarry chat command")]
            public string  quarryquerry = "quarry";

            [JsonProperty(PropertyName = "Quarry clear status")]
            public string quarryclearstatus = "quarryclear";

            [JsonProperty(PropertyName = "Quarry stop command")]
            public string quarrystopcommand = "quarrystop";

            [JsonProperty(PropertyName = "Empty the output hopper when quarry/pumpjack start")]
            public bool FlushOutputHopper = false;

            [JsonProperty(PropertyName = "Clear quarry lock after all player from team/clan disconnect")]
            public bool ClearQuarryLockOnAllTeamDisconnect = false;

            [JsonProperty(PropertyName = "Clear quarry lock after player owner disconnect")]
            public bool ClearQuarryLockOnPlayerOwnerDisconnect = false;

            [JsonProperty(PropertyName = "Time after all player disconnect before quarry clear (minutes)")]
            public long CooldownQuarryLockOnDisconnect = 10;    // default 10 minutes

            [JsonProperty(PropertyName = "Items in report list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] ReportItems = {"stones", "metal.ore", "metal.fragments", "hq.metal.ore", "metal.refined", "sulfur.ore", "sulfur", "lowgradefuel", "crude.oil"};

            [JsonProperty("Use Discord hook")]
            public bool Discordena = false;

            [JsonProperty("Use Discord timestamp")]
            public bool UseDiscordTimestamp = true;

            [JsonProperty("Discord hook url")]
            public string DiscordHookUrl = "";

            [JsonProperty(PropertyName = "Use Notify plugin")]
            public bool useNotify = false;

            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;

            [JsonProperty(PropertyName = "Log to file")]
            public bool LogToFile = false;			
        };


        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch (Exception ex)
            {
                PrintError(ex.Message);
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }

            if  (_config.FuelSlots > 6)  _config.FuelSlots = 6;
            if  (_config.FuelSlots == 0)  _config.FuelSlots = -1;

            if (_config.HopperSlots > 48) _config.HopperSlots = 48;

            _config._PlayerCoolDown = Math.Max(_config.PlayerCoolDown, _config.CoolDown);

            if (_config.ClearQuarryLockOnAllTeamDisconnect == true && _config.ClearQuarryLockOnPlayerOwnerDisconnect == true)
            {
                PrintError("Both ClearQuarryLockOnAllTeamDisconnect and ClearQuarryLockOnPlayerOwnerDisconnect are true. Using team mode by default");
                _config.ClearQuarryLockOnPlayerOwnerDisconnect = false;
            }

            if (_config.CooldownQuarryLockOnDisconnect < 0) _config.CooldownQuarryLockOnDisconnect = 0;
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

#endregion Configuration


        // ############################################################################################
#region UserInfo

        private Dictionary<ulong, QuarryInfo> Quarrys = new Dictionary<ulong, QuarryInfo>();

        // dict to link all the diff component entity to the right quarry
        private Dictionary<ulong, ulong> Associate = new Dictionary<ulong, ulong>();

        enum miningtype { none, miningquarry, miningpumpjack };

        private class QuarryInfo
        {
            public ulong playerid;
            public string displayName;
            public string ShortPrefabName;
            [JsonIgnore]
            public string readablename;
            [JsonIgnore]
            public miningtype type;

            [JsonIgnore]
            public double FuelTimeRemaining;
            //[JsonIgnore]
            public bool state;      // capture or not by playerid
            public bool EnableLock;      // capture or not by playerid

            public DateTime checkfueltime;
            public DateTime stoptime;
            public string Name;
            public float processRate = 5f;    // default value
            public Dictionary<ulong, CooldownTime> PlayerCooldown;

            [JsonIgnore]
            public DateTime PlayerDisconnectTime;
            [JsonIgnore]
            public int CountTick;

            [JsonIgnore]
            public MiningQuarry Quarry;

            [JsonIgnore]
            public Timer timerQuarryStopped = null;

            public QuarryInfo()
            {
                playerid = 0;
                displayName = "nobody";
                readablename = "none";
                type = miningtype.none;
                FuelTimeRemaining = 0f;
                state = false;
                EnableLock = false;
                PlayerDisconnectTime = DateTime.MaxValue;

                checkfueltime = DateTime.MinValue;
                stoptime  = DateTime.MinValue;
                Name = string.Empty;
                PlayerCooldown = new Dictionary<ulong, CooldownTime>();
                CountTick = 1;
                Quarry = null;
            }
        }

        public class CooldownTime
        {
            public bool IsOnline;
            public bool IgnoreOnline;
            public DateTime Time;
            public CooldownTime() { IsOnline = true; Time = DateTime.MinValue; IgnoreOnline = false; }
        }

        private void LoadData()
        {
            try {
                Quarrys = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, QuarryInfo>>(Name);
                if (Quarrys == null) throw new Exception();
            }
            catch (Exception ex)
            {
                PrintError(ex.Message);
                Quarrys = new Dictionary<ulong, QuarryInfo>();
                PrintWarning($"Data file corrupted or incompatible. Reinitialising data file ");
                SaveData();
            }
        }
        private void SaveData() { Interface.Oxide.DataFileSystem.WriteObject(Name, Quarrys); }

#endregion UserInfo

        // ############################################################################################
#region Localization

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["QuarryOff"]      = "<color=#FF1500>- {1} at {0} just turn off !</color>",
                ["QuarryCoolDown"] = "<color=#FF1500>- You have {0} min. to get the ore, before quarry unlock to all</color>",
                ["QuarryInUse"]    = "<color=#FFA500>{2} at {1} currently in use by {0}</color>",
                ["QuarryStartEngine"] = "{1} started for {0,2:F0} minutes",
                ["QuarryStartEngineHM"] = "{2} started for {0,2:F0} hour, {1,2:F0} minutes",
                ["QuarryStartEngineNolock"] = "{0} started in Dynamic PVP zone (not locked)",
                ["QuarryStarted"]  = "{2} at {1}, started by {0}. loot is protected",
                ["QuarryStoped"]   = "{2} at {1}, stopped and is available to all",
                ["QuarryStoped_B"] = "{2} at {1}, is available to all",
                ["QuarryFuel"]     = "<color=#FFA500>{1} currently running with {0} fuel in storage</color>",
                ["QuarryPlCooldown"] = "{1} player cooldown will expire in {0} min.",
                ["QuarryAvailableIn2"] = "{2} at {0},used by {3}, will be available in {1,2:F0} min.",
                ["QuarryClearStatus"] = "Clearing the status of mining quarry and pump jack",
                [ReadableNameQuarry] = "mining quarry",
                [ReadableNamePump] = "pump jack",
                ["QuarryClearOffline"] = "Quarry {0}, cleared because team/clan player are offline",
                ["QuarryAccessDenied"] = "Access denied. you do not have permission",
                ["QuarryInfoCmd"] = "Quarry info.",
                ["NoQuarryFoundNear"] = "No Quarry found near to apply command.",
                ["MoveFuelToOutput"] = "Stop quarry, Moving fuel to output hopper.",
                

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["QuarryOff"]      = "<color=#FF1500>- {1} a {0} viens de s'arreter !</color>",
                ["QuarryCoolDown"] = "<color=#FF1500>- Vous avez {0} min. pour récuperer le butin avant que l'acces débloque</color>",
                ["QuarryInUse"]    = "<color=#FFA500>{2} a {1} est utilisé par {0}</color>",
                ["QuarryStartEngine"] = "{1} démarré pour {0,2:F0} minutes",
                ["QuarryStartEngineHM"] = "{1} démarré pour {0,2:F0} heure, {1,2:F0} minutes",
                ["QuarryStartEngineNolock"] = "{0} démarré en zone PVP Dynamique (non protégé)",
                ["QuarryStarted"]  = "{2} a {1}, est démarré par {0}. butin protégé",
                ["QuarryStoped"]   = "Arret de {2} a {1}, disponible pour tous",
                ["QuarryStoped_B"] = "{2} a {1}, disponible pour tous",
                ["QuarryFuel"]     = "<color=#FFA500>{1} démarré avec {0} fuel dans le reservoir</color>",
                ["QuarryPlCooldown"] = "Le delai d'utilisation de {1} par joueur expire dans {0} min.",
                ["QuarryAvailableIn2"] = "{2} a {0},utilisé par {3}, sera disponible dans {1,2:F0} min.",
                ["QuarryClearStatus"] = "Efface le status des carrière minière et chevalet de pompage",
                [ReadableNameQuarry] = "carrière minière",
                [ReadableNamePump] = "chevalet de pompage",
                ["QuarryClearOffline"] = "Carrière minière {0}, libéré car l'équipe/clan des joueurs est hors-ligne",
                ["QuarryAccessDenied"] = "Access bloqué. vous n'avez pas la permission",
                ["QuarryInfoCmd"] = "Info des carrières minière",
                ["NoQuarryFoundNear"] = "Pas de carrières minière trouvé a proximité, pour cette commande",
                ["MoveFuelToOutput"] = "Arret de la carrières minière, transfer du carburant vers le contenant de sortie.",
            }, this, "fr");
        }
        #endregion Localization

        #region Hooks 

        private void Init()
        {
            StorageContainer fuelstorage;
            StorageContainer hopper;

            LoadData();

            var staticQuarry = GameManager.server.FindPrefab("assets/bundled/prefabs/static/miningquarry_static.prefab")?.GetComponent<MiningQuarry>();
            if (staticQuarry != null)
            {
                fuelstorage = staticQuarry?.fuelStoragePrefab.prefabToSpawn.GetEntity() as StorageContainer;
                QuarryDefaultDieselStack = fuelstorage?.maxStackSize ?? 0;
                QuarryDefaultFuelCapacity = fuelstorage?.inventorySlots ?? 6;

                hopper = staticQuarry.hopperPrefab.prefabToSpawn.GetEntity() as StorageContainer;
                QuarryDefaultHopperSlots = hopper?.inventorySlots ?? 18;
            }
            
            var staticpumpjack = GameManager.server.FindPrefab("assets/bundled/prefabs/static/pumpjack-static.prefab")?.GetComponent<MiningQuarry>();
            if (staticpumpjack != null)
            {
                fuelstorage = staticpumpjack.fuelStoragePrefab.prefabToSpawn.GetEntity() as StorageContainer;
                PumpDefaultDieselStack = fuelstorage?.maxStackSize ?? 0;
                PumpDefaultFuelCapacity = fuelstorage?.inventorySlots ?? 6;

                hopper = staticpumpjack.hopperPrefab.prefabToSpawn.GetEntity() as StorageContainer;
                PumpDefaultHopperSlots = hopper?.inventorySlots ?? 18;
            }

            _instance = this;

            permission.RegisterPermission(_config.PermissionUseQuarry, this);
            permission.RegisterPermission(_config.PermissionUsePump, this);
            permission.RegisterPermission(_config.PermissionBypassCooldown, this);            

            permission.RegisterPermission(_config.PermissionAdmin, this);

            if (!_config.ClearQuarryLockOnAllTeamDisconnect &&
                !_config.ClearQuarryLockOnPlayerOwnerDisconnect)
            {
                Unsubscribe(nameof(OnPlayerConnected));
                Unsubscribe(nameof(OnPlayerDisconnected));
            }
            Unsubscribe(nameof(OnEntitySpawned));

            AddCovalenceCommand(_config.quarryquerry, nameof(Quarry_info));
            AddCovalenceCommand(_config.quarryclearstatus, nameof(Quarry_clearstatus));
            AddCovalenceCommand(_config.quarrystopcommand, nameof(Mining_stopcommand));
            
        }

        private void Unload()
        {
            foreach (var entquarry in BaseNetworkable.serverEntities)
            {
                var quarry = entquarry as MiningQuarry;
                if (quarry != null)
                {
                    QuarryDetector quarrydetector = quarry.gameObject.GetComponent<QuarryDetector>();
                    if (quarrydetector != null) UnityEngine.Object.Destroy(quarrydetector);

                    QuarryInfo quarryinfo;
                    if (Quarrys.TryGetValue(quarry.net.ID.Value, out quarryinfo))
                    {
                        if (quarryinfo.EnableLock == true)
                        {
                            // restore default value

                            try
                            {
                                StorageContainer fuelstorage = quarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>();
                                if (quarry.ShortPrefabName == "miningquarry_static")
                                {
                                    if (_config.DieselFuelMaxStackSize >= 0) fuelstorage.inventory.maxStackSize = QuarryDefaultDieselStack;
                                    if (_config.FuelSlots > 0) fuelstorage.inventory.capacity = QuarryDefaultFuelCapacity;  // restore default
                                }
                                if (quarry.ShortPrefabName == "pumpjack-static")
                                {
                                    if (_config.DieselFuelMaxStackSize >= 0) fuelstorage.inventory.maxStackSize = PumpDefaultDieselStack;
                                    if (_config.FuelSlots > 0) fuelstorage.inventory.capacity = PumpDefaultFuelCapacity;  // restore default
                                }
                            }
                            catch (Exception ex)
                            {
                                PrintError(ex.Message);
                                PrintError($"Quarry at location {quarry.transform.position} is missing fuel storage container.");
                                quarry.fuelStoragePrefab?.DoSpawn(quarry);
                            }

                            try
                            {
                                StorageContainer hopper = quarry.hopperPrefab.instance.GetComponent<StorageContainer>();
                                if (quarry.ShortPrefabName == "miningquarry_static")
                                {
                                    if (_config.HopperSlots > 0) hopper.inventory.capacity = QuarryDefaultHopperSlots;
                                }
                                if (quarry.ShortPrefabName == "pumpjack-static")
                                {
                                    if (_config.HopperSlots > 0) hopper.inventory.capacity = PumpDefaultHopperSlots;
                                }
                            }
                            catch (Exception ex)
                            {
                                PrintError(ex.Message);
                                PrintError($"Quarry at location {quarry.transform.position} is missing hopper storage container.");
                                quarry.hopperPrefab?.DoSpawn(quarry);
                            }

                            if (_config.TimePerBarrel > 0) quarry.workPerFuel = 1000f;
							if (quarry.pendingWork > quarry.workPerFuel) quarry.pendingWork = quarry.workPerFuel;
                        }

                        if (quarryinfo.timerQuarryStopped != null)
                        {
                            timer.Destroy(ref quarryinfo.timerQuarryStopped);
                        }
                    }
                }
            }

            SaveData();
        
            // clear static
            _instance = null;
            _discord = null;
		    _config = null;
        }

        //
        private void OnServerInitialized(bool initial)
        {
            // setup discord info
            if (_config.Discordena && !string.IsNullOrEmpty(_config.DiscordHookUrl))
            {
                var loader = new GameObject("WebObject");
                _discord = loader.AddComponent<DiscordComponent>().Configure(_config.DiscordHookUrl);
                PrintToLog($"Plugin PublicQuarryLock restarted");
            }

            // this is just in case user think its in second and put a large value 
            if (_config.PlayerCoolDown > 120)
            {
                PrintWarning($"Configuration cooldown period {_config.PlayerCoolDown} minutes");
            }



            if (_config.UseClans && !IspluginLoaded(Clans))
            {
                PrintWarning("Optional Clans plugin not found. Clans disabled");
            }

            if (_config.useNotify && !IspluginLoaded(Notify))
            {
                PrintWarning("Optional Notify plugin not found. Notify disabled");
            }

            timer.Once(1f, () =>
            {
                Subscribe(nameof(OnEntitySpawned));
                // count the MiningQuarry engine on the map
                foreach (var entquarry in BaseNetworkable.serverEntities)
                {
                    var quarry = entquarry as MiningQuarry;
                    if (quarry != null)
                    {
                        OnEntitySpawned(quarry);
                    }
                }

                // Check if the quarry entry exist 
                // If not remove it. This append when server wipe
                List<ulong> removals = Pool.Get<List<ulong>>();
                removals.Clear();
                foreach (KeyValuePair<ulong, QuarryInfo> KVP in Quarrys)
                {
                    var quarry = KVP.Value.Quarry;
                    if (quarry == null)
                    {
                        removals.Add(KVP.Key);
                    }
                }

                if (removals.Count != 0) PrintWarning($"Removing {removals.Count} unused entry from the data file ");

                // cleanup dict entry of unused info
                foreach (ulong removeid in removals)
                {
                    Quarrys.Remove(removeid);
                }
                Pool.FreeUnmanaged(ref removals);
            });
        }

        //OnEntitySpawned execute before OnServerInitialized
        void OnEntitySpawned(MiningQuarry quarry)
        {
            QuarryInfo quarryinfo;
            if (!Quarrys.TryGetValue(quarry.net.ID.Value, out quarryinfo))
            {
                quarryinfo = new QuarryInfo();
                quarryinfo.ShortPrefabName = quarry.ShortPrefabName;
                Quarrys.Add(quarry.net.ID.Value, quarryinfo);
            }
            quarryinfo.Name = PositionToString(quarry.transform.position);
            quarryinfo.Quarry = quarry;

            if ((_config.enableMiningQuarry && quarry.ShortPrefabName == "miningquarry_static" && !quarry.OwnerID.IsSteamId()) ||
                (_config.enablePumpJack && quarry.ShortPrefabName == "pumpjack-static" && !quarry.OwnerID.IsSteamId()) ||
                (_config.enablePlayerQuarry && _config.enableMiningQuarry && quarry.ShortPrefabName == "mining_quarry") ||
                (_config.enablePlayerPump && _config.enablePumpJack && quarry.ShortPrefabName == "mining.pumpjack") ||
                (_config.enablePlayerQuarry && _config.enableMiningQuarry && quarry.ShortPrefabName == "miningquarry_static" && quarry.OwnerID.IsSteamId()) ||
                (_config.enablePlayerPump && _config.enablePumpJack && quarry.ShortPrefabName == "pumpjack-static") && quarry.OwnerID.IsSteamId())
            {
                quarryinfo.EnableLock = true;
                try
                {
                    // experimental max stack size
                    StorageContainer fuelstorage = quarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>();
                    if (_config.DieselFuelMaxStackSize >= 0) fuelstorage.inventory.maxStackSize = _config.DieselFuelMaxStackSize;
                    if (_config.FuelSlots > 0) fuelstorage.inventory.capacity = _config.FuelSlots;
                }
                catch (Exception ex)
                {
                    PrintError(ex.Message);
                    PrintError($"Quarry at location {quarry.transform.position} is missing fuel storage container.");
                    quarry.fuelStoragePrefab?.DoSpawn(quarry);
                }

                try
                {
                    StorageContainer hopper = quarry.hopperPrefab.instance.GetComponent<StorageContainer>();
                    if (_config.HopperSlots > 0) hopper.inventory.capacity = _config.HopperSlots;
                }
                catch (Exception ex)
                {
                    PrintError(ex.Message);
                    PrintError($"Quarry at location {quarry.transform.position} is missing hopper storage container.");
                    quarry.hopperPrefab?.DoSpawn(quarry);
                }

                try
                {
                    quarryinfo.processRate = quarry.processRate;
                    if (!Associate.ContainsKey(quarry.fuelStoragePrefab.instance.net.ID.Value))
                        Associate.Add(quarry.fuelStoragePrefab.instance.net.ID.Value, quarry.net.ID.Value);
                    if (!Associate.ContainsKey(quarry.hopperPrefab.instance.net.ID.Value))
                        Associate.Add(quarry.hopperPrefab.instance.net.ID.Value, quarry.net.ID.Value);
                    if (!Associate.ContainsKey(quarry.engineSwitchPrefab.instance.net.ID.Value))
                        Associate.Add(quarry.engineSwitchPrefab.instance.net.ID.Value, quarry.net.ID.Value);
                }
                catch (Exception ex)
                {
                    PrintError(ex.Message);
                    PrintError($"Quarry spawn associate error : {quarry.ShortPrefabName} at {quarry.transform.position}");
                }

                if (_config.TimePerBarrel > 0.0f)
                {
                    quarry.workPerFuel = quarry.workToAdd / quarry.processRate * (float)_config.TimePerBarrel;                    
                }
                if (quarry.pendingWork > quarry.workPerFuel) quarry.pendingWork = quarry.workPerFuel;
            }
            else
            { 
                quarryinfo.EnableLock = false;
            }

            if (quarry.ShortPrefabName == "miningquarry_static" || quarry.ShortPrefabName == "mining_quarry")
            {
                quarryinfo.readablename = ReadableNameQuarry;
                quarryinfo.type = miningtype.miningquarry;
            }
            else
            {
                quarryinfo.readablename = ReadableNamePump;
                quarryinfo.type = miningtype.miningpumpjack;
            }
            
            QuarryDetector quarrydetector = quarry.gameObject.GetComponent<QuarryDetector>();
            if (quarrydetector == null) quarry.gameObject.AddComponent<QuarryDetector>();
        }

        private object OnQuarryToggle(MiningQuarry quarry, BasePlayer player)
        {
            if (quarry == null || player==null) return null;

            QuarryInfo quarryinfo = null;
            if (!Quarrys.TryGetValue(quarry.net.ID.Value, out quarryinfo))
            {
                PrintWarning("Unregistered Quarry ?");
                return true;  // 
            }

            if (quarryinfo.EnableLock)
            {
                bool permquarry = CanPlayerUseQuarry((ulong)player.userID);
                bool permpump = CanPlayerUsePump((ulong)player.userID);
                quarryinfo.state = quarry.IsEngineOn();

                if (!quarryinfo.state && _config.UseDynamicPVP && isEntityInDynamicPVP(quarry))
                {
                    SendChatMessage(player, "QuarryStartEngineNolock", quarryinfo.readablename);
                    quarryinfo.playerid = 0;
                    quarryinfo.displayName = "nobody";
                    quarryinfo.checkfueltime = DateTime.Now;
                    quarryinfo.PlayerDisconnectTime = DateTime.MaxValue;
                    int itemcnt = quarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.TotalItemAmount() + 1;
                    PrintToLog($"Quarry [{quarryinfo.Name}] started at : {DateTime.Now.ToString("h:mm tt")} by {player.displayName}/{(ulong)player.userID} with {itemcnt} diesel");
                    return null;
                }

                if (!_config.UseQuarryWithoutPermission &&
                    !(permquarry && quarryinfo.type == miningtype.miningquarry ||
                      permpump && quarryinfo.type == miningtype.miningpumpjack))
                {
                    SendChatMessage(player, "QuarryAccessDenied");
                    return true;
                }

                // check if engine is off. 
                if (!quarryinfo.state)
                {
                    bool checkcooldown = CheckPlayerCooldown((ulong)player.userID, quarryinfo);

                    // check if player is allowed to switch engine
                    if ((quarryinfo.playerid == 0 && !checkcooldown) ||    // not locked
                        ((ulong)player.userID == quarryinfo.playerid) ||        // already lock by same player
                        (SameTeam((ulong)player.userID, quarryinfo.playerid)) ||
                        (SameClan((ulong)player.userID, quarryinfo.playerid)))
                    {
                        if (permquarry && quarryinfo.type == miningtype.miningquarry ||
                            permpump && quarryinfo.type == miningtype.miningpumpjack)
                        {
                            quarryinfo.playerid = (ulong)player.userID;
                            quarryinfo.displayName = player.displayName;
                            quarryinfo.checkfueltime = DateTime.Now;
                            quarryinfo.PlayerDisconnectTime = DateTime.MaxValue;
                            return null;
                        }
                        else
                        {
                            quarryinfo.playerid = 0;
                            quarryinfo.displayName = "nobody";
                            quarryinfo.checkfueltime = DateTime.Now;
                            quarryinfo.PlayerDisconnectTime = DateTime.MaxValue;
                            return null;
                        }
                    }
                    else
                    {
                        if (checkcooldown)
                        {
                            SendChatMessage(player, "QuarryPlCooldown", PlayerCooldownTime((ulong)player.userID, quarryinfo), quarryinfo.readablename);
                        }
                        else
                        {
                            SendChatMessage(player, "QuarryInUse", quarryinfo.displayName, quarryinfo.Name, quarryinfo.readablename);
                        }
                        return true;
                    }                    
                }
                else  // try to turn off quarry
                {                    
                    if (quarryinfo.playerid != 0)
                    {
                        // Quarry state is Off
                        if ((((ulong)player.userID == quarryinfo.playerid) ||
                            SameTeam((ulong)player.userID, quarryinfo.playerid) ||
                            SameClan((ulong)player.userID, quarryinfo.playerid)) && _config.engineloot)
                        {
                            return null;
                        }
                        else
                        {
                            SendChatMessage(player, "QuarryInUse", quarryinfo.displayName, quarryinfo.Name, quarryinfo.readablename);
                            return true;
                        }
                    }
                    return null;
                }
            }
            return null; // not lockable
        }

        float CalcFuelTime(MiningQuarry quarry)
        {
            if (quarry == null) return 0f;
            int itemcnt = quarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.TotalItemAmount();
            var FuelTime = (quarry.processRate * (quarry.pendingWork + quarry.workPerFuel * (float)itemcnt) / (quarry.workToAdd * 60f));
            return FuelTime;
        }

        // The engine was toggled by user. not called whe stop for fuel or full
        void OnQuarryToggled(MiningQuarry quarry, BasePlayer player)
        {
            if (player == null) return;

            QuarryInfo quarryinfo;
            if (!Quarrys.TryGetValue(quarry.net.ID.Value, out quarryinfo))
            {
                PrintWarning("Unregistered Quarry ?");
                return;
            }
            quarryinfo.state = quarry.IsEngineOn();

            if (quarryinfo.EnableLock)
            {
                if (quarryinfo.state) // turn on
                {
                    if (quarryinfo.playerid != 0)
                    {
                        bool checkcooldown = CheckPlayerCooldown((ulong)player.userID, quarryinfo);
                        if (((ulong)player.userID == quarryinfo.playerid) ||       // already lock by same player
                            (SameTeam((ulong)player.userID, quarryinfo.playerid)) ||
                            (SameClan((ulong)player.userID, quarryinfo.playerid)))
                        {
                            // Quarry state is On
                            quarryinfo.checkfueltime = DateTime.Now;
                            quarryinfo.PlayerDisconnectTime = DateTime.MaxValue;
                            quarryinfo.FuelTimeRemaining = CalcFuelTime(quarry);

                            if (quarryinfo.FuelTimeRemaining < 60) SendChatMessage(player, "QuarryStartEngine", Math.Ceiling(quarryinfo.FuelTimeRemaining), quarryinfo.readablename);
                            else SendChatMessage(player, "QuarryStartEngineHM", quarryinfo.FuelTimeRemaining / 60, quarryinfo.FuelTimeRemaining % 60, quarryinfo.readablename);

                            if (_config.MessageAll)
                            {
                                BroadcastMessage("QuarryStarted", player.displayName, quarryinfo.Name, quarryinfo.readablename);
                            }

                            int itemcnt = quarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.TotalItemAmount() + 1;
                            PrintToLog($"Quarry [{quarryinfo.Name}] started at : {DateTime.Now.ToString("h:mm tt")} by {player.displayName}/{(ulong)player.userID} with {itemcnt} diesel");

                            // Start 
                            AddPlayerCooldown(quarryinfo.playerid, quarryinfo.FuelTimeRemaining, quarryinfo);

                            if (_config.FlushOutputHopper)
                            {
                                var hopper = quarry.hopperPrefab.instance.GetComponent<StorageContainer>();
                                PrintToLog($"Flush {ReportInventory(hopper)} items from hopper");
                                DropItemContainer(hopper.inventory, hopper.transform.position + quarry.transform.rotation * DropVect, quarry.transform.rotation);
                            }

                            if (quarryinfo.timerQuarryStopped != null)
                            {
                                timer.Destroy(ref quarryinfo.timerQuarryStopped);
                            }
                        }
                    }
                }
                else // turn off
                {
                    if (quarryinfo.playerid != 0)
                    {
                        // Quarry state is Off
                        if ((((ulong)player.userID == quarryinfo.playerid) ||
                        SameTeam((ulong)player.userID, quarryinfo.playerid) ||
                        SameClan((ulong)player.userID, quarryinfo.playerid)) && _config.engineloot)
                        {
                            OnQuarryToggledOff(quarry, false);
                            PrintToLog($"Quarry [{quarryinfo.Name}] stopped at : {DateTime.Now.ToString("h:mm tt")} by {player.displayName}/{(ulong)player.userID}");
                        }
                    }
                }
            }
        }

        void OnQuarryToggledOff(MiningQuarry quarry, bool enableMsg = true)
        {
            QuarryInfo quarryinfo;
            if (Quarrys.TryGetValue(quarry.net.ID.Value, out quarryinfo))
            {
                // Quarry state is Off
                quarryinfo.state = quarry.IsEngineOn();
                quarryinfo.stoptime = DateTime.Now;
                quarryinfo.checkfueltime = DateTime.Now;
                quarryinfo.FuelTimeRemaining = 0;

                if (quarryinfo.playerid != 0 && quarryinfo.EnableLock)
                {
                    // Update cooldown info when the quarry stop
                    AddPlayerCooldown(quarryinfo.playerid, 0f, quarryinfo);

                    // player will be null when disconnected and wont receive message
                    var player = BasePlayer.FindByID(quarryinfo.playerid);
                    if (player != null && enableMsg)
                    {
                        SendChatMessage(player, "QuarryOff", quarryinfo.Name, quarryinfo.readablename);
                        SendChatMessage(player, "QuarryCoolDown", _config.CoolDown);
                    }

                    if (enableMsg)
                    {
                        int fuelcnt = quarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.TotalItemAmount();
                        int hoppercnt = quarry.hopperPrefab.instance.GetComponent<StorageContainer>().inventory.TotalItemAmount();
                        PrintToLog($"Quarry [{quarryinfo.Name}] stopped at : {DateTime.Now.ToString("h:mm tt")} because of fuel or hopper is full ({fuelcnt} diesel / {ReportInventory(quarry.hopperPrefab.instance.GetComponent<StorageContainer>())} items in hopper)");
                    }

                    if (quarryinfo.timerQuarryStopped != null)
                    {
                        timer.Destroy(ref quarryinfo.timerQuarryStopped);
                    }
                    quarryinfo.timerQuarryStopped = timer.Once(_config.CoolDown * 60f, () =>
                    {
                        // In case quarry is restarted after cooldown
                        if (quarryinfo!=null && !quarryinfo.state)
                        {
                            if (_config.MessageAll) BroadcastMessage("QuarryStoped", quarryinfo.displayName, quarryinfo.Name, quarryinfo.readablename);
                            PrintToLog($"Quarry [{quarryinfo.Name}] Unlocked to all players");
                            quarryinfo.playerid = 0;
                            quarryinfo.displayName = "nobody";
                            quarryinfo.PlayerDisconnectTime = DateTime.MaxValue;
                            quarryinfo.timerQuarryStopped = null;
                        }
                        
                    });
                }
            }
        }

        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (player == null) return null;
            if (container == null) return null;          

            // pumpjack
            if (_config.enableMiningQuarry)
            {
                if (container.prefabID == FuelStoragePumpID) return LootQuarryFuel(player, container); // "fuelstorage"
                else if (container.prefabID == OutputHopperPumpID) return LootQuarryOutput(player, container);    // "crudeoutput"
            }

            // mining quarry
            if (_config.enablePumpJack)
            {
                if (container.prefabID == FuelStorageQuarryID) return LootQuarryFuel(player, container);    // "fuelstorage"
                else if (container.prefabID == OutputHopperQuarryID) return LootQuarryOutput(player, container);    // "hopperoutput"
            }

            return null;
        }

        void OnLootEntityEnd(BasePlayer player, StorageContainer container)
        {
            if (container.prefabID == FuelStoragePumpID ||
     			container.prefabID == FuelStorageQuarryID) LootDieselEngineEnd(player, container);   // fuelstorage for quarry or pumpjack
        }
		
        void LootDieselEngineEnd(BasePlayer player, StorageContainer fueltank)
        {
            ulong quarryID;
            QuarryInfo quarryinfo;
            if (!Associate.TryGetValue(fueltank.net.ID.Value, out quarryID)) return;
            if (!Quarrys.TryGetValue(quarryID, out quarryinfo)) return;
            if (!quarryinfo.EnableLock) return;

            var quarry = quarryinfo.Quarry;
            var amount = fueltank.inventory.GetAmount(1568388703, true);    // lowgradefuel == -946369541, Diesel == 1568388703

            if (quarry != null && quarry.IsEngineOn())
            {
				quarryinfo.checkfueltime = DateTime.Now;
                quarryinfo.FuelTimeRemaining = CalcFuelTime(quarry);

                AddPlayerCooldown(quarryinfo.playerid, quarryinfo.FuelTimeRemaining, quarryinfo);
            }
            PrintToLog($"Player {player.displayName}/{(ulong)player.userID} looting fuel in engine at [{quarryinfo.Name}],  {amount} diesel");
        }

        object LootQuarryOutput(BasePlayer player, StorageContainer container)
        {
            ulong quarryID;
            QuarryInfo quarryinfo;

            if (IsAdmin((ulong)player.userID) == true) return null;
            if (!Associate.TryGetValue(container.net.ID.Value, out quarryID)) return null;
            if (!Quarrys.TryGetValue(quarryID, out quarryinfo)) return null;  // 

            if (!quarryinfo.EnableLock) return null;
            if ((!_config.UseQuarryWithoutPermission && quarryinfo.type == miningtype.miningquarry && !CanPlayerUseQuarry((ulong)player.userID)) ||
                (!_config.UseQuarryWithoutPermission && quarryinfo.type == miningtype.miningpumpjack && !CanPlayerUsePump((ulong)player.userID))) 
            {
                SendChatMessage(player, "QuarryAccessDenied");
                return true;
            }

            if (quarryinfo.playerid == 0 ||
                IsQuarryAvailable(quarryinfo))
            {
                int hoppercnt = container.inventory.TotalItemAmount();
                PrintToLog($"Player {player.displayName}/{(ulong)player.userID} looting quarry [{quarryinfo.Name}], {ReportInventory(container)} items in hopper");
                return null;
            }

            if (((ulong)player.userID == quarryinfo.playerid) ||
                (SameTeam((ulong)player.userID, quarryinfo.playerid)) ||
                (SameClan((ulong)player.userID, quarryinfo.playerid)))
            {
                int hoppercnt = container.inventory.TotalItemAmount();
                PrintToLog($"Player {player.displayName}/{(ulong)player.userID} looting quarry [{quarryinfo.Name}] owned by:{quarryinfo.displayName}/{quarryinfo.playerid}, {ReportInventory(container)} items in hopper");
                return null;
            }

            SendChatMessage(player, "QuarryInUse", quarryinfo.displayName, quarryinfo.Name, quarryinfo.readablename);

            return true;
        }

        object LootQuarryFuel(BasePlayer player, StorageContainer container)
        {
            ulong quarryID;
            QuarryInfo quarryinfo;
            
            if (IsAdmin((ulong)player.userID) == true) return null;

            if (!Associate.TryGetValue(container.net.ID.Value, out quarryID)) return null;
            if (!Quarrys.TryGetValue(quarryID, out quarryinfo)) return null;  // 
            if (!quarryinfo.EnableLock) return null;

            var quarry = quarryinfo.Quarry;

            if ((!_config.UseQuarryWithoutPermission && quarryinfo.type == miningtype.miningquarry && !CanPlayerUseQuarry((ulong)player.userID)) ||
               (!_config.UseQuarryWithoutPermission && quarryinfo.type == miningtype.miningpumpjack && !CanPlayerUsePump((ulong)player.userID)))
            {
                SendChatMessage(player, "QuarryAccessDenied"); 
                return true;
            }

            if (quarryinfo.playerid == 0 ||
                IsQuarryAvailable(quarryinfo))
            {
                return null;
            }

            if (!_config.engineloot)
            {
                float amount = (quarry!=null) ? quarry.pendingWork/quarry.workPerFuel : 0;
                amount += (float)container.inventory.GetAmount(1568388703, true);   // check lowgradefuel = -946369541, diesel == 1568388703
                if (quarryinfo.state) SendChatMessage(player, "QuarryFuel", Math.Ceiling(amount).ToString(), quarryinfo.readablename);                    
                else SendChatMessage(player, "QuarryInUse", quarryinfo.displayName, quarryinfo.Name, quarryinfo.readablename);
                return true;   // disable engine loot
            }

            if (((ulong)player.userID == quarryinfo.playerid) ||
                (SameTeam((ulong)player.userID, quarryinfo.playerid)) ||
                (SameClan((ulong)player.userID, quarryinfo.playerid))) return null;

            SendChatMessage(player, "QuarryInUse", quarryinfo.displayName, quarryinfo.Name, quarryinfo.readablename);
            return true;
        }

        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            QuarryInfo quarryinfo;
            if (!Quarrys.TryGetValue(quarry.net.ID.Value, out quarryinfo)) return;

            if ((_config.ClearQuarryLockOnAllTeamDisconnect || _config.ClearQuarryLockOnPlayerOwnerDisconnect) && --quarryinfo.CountTick == 0)
            {
                quarryinfo.CountTick = 2;

                if (quarryinfo.PlayerDisconnectTime != DateTime.MaxValue)
                {
                    if (quarryinfo.PlayerDisconnectTime.AddMinutes(_config.CooldownQuarryLockOnDisconnect) <= DateTime.Now)
                    {
                        // Clear quarry lock                        
                        if (_config.ClearQuarryLockOnPlayerOwnerDisconnect)
                        {
                            PrintToLog($"Quarry [{quarryinfo.Name}] unlocked because player owner disconnected for {_config.CooldownQuarryLockOnDisconnect} minutes {quarryinfo.displayName}/{quarryinfo.playerid}  isconnected:{BasePlayer.FindAwakeOrSleeping(quarryinfo.playerid.ToString())?.IsConnected ?? false}");
                        }
                        if (_config.ClearQuarryLockOnAllTeamDisconnect)
                        {
                            PrintToLog($"Quarry [{quarryinfo.Name}] unlocked because all team/clan disconnected for {_config.CooldownQuarryLockOnDisconnect} minutes {quarryinfo.displayName}/{quarryinfo.playerid} ");
                        }

                        if (_config.MessageAll) BroadcastMessage("QuarryClearOffline", quarryinfo.Name);
                        quarryinfo.PlayerDisconnectTime = DateTime.MaxValue;
                        ClearQuarry(quarryinfo, false);
                    }
                }
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;

            foreach (KeyValuePair<ulong, QuarryInfo> quarrys in Quarrys)
            {
                foreach (var kvp in quarrys.Value.PlayerCooldown)
                {
                    if (_config.ClearQuarryLockOnPlayerOwnerDisconnect)
                    {
                        if ((ulong)player.userID == kvp.Key && (ulong)player.userID == quarrys.Value.playerid)
                        {
                            kvp.Value.IsOnline = true;
                            quarrys.Value.PlayerDisconnectTime = DateTime.MaxValue;
                            PrintToLog($"Player connected {player.displayName}/{(ulong)player.userID} at {DateTime.Now}   isconnected:{BasePlayer.FindAwakeOrSleeping(player.UserIDString)?.IsConnected ?? false}");

                        }
                    }

                    if (_config.ClearQuarryLockOnAllTeamDisconnect)
                    {
                        if ((ulong)player.userID == kvp.Key)
                        {
                            kvp.Value.IsOnline = true;
                            quarrys.Value.PlayerDisconnectTime = DateTime.MaxValue;
                            PrintToLog($"Player connected {player.displayName}/{(ulong)player.userID} at {DateTime.Now}   isconnected:{BasePlayer.FindAwakeOrSleeping(player.UserIDString)?.IsConnected ?? false}");
                        }
                    }
                }
            }
        }

        void OnPlayerDisconnected(BasePlayer player, string strReason)
        {
            int PlayerCount;
            if (player == null) return;

            foreach (KeyValuePair<ulong, QuarryInfo> quarrys in Quarrys)
            {
                if (_config.ClearQuarryLockOnPlayerOwnerDisconnect) PlayerCount = 1;
                else PlayerCount = quarrys.Value.PlayerCooldown.Count;

                foreach (var kvp in quarrys.Value.PlayerCooldown)
                {
                    if (_config.ClearQuarryLockOnPlayerOwnerDisconnect)
                    {
                        if ((ulong)player.userID == kvp.Key && (ulong)player.userID == quarrys.Value.playerid)
                        {
                            kvp.Value.IsOnline = false;
                            PlayerCount--;
                            PrintToLog($"Player disconnected {player.displayName}/{(ulong)player.userID} at {DateTime.Now} ");
                        }
                    }
                    if (_config.ClearQuarryLockOnAllTeamDisconnect)
                    {
                        if ((ulong)player.userID == kvp.Key)
                        {
                            kvp.Value.IsOnline = false;
                            PrintToLog($"Player disconnected {player.displayName}/{(ulong)player.userID} at {DateTime.Now} ");
                        }
                        if (!kvp.Value.IsOnline || kvp.Value.IgnoreOnline) PlayerCount--;                        
                    }
                }

                if (PlayerCount <= 0)
                {
                    quarrys.Value.PlayerDisconnectTime = DateTime.Now;
                    PrintToLog($"Activate disconnect countdown {player.displayName}/{(ulong)player.userID} at {DateTime.Now}  {quarrys.Value.Name} by {quarrys.Value.displayName}/{quarrys.Value.playerid} ");
                }
                if (PlayerCount < 0)
                {
                    PrintToLog($"Warning : PlayerCount < 0 {player.displayName}/{(ulong)player.userID} at {DateTime.Now}  {quarrys.Value.Name}");
                }
            }
        }

#endregion Hooks

#region Helpers
        bool CheckPlayerCooldown(ulong PlayerID, QuarryInfo quarryinfo)
        {
            List<ulong> removals = Pool.Get<List<ulong>>();
            removals.Clear();
            DateTime now = DateTime.Now;
            bool result = false;

            if (_config.CoolDownGlobal && !CanPlayerBypassCooldown(PlayerID))
            {
                foreach (KeyValuePair<ulong, QuarryInfo> quarrykvp in Quarrys)
                {
                    foreach (KeyValuePair<ulong, CooldownTime> kvp in quarrykvp.Value.PlayerCooldown)
                    {
                        if (now >= kvp.Value.Time) removals.Add(kvp.Key);
                        if (kvp.Key == PlayerID && now < kvp.Value.Time) result=true;
                    }

                    // cleanup dict entry of older time info
                    foreach (ulong removeid in removals)
                    {
                        quarrykvp.Value.PlayerCooldown.Remove(removeid);
                    }
                    removals.Clear();
                }
            }
            else
            {
                foreach (KeyValuePair<ulong, CooldownTime> kvp in quarryinfo.PlayerCooldown)
                {
                    if (now >= kvp.Value.Time) removals.Add(kvp.Key);
                    if (kvp.Key == PlayerID && now < kvp.Value.Time) result=true;
                }

                // cleanup dict entry of older time info
                foreach (ulong removeid in removals)
                {
                    quarryinfo.PlayerCooldown.Remove(removeid);
                }
            }

            Pool.FreeUnmanaged(ref removals);
            return result;
        }

        int PlayerCooldownTime(ulong PlayerID, QuarryInfo quarryinfo)
        {
            DateTime now = DateTime.Now;
            CooldownTime cooldown;

            if (_config.CoolDownGlobal && !CanPlayerBypassCooldown(PlayerID))
            {
                foreach (KeyValuePair<ulong, QuarryInfo> quarrykvp in Quarrys)
                {
                    if (quarrykvp.Value.PlayerCooldown.TryGetValue(PlayerID, out cooldown) && now < cooldown.Time)
                   {
                        var diff = cooldown.Time.Subtract(now);
                        return (int)Math.Ceiling(diff.TotalMinutes);
                    }
                }
            }
            else
            {
                if (quarryinfo.PlayerCooldown.TryGetValue(PlayerID, out cooldown) && now < cooldown.Time)			
               {
                    var diff = cooldown.Time.Subtract(now);
                    return (int)Math.Ceiling(diff.TotalMinutes);
                }
            }
            return 0;
        }

        void AddPlayerCooldown(ulong playerID, double extra, QuarryInfo quarryinfo)
        {
            foreach (KeyValuePair<ulong, CooldownTime> kvp in quarryinfo.PlayerCooldown)
            {
                kvp.Value.IgnoreOnline = true; // Ignore previous users of the quarry
            }

            CooldownTime CoolDown = new CooldownTime();
            CoolDown.IsOnline = BasePlayer.FindAwakeOrSleeping(playerID.ToString())?.IsConnected ?? false;
            CoolDown.Time = DateTime.Now.AddMinutes(_config._PlayerCoolDown + extra);
            AddSinglePlayerCooldown(playerID, quarryinfo, CoolDown);

            if (CoolDown.IsOnline == false)
            {
                PrintWarning($"quarry [{quarryinfo.Name}] change on/off state, Player {playerID} is flagged Offline.");
            }

            // If enable, Process all team members
            var teammanager = RelationshipManager.ServerInstance;
            if (_config.UseTeams && teammanager != null)
            {
                var team = teammanager.FindPlayersTeam(playerID);
                if (team != null)
                {
                    foreach (var ent in team.members)
                    {
                        CoolDown = new CooldownTime();
                        CoolDown.IsOnline = BasePlayer.FindAwakeOrSleeping(ent.ToString())?.IsConnected ?? false;
                        CoolDown.IgnoreOnline = false;
                        CoolDown.Time = DateTime.Now.AddMinutes(_config._PlayerCoolDown + extra);
                        AddSinglePlayerCooldown(ent, quarryinfo, CoolDown);
                    }
                }
            }

            // if enable, process the clan member
            if (_config.UseClans && IspluginLoaded(Clans))
            {
                BasePlayer friend;
                var member = Clans.Call("GetClanMembers", playerID.ToString());
                if (member!=null)
                {
                    List<string> memberlist = member as List<string>;

                    foreach (var ent in memberlist)
                    {
                        friend = BasePlayer.FindAwakeOrSleeping(ent);
                        if (friend != null)
                        {
                            CoolDown = new CooldownTime();
                            CoolDown.IsOnline = friend.IsConnected;
                            CoolDown.IgnoreOnline = false;
                            CoolDown.Time = DateTime.Now.AddMinutes(_config._PlayerCoolDown + extra);
                            AddSinglePlayerCooldown(ulong.Parse(ent), quarryinfo, CoolDown);
                        }
                    }
                }
            }

            // if enable, process the clan member from clantable
            if (_config.UseClanTable)
            {
                BasePlayer friend;
                long clanId = BasePlayer.FindAwakeOrSleeping(playerID.ToString())?.clanId ?? 0;
                if (clanId != 0)
                {
                    IClan clan = null;
                    if (ClanManager.ServerInstance.Backend?.TryGet(clanId, out clan) ?? false)
                    {
                        foreach (ClanMember member in clan.Members)
                        {
                            friend = BasePlayer.FindAwakeOrSleeping(member.SteamId.ToString());
                            if (friend != null)
                            {
                                CoolDown = new CooldownTime();
                                CoolDown.IsOnline = friend.IsConnected;
                                CoolDown.IgnoreOnline = false;
                                CoolDown.Time = DateTime.Now.AddMinutes(_config._PlayerCoolDown + extra);
                                AddSinglePlayerCooldown(member.SteamId, quarryinfo, CoolDown);
                            }
                        }
                    }
                }
            }
        }

        void AddSinglePlayerCooldown(ulong PlayerID, QuarryInfo quarryinfo, CooldownTime Cooldown)
        {
			// filter some bogus 0 entry comming from Team and Clan plugin
            if (PlayerID == 0) return;
            if (quarryinfo.PlayerCooldown.ContainsKey(PlayerID))
            {
                quarryinfo.PlayerCooldown[PlayerID] = Cooldown;
            }
            else
            {
                quarryinfo.PlayerCooldown.Add(PlayerID, Cooldown);
            }
        }

        bool isEntityInDynamicPVP(BaseEntity entity)
        {
            if (!IspluginLoaded(ZoneManager) || !IspluginLoaded(DynamicPVP)) return false;

            var zones = (string[])ZoneManager.Call("GetEntityZoneIDs", entity);
            foreach (var zone in zones)
            {
                if ((bool)DynamicPVP.Call("IsDynamicPVPZone", zone)) return true;
            }
            return false;
        }

        bool IspluginLoaded(Plugin a) => (a?.IsLoaded ?? false);

        #endregion Helpers

        #region Commands
        private void Quarry_info(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (player == null) return;

            SendChatMessage(player, "QuarryInfoCmd");

            foreach (var KVP in Quarrys)
            {
                MiningQuarry quarry = KVP.Value.Quarry;
                if (quarry == null) continue;
                if (!KVP.Value.EnableLock) continue;
                if (_config.UseDynamicPVP && isEntityInDynamicPVP(quarry)) continue;

                var remaining = Math.Max(0, (KVP.Value.FuelTimeRemaining + _config.CoolDown) - (DateTime.Now - KVP.Value.checkfueltime).TotalMinutes);

                if (remaining > 0)
                {
                    SendChatMessage(player, "QuarryAvailableIn2", KVP.Value.Name, Math.Ceiling(remaining), KVP.Value.readablename, KVP.Value.displayName);
                }
                else
                {
                    SendChatMessage(player, "QuarryStoped_B", KVP.Value.displayName, KVP.Value.Name, KVP.Value.readablename);
                }

                var checkcooldown = CheckPlayerCooldown((ulong)player.userID, KVP.Value);
                if (checkcooldown)
                {
                    SendChatMessage(player, "QuarryPlCooldown", PlayerCooldownTime((ulong)player.userID, KVP.Value), KVP.Value.readablename);
                }                
            }

            return;
        }

        
        private void Quarry_clearstatus(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (iplayer.Id == "server_console" ||
                (player != null && IsAdmin((ulong)player.userID)))
            {
                foreach (var quarry in Quarrys)
                {
                    ClearQuarry(quarry.Value);

                }

                if (player != null)
                {
                    SendChatMessage(player, "QuarryClearStatus");
                    PrintWarning(Lang("Quarryclearstatus", player.UserIDString));
                }
                else
                {
                    PrintWarning(Lang("Quarryclearstatus", "0"));
                }

                SaveData();
                PrintToLog($"Quarry clear status {iplayer.Id} ");
            }

            return;
        }
        
        private void Mining_stopcommand(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (player == null) return;
            
            MiningQuarry quarry = null;
            List<MiningQuarry> quarries = Pool.Get<List<MiningQuarry>>();
            Vis.Entities<MiningQuarry>(player.transform.position, 20f, quarries, -1);
            if (quarries.Count > 0)
            {
                quarry = quarries[0];
                var distance = Vector3Ex.Distance2D(player.transform.position, quarries[0].transform.position);
            }
            Pool.FreeUnmanaged(ref quarries);

            QuarryInfo quarryinfo;
            if ((quarry == null) ||
                !Quarrys.TryGetValue(quarry.net.ID.Value, out quarryinfo))
            {
                SendChatMessage(player, "NoQuarryFoundNear");
                return;
            }

            StorageContainer fuelstorage = quarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>();
            StorageContainer hopper  = quarry.hopperPrefab.instance.GetComponent<StorageContainer>();
            if (fuelstorage == null || hopper == null) { Puts("missing storage in Mining_stopcommand"); return; }

            int fuelmoved = 0;
            if (((ulong)player.userID == quarryinfo.playerid) ||
                (SameTeam((ulong)player.userID, quarryinfo.playerid)) ||
                (SameClan((ulong)player.userID, quarryinfo.playerid)))
            {
                List<Item> items = fuelstorage.inventory.FindItemsByItemID(1568388703);    // lowgradefuel == -946369541, Diesel == 1568388703
                foreach (Item item in items)
                {
                    if (!item.MoveToContainer(hopper.inventory, -1, true, false, null, true))
                    {
                        item.Drop(hopper.GetDropPosition(), hopper.GetDropVelocity(), default(Quaternion));
                    }
                    fuelmoved += item.amount;
                }
                SendChatMessage(player, "MoveFuelToOutput");
                PrintToLog($"Quarry stop command by {player.displayName}/{(ulong)player.userID}  at {quarryinfo.Name}. moving {fuelmoved} fuel ");
            }
            else SendChatMessage(player, "NoQuarryFoundNear");

            return;
        }
        

        #endregion Commands

        #region Helpers

        void ClearQuarry(QuarryInfo quarry, bool clearcooldownlist = true)
        {
            quarry.playerid = 0;
            quarry.displayName = "nobody";
            quarry.FuelTimeRemaining = 0f;
            quarry.state = false;
            quarry.PlayerDisconnectTime = DateTime.MaxValue;

            quarry.checkfueltime = DateTime.MinValue;
            quarry.stoptime = DateTime.MinValue;
            if (clearcooldownlist) quarry.PlayerCooldown = new Dictionary<ulong, CooldownTime>();
        }

        bool IsQuarryAvailable(QuarryInfo quarryinfo)
        {
            quarryinfo.state = quarryinfo.Quarry.IsEngineOn();
            // check if quarry is off longer then cooldown
            if ((quarryinfo.state == false) && ((DateTime.Now - quarryinfo.stoptime).TotalMinutes > _config.CoolDown))            
            {
                // enough time elapse, allow loot, clear owner info
                quarryinfo.playerid = 0;
                quarryinfo.displayName = "nobody";
                quarryinfo.PlayerDisconnectTime = DateTime.MaxValue;
                return true;
            }
            return false;
        }

        private static void DropItemContainer(ItemContainer itemContainer, Vector3 dropPosition, Quaternion rotation) => itemContainer?.Drop(PREFAB_ITEM_DROP, dropPosition, rotation, 0);

        string ReportInventory(StorageContainer storage)
        {
            StringBuilder Report = new StringBuilder(" [");
            int itemcount;
            int count = 0;
            foreach (var itemstr in _config.ReportItems)
            {
                Item item = storage.inventory.FindItemByItemName(itemstr);
                if (item == null) continue;
                itemcount = storage.inventory.GetTotalItemAmount(item, 0, storage.inventory.capacity - 1);
                if (count != 0) Report.Append(", ");
                Report.Append(string.Format("{1} {0}", item.info.displayName.english, itemcount.ToString()));
                count++;
            }
            if (count == 0) Report.Append("Empty");
            Report.Append("]");
            return Report.ToString();
        }

        private void PrintToLog(string message)
        {
            if (_config.Debug)
                UnityEngine.Debug.Log($"[{_instance.Name}] [{DateTime.Now.ToString("h:mm tt")}]{Platform} {message}");

            if (_config.LogToFile)
                LogToFile(TraceFile, $"[{DateTime.Now.ToString("h:mm tt")}]{Platform} {message}", this);

            if (_config.Discordena)
                PrintToDiscord(message);
        }


        private bool IsAdmin(ulong id) =>
            (permission.UserHasPermission(id.ToString(), _config.PermissionAdmin));
        private bool IsAdmin(string id) =>
            (permission.UserHasPermission(id, _config.PermissionAdmin));


        private bool CanPlayerUseQuarry(ulong id) =>
            (!_config.UsePermission || 
                permission.UserHasPermission(id.ToString(), _config.PermissionUseQuarry) ||
                permission.UserHasPermission(id.ToString(), _config.PermissionAdmin));
        private bool CanPlayerUsePump(ulong id) =>
            (!_config.UsePermission ||
                permission.UserHasPermission(id.ToString(), _config.PermissionUsePump) ||
                permission.UserHasPermission(id.ToString(), _config.PermissionAdmin));

        private bool CanPlayerBypassCooldown(ulong id) =>
            (!_config.UsePermission ||
                permission.UserHasPermission(id.ToString(), _config.PermissionBypassCooldown) ||
                permission.UserHasPermission(id.ToString(), _config.PermissionAdmin));        

        private bool SameClan(ulong playerID, ulong friendID)
        {
            if (_config.UseClans == true && IspluginLoaded(Clans))
            {
                //Clans
                var isMember = Clans.Call("IsClanMember", playerID.ToString(), friendID.ToString());
                if (isMember != null && (bool)isMember) return true;
            }

            if (_config.UseClanTable == true)
            {
                long playerclan = BasePlayer.FindAwakeOrSleeping(playerID.ToString())?.clanId ?? 0;
                IClan clan = null;
                if (playerclan != 0 && (ClanManager.ServerInstance.Backend?.TryGet(playerclan, out clan) ?? false))
                {
                    foreach (ClanMember member in clan.Members)
                    {
                        if (member.SteamId == friendID) return true;
                    }
                }
            }

            return false;
        }

        // Check if in same team
        private bool SameTeam(ulong playerID, ulong friendID)
        {
            if (playerID==0 || friendID==0 || _config.UseTeams == false) return false;

            var teammanager = RelationshipManager.ServerInstance;
            if (teammanager == null) return false;

            var team = teammanager.FindPlayersTeam(playerID);
            if (team == null) return false;

            if (team.members.Contains(friendID)) return true;
            return false;
        }

        private void BroadcastMessage(string msg, params object[] args)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                SendChatMessage(player, msg, args);                
            }
        }

        public void SendChatMessage(BasePlayer player, string msg, params object[] args)
        {
            for (int i = 0; i < args.Length; i++)
            {
                if (args[i] is string) args[i] = (object)Lang(args[i] as string, player.UserIDString);
            }

            if (_config.useNotify && IspluginLoaded(Notify))
            {
                Notify.Call("SendNotify", player, 0, Lang(msg, player.UserIDString, args));
            }
            else
            {
                player.ChatMessage(Lang(msg, player.UserIDString, args));
            }
        }

        private void PrintToDiscord(string message, double seconds = 0)
        {
            if (_discord == null) return;

            if (_discord.MsgCooldown <= DateTime.Now.ToBinary())
            {
                _discord.MsgCooldown = DateTime.Now.AddSeconds(seconds).ToBinary();
               
                long unixTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();                
                if (_config.UseDiscordTimestamp)
                    _discord.SendTextMessage($"[<t:{unixTime}:t>]{Platform} {message}");
                else
                    _discord.SendTextMessage($"[{DateTime.Now.ToString("h:mm tt")}]{Platform} {message}");
            }
        }

        private string PositionToString(Vector3 position) => MapHelper.PositionToString(position);


        #endregion helpers

        //######################################################
        #region Shared.Components

        private class DiscordComponent : MonoBehaviour
        {
            private const float PostDelay = 2.5f; // set min 2 sec delay between two discord post, rate limit
            public long MsgCooldown = DateTime.Now.ToBinary();

            private readonly Queue<object> _queue = new Queue<object>();
            private string _url;
            private bool _busy = false;

            public DiscordComponent Configure(string url)
            {
                if (url == null) throw new ArgumentNullException(nameof(url));
                _url = url;

                return this;
            }

            public DiscordComponent SendTextMessage(string message, params object[] args)
            {
                message = args.Length > 0 ? string.Format(message, args) : message;
                return AddQueue(new MessageRequest(message));
            }

#region Send requests to server

            private DiscordComponent AddQueue(object request)
            {
                _queue.Enqueue(request);

                if (!_busy)
                    StartCoroutine(ProcessQueue());

                return this;
            }

            private IEnumerator ProcessQueue()
            {
                if (_busy) yield break;
                _busy = true;

                while (_queue.Count != 0)
                {
                    var request = _queue.Dequeue();
                    yield return ProcessRequest(request);
                }

                _busy = false;
            }
            
            private IEnumerator ProcessRequest(object request)
            {
                if (string.IsNullOrEmpty(_url))
                {
                    print("[ERROR] Discord webhook URL wasn't specified");
                    yield break;
                }

                var data = System.Text.Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(request));
                var uh = new UploadHandlerRaw(data) { contentType = "application/json" };
                var www = UnityWebRequest.PostWwwForm(_url, UnityWebRequest.kHttpVerbPOST);
                www.uploadHandler = uh;

                yield return www.SendWebRequest();

                if (www.result == UnityWebRequest.Result.ConnectionError || www.result == UnityWebRequest.Result.ProtocolError)
                    print($"ERROR: {www.error} | {www.downloadHandler?.text}");

                www.Dispose();

                // to avoid spam requests to Discord
                yield return new WaitForSeconds(PostDelay);
            }            

#endregion


#region Requests
            private class MessageRequest
            {
                [JsonProperty("content")]
                public string Content { get; set; }

                public MessageRequest(string content)
                {
                    if (content == null) throw new ArgumentNullException(nameof(content));
                    Content = content;
                }
            }

#endregion
        }
#endregion

#region proximity
        // This component adds a method to evaluate if quarry is stopped from fuel or full output 
        public class QuarryDetector : MonoBehaviour
        {
            private MiningQuarry quarry;
            private bool state;

            void Awake()
            {
                quarry = GetComponent<MiningQuarry>();

                state = quarry.IsEngineOn();

                // randomize the start of the invoke to avoid server lag if all quarry evaluate at the same time
                var delay = Oxide.Core.Random.Range(0f, 2.0f);
                InvokeRepeating("CheckMiningQuarry", delay, 2.0f);
            }

            void OnDestroy() => CancelInvoke("CheckMiningQuarry");

            void CheckMiningQuarry()
            {
                if (!quarry.IsEngineOn() && state)    // switch off
                {
                    state = false;
                    notifyQuarryStopped(quarry);
                }
                else if (quarry.IsEngineOn() && !state) // switch on
                {
                    state = true;
                }
            }

            void notifyQuarryStopped(MiningQuarry quarry) => Interface.Oxide.CallHook("OnQuarryToggledOff", quarry);
        }

#endregion


    }
}

// --- End of file: PublicQuarryLock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/path-finding ---
// --- Original File Path: P/PathFinding/PathFinding.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine;
using static UnityEngine.Vector3;

namespace Oxide.Plugins
{
    [Info("PathFinding", "Reneb / Nogrod", "1.1.3", ResourceId = 868)]
    [Description("Path finding API, used by other plugins only")]
    public class PathFinding : RustPlugin
    {
        private static readonly Vector3 Up = up;
        public sealed class PathFinder
        {
            private static readonly sbyte[,] Direction = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}, {1, -1}, {1, 1}, {-1, 1}, {-1, -1}};
            public static readonly Vector3 EyesPosition;
            public static readonly uint Size;
            public static PriorityQueue OpenList;
            public static PathFindNode[,] Grid;

            static PathFinder()
            {
                EyesPosition = new Vector3(0f, 1.6f, 0f);
                OpenList = new PriorityQueue(MaxDepth * Direction.GetLength(0)); // 8 directions for each node
                Size = World.Size;
                Grid = new PathFindNode[Size, Size];
                //Interface.Oxide.LogInfo("Queue: {0} Grid: {1} Size: {2}", OpenList.MaxSize, Grid.Length, Size);
            }

            public List<Vector3> FindPath(Vector3 sourcePos, Vector3 targetPos)
            {
                //Interface.Oxide.LogInfo("Queue: {0} Grid: {1}", OpenList.MaxSize, Grid.Length);
                var closedList = new HashSet<PathFindNode>();

                var targetNode = new PathFindNode(targetPos);
                if (targetNode.X < 0 || targetNode.X >= Size || targetNode.Z < 0 || targetNode.Z >= Size) return null;
                Grid[targetNode.X, targetNode.Z] = targetNode;

                var startNode = new PathFindNode(sourcePos);
                if (startNode.X < 0 || startNode.X >= Size || startNode.Z < 0 || startNode.Z >= Size) return null;
                Grid[startNode.X, startNode.Z] = startNode;
                OpenList.Enqueue(startNode);
                //PathFindNode closestNode = null;

                while (OpenList.Count > 0)
                {
                    var currentNode = OpenList.Dequeue();
                    if (currentNode == targetNode)
                    {
                        Clear();
                        return RetracePath(startNode, targetNode);
                    }
                    closedList.Add(currentNode);
                    for (var i = 0; i < 8; i++)
                    {
                        var dirX = Direction[i, 0];
                        var dirZ = Direction[i, 1];
                        var x = currentNode.X + dirX;
                        var z = currentNode.Z + dirZ;
                        if (x < 0 || x >= Size || z < 0 || z >= Size) continue;
                        var neighbour = FindPathNodeOrCreate(x, z, currentNode.Position.y);
                        //Interface.Oxide.LogInfo("Checking neighbour: {0} {1} {2} {3} {4}", x, z, neighbour.Position, closedList.Contains(neighbour), neighbour.Walkable);
                        if (!neighbour.Walkable) continue;
                        var newGScore = currentNode.G + GetDistance(currentNode, neighbour);
                        if (newGScore >= neighbour.G && closedList.Contains(neighbour)) continue;
                        if (newGScore < neighbour.G || !OpenList.Contains(neighbour))
                        {
                            //foreach (var player in BasePlayer.activePlayerList)
                            //    player.SendConsoleCommand("ddraw.sphere", 30f, Color.black, neighbour.Position, .25f);
                            neighbour.G = newGScore;
                            neighbour.H = GetDistance(neighbour, targetNode);
                            neighbour.F = newGScore + neighbour.H;
                            neighbour.Parent = currentNode;
                            if (!OpenList.Contains(neighbour))
                                OpenList.Enqueue(neighbour);
                            else
                                OpenList.Update(neighbour);
                            //if (closestNode == null || newGScore < closestNode.G)
                            //    closestNode = neighbour;
                        }
                    }
                    if (closedList.Count > MaxDepth)
                    {
                        //Interface.Oxide.LogWarning("[PathFinding] Hit MaxDepth!");
                        break;
                    }
                }
                Clear();
                //if (closestNode != null)
                //    return RetracePath(startNode, closestNode);
                return null;
            }

            private static void Clear()
            {
                OpenList.Clear();
                Array.Clear(Grid, 0, Grid.Length);
            }

            private static List<Vector3> RetracePath(PathFindNode startNode, PathFindNode endNode)
            {
                var path = new List<Vector3>();
                while (endNode != startNode)
                {
                    path.Add(endNode.Position);
                    endNode = endNode.Parent;
                }
                path.Reverse();
                //path.RemoveAt(0);
                return path;
            }

            private static int GetDistance(PathFindNode nodeA, PathFindNode nodeB)
            {
                var dstX = Math.Abs(nodeA.X - nodeB.X);
                var dstZ = Math.Abs(nodeA.Z - nodeB.Z);
                var dstY = Math.Abs(nodeA.Position.y - nodeB.Position.y);

                if (dstX > dstZ)
                    return 14*dstZ + 10*(dstX - dstZ) + (int)(10*dstY);
                return 14*dstX + 10*(dstZ - dstX) + (int)(10*dstY);
            }

            private static PathFindNode FindPathNodeOrCreate(int x, int z, float y)
            {
                var node = Grid[x, z];
                if (node != null) return node;
                var halfGrid = Size/2f;
                var groundPos = new Vector3(x - halfGrid, y, z - halfGrid);
                //groundPos.y = TerrainMeta.HeightMap.GetHeight(groundPos);
                FindRawGroundPosition(groundPos, out groundPos);
                Grid[x, z] = node = new PathFindNode(groundPos);
                return node;
            }
        }

        public sealed class PriorityQueue
        {
            private readonly PathFindNode[] nodes;
            private int numNodes;

            public PriorityQueue(int maxNodes)
            {
                numNodes = 0;
                nodes = new PathFindNode[maxNodes + 1];
            }

            public int Count => numNodes;

            public int MaxSize => nodes.Length - 1;

            public void Clear()
            {
                Array.Clear(nodes, 1, numNodes);
                numNodes = 0;
            }

            public bool Contains(PathFindNode node)
            {
                return nodes[node.QueueIndex] == node;
            }

            public void Update(PathFindNode node)
            {
                SortUp(node);
            }

            public void Enqueue(PathFindNode node)
            {
                nodes[++numNodes] = node;
                node.QueueIndex = numNodes;
                SortUp(node);
            }

            private void Swap(PathFindNode node1, PathFindNode node2)
            {
                nodes[node1.QueueIndex] = node2;
                nodes[node2.QueueIndex] = node1;

                var temp = node1.QueueIndex;
                node1.QueueIndex = node2.QueueIndex;
                node2.QueueIndex = temp;
            }

            private void SortUp(PathFindNode node)
            {
                var parent = node.QueueIndex/2;
                while (parent > 0)
                {
                    var parentNode = nodes[parent];
                    if (CompareTo(parentNode, node) >= 0)
                        break;

                    Swap(node, parentNode);

                    parent = node.QueueIndex/2;
                }
            }

            private void SortDown(PathFindNode node)
            {
                var finalQueueIndex = node.QueueIndex;
                while (true)
                {
                    var newParent = node;
                    var childLeftIndex = 2*finalQueueIndex;

                    if (childLeftIndex > numNodes)
                    {
                        node.QueueIndex = finalQueueIndex;
                        nodes[finalQueueIndex] = node;
                        break;
                    }

                    var childLeft = nodes[childLeftIndex];
                    if (CompareTo(childLeft, newParent) >= 0)
                    {
                        newParent = childLeft;
                    }

                    var childRightIndex = childLeftIndex + 1;
                    if (childRightIndex <= numNodes)
                    {
                        var childRight = nodes[childRightIndex];
                        if (CompareTo(childRight, newParent) >= 0)
                        {
                            newParent = childRight;
                        }
                    }

                    if (newParent != node)
                    {
                        nodes[finalQueueIndex] = newParent;

                        var temp = newParent.QueueIndex;
                        newParent.QueueIndex = finalQueueIndex;
                        finalQueueIndex = temp;
                    }
                    else
                    {
                        node.QueueIndex = finalQueueIndex;
                        nodes[finalQueueIndex] = node;
                        break;
                    }
                }
            }

            public PathFindNode Dequeue()
            {
                var node = nodes[1];
                Remove(node);
                return node;
            }

            public void Remove(PathFindNode node)
            {
                if (node.QueueIndex == numNodes)
                {
                    nodes[numNodes--] = null;
                    return;
                }

                var formerLastNode = nodes[numNodes];
                Swap(node, formerLastNode);
                nodes[numNodes--] = null;

                var parentIndex = formerLastNode.QueueIndex/2;
                var parentNode = nodes[parentIndex];

                if (parentIndex > 0 && CompareTo(formerLastNode, parentNode) >= 0)
                    SortUp(formerLastNode);
                else
                    SortDown(formerLastNode);
            }

            private static int CompareTo(PathFindNode node, PathFindNode other)
            {
                if (node.F == other.F)
                {
                    if (node.H == other.H)
                        return 0;
                    if (node.H > other.H)
                        return -1;
                    return 1;
                }
                if (node.F > other.F)
                    return -1;
                return 1;
            }
        }

        public sealed class PathFindNode
        {
            public readonly int X;
            public readonly int Z;
            public int QueueIndex;
            public float H;
            public float G;
            public float F;
            public PathFindNode Parent;
            public Vector3 Position;
            public bool Walkable;

            public PathFindNode(Vector3 position)
            {
                Position = position;
                X = (int) Math.Round(position.x + PathFinder.Size/2f);
                Z = (int) Math.Round(position.z + PathFinder.Size/2f);
                Walkable = !Physics.CheckSphere(position + PathFinder.EyesPosition, .801f, blockLayer);
            }

            public override int GetHashCode()
            {
                return X << 16 | Z;
            }
        }

        public static bool FindRawGroundPosition(Vector3 sourcePos, out Vector3 groundPos)
        {
            groundPos = sourcePos;
            RaycastHit hitinfo;
            if (Physics.Raycast(sourcePos + Up, down, out hitinfo, 50, groundLayer))
            {
                groundPos.y = Math.Max(hitinfo.point.y, TerrainMeta.HeightMap.GetHeight(groundPos));
                return true;
            }
            if (Physics.Raycast(sourcePos - Up, Up, out hitinfo, 1.5f, groundLayer))
            {
                groundPos.y = Math.Max(hitinfo.point.y, TerrainMeta.HeightMap.GetHeight(groundPos));
                return true;
            }
            return false;
        }

        private class PathFollower : MonoBehaviour
        {
            public List<Vector3> Paths = new List<Vector3>();
            public float secondsTaken;
            public float secondsToTake;
            public float waypointDone;
            public float speed;
            public Vector3 StartPos;
            public Vector3 EndPos;
            public Vector3 nextPos;
            public BaseEntity entity;
            public BasePlayer player;

            private void Awake()
            {
                entity = GetComponent<BaseEntity>();
                player = GetComponent<BasePlayer>() ?? player;
                speed = 4f;
            }

            private void Move()
            {
                if (secondsTaken == 0f) FindNextWaypoint();
                Execute_Move();
                if (waypointDone >= 1f) secondsTaken = 0f;
            }

            private void Execute_Move()
            {
                if (StartPos == EndPos) return;
                secondsTaken += Time.deltaTime;
                waypointDone = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
                nextPos = Lerp(StartPos, EndPos, waypointDone);
                entity.transform.position = nextPos;
                player?.ClientRPCPlayer(null, player, "ForcePositionTo", nextPos);
            }

            private void FindNextWaypoint()
            {
                if (Paths.Count == 0)
                {
                    StartPos = EndPos = zero;
                    enabled = false;
                    return;
                }
                SetMovementPoint(Paths[0], 4f);
            }

            public void SetMovementPoint(Vector3 endpos, float s)
            {
                StartPos = entity.transform.position;
                if (endpos != StartPos)
                {
                    EndPos = endpos;
                    secondsToTake = Distance(EndPos, StartPos)/s;
                    entity.transform.rotation = Quaternion.LookRotation(EndPos - StartPos);
                    if (player != null) SetViewAngle(player, entity.transform.rotation);
                    secondsTaken = 0f;
                    waypointDone = 0f;
                }
                Paths.RemoveAt(0);
            }

            private void SetViewAngle(BasePlayer player, Quaternion ViewAngles)
            {
                player.viewAngles = ViewAngles.eulerAngles;
                player.SendNetworkUpdate();
            }

            private void FixedUpdate()
            {
                Move();
            }
        }

        public static Vector3 jumpPosition = new Vector3(0f, 1f, 0f);
        public static int groundLayer;
        public static int blockLayer;
        private static int MaxDepth = 5000;

        protected override void LoadDefaultConfig()
        {
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T) Config[Key];
            else
                Config[Key] = var;
        }

        private void Init()
        {
            CheckCfg("Max Depth", ref MaxDepth);
            SaveConfig();
        }

        /////////////////////////////////////////////
        /// OXIDE HOOKS
        /////////////////////////////////////////////
        private void OnServerInitialized()
        {
            groundLayer = LayerMask.GetMask("Terrain", "World", "Construction", "Deployed", "Default");
            blockLayer = LayerMask.GetMask("World", "Construction", "Tree", "Deployed", "Default");

            timer.Once(30f, ResetPathFollowers);
        }

        private void Unload()
        {
            var objects = UnityEngine.Object.FindObjectsOfType<PathFollower>();
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);
            PathFinder.OpenList = null;
            PathFinder.Grid = null;
        }

        /////////////////////////////////////////////
        /// Outside Plugin Calls
        /////////////////////////////////////////////
        private bool FindAndFollowPath(BaseEntity entity, Vector3 sourcePosition, Vector3 targetPosition)
        {
            //var curtime = Time.realtimeSinceStartup;
            var bestPath = FindBestPath(sourcePosition, targetPosition);
            //Debug.Log((Time.realtimeSinceStartup - curtime).ToString());
            if (bestPath == null) return false;
            FollowPath(entity, bestPath);
            return true;
        }

        private void FollowPath(BaseEntity entity, List<Vector3> pathpoints)
        {
            var pathfollower = entity.GetComponent<PathFollower>() ?? entity.gameObject.AddComponent<PathFollower>();
            pathfollower.Paths = pathpoints;
            pathfollower.enabled = true;
        }

        [HookMethod("FindBestPath")]
        public List<Vector3> FindBestPath(Vector3 sourcePosition, Vector3 targetPosition)
        {
            return FindLinePath(sourcePosition, targetPosition) ?? FindPath(sourcePosition, targetPosition);
        }

        public List<Vector3> Go(Vector3 source, Vector3 target)
        {
            return FindLinePath(source, target) ?? FindPath(source, target);
        }

        private List<Vector3> FindPath(Vector3 sourcePosition, Vector3 targetPosition)
        {
            //Puts("FindPath: {0} {1}", sourcePosition, targetPosition);
            return new PathFinder().FindPath(sourcePosition, targetPosition);
        }

        private List<Vector3> FindLinePath(Vector3 sourcePosition, Vector3 targetPosition)
        {
            var distance = (int) Math.Ceiling(Distance(sourcePosition, targetPosition));
            if (distance <= 0) return null;
            var straightPath = new List<Vector3>(new Vector3[distance]) {[distance - 1] = targetPosition};
            var currentPos = Lerp(sourcePosition, targetPosition, 1f / distance);
            Vector3 groundPosition;
            if (!FindRawGroundPosition(currentPos, out groundPosition)) return null;
            if (Distance(groundPosition, sourcePosition) > 2) return null;
            if (Physics.Linecast(sourcePosition + jumpPosition, groundPosition + jumpPosition, blockLayer)) return null;
            straightPath[0] = groundPosition;
            for (var i = 1; i < distance - 1; i++)
            {
                currentPos = Lerp(sourcePosition, targetPosition, (i + 1f)/distance);
                if (!FindRawGroundPosition(currentPos, out groundPosition)) return null;
                if (Distance(groundPosition, straightPath[i - 1]) > 2) return null;
                if (Physics.Linecast(straightPath[i - 1] + jumpPosition, groundPosition + jumpPosition, blockLayer)) return null;
                straightPath[i] = groundPosition;
            }
            if (Physics.Linecast((distance == 1 ? sourcePosition : straightPath[distance - 2]) + jumpPosition, targetPosition + jumpPosition, blockLayer)) return null;
            return straightPath;
        }

        /////////////////////////////////////////////
        /// Reset part of the plugin
        /////////////////////////////////////////////
        private void ResetPathFollowers()
        {
            var objects = UnityEngine.Object.FindObjectsOfType<PathFollower>();
            foreach (var gameObj in objects)
                if (gameObj.Paths.Count == 0)
                    UnityEngine.Object.Destroy(gameObj);
        }

        /////////////////////////////////////////////
        /// Debug Command
        /////////////////////////////////////////////
        [ChatCommand("path")]
        private void cmdChatPath(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1) return;
            Quaternion currentRot;
            if (!TryGetPlayerView(player, out currentRot)) return;
            object closestEnt;
            Vector3 closestHitpoint;
            if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;

            FindAndFollowPath(player, player.transform.position, closestHitpoint);
        }

        private bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            if (player.serverInput.current == null) return false;
            viewAngle = Quaternion.Euler(player.serverInput.current.aimAngles);
            return true;
        }

        private bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            var sourceEye = sourcePos + PathFinder.EyesPosition;
            var ray = new Ray(sourceEye, sourceDir*forward);

            var hits = Physics.RaycastAll(ray);
            var closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;
            for (var i = 0; i < hits.Length; i++)
            {
                var hit = hits[i];
                if (hit.collider.GetComponentInParent<TriggerBase>() == null && hit.distance < closestdist)
                {
                    closestdist = hit.distance;
                    closestEnt = hit.collider;
                    closestHitpoint = hit.point;
                }
            }

            if (closestEnt is bool) return false;
            return true;
        }
    }
}


// --- End of file: PathFinding.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-loot-logs ---
// --- Original File Path: P/PlayerLootLogs/PlayerLootLogs.cs ---

using Oxide.Core.Plugins;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
#pragma warning disable 0649
namespace Oxide.Plugins
{
    [Info("Player Loot Logs", "hizentv + Irish", "1.5.2")]
    [Description("Detailed logging for player looting events. Optionally log to Console, File, and/or Discord.")]
    class PlayerLootLogs : RustPlugin
    {
        #region Plugin Reference
        [PluginReference] private Plugin DiscordLogger;
        #endregion
        #region Configuration
        class PlayerLootLogConfig
        {
            public enum LootTarget
            {
                Player,
                PlayerTeam,
                PlayerCorpse
            }

            public Dictionary<LootTarget, bool> Tracking { get; set; }
            public LogSource Console { get; set; } = new LogSource();
            public FileLogSource File { get; set; } = new FileLogSource();
            public DiscordLogSource Discord { get; set; } = new DiscordLogSource();

            public PlayerLootLogConfig InitDefaults()
            {
                if (Tracking == null)
                {
                    Tracking = new Dictionary<LootTarget, bool>();
                }
                foreach (LootTarget target in Enum.GetValues(typeof(LootTarget)))
                {
                    if (!Tracking.ContainsKey(target))
                    {
                        Tracking[target] = true;
                    }
                }
                Console = Console ?? new LogSource();
                File = File ?? new FileLogSource();
                Discord = Discord ?? new DiscordLogSource();
                return this;
            }

            public bool IsTracking(BasePlayer player, BaseEntity target)
            {
                if (target is NPCPlayer || target is NPCPlayerCorpse)
                {
                    return false;
                }
                if (target is BasePlayer)
                {
                    return Tracking[LootTarget.Player] && IsTrackingTeam(player, target);
                }
                else if (target is PlayerCorpse)
                {
                    return Tracking[LootTarget.PlayerCorpse] && IsTrackingTeam(player, target);
                }
                return false;
            }

            private bool IsTrackingTeam(BasePlayer player, BaseEntity target) => Tracking[LootTarget.PlayerTeam] ||
                !(player.Team?.members?.Contains(new PlayerInfo(target).SteamID) ?? false);

            public class LogSource
            {
                const string defaultPrefix = "[{0:yyyy/MM/dd HH:mm:ss}] ";
                public bool Enabled { get; set; }
                public string FormatLootGive { get; set; } = defaultPrefix + "{8} gave {3} ({4}) to {1}";
                public string FormatLootTake { get; set; } = defaultPrefix + "{8} looted {3} ({4}) from {1}";
                public string FormatLootDropSelf { get; set; } =
                    defaultPrefix + "{8} dropped {3} ({4}) while looting {1}";
                public string FormatLootDropTarget { get; set; } = defaultPrefix + "{8} dropped {3} ({4}) from {1}";

                public enum LootAction
                {
                    Add,
                    Take,
                    DropSelf,
                    DropTarget
                }

                private string GetFormat(LootAction type)
                {
                    switch (type)
                    {
                        case LootAction.Add: return FormatLootGive;
                        case LootAction.Take: return FormatLootTake;
                        case LootAction.DropSelf: return FormatLootDropSelf;
                        case LootAction.DropTarget: return FormatLootDropTarget;
                        default: throw new ArgumentException($"Type '{type}' not supported.", nameof(type));
                    }
                }

                public string FormatMessage(LootAction lootType, LootChange change, LootItem item,
                    params PlayerInfo[] looters) => FormatMessage(GetFormat(lootType), change, item, looters);

                private string FormatMessage(string format, LootChange change, LootItem item,
                    params PlayerInfo[] looters) => string.Format(format,
                    change.Timestamp,
                    change.Target.DisplayName,
                    change.Target.SteamID,
                    item.Name,
                    Math.Abs(item.Amount),
                    item.Condition,
                    item.ConditionMax,
                    item.ConditionPercent,
                    string.Join(", ", looters.Select(looter => looter.DisplayName)),
                    string.Join(", ", looters.Select(looter => looter.SteamIDString)),
                    string.Join(", ", looters.Select(looter => $"{looter.DisplayName}{looter.SteamID}]")),
                    change.Target.Location.x.ToString("0"),
                    change.Target.Location.y.ToString("0"),
                    change.Target.Location.z.ToString("0")
                );
            }

            public class FileLogSource : LogSource
            {
                public string FileNameFormat { get; set; } = "{0:yyyyMMdd}";
                public int DelaySeconds { get; set; } = 60;
            }

            public class DiscordLogSource : LogSource
            {
                public string WebHookUrl { get; set; } = string.Empty;
            }
        }

        PlayerLootLogConfig config;

        protected override void LoadDefaultConfig() =>
            Config.WriteObject(new PlayerLootLogConfig().InitDefaults(), true);
        #endregion
        #region System Hooks

        void Init()
        {
            config = Config.ReadObject<PlayerLootLogConfig>().InitDefaults();
            if (!config.File.Enabled && !config.Discord.Enabled && !config.Console.Enabled)
            {
                Puts("No logging configuration is enabled.");
                return;
            }
            if (config.File.Enabled)
            {
                if (string.IsNullOrWhiteSpace(config.File.FileNameFormat))
                {
                    Puts(
                        $"Setting '{nameof(PlayerLootLogConfig.File)}:{nameof(PlayerLootLogConfig.FileLogSource.FileNameFormat)}' is empty, disabling file logging.");
                    config.File.Enabled = false;
                }
                else if (config.File.DelaySeconds <= 0)
                {
                    Puts(
                        $"Setting '{nameof(PlayerLootLogConfig.File)}:{nameof(PlayerLootLogConfig.FileLogSource.DelaySeconds)}' must be greater than 0, disabling file logging.");
                }
                else
                {
                    timer.Every(config.File.DelaySeconds, FlushLogQueue);
                }
            }
            if (config.Discord.Enabled)
            {
                if (string.IsNullOrWhiteSpace(config.Discord.WebHookUrl))
                {
                    Puts(
                        $"Setting '{nameof(PlayerLootLogConfig.Discord)}:{nameof(PlayerLootLogConfig.DiscordLogSource.WebHookUrl)}' is empty, disabling discord logging.");
                    config.Discord.Enabled = false;
                }
            }
            Config.WriteObject(config, true);
        }

        void Unload() => FlushLogQueue();
        #endregion
        #region Logging

        private void LogChange(LootChange change)
        {
            foreach (var looter in change.Looters)
            {
                if (change.ItemsModified[looter.SteamID].Any())
                {
                    foreach (var item in change.ItemsModified[looter.SteamID])
                    {
                        if (change.ItemsModified[change.Target.SteamID].Any(tItem =>
                                tItem.Id == item.Id && tItem.Amount == item.Amount * -1))
                        {
                            if (item.Amount > 0)
                            {
                                SendLog(PlayerLootLogConfig.LogSource.LootAction.Take, change, item, change.Looters);
                            }
                            else
                            {
                                SendLog(PlayerLootLogConfig.LogSource.LootAction.Add, change, item, change.Looters);
                            }
                        }
                        else
                        {
                            SendLog(PlayerLootLogConfig.LogSource.LootAction.DropSelf, change, item, change.Looters);
                        }
                    }
                }
            }
            foreach (var item in change.ItemsModified[change.Target.SteamID])
            {
                if (!change.ItemsModified.Where(im => im.Key != change.Target.SteamID).Any(im =>
                        im.Value.Any(li => li.Id == item.Id && li.Amount == item.Amount * -1)))
                {
                    SendLog(PlayerLootLogConfig.LogSource.LootAction.DropTarget, change, item, change.Looters);
                }
            }
        }

        public ConcurrentQueue<string> FileLogQueue { get; set; } = new ConcurrentQueue<string>();

        private void SendLog(PlayerLootLogConfig.LogSource.LootAction lootType, LootChange change, LootItem item,
            params PlayerInfo[] looters)
        {
            if (config.Console.Enabled)
            {
                Puts(config.Console.FormatMessage(lootType, change, item, looters));
            }
            if (config.File.Enabled)
            {
                FileLogQueue.Enqueue(config.File.FormatMessage(lootType, change, item, looters));
            }
            if (config.Discord.Enabled)
            {
                if (DiscordLogger == null || !DiscordLogger.IsLoaded)
                {
                    Puts($"Plugin {nameof(DiscordLogger)} must be installed in order to enable discord logging.");
                    config.Discord.Enabled = false;
                }
                else if (string.IsNullOrWhiteSpace(config.Discord.WebHookUrl))
                {
                    Puts(
                        $"Setting {nameof(PlayerLootLogConfig.Discord)}:{nameof(PlayerLootLogConfig.DiscordLogSource.WebHookUrl)} must be set to enable discord logging.");
                    config.Discord.Enabled = false;
                }
                else
                {
                    DiscordLogger.Call("DiscordSendMessage",
                        config.Discord.FormatMessage(lootType, change, item, looters), config.Discord.WebHookUrl);
                }
            }
        }

        bool isFlushingLogQueue = false;
        object flushLock = new object();

        private void FlushLogQueue()
        {
            var sb = new StringBuilder();
            string line;
            try
            {
                lock (flushLock)
                {
                    if (isFlushingLogQueue) return;
                    isFlushingLogQueue = true;
                }
                while (FileLogQueue.TryDequeue(out line))
                {
                    sb.AppendLine(line);
                }
                if (sb.Length > 0)
                {
                    LogToFile(string.Format(config.File.FileNameFormat, DateTimeOffset.Now), sb.ToString().Trim(),
                        this, false);
                }
            }
            finally
            {
                isFlushingLogQueue = false;
            }
        }
        #endregion
        #region Player Hooks

        void OnLootEntity(BasePlayer player, BaseEntity entity) => EnterLootEvent(player, entity);

        void OnLootNetworkUpdate(PlayerLoot loot)
        {
            if (loot != null
                && loot.baseEntity != null
                && loot.entitySource != null)
            {
                EnterLootEvent(loot.baseEntity, loot.entitySource);
            }
        }

        void OnInventoryNetworkUpdate(PlayerInventory inventory, ItemContainer container,
            ProtoBuf.UpdateItemContainer updateItemContainer, PlayerInventory.Type type, bool broadcast)
        {
            if (inventory == null)
            {
                return;
            }
            var player = inventory.baseEntity;
            if (player != null && LinkToLootEvent.ContainsKey(player.userID) &&
                TargetLootEvents.ContainsKey(LinkToLootEvent[player.userID]))
            {
                EnterLootEvent(player, TargetLootEvents[LinkToLootEvent[player.userID]].Target);
            }
        }

        void OnPlayerLootEnd(PlayerLoot inventory) => ExitLootEvent(inventory.baseEntity, inventory.entitySource);

        void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity) => ExitLootEvent(player, entity);
        #endregion
        #region Loot Events Methods

        private Dictionary<ulong, ulong> LinkToLootEvent { get; set; } = new Dictionary<ulong, ulong>();
        private Dictionary<ulong, LootEvent> TargetLootEvents { get; set; } = new Dictionary<ulong, LootEvent>();

        private void EnterLootEvent(BasePlayer player, BaseEntity target)
        {
            if (!config.IsTracking(player, target))
            {
                return;
            }
            if (target is BasePlayer || target is PlayerCorpse)
            {
                var targetPlayer = new PlayerInfo(target);
                if (targetPlayer.SteamID == player.userID)
                {
                    return;
                }
                if (!config.Tracking[PlayerLootLogConfig.LootTarget.PlayerTeam] && player?.Team?.members != null &&
                    player.Team.members.Contains(targetPlayer.SteamID))
                {
                    return;
                }
                LinkToLootEvent[player.userID] = targetPlayer.SteamID;
                if (TargetLootEvents.ContainsKey(targetPlayer.SteamID))
                {
                    LootChange change;
                    if (TargetLootEvents[targetPlayer.SteamID].RecordChange(player, target, out change))
                    {
                        LogChange(change);
                    }
                }
                else
                {
                    TargetLootEvents[targetPlayer.SteamID] = new LootEvent(player, target);
                }
            }
        }

        private void ExitLootEvent(BasePlayer player, BaseEntity target)
        {
            if (!config.IsTracking(player, target))
            {
                return;
            }
            if (target is BasePlayer || target is PlayerCorpse)
            {
                var targetPlayer = new PlayerInfo(target);
                if (TargetLootEvents.ContainsKey(targetPlayer.SteamID))
                {
                    TargetLootEvents[targetPlayer.SteamID].RemoveLooter(player);
                    if (!TargetLootEvents[targetPlayer.SteamID].Active)
                    {
                        TargetLootEvents.Remove(targetPlayer.SteamID);
                    }
                }
                if (LinkToLootEvent.ContainsKey(player.userID))
                {
                    LinkToLootEvent.Remove(player.userID);
                }
            }
            else
            {
                return;
            }
        }
        #endregion
        #region Data Models (PlayerInfo, LootChange, LootEvent, LootItem, LootTarget)
        private struct PlayerInfo
        {
            public ulong SteamID { get; set; }
            public string SteamIDString => SteamID.ToString();
            public string DisplayName { get; set; }
            public Vector3 Location { get; set; }
            public PlayerInfo(BaseEntity baseEntity)
            {
                if (baseEntity == null)
                {
                    throw new ArgumentNullException(nameof(baseEntity));
                }
                Location = baseEntity.ServerPosition;
                if (baseEntity is BasePlayer)
                {
                    var player = (BasePlayer)baseEntity;
                    SteamID = player.userID;
                    DisplayName = player.displayName;
                }
                else if (baseEntity is PlayerCorpse)
                {
                    var corpse = (PlayerCorpse)baseEntity;
                    SteamID = corpse.playerSteamID;
                    DisplayName = corpse.playerName;
                }
                else
                {
                    throw new ArgumentException(
                        $"Type '{baseEntity.GetType()}' not supported. Argument must be type {nameof(BasePlayer)} or {nameof(PlayerCorpse)}.",
                        nameof(baseEntity));
                }
            }
        }
        private struct LootChange
        {
            public PlayerInfo[] Looters { get; set; }
            public PlayerInfo Target { get; set; }
            public Vector3 Position { get; set; }
            public DateTimeOffset Timestamp { get; set; }
            public Dictionary<ulong, LootItem[]> ItemsModified { get; set; }
            public static LootChange Empty = new LootChange
            {
                Looters = Array.Empty<PlayerInfo>()
            };
            public bool IsEmpty() => Looters.Any();
            public static LootChange FromEvent(LootEvent lootEvent, BaseEntity baseTarget)
            {
                var target = new PlayerInfo(baseTarget);
                var existingTargetItems = lootEvent.Items[target.SteamID];
                var newTargetItems = LootItem.GetItems(baseTarget);
                var targetItemChanges = LootItem.GetChanges(existingTargetItems, newTargetItems);
                if (targetItemChanges.Any())
                {
                    var lootChange = new LootChange
                    {
                        Looters = lootEvent.Looters.Values.Select(player => new PlayerInfo(player)).ToArray(),
                        Target = target,
                        ItemsModified = new Dictionary<ulong, LootItem[]>
                        {
                            [target.SteamID] = targetItemChanges.ToArray()
                        },
                        Position = baseTarget.ServerPosition,
                        Timestamp = DateTimeOffset.Now,
                    };
                    foreach (var player in lootEvent.Looters)
                    {
                        var playerMod =
                            LootItem.GetChanges(lootEvent.Items[player.Key], LootItem.GetItems(player.Value))
                                ?.ToArray() ?? Array.Empty<LootItem>();
                        lootChange.ItemsModified[player.Key] = playerMod;
                    }
                    return lootChange;
                }
                return Empty;
            }
        }
        private class LootEvent
        {
            public Dictionary<ulong, BasePlayer> Looters { get; set; } = new Dictionary<ulong, BasePlayer>();
            public BaseEntity Target { get; set; }
            public Dictionary<ulong, List<LootItem>> Items { get; set; } = new Dictionary<ulong, List<LootItem>>();
            public bool Active => Looters.Count > 0;
            public LootEvent(BasePlayer player, BaseEntity baseTarget)
            {
                Looters = new Dictionary<ulong, BasePlayer>()
                {
                    [player.userID] = player
                };
                Target = baseTarget;
                UpdateItems();
            }
            public bool RecordChange(BasePlayer player, BaseEntity baseTarget, out LootChange lootChange)
            {
                if (!Looters.ContainsKey(player.userID) || !Items.ContainsKey(player.userID))
                {
                    Looters[player.userID] = player;
                    Items[player.userID] = LootItem.GetItems(player);
                    lootChange = LootChange.Empty;
                }
                else
                {
                    lootChange = LootChange.FromEvent(this, baseTarget);
                }
                UpdateItems();
                return lootChange.IsEmpty();
            }
            public void RemoveLooter(BasePlayer player)
            {
                if (Looters.ContainsKey(player.userID))
                {
                    Looters.Remove(player.userID);
                }
                if (Items.ContainsKey(player.userID))
                {
                    Items.Remove(player.userID);
                }
            }
            private void UpdateItems()
            {
                Items[new PlayerInfo(Target).SteamID] = LootItem.GetItems(Target);
                foreach (var looter in Looters)
                {
                    Items[looter.Key] = LootItem.GetItems(looter.Value);
                }
            }
        }

        private struct LootEntity
        {
            public PlayerInfo Player { get; set; }
            public List<LootItem> Items { get; set; }
            public LootEntity(BaseEntity baseEntity)
            {
                Player = new PlayerInfo(baseEntity);
                Items = LootItem.GetItems(baseEntity);
            }
        }

        private struct LootItem
        {
            public int Id { get; set; }
            public string Name { get; set; }
            public int Amount { get; set; }
            public float Condition { get; set; }
            public float ConditionMax { get; set; }
            public float ConditionPercent => ConditionMax == 0 ? 100 : Condition / ConditionMax * 100;
            public bool CanStack { get; set; }
            public LootItem(Item baseItem)
            {
                Id = baseItem.info.itemid;
                Name = baseItem.info.name;
                Amount = baseItem.amount;
                Condition = baseItem.condition;
                ConditionMax = baseItem.info.condition.max;
                CanStack = baseItem.info.stackable > 1 || Condition == baseItem.maxCondition;
            }
            public static List<LootItem> GetItems(BaseEntity baseEntity)
            {
                if (baseEntity == null)
                {
                    throw new ArgumentNullException(nameof(baseEntity));
                }
                if (baseEntity is BasePlayer)
                {
                    var player = (BasePlayer)baseEntity;
                    var items = player.inventory.containerMain.itemList
                        .Concat(player.inventory.containerBelt.itemList)
                        .Concat(player.inventory.containerWear.itemList);
                    return Merge(items.Select(item => new LootItem(item)));
                }
                else if (baseEntity is PlayerCorpse)
                {
                    return FromContainers(((PlayerCorpse)baseEntity).containers);
                }
                else
                {
                    throw new ArgumentException($"Type '{baseEntity.GetType()}' not supported. Argument must be type {nameof(BasePlayer)} or {nameof(PlayerCorpse)}.", nameof(baseEntity));
                }
            }

            public static List<LootItem> GetChanges(IEnumerable<LootItem> existingItems, IEnumerable<LootItem> newItems)
            {
                var previous = Merge(existingItems);
                var current = Merge(newItems);
                var modified = new List<LootItem>();
                foreach (var item in current)
                {
                    var modItem = item;
                    var prevItem = previous.Where(pItem => pItem.Id == item.Id && pItem.Condition == item.Condition);
                    if (!prevItem.Any())
                    {
                        modified.Add(modItem);
                    }
                    else
                    {
                        modItem.Amount -= prevItem.First().Amount;
                        if (modItem.Amount != 0)
                        {
                            modified.Add(modItem);
                        }
                    }
                }
                foreach (var item in previous)
                {
                    if (!current.Any(cItem => cItem.Id == item.Id && cItem.Condition == item.Condition))
                    {
                        var modItem = item;
                        modItem.Amount *= -1;
                        modified.Add(modItem);
                    }
                }
                return modified;
            }

            public static List<LootItem> FromContainers(params ItemContainer[] containers)
            {
                if (containers == null)
                {
                    return new List<LootItem>();
                }
                else
                {
                    return Merge(containers.SelectMany(container =>
                        container.itemList.Select(item => new LootItem(item))));
                }
            }

            public static List<LootItem> Merge(IEnumerable<LootItem> items)
            {
                var stacks = new Dictionary<int, LootItem>();
                var final = new List<LootItem>();
                foreach (var item in items)
                {
                    if (item.CanStack)
                    {
                        if (stacks.ContainsKey(item.Id))
                        {
                            var currentStack = stacks[item.Id];
                            currentStack.Amount += item.Amount;
                            stacks[item.Id] = currentStack;
                        }
                        else
                        {
                            stacks[item.Id] = item;
                        }
                    }
                    else
                    {
                        final.Add(item);
                    }
                }
                final.AddRange(stacks.Values);
                return final;
            }
        }

        private struct LootIndex<T>
        {
            public Dictionary<T, string[]> Entries { get; set; }
            public void AddEntry(T key, string logId)
            {
                var entries = new List<string>(Entries.ContainsKey(key) ? Entries[key] : Array.Empty<string>());
                entries.Add(logId);
                Entries[key] = entries.Distinct().ToArray();
            }
        }
        #endregion
    }
}


// --- End of file: PlayerLootLogs.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/port-forward ---
// --- Original File Path: P/PortForward/PortForward.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Text;

// TODO: Add support for additional router brands and firmware
// TODO: Fix port forwards not always being applied with DD-WRT
// TODO: Implement https preference when Oxide can support this
// TODO: Forward RCON port if enabled (need Covalence support for this)

namespace Oxide.Plugins
{
    [Info("Port Forward", "Wulf/lukespragg", "0.0.1")]
    [Description("Automatic port forwarding for DD-WRT routers")]
    public class PortForward : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "DD-WRT username (default is root)")]
            public string Username { get; set; } = "root";

            [JsonProperty(PropertyName = "DD-WRT password (default is admin)")]
            public string Password { get; set; } = "admin";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            LogWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Initialization

        private static Dictionary<string, string> headers;
        private static IPAddress localIp;
        private static IPAddress routerIp;

        private void OnServerInitialized()
        {
            localIp = GetLocalIp();
            routerIp = GetGateway();

            if (localIp == null || routerIp == null)
            {
                LogWarning("This server does not appear to be behind a router");
                return;
            }

            headers = new Dictionary<string, string>
            {
                ["Authorization"] = "Basic " + Convert.ToBase64String(Encoding.UTF8.GetBytes($"{config.Username}:{config.Password}")),
                ["Referer"] = $"http://{routerIp}/ForwardSpec.asp"
            };

            ToggleForward("on");
        }

        private void Unload()
        {
            ToggleForward("off");
        }

        #endregion Initialization

        #region Commands

        [Command("pf.net")]
        private void NetCommand(IPlayer player, string command, string[] args)
        {
            if (!player.IsServer)
            {
                return;
            }

            LogWarning($"Local IP address: {localIp}");
            LogWarning($"Router IP address: {routerIp}");
            LogWarning($"External IP address: {server.Address}");
            LogWarning($"Server port: {server.Port}");
            // TODO: Show RCON port
        }

        [Command("pf.toggle")]
        private void ToggleCommand(IPlayer player, string command, string[] args)
        {
            if (!player.IsServer)
            {
                return;
            }

            string state = args.Length > 0 ? args[0].ToLower() : "on";
            if (state != "on" && state != "off")
            {
                LogWarning("Please specify 'on' or 'off' state");
                return;
            }

            ToggleForward(state);
        }

        #endregion Commands

        #region The Magic

        private void ToggleForward(string state)
        {
            // Set form data to send
            string data = $"name0={covalence.Game}&pro0=both&ip0={localIp}&from0={server.Port}&to0={server.Port}" +
                $"&enable0={state}&forward_spec=13&submit_button=ForwardSpec&action=Apply";

            // Send web request to control panel
            webrequest.Enqueue($"http://{routerIp}/apply.cgi", data, (code, response) =>
            {
                if (code == 400) // TODO: Handle specific error messages
                {
                    LogWarning("Could not login to router control panel");
                }
                else if (code != 200 || response == null)
                {
                    LogWarning($"HTTP code: {code}");
                    LogWarning($"Response: {response}");
                }
                else
                {
                    LogWarning($"Toggled port {server.Port} forward {state} for {localIp}");
                }
            }, this, RequestMethod.POST, headers);
        }

        #endregion The Magic

        #region Helpers

        private static IPAddress GetGateway() // TODO: Clean this up
        {
            return NetworkInterface
                .GetAllNetworkInterfaces()
                .Where(n => n.OperationalStatus == OperationalStatus.Up)
                .Where(n => n.NetworkInterfaceType != NetworkInterfaceType.Loopback)
                .SelectMany(n => n.GetIPProperties()?.GatewayAddresses)
                .Select(g => g?.Address)
                .Where(a => a != null)
                .Where(a => a.AddressFamily == AddressFamily.InterNetwork)
                .FirstOrDefault(a => Array.FindIndex(a.GetAddressBytes(), b => b != 0) >= 0);
        }

        private static IPAddress GetLocalIp() // TODO: Clean this up
        {
            return NetworkInterface
                .GetAllNetworkInterfaces()
                .Where(n => n.OperationalStatus == OperationalStatus.Up)
                .Where(n => n.NetworkInterfaceType == NetworkInterfaceType.Ethernet
                            || n.NetworkInterfaceType == NetworkInterfaceType.Wireless80211)
                .SelectMany(n => n.GetIPProperties()?.UnicastAddresses)
                .Select(g => g?.Address)
                .LastOrDefault(a => a?.AddressFamily == AddressFamily.InterNetwork);
        }

        // TODO: Create enum of protocols per game

        #endregion Helpers
    }
}


// --- End of file: PortForward.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/portable-vehicles ---
// --- Original File Path: P/PortableVehicles/PortableVehicles.cs ---

/*
 ########### README ####################################################
                                                                             
  !!! DON'T EDIT THIS FILE !!!
  Orange is the original developer of this plugin
                                                                     
 ########### CHANGES ###################################################

 1.1.2
    - Rewrited config
    - Added chat command
    - Added chat icon option
    - Added more localization messages
    - Added option blacklist pickupable vehicles
    - Added item name vehicle
    - Fixed Pickupable Hot Air Balloon
    - Added submarinesolo
    - Added submarineduo
    - Added snowmobile
    - Added option what item you will be placing
 1.1.3
    - Changed skinId icons
    - Added tugboat
    - Added tomaha snowmobile
    - Added option item for big models
    - Added option pickup any vehicles
    - Added option pickup own vehicles
    - Added option require building priviledge
 1.1.4
    - Fixed minicopter skinid
 1.1.5
    - Added Attack Helicopter
 1.1.6
    - Rust Update Fix
 1.1.7
    - Added motorbike
    - Added bicykle
    - Added trike
    - Fixed pickup conflict with repair
 1.1.8
    - Changed ridable horse prefab
    - Remove blacklist vehicles from config
    - Added option check storages before pickup
    - Fixed pickup
    - Added option auto fuel to vehicle
 1.1.9
    - Added siegeweapons
    - Added option ignore repair vehicles

 #######################################################################
*/

using System.Collections.Generic;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Portable Vehicles", "Paulsimik", "1.1.9")]
    [Description("Give vehicles as item to your players")]
    public class PortableVehicles : RustPlugin
    {
        #region [Fields]

        private static Configuration config;
        private const string permUse = "portablevehicles.use";
        private const string permAdmin = "portablevehicles.admin";
        private const string permPickup = "portablevehicles.pickup";
        private const string permFuel = "portablevehicles.fuel";
        private string[] chatCommands = { "pv", "portablevehicles", "portablevehicle" };

        #endregion

        #region [Oxide Hooks]

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permAdmin, this);
            permission.RegisterPermission(permPickup, this);
            permission.RegisterPermission(permFuel, this);

            foreach (var command in chatCommands)
                cmd.AddChatCommand(command, this, nameof(cmdPortableVehicles));
        }

        private void OnEntityBuilt(Planner plan, GameObject go) => CheckPlacement(plan, go);

        private object OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (info.HitEntity is BaseVehicle)
                return CheckPickup(player, info.HitEntity as BaseVehicle);

            if (info.HitEntity is HotAirBalloon)
                return CheckPickupBalloon(player, info.HitEntity as HotAirBalloon);

            return null;
        }

        #endregion

        #region [Hooks]   

        private void CheckPlacement(Planner plan, GameObject go)
        {
            var entity = go.ToBaseEntity();
            if (entity == null)
                return;

            var player = plan.GetOwnerPlayer();
            var info = AllVehicles.FirstOrDefault(x => x.skinId == entity.skinID);
            if (info == null)
                return;

            var transform = entity.transform;
            var position = transform.position;
            var rotation = transform.rotation;
            var owner = entity.OwnerID;
            var skin = entity.skinID;

            transform.position = new Vector3();
            entity.TransformChanged();
            timer.Once(1f, () =>
            {
                if (entity.IsValid() && !entity.IsDestroyed)
                {
                    entity.Kill();
                }
            });

            var time = 1f;
            if (info.bigModel)
            {
                time = 3f;
                Message(player, "BigModel");
            }

            timer.Once(time, () =>
            {
                var vehicle = GameManager.server.CreateEntity(info.prefab, position, rotation);
                if (vehicle != null)
                {
                    vehicle.skinID = skin;
                    vehicle.OwnerID = owner;
                    vehicle.Spawn();

                    if (vehicle is HotAirBalloon)
                    {
                        var balloon = (HotAirBalloon)vehicle;
                        if (balloon != null)
                        {
                            AddFuelBalloon(player, balloon);
                        }

                        return;
                    }

                    if (vehicle is BaseVehicle)
                    {
                        var baseVehicle = (BaseVehicle)vehicle;
                        if (baseVehicle != null)
                        {
                            AddFuel(player, baseVehicle);

                            if (config.autoMount)
                            {
                                if (baseVehicle.mountPoints != null && baseVehicle.mountPoints.Count > 0)
                                {
                                    var driverSeat = baseVehicle.mountPoints.FirstOrDefault()?.mountable;
                                    if (driverSeat != null)
                                    {
                                        driverSeat.MountPlayer(player);
                                        player.SendNetworkUpdate();
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    SendMessage(player, "<size=12><color=#ff6666>Portable Vehicles: Failed to spawn vehicle!</color></size>");
                }
            });
        }

        private object CheckPickup(BasePlayer player, BaseVehicle entity)
        {
            if (entity == null)
                return null;

            if (!config.pickupAnyVehicles && entity.skinID == 0)
                return null;

            if (!permission.UserHasPermission(player.UserIDString, permPickup))
                return null;

            if (config.pickupableBlacklist.Contains(entity.ShortPrefabName))
            {
                Message(player, "Pickupable");
                return null;
            }

            if (config.pickupOwnVehicles && entity.skinID != 0 && entity.OwnerID != player.userID)
            {
                Message(player, "Pickup Ownership");
                return null;
            }

            if (config.requireBuildingPrivilege && !player.CanBuild())
            {
                Message(player, "Cupboard");
                return null;
            }

            var time = entity.SecondsSinceAttacked;
            if (time < 30)
            {
                Message(player, "Recently Attacked", (30 - time).ToString("0.0"));
                return true;
            }

            var diff = (Mathf.Abs(entity.MaxHealth() - entity.Health()));
            if (config.needRepair && diff > 5f)
            {
                Message(player, "Durability");
                return null;
            }

            if (config.checkStorages)
            {
                var containers = entity.GetComponentsInChildren<StorageContainer>();
                if (containers.Any(x => x.inventory.itemList.Count > 0))
                {
                    Message(player, "Not Empty");
                    return true;
                }

                var fs = entity.GetFuelSystem() as EntityFuelSystem;
                if (fs != null && !fs.fuelStorageInstance.Get(true).IsLocked() && fs.HasFuel())
                {
                    Message(player, "Fuel");
                    return true;
                }
            }

            var script = entity.GetOrAddComponent<PickupScript>();
            script.AddHit();
            var left = script.GetHitsLeft();
            if (left > 0)
            {
                Message(player, "Hits", script.GetHitsLeft());
                return true;
            }

            foreach (var vehicle in AllVehicles)
            {
                if (vehicle.prefab == entity.PrefabName)
                {
                    entity.Kill();
                    GiveItem(player, vehicle);
                    return true;
                }
            }

            return null;
        }

        private object CheckPickupBalloon(BasePlayer player, HotAirBalloon balloon)
        {
            if (balloon == null)
                return null;

            if (!config.pickupAnyVehicles && balloon.skinID == 0)
                return null;

            if (!permission.UserHasPermission(player.UserIDString, permPickup))
                return null;

            if (config.pickupableBlacklist.Contains(balloon.ShortPrefabName))
            {
                Message(player, "Pickupable");
                return null;
            }

            if (config.pickupOwnVehicles && balloon.OwnerID != player.userID)
            {
                Message(player, "Pickup Ownership");
                return null;
            }

            if (config.requireBuildingPrivilege && !player.CanBuild())
            {
                Message(player, "Cupboard");
                return null;
            }

            var time = balloon.SecondsSinceAttacked;
            if (time < 30)
            {
                Message(player, "Recently Attacked", (30 - time).ToString("0.0"));
                return true;
            }

            var diff = (Mathf.Abs(balloon.MaxHealth() - balloon.Health()));
            if (config.needRepair && diff > 5f)
            {
                Message(player, "Durability");
                return null;
            }

            if (config.checkStorages)
            {
                var containers = balloon.GetComponentsInChildren<StorageContainer>();
                if (containers.Any(x => x.inventory.itemList.Count > 0))
                {
                    Message(player, "Not Empty");
                    return true;
                }

                var fs = balloon.fuelSystem;
                if (fs != null && !fs.fuelStorageInstance.Get(true).IsLocked() && fs.HasFuel())
                {
                    Message(player, "Fuel");
                    return true;
                }
            }

            var script = balloon.GetOrAddComponent<PickupScript>();
            script.AddHit();
            var left = script.GetHitsLeft();
            if (left > 0)
            {
                Message(player, "Hits", script.GetHitsLeft());
                return true;
            }

            foreach (var vehicle in AllVehicles)
            {
                if (vehicle.prefab == balloon.PrefabName)
                {
                    balloon.Kill();
                    GiveItem(player, vehicle);
                    return true;
                }
            }

            return null;
        }

        private void GiveItem(BasePlayer player, ulong skin)
        {
            var vehicle = AllVehicles.FirstOrDefault(x => x.skinId == skin);
            if (vehicle == null)
                return;

            GiveItem(player, vehicle);
        }

        private void GiveItem(BasePlayer player, VehicleEntry vehicle)
        {
            var name = string.IsNullOrEmpty(vehicle.displayName) ? "Portable Vehicle" : vehicle.displayName;
            var shortname = "box.wooden.large";

            if (vehicle.bigModel)
            {
                shortname = config.bigModelEntityShortName;
            }
            else
            {
                shortname = vehicle.isWaterVehicle ? config.waterEntityShortName : config.groundEntityShortName;
            }

            Item item = ItemManager.CreateByName(shortname, 1, vehicle.skinId);
            if (item != null)
            {
                item.name = name;
                player.GiveItem(item);
                Message(player, "Received", name);
            }
            else
            {
                SendMessage(player, "<size=12><color=#ff6666>Portable Vehicles: Item not created. Wrong entity name in the configuration!</color></size>");
            }
        }

        private ulong GetSkin(string name)
        {
            switch (name.ToLower())
            {
                case "rhib":
                case "militaryboat":
                case "military":
                    return 2783365542;

                case "boat":
                case "rowboat":
                case "motorboat":
                    return 2783365250;

                case "copter":
                case "mini":
                case "minicopter":
                    return 2906148311;

                case "balloon":
                case "hotairballoon":
                    return 2783364912;

                case "ch":
                case "ch47":
                case "chinook":
                    return 2783365479;

                case "horse":
                case "unicorn":
                case "testridablehorse":
                    return 2783365408;

                case "scrap":
                case "scrapheli":
                case "scraphelicopter":
                case "helicopter":
                    return 2783365006;

                case "car":
                case "car1":
                case "sedan":
                    return 2783365060;

                case "car2":
                    return 2783364084;

                case "car3":
                    return 2783364660;

                case "car4":
                    return 2783364761;

                case "submarinesolo":
                    return 2783365665;

                case "submarineduo":
                    return 2783365593;

                case "snowmobile":
                case "snow":
                    return 2783366199;

                case "tomahasnowmobile":
                case "tsnowmobile":
                case "tsnow":
                    return 3000416835;

                case "tugboat":
                    return 3000418301;

                case "attackheli":
                case "attackhelicopter":
                case "attackcopter":
                    return 3284204081;

                case "motorbike":
                    return 3284204457;

                case "motorbikesidecar":
                case "motorsidecar":
                case "sidecar":
                    return 3284204759;

                case "bicycle":
                case "pedalbike":
                case "bike":
                    return 3284205070;

                case "trike":
                case "pedaltrike":
                    return 3284205351;

                case "catapult":
                    return 3446373078;

                case "siegetower":
                case "tower":
                    return 3446373165;

                case "batteringram":
                case "ram":
                    return 3446372968;

                case "ballista":
                    return 3446372639;

                default:
                    return 0;
            }
        }

        private void AddFuel(BasePlayer player, BaseVehicle baseVehicle)
        {
            if (!permission.UserHasPermission(player.UserIDString, permFuel) || config.vehicleFuel <= 0)
                return;

            NextTick(() =>
            {
                EntityFuelSystem entityFuelSystem = baseVehicle?.GetFuelSystem() as EntityFuelSystem;
                if (entityFuelSystem != null)
                {
                    entityFuelSystem.AddFuel(config.vehicleFuel);
                }
            });
        }

        private void AddFuelBalloon(BasePlayer player, HotAirBalloon hotAirBalloon)
        {
            if (!permission.UserHasPermission(player.UserIDString, permFuel) || config.vehicleFuel <= 0)
                return;

            NextTick(() =>
            {
                var fs = hotAirBalloon.fuelSystem;
                if (fs != null)
                {
                    fs.AddFuel(config.vehicleFuel);
                }
            });
        }

        #endregion

        #region [Chat Commands]

        private void cmdPortableVehicles(BasePlayer player, string command, string[] args)
        {
            var value = args.Length > 0 ? args[0] : null;
            var value2 = args.Length > 1 ? args[1] : null;
            if (value == null)
            {
                Message(player, "Invalid Syntax");
                return;
            }

            if (value2 == null)
            {
                if (!permission.UserHasPermission(player.UserIDString, permUse))
                {
                    Message(player, "Permission");
                    return;
                }

                var skin = GetSkin(value);
                if (skin == 0)
                {
                    Message(player, "Invalid Vehicle");
                    return;
                }

                GiveItem(player, skin);
            }
            else
            {
                if (!IsAdmin(player))
                {
                    Message(player, "Permission");
                    return;
                }

                var target = FindPlayer(player, value);
                if (target == null)
                    return;

                var skin = GetSkin(value2);
                if (skin == 0)
                {
                    Message(player, "Invalid Vehicle");
                    return;
                }

                GiveItem(target, skin);
            }
        }

        #endregion

        #region [Console Commands]

        [ConsoleCommand("portablevehicles.give")]
        private void cmdGiveConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !IsAdmin(player))
            {
                Message(player, "Permission");
                return;
            }

            var args = arg.Args;
            if (args == null || args.Length < 2)
            {
                Message(arg, "Usage");
                return;
            }

            var target = FindPlayer(arg, args[0]);
            if (target == null)
                return;

            var skin = GetSkin(args[1]);
            if (skin == 0)
            {
                Message(arg, "Invalid Vehicle");
                return;
            }

            GiveItem(target, skin);
        }

        #endregion

        #region [Classes]

        private class Configuration
        {
            [JsonProperty(PropertyName = "Chat Icon")]
            public ulong chatIcon;

            [JsonProperty("Hits count to pickup vehicle")]
            public int hitsToPickup;

            [JsonProperty("Pickup any vehicles")]
            public bool pickupAnyVehicles;

            [JsonProperty("Pickup only your own vehicles")]
            public bool pickupOwnVehicles;

            [JsonProperty("Pickup require building priviledge")]
            public bool requireBuildingPrivilege;

            [JsonProperty("Automatically mount players")]
            public bool autoMount;

            [JsonProperty("Check storages before pickup")]
            public bool checkStorages;

            [JsonProperty("Need repair vehicles before pickup")]
            public bool needRepair;

            [JsonProperty(PropertyName = "Auto amount fuel to vehicle")]
            public int vehicleFuel;

            [JsonProperty(PropertyName = "Item shortname for water entity")]
            public string waterEntityShortName;

            [JsonProperty(PropertyName = "Item shortname for big models")]
            public string bigModelEntityShortName;

            [JsonProperty(PropertyName = "Item shortname for ground entity")]
            public string groundEntityShortName;

            [JsonProperty(PropertyName = "Blacklist pickupable vehicles shortname")]
            public List<string> pickupableBlacklist = new List<string>();

            public VersionNumber version;
        }

        private class VehicleEntry
        {
            public ulong skinId;
            public string displayName;
            public string prefab;
            public bool bigModel;
            public bool isWaterVehicle;
        }

        private VehicleEntry[] AllVehicles = new[]
        {
            new VehicleEntry
            {
                skinId = 2783365542,
                displayName = "Rhib",
                prefab = "assets/content/vehicles/boats/rhib/rhib.prefab",
                isWaterVehicle = true
            },
            new VehicleEntry
            {
                skinId = 2783365250,
                displayName = "Boat",
                prefab = "assets/content/vehicles/boats/rowboat/rowboat.prefab",
                isWaterVehicle = true
            },
            new VehicleEntry
            {
                skinId = 2906148311,
                displayName = "MiniCopter",
                prefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab"
            },
            new VehicleEntry
            {
                skinId = 2783365060,
                displayName = "Sedan",
                prefab = "assets/content/vehicles/sedan_a/sedantest.entity.prefab"
            },
            new VehicleEntry
            {
                skinId = 2783365479,
                displayName = "Chinook",
                prefab = "assets/prefabs/npc/ch47/ch47.entity.prefab",
                bigModel = true,
            },
            new VehicleEntry
            {
                skinId = 2783364912,
                displayName = "Hot Air Balloon",
                prefab = "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab",
                bigModel = true,
            },
            new VehicleEntry
            {
                skinId = 2783365408,
                displayName = "Horse",
                prefab = "assets/content/vehicles/horse/ridablehorse2.prefab"
            },
            new VehicleEntry
            {
                skinId = 2783365006,
                displayName = "Scrap Transport Helicopter",
                prefab = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab",
                bigModel = true,
            },
            new VehicleEntry
            {
                skinId = 2783364084,
                displayName = "2 Module Car",
                prefab = "assets/content/vehicles/modularcar/2module_car_spawned.entity.prefab"
            },
            new VehicleEntry
            {
                skinId = 2783364660,
                displayName = "3 Module Car",
                prefab = "assets/content/vehicles/modularcar/3module_car_spawned.entity.prefab"
            },
            new VehicleEntry
            {
                skinId = 2783364761,
                displayName = "4 Module Car",
                prefab = "assets/content/vehicles/modularcar/4module_car_spawned.entity.prefab"
            },
            new VehicleEntry
            {
                skinId = 2783365665,
                displayName = "Submarine Solo",
                prefab = "assets/content/vehicles/submarine/submarinesolo.entity.prefab",
                isWaterVehicle = true
            },
            new VehicleEntry
            {
                skinId = 2783365593,
                displayName = "Submarine Duo",
                prefab = "assets/content/vehicles/submarine/submarineduo.entity.prefab",
                isWaterVehicle = true
            },
            new VehicleEntry
            {
                skinId = 2783366199,
                displayName = "Snowmobile",
                prefab = "assets/content/vehicles/snowmobiles/snowmobile.prefab"
            },
            new VehicleEntry
            {
                skinId = 3000416835,
                displayName = "Tomaha Snowmobile",
                prefab = "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab"
            },
            new VehicleEntry
            {
                skinId = 3000418301,
                displayName = "Tugboat",
                prefab = "assets/content/vehicles/boats/tugboat/tugboat.prefab",
                isWaterVehicle = true
            },
            new VehicleEntry
            {
                skinId = 3284204081,
                displayName = "Attack Helicopter",
                prefab = "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab"
            },
            new VehicleEntry
            {
                skinId = 3284204457,
                displayName = "Motorbike",
                prefab = "assets/content/vehicles/bikes/motorbike.prefab"
            },
            new VehicleEntry
            {
                skinId = 3284204759,
                displayName = "Motorbike With Sidecar",
                prefab = "assets/content/vehicles/bikes/motorbike_sidecar.prefab"
            },
            new VehicleEntry
            {
                skinId = 3284205070,
                displayName = "Bicycle",
                prefab = "assets/content/vehicles/bikes/pedalbike.prefab"
            },
            new VehicleEntry
            {
                skinId = 3284205351,
                displayName = "Trike",
                prefab = "assets/content/vehicles/bikes/pedaltrike.prefab"
            },
            new VehicleEntry
            {
                skinId = 3446373078,
                displayName = "Catapult",
                prefab = "assets/content/vehicles/siegeweapons/catapult/catapult.entity.prefab"
            },
            new VehicleEntry
            {
                skinId = 3446373165,
                displayName = "Siege Tower",
                prefab = "assets/content/vehicles/siegeweapons/siegetower/siegetower.entity.prefab"
            },
            new VehicleEntry
            {
                skinId = 3446372639,
                displayName = "Ballista",
                prefab = "assets/content/vehicles/siegeweapons/ballista/ballista.entity.prefab"
            },
            new VehicleEntry
            {
                skinId = 3446372968,
                displayName = "Battering Ram",
                prefab = "assets/content/vehicles/siegeweapons/batteringram/batteringram.entity.prefab",
                bigModel = true
            }
        };

        private class PickupScript : MonoBehaviour
        {
            private BaseEntity entity;
            private int hits;

            private void Awake()
            {
                entity = GetComponent<BaseEntity>();
            }

            public void AddHit()
            {
                hits++;
                CancelInvoke(nameof(ResetHits));
                Invoke(nameof(ResetHits), 60);
            }

            private void ResetHits()
            {
                hits = 0;
            }

            public int GetHitsLeft()
            {
                return config.hitsToPickup - hits;
            }
        }

        #endregion

        #region [Config]

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                chatIcon = 0,
                hitsToPickup = 5,
                pickupAnyVehicles = true,
                pickupOwnVehicles = true,
                requireBuildingPrivilege = true,
                autoMount = false,
                checkStorages = true,
                needRepair = false,
                vehicleFuel = 0,
                waterEntityShortName = "kayak",
                groundEntityShortName = "box.wooden.large",
                bigModelEntityShortName = "furnace.large",
                pickupableBlacklist = new List<string>() { },
                version = Version
            };
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
            Puts("Generating new configuration file........");
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();

                if (config == null)
                    LoadDefaultConfig();

                if (config.version < Version)
                    UpdateConfig();
            }
            catch
            {
                PrintError("######### Configuration file is not valid! #########");
                return;
            }

            SaveConfig();
        }

        private void UpdateConfig()
        {
            Puts("Updating configuration values.....");

            if (config.version < new VersionNumber(1, 1, 8))
            {
                config = GetDefaultConfig();
                Config.WriteObject(config);
            };

            config.version = Version;
            Puts("Configuration updated");
        }

        #endregion

        #region [Localization]

        private string GetLang(string key, string playerID, params object[] args) => string.Format(lang.GetMessage(key, this, playerID), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Usage", "Usage: portablevehicles.give 'steamID/player name' 'vehicle name'\n"},
                {"Invalid Syntax", "Invalid Syntax!\n/pv 'vehicle name'\n/pv 'steamID/player name' 'vehicle name'"},
                {"Permission", "You don't have permission to use that!"},
                {"Received", "You received '{0}'!"},
                {"No Player", "There are no players with that Name or steamID!"},
                {"Multiple Players", "There are many players with that Name:\n{0}"},
                {"Pickup Ownership", "Only owner can pickup vehicles!"},
                {"Fuel", "You need to remove fuel from vehicle first!"},
                {"Recently Attacked", "Vehicle was recently attacked! {0}s left"},
                {"Durability", "You need to repair vehicles fully!"},
                {"Not Empty", "Vehicle is not empty! Check fuel or storages!"},
                {"Hits", "You need to do more {0} hits!"},
                {"Cupboard", "You need to have building privilege to do that!"},
                {"BigModel", "That vehicle have big model and can kill you. Run away! It will be spawned in 3 seconds"},
                {"Pickupable", "This vehicle cannot be picked up"},
                {"Invalid Vehicle", "Vehicle name is invalid!"},
            }, this);
        }

        #endregion

        #region [Helpers]

        private bool IsAdmin(BasePlayer player)
        {
            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, permAdmin))
                return true;

            return false;
        }

        private BasePlayer FindPlayer(ConsoleSystem.Arg arg, string nameOrID)
        {
            var targets = BasePlayer.activePlayerList.Where(x => x.UserIDString == nameOrID || x.displayName.ToLower().Contains(nameOrID.ToLower())).ToList();
            if (targets.Count == 0)
            {
                Message(arg, "No Player");
                return null;
            }

            if (targets.Count > 1)
            {
                Message(arg, "Multiple Players");
                return null;
            }

            return targets[0];
        }

        private BasePlayer FindPlayer(BasePlayer player, string nameOrID)
        {
            var targets = BasePlayer.activePlayerList.Where(x => x.UserIDString == nameOrID || x.displayName.ToLower().Contains(nameOrID.ToLower())).ToList();
            if (targets.Count == 0)
            {
                Message(player, "No Player");
                return null;
            }

            if (targets.Count > 1)
            {
                Message(player, "Multiple Players");
                return null;
            }

            return targets[0];
        }

        private void Message(ConsoleSystem.Arg arg, string messageKey, params object[] args)
        {
            var message = GetLang(messageKey, null, args);
            var player = arg.Player();
            if (player != null)
            {
                SendMessage(player, message);
            }
            else
            {
                SendReply(arg, message);
            }
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
                return;

            var message = GetLang(messageKey, player.UserIDString, args);
            SendMessage(player, message);
        }

        private void SendMessage(BasePlayer player, string msg) => Player.Message(player, msg, config.chatIcon);

        #endregion
    }
}

// --- End of file: PortableVehicles.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pay-for-electricity ---
// --- Original File Path: P/PayForElectricity/PayForElectricity.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Pay for Electricity", "mr01sam", "1.0.4")]
	[Description("Electric generators cost money (or scrap) to provide power")]
	public class PayForElectricity : CovalencePlugin
	{
		private static PayForElectricity PLUGIN;

		/* Permissions */
		private const string PermissionUse = "payforelectricity.use";

		/* Dependencies */
		[PluginReference]
		private readonly Plugin Economics;

		private readonly string prefab = "assets/prefabs/io/electric/switches/fusebox/fusebox.prefab";

		private const int PAY_PERIOD = 2;

		#region Oxide Hooks
		void Init()
		{
			PLUGIN = this;

			/* Unsubscribe */
			Unsubscribe(nameof(OnEntityKill));
			Unsubscribe(nameof(OnEntitySpawned));
			Unsubscribe(nameof(OnLootEntity));
			Unsubscribe(nameof(CanAcceptItem));
		}

		void OnServerInitialized( bool initial )
		{
			/* Register perms */
			permission.RegisterPermission(PermissionUse, this);

			/* Check if using Economics */
			if (config.UseEconomics && !Economics)
			{
				PrintWarning($"You do not have the Economics plugin installed, setting 'Use economics balance' to false");
				config.UseEconomics = false;
			}

			/* Reset UI */
			foreach (BasePlayer player in BasePlayer.activePlayerList)
			{
				CuiHelper.DestroyUi(player, "pfePanel");
			}

			/* Load existing generators */
			try
			{
				PaidGenerator.LoadAll(Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PaidGenerator>>($"{Name}/generators"));
			}
			catch
			{
				PrintWarning("Failed to load existing generator data");
			}

			/* Start collection timer */
			timer.Every(PAY_PERIOD, () =>
			{
				foreach (PaidGenerator gen in PaidGenerator.Generators.Values.ToArray())
				{
					gen.CollectPayment(PAY_PERIOD);
				}
			});

			/* Subscribe */
			Subscribe(nameof(OnEntityKill));
			Subscribe(nameof(OnEntitySpawned));
			Subscribe(nameof(OnLootEntity));
			Subscribe(nameof(CanAcceptItem));
		}

		void OnServerSave()
		{
			Interface.Oxide.DataFileSystem.WriteObject($"{Name}/generators", PaidGenerator.Generators);
		}

		void Unload()
		{
			PaidGenerator.Generators.Clear();
			PLUGIN = null;
		}

		void OnEntitySpawned( ElectricGenerator entity )
		{
			if (entity.IsValid())
			{
				BasePlayer owner = BasePlayer.FindByID(entity.OwnerID);
				if (owner.IsValid() && !permission.UserHasPermission(owner.UserIDString, PermissionUse))
					return;
				var box = GameManager.server?.CreateEntity(prefab, entity.transform.position) as ItemBasedFlowRestrictor;
				if (box == null) return;
				box.SetParent(entity);
				box.transform.localPosition = new Vector3(0.15f, 0.75f, 1.7f);
				box.transform.Rotate(new Vector3(-90.0f, 0.0f, 0.0f));
				box.SendNetworkUpdateImmediate(true);
				timer.In(0.1f, () =>
				{
					PaidGenerator gen = PaidGenerator.Create(entity.net.ID, box.net.ID);
				});
			}
		}

		void OnEntityKill( ItemBasedFlowRestrictor entity )
		{
			if (entity.IsValid())
			{
				PaidGenerator.Destroy(entity.net.ID);
				BaseEntity parent = entity.GetParentEntity();
				if (parent != null)
				{
					foreach (BaseEntity child in parent.children.ToArray())
					{
						child.SetParent(null);
					}
					parent.Kill();
				}
			}
		}

		void OnLootEntity( BasePlayer player, ItemBasedFlowRestrictor entity )
		{
			BaseEntity parent = entity.GetParentEntity();
			if (parent != null && parent.ShortPrefabName == "generator.small")
			{
				PaidGenerator gen = PaidGenerator.FindById(entity.net.ID);
				if (gen == null)
				{
					gen = PaidGenerator.Create(parent.net.ID, entity.net.ID);
				}
				ShowUI(player, gen);
				CheckIfLooting(player);
			}
		}

		ItemContainer.CanAcceptResult? CanAcceptItem( ItemContainer container, Item item, int targetPos )
		{
			BaseEntity parent = container.entityOwner;
			if (parent != null && parent.name == prefab)
			{
				BaseEntity gen = parent.GetParentEntity();
				if (gen != null)
					return ItemContainer.CanAcceptResult.CannotAccept;
			}
			return null;
		}
		#endregion

		#region Helpers
		private void CheckIfLooting( BasePlayer player )
		{
			timer.In(0.1f, () =>
			{
				if (!player.inventory.loot.IsLooting())
				{
					CuiHelper.DestroyUi(player, "pfePanel");
				}
				else
				{
					CheckIfLooting(player);
				}
			});
		}

		private string FormatTime( BasePlayer player, double hours )
		{
			if (double.IsInfinity(hours))
			{
				return Lang("no power", player.UserIDString);
			}
			else if (double.IsNaN(hours) || hours <= 0)
			{
				return "---";
			}
			else if (hours < 1)
			{
				return Lang("minutes", player.UserIDString, Math.Round(hours * 60, 1));
			}
			else
			{
				return Lang("hours", player.UserIDString, Math.Round(hours, 1));
			}
		}

		private void RemoveScrap( BasePlayer player, int amount )
		{
			List<Item> stacks = player.inventory.FindItemsByItemID(-932201673);
			foreach (Item stack in stacks)
			{
				int size = stack.amount;
				if (size >= amount)
				{
					stack.UseItem(amount);
					break;
				}
				else
				{
					stack.UseItem(amount);
					amount -= size;
				}
			}
		}

		private double GetBalance( BasePlayer player )
		{
			if (config.UseEconomics)
			{
				return (double)Economics.Call("Balance", player.userID);
			}
			else
			{
				return player.inventory.GetAmount(-932201673);
			}
		}

		private void SubBalance( BasePlayer player, double amount )
		{
			if (config.UseEconomics)
			{
				Economics.Call("Withdraw", player.userID, amount);
			}
			else
			{
				RemoveScrap(player, (int)amount);
			}
		}


		private void PlayEffect( BaseEntity entity, string effectString )
		{
			var effect = new Effect(effectString, entity, 0, new Vector3(0.1f, 1, 0.4f), Vector3.forward);
			EffectNetwork.Send(effect);
		}

		#endregion

		#region Classes
		private class PaidGenerator
		{

			public static readonly Dictionary<ulong, PaidGenerator> Generators = new Dictionary<ulong, PaidGenerator>();

			public NetworkableId boxId { get; set; }
			public NetworkableId generatorId { get; set; }
			public double powerOutput { get; set; }
			public double costPerHour { get; set; }
			public double balance { get; set; }

			public PaidGenerator(NetworkableId generatorId, NetworkableId boxId )
			{
				this.generatorId = generatorId;
				this.boxId = boxId;
				this.balance = 0;
				SetPowerOutput(0);
			}

			public void SetPowerOutput( double output )
			{
				output = Math.Min(PLUGIN.config.MaxPower, Math.Max(PLUGIN.config.MinPower, output));
				this.powerOutput = output;
				this.costPerHour = PLUGIN.config.PricePerWatt * output;
				ElectricGenerator obj = GetElectricGenerator(generatorId);
				if (obj != null)
				{
					if (balance == 0)
						obj.electricAmount = 0;
					else
						obj.electricAmount = (float)output;
					obj.currentEnergy = (int)obj.electricAmount;
					obj.UpdateOutputs();
				}
			}

			public ElectricGenerator GetElectricGenerator( NetworkableId entityId )
			{
				return (ElectricGenerator)BaseNetworkable.serverEntities.Find(entityId);
			}

			public double AddBalance( double amount )
			{
				this.balance += amount;
				return balance;
			}

			public void CollectPayment( int seconds )
			{
				double oldBalance = this.balance;
				this.balance = Math.Max(0, this.balance - (costPerHour * ((float)seconds / 3600.0)));
				if (balance <= 0 && oldBalance > 0)
				{
					PlayShutdownEffect();
				}
				SetPowerOutput(powerOutput);
			}

			public double GetHoursRemaining()
			{
				return balance / costPerHour;
			}

			public double CostOfHours( int hours )
			{
				return hours * costPerHour;
			}

			private void PlayShutdownEffect()
			{
				ElectricGenerator entity = GetElectricGenerator(generatorId);
				EffectNetwork.Send(new Effect("assets/prefabs/locks/keypad/effects/lock.code.shock.prefab", entity, 0, new Vector3(0.1f, 0.7f, 0.4f), Vector3.forward));
			}

			public static void LoadAll( Dictionary<ulong, PaidGenerator> existing )
			{
				foreach (uint key in existing.Keys)
				{
					Generators.Add(key, existing[key]);
				}
			}

			public static void Destroy( NetworkableId boxId )
			{
				if (Generators.ContainsKey(boxId.Value))
					Generators.Remove(boxId.Value);
			}

			public static PaidGenerator Create(NetworkableId generatorId, NetworkableId boxId )
			{
				PaidGenerator generator = new PaidGenerator(generatorId, boxId);
				Generators.Add(boxId.Value, generator);
				return generator;
			}

			public static PaidGenerator FindById( NetworkableId boxId )
			{
				if (Generators.ContainsKey(boxId.Value))
					return Generators[boxId.Value];
				return null;
			}
		}
		#endregion

		#region Commands
		[Command("setpower")]
		private void cmd_setpower( IPlayer player, string command, string[] args )
		{
			ulong boxId = ulong.Parse(args[0]);
			double newPowerAmount = double.Parse(args[1]);
			PaidGenerator gen = PaidGenerator.FindById(new NetworkableId(boxId));
			if (gen != null)
			{
				BasePlayer basePlayer = BasePlayer.FindByID(ulong.Parse(player.Id));
				gen.SetPowerOutput(newPowerAmount);
				ShowUI(basePlayer, gen);
			}
		}

		[Command("addhours")]
		private void cmd_addhours( IPlayer player, string command, string[] args )
		{
			ulong boxId = ulong.Parse(args[0]);
			int hours = int.Parse(args[1]);
			PaidGenerator gen = PaidGenerator.FindById(new NetworkableId(boxId));
			if (gen != null)
			{
				BasePlayer basePlayer = BasePlayer.FindByID(ulong.Parse(player.Id));
				double balance = GetBalance(basePlayer);
				double cost = gen.CostOfHours(hours);
				if (balance >= cost)
				{
					SubBalance(basePlayer, cost);
					gen.AddBalance(cost);
					ShowUI(basePlayer, gen);
				}
			}
		}
		#endregion

		#region Config

		private Configuration config;
		private class Configuration
		{
			[JsonProperty(PropertyName = "Price per watt (hourly)")]
			public float PricePerWatt = 0.1f;

			[JsonProperty(PropertyName = "Min power")]
			public float MinPower = 10;

			[JsonProperty(PropertyName = "Max power")]
			public float MaxPower = 1000;

			[JsonProperty(PropertyName = "Power increments")]
			public float PowerIncrements = 10;

			[JsonProperty(PropertyName = "Use economics balance (requires plugin)")]
			public bool UseEconomics = false;
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();

			try
			{
				config = Config.ReadObject<Configuration>();
				if (config == null) throw new Exception();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
			}

			SaveConfig();
		}

		protected override void SaveConfig() => Config.WriteObject(config);

		protected override void LoadDefaultConfig() => config = new Configuration();
		#endregion

		#region UI
		void ShowUI( BasePlayer player, PaidGenerator generator )
		{
			CuiHelper.DestroyUi(player, "pfePanel");
			CuiElementContainer container = new CuiElementContainer();
			string backgroundColor = "0.45 0.45 0.45 0";
			string btnColor = "0.475 0.54 0.32 0.8";
			string btnColorFaded = "0.6 0.6 0.6 0.4";
			string textColor = "0.9 0.9 0.9 1";
			int fontSize = 11;
			int btnSize = 10;

			container.Add(new CuiElement
			{
				Name = "pfePanel",
				Parent = "Overlay",
				Components = {
					new CuiImageComponent {
						Color = "0 0 0 0"
					},
					new CuiRectTransformComponent {
						AnchorMin = "0.65 0.151",
						AnchorMax = "0.947 0.266"
					}
				}
			});
			container.Add(new CuiElement
			{
				Name = "pfeTitle",
				Parent = "pfePanel",
				Components = {
					new CuiImageComponent {
						Color = "0 0 0 0"
					},
					new CuiRectTransformComponent {
						AnchorMin = "0 0.75",
						AnchorMax = "1 1"
					}
				}
			});
			container.Add(new CuiElement
			{
				Name = "pfeBody",
				Parent = "pfePanel",
				Components = {
					new CuiImageComponent {
						Color = "0.35 0.35 0.35 0.9"
					},
					new CuiRectTransformComponent {
						AnchorMin = "0 0",
						AnchorMax = "1 0.6677"
					}
				}
			});
			container.Add(new CuiElement
			{
				Name = "pfeBack1",
				Parent = "pfeBody",
				Components = {
					new CuiImageComponent {
						Color = "0 0 0 0"
					},
					new CuiRectTransformComponent {
						AnchorMin = "0 0.02",
						AnchorMax = "0.424 0.985"
					}
				}
			});
			container.Add(new CuiElement
			{
				Name = "pfeBack2",
				Parent = "pfeBody",
				Components = {
					new CuiImageComponent {
						Color = backgroundColor
					},
					new CuiRectTransformComponent {
						AnchorMin = "0.572 0.02",
						AnchorMax = "0.995 0.985"
					}
				}
			});
			container.Add(new CuiElement
			{
				Name = "pfeLeft",
				Parent = "pfeBody",
				Components = {
					new CuiImageComponent {
						Color = "0 0 0 0"
					},
					new CuiRectTransformComponent {
						AnchorMin = "0.02 0",
						AnchorMax = "0.5 1"
					}
				}
			});
			container.Add(new CuiElement
			{
				Name = "pfeRight",
				Parent = "pfeBody",
				Components = {
					new CuiImageComponent {
						Color = "0 0 0 0"
					},
					new CuiRectTransformComponent {
						AnchorMin = "0.4 0",
						AnchorMax = "0.98 1"
					}
				}
			});
			#region Title
			container.Add(new CuiElement
			{
				Name = "pfeTitleText",
				Parent = "pfeTitle",
				Components = {
					new CuiTextComponent {
						Text = Lang("ELECTRIC GENERATOR", player.UserIDString),
						Align = TextAnchor.MiddleLeft
					},
					new CuiRectTransformComponent {
						AnchorMin="0.02 0",
						AnchorMax="1 1"
					}
				}
			});
			#endregion
			#region Left
			container.Add(new CuiElement
			{
				Name = "pfeCostText",
				Parent = "pfeLeft",
				Components = {
					new CuiTextComponent {
						Text = Lang("cost", player.UserIDString, Math.Round(generator.costPerHour, 1)),
						Align = TextAnchor.MiddleLeft,
						FontSize = fontSize,
						Color = textColor
					},
					new CuiRectTransformComponent {
						AnchorMin="0 0.6",
						AnchorMax="1 1.0"
					}
				}
			});
			container.Add(new CuiButton
			{
				Button = {
					Command = $"setpower {generator.boxId} {generator.powerOutput - config.PowerIncrements}",
					Color = "1 1 1 0.5"
				},
				Text = {
					Text = "<",
					Align = TextAnchor.MiddleCenter,
					FontSize = btnSize,
				},
				RectTransform = {
					AnchorMin = "0 0.1",
					AnchorMax = "0.07 0.5"
				}
			}, "pfeLeft", "pfeButtonSub");
			container.Add(new CuiButton
			{
				Button = {
					Command = $"setpower {generator.boxId} {generator.powerOutput + config.PowerIncrements}",
					Color = "1 1 1 0.5"
				},
				Text = {
					Text = ">",
					Align = TextAnchor.MiddleCenter,
					FontSize = btnSize
				},
				RectTransform = {
					AnchorMin = "0.25 0.1",
					AnchorMax = "0.32 0.5"
				}
			}, "pfeLeft", "pfeButtonAdd");
			container.Add(new CuiElement
			{
				Name = "pfeInputText",
				Parent = "pfeLeft",
				Components = {
					new CuiTextComponent {
						Text = $"{(int) generator.powerOutput}",
						Align = TextAnchor.MiddleCenter,
						Color = textColor
					},
					new CuiRectTransformComponent {
						AnchorMin="0.07 0.1",
						AnchorMax="0.25 0.5"
					}
				}
			});
			container.Add(new CuiElement
			{
				Name = "pfeInputLabel",
				Parent = "pfeLeft",
				Components = {
					new CuiTextComponent {
						Text = "power",
						Align = TextAnchor.MiddleLeft,
						FontSize = fontSize,
						Color = textColor
					},
					new CuiRectTransformComponent {
						AnchorMin="0.35 0.1",
						AnchorMax="1.0 0.5"
					}
				}
			});
			#endregion
			#region Right
			container.Add(new CuiElement
			{
				Name = "pfeTimeText",
				Parent = "pfeRight",
				Components = {
					new CuiTextComponent {
						Text = Lang("time left", player.UserIDString, FormatTime(player, generator.GetHoursRemaining())),
						Align = TextAnchor.MiddleLeft,
						FontSize = fontSize,
						Color = textColor
					},
					new CuiRectTransformComponent {
						AnchorMin="0 0.6",
						AnchorMax="1 1.0"
					}
				}
			});
			container.Add(new CuiButton
			{
				Button = {
					Command = $"addhours {generator.boxId} 1",
					Color = GetBalance(player) >= Math.Round(generator.costPerHour, 0) ? btnColor : btnColorFaded
				},
				Text = {
					Text = Lang("pay1", player.UserIDString, Math.Round(generator.costPerHour, 0)),
					Align = TextAnchor.MiddleCenter,
					Color = GetBalance(player) >= Math.Round(generator.costPerHour, 0) ? "1 1 1 1" : "1 1 1 0.3",
					FontSize = btnSize
				},
				RectTransform = {
					AnchorMin = "0 0.1",
					AnchorMax = "0.4 0.5"
				}
			}, "pfeRight", "pfeButtonPay1");
			container.Add(new CuiButton
			{
				Button = {
					Command = $"addhours {generator.boxId} 24",
					Color = GetBalance(player) >= Math.Round(generator.costPerHour*24, 0) ? btnColor : btnColorFaded
				},
				Text = {
					Text = Lang("pay24", player.UserIDString, Math.Round(generator.costPerHour*24, 0)),
					Color = GetBalance(player) >= Math.Round(generator.costPerHour*24, 0) ? "1 1 1 1" : "1 1 1 0.3",
					Align = TextAnchor.MiddleCenter,
					FontSize = btnSize
				},
				RectTransform = {
					AnchorMin = "0.45 0.1",
					AnchorMax = "0.85 0.5"
				}
			}, "pfeRight", "pfeButtonPay24");
			#endregion
			CuiHelper.AddUi(player, container);
		}
		#endregion

		#region Localization
		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["days"] = "{0} days",
				["hours"] = "{0} hrs",
				["minutes"] = "{0} min",
				["power"] = "power",
				["no power"] = "NO POWER",
				["cost"] = "Cost: {0}/hr",
				["time left"] = "Time left: {0}",
				["pay1"] = "1 Hour ({0})",
				["pay24"] = "24 Hours ({0})",
				["title"] = "ELECTRIC GENERATOR"
			}, this);
		}

		private string Lang( string key, string id = null, params object[] args ) => string.Format(lang.GetMessage(key, this, id), args);

		#endregion
	}
}

// --- End of file: PayForElectricity.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/portals ---
// --- Original File Path: P/Portals/Portals.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Collections;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
	[Info("Portals", "LaserHydra", "3.1.0")]
	[Description("Allows to place Portals which you can step into to teleport")]
	public class Portals : RustPlugin
	{
		private const int PortalLayer = 3;

		private const string UsagePermission = "portals.use";
		private const string AdminPermission = "portals.admin";

		private Configuration _config;
		private static Portals _instance;

		#region Hooks

		private void OnServerInitialized()
		{
			_instance = this;

			permission.RegisterPermission(UsagePermission, this);
			permission.RegisterPermission(AdminPermission, this);

			LoadConfig();

			foreach (Portal portal in _config.Portals)
			{
				if (portal.RequiresIndiviualPermission)
					permission.RegisterPermission(portal.GetUsagePermission(), this);

				portal.Spawn();
			}
		}

		private void Unload()
		{
			foreach (var player in BasePlayer.activePlayerList)
				player.GetComponent<PlayerTeleporter>()?.Remove();

			foreach (Portal portal in _config.Portals)
				portal.Destroy();
		}

		private void OnPlayerDisconnected(BasePlayer player, string reason) =>
			player.GetComponent<PlayerTeleporter>()?.Remove();

		#endregion

		#region Commands

		[ChatCommand("portal")]
		private void PortalCommand(BasePlayer player, string cmd, string[] args)
		{
			if (!permission.UserHasPermission(player.UserIDString, AdminPermission))
			{
				SendMessage(player, "No Command Permission");
				return;
			}

			if (args.Length == 0)
			{
				SendMessage(player, "Command Syntax");
				return;
			}

			switch (args[0].ToLower())
			{
				case "list":
					{
						if (_config.Portals.Count == 0)
						{
							SendMessage(player, "No Existing Portals");
							return;
						}

						string[] portalNames = _config.Portals
							.Select(p => p.Name)
							.ToArray();

						SendMessage(player, "Portal List", string.Join(", ", portalNames));
					}

					break;

				case "remove":
					{
						if (args.Length == 2)
						{
							string name = args[1];

							Portal portal = _config.Portals.FirstOrDefault(p => p.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase));

							if (portal == null)
							{
								SendMessage(player, "Portal Doesn't Exist", name);
								return;
							}

							portal.Destroy();

							_config.Portals.Remove(portal);
							SaveConfig();

							SendMessage(player, "Portal Removed", name);
						}
						else
						{
							PortalPointBehaviour portalPoint = GetPortalPointInView(player);

							if (portalPoint == null)
							{
								SendMessage(player, "Not Looking At Portal (Remove)");
								return;
							}

							portalPoint.Portal.RemovePoint(portalPoint.Position);

							SaveConfig();

							SendMessage(player, "Portal Point Removed");
						}
					}

					break;

				case "info":
					{
						PortalPointBehaviour portalPoint = GetPortalPointInView(player);

						if (portalPoint == null)
						{
							SendMessage(player, "Not Looking At Portal (Info)");
							return;
						}

						SendMessage(player, "Portal Point Info", portalPoint.Portal.Name, portalPoint.PointType);
					}

					break;

				case "entr":
				case "entrance":
				case "exit":
					{
						if (args.Length < 2 || args.Length > 3)
						{
							SendMessage(player, "Command Syntax");
							return;
						}

						string name = args[1];
						bool removeOthers = false;

						if (args.Length == 3)
						{
							string tag = args[1];
							if (!tag.Equals("-r", StringComparison.InvariantCultureIgnoreCase))
							{
								SendMessage(player, "Invalid Tag", tag);
								return;
							}

							name = args[2];
							removeOthers = true;
						}

						Portal portal = _config.Portals.FirstOrDefault(p => p.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase));

						if (portal == null)
						{
							portal = new Portal { Name = name };
							_config.Portals.Add(portal);

							SendMessage(player, "Portal Created", name);
						}

						if (args[0].Equals("exit", StringComparison.InvariantCultureIgnoreCase))
						{
							if (removeOthers)
							{
								portal.RemovePointsOfType(Portal.PointType.Exit);
								SendMessage(player, "Exits Cleared", name);
							}

							portal.Exits.Add(player.transform.position);
							SendMessage(player, "Exit Added", name);
						}
						else
						{
							if (removeOthers)
							{
								portal.RemovePointsOfType(Portal.PointType.Entrance);
								SendMessage(player, "Entrances Cleared", name);
							}

							portal.Entrances.Add(player.transform.position);
							SendMessage(player, "Entrance Added", name);
						}

						portal.Spawn();

						SaveConfig();
					}

					break;

                default:
                    SendMessage(player, "Command Syntax");
                    break;
            }
		}

		#endregion

		#region Helper Methods

		private static void SendMessage(BasePlayer player, string key, params object[] args) =>
			_instance.PrintToChat(player, _instance.lang.GetMessage(key, _instance, player.UserIDString), args);

		private static PortalPointBehaviour GetPortalPointInView(BasePlayer player)
		{
			RaycastHit hit;

			if (Physics.Raycast(player.eyes.HeadRay(), out hit, 10))
			{
				var portalPoint = hit.collider.GetComponent<PortalPointBehaviour>();

				if (portalPoint != null)
					return portalPoint;
			}

			return null;
		}

		private static void Teleport(BasePlayer player, Vector3 destination)
		{
			if (player.net?.connection != null)
				player.ClientRPCPlayer(null, player, "StartLoading");

			player.StartSleeping();
			player.MovePosition(destination);

			if (player.net?.connection != null)
				player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);

			player.UpdateNetworkGroup();
			player.SendNetworkUpdateImmediate(false);

			if (player.net?.connection == null)
				return;

			try
			{
				player.ClearEntityQueue(null);
			}
			catch
			{ }

			player.SendFullSnapshot();
		}

		#endregion

		#region Localization

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				// Commands
				["No Command Permission"] = "You don't have permission to use this command.",
				["Command Syntax"] = string.Join(Environment.NewLine, new [] {
					"/portal list -- <i><color=#c0c0c0> list existing portal names</color></i>",
					"/portal entrance|entr|exit [-r] <portal> -- <i><color=#c0c0c0>add new entrance or exit to a portal; with '-r' all other entrances/exits are removed</color></i>",
					"/portal info -- <i><color=#c0c0c0>show information about the portal entrance/exit you are looking at</color></i>",
					"/portal remove -- <i><color=#c0c0c0>remove the portal entrance/exit you are looking at</color></i>",
					"/portal remove <portal> -- <i><color=#c0c0c0>remove the entire portal with the specified name</color></i>"
				}),
				["Invalid Tag"] = "Invalid tag '{0}', please check the command syntax again.",

				["No Existing Portals"] = "There aren't any portals.",
				["Portal List"] = "Portal names: {0}",

				["Not Looking At Portal (Remove)"] = "You are not looking at a portal entrance or exit. If you want to remove an entire portal, use '/portal remove <portal>'",
				["Not Looking At Portal (Info)"] = "You are not looking at a portal entrance or exit. If you want to list portals use '/portal list'",
				["Portal Doesn't Exist"] = "Portal with the name '{0}' does not exist.",

				["Portal Point Removed"] = "Successfully removed the entrance/exit you were looking at.",
				["Portal Removed"] = "Successfully removed portal '{0}'.",

				["Portal Point Info"] = string.Join(Environment.NewLine, new[] {
					"Portal Name: {0}",
					"Type: {1}",
				}),

				["Portal Created"] = "Successfully created a new portal with the name '{0}'.",
				["Entrances Cleared"] = "All entrances for portal '{0}' were removed.",
				["Exits Cleared"] = "All exits for portal '{0}' were removed.",
				["Entrance Added"] = "A new entrance was added to portal '{0}'.",
				["Exit Added"] = "A new exit was added to portal '{0}'.",

				// Usage
				["No Usage Permission"] = "You don't have permission to enter this portal.",
				["Teleporting Shortly"] = "You will be teleported in {0} seconds.",
				["Teleportation Cancelled"] = "The teleportation was cancelled."
			}, this);
		}

		#endregion

		#region Configuration

		protected override void LoadConfig()
		{
			base.LoadConfig();
			_config = Config.ReadObject<Configuration>();
			SaveConfig();
		}

		protected override void LoadDefaultConfig() => _config = new Configuration();

		protected override void SaveConfig() => Config.WriteObject(_config);

		private class Configuration
		{
			[JsonProperty("Sphere Radius")]
			public float SphereRadius { get; set; } = 1f;

			[JsonProperty("Sphere Density (Enterable)")]
			public ushort SphereEntityCount { get; set; } = 3;

			[JsonProperty("Sphere Density (Not Enterable)")]
			public ushort ExitSphereEntityCount { get; set; } = 1;

			public HashSet<Portal> Portals { get; set; } = new HashSet<Portal>();
		}

		#endregion

		#region Portals and teleportation

		private class PlayerTeleporter : MonoBehaviour
		{
			public BasePlayer Player { get; private set; }

			public bool IsRunning { get; private set; }

			public Vector3 Destination { get; set; }
			public int Seconds { get; set; }

			public bool ReachedDestination { get; set; }

			public void Start()
			{
				if (IsRunning)
					return;

				StartCoroutine(nameof(Teleport));
				IsRunning = true;
				ReachedDestination = false;
			}

			public void Stop()
			{
				StopCoroutine(nameof(Teleport));
				IsRunning = false;
			}

			public void Remove() => Destroy(this);

			private void Awake() => Player = GetComponent<BasePlayer>();

			private IEnumerator Teleport()
			{
				yield return new WaitForSecondsRealtime(Seconds);

				IsRunning = false;

				Portals.Teleport(Player, Destination);
			}
		}

		private class PortalPointBehaviour : MonoBehaviour
		{
			private SphereEntity[] _sphereEntities = null;

			public Portal Portal { get; private set; }
			public Portal.PointType PointType { get; private set; }
			public Vector3 Position { get; private set; }

			private bool _isEnterable;
			private Portal.PointType _opposingPointType;
			private float _radius;
			private ushort _sphereEntityCount;

			private void Awake()
			{
				gameObject.layer = Portals.PortalLayer;

				var rigidbody = gameObject.AddComponent<Rigidbody>();
				rigidbody.useGravity = false;
				rigidbody.isKinematic = true;
				rigidbody.detectCollisions = true;
				rigidbody.collisionDetectionMode = CollisionDetectionMode.Discrete;

				var collider = gameObject.AddComponent<SphereCollider>();
				collider.radius = _radius;
				collider.isTrigger = true;
				collider.enabled = true;

				SpawnSphereEntities();
			}

			private void SpawnSphereEntities()
			{
				if (_sphereEntities != null)
					return;

				_sphereEntities = new SphereEntity[_sphereEntityCount];

				for (int i = 0; i < _sphereEntityCount; i++)
				{
					var sphere = GameManager.server.CreateEntity("assets/prefabs/visualization/sphere.prefab", transform.position)
						.GetComponent<SphereEntity>();

					sphere.currentRadius = _radius * 2;
					sphere.lerpRadius = _radius * 2;
					sphere.lerpSpeed = 1f;
					sphere.Spawn();

					_sphereEntities[i] = sphere;
				}
			}
			
			private void OnTriggerEnter(Collider collider)
			{
				var teleporter = collider.gameObject.GetComponent<PlayerTeleporter>();
				if (teleporter != null && !teleporter.ReachedDestination && !teleporter.Player.IsSleeping())
				{
					teleporter.ReachedDestination = true;
					return;
				}

				if (!_isEnterable)
					return;

				BasePlayer player = collider.gameObject.GetComponent<BasePlayer>();

				if (player != null && !player.IsSleeping())
				{
					if (Portal.HasPermission(player))
					{
						var destination = Portal.GetRandomPoint(_opposingPointType);

						if (destination != null)
							Teleport(player, (Vector3)destination);
					}
					else
					{
						Portals.SendMessage(player, "No Portal Permission");
					}
				}
			}

			private void OnTriggerExit(Collider collider)
			{
				if (!_isEnterable)
					return;

				var teleporter = collider.gameObject.GetComponent<PlayerTeleporter>();

				if (teleporter?.IsRunning ?? false)
				{
					teleporter.Stop();

					Portals.SendMessage(teleporter.Player, "Teleportation Cancelled");
				}
			}

			private void Teleport(BasePlayer player, Vector3 destination)
			{
				var teleporter = player.gameObject.GetComponent<PlayerTeleporter>() 
					?? player.gameObject.AddComponent<PlayerTeleporter>();

				teleporter.Destination = destination;
				teleporter.Seconds = Portal.TeleportationTime;

				teleporter.Start();

				if (Portal.TeleportationTime != 0)
				{
					Portals.SendMessage(player, "Teleporting Shortly", Portal.TeleportationTime);
				}
			}

			public void Destroy()
			{
				if (_sphereEntities != null)
				{
					foreach (var sphereEntity in _sphereEntities)
						sphereEntity.Kill();
				}

				_sphereEntities = null;

				Destroy(gameObject);
			}

			public static PortalPointBehaviour Create(Portal portal, Portal.PointType pointType, Vector3 position)
			{
				var gameObject = new GameObject();
				gameObject.transform.position = position + new Vector3(0, _instance._config.SphereRadius);

				// Deactivate gameObject temporarily to allow initializing of the portal point before Awake()
				gameObject.SetActive(false);

				var behaviour = gameObject.AddComponent<PortalPointBehaviour>();
				behaviour.Portal = portal;
				behaviour.Position = position;
				behaviour.PointType = pointType;
				behaviour._opposingPointType = pointType == Portal.PointType.Entrance
					? Portal.PointType.Exit
					: Portal.PointType.Entrance;
				behaviour._isEnterable = !portal.IsOneWay || pointType == Portal.PointType.Entrance;
				behaviour._radius = _instance._config.SphereRadius;
				behaviour._sphereEntityCount = behaviour._isEnterable
					? _instance._config.SphereEntityCount
					: _instance._config.ExitSphereEntityCount;

				gameObject.SetActive(true);

				return behaviour;
			}
		}

		private class Portal
		{
			private readonly List<PortalPointBehaviour> _portalPoints = new List<PortalPointBehaviour>();

			public string Name { get; set; }

			public bool IsOneWay { get; set; } = true;
			public bool RequiresIndiviualPermission { get; set; } = false;
			public int TeleportationTime { get; set; } = 0;

			public List<Vector3> Entrances { get; set; } = new List<Vector3>();
			public List<Vector3> Exits { get; set; } = new List<Vector3>();

			public bool HasPermission(BasePlayer player) => Portals._instance.permission.UserHasPermission(player.UserIDString, GetUsagePermission());

			public string GetUsagePermission() => RequiresIndiviualPermission
				? $"{Portals.UsagePermission}.{this.Name}"
				: Portals.UsagePermission;

			public void Spawn()
			{
				Destroy();

				foreach (var position in Entrances)
					_portalPoints.Add(PortalPointBehaviour.Create(this, PointType.Entrance, position));

				foreach (var position in Exits)
					_portalPoints.Add(PortalPointBehaviour.Create(this, PointType.Exit, position));
			}

			public void Destroy()
			{
				if (_portalPoints.Count == 0)
					return;

				foreach (var portalPoint in _portalPoints)
					portalPoint.Destroy();

				_portalPoints.Clear();
			}

			public void RemovePoint(Vector3 position)
			{
				if (Entrances.Contains(position))
				{
					DestroyPointBehaviour(position);
					Entrances.Remove(position);
				}
				else if (Exits.Contains(position))
				{
					DestroyPointBehaviour(position);
					Exits.Remove(position);
				}
			}

			public void RemovePointsOfType(PointType pointType)
			{
				if (pointType == PointType.Entrance)
				{
					for (int i = Entrances.Count - 1; i >= 0; i--)
					{
						RemovePoint(Entrances[i]);
					}
				}
				else if (pointType == PointType.Exit)
				{
					for (int i = Exits.Count - 1; i >= 0; i--)
					{
						RemovePoint(Exits[i]);
					}
				}
			}

			public Vector3? GetRandomPoint(PointType pointType)
			{
				if (pointType == PointType.Entrance)
				{
					if (Entrances.Count == 0)
						return null;

					return Entrances.GetRandom((uint)DateTime.UtcNow.Millisecond);
				}

				if (Exits.Count == 0)
					return null;

				return Exits.GetRandom((uint)DateTime.UtcNow.Millisecond);
			}

			private void DestroyPointBehaviour(Vector3 position)
			{
				for (int i = _portalPoints.Count - 1; i >= 0; i--)
				{
					PortalPointBehaviour point = _portalPoints[i];

					if (point.Position == position)
					{
						point.Destroy();
						_portalPoints.RemoveAt(i);
						return;
					}
				}
			}

			public enum PointType
			{
				Entrance,
				Exit
			}
		}

		#endregion
	}
}

// --- End of file: Portals.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pound-bot ---
// --- Original File Path: P/PoundBot/PoundBot.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Pound Bot", "MrPoundsign", "2.0.1")]
    [Description("Connector for the Discord bot PoundBot.")]

    class PoundBot : CovalencePlugin
    {
        const string EntityDeathURI = "/entity_death";
        const string ApiMessageBaseURI = "/messages";
        const string ApiRolesURI = "/roles";
        const string ApiChatURI = "/chat";
        const string ApiRegisteredPlayersURI = "/players/registered";
        const string ApiDiscordAuthURI = "/discord_auth";
        const string ApiClansURI = "/clans";

        private string ApiBaseURI;

        enum DebugLevels { TRACE, INFO };

        protected string DebugURI = "";
        protected int DebugLevel = (int)DebugLevels.INFO;
        protected int ApiRetrySeconds = 1;
        protected int ApiRetryNotify = 30;

        protected string RegisteredUsersGroup;
        protected bool ApiInError;
        protected bool ApiRetry;
        protected uint ApiRetryAttempts;
        protected DateTime ApiErrorTime;
        protected DateTime LastApiAttempt;
        private Dictionary<string, string> RequestHeaders;
        protected bool RegisteredUsersInFlight;
        private ChannelList KnownChannelList;

        class ApiErrorResponse
        {
            public string Error;
        }

        class ApiRequest
        {
            public RequestMethod Method;
            public string URI;
            public string Body;
            public Plugin Plugin;
            public string RequestUUID;

            public ApiRequest(RequestMethod method, string uri, string body, Plugin plugin)
            {
                Method = method;
                URI = uri;
                Body = body;
                Plugin = plugin;
                RequestUUID = Guid.NewGuid().ToString();
            }
        }

        #region PoundBot messages
        class Channel
        {
            public string ID;
            public string Name;
            public bool CanSend;
            public bool CanStyle;

            public bool IsAvailable()
            {
                return CanSend || CanStyle;
            }
        }

        class ChannelList
        {
            public Channel[] Channels;

            public bool CanSendTo(string channel)
            {
                foreach (Channel chan in Channels)
                {
                    if (chan.Name == channel || chan.ID == channel)
                    {
                        return chan.CanSend;
                    }
                }
                return false;
            }

            public bool CanStyleTo(string channel)
            {
                foreach (Channel chan in Channels)
                {
                    if (chan.Name == channel || chan.ID == channel)
                    {
                        return chan.CanStyle;
                    }
                }
                return false;
            }
        }

        class DiscordAuth
        {
            public string PlayerID;
            public string DisplayName;
            public string ClanTag;
            public string DiscordName;
            public int Pin;
            public DateTime CreatedAt;

            public DiscordAuth(string displayName, string discordName, string playerid)
            {
                Pin = new System.Random().Next(1, 9999);
                DisplayName = displayName;
                DiscordName = discordName;
                PlayerID = playerid;
                CreatedAt = DateTime.UtcNow;
            }
        }

        public class GameMessageEmbedStyle
        {
            public string Color { get; set; }
        }

        class GameMessagePart
        {
            public string Content { get; set; }
            public bool Escape { get; set; }
        }

        class GameMessage
        {
            public GameMessagePart[] MessageParts { get; set; }
            public int Type { get; set; } // 0 = plain, 1 = embedded
            public GameMessageEmbedStyle EmbedStyle { get; set; }
        }

        class RoleSyncRequest
        {
            public string GuildID;
            public string[] PlayerIDs;
        }

        class EntityDeath
        {
            public string Name;
            public string GridPos;
            public string[] OwnerIDs;
            public DateTime CreatedAt;

            public EntityDeath(string name, string gridpos, string[] ownerIDs)
            {
                Name = name;
                GridPos = gridpos;
                OwnerIDs = ownerIDs;
                CreatedAt = DateTime.UtcNow;
            }
        }
        #endregion

        #region Configuration
        protected override void LoadDefaultConfig()
        {
            Config["api.url"] = "https://api.poundbot.com/";
            Config["api.key"] = "API KEY HERE";
            Config["config.version"] = 2;
            Config["players.registered.group"] = "poundbot.registered";
        }

        void UpgradeConfig()
        {
            string configVersion = "config.version";
            bool dirty = false;

            if (Config[configVersion] == null)
            {
                Config[configVersion] = 1;
            }
            else
            {
                try
                {
                    var foo = (string)Config[configVersion];
                    Config[configVersion] = 2;
                    dirty = true;
                }
                catch (InvalidCastException) { } // testing if it can be converted to a string or not. No need to change it because it's not a string.
            }

            if ((int)Config[configVersion] < 2)
            {
                LogWarning(string.Format(lang.GetMessage("config.upgrading", this), "1.1.2"));

                // Update the API endpoint
                string api_url = (string)Config["api_url"];
                if (api_url == "http://poundbot.mrpoundsign.com/" || api_url == "http://api.poundbot.com/")
                {
                    Config["api.url"] = "https://api.poundbot.com/";
                }
                else
                {
                    Config["api.url"] = (string)Config["api_url"];
                }
                Config["api.key"] = (string)Config["api_key"];
                Config.Remove("api_url");
                Config.Remove("api_key");
                Config["players.registered.group"] = "poundbot.registered";
                Config[configVersion] = 2;
                dirty = true;
            }

            if (dirty)
            {
                SaveConfig();
            }
        }
        #endregion

        #region Language
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["config.upgrading"] = "Upgrading config to v{0}",
                ["config.api_key_updated"] = "Your API key has been updated. Check config/PoundBot.json.",
                ["command.poundbot_register"] = "pbreg",
                ["connector.reconnected"] = "Reconnected with PoundBot",
                ["connector.time_in_error"] = "Total time in error: {0}",
                ["connector.error"] = "Error communicating with PoundBot: {0}:{1}",
                ["connector.error_with_rid"] = "Error communicating with PoundBot: [{0}] {1}:{2}",
                ["connector.user_error"] = "Cannot connect to PoundBot right now. Please alert the admins.",
                ["discord.pin"] = "Enter the following PIN to the bot in discord: {0}.",
                ["discord.connected"] = "You are registered.",
                ["discord.already_connected"] = "You are already registered.",
                ["discord.not_connected"] = "Registration not found.",
                ["discord.channels_updated"] = "Channel cache updated.",
                ["discord.channel_cannot_send"] = "Cannot send to channel {0}. Please check that the bot can send to this channel. Run pb.updatechannels after making Discord changes to update the cache.",
                ["discord.channel_cannot_style"] = "Cannot send to channel {0}. Please check that the bot can embed links to this channel. Run pb.updatechannels after making Discord changes to update the cache.",
                ["usage.pbreg"] = "Usage: {0} \"<discord name>\"\n Example: {0} \"Fancy Guy#8080\"",
                ["usage.set_api_key"] = "Usage:\n\tpb.set_api_key <api key>",
                ["discord.console.registration_attempt"] = "Player {0}({1}) attempting to register as {2}",
            }, this);
        }

        #endregion

        #region Oxide API
        void Init()
        {
            UpgradeConfig();
            ApiBaseURI = $"{Config["api.url"]}api";
            ApplyConfig();

            RegisteredUsersGroup = (string)Config["players.registered.group"];
            permission.RegisterPermission(RegisteredUsersGroup, this);
            if (!permission.GroupExists(RegisteredUsersGroup))
            {
                permission.CreateGroup(RegisteredUsersGroup, "PoundBot Registered Users", 0);
            }

            AddLocalizedCommand("command.poundbot_register", "CommandPoundBotRegister");

            Connected();

            timer.Every(5f, () =>
            {
                if (RegisteredUsersInFlight) return;
                RegisteredUsersInFlight = true;
                Request(new ApiRequest(RequestMethod.GET, ApiRegisteredPlayersURI, null, this),
          (code, response) =>
          {
                  RegisteredUsersInFlight = false;
                  if (code == 200)
                  {
                      string[] groupPlayerIDs = permission.GetUsersInGroup(RegisteredUsersGroup);
                      string[] playerIDs = JsonConvert.DeserializeObject<string[]>(response);

                      for (int i = 0; i < groupPlayerIDs.Length; i++)
                      {
                          groupPlayerIDs[i] = groupPlayerIDs[i].Substring(0, groupPlayerIDs[i].IndexOf(' '));
                      }

                // hot group diff action
                string[] playersToRemove = groupPlayerIDs.Except(playerIDs).ToArray();
                      string[] playersToAdd = playerIDs.Except(groupPlayerIDs).ToArray();

                      if (playersToAdd.Length + playersToRemove.Length == 0)
                      {
                          return true;
                      }

                      foreach (string id in playersToRemove)
                      {
                          Puts($"Removing user {id} from {RegisteredUsersGroup}");
                          permission.RemoveUserGroup(id, RegisteredUsersGroup);
                      }

                      foreach (string id in playersToAdd)
                      {
                          Puts($"Adding user {id} to {RegisteredUsersGroup}");
                          permission.AddUserGroup(id, RegisteredUsersGroup);
                      }
                      return true;
                  }

                  Puts("Unuccessful registered players get");
                  Puts(response);
                  return false;
              });
            });
        }
        #endregion

        private void ApplyConfig()
        {
            RequestHeaders = new Dictionary<string, string>
            {
                ["Content-type"] = "application/json",
                ["Authorization"] = $"Token {Config["api.key"]}",
                ["X-PoundBotConnector-Version"] = Version.ToString(),
                ["User-Agent"] = $"PoundBotConnector/{Version.ToString()}",
                ["X-PoundBot-Game"] = covalence.Game.ToLower()
            };
        }

        #region API

        // private Dictionary<string, string> Headers() => RequestHeaders;

        private string API_RegisteredUsersGroup() => RegisteredUsersGroup;

        private string ApiBase() => ApiBaseURI;

        private bool ApiRequestOk()
        {
            if (ApiInError && !ApiRetry && (LastApiAttempt.AddSeconds(ApiRetrySeconds) < DateTime.Now))
            {
                ApiRetryAttempts++;
                if (ApiRetryAttempts == 1 || ApiRetryAttempts % ApiRetryNotify == 0)
                {
                    Puts(string.Format(lang.GetMessage("connector.time_in_error", this), DateTime.Now.Subtract(ApiErrorTime)));
                }
                ApiRetry = true;
            }
            return (!ApiInError || ApiRetry);
        }

        private void ApiError(int code, string response, string requestID = null)
        {
            string error;
            if (ApiInError)
            {
                if (ApiRetry)
                {
                    LastApiAttempt = DateTime.Now;
                    ApiRetry = false;
                }

                if (ApiRetryAttempts % ApiRetryNotify != 0) return;
            }
            else
            {
                ApiErrorTime = DateTime.Now;
                LastApiAttempt = DateTime.Now;
                ApiInError = true;
                ApiRetry = false;
            }

            if (code == 0)
            {
                error = "Connection Failure!";
            }
            else
            {
                try
                {
                    var air = JsonConvert.DeserializeObject<ApiErrorResponse>(response);
                    error = air.Error;
                }
                catch
                {
                    error = response;
                }
            }
            if (code == 0)
            {
                Puts(string.Format(lang.GetMessage("connector.error", this), code, error));
                return;
            }
            Puts(string.Format(lang.GetMessage("connector.error_with_rid", this), requestID, code, error));

        }

        private bool ApiSuccess(bool success)
        {
            // Reset retry variables if we're successful
            if (ApiInError && success)
            {
                Puts(lang.GetMessage("connector.reconnected", this));
                Puts(string.Format(lang.GetMessage("connector.time_in_error", this), DateTime.Now.Subtract(ApiErrorTime)));
                ApiRetryAttempts = 0;
                ApiInError = false;
                ApiRetry = true;
                Connected();
            }
            return success;
        }

        #region Requests

        private bool Request(ApiRequest api_request, Func<int, string, bool> callback)
        {
            if (!ApiRequestOk()) return false;

            if (DebugURI.Length > 0 && api_request.URI.StartsWith(DebugURI))
            {
                Puts($"Request from {api_request.Plugin.Name} to {api_request.URI} with RequestUUID {api_request.RequestUUID}\n{api_request.Body}");
            }

            if (api_request.Plugin == null)
            {
                api_request.Plugin = this;
            }

            Dictionary<string, string> rHeaders = new Dictionary<string, string>(RequestHeaders);
            rHeaders["X-Request-ID"] = api_request.RequestUUID;

            webrequest.Enqueue($"{ApiBaseURI}{api_request.URI}", api_request.Body,
            (code, response) =>
            {
                if (!ApiSuccess(callback(code, response)))
                {
                    ApiError(code, response, rHeaders["X-Request-ID"]);
                }
            },
            api_request.Plugin, api_request.Method, rHeaders, 12000f);

            return true;
        }
        // Returns true if request was sent, false otherwise.
        private bool API_Request(string uri, string body, Func<int, string, bool> callback, Plugin owner, RequestMethod method = RequestMethod.GET, Dictionary<string, string> headers = null)
        {
            return Request(new ApiRequest(method, uri, body, this), callback);
        }
        #endregion

        #region Messages API
        private bool API_SendChannelMessage(Plugin owner, string channel, KeyValuePair<string, bool>[] message_parts, string embed_color = null, Func<int, string, bool> callback = null, Dictionary<string, string> headers = null, string type = "plain")
        {
            List<GameMessagePart> parts = new List<GameMessagePart>();

            foreach (KeyValuePair<string, bool> part in message_parts)
            {
                parts.Add(
                  new GameMessagePart
                  {
                      Content = part.Key,
                      Escape = part.Value
                  }
                );
            }

            GameMessage sm = new GameMessage
            {
                MessageParts = parts.ToArray()
            };

            if (embed_color != null)
            {
                if (!KnownChannelList.CanStyleTo(channel))
                {
                    Puts(string.Format(lang.GetMessage("discord.channel_cannot_style", this), channel));
                    return false;
                }
                sm.Type = 1;
                sm.EmbedStyle = new GameMessageEmbedStyle
                {
                    Color = embed_color
                };
            }
            else
            {
                if (!KnownChannelList.CanSendTo(channel))
                {
                    Puts(string.Format(lang.GetMessage("discord.channel_cannot_send", this), channel));
                    return false;
                }
            }

            if (channel[0] == '#')
            {
                channel = channel.Substring(1);
            }

            if (callback == null)
            {
                callback = (int code, string response) => (code == 200);
            }

            string body = JsonConvert.SerializeObject(sm);
            return Request(new ApiRequest(RequestMethod.POST, $"{ApiMessageBaseURI}/{channel}", body, owner), callback);
        }

        private bool API_GetChannelMessage(Plugin owner, string channel, Func<int, string, bool> callback = null)
        {
            return Request(new ApiRequest(RequestMethod.GET, ApiChatURI, null, owner), callback);
        }
        #endregion

        #region Roles API
        private bool API_SendRole(Plugin owner, string[] groupPlayerIDs, string role, Func<int, string, bool> callback)
        {
            RoleSyncRequest rsr = new RoleSyncRequest
            {
                PlayerIDs = groupPlayerIDs,
            };

            return Request(new ApiRequest(RequestMethod.POST, $"{ApiRolesURI}/{role}", JsonConvert.SerializeObject(rsr), owner), callback);
        }
        #endregion

        private bool API_SendEntityDeath(Plugin owner, string name, string gridPos, string[] owners, Func<int, string, bool> callback)
        {
            EntityDeath di = new EntityDeath(name, gridPos, owners);

            return Request(new ApiRequest(RequestMethod.PUT, EntityDeathURI, JsonConvert.SerializeObject(di), owner), callback);
        }

        private bool API_SendClans(Plugin owner, List<JObject> clans, Func<int, string, bool> callback)
        {
            return Request(new ApiRequest(RequestMethod.PUT, ApiClansURI, JsonConvert.SerializeObject(clans), owner), callback);
        }

        private bool API_SendClan(Plugin owner, string tag, JObject clan, Func<int, string, bool> callback)
        {
            return Request(new ApiRequest(RequestMethod.PUT, $"{ApiClansURI}/{tag}", JsonConvert.SerializeObject(clan), owner), callback);
        }

        private bool API_DeleteClan(Plugin owner, string tag, Func<int, string, bool> callback)
        {
            return Request(new ApiRequest(RequestMethod.DELETE, $"{ApiClansURI}/{tag}", null, owner), callback);
        }

        private void Connected()
        {
            UpdateChannels();
            Interface.Call("OnPoundBotConnected");
        }
        #endregion

        private void UpdateChannels()
        {
            Request(new ApiRequest(RequestMethod.GET, ApiMessageBaseURI, null, this),
                (code, response) =>
                {
                    if (code == 200)
                    {
                        KnownChannelList = JsonConvert.DeserializeObject<ChannelList>(response);
                        Puts(lang.GetMessage("discord.channels_updated", this));
                        return true;
                    }

                    return false;
                });
        }

        public void PrintChannels(bool all = false)
        {
            foreach (Channel c in KnownChannelList.Channels)
            {
                if (all || c.IsAvailable())
                {
                    Puts($"ID: {c.ID}, Name: {c.Name}, CanSend: {c.CanSend}, CanStyle: {c.CanStyle}");
                }
            }
        }

        #region Helpers
        private void AddLocalizedCommand(string key, string command)
        {
            foreach (var language in lang.GetLanguages(this))
            {
                var messages = lang.GetMessages(language, this);
                foreach (var message in messages.Where(m => m.Key.Equals(key)))
                    if (!string.IsNullOrEmpty(message.Value)) AddCovalenceCommand(message.Value, command);
            }
        }
        #endregion

        #region Commands
        private void CommandPoundBotRegister(IPlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                player.Message(string.Format(lang.GetMessage("usage.pbreg", this, player.Id), lang.GetMessage("command.poundbot_register", this, player.Id)));
                return;
            }

            if (args[0] == "check")
            {
                Request(new ApiRequest(RequestMethod.GET, $"{ApiDiscordAuthURI}/check/{player.Id}", null, this),
                (code, response) =>
                {
                    if (code == 200)
                    {
                        player.Message(lang.GetMessage("discord.connected", this, player.Id));
                        return true;
                    }

                    if (code == 404) // Method not allowed means we're already connected
            {
                        player.Message(lang.GetMessage("discord.not_connected", this, player.Id));
                        return true;
                    }

                    return false;
                });

                return;
            }

            Regex r = new Regex(@"^[^#]+#[0-9]+$");
            if (!r.Match(args[0]).Success)
            {
                player.Message(lang.GetMessage("usage.pbreg", this, player.Id));
                return;
            }

            string.Format(lang.GetMessage("discord.console.registration_attempt", this), player.Name, player.Id, args[0]);

            var da = new DiscordAuth(player.Name, args[0], player.Id);

            Request(new ApiRequest(RequestMethod.PUT, ApiDiscordAuthURI, JsonConvert.SerializeObject(da), this),
              (code, response) =>
              {
                  if (code == 200)
                  {
                      player.Message(string.Format(lang.GetMessage("discord.pin", this, player.Id), da.Pin.ToString("D4")));
                      return true;
                  }

                  if (code == 409) // Conflict means we're already connected
            {
                      player.Message(lang.GetMessage("discord.already_connected", this, player.Id));
                      return true;
                  }

                  return false;
              });
        }

        [Command("pb.update_channels")]
        private void ConsoleCommandUpdateChannels(IPlayer player, string command, string[] args)
        {
            UpdateChannels();
        }

        [Command("pb.channels")]
        private void ConsoleCommandChannels(IPlayer player, string command, string[] args)
        {
            PrintChannels((args.Length != 0));
        }

        [Command("pb.set_api_key")]
        private void ConsoleCommandSetAPIKey(IPlayer player, string command, string[] args)
        {
            if (args.Count() != 1)
            {
                Puts(lang.GetMessage("usage.set_api_key", this));
                return;
            }

            Puts(lang.GetMessage("config.api_key_updated", this));
            Config["api.key"] = args[0];
            SaveConfig();
            ApplyConfig();
        }

        [Command("pb.set_debug_uri")]
        private void ConsoleCommandSetDebugURI(IPlayer player, string command, string[] args)
        {
            if (args.Count() != 1)
            {
                Puts(lang.GetMessage("usage.set_debug_uri", this));
                return;
            }

            DebugURI = args[0];
        }
        #endregion
    }
}

// --- End of file: PoundBot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/private-messages-gui ---
// --- Original File Path: P/PrivateMessagesGUI/PrivateMessagesGUI.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Plugins;
using System;

namespace Oxide.Plugins
{
    [Info("Private Messages GUI", "Tricky/TurtleInBlack", "1.1.0")]
    [Description("Shows the sent messages of the PrivateMessages plugin as game tips.")]

    public class PrivateMessagesGUI : CovalencePlugin
    {
        #region References

        // Required dependency.
        [PluginReference]
        private Plugin PrivateMessages;

        #endregion

        #region Fields

        // Configuration.
        private static Configuration config;

        #endregion

        #region Configuration

        /// <summary>
        /// Provides the configuration options.
        /// </summary>
        private class Configuration
        {
            [JsonProperty(PropertyName = "Game Tip Duration In Seconds")]
            public float GameTipDuration { get; set; }

            [JsonProperty(PropertyName = "Show To Sender")]
            public bool ShowToSender { get; set; }

            [JsonProperty(PropertyName = "Show To Receiver")]
            public bool ShowToReceiver { get; set; }
        }

        /// <summary>
        /// Provides the default values for each configuration key.
        /// </summary>
        private Configuration DefaultConfig()
        {
            return new Configuration
            {
                GameTipDuration = 10f,
                ShowToSender = false,
                ShowToReceiver = true,
            };
        }

        /// <summary>
        /// Loads the configuration file.
        /// </summary>
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception exception)
            {
                PrintError(exception.ToString());
                PrintWarning("Failed to load the configuration file.");
                return;
            }
            SaveConfig();
        }

        /// <summary>
        /// Creates a configuration file and populates it with the required default values.
        /// </summary>
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file.");
            config = DefaultConfig();
        }

        /// <summary>
        /// Saves the configuration file.
        /// </summary>
        protected override void SaveConfig()
        {
            Config.WriteObject(config, true);
        }

        #endregion

        #region Initialization and Quitting

        /// <summary>
        /// Called after the server startup has been completed and is awaiting connections or when a plugin is hot loaded.
        /// </summary>
        private void OnServerInitialized()
        {
            // Send a warning if the dependency is not present or not loaded.
            if (PrivateMessages == null || !PrivateMessages.IsLoaded)
                PrintWarning("PrivateMessages is not installed and is required to use this plugin. Get it at http://umod.org.");
        }

        /// <summary>
        /// Called when a plugin is being unloaded.
        /// </summary>
        private void Unload()
        {
            // Nullify the configuration to leave no traces behind.
            config = null;
        }

        #endregion

        #region Custom Hooks

        private void OnPMProcessed(IPlayer sender, IPlayer receiver, string message)
        {
            // Show the game tip to the sender if enabled.
            if (config.ShowToSender)
                SendGameTip(sender, GetMessage("PMTo", sender.Id, receiver.Name, message));

            // Show the game tip to the receiver if enabled.
            if (config.ShowToReceiver)
                SendGameTip(receiver, GetMessage("PMFrom", receiver.Id, sender.Name, message));
        }

        #endregion

        #region Functions

        /// <summary>
        /// Creates a game tip and sends it to the target player.
        /// </summary> 
        /// <param name="player"> The player to whom the game tip is to be sent. </param>
        /// <param name="message"> The given message in the game tip. </param>
        private void SendGameTip(IPlayer player, string message)
        {
            // Strip the formatting tags off the message and convert it into plain text. Note: This doesn't affect the text size tag.
            message = Formatter.ToPlaintext(message);

            // Send the game tip.
            player.Command("gametip.showgametip", message);
            // If the player is still alive, hide the game tip after a set interval of time in seconds.
            timer.Once(config.GameTipDuration, () => player?.Command("gametip.hidegametip"));
        }

        #endregion

        #region Helper Functions

        /// <summary>
        /// Gets the localized and formatted message from the localization file.
        /// </summary>
        /// <param name="messageKey"> The message key. </param>
        /// <param name="playerId"> The player to whom the message is to be sent. </param>
        /// <param name="args"> Any additional arguments required in the message. </param>
        /// <returns> The localized message for the stated key. </returns>
        private string GetMessage(string messageKey, string playerId = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(messageKey, PrivateMessages, playerId), args);
            }
            catch (Exception exception)
            {
                PrintError(exception.ToString());
                throw;
            }
        }

        #endregion
    }
}

// --- End of file: PrivateMessagesGUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/placeholder-api ---
// --- Original File Path: P/PlaceholderAPI/PlaceholderAPI.cs ---

// Uncomment this line to enable some debug output and performance measurers
//#define DEBUG
//#define Conditionals

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
#if DEBUG
using System.Diagnostics;
#endif

namespace Oxide.Plugins;

[Info("Placeholder API", "misticos", "2.2.5")]
[Description("Centralized location to query data from other plugins. Streamlined, convenient, and performant.")]
internal class PlaceholderAPI : CovalencePlugin
{
    #region Variables

#if RUST
    [PluginReference(nameof(Game.Rust.RustCore))]
    private Plugin _rustCore = null;
#endif

#if SEVENDAYSTODIE
        private int _bloodMoonFrequency;
#endif

    private Dictionary<string, Placeholder> _placeholdersByName =
        new Dictionary<string, Placeholder>();

    private string _serverAddress;

    private static PlaceholderAPI _ins;

    private const string PermissionList = "placeholderapi.list";
    private const string CommandNameList = "placeholderapi.list";

    private const string PermissionTest = "placeholderapi.test";
    private const string CommandNameTest = "placeholderapi.test";

    private const string HookNameReady = "OnPlaceholderAPIReady";
    private const string HookNameAddressDataRetrieved = "OnAddressDataRetrieved";

    #endregion

    #region Configuration

    private Configuration _config;

    private class Configuration
    {
        [JsonProperty(PropertyName = "Placeholders", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, string> Placeholders = new Dictionary<string, string>
        {
            { "key", "Custom value" }
        };

        [JsonProperty(PropertyName = "Culture Ietf Tag")]
        public string DefaultCulture = "en-US";

        [JsonProperty(PropertyName = "Local Time Offset")]
        public TimeSpan LocalTimeOffset = TimeSpan.Zero;

#if RUST
        [JsonProperty(PropertyName = "Map Wipe Schedule")]
        public WipeSchedule MapWipe = new WipeSchedule();

        [JsonProperty(PropertyName = "Blueprints Wipe Schedule")]
        public WipeSchedule BlueprintsWipe = new WipeSchedule();
#endif

        [JsonProperty(PropertyName = "Request Address Data (ip-api.com)")]
        public bool RequestAddressData = true;

        [JsonIgnore]
        public CultureInfo Culture;

        public class WipeSchedule
        {
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Every First Month Day")]
            public DayOfWeek? EveryFirstDay = DayOfWeek.Friday;

            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Every N Day")]
            public DayOfWeek? EveryDay = DayOfWeek.Monday;

            [JsonProperty(PropertyName = "Every")]
            public TimeSpan? Every = TimeSpan.FromDays(7);

            [JsonProperty(PropertyName = "Time")]
            public TimeSpan? Time = TimeSpan.FromHours(12);

            public DateTime GetNextWipeDate(DateTime lastWipe)
            {
                var date = lastWipe;
                if (EveryFirstDay != null)
                {
                    var nextWipeCurrentMonth = GetFirstMonthDayOfWeek(lastWipe, EveryFirstDay.Value);
                    date = nextWipeCurrentMonth < lastWipe
                        ? GetFirstMonthDayOfWeek(lastWipe.AddMonths(1), EveryFirstDay ?? DayOfWeek.Friday)
                        : nextWipeCurrentMonth;
                }

                if (EveryDay != null)
                {
                    var nextDay = GetNextDayOfWeek(lastWipe, EveryDay.Value);
                    if (nextDay < date && nextDay > lastWipe)
                        date = nextDay;
                }

                if (Every != null)
                {
                    var next = lastWipe.Add(Every.Value);
                    if (next > date)
                        date = next;
                }

                if (Time != null)
                    date = date.Date + Time.Value;

                return date;
            }

            private DateTime GetFirstMonthDayOfWeek(DateTime date, DayOfWeek day) =>
                GetNextDayOfWeek(date.AddDays(-date.Day + 1), day);

            private DateTime GetNextDayOfWeek(DateTime date, DayOfWeek day) =>
                date.AddDays(Math.Abs(date.DayOfWeek - day - 7) % 7);
        }
    }

    protected override void LoadConfig()
    {
        base.LoadConfig();
        try
        {
            _config = Config.ReadObject<Configuration>();
            if (_config == null) throw new Exception();

            try
            {
                _config.Culture = CultureInfo.GetCultureInfoByIetfLanguageTag(_config.DefaultCulture);
            }
            catch
            {
                _config.Culture = CultureInfo.CurrentCulture;
                Interface.Oxide.LogInfo(
                    $"{_config.DefaultCulture} is an invalid language tag! Valid: {string.Join(", ", CultureInfo.GetCultures(CultureTypes.AllCultures).Select(x => x.IetfLanguageTag).ToArray())}");
            }

            SaveConfig();
        }
        catch
        {
            PrintError("Your configuration file contains an error. Using default configuration values.");
            LoadDefaultConfig();
        }
    }

    protected override void SaveConfig() => Config.WriteObject(_config);

    protected override void LoadDefaultConfig() => _config = new Configuration();

    #endregion

    #region Commands

    private void CommandList(IPlayer player, string command, string[] args)
    {
        if (!player.IsAdmin && !player.HasPermission(PermissionList))
        {
            player.Reply(GetMsg("No Permission", player.Id));
            return;
        }

        var builder = new StringBuilder();

        var separator = GetMsg("Command: List: Entry Separator", player.Id);
        var format = GetMsg("Command: List: Entry Format", player.Id);
        var noDescription = GetMsg("Command: List: No Description", player.Id);
        var noCache = GetMsg("Command: List: No Cache", player.Id);

        var found = 0;
        foreach (var kvp in _placeholdersByName.OrderBy(x => x.Key))
        {
            if (args.Length != 0)
            {
                var flag = false;
                foreach (var arg in args)
                {
                    if (kvp.Key.Contains(arg))
                    {
                        flag = true;
                        break;
                    }
                }

                if (!flag)
                    continue;
            }

            if (builder.Length != 0)
                builder.Append(separator);

            builder.Append(format).Replace("{name}", kvp.Key).Replace("{owner}", kvp.Value.Owner.Title)
                .Replace("{description}",
                    string.IsNullOrEmpty(kvp.Value.Description) ? noDescription : kvp.Value.Description)
                .Replace("{cache}",
                    kvp.Value.HasCache()
                        ? kvp.Value.HasCacheExpiration()
                            ? TimeSpan.FromTicks(kvp.Value.CacheTTLTicks).ToString()
                            : "MAX"
                        : noCache);

            found++;
        }

        if (builder.Length == 0)
        {
            player.Reply(GetMsg("Command: List: Not Found", player.Id));
            return;
        }

        var list = builder.ToString();

        // Clear it. No Clear method.
        builder.Length = 0;

        player.Reply(builder.Append(GetMsg("Command: List: Format", player.Id)).Replace("{list}", list)
            .Replace("{found}", found.ToString()).Replace("{total}", _placeholdersByName.Count.ToString())
            .ToString());
    }

    private class Options
    {
        public IPlayer Target;
        public bool IgnoreCache;
        public int Parsed;

        public Options(IPlayer caller, string[] args)
        {
            Target = caller;
            IgnoreCache = false;
            Parsed = 0;

            if (args.Length < 3)
                return;

            for (var i = args.Length - 1; i > 0 && i > args.Length - 5; i -= 2)
            {
                switch (args[i - 1]?.ToLower(CultureInfo.InvariantCulture))
                {
                    case "player":
                    case "p":
                    {
                        Parsed++;
                        Target = _ins.players.FindPlayer(args[i]) ?? caller;
                        break;
                    }

                    case "ignorecache":
                    case "ic":
                    {
                        Parsed++;
                        if (!bool.TryParse(args[i], out IgnoreCache))
                            IgnoreCache = false;

                        break;
                    }

                    default:
                        return;
                }
            }
        }
    }

    private void CommandTest(IPlayer player, string command, string[] args)
    {
        if (!player.IsAdmin && !player.HasPermission(PermissionTest))
        {
            player.Reply(GetMsg("No Permission", player.Id));
            return;
        }

        if (args.Length == 0)
        {
            player.Reply(GetMsg("Command: Test: Syntax", player.Id));
            return;
        }

        var options = new Options(player, args);
        var builder = new StringBuilder(string.Join(" ", args.Take(args.Length - options.Parsed * 2).ToArray()));

        Placeholder.Run(options.Target, builder, options.IgnoreCache);

        var result = builder.Length > 0 ? builder.ToString(0, Math.Min(builder.Length, 1024)) : "NONE";
        player.Reply(result.Trim('{', '}'));
    }

    #endregion

    #region Temporary Data

    public static class AddressHandler
    {
        public static Queue<KeyValuePair<IPlayer, string>> QueuedPlayers =
            new Queue<KeyValuePair<IPlayer, string>>();

        public static Dictionary<string, AddressResponse> Cache = new Dictionary<string, AddressResponse>();
        public static Dictionary<string, JObject> CachedJson = new Dictionary<string, JObject>();

        public const float FrequencyRequest = 60f / 45f * 1.1f;
        public const float FrequencyBulkRequest = 60f / 15f * 1.1f;

        private const string AddressDataRequest =
            "http://ip-api.com/json/{0}?fields=status,continent,continentCode,country,countryCode,region,regionName,city,district,zip,lat,lon,timezone,offset,currency,isp,org,as,asname,mobile,proxy,hosting";

        private const string AddressDataBulkRequest =
            "http://ip-api.com/batch?fields=status,continent,continentCode,country,countryCode,region,regionName,city,district,zip,lat,lon,timezone,offset,currency,isp,org,as,asname,mobile,proxy,hosting";

        /// <summary>
        /// Enqueue an address for API check
        /// </summary>
        /// <param name="player">Player</param>
        /// <param name="address">Address to check</param>
        /// <returns></returns>
        public static bool Enqueue(IPlayer player, string address)
        {
            if (Cache.ContainsKey(address))
                return false;
#if DEBUG
            Interface.Oxide.LogDebug($"Enqueuing player in {nameof(AddressHandler)} ({player?.Id ?? "<null>"})");
#endif

            QueuedPlayers.Enqueue(new KeyValuePair<IPlayer, string>(player, address));
            return true;
        }

        public static void Clear()
        {
            QueuedPlayers.Clear();
            Cache.Clear();
        }

        public static void RunTimers()
        {
            _ins.timer.Every(FrequencyRequest, ProcessQueue);
            _ins.timer.Every(FrequencyBulkRequest, ProcessQueueBulk);
        }

        private static void ProcessQueue()
        {
            if (QueuedPlayers.Count == 0)
                return;

            var kvp = QueuedPlayers.Dequeue();
            Request(kvp.Key, kvp.Value);
        }

        private static void Request(IPlayer player, string address)
        {
            _ins.webrequest.Enqueue(string.Format(AddressDataRequest, address), string.Empty,
                (code, response) =>
                {
                    if (code != 200)
                    {
                        Interface.Oxide.LogWarning(
                            $"There was an issue connecting to \"ip-api.com\"! Some address placeholders may not be available. Code: {code}");

                        return;
                    }

                    var addressData = JsonConvert.DeserializeObject<AddressResponse>(response);
                    if (!addressData.IsSuccess)
                        return;

                    Cache[address] = addressData;
                    Interface.Oxide.CallHook(HookNameAddressDataRetrieved, player, false);
#if DEBUG
                    Interface.Oxide.LogDebug("Received data for address (1)");
#endif
                }, _ins);
        }

        private static void ProcessQueueBulk()
        {
            if (QueuedPlayers.Count == 0)
                return;

            var players = new IPlayer[Math.Min(100, QueuedPlayers.Count)];
            var addresses = new string[players.Length];
            var body = new StringBuilder();

            body.Append('[');
            for (var i = 0; i < players.Length; i++)
            {
                if (i != 0)
                    body.Append(',');

                var kvp = QueuedPlayers.Dequeue();

                players[i] = kvp.Key;
                body.Append('"');
                body.Append(addresses[i] = kvp.Value);
                body.Append('"');
            }

            body.Append(']');

            RequestBulk(players, addresses, body.ToString());
        }

        private static void RequestBulk(IPlayer[] players, string[] addresses, string body)
        {
            _ins.webrequest.Enqueue(AddressDataBulkRequest, body, (code, response) =>
            {
                if (code != 200)
                    goto nosuccess;

                var deserializedResponses = JsonConvert.DeserializeObject<List<AddressResponse>>(response);
                if (deserializedResponses == null || deserializedResponses.Count < players.Length)
                    goto nosuccess;

                for (var i = 0; i < deserializedResponses.Count; i++)
                {
                    var addressData = deserializedResponses[i];
                    if (!addressData.IsSuccess)
                        continue;

                    Cache[addresses[i]] = addressData;
                    Interface.Oxide.CallHook(HookNameAddressDataRetrieved, players[i], false);
                }

#if DEBUG
                Interface.Oxide.LogDebug($"Received bulk data for addresses ({players.Length})");
#endif
                return;

                nosuccess:
                Interface.Oxide.LogWarning(
                    $"There was an issue connecting to \"ip-api.com\" for a bulk request! Many address placeholders may not be available. Code: {code}");
            }, _ins, RequestMethod.POST);
        }
    }

    public class AddressResponse
    {
        [JsonProperty(PropertyName = "status")]
        public string Status = null;

        [JsonIgnore]
        public bool IsSuccess => Status == "success";

        [JsonProperty(PropertyName = "continent")]
        public string Continent = null;

        [JsonProperty(PropertyName = "continentCode")]
        public string ContinentCode = null;

        [JsonProperty(PropertyName = "country")]
        public string Country = null;

        [JsonProperty(PropertyName = "countryCode")]
        public string CountryCode = null;

        [JsonProperty(PropertyName = "regionName")]
        public string Region = null;

        [JsonProperty(PropertyName = "region")]
        public string RegionCode = null;

        [JsonProperty(PropertyName = "city")]
        public string City = null;

        [JsonProperty(PropertyName = "district")]
        public string District = null;

        [JsonProperty(PropertyName = "zip")]
        public string ZipCode = null;

        [JsonProperty(PropertyName = "lat")]
        public float Latitude = 0f;

        [JsonProperty(PropertyName = "lon")]
        public float Longitude = 0f;

        [JsonProperty(PropertyName = "timezone")]
        public string Timezone = null;

        [JsonProperty(PropertyName = "offset")]
        public int TimezoneOffset = 0;

        [JsonProperty(PropertyName = "currency")]
        public string Currency = null;

        [JsonProperty(PropertyName = "isp")]
        public string ISP = null;

        [JsonProperty(PropertyName = "org")]
        public string Organization = null;

        [JsonProperty(PropertyName = "as", NullValueHandling = NullValueHandling.Ignore)]
        public string AS = null;

        [JsonProperty(PropertyName = "asname", NullValueHandling = NullValueHandling.Ignore)]
        public string ASName = null;

        [JsonProperty(PropertyName = "mobile")]
        public bool Mobile = false;

        [JsonProperty(PropertyName = "proxy")]
        public bool Proxy = false;

        [JsonProperty(PropertyName = "hosting")]
        public bool Hosting = false;
    }

    #endregion

    #region Placeholders

    public class Placeholder
    {
        public string Name;
        public string Description;

        public Plugin Owner;

        public Func<IPlayer, string, object> Action;

        public Dictionary<string, Dictionary<string, KeyValuePair<long, object>>> Cache;

        public long CacheTTLTicks = 0;
        public bool CachePerPlayer = true;

        public Placeholder(Plugin owner, string name, string description, Func<IPlayer, string, object> action,
            double cacheTTL, bool cachePerPlayer)
        {
            Owner = owner;
            Name = name;
            Description = description;
            Action = action;

            CachePerPlayer = cachePerPlayer;
            CacheTTLTicks = double.IsNaN(cacheTTL) || cacheTTL <= 0d
                ? long.MinValue
                : Math.Abs(double.MaxValue - cacheTTL) < 0.1 // why not just in case
                    ? long.MaxValue
                    : (long)Math.Round(cacheTTL * TimeSpan.TicksPerSecond);

            if (!HasCache())
                return;

            Cache = new Dictionary<string, Dictionary<string, KeyValuePair<long, object>>>();
        }

        public bool HasCache() => CacheTTLTicks != long.MinValue;
        public bool HasCacheExpiration() => CacheTTLTicks != long.MaxValue;

        public object Evaluate(long timestamp, IPlayer player, string option, bool ignoreCache)
        {
            Dictionary<string, KeyValuePair<long, object>> cachedData = null;
            if (ignoreCache || Cache == null)
                goto evaluate;

            // If we do not want to cache per player or there is no player, use global cache with empty ID
            var id = !CachePerPlayer || player == null ? string.Empty : player.Id;
            if (!Cache.TryGetValue(id, out cachedData))
            {
                cachedData = Cache[id] = new Dictionary<string, KeyValuePair<long, object>>();
                goto evaluate;
            }

            if (cachedData.TryGetValue(option, out var cached) && (!HasCacheExpiration() || cached.Key > timestamp))
            {
                return cached.Value;
            }

            evaluate:
            var result = Action.Invoke(player, option);
            if (cachedData != null)
                cachedData[option] =
                    new KeyValuePair<long, object>(HasCacheExpiration() ? timestamp + CacheTTLTicks : 0, result);

            return result;
        }

        /*
         * 1 - Name
         * 2 - Option
         * 3 - Format
         */

        // Unescaped: {([^!:{}"]+)(?:!([^:{}"]+)|:([^!{}"]+))*?}
        private static readonly Regex InputRegex =
            new Regex(@"{([^!:{}""]+)(?:!([^:{}""]+)|:([^!{}""]+))*?}", RegexOptions.Compiled);

        /// <summary>
        /// Get nested level of placeholders
        /// </summary>
        /// <param name="input">Text</param>
        /// <returns>Nested level</returns>
        private static int GetNestedLevel(string input)
        {
            var currentNested = 0;
            var nestedMax = 0;

            for (var i = 0; i < input.Length; i++)
            {
                var character = input[i];

                // ReSharper disable once ConvertIfStatementToSwitchStatement
                if (character == '{')
                {
                    if (++currentNested > nestedMax)
                        nestedMax = currentNested;
                }
                else if (character == '}')
                {
                    currentNested--;
                }
            }

            return nestedMax;
        }

        /// <summary>
        /// Run placeholders
        /// </summary>
        /// <param name="player">Player</param>
        /// <param name="builder">Builder containing text</param>
        /// <param name="ignoreCache">Whether to ignore cache</param>
        public static void Run(IPlayer player, StringBuilder builder, bool ignoreCache)
        {
#if DEBUG
            Interface.Oxide.LogDebug($"Executing replacement. Input length: {builder.Length}");

            var replaced = 0;
            var watch = Stopwatch.StartNew();
#endif
            var inputString = builder.ToString();
            var nestedLevel = GetNestedLevel(inputString);

            var timestamp = DateTime.UtcNow.Ticks;
            for (var i = 0; i < nestedLevel; i++)
            {
                if (i != 0)
                    inputString = builder.ToString();

                var offset = 0;
                foreach (Match match in InputRegex.Matches(inputString))
                {
                    // Using group numbers instead of named groups. Saves us around 0.9%
                    var nameGroup = match.Groups[1];

                    // builder.ToString because .Value uses string.Substring which is a bit slower. Saves us around 0.3%
                    if (!_ins._placeholdersByName.TryGetValue(
                            builder.ToString(nameGroup.Index + offset, nameGroup.Length), out var placeholder) ||
                        placeholder.Action == null)
                        continue;

                    var optionGroup = match.Groups[2];
                    var option = optionGroup.Success
                        ? builder.ToString(optionGroup.Index + offset, optionGroup.Length)
                        : string.Empty;

                    var formatGroup = match.Groups[3];
                    var formatted = Format(placeholder.Evaluate(timestamp, player, option, ignoreCache),
                        formatGroup.Success
                            ? builder.ToString(formatGroup.Index + offset, formatGroup.Length)
                            : null,
                        option);

                    builder.Remove(match.Index + offset, match.Length);
                    builder.Insert(match.Index + offset, formatted);

                    offset += formatted.Length - match.Length;

#if DEBUG
                    replaced++;
#endif
                }
            }
#if DEBUG
            watch.Stop();

            Interface.Oxide.LogDebug(
                $"Execution took: {watch.Elapsed.TotalMilliseconds:0.000}ms. Replaced entries: {replaced}. Nested level: {nestedLevel}. Output length: {builder.Length}. Per entry replaced: {watch.Elapsed.TotalMilliseconds / replaced:0.0000}ms");
#endif
        }

        private static string Format(object value, string format, string option)
        {
            if (value == null)
                return string.Empty;

            if (value is DateTime pDateTime && option?.ToLower(CultureInfo.CurrentCulture) == "local")
                value = pDateTime + _ins._config.LocalTimeOffset;

            if (string.IsNullOrEmpty(format))
                return value.ToString();

#if Conditionals
                if (value is string)
                {
                    var equalIndex = format.IndexOf('=', 0, format.Length);
                    if (equalIndex != -1)
                    {
                        value = (string)value == format.Substring(0, equalIndex);
                        format = format.Substring(equalIndex + 1);
                    }
                }
#endif

            if (value is string pString)
            {
                switch (format)
                {
                    case "lower":
                        return pString.ToLower();
                    case "upper":
                        return pString.ToUpper();
                }
            }

            if (value is bool pBool)
            {
                // string.Split has awful performance, this lets us have a better one
                var separatorIndex = format.IndexOf('|', 0, format.Length);
                if (separatorIndex != -1)
                {
                    if (pBool)
                        return format.Substring(0, separatorIndex);
                    return format.Substring(separatorIndex + 1);
                }

                Interface.Oxide.LogError($"Invalid format for 'bool': {format}");
            }

            return value is IFormattable formattable
                ? formattable.ToString(format, _ins._config.Culture)
                : string.Format('{' + format + '}', value);
        }
    }

    #endregion

    #region Hooks

    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            { "Command: List: Not Found", "There are no registered placeholders." },
            { "Command: List: Format", "Placeholders ({found}/{total}):\n{list}" },
            { "Command: List: Entry Format", "{name} ({owner}, {cache}) - {description}" },
            { "Command: List: Entry Separator", "\n" },
            { "Command: List: No Description", "No description" },
            { "Command: List: No Cache", "No cache" },
            { "Command: Test: Syntax", "Usage: (Text) [player Player] [ignoreCache Ignore Cache]" },
            { "Command: Test: Player Not Found", "Player specified was not found." },
            { "No Permission", "You do not have enough permissions." }
        }, this);
    }

    private void Init()
    {
        _ins = this;

        _serverAddress = server.Address.ToString();

        permission.RegisterPermission(PermissionList, this);
        permission.RegisterPermission(PermissionTest, this);

        AddCovalenceCommand(CommandNameList, nameof(CommandList));
        AddCovalenceCommand(CommandNameTest, nameof(CommandTest));

        Unsubscribe(nameof(OnPluginLoaded));
    }

    private void Loaded()
    {
        foreach (var kvp in _config.Placeholders)
        {
            AddPlaceholder(this, kvp.Key, (p, o) => kvp.Value);
        }

        if (_config.RequestAddressData)
            AddressHandler.RunTimers();
    }

    // Remove all placeholders registered for this plugin
    private void OnPluginUnloaded(Plugin plugin)
    {
        if (ReferenceEquals(this, plugin))
            return;
#if DEBUG
        Interface.Oxide.LogDebug($"{plugin.Title} unloaded, removing existing placeholders..");
#endif
        // I am so sorry.. I did not want to do this, honestly..
        foreach (var kvp in _placeholdersByName.ToArray())
        {
            if (kvp.Value.Owner == plugin)
                _placeholdersByName.Remove(kvp.Value.Name);
        }
    }

    private void OnPluginLoaded(Plugin plugin)
    {
        if (ReferenceEquals(this, plugin))
            return;
#if DEBUG
        Interface.Oxide.LogDebug($"{plugin.Title} loaded, calling hook!");
#endif
        NextTick(() => CallReady(plugin)); // Wait until reference is set
    }

    private void OnServerInitialized(bool isServer)
    {
#if SEVENDAYSTODIE
            _bloodMoonFrequency = GamePrefs.GetInt(EnumGamePrefs.BloodMoonFrequency);
#endif

        RegisterInbuiltPlaceholders();

#if DEBUG
        Interface.Oxide.LogDebug($"{nameof(OnServerInitialized)}, calling hook!");
#endif
        if (isServer)
            CallReady(null);
        else // Wait until references are set
            NextTick(() => CallReady(null));

        OnUserApprovedInternal(null, _serverAddress);

        foreach (var player in players.Connected)
        {
            OnUserApprovedInternal(player, player.Address);
        }

        Subscribe(nameof(OnPluginLoaded));
    }

    private void Unload()
    {
        AddressHandler.Clear();
        _ins = null;
    }

    private void OnUserApproved(string username, string id, string address) =>
        OnUserApprovedInternal(players.FindPlayerById(id), address);

    private void OnUserApprovedInternal(IPlayer player, string address)
    {
        // Skip if we request user data and it was NOT cached - hook will be called
        if (_config.RequestAddressData && AddressHandler.Enqueue(player, address))
            return;

        Interface.Oxide.CallHook(HookNameAddressDataRetrieved, player, true);
    }

    #endregion

    #region API

    [HookMethod(nameof(ProcessPlaceholders))]
    private void ProcessPlaceholders(IPlayer player, StringBuilder builder, bool ignoreCache = false)
    {
        if (builder == null || builder.Length == 0)
            return;

        Placeholder.Run(player, builder, ignoreCache);
    }

    // Leads to performance boosts (Tests: 30-70%)
    [HookMethod(nameof(GetProcessPlaceholders))]
    private object GetProcessPlaceholders(int version = 0)
    {
        switch (version)
        {
            case 0:
            {
                return (Action<IPlayer, StringBuilder>)((player, builder) => ProcessPlaceholders(player, builder));
            }

            case 1:
            {
                return (Action<IPlayer, StringBuilder, bool>)ProcessPlaceholders;
            }

            default:
            {
                return null;
            }
        }
    }

    [HookMethod(nameof(EvaluatePlaceholder))]
    private object EvaluatePlaceholder(IPlayer player, string name, string option, bool ignoreCache = false)
    {
        return _placeholdersByName.TryGetValue(name, out var placeholder)
            ? placeholder.Evaluate(DateTime.UtcNow.Ticks, player, option, ignoreCache)
            : null;
    }

    [HookMethod(nameof(GetEvaluatePlaceholder))]
    private object GetEvaluatePlaceholder(int version = 0)
    {
        switch (version)
        {
            case 0:
            {
                return (Func<IPlayer, string, string, object>)((player, name, option) =>
                    EvaluatePlaceholder(player, name, option));
            }

            case 1:
            {
                return (Func<IPlayer, string, string, bool, object>)EvaluatePlaceholder;
            }

            default:
            {
                return null;
            }
        }
    }

    [HookMethod(nameof(ExistsPlaceholder))]
    private bool ExistsPlaceholder(string name) => _placeholdersByName.ContainsKey(name);

    [HookMethod(nameof(GetAddressData))]
    private JObject GetAddressData(string address)
    {
        if (!_config.RequestAddressData || string.IsNullOrEmpty(address))
            return null;

        if (AddressHandler.CachedJson.TryGetValue(address, out var json))
            return json;

        return AddressHandler.Cache.TryGetValue(address, out var cached)
            ? AddressHandler.CachedJson[address] = JObject.FromObject(cached)
            : null;
    }

    private static readonly Regex PlaceholderValidNameRegex =
        new Regex(@"^(?:[a-z]|\.)+$", RegexOptions.Compiled | RegexOptions.Singleline);

    [HookMethod(nameof(AddPlaceholder))]
    private bool AddPlaceholder(Plugin plugin, string name, Func<IPlayer, string, object> action,
        string description = null, double cacheTTL = double.NaN, bool cachePerPlayer = true)
    {
#if DEBUG
        if (!ReferenceEquals(this, plugin))
            Interface.Oxide.LogDebug($"Adding placeholder ({name}) for {plugin?.Title ?? "null plugin"}..");
#endif
        if (plugin == null)
            return false;

        if (!PlaceholderValidNameRegex.IsMatch(name))
        {
            Interface.Oxide.LogWarning(
                $"Plugin ({plugin.Title} by {plugin.Author}) tried to register a placeholder with an invalid name ({name})!");

            return false;
        }

        if (ExistsPlaceholder(name))
        {
            Interface.Oxide.LogWarning(
                $"Plugin ({plugin.Title} by {plugin.Author}) tried to register an already existing placeholder ({name})!");

            return false;
        }

        _placeholdersByName.Add(name, new Placeholder(plugin, name, description, action, cacheTTL, cachePerPlayer));
        return true;
    }

    [HookMethod(nameof(RemovePlaceholder))]
    private void RemovePlaceholder(string name) => _placeholdersByName.Remove(name);

    #endregion

    #region Helpers

    private void CallReady(Plugin plugin)
    {
        if (plugin == null)
            Interface.CallHook(HookNameReady, _config.RequestAddressData);
        else
            plugin.CallHook(HookNameReady, _config.RequestAddressData);
    }

    private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

#if RUST
    private SaveInfo _saveInfo;

    public DateTime GetLastBlueprintsWipeUniversal(bool time) => !time || _config.BlueprintsWipe.Time == null
        ? _saveInfo.CreationTime.ToUniversalTime()
        : _saveInfo.CreationTime.ToUniversalTime().Date + _config.BlueprintsWipe.Time.Value;

    public DateTime GetLastMapWipeUniversal(bool time) => !time || _config.MapWipe.Time == null
        ? SaveRestore.SaveCreatedTime
        : SaveRestore.SaveCreatedTime.Date + _config.MapWipe.Time.Value;
#endif
    private void RegisterInbuiltPlaceholders()
    {
#if RUST
        _saveInfo ??= SaveInfo.Create(World.SaveFolderName +
                                      $"/player.blueprints.{Rust.Protocol.persistance}.db");

        AddPlaceholder(this, "world.seed", (p, o) => World.Seed);
        AddPlaceholder(this, "world.salt", (p, o) => World.Salt);
        AddPlaceholder(this, "world.url", (p, o) => World.Url);
        AddPlaceholder(this, "world.name", (p, o) => World.Name);
        AddPlaceholder(this, "world.size", (p, o) =>
        {
            switch (o?.ToLower(CultureInfo.CurrentCulture))
            {
                case "km":
                {
                    return World.Size / 1000;
                }

                case "km2":
                case "km^2":
                {
                    return World.Size * World.Size / (1000 * 1000);
                }

                case "m":
                {
                    return World.Size;
                }

                case "m2":
                case "m^2":
                {
                    return World.Size * World.Size;
                }

                default:
                {
                    return World.Size;
                }
            }
        }, "Options: km, km2 (or km^2), m (default), m2 (or m^2)");

        AddPlaceholder(this, "server.description", (p, o) => ConVar.Server.description);

        AddPlaceholder(this, "server.protocol.network", (p, o) => Rust.Protocol.network);
        AddPlaceholder(this, "server.protocol.persistance", (p, o) => Rust.Protocol.persistance);
        AddPlaceholder(this, "server.protocol.report", (p, o) => Rust.Protocol.report);
        AddPlaceholder(this, "server.protocol.save", (p, o) => Rust.Protocol.save);

        AddPlaceholder(this, "server.players.stored",
            (p, o) => BasePlayer.activePlayerList.Count + BasePlayer.sleepingPlayerList.Count);
        AddPlaceholder(this, "server.players.sleepers", (p, o) => BasePlayer.sleepingPlayerList.Count);
        AddPlaceholder(this, "server.players.loading", (p, o) => ServerMgr.Instance.connectionQueue.joining.Count);
        AddPlaceholder(this, "server.players.queued", (p, o) => ServerMgr.Instance.connectionQueue.queue.Count);
        AddPlaceholder(this, "server.entities", (p, o) => BaseNetworkable.serverEntities.Count);
        AddPlaceholder(this, "server.fps", (p, o) => Performance.report.frameRate);
        AddPlaceholder(this, "server.fps.average", (p, o) => Performance.report.frameRateAverage);
        AddPlaceholder(this, "server.oxide.rust.version", (p, o) => _rustCore?.Version,
            "Oxide.Rust version installed");

        AddPlaceholder(this, "server.map.wipe.last", (p, o) => GetLastMapWipeUniversal(true),
            "Options: \"local\" to use local time offset, UTC (default)", 60 * 60, false);

        AddPlaceholder(this, "server.map.wipe.next",
            (p, o) => _config.MapWipe.GetNextWipeDate(GetLastMapWipeUniversal(false)),
            "Options: \"local\" to use local time offset, UTC (default)", 60 * 60, false);

        AddPlaceholder(this, "server.map.wipe.last.istoday",
            (p, o) => GetLastMapWipeUniversal(false).Date == DateTime.UtcNow.Date,
            cacheTTL: 60 * 15, cachePerPlayer: false);

        AddPlaceholder(this, "server.map.wipe.next.istoday",
            (p, o) => _config.MapWipe.GetNextWipeDate(GetLastMapWipeUniversal(false)).Date == DateTime.UtcNow.Date,
            cacheTTL: 60 * 15, cachePerPlayer: false);

        AddPlaceholder(this, "server.blueprints.wipe.last", (p, o) => GetLastBlueprintsWipeUniversal(true),
            "Options: \"local\" to use local time offset, UTC (default)", 60 * 60, false);

        AddPlaceholder(this, "server.blueprints.wipe.next",
            (p, o) => _config.BlueprintsWipe.GetNextWipeDate(GetLastBlueprintsWipeUniversal(false)),
            "Options: \"local\" to use local time offset, UTC (default)", 60 * 60, false);

        AddPlaceholder(this, "server.blueprints.wipe.last.istoday",
            (p, o) => GetLastBlueprintsWipeUniversal(false).Date == DateTime.UtcNow.Date,
            cacheTTL: 60 * 15, cachePerPlayer: false);

        AddPlaceholder(this, "server.blueprints.wipe.next.istoday",
            (p, o) => _config.MapWipe.GetNextWipeDate(GetLastMapWipeUniversal(false)).Date == DateTime.UtcNow.Date,
            cacheTTL: 60 * 15, cachePerPlayer: false);

        AddPlaceholder(this, "server.memory.used", (p, o) =>
        {
            // Already MB
            var used = Performance.current.memoryUsageSystem * 1f;
            switch (o?.ToLower(CultureInfo.CurrentCulture))
            {
                case "kb":
                {
                    return used * 1024;
                }

                case "mb":
                {
                    return used;
                }

                case "gb":
                {
                    return used / 1024;
                }

                default:
                {
                    return used * (1024 * 1024);
                }
            }
        }, "Options: B (default), KB, MB, GB", 1d, false);

        AddPlaceholder(this, "server.memory.total", (p, o) =>
        {
            // Already MB
            var used = UnityEngine.SystemInfo.systemMemorySize * 1f;
            switch (o?.ToLower(CultureInfo.CurrentCulture))
            {
                case "kb":
                {
                    return used * 1024;
                }

                case "mb":
                {
                    return used;
                }

                case "gb":
                {
                    return used / 1024;
                }

                default:
                {
                    return used * (1024 * 1024);
                }
            }
        }, "Options: B (default), KB, MB, GB", double.MaxValue, false);

        AddPlaceholder(this, "server.network.in", (p, o) =>
            {
                var used = Network.Net.sv.GetStat(null, Network.BaseNetwork.StatTypeLong.BytesReceived_LastSecond) *
                           1f;
                switch (o?.ToLower(CultureInfo.CurrentCulture))
                {
                    case "kb":
                    case "kb/s":
                    {
                        return used / 1024;
                    }

                    case "mb":
                    case "mb/s":
                    {
                        return used / (1024 * 1024);
                    }

                    case "gb":
                    case "gb/s":
                    {
                        return used / (1024 * 1024 * 1024);
                    }

                    case "kbps":
                    {
                        return used / 1024 * 8;
                    }

                    case "mbps":
                    {
                        return used / (1024 * 1024) * 8;
                    }

                    case "gbps":
                    {
                        return used / (1024 * 1024 * 1024) * 8;
                    }

                    case "bps":
                    {
                        return used * 8;
                    }

                    default:
                    {
                        return used;
                    }
                }
            }, "Options: B (or B/s, default) KB (or KB/s), MB (or MB/s), GB (or GB/s), Bps, Kbps, Mbps, Gbps", 1d,
            false);

        AddPlaceholder(this, "server.network.out", (p, o) =>
            {
                var used = Network.Net.sv.GetStat(null, Network.BaseNetwork.StatTypeLong.BytesSent_LastSecond) * 1f;
                switch (o?.ToLower(CultureInfo.CurrentCulture))
                {
                    case "kb":
                    case "kb/s":
                    {
                        return used / 1024;
                    }

                    case "mb":
                    case "mb/s":
                    {
                        return used / (1024 * 1024);
                    }

                    case "gb":
                    case "gb/s":
                    {
                        return used / (1024 * 1024 * 1024);
                    }

                    case "kbps":
                    {
                        return used / 1024 * 8;
                    }

                    case "mbps":
                    {
                        return used / (1024 * 1024) * 8;
                    }

                    case "gbps":
                    {
                        return used / (1024 * 1024 * 1024) * 8;
                    }

                    case "bps":
                    {
                        return used * 8;
                    }

                    default:
                    {
                        return used;
                    }
                }
            }, "Options: B (or B/s, default) KB (or KB/s), MB (or MB/s), GB (or GB/s), Bps, Kbps, Mbps, Gbps", 1d,
            false);

        AddPlaceholder(this, "player.hasflag", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            if (!Enum.TryParse(o, true, out BaseEntity.Flags flag))
                return null;

            return basePlayer.HasFlag(flag);
        }, "Options: Flag name (See description on uMod for full list)");

        AddPlaceholder(this, "player.hasplayerflag", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            if (!Enum.TryParse(o, true, out BasePlayer.PlayerFlags flag))
                return null;

            return basePlayer.HasPlayerFlag(flag);
        }, "Options: Player flag name (See description on uMod for full list)");

        AddPlaceholder(this, "player.blueprints.hasunlocked", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            var item = ItemManager.FindItemDefinition(o);
            if (item == null)
                return null;

            return basePlayer.blueprints.HasUnlocked(item);
        }, "Options: Item shortname", 10d);

        AddPlaceholder(this, "player.stats", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            return basePlayer.stats.steam.intStats.GetValueOrDefault(o, 0);
        }, "Options: Statistics key name");

        AddPlaceholder(this, "player.team.any", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            return basePlayer.currentTeam == 0;
        });

        AddPlaceholder(this, "player.team.leader", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            if (basePlayer.currentTeam == 0)
                return null;

            return basePlayer.Team.teamLeader;
        });

        AddPlaceholder(this, "player.team.invites", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            if (basePlayer.currentTeam == 0)
                return null;

            return basePlayer.Team.invites.Count;
        });

        AddPlaceholder(this, "player.team.members", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            if (basePlayer.currentTeam == 0)
                return null;

            return basePlayer.Team.members.Count;
        });

        AddPlaceholder(this, "player.metabolism", (p, o) =>
            {
                if (string.IsNullOrEmpty(o))
                    return null;

                var basePlayer = p?.Object as BasePlayer;
                if (basePlayer == null)
                    return null;

                var options = o.ToLower(CultureInfo.CurrentCulture).Split(';');
                if (options.Length > 2)
                    return null;

                MetabolismAttribute attribute;
                switch (options[0])
                {
                    case "bleeding":
                    case "blood":
                    {
                        attribute = basePlayer.metabolism.bleeding;
                        break;
                    }

                    case "comfort":
                    {
                        attribute = basePlayer.metabolism.comfort;
                        break;
                    }

                    case "dirtyness":
                    case "dirty":
                    {
                        attribute = basePlayer.metabolism.dirtyness;
                        break;
                    }

                    case "oxygen":
                    {
                        attribute = basePlayer.metabolism.oxygen;
                        break;
                    }

                    case "pending_health":
                    case "pending.health":
                    case "pendinghealth":
                    {
                        attribute = basePlayer.metabolism.pending_health;
                        break;
                    }

                    case "poison":
                    {
                        attribute = basePlayer.metabolism.poison;
                        break;
                    }

                    case "radiation_level":
                    case "radiation.level":
                    case "radiationlevel":
                    {
                        attribute = basePlayer.metabolism.radiation_level;
                        break;
                    }

                    case "radiation_poison":
                    case "radiation.poison":
                    case "radiationpoison":
                    {
                        attribute = basePlayer.metabolism.radiation_poison;
                        break;
                    }

                    case "temperature":
                    {
                        attribute = basePlayer.metabolism.temperature;
                        break;
                    }

                    case "wet":
                    case "wetness":
                    {
                        attribute = basePlayer.metabolism.wetness;
                        break;
                    }

                    case "calories":
                    case "hunger":
                    case "food":
                    {
                        attribute = basePlayer.metabolism.calories;
                        break;
                    }

                    case "heart":
                    case "heartrate":
                    {
                        attribute = basePlayer.metabolism.heartrate;
                        break;
                    }

                    case "hydration":
                    case "water":
                    {
                        attribute = basePlayer.metabolism.hydration;
                        break;
                    }

                    default:
                    {
                        return null;
                    }
                }

                switch (options.Length == 2 ? options[1] : null)
                {
                    case "max":
                    {
                        return attribute.max;
                    }

                    case "min":
                    {
                        return attribute.min;
                    }

                    case "startmax":
                    {
                        return attribute.startMax;
                    }

                    case "startmin":
                    {
                        return attribute.startMin;
                    }

                    default:
                    {
                        return attribute.value;
                    }
                }
            },
            "Options: Metabolism parameter (See description on uMod for full list) and parameter separated with \";\": max, min, startMax, startMin, value (default)",
            3d);

        AddPlaceholder(this, "player.craftlevel", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            return basePlayer.currentCraftLevel;
        });

        AddPlaceholder(this, "player.safezone", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            return basePlayer.InSafeZone();
        });

        AddPlaceholder(this, "player.comfort", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            return basePlayer.currentComfort;
        });

        AddPlaceholder(this, "player.ishostile", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            return basePlayer.IsHostile();
        });

        AddPlaceholder(this, "player.hostile.timeleft", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            return TimeSpan.FromSeconds(basePlayer.unHostileTime - Network.TimeEx.currentTimestamp);
        });

        AddPlaceholder(this, "player.input.isdown", (p, o) =>
        {
            if (string.IsNullOrEmpty(o))
                return null;

            var basePlayer = p?.Object as BasePlayer;
            if (basePlayer == null)
                return null;

            if (!Enum.TryParse(o, true, out BUTTON button))
                return null;

            return basePlayer.serverInput.IsDown(button);
        });
#elif SEVENDAYSTODIE
            AddPlaceholder(this, "server.fps", (p, o) =>  GameManager.Instance.fps.Counter);
            AddPlaceholder(this, "server.entities", (p, o) => GameManager.Instance.World.Entities.list.Count);
            AddPlaceholder(this, "server.day", (p, o) => SkyManager.dayCount);
            AddPlaceholder(this, "server.isbloodmoon", (p, o) => SkyManager.IsBloodMoonVisible());
            AddPlaceholder(this, "server.day.bloodmoonin", (p, o) => _bloodMoonFrequency - (SkyManager.dayCount % _bloodMoonFrequency));
#elif HURTWORLD
            AddPlaceholder(this, "server.wipe.last", (p, o) => DateTimeX.FromUTCInt(GameSerializer.Instance.CurrentSaveCreationTimestamp),
                "Options: \"local\" to use local time offset, UTC (default)");

            AddPlaceholder(this, "server.wipe.next",
                (p, o) => DateTimeX.FromUTCInt(GameSerializer.Instance.CurrentSaveCreationTimestamp).AddSeconds(GameManager.Instance.ServerConfig.WipeInterval),
                "Options: \"local\" to use local time offset, UTC (default)");
#endif

        AddPlaceholder(this, "server.address", (p, o) => GetServerAddress(), cacheTTL: 60 * 60,
            cachePerPlayer: false);
        AddPlaceholder(this, "server.protocol", (p, o) => server.Protocol);
        AddPlaceholder(this, "server.language.code", (p, o) => server.Language.TwoLetterISOLanguageName,
            "Two letter ISO language name");
        AddPlaceholder(this, "server.language.name", (p, o) => server.Language.Name);
        AddPlaceholder(this, "server.name", (p, o) => server.Name);
        AddPlaceholder(this, "server.players", (p, o) => server.Players);
        AddPlaceholder(this, "server.players.max", (p, o) => server.MaxPlayers);
        AddPlaceholder(this, "server.players.total",
            (p, o) => players.All.Count()); // should call ICollection.Count (not a method)
        AddPlaceholder(this, "server.port", (p, o) => server.Port);
        AddPlaceholder(this, "server.time", (p, o) => server.Time, "Current in-game time");

        AddPlaceholder(this, "player.address", (p, o) => p?.Address);

        if (_config.RequestAddressData)
        {
            AddPlaceholder(this, "player.address.data", (p, o) =>
                {
                    if (string.IsNullOrEmpty(p?.Address))
                    {
#if DEBUG
                        Interface.Oxide.LogDebug("There was no player or address supplied");
#endif
                        return null;
                    }

                    // ReSharper disable once PossibleNullReferenceException
                    if (!AddressHandler.Cache.TryGetValue(p.Address, out var data) &&
                        !AddressHandler.Cache.TryGetValue(_serverAddress, out data))
                    {
#if DEBUG
                        Interface.Oxide.LogDebug("Address data was not found");
#endif
                        return null;
                    }

                    switch (o?.ToLower(CultureInfo.CurrentCulture))
                    {
                        case "continent":
                        {
                            return data.Continent;
                        }

                        case "continent.code":
                        {
                            return data.ContinentCode;
                        }

                        case "country":
                        {
                            return data.Country;
                        }

                        case "country.code":
                        {
                            return data.CountryCode;
                        }

                        case "region":
                        {
                            return data.Region;
                        }

                        case "region.code":
                        {
                            return data.RegionCode;
                        }

                        case "city":
                        {
                            return data.City;
                        }

                        case "district":
                        {
                            return data.District;
                        }

                        case "zip":
                        case "zip.code":
                        {
                            return data.ZipCode;
                        }

                        case "lat":
                        case "latitude":
                        {
                            return data.Latitude;
                        }

                        case "lon":
                        case "longitude":
                        {
                            return data.Longitude;
                        }

                        case "timezone":
                        {
                            return data.Timezone;
                        }

                        case "timezone.offset":
                        {
                            return TimeSpan.FromSeconds(data.TimezoneOffset);
                        }

                        case "currency":
                        {
                            return data.Currency;
                        }

                        case "isp":
                        {
                            return data.ISP;
                        }

                        case "org":
                        case "organization":
                        {
                            return data.Organization;
                        }

                        case "as":
                        {
                            return data.AS;
                        }

                        case "as.name":
                        {
                            return data.ASName;
                        }

                        case "mobile":
                        {
                            return data.Mobile;
                        }

                        case "proxy":
                        {
                            return data.Proxy;
                        }

                        case "hosting":
                        {
                            return data.Hosting;
                        }

                        default:
                        {
                            return p.Address;
                        }
                    }
                },
                "Options: continent, continent.code, country, country.code, region, region.code, city, district, zip.code, latitude, longtitude, timezone, timezone.offset, currency, isp, org, as, as.name, mobile, proxy, and hosting",
                5);
        }

        AddPlaceholder(this, "player.health", (p, o) => p?.Health);
        AddPlaceholder(this, "player.id", (p, o) => p?.Id);
        AddPlaceholder(this, "player.language.code", (p, o) => p?.Language?.TwoLetterISOLanguageName,
            "Two letter ISO language name");
        AddPlaceholder(this, "player.language.name", (p, o) => p?.Language?.Name);
        AddPlaceholder(this, "player.name", (p, o) => p?.Name);
        AddPlaceholder(this, "player.ping", (p, o) => p?.Ping);
        AddPlaceholder(this, "player.isadmin", (p, o) => p?.IsAdmin);
        AddPlaceholder(this, "player.isbanned", (p, o) => p?.IsBanned);
        AddPlaceholder(this, "player.isconnected", (p, o) => p?.IsConnected);
        AddPlaceholder(this, "player.lastcommand", (p, o) => p?.LastCommand);
        AddPlaceholder(this, "player.health.max", (p, o) => p?.MaxHealth);

        AddPlaceholder(this, "player.position", (p, o) =>
        {
            if (p == null)
                return null;

            switch (o?.ToLower(CultureInfo.CurrentCulture))
            {
                case "x":
                {
                    return p.Position().X;
                }

                case "y":
                {
                    return p.Position().Y;
                }

                case "z":
                {
                    return p.Position().Z;
                }

                default:
                {
                    return p.Position();
                }
            }
        }, "Options: X, Y, Z, Full (default)", 3d);

        AddPlaceholder(this, "player.haspermission", (p, o) =>
        {
            if (p == null || string.IsNullOrEmpty(o))
                return null;

            return !string.IsNullOrEmpty(o) && p.HasPermission(o);
        }, "Options: Permission name");

        AddPlaceholder(this, "player.hasgroup", (p, o) =>
        {
            if (p == null || string.IsNullOrEmpty(o))
                return null;

            return !string.IsNullOrEmpty(o) && p.BelongsToGroup(o);
        }, "Options: Group name");

        AddPlaceholder(this, "plugins.amount", (p, o) => plugins.GetAll().Length);
        AddPlaceholder(this, "plugins.loaded",
            (p, o) => !string.IsNullOrEmpty(o) && (plugins.Find(o)?.IsLoaded ?? false), "Options: Plugin name");

        AddPlaceholder(this, "date.now", (p, o) => DateTime.UtcNow,
            "Options: \"local\" to use local time offset, UTC (default)");
    }

    private IPAddress GetServerAddress()
    {
#if RUST
        return Steamworks.SteamServer.PublicIp;
#else
        return Equals(server.Address, IPAddress.Any) ? server.LocalAddress : server.Address;
#endif
    }

    #endregion
}

// --- End of file: PlaceholderAPI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/parented-entity-render-fix ---
// --- Original File Path: P/ParentedEntityRenderFix/ParentedEntityRenderFix.cs ---

﻿using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Parented Entity Render Fix", "WhiteThunder", "0.1.2")]
    [Description("Fixes bug where some parented entities do not render except near map origin.")]
    /**
     * ## Background
     *
     * For some entities, especially IO entities, the Rust client will cache the initial network
     * position (entity.transform.localPosition) as the rendering origin. When the player gets a
     * sufficient distance away from that rendering origin, the entity will not be rendered,
     * presumably as a performance optimization. However, there is a bug where the client does
     * not take into account that the entity was parented, even though that information was sent
     * in the same snapshot. Since most plugins set localPosition to a relatively small vector,
     * this causes these entities to not render unless the player is near the map origin.
     *
     * ## Previously attempted workarounds
     *
     * Some developers have attempted to work around this issue by spawning the entity unparented
     * at the desired world position. This works because the networked position (localPosition) is
     * equal to the world position, so the Rust client correctly caches that as the rendering
     * origin. However, you then have to solve the problem of manually destroying the entity when
     * its intended parent is destroyed, not to mention move the entity when its parent moves.
     *
     * Some have tried to avoid manual position updates by simply parenting the entity after it is
     * spawned with the correct world position. This appears to work at first because only the
     * initial snapshot needs to send the world position. Subsequent updates can indicate parentage
     * and localPosition without issue. However, this only works for clients that were networked
     * the original position. Clients not subscribed to the entity's network group at the time it
     * spawned, or clients who disconnect or leave that entity's network group (which causes the
     * entity to be destroyed client-side), will reproduce the problem the next time they create
     * the entity since it will be parented in the initial snapshot they receive.
     *
     * Neither of those workarounds solve the problem of an entity moving signifcantly away from
     * its rendering origin. To solve that, the entity must be periodically destroyed and recreated
     * client-side (does not have to happen server-side).
     *
     * ## How this plugin works
     *
     * This plugin solves the problem by sending an additional network update ahead of the update
     * that would cause the client to create the entity. This extra update essentially lies about
     * the entity's parentage and network position, causing the client to cache the correct
     * rendering origin. This plugin is able to deduce that a client is creating or destroying an
     * entity by using multiple hooks and keeping state.
     *
     * For entities that move a significant distance from their spawn location, players that move
     * with the entity will not be able to see it, but disconnecting or leaving the network group
     * and returning will recreate the entity client-side which will resolve the issue.
     */
    internal class ParentedEntityRenderFix : CovalencePlugin
    {
        #region Fields

        private Configuration _pluginConfig;

        #endregion

        #region Hooks

        private void Unload()
        {
            EntitySubscriptionManager.Instance.Clear();
            NetworkCacheManager.Instance.Clear();
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (player.IsNpc || !player.userID.IsSteamId())
                return;

            EntitySubscriptionManager.Instance.RemoveSubscriber(player.userID);
        }

        private void OnEntityKill(BaseEntity entity)
        {
            if (entity == null || entity.net == null)
                return;

            EntitySubscriptionManager.Instance.RemoveEntity(entity.net.ID);
            NetworkCacheManager.Instance.InvalidateForEntity(entity.net.ID);
        }

        private void OnEntitySnapshot(BaseEntity entity, Connection connection)
        {
            if (entity == null || entity.net == null)
                return;

            if (!entity.HasParent())
                return;

            if (!_pluginConfig.EnabledEntities.Contains(entity.ShortPrefabName))
                return;

            // Detect when the vanilla network cache has been cleared in order to invalidate the custom cache.
            if (entity._NetworkCache == null)
                NetworkCacheManager.Instance.InvalidateForEntity(entity.net.ID);

            // Ignore if the subscription was already being tracked, which indicates the client already has the entity.
            if (EntitySubscriptionManager.Instance.AddEntitySubscription(entity.net.ID, connection.ownerid))
            {
                // Send an extra update ahead of the original, to represent the entity as unparented.
                NetworkCacheManager.Instance.SendModifiedSnapshot(entity, connection);
            }
        }

        // Clients destroy entities from a network group when the client leaves it.
        private void OnNetworkGroupLeft(BasePlayer player, Network.Visibility.Group group)
        {
            if (player.IsNpc || !player.userID.IsSteamId())
                return;

            for (var i = 0; i < group.networkables.Count; i++)
            {
                var networkable = group.networkables.Values.Buffer[i];
                if (networkable == null)
                    continue;

                var entity = networkable.handler as BaseNetworkable;
                if (entity == null || entity.net == null)
                    continue;

                EntitySubscriptionManager.Instance.RemoveEntitySubscription(entity.net.ID, player.userID);
            }
        }

        #endregion

        #region Network Cache Manager

        private abstract class BaseNetworkCacheManager
        {
            private readonly Dictionary<NetworkableId, MemoryStream> _networkCache = new Dictionary<NetworkableId, MemoryStream>();

            public void Clear()
            {
                _networkCache.Clear();
            }

            public void InvalidateForEntity(NetworkableId entityId)
            {
                _networkCache.Remove(entityId);
            }

            // Mostly copied from:
            // - `BaseNetworkable.SendAsSnapshot(Connection)`
            // - `BasePlayer.SendEntitySnapshot(BaseNetworkable)`
            public void SendModifiedSnapshot(BaseEntity entity, Connection connection)
            {
                var write = Net.sv.StartWrite();
                connection.validate.entityUpdates++;
                var saveInfo = new BaseNetworkable.SaveInfo()
                {
                    forConnection = connection,
                    forDisk = false
                };
                write.PacketID(Message.Type.Entities);
                write.UInt32(connection.validate.entityUpdates);
                ToStreamForNetwork(entity, write, saveInfo);
                write.Send(new SendInfo(connection));
            }

            // Mostly copied from `BaseNetworkable.ToStream(Stream, SaveInfo)`.
            private void ToStream(BaseEntity entity, Stream stream, BaseNetworkable.SaveInfo saveInfo)
            {
                using (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())
                {
                    entity.Save(saveInfo);
                    Interface.CallHook("OnEntitySaved", entity, saveInfo);
                    HandleOnEntitySaved(entity, saveInfo);
                    saveInfo.msg.ToProto(stream);
                    entity.PostSave(saveInfo);
                }
            }

            // Mostly copied from `BaseNetworkable.ToStreamForNetwork(Stream, SaveInfo)`.
            private Stream ToStreamForNetwork(BaseEntity entity, Stream stream, BaseNetworkable.SaveInfo saveInfo)
            {
                MemoryStream cachedStream;
                if (!_networkCache.TryGetValue(entity.net.ID, out cachedStream))
                {
                    cachedStream = BaseNetworkable.EntityMemoryStreamPool.Count > 0
                        ? BaseNetworkable.EntityMemoryStreamPool.Dequeue()
                        : new MemoryStream(8);

                    ToStream(entity, cachedStream, saveInfo);
                    _networkCache[entity.net.ID] = cachedStream;
                }

                cachedStream.WriteTo(stream);
                return cachedStream;
            }

            // Handler for modifying save info when building a snapshot.
            protected abstract void HandleOnEntitySaved(BaseEntity entity, BaseNetworkable.SaveInfo saveInfo);
        }

        private class NetworkCacheManager : BaseNetworkCacheManager
        {
            private static NetworkCacheManager _instance = new NetworkCacheManager();
            public static NetworkCacheManager Instance => _instance;

            protected override void HandleOnEntitySaved(BaseEntity entity, BaseNetworkable.SaveInfo saveInfo)
            {
                var parent = entity.GetParentEntity();
                saveInfo.msg.baseEntity.pos = entity.transform.position;
                saveInfo.msg.baseEntity.rot = entity.transform.rotation.eulerAngles;
                saveInfo.msg.parent = null;
            }
        }

        #endregion

        #region Entity Subscription Manager

        private class EntitySubscriptionManager
        {
            private static EntitySubscriptionManager _instance = new EntitySubscriptionManager();
            public static EntitySubscriptionManager Instance => _instance;

            private readonly Dictionary<NetworkableId, HashSet<ulong>> _entitySubscibers = new Dictionary<NetworkableId, HashSet<ulong>>();

            public void Clear()
            {
                _entitySubscibers.Clear();
            }

            public bool AddEntitySubscription(NetworkableId entityId, ulong userId)
            {
                HashSet<ulong> subscribers;
                if (_entitySubscibers.TryGetValue(entityId, out subscribers))
                    return subscribers.Add(userId);

                _entitySubscibers[entityId] = new HashSet<ulong>() { userId };
                return true;
            }

            public void RemoveEntitySubscription(NetworkableId entityId, ulong userId)
            {
                HashSet<ulong> subscribers;
                if (_entitySubscibers.TryGetValue(entityId, out subscribers))
                    subscribers.Remove(userId);
            }

            public void RemoveSubscriber(ulong userId)
            {
                foreach (var entry in _entitySubscibers)
                    entry.Value.Remove(userId);
            }

            public void RemoveEntity(NetworkableId entityId)
            {
                _entitySubscibers.Remove(entityId);
            }
        }

        #endregion

        #region Configuration

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("EnabledEntities")]
            public HashSet<string> EnabledEntities = new HashSet<string>();
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Boilerplate

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion

    }
}


// --- End of file: ParentedEntityRenderFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pickup-lines ---
// --- Original File Path: P/PickupLines/PickupLines.cs ---

using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("PickupLines", "Spicy", "1.0.2")]
    [Description("Send lovely pickup lines to yourself or other players.")]

    class PickupLines : CovalencePlugin
    {
        void Init()
        {
            SetupLanguage();
            permission.RegisterPermission("pickuplines.use", this);
        }

        void SetupLanguage()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You do not have permission to use this command.",
                ["InvalidSyntax"] = "Invalid syntax. Syntax: /pickupline [me|playername].",
                ["NoPlayersFound"] = "No players were found with that name.",
                ["MultiplePlayersFound"] = "Multiple players were found with that name.",
                ["WebRequestFailed"] = "WebRequest to {0} failed!",
                ["YouPickupLinedYourself"] = "You sent yourself a pickup line:\n{0}",
                ["YouPickupLinedPlayer"] = "You sent {0} a pickup line:\n{1}",
                ["PlayerPickupLinedYou"] = "{0} sent you a pickup line:\n{1}"
            }, this, "en");
        }

        [Command("pickupline")]
        void cmdPickupLine(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("pickuplines.use"))
            {
                player.Reply(lang.GetMessage("NoPermission", this, player.Id));
                return;
            }

            if (args == null || args.Length == 0)
            {
                player.Reply(lang.GetMessage("InvalidSyntax", this, player.Id));
                return;
            }

            IPlayer targetPlayer;

            if (args[0] == "me")
                targetPlayer = player;
            else
            {
                IEnumerable<IPlayer> targetList = players.FindPlayers(args[0]);

                if (targetList.Count() < 1)
                {
                    player.Reply(lang.GetMessage("NoPlayersFound", this, player.Id));
                    return;
                }

                if (targetList.Count() > 1)
                {
                    player.Reply(lang.GetMessage("MultiplePlayersFound", this, player.Id));
                    return;
                }

                targetPlayer = players.FindPlayer(args[0]);
            }

            string pickupLineURL = "http://www.pickuplinegen.com";

            webrequest.EnqueueGet(pickupLineURL, (code, response) =>
            {
                if (code != 200 || response == null)
                {
                    player.Reply(string.Format(lang.GetMessage("WebRequestFailed", this, player.Id), pickupLineURL));
                    return;
                }

                string pickupLine = GetPickupLine(response);

                if (targetPlayer == player)
                {
                    player.Reply(string.Format(lang.GetMessage("YouPickupLinedYourself", this, player.Id), pickupLine));
                    return;
                }

                player.Reply(string.Format(lang.GetMessage("YouPickupLinedPlayer", this, player.Id), targetPlayer.Name, pickupLine));
                targetPlayer.Reply(string.Format(lang.GetMessage("PlayerPickupLinedYou", this, targetPlayer.Id), player.Name, pickupLine));
            }, this);
        }

        string GetPickupLine(string pageResponse)
        {
            int startIndex = pageResponse.IndexOf("<h2>Pickup lines used at your own risk</h2>");
            int endIndex = pageResponse.IndexOf("<div id=\"generate\">");

            string pickupLine = pageResponse.Substring(startIndex + 80, endIndex - startIndex - 93);

            string[] badStrings = { };

            foreach (string badString in badStrings)
                if (pickupLine.Contains(badString))
                    pickupLine = pickupLine.Replace(badString, "");

            return pickupLine;
        }
    }
}

// --- End of file: PickupLines.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/phones-plus ---
// --- Original File Path: P/PhonesPlus/PhonesPlus.cs ---

﻿
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{

    [Info("Phones Plus", "mr01sam", "1.0.2")]
    [Description("Adds notifications, messages, caller ID and more features to phones.")]
    public class PhonesPlus : CovalencePlugin
    {
        private static PhonesPlus PLUGIN;

        private const string PermissionUse = "phonesplus.use";
        private const string PermissionAdmin = "phonesplus.admin";

        /* For internal use */
        private const string PermissionTemp = "phonesplus.temp";

        [PluginReference]
        Plugin ImageLibrary;

        PhoneManager phoneManager;


        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UI title history"] = "HISTORY",
                ["UI title messages"] = "MESSAGES",
                ["UI title clear"] = "CLEAR",
                ["UI title track"] = "TRACK PHONE",
                ["UI title untrack"] = "UNTRACK PHONE",
                ["UI title prompt"] = "No answer? Leave a message:",
                ["HUD incoming"] = "Incoming call from {0}",
                ["History missed"] = "Missed call from {0}",
                ["History outgoing"] = "Outgoing call to {0}",
                ["History answered"] = "Answered call from {0}",
                ["Time minutes"] = "{0} minutes ago",
                ["Time hours"] = "{0} hours ago",
                ["Time days"] = "{0} days ago",
                ["Usage"] = "Usage: {0}",
                ["Notifications on"] = "You will receive incoming call notifications from tracked phones",
                ["Notifications off"] = "You will no longer receive incoming call notifications from tracked phones",
                ["Indicators on"] = "Indicators will be displayed on the HUD for tracked phones",
                ["Indicators off"] = "Indicators will no longer be displayed on the HUD for tracked phones",
                ["No permission"] = "You do not have permission to use that command",
                ["Tracking on"] = "Now tracking phone {0}",
                ["Tracking off"] = "Stopped tracking phone {0}",
                ["Reset ui"] = "Reset UI",
                ["Reset tracked"] = "Reset tracked phone records",
                ["No messages"] = "No recent messages",
                ["No history"] = "No recent calls",
                ["Clear history"] = "Cleared history for {0}",
                ["Clear trackers"] = "Cleared trackers for {0}",
                ["Clear messages"] = "Cleared messages for {0}"
            }, this);
        }
        #endregion

        #region Configuration

        private Configuration config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Enable incoming call notifications (true/false)")]
            public bool EnableIncomingCallNotifications { get; set; } = true;

            [JsonProperty(PropertyName = "Hourly message limit")]
            public int HourlyMessageLimit { get; set; } = 50;

            [JsonProperty(PropertyName = "HUD Notification")]
            public NotificationHUD HudNotification = new NotificationHUD
            {
                AnchorMin = "0.4 0.87",
                AnchorMax = "0.6 0.95",
                BackgroundColor = "0.4 0.4 0.4"
            };

            [JsonProperty(PropertyName = "HUD Call Indicator")]
            public IndicatorHUD HudCallIndicator = new IndicatorHUD
            {
                AnchorMin = "0.655 0.90",
                AnchorMax = "0.675 0.95",
                ImageColor = "0.5 1 0.5 0.5"
            };

            [JsonProperty(PropertyName = "HUD Message Indicator")]
            public IndicatorHUD HudMessageIndicator = new IndicatorHUD
            {
                AnchorMin = "0.68 0.90",
                AnchorMax = "0.70 0.95",
                ImageColor = "0.5 0.5 1 0.5"
            };

            public class NotificationHUD
            {
                [JsonProperty(PropertyName = "Anchor min")]
                public string AnchorMin;
                [JsonProperty(PropertyName = "Anchor max")]
                public string AnchorMax;
                [JsonProperty(PropertyName = "Background color")]
                public string BackgroundColor;
            }

            public class IndicatorHUD
            {
                [JsonProperty(PropertyName = "Anchor min")]
                public string AnchorMin;
                [JsonProperty(PropertyName = "Anchor max")]
                public string AnchorMax;
                [JsonProperty(PropertyName = "Image color")]
                public string ImageColor;
            }

            public class HistoryUI
            {
                [JsonProperty(PropertyName = "Entry background color")]
                public string EntryBackgroundColor = "0.9 0.9 0.9 0.9";
                [JsonProperty(PropertyName = "Font color")]
                public string FontColor = "1 1 1 1";
            }

            public class MessagesUI
            {
                [JsonProperty(PropertyName = "Entry background color")]
                public string EntryBackgroundColor = "0.9 0.9 0.9 0.9";
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadDefaultConfig() => config = new Configuration();


        #endregion

        #region Commands

        private Dictionary<string, ChatCmd> commands = new Dictionary<string, ChatCmd>();

        void InitCommands()
        {
            commands.Add("help", new ChatCmd
            {
                perms = new List<string>() { PermissionUse },
                function = (IPlayer player, string command, string[] args) => { cmd_phone_help(player, command, args); }
            });
            commands.Add("set", new ChatCmd
            {
                usages = new List<string>() { "<notifications/indicators> <true/false>" },
                perms = new List<string>() { PermissionUse },
                function = (IPlayer player, string command, string[] args) => { cmd_phone_set(player, command, args); }
            });
            commands.Add("reset", new ChatCmd
            {
                usages = new List<string>() { "<ui/tracked>" },
                perms = new List<string>() { PermissionUse },
                function = (IPlayer player, string command, string[] args) => { cmd_phone_reset(player, command, args); }
            });
            commands.Add("clear", new ChatCmd
            {
                usages = new List<string>() { "<trackers/messages/history> <phonenumber>" },
                perms = new List<string>() { PermissionAdmin },
                function = (IPlayer player, string command, string[] args) => { cmd_phone_clear(player, command, args); }
            });
        }

        class ChatCmd
        {
            public string prefix = "";
            public List<string> usages = new List<string>();
            public List<string> perms = new List<string>();
            public Action<IPlayer, string, string[]> function;

            public bool HasPerms(string id, PhonesPlus plugin)
            {
                foreach (string perm in perms)
                    if (plugin.permission.UserHasPermission(id, perm))
                        return true;
                return false;
            }

            public string Usage(string prefix)
            {
                string message = "";
                if (usages.Count > 0)
                {
                    string last = usages.Last();
                    foreach (string usg in usages)
                    {
                        message += string.Format("{0} {1}", prefix, usg);
                        if (!usg.Equals(last))
                            message += ", ";
                    }
                }
                else
                {
                    message = prefix;
                }

                return message;
            }
        }

        [Command("phone")]
        private void cmd_phone(IPlayer player, string command, string[] args)
        {
            if (args.Length >= 1)
            {
                string prefix = args[0].ToLower();
                if (commands.ContainsKey(prefix))
                {
                    args = args.Skip(1).ToArray();

                    ChatCmd cmd = commands[prefix];
                    if (cmd.HasPerms(player.Id, this))
                    {
                        try
                        {
                            commands[prefix].function(player, command, args);
                        }
                        catch (Exception)
                        {
                            player.Reply(string.Format(lang.GetMessage("Usage", this, player.Id), "phone " + cmd.Usage(prefix)));
                        }
                        return;
                    }
                    else
                    {
                        /* No perms */
                        player.Reply(lang.GetMessage("No permission", this, player.Id));
                    }
                }
            }
            else
            {
                if (permission.UserHasPermission(player.Id, PermissionUse))
                {
                    cmd_phone_help(player, command, args);
                }
                else
                {
                    player.Reply(lang.GetMessage("No permission", this, player.Id));
                }
            }
        }

        #region User Commands

        [Command("phone.set"), Permission(PermissionUse)]
        private void cmd_phone_set(IPlayer player, string command, string[] args)
        {
            bool value = bool.Parse(args[1]);
            switch (args[0].ToLower())
            {
                case "notifications":
                    phoneManager.SetPreference(ulong.Parse(player.Id), "notifications", value);
                    if (value)
                        player.Reply(lang.GetMessage("Notifications on", this, player.Id));
                    else
                        player.Reply(lang.GetMessage("Notifications off", this, player.Id));
                    break;
                case "indicators":
                    phoneManager.SetPreference(ulong.Parse(player.Id), "indicators", value);
                    if (value)
                        player.Reply(lang.GetMessage("Indicators on", this, player.Id));
                    else
                        player.Reply(lang.GetMessage("Indicators off", this, player.Id));
                    ShowUnreadIndicator(BasePlayer.FindByID(ulong.Parse(player.Id)));
                    ShowCallIndicator(BasePlayer.FindByID(ulong.Parse(player.Id)));
                    break;
                default:
                    break;
            }
        }

        [Command("phone.reset"), Permission(PermissionUse)]
        private void cmd_phone_reset(IPlayer player, string command, string[] args)
        {
            BasePlayer entity = BasePlayer.FindByID(ulong.Parse(player.Id));
            switch (args[0].ToLower())
            {
                case "ui":
                    HideAllUI(entity);
                    ShowCallIndicator(entity);
                    ShowUnreadIndicator(entity);
                    player.Reply(lang.GetMessage("Reset ui", this, player.Id));
                    break;
                case "tracked":
                    foreach (uint id in phoneManager.GetTrackedPhones(entity.userID))
                    {
                        RegisteredPhone phone = phoneManager.FindPhoneByID(id);
                        if (phone != null)
                            phoneManager.UntrackPhone(entity, phone.GetNumber());
                    }

                    phoneManager.UpdatePhoneMessageCount(entity.userID, 0);
                    phoneManager.UpdatePhoneRecordsCount(entity.userID, 0);
                    player.Reply(lang.GetMessage("Reset tracked", this, player.Id));
                    ShowUnreadIndicator(entity);
                    ShowCallIndicator(entity);
                    break;
                default:
                    break;
            }
        }

        [Command("phone.help"), Permission(PermissionUse)]
        private void cmd_phone_help(IPlayer player, string command, string[] args)
        {
            string size = "16";
            string cmdList = FormatTxt("Phones", "ca2a13", size) + FormatTxt("Plus", "ca2a13", size) + "\n";
            foreach (string prefix in commands.Keys)
            {
                ChatCmd cmd = commands[prefix];
                if (cmd.HasPerms(player.Id, this))
                    cmdList += "phone " + cmd.Usage(prefix) + "\n";
            }
            player.Reply(cmdList);
        }

        #endregion

        #region UI Commands
        [Command("phone.message"), Permission(PermissionTemp)]
        private void cmd_phone_message(IPlayer player, string command, string[] args)
        {
            int senderNumber = int.Parse(args[0]);
            int targetNumber = int.Parse(args[1]);
            string text = "";
            if (args.Length > 2 && !phoneManager.ExceededMessageLimit(ulong.Parse(player.Id)))
            {
                for (int i = 2; i < args.Length; i++)
                {
                    if (i == 2)
                        args[i] = args[i].TitleCase();
                    text += args[i];
                    if (i < args.Length - 1)
                        text += " ";
                }
                CuiHelper.DestroyUi(BasePlayer.FindByID(ulong.Parse(player.Id)), "phonesInputOverlay");
                if (text.Length > 0)
                {
                    phoneManager.IncrementMessageUse(ulong.Parse(player.Id));
                    phoneManager.LeaveMessage(senderNumber, targetNumber, text);
                }
            }
            CuiHelper.DestroyUi(BasePlayer.FindByID(ulong.Parse(player.Id)), "phonesInputOverlay");
        }

        [Command("phone.track"), Permission(PermissionTemp)]
        private void cmd_phone_track(IPlayer player, string command, string[] args)
        {
            int phoneNumber = int.Parse(args[0]);

            RegisteredPhone phone = phoneManager.FindPhoneByNumber(phoneNumber);
            if (phone != null)
            {
                BasePlayer target = BasePlayer.FindByID(ulong.Parse(player.Id));
                if (phoneManager.TrackPhone(target, phoneNumber))
                    player.Reply(string.Format(lang.GetMessage("Tracking on", this, player.Id), phoneNumber));
                ShowPhoneUI(target, phone);
            }
        }

        [Command("phone.untrack"), Permission(PermissionTemp)]
        private void cmd_phone_untrack(IPlayer player, string command, string[] args)
        {
            int phoneNumber = int.Parse(args[0]);

            RegisteredPhone phone = phoneManager.FindPhoneByNumber(phoneNumber);
            if (phone != null)
            {
                BasePlayer target = BasePlayer.FindByID(ulong.Parse(player.Id));
                if (phoneManager.UntrackPhone(target, phoneNumber))
                    player.Reply(string.Format(lang.GetMessage("Tracking off", this, player.Id), phoneNumber));
                ShowPhoneUI(target, phone);
            }
        }

        [Command("phone.clear"), Permission(PermissionTemp)]
        private void cmd_phone_clear(IPlayer player, string command, string[] args)
        {
            int number = int.Parse(args[1]);
            RegisteredPhone phone = phoneManager.FindPhoneByNumber(number);
            BasePlayer entity = BasePlayer.FindByID(ulong.Parse(player.Id));
            switch (args[0].ToLower())
            {
                case "messages":
                    phoneManager.ClearMessages(phone);
                    if (!phoneManager.IsStateEqualTo(entity, 0))
                        ShowPhoneUI(entity, phone);
                    else
                        player.Reply(string.Format(lang.GetMessage("Clear messages", this, player.Id), phone.GetIdentity()));
                    break;
                case "history":
                    phoneManager.ClearHistory(phone);
                    if (!phoneManager.IsStateEqualTo(entity, 0))
                        ShowPhoneUI(entity, phone);
                    else
                        player.Reply(string.Format(lang.GetMessage("Clear history", this, player.Id), phone.GetIdentity()));
                    break;
                case "trackers":
                    phoneManager.ClearTrackers(phone);
                    if (!phoneManager.IsStateEqualTo(entity, 0))
                        ShowPhoneUI(entity, phone);
                    else
                        player.Reply(string.Format(lang.GetMessage("Clear trackers", this, player.Id), phone.GetIdentity()));
                    break;
                default:
                    break;
            }
        }

        [Command("phone.uiclose"), Permission(PermissionTemp)]
        private void cmd_uiclose(IPlayer player, string command, string[] args)
        {
            HideAllUI(BasePlayer.FindByID(ulong.Parse(player.Id)));
            string usage = string.Format(lang.GetMessage("Usage", this, player.Id), command);
            player.Reply(usage);
        }

        #endregion

        #region Admin Commands
        [Command("phone.history"), Permission(PermissionAdmin)]
        private void cmd_phone_history(IPlayer player, string command, string[] args)
        {
            try
            {
                int phoneNumber = int.Parse(args[0]);
                RegisteredPhone phone = phoneManager.FindPhoneByNumber(phoneNumber);
                if (phone != null)
                {
                    PhoneRecordList records = phoneManager.GetPhoneRecords(phoneNumber);
                    string recordListStr = "<" + phoneNumber + ">\n";
                    foreach (PhoneRecord record in records.RecentRecords(10))
                    {
                        recordListStr += string.Format("({0}, {1}, {2})", record.GetTimeElapsed(), record.status, record.Number(phoneManager)) + "\n";
                    }
                    player.Reply(recordListStr);
                }
            }
            catch (Exception)
            {
                string usage = string.Format(lang.GetMessage("Usage", this, player.Id), command) + " <phone_number>";
                player.Reply(usage);
            }
        }
        #endregion

        #endregion

        #region Custom Hooks
        void UsePhone(BasePlayer player, RegisteredPhone phone)
        {
            if (Interface.CallHook("OnPhoneUse", player, phone.phoneController) != null) return;
            if (player.IsValid() && phone != null && permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                if (phone.phoneController.activeCallTo == null)
                    ShowPhoneUI(player, phone);
                HideNotificationHUD(player);
                int changedMessages = phoneManager.GetPhoneMessages(phone.GetNumber()).MarkAllAsRead();
                int changedRecords = phoneManager.GetPhoneRecords(phone.GetNumber()).MarkAllAsRead();
                foreach (ulong userId in phoneManager.GetPhoneTrackers(phone))
                {
                    BasePlayer tracker = BasePlayer.FindByID(userId);
                    if (tracker.IsValid())
                    {
                        phoneManager.UpdatePhoneMessageCount(tracker.userID, phoneManager.GetPhoneMessageCount(tracker.userID) - changedMessages);
                        phoneManager.UpdatePhoneRecordsCount(tracker.userID, phoneManager.GetPhoneRecordsCount(tracker.userID) - changedRecords);
                        ShowUnreadIndicator(tracker);
                        ShowCallIndicator(tracker);
                    }
                }
            }
        }

        void UsePhoneEnd(BasePlayer player)
        {
            if (Interface.CallHook("OnPhoneUseEnd", player) != null) return;
            HideAllUI(player);
        }

        void ActiveCall(BasePlayer player, RegisteredPhone phone)
        {
            if (Interface.CallHook("OnActiveCall", player, phone.phoneController) != null) return;
            HideAllUI(player);
        }

        void ActiveCallEnd(BasePlayer player, RegisteredPhone phone)
        {
            if (Interface.CallHook("OnActiveCallEnd", player, phone.phoneController) != null) return;
            ShowPhoneUI(player, phone);
        }
        #endregion

        #region Hooks

        void Init()
        {
            #region Unsubscribe
            Unsubscribe(nameof(OnPhoneAnswered));
            Unsubscribe(nameof(OnPhoneDial));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(CanPickupEntity));
            Unsubscribe(nameof(OnPlayerConnected));
            Unsubscribe(nameof(OnUserPermissionGranted));
            Unsubscribe(nameof(OnPhoneDialFail));
            Unsubscribe(nameof(OnServerSave));
            #endregion

            InitCommands();
        }

        void OnServerInitialized()
        {
            PLUGIN = this;
            try
            {
                ImageLibrary.Call("isLoaded", null);
            }
            catch (Exception)
            {
                PrintWarning($"The required dependency ImageLibrary is not installed, unloading {Name}.");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }

            #region Subscribe
            Subscribe(nameof(OnPhoneAnswered));
            Subscribe(nameof(OnPhoneDial));
            Subscribe(nameof(OnEntitySpawned));
            Subscribe(nameof(OnEntityDeath));
            Subscribe(nameof(CanPickupEntity));
            Subscribe(nameof(OnPlayerConnected));
            Subscribe(nameof(OnUserPermissionGranted));
            Subscribe(nameof(OnPhoneDialFail));
            Subscribe(nameof(OnServerSave));
            #endregion

            phoneManager = new PhoneManager();

            LoadImages();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                HideAllUI(player);
                HideNotificationHUD(player);
                ShowUnreadIndicator(player);
                ShowCallIndicator(player);
                CheckIfUsingPhone(player);
            }
            ResetMessages();
        }

        void OnPhoneAnswered(PhoneController receiverPhone, PhoneController callerPhone)
        {
            phoneManager.RegisterPhone(callerPhone);
            phoneManager.RegisterPhone(receiverPhone);
            phoneManager.GetPhoneRecords(receiverPhone.PhoneNumber).RecordAnswered(receiverPhone, callerPhone, phoneManager);
            HideAllUI(receiverPhone.currentPlayer);
            HideAllUI(callerPhone.currentPlayer);
        }

        object OnPhoneDial(PhoneController callerPhone, PhoneController receiverPhone, BasePlayer player)
        {
            HideAllUI(player);
            phoneManager.RegisterPhone(callerPhone);
            phoneManager.RegisterPhone(receiverPhone);
            phoneManager.GetPhoneRecords(callerPhone.PhoneNumber).RecordOutgoing(callerPhone, receiverPhone, phoneManager);
            if (config.EnableIncomingCallNotifications)
                NotifyIncoming(receiverPhone.baseEntity.net.ID, callerPhone.baseEntity.net.ID);
            return null;
        }

        void OnEntitySpawned(Telephone entity)
        {
            phoneManager.RegisterPhone(entity.Controller);
        }

        void OnEntityDeath(Telephone entity, HitInfo info)
        {
            phoneManager.UnregisterPhone(entity);
        }

        bool CanPickupEntity(BasePlayer player, Telephone entity)
        {
            phoneManager.UnregisterPhone(entity);
            return true;
        }

        void OnPlayerConnected(BasePlayer player)
        {
            InitPlayer(player);
        }

        void OnUserPermissionGranted(string id, string permName)
        {
            if (permName == PermissionUse)
                InitPlayer(BasePlayer.FindByID(ulong.Parse(id)));
        }

        object OnPhoneDialFail(PhoneController callerPhone, Telephone.DialFailReason reason, BasePlayer player)
        {
            if (callerPhone == null) return null;
            PhoneController receiverPhone = callerPhone.activeCallTo;
            if (receiverPhone == null) return null;
            phoneManager.RegisterPhone(callerPhone);
            phoneManager.RegisterPhone(receiverPhone);

            if (reason == Telephone.DialFailReason.SelfHangUp || reason == Telephone.DialFailReason.TimedOut)
            {
                phoneManager.GetPhoneRecords(receiverPhone.PhoneNumber).RecordMissed(receiverPhone, callerPhone, phoneManager);
                if (player != null && callerPhone != null)
                {
                    ShowPhoneUI(player, phoneManager.FindPhoneByNumber(callerPhone.PhoneNumber));
                    timer.In(0.05f, () =>
                    {
                        if (receiverPhone != null)
                            receiverPhone.activeCallTo = null;
                        if (!phoneManager.ExceededMessageLimit(player.userID) && !receiverPhone.currentPlayer.IsValid())
                            ShowInputUI(player, callerPhone.PhoneNumber, receiverPhone.PhoneNumber);
                    });
                    

                }
            }

            return null;
        }

        void OnServerSave()
        {
            phoneManager.SavePhoneMessages();
            phoneManager.SavePhoneRecords();
            phoneManager.SavePreferences();
            phoneManager.SaveTrackedPhones();
            Puts("saved data");
        }

        #endregion

        #region Helpers
        private string FormatTxt(string text, string color = "white", string size = "14")
        {
            return $"<size={size}>[#{color}]{text}[/#]</size>";
        }

        private void LoadImages()
        {
            ImageLibrary.Call<bool>("AddImage", "https://i.imgur.com/P4yACUv.png", "PhonesPlusIcon", 0UL);
            ImageLibrary.Call<bool>("AddImage", "https://i.imgur.com/HlSs8oN.png", "CallIcon", 0UL);
            ImageLibrary.Call<bool>("AddImage", "https://i.imgur.com/wbEpjW2.png", "HistoryIcon", 0UL);
            ImageLibrary.Call<bool>("AddImage", "https://i.imgur.com/dpAt1K4.png", "MessageIcon", 0UL);
            ImageLibrary.Call<bool>("AddImage", "https://i.imgur.com/CXcaqw7.png", "CloseIcon", 0UL);
        }

        private void CheckIfUsingPhone(BasePlayer player)
        {
            if (player.IsValid() && player.IsConnected)
            {
                if (player.HasActiveTelephone && phoneManager.IsStateEqualTo(player, 0))
                {
                    RegisteredPhone phone = phoneManager.GetNearbyPhone(player);
                    if (phone != null)
                    {
                        phoneManager.SetState(player, 1);
                        UsePhone(player, phone);
                    }
                }
                else if (player.HasActiveTelephone && phoneManager.IsStateEqualTo(player, 1))
                {
                    RegisteredPhone phone = phoneManager.GetNearbyPhone(player);
                    if (phone != null)
                    {
                        if (phone.phoneController.activeCallTo != null)
                        {
                            phoneManager.SetState(player, 2);
                            ActiveCall(player, phone);
                        }
                    }
                }
                else if (player.HasActiveTelephone && phoneManager.IsStateEqualTo(player, 2))
                {
                    RegisteredPhone phone = phoneManager.GetNearbyPhone(player);
                    if (phone != null)
                    {
                        if (phone.phoneController.activeCallTo == null)
                        {
                            phoneManager.SetState(player, 1);
                            ActiveCallEnd(player, phone);
                        }
                    }
                }
                else if (!player.HasActiveTelephone && !phoneManager.IsStateEqualTo(player, 0))
                {
                    phoneManager.SetState(player, 0);
                    UsePhoneEnd(player);
                }

                timer.In(0.05f, () =>
                {
                    CheckIfUsingPhone(player);
                });

            }
        }

        private void ResetMessages()
        {
            timer.In(3600f, () =>
            {
                phoneManager.ResetHourlyMessageLimits();
                ResetMessages();
            });
        }

        private void InitPlayer(BasePlayer player)
        {
            if (player.IsValid())
            {
                HideAllUI(player);
                CheckIfUsingPhone(player);
                ShowUnreadIndicator(player);
                ShowCallIndicator(player);
            }
        }

        private string ElapsedTimeString(BasePlayer player, long seconds)
        {
            if (seconds < 3600)
                return string.Format(lang.GetMessage("Time minutes", this, player.UserIDString), Math.Max(1, Math.Round((double)seconds / 60)));
            if (seconds < 86400)
                return string.Format(lang.GetMessage("Time hours", this, player.UserIDString), Math.Max(1, Math.Round((double)seconds / 3600)));
            else
                return string.Format(lang.GetMessage("Time hours", this, player.UserIDString), Math.Max(1, Math.Round((double)seconds / 86400)));
        }

        void NotifyIncoming(uint receiverPhoneID, uint callerPhoneID)
        {
            RegisteredPhone receivingPhone = phoneManager.FindPhoneByID(receiverPhoneID);
            RegisteredPhone callingPhone = phoneManager.FindPhoneByID(callerPhoneID);
            List<ulong> trackers = phoneManager.GetPhoneTrackers(receivingPhone);
            foreach (ulong userId in trackers)
            {
                BasePlayer tracker = BasePlayer.FindByID(userId);
                if (tracker.IsValid())
                {
                    if (phoneManager.GetPreference<bool>(tracker.userID, "notifications") && phoneManager.IsStateEqualTo(tracker, 0))
                    {
                        string message = string.Format(lang.GetMessage("HUD incoming", this, tracker.UserIDString), callingPhone.GetIdentity());
                        ShowNotificationHUD(tracker, message, receivingPhone);
                    };
                }
            }
        }
        #endregion

        #region Classes

        class PhoneMessage
        {
            public readonly int senderNumber;
            public readonly int receiverNumber;
            public readonly string text;
            public bool unread;
            public long time;

            public PhoneMessage(int senderNumber, int receiverNumber, string text, long time = 0)
            {
                this.text = text;
                this.senderNumber = senderNumber;
                this.receiverNumber = receiverNumber;
                if (time == 0)
                    this.time = DateTimeOffset.Now.ToUnixTimeSeconds();
                else
                    this.time = time;
                this.unread = true;
            }

            public long GetTimeElapsed()
            {
                return DateTimeOffset.Now.ToUnixTimeSeconds() - time;
            }

            public string SenderID(PhoneManager manager)
            {
                RegisteredPhone phone = manager.FindPhoneByNumber(senderNumber);
                return phone != null ? phone.GetIdentity() : manager.UNREGISTERED;
            }

            public string ReceiverID(PhoneManager manager)
            {
                RegisteredPhone phone = manager.FindPhoneByNumber(receiverNumber);
                return phone != null ? phone.GetIdentity() : manager.UNREGISTERED;
            }
        }

        class PhoneMessageList
        {
            public List<PhoneMessage> messages;

            public PhoneMessageList()
            {
                messages = new List<PhoneMessage>();
            }

            public List<PhoneMessage> RecentMessages(int amount)
            {
                List<PhoneMessage> recent = new List<PhoneMessage>();
                for (int i = Math.Max(0, messages.Count - amount); i < messages.Count; ++i)
                {
                    recent.Add(messages[i]);
                }
                recent.Sort((x, y) => y.time.CompareTo(x.time));
                return recent;
            }

            public int MarkAllAsRead()
            {
                int changed = 0;
                foreach (PhoneMessage message in messages)
                {
                    if (message.unread)
                    {
                        changed++;
                        message.unread = false;
                    }
                }
                return changed;
            }
        }

        class PhoneRecord
        {
            public readonly int callerNumber;
            public readonly int receiverNumber;
            public bool unread;
            public readonly string status; /* answered, missed, outgoing */
            public long time;

            public PhoneRecord(string status, int callerNumber, int receiverNumber, long time = 0)
            {
                this.status = status;
                this.callerNumber = callerNumber;
                this.receiverNumber = receiverNumber;
                if (time == 0)
                    this.time = DateTimeOffset.Now.ToUnixTimeSeconds();
                else
                    this.time = time;
                this.unread = true;
            }

            public long GetTimeElapsed()
            {
                return DateTimeOffset.Now.ToUnixTimeSeconds() - time;
            }

            public string CallerID(PhoneManager manager)
            {
                RegisteredPhone phone = manager.FindPhoneByNumber(callerNumber);
                if (phone != null)
                    return phone.GetIdentity();
                return manager.UNREGISTERED;
            }

            public string ReceiverID(PhoneManager manager)
            {
                RegisteredPhone phone = manager.FindPhoneByNumber(receiverNumber);
                if (phone != null)
                    return phone.GetIdentity();
                return manager.UNREGISTERED;
            }

            public string ID(PhoneManager manager)
            {
                if (status == "outgoing")
                    return ReceiverID(manager);
                return CallerID(manager);
            }

            public int Number(PhoneManager manager)
            {
                if (status == "outgoing")
                    return receiverNumber;
                return callerNumber;
            }
        }

        class PhoneRecordList
        {
            public List<PhoneRecord> records;

            [NonSerialized]
            public PhoneController phoneItem;

            public PhoneRecordList(PhoneController phone)
            {
                records = new List<PhoneRecord>();
                phoneItem = phone;
            }

            public PhoneRecordList()
            {
                records = new List<PhoneRecord>();
            }

            public List<PhoneRecord> RecentRecords(int amount)
            {
                List<PhoneRecord> recent = new List<PhoneRecord>();
                for (int i = Math.Max(0, records.Count - amount); i < records.Count; ++i)
                {
                    recent.Add(records[i]);
                }
                recent.Sort((x, y) => y.time.CompareTo(x.time));
                return recent;
            }

            public void RecordAnswered(PhoneController thisPhone, PhoneController callerPhone, PhoneManager manager)
            {
                records.Add(new PhoneRecord("answered", callerPhone.PhoneNumber, thisPhone.PhoneNumber));
            }

            public void RecordMissed(PhoneController thisPhone, PhoneController callerPhone, PhoneManager manager)
            {
                RegisteredPhone phone = manager.FindPhoneByNumber(thisPhone.PhoneNumber);
                records.Add(new PhoneRecord("missed", callerPhone.PhoneNumber, thisPhone.PhoneNumber));
                foreach (ulong userId in manager.GetPhoneTrackers(phone))
                {
                    BasePlayer tracker = BasePlayer.FindByID(userId);
                    if (tracker.IsValid())
                    {
                        manager.UpdatePhoneRecordsCount(tracker.userID, manager.GetPhoneRecordsCount(tracker.userID) + 1);
                        PLUGIN.ShowCallIndicator(tracker);
                    }
                }
            }

            public void RecordOutgoing(PhoneController thisPhone, PhoneController receiverPhone, PhoneManager manager)
            {
                records.Add(new PhoneRecord("outgoing", thisPhone.PhoneNumber, receiverPhone.PhoneNumber));
            }

            public int MarkAllAsRead()
            {
                int changed = 0;
                foreach (PhoneRecord record in records)
                {
                    if (record.unread)
                    {
                        changed++;
                        record.unread = false;
                    }
                }
                return changed;
            }
        }

        class RegisteredPhone
        {
            public readonly BaseEntity baseEntity;

            public readonly PhoneController phoneController;

            public RegisteredPhone(PhoneController phoneController)
            {
                this.phoneController = phoneController;
                this.baseEntity = phoneController.baseEntity;
            }

            public uint GetID()
            {
                return baseEntity.net.ID;
            }

            public int GetNumber()
            {
                return phoneController.PhoneNumber;
            }

            public string GetName()
            {
                return phoneController.PhoneName;
            }

            public bool HasName()
            {
                return phoneController.PhoneName != null && phoneController.PhoneName != "";
            }

            public string GetIdentity()
            {
                if (HasName())
                    return GetName().Substring(0, Math.Min(16, GetName().Length));
                return GetNumber().ToString();
            }

            public bool UserHasAuth(BasePlayer player)
            {
                BuildingPrivlidge priv = baseEntity.GetBuildingPrivilege();
                if (priv != null)
                {
                    foreach (ProtoBuf.PlayerNameID playerID in priv.authorizedPlayers)
                    {
                        if (playerID.userid == player.userID)
                            return true;
                    }
                }
                return false;
            }
        }

        class PhoneManager
        {
            public List<uint> registeredPhoneIds;
            public List<RegisteredPhone> registeredPhones;
            private Dictionary<uint, RegisteredPhone> id2phone;
            private Dictionary<int, RegisteredPhone> number2phone;
            private Dictionary<ulong, List<uint>> userTrackedPhones;
            private Dictionary<uint, List<ulong>> trackersOfPhone;
            private Dictionary<ulong, Dictionary<string, object>> userPreferences;
            public Dictionary<int, PhoneRecordList> phoneRecords;
            private Dictionary<ulong, int> phoneRecordsCount;
            public Dictionary<int, PhoneMessageList> phoneMessages;
            private Dictionary<ulong, int> phoneMessageCount;
            private Dictionary<ulong, int> hourlyMessageCount;
            private Dictionary<ulong, int> callState;

            public readonly string UNREGISTERED = "???";

            public PhoneManager()
            {
                registeredPhones = new List<RegisteredPhone>();
                registeredPhoneIds = new List<uint>();
                id2phone = new Dictionary<uint, RegisteredPhone>();
                number2phone = new Dictionary<int, RegisteredPhone>();
                userTrackedPhones = new Dictionary<ulong, List<uint>>();
                trackersOfPhone = new Dictionary<uint, List<ulong>>();
                userPreferences = new Dictionary<ulong, Dictionary<string, object>>();
                phoneRecords = new Dictionary<int, PhoneRecordList>();
                phoneRecordsCount = new Dictionary<ulong, int>();
                phoneMessages = new Dictionary<int, PhoneMessageList>();
                phoneMessageCount = new Dictionary<ulong, int>();
                hourlyMessageCount = new Dictionary<ulong, int>();
                callState = new Dictionary<ulong, int>();
                RegisterExistingPhones();
                LoadTrackedPhones();
                LoadPhoneRecords();
                LoadPhoneMessages();
                LoadPreferences();
            }

            public void LeaveMessage(int senderNumber, int targetNumber, string text)
            {
                RegisteredPhone phone = FindPhoneByNumber(targetNumber);
                if (phone != null)
                {
                    if (!phoneMessages.ContainsKey(targetNumber))
                        phoneMessages.Add(targetNumber, new PhoneMessageList());
                    phoneMessages[targetNumber].messages.Add(new PhoneMessage(senderNumber, targetNumber, text));
                    foreach (ulong userId in GetPhoneTrackers(phone))
                    {
                        BasePlayer tracker = BasePlayer.FindByID(userId);
                        if (tracker.IsValid())
                        {
                            UpdatePhoneMessageCount(tracker.userID, GetPhoneMessageCount(tracker.userID) + 1);
                            PLUGIN.ShowUnreadIndicator(tracker);
                        }
                    }
                }
            }

            public void InitPreferences(ulong userID)
            {
                if (!userPreferences.ContainsKey(userID))
                {
                    userPreferences.Add(userID, new Dictionary<string, object>() {
                        { "notifications", true },
                        { "indicators", true }
                    });
                }
            }

            public void SetPreference(ulong userID, string key, object value)
            {
                InitPreferences(userID);
                userPreferences[userID][key] = value;
            }

            public T GetPreference<T>(ulong userID, string key)
            {
                InitPreferences(userID);
                return (T)userPreferences[userID][key];
            }

            public void RegisterPhone(PhoneController phone)
            {
                if (!registeredPhoneIds.Contains(phone.baseEntity.net.ID))
                {
                    RegisteredPhone newPhone = new RegisteredPhone(phone);
                    id2phone.Add(newPhone.GetID(), newPhone);
                    number2phone.Add(newPhone.GetNumber(), newPhone);
                    registeredPhones.Add(newPhone);
                    registeredPhoneIds.Add(newPhone.GetID());
                    phoneRecords.Add(newPhone.GetNumber(), new PhoneRecordList());
                    phoneMessages.Add(newPhone.GetNumber(), new PhoneMessageList());
                }
            }

            public void UnregisterPhone(Telephone baseEntity)
            {
                if (baseEntity.IsValid() && registeredPhoneIds.Contains(baseEntity.net.ID))
                {
                    RegisteredPhone phone = id2phone[baseEntity.net.ID];
                    id2phone.Remove(phone.GetID());
                    number2phone.Remove(phone.GetNumber());
                    foreach (ulong userId in GetPhoneTrackers(phone))
                    {
                        BasePlayer player = BasePlayer.FindByID(userId);
                        if (player.IsValid())
                        {
                            int changedMessages = GetPhoneMessages(phone.GetNumber()).MarkAllAsRead();
                            int changedRecords = GetPhoneRecords(phone.GetNumber()).MarkAllAsRead();
                            UpdatePhoneMessageCount(player.userID, GetPhoneMessageCount(player.userID) - changedMessages);
                            UpdatePhoneRecordsCount(player.userID, GetPhoneRecordsCount(player.userID) - changedRecords);
                            PLUGIN.ShowUnreadIndicator(player);
                            PLUGIN.ShowCallIndicator(player);
                            userTrackedPhones[player.userID].Remove(phone.GetID());
                        }

                    }

                    if (trackersOfPhone.ContainsKey(phone.GetID()))
                        trackersOfPhone.Remove(phone.GetID());
                    registeredPhones.Remove(phone);
                    registeredPhoneIds.Remove(phone.GetID());
                    phoneRecords.Remove(phone.GetNumber());
                    phoneMessages.Remove(phone.GetNumber());

                }
            }

            public bool TrackPhone(BasePlayer player, int phoneNumber)
            {
                RegisteredPhone phone = FindPhoneByNumber(phoneNumber);

                if (phone != null && player.IsValid())
                {
                    if (!userTrackedPhones.ContainsKey(player.userID))
                        userTrackedPhones.Add(player.userID, new List<uint>());
                    if (!trackersOfPhone.ContainsKey(phone.GetID()))
                        trackersOfPhone.Add(phone.GetID(), new List<ulong>());

                    userTrackedPhones[player.userID].Add(phone.GetID());
                    trackersOfPhone[phone.GetID()].Add(player.userID);

                    return true;
                }
                /* Phone not registered */
                return false;
            }

            public bool UntrackPhone(BasePlayer player, int phoneNumber)
            {
                RegisteredPhone phone = FindPhoneByNumber(phoneNumber);

                if (phone != null)
                {
                    if (this.userTrackedPhones.ContainsKey(player.userID) && this.userTrackedPhones[player.userID].Contains(phone.GetID()))
                    {
                        this.userTrackedPhones[player.userID].Remove(phone.GetID());
                        this.trackersOfPhone[phone.GetID()].Remove(player.userID);
                    }
                    return true;
                }
                return false;
            }

            public void ClearTrackers(RegisteredPhone phone)
            {
                if (phone != null && trackersOfPhone.ContainsKey(phone.GetID()))
                {
                    int changedMessages = GetPhoneMessages(phone.GetNumber()).MarkAllAsRead();
                    int changedRecords = GetPhoneRecords(phone.GetNumber()).MarkAllAsRead();
                    foreach (ulong userId in GetPhoneTrackers(phone))
                    {
                        BasePlayer tracker = BasePlayer.FindByID(userId);
                        if (tracker.IsValid())
                        {
                            if (userTrackedPhones.ContainsKey(phone.GetID()))
                                userTrackedPhones[tracker.userID].Remove(phone.GetID());
                            UpdatePhoneMessageCount(tracker.userID, GetPhoneMessageCount(tracker.userID) - changedMessages);
                            PLUGIN.ShowUnreadIndicator(tracker);
                            UpdatePhoneRecordsCount(tracker.userID, GetPhoneRecordsCount(tracker.userID) - changedRecords);
                            PLUGIN.ShowCallIndicator(tracker);
                        }
                    }
                    trackersOfPhone[phone.GetID()] = new List<ulong>();
                }
            }

            public void ClearMessages(RegisteredPhone phone)
            {
                if (phone != null && phoneMessages.ContainsKey(phone.GetNumber()))
                {
                    int changed = GetPhoneMessages(phone.GetNumber()).MarkAllAsRead();
                    phoneMessages[phone.GetNumber()].messages = new List<PhoneMessage>();
                    foreach (ulong userId in GetPhoneTrackers(phone))
                    {
                        BasePlayer tracker = BasePlayer.FindByID(userId);
                        if (tracker.IsValid())
                        {
                            UpdatePhoneMessageCount(tracker.userID, GetPhoneMessageCount(tracker.userID) - changed);
                            PLUGIN.ShowUnreadIndicator(tracker);
                        }
                    }
                }
            }

            public void ClearHistory(RegisteredPhone phone)
            {
                if (phone != null && phoneRecords.ContainsKey(phone.GetNumber()))
                {
                    int changed = GetPhoneRecords(phone.GetNumber()).MarkAllAsRead();
                    phoneRecords[phone.GetNumber()].records = new List<PhoneRecord>();
                    foreach (ulong userId in GetPhoneTrackers(phone))
                    {
                        BasePlayer tracker = BasePlayer.FindByID(userId);
                        if (tracker.IsValid())
                        {
                            UpdatePhoneRecordsCount(tracker.userID, GetPhoneRecordsCount(tracker.userID) - changed);
                            PLUGIN.ShowCallIndicator(tracker);
                        }
                    }
                }
            }

            public void ResetHourlyMessageLimits()
            {
                hourlyMessageCount = new Dictionary<ulong, int>();
            }

            public void IncrementMessageUse(ulong userId)
            {
                if (hourlyMessageCount.ContainsKey(userId))
                    hourlyMessageCount[userId] += 1;
                else
                    hourlyMessageCount.Add(userId, 0);
            }

            public bool ExceededMessageLimit(ulong userId)
            {
                if (hourlyMessageCount.ContainsKey(userId))
                    return hourlyMessageCount[userId] > PLUGIN.config.HourlyMessageLimit;
                return false;
            }

            public RegisteredPhone GetNearbyPhone(BasePlayer entity)
            {
                Vector3 startPos = entity.transform.position;
                double maxDist = 3.0;
                foreach (RegisteredPhone phone in registeredPhones)
                {
                    if (phone != null && phone.baseEntity.IsValid())
                    {
                        Vector3 endPos = phone.baseEntity.transform.position;
                        double dist = Math.Sqrt(Math.Pow(startPos.x - endPos.x, 2) + Math.Pow(startPos.z - endPos.z, 2));
                        if (dist <= maxDist && phone.phoneController.currentPlayer == entity)
                        {
                            return phone;
                        }
                    }
                }
                return null;
            }

            public RegisteredPhone FindPhoneByNumber(int phoneNumber)
            {
                if (number2phone.ContainsKey(phoneNumber))
                    return number2phone[phoneNumber];
                return null;
            }

            public RegisteredPhone FindPhoneByID(uint baseEntityId)
            {
                if (id2phone.ContainsKey(baseEntityId))
                    return id2phone[baseEntityId];
                return null;
            }

            public List<ulong> GetPhoneTrackers(RegisteredPhone phone)
            {

                if (trackersOfPhone.ContainsKey(phone.GetID()))
                {
                    return trackersOfPhone[phone.GetID()];
                }

                return new List<ulong>();
            }

            public List<uint> GetTrackedPhones(ulong basePlayerId)
            {
                if (userTrackedPhones.ContainsKey(basePlayerId))
                    return userTrackedPhones[basePlayerId];
                return new List<uint>();
            }

            public bool IsTrackedBy(RegisteredPhone phone, ulong userId)
            {
                return GetPhoneTrackers(phone).Contains(userId);
            }

            public PhoneRecordList GetPhoneRecords(int phoneNumber)
            {
                if (!phoneRecords.ContainsKey(phoneNumber))
                    phoneRecords.Add(phoneNumber, new PhoneRecordList());
                return phoneRecords[phoneNumber];
            }

            public int GetPhoneRecordsCount(ulong userId)
            {
                if (phoneRecordsCount.ContainsKey(userId))
                    return phoneRecordsCount[userId];
                return 0;
            }

            public void UpdatePhoneRecordsCount(ulong userId, int newValue)
            {
                if (phoneRecordsCount.ContainsKey(userId))
                    phoneRecordsCount[userId] = Math.Max(0, newValue);
                else
                    phoneRecordsCount.Add(userId, Math.Max(0, newValue));
            }

            public PhoneMessageList GetPhoneMessages(int phoneNumber)
            {
                if (!phoneMessages.ContainsKey(phoneNumber))
                    phoneMessages.Add(phoneNumber, new PhoneMessageList());
                return phoneMessages[phoneNumber];
            }

            public int GetPhoneMessageCount(ulong userId)
            {
                if (phoneMessageCount.ContainsKey(userId))
                    return phoneMessageCount[userId];
                return 0;
            }

            public void UpdatePhoneMessageCount(ulong userId, int newValue)
            {
                if (phoneMessageCount.ContainsKey(userId))
                    phoneMessageCount[userId] = Math.Max(0, newValue);
                else
                    phoneMessageCount.Add(userId, Math.Max(0, newValue));
            }

            public void SetState(BasePlayer player, int value)
            {
                if (callState.ContainsKey(player.userID))
                    callState[player.userID] = value;
                else
                    callState.Add(player.userID, value);
            }

            public bool IsStateEqualTo(BasePlayer player, int value)
            {
                if (callState.ContainsKey(player.userID))
                    return callState[player.userID] == value;
                else
                    callState.Add(player.userID, 0);
                return callState[player.userID] == value;
            }

            public void RegisterExistingPhones()
            {
                List<Telephone> allPhones = BaseNetworkable.serverEntities.OfType<Telephone>().ToList();
                foreach (Telephone phone in allPhones)
                    RegisterPhone(phone.Controller);
                PLUGIN.Puts(registeredPhones.Count() + " registered");
            }

            #region File IO
            public void SaveTrackedPhones()
            {
                SaveFile<Dictionary<ulong, List<uint>>>("tracked", userTrackedPhones);
            }

            public void LoadTrackedPhones()
            {
                try
                {
                    Dictionary<ulong, List<uint>> tracked = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, List<uint>>>("PhonesPlus/tracked");
                    Dictionary<uint, List<ulong>> temp = new Dictionary<uint, List<ulong>>();
                    foreach (ulong userId in tracked.Keys)
                    {
                        BasePlayer player = BasePlayer.FindByID(userId);
                        if (player.IsValid())
                        {
                            List<uint> phones = tracked[userId];
                            foreach (uint entityId in phones)
                            {
                                if (id2phone.ContainsKey(entityId))
                                {
                                    RegisteredPhone phone = id2phone[entityId];
                                    if (phone != null)
                                    {
                                        TrackPhone(player, phone.GetNumber());
                                    }
                                }
                            }
                        }
                    }
                }
                catch (Exception)
                {
                    PLUGIN.PrintWarning("Failed to load from data file 'tracked'");
                }
            }

            public void SavePhoneRecords()
            {
                SaveFile<Dictionary<int, PhoneRecordList>>("records", phoneRecords);
            }

            public void LoadPhoneRecords()
            {
                phoneRecords = LoadFromFile<Dictionary<int, PhoneRecordList>>("records", phoneRecords);
            }

            public void SavePhoneMessages()
            {
                SaveFile<Dictionary<int, PhoneMessageList>>("messages", phoneMessages);
            }

            public void LoadPhoneMessages()
            {
                phoneMessages = LoadFromFile<Dictionary<int, PhoneMessageList>>("messages", phoneMessages);
                foreach (int number in phoneMessages.Keys)
                {
                    RegisteredPhone phone = FindPhoneByNumber(number);
                    if (phone != null)
                    {
                        foreach (ulong userId in GetPhoneTrackers(phone))
                        {
                            BasePlayer player = BasePlayer.FindByID(userId);
                            if (player.IsValid())
                            {
                                PhoneMessageList messageList = phoneMessages[number];
                                foreach (PhoneMessage message in messageList.RecentMessages(6))
                                {
                                    if (message.unread)
                                    {
                                        UpdatePhoneMessageCount(userId, GetPhoneMessageCount(userId) + 1);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            public void SavePreferences()
            {
                SaveFile<Dictionary<ulong, Dictionary<string, object>>>("preferences", userPreferences);
            }

            public void LoadPreferences()
            {
                userPreferences = LoadFromFile<Dictionary<ulong, Dictionary<string, object>>>("preferences", userPreferences);
            }

            private void SaveFile<T>(string fileName, T data)
            {
                try
                {
                    Interface.Oxide.DataFileSystem.WriteObject("PhonesPlus/" + fileName, data);
                }
                catch (Exception)
                {
                    PLUGIN.PrintWarning("Failed to save data to file '" + fileName + "'");
                }
            }

            private T LoadFromFile<T>(string fileName, T defaultValue)
            {
                try
                {
                    T data = Interface.Oxide.DataFileSystem.ReadObject<T>("PhonesPlus/" + fileName);
                    return data;
                }
                catch (Exception)
                {
                    PLUGIN.PrintWarning("Failed to load from data file '" + fileName + "'");
                }
                return defaultValue;
            }
            #endregion
        }
        #endregion

        #region UI

        #region History Panel
        CuiElementContainer CreateHistoryPanel(BasePlayer player, RegisteredPhone phone)
        {
            CuiElementContainer container = new CuiElementContainer();
            if (player.IsValid() && phone != null)
            {
                container.Add(new CuiPanel
                {
                    Image =
                {
                    Color = "0 0 0 0"
                },
                    RectTransform =
                {
                    AnchorMin = "0.685 0.1275",
                    AnchorMax = "0.900 0.76"
                }
                }, "Overlay", "phonesHistory");
                container.Add(new CuiPanel
                {
                    Image =
                {
                    Color = COLOR_RUST_BODY.RGBA()
                },
                    RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 0.92"
                }
                }, "phonesHistory", "phonesHistoryBody");
                container.Add(new CuiPanel
                {
                    Image =
                {
                    Color = COLOR_RUST_HEADER.RGBA()
                },
                    RectTransform =
                {
                    AnchorMin = "0 0.92",
                    AnchorMax = "1 1"
                }
                }, "phonesHistory", "phonesHistoryHeader");
                container.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = lang.GetMessage("UI title history", this, player.UserIDString),
                        FontSize = 14,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                }
                }, "phonesHistoryHeader", "phonesHistoryHeaderText");
                container.Add(new CuiElement
                {
                    Name = "phonesHistoryHeaderImage",
                    Parent = "phonesHistoryHeader",
                    Components =
                {
                    new CuiRawImageComponent {
                        Png = ImageLibrary?.Call<string>("GetImage", "HistoryIcon")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.04 0.3",
                        AnchorMax = "0.10 0.7"
                    }
                },
                });

                List<PhoneRecord> records = phoneManager.GetPhoneRecords(phone.GetNumber()).RecentRecords(10);
                if (records.Count > 0)
                {
                    int index = 0;
                    double bottomS = 0.9;
                    double topS = 0.97;
                    double mod = 0.08;
                    foreach (PhoneRecord record in phoneManager.GetPhoneRecords(phone.GetNumber()).RecentRecords(10))
                    {
                        CreateHistoryEntry(container, player, record, index, mod, bottomS, topS);
                        index++;
                    }
                    container.Add(new CuiElement
                    {
                        Name = "phonesHistoryBodyButton",
                        Parent = "phonesHistoryBody",
                        Components =
                    {
                        new CuiButtonComponent
                        {
                            Command = "phone.clear history " + phone.GetNumber(),
                            Color = COLOR_PP_WARN.RGBA()
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.38 0.05",
                            AnchorMax = "0.62 0.11"
                        }
                    }
                    });
                    container.Add(new CuiElement
                    {
                        Name = "phonesHistoryBodyButtonText",
                        Parent = "phonesHistoryBodyButton",
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = lang.GetMessage("UI title clear", this, player.UserIDString),
                                FontSize = 10,
                                Color = "1 1 1 1",
                                Align = TextAnchor.MiddleCenter
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1"
                            }
                        }
                    });
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Name = "phonesHistoryBodyText",
                        Parent = "phonesHistoryBody",
                        Components =
                {
                    new CuiTextComponent {
                        Text = lang.GetMessage("No history", this, player.UserIDString),
                        Color = "1 1 1 0.5",
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                },
                    });
                }
            }

            return container;
        }

        void CreateHistoryEntry(CuiElementContainer container, BasePlayer player, PhoneRecord record, int index, double mod, double bottomS, double topS)
        {
            float opacity = 0.9f;
            if (!record.unread)
                opacity = 0.3f;
            string bodyColor = COLOR_PP_ENTRY_BODY.RGBA(opacity);
            string titleColor = COLOR_PP_ENTRY_TITLE_FONT.RGBA(opacity);

            container.Add(new CuiElement
            {
                Name = "phonesHistoryEntry" + index,
                Parent = "phonesHistoryBody",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = bodyColor,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.05 " + (bottomS - (index * mod)),
                        AnchorMax = "0.95 " + (topS - (index * mod)),
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesHistoryEntryText" + index,
                Parent = "phonesHistoryEntry" + index,
                Components =
                {
                    new CuiTextComponent
                    {
                        Color = titleColor,
                        Text = string.Format(lang.GetMessage("History " + record.status, this, player.UserIDString), record.ID(phoneManager)),
                        Align = TextAnchor.MiddleLeft,
                        FontSize = 10
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.05 0",
                        AnchorMax = "0.65 1",
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesHistoryEntryTime" + index,
                Parent = "phonesHistoryEntry" + index,
                Components =
                {
                    new CuiTextComponent
                    {
                        Color = titleColor,
                        Text = ElapsedTimeString(player, record.GetTimeElapsed()),
                        Align = TextAnchor.MiddleRight,
                        FontSize = 10
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.70 0",
                        AnchorMax = "0.95 1",
                    }
                }
            });
        }

        CuiElementContainer CreateTrackButton(BasePlayer player, RegisteredPhone phone)
        {
            CuiElementContainer container = new CuiElementContainer();
            string buttonCmd = "phone.track " + phone.GetNumber();
            string buttonColor = COLOR_PP_SUBMIT.RGBA();
            string buttonText = lang.GetMessage("UI title track", this, player.UserIDString);
            if (phoneManager.IsTrackedBy(phone, player.userID))
            {
                buttonCmd = "phone.untrack " + phone.GetNumber();
                buttonColor = COLOR_PP_WARN.RGBA();
                buttonText = lang.GetMessage("UI title untrack", this, player.UserIDString);
            }
            container.Add(new CuiElement
            {
                Name = "phonesTrackButton",
                Parent = "Overlay",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = buttonCmd,
                        Color = buttonColor,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.425 0.03",
                        AnchorMax = "0.575 0.09"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesTrackButtonText",
                Parent = "phonesTrackButton",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = buttonText,
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            return container;
        }

        #endregion

        #region Messages Panel
        CuiElementContainer CreateMessagesPanel(BasePlayer player, RegisteredPhone phone, bool centered = false)
        {
            CuiElementContainer container = new CuiElementContainer();
            float aMin1 = 0.098f;
            float aMin2 = 0.1275f;
            float aMax1 = 0.313f;
            float aMax2 = 0.76f;
            float opacity = 0.9f;
            if (centered)
            {
                float modX = 0.3f;
                aMin1 += modX;
                aMax1 += modX;
                opacity = 0.99f;
            }

            if (player.IsValid() && phone != null)
            {
                container.Add(new CuiPanel
                {
                    CursorEnabled = centered,
                    Image =
                    {
                        Color = "0 0 0 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = aMin1.ToString() + " " + aMin2.ToString(),
                        AnchorMax = aMax1.ToString() + " " + aMax2.ToString(),
                    }
                }, "Overlay", "phonesMessages");
                container.Add(new CuiPanel
                {
                    Image =
                {
                    Color = COLOR_RUST_BODY.RGBA(opacity)
                },
                    RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 0.92"
                }
                }, "phonesMessages", "phonesMessagesBody");
                container.Add(new CuiPanel
                {
                    Image =
                {
                    Color = COLOR_RUST_HEADER.RGBA(opacity)
                },
                    RectTransform =
                {
                    AnchorMin = "0 0.92",
                    AnchorMax = "1 1"
                }
                }, "phonesMessages", "phonesMessagesHeader");
                container.Add(new CuiLabel
                {
                    Text =
                {
                    Text = lang.GetMessage("UI title messages", this, player.UserIDString),
                    FontSize = 14,
                    Align = TextAnchor.MiddleCenter
                },
                    RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                }
                }, "phonesMessagesHeader", "phonesMessagesHeaderText");
                container.Add(new CuiElement
                {
                    Name = "phonesMessagesHeaderImage",
                    Parent = "phonesMessagesHeader",
                    Components =
                {
                    new CuiRawImageComponent {
                        Png = ImageLibrary.Call<string>("GetImage", "MessageIcon"),
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.04 0.3",
                        AnchorMax = "0.10 0.7"
                    }
                },
                });


                List<PhoneMessage> messages = phoneManager.GetPhoneMessages(phone.GetNumber()).RecentMessages(6);
                if (messages.Count > 0)
                {
                    int index = 0;
                    double bottomS = 0.85;
                    double topS = 0.97;
                    double mod = 0.13;
                    foreach (PhoneMessage message in messages)
                    {
                        CreateMessageEntry(container, player, message, index, mod, bottomS, topS);
                        index++;
                    }
                    container.Add(new CuiElement
                    {
                        Name = "phonesMessagesBodyButton",
                        Parent = "phonesMessagesBody",
                        Components =
                    {
                        new CuiButtonComponent
                        {
                            Command = "phone.clear messages " + phone.GetNumber(),
                            Color = COLOR_PP_WARN.RGBA()
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.38 0.05",
                            AnchorMax = "0.62 0.11"
                        }
                    }
                    });
                    container.Add(new CuiElement
                    {
                        Name = "phonesMessagesBodyButtonText",
                        Parent = "phonesMessagesBodyButton",
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = lang.GetMessage("UI title clear", this, player.UserIDString),
                                FontSize = 10,
                                Color = "1 1 1 1",
                                Align = TextAnchor.MiddleCenter
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1"
                            }
                        }
                    });
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Name = "phonesMessagesBodyText",
                        Parent = "phonesMessagesBody",
                        Components =
                {
                    new CuiTextComponent {
                        Text = lang.GetMessage("No messages", this, player.UserIDString),
                        Color = "1 1 1 0.5",
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                },
                    });
                }
            }

            return container;
        }

        void CreateMessageEntry(CuiElementContainer container, BasePlayer player, PhoneMessage message, int index, double mod, double bottomS, double topS)
        {
            float opacity = 0.9f;
            if (!message.unread)
                opacity = 0.3f;
            string headerColor = COLOR_PP_ENTRY_HEADER.RGBA(opacity);
            string bodyColor = COLOR_PP_ENTRY_BODY.RGBA(opacity);
            string titleColor = COLOR_PP_ENTRY_TITLE_FONT.RGBA(opacity);
            string textColor = COLOR_PP_ENTRY_BODY_FONT.RGBA(opacity);

            container.Add(new CuiElement
            {
                Name = "phonesMessagesEntry" + index,
                Parent = "phonesMessagesBody",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0.5"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.05 " + (bottomS - (index * mod)),
                        AnchorMax = "0.95 " + (topS - (index * mod)),
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesMessagesEntryHeader" + index,
                Parent = "phonesMessagesEntry" + index,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = headerColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5",
                        AnchorMax = "1 1"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesMessagesEntryBody" + index,
                Parent = "phonesMessagesEntry" + index,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = bodyColor,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.49"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesMessagesEntryHeaderName" + index,
                Parent = "phonesMessagesEntryHeader" + index,
                Components =
                {
                    new CuiTextComponent
                    {
                        Color = titleColor,
                        Text = message.SenderID(phoneManager),
                        FontSize = 10,
                        Align = TextAnchor.MiddleLeft
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.03 0",
                        AnchorMax = "0.50 1"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesMessagesEntryHeaderTime" + index,
                Parent = "phonesMessagesEntryHeader" + index,
                Components =
                {
                    new CuiTextComponent
                    {
                        Color = titleColor,
                        Text = ElapsedTimeString(player, message.GetTimeElapsed()),
                        FontSize = 10,
                        Align = TextAnchor.MiddleRight
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0",
                        AnchorMax = "0.97 1"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesMessagesEntryBodyText" + index,
                Parent = "phonesMessagesEntryBody" + index,
                Components =
                {
                    new CuiTextComponent
                    {
                        Color = textColor,
                        Text = message.text,
                        FontSize = 10,
                        Align = TextAnchor.MiddleLeft
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.05 0",
                        AnchorMax = "0.95 1"
                    }
                }
            });
        }

        #endregion

        #region Input Panel
        CuiElementContainer CreateInputPanel(BasePlayer player, int callerNumber, int receiverNumber)
        {
            string panelColor = "0.36 0.34 0.3 0.99";
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0.9"
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                }
            }, "Overlay", "phonesInputOverlay");
            container.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0"
                },
                RectTransform =
                {
                    AnchorMin = "0.35 0.45",
                    AnchorMax = "0.65 0.6"
                }
            }, "phonesInputOverlay", "phonesInput");
            container.Add(new CuiPanel
            {
                Image =
                {
                    Color = panelColor
                },
                RectTransform =
                {
                    AnchorMin = "0 0.7",
                    AnchorMax = "1 1"
                }
            }, "phonesInput", "phonesInputHeader");
            container.Add(new CuiPanel
            {
                Image =
                {
                    Color = panelColor
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 0.69"
                }
            }, "phonesInput", "phonesInputBody");
            container.Add(new CuiLabel
            {
                Text =
                {
                    Text = lang.GetMessage("UI title prompt", this, player.UserIDString),
                    Color = "1 1 1 0.9",
                    FontSize = 14,
                    Align = TextAnchor.MiddleLeft
                },
                RectTransform =
                {
                    AnchorMin = "0.05 0",
                    AnchorMax = "0.95 1"
                }
            }, "phonesInputHeader", "phonesInputHeaderText");
            container.Add(new CuiButton
            {
                Text =
                {
                    Text = ""
                },
                Button =
                {
                    Command = "phone.message " + callerNumber + " " + receiverNumber + " ",
                    Color = "0 0 0 0"
                },
                RectTransform =
                {
                    AnchorMin = "0.92 0.25",
                    AnchorMax = "0.97 0.75"
                }
            }, "phonesInputHeader", "phonesInputHeaderButton");
            container.Add(new CuiElement
            {
                Name = "phonesInputHeaderButtonImage",
                Parent = "phonesInputHeaderButton",
                Components =
                {
                    new CuiRawImageComponent {
                        Png = ImageLibrary.Call<string>("GetImage", "CloseIcon"),
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.1 0.1",
                        AnchorMax = "0.9 0.9"
                    }
                },
            });
            container.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0.5"
                },
                RectTransform =
                {
                    AnchorMin = "0.025 0.18",
                    AnchorMax = "0.975 0.82"
                }
            }, "phonesInputBody", "phonesInputBodyField");
            container.Add(new CuiElement
            {
                Name = "phonesInputBodyFieldInput",
                Parent = "phonesInputBodyField",
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        CharsLimit = 40,
                        Command = "phone.message " + callerNumber + " " + receiverNumber,
                        Color = "1 1 1 1",
                        Align = TextAnchor.MiddleLeft,
                        FontSize = 14
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.02 0",
                        AnchorMax = "0.98 1"
                    }
                },
            });
            return container;
        }
        #endregion

        #region Notification Panel
        CuiElementContainer CreateNotificationPanel(BasePlayer player, string message, RegisteredPhone phone)
        {
            CuiElementContainer container = new CuiElementContainer();
            string bodyOpacity = " 0.9";
            string titleOpacity = " 0.95";
            container.Add(new CuiElement
            {
                Name = "phonesNotify",
                Parent = "Hud",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = config.HudNotification.AnchorMin,
                        AnchorMax = config.HudNotification.AnchorMax
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesNotifyHeader",
                Parent = "phonesNotify",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = config.HudNotification.BackgroundColor + titleOpacity
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.82",
                        AnchorMax = "1 1"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesNotifyHeaderText",
                Parent = "phonesNotifyHeader",
                Components =
                {
                    new CuiTextComponent
                    {
                        FontSize = 9,
                        Color = "1 1 1 1",
                        Text = phone.GetIdentity(),
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesNotifyBody",
                Parent = "phonesNotify",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = config.HudNotification.BackgroundColor + bodyOpacity
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.25",
                        AnchorMax = "1 0.80"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesNotifyBodyImage",
                Parent = "phonesNotifyBody",
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = ImageLibrary.Call<string>("GetImage", "CallIcon"),
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01 0.08",
                        AnchorMax = "0.13 0.9"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesNotifyBodyText",
                Parent = "phonesNotifyBody",
                Components =
                {
                    new CuiTextComponent
                    {
                        FontSize = 12,
                        Color = "1 1 1 1",
                        Text = message,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.14 0.08",
                        AnchorMax = "0.86 0.9"
                    }
                }
            });
            return container;
        }
        #endregion

        #region Indicators
        CuiElementContainer CreateUnreadIndicator(BasePlayer player, int messages)
        {
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "phonesUnread",
                Parent = "Hud",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = config.HudMessageIndicator.AnchorMin,
                        AnchorMax = config.HudMessageIndicator.AnchorMax
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesUnreadImage",
                Parent = "phonesUnread",
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = ImageLibrary.Call<string>("GetImage", "MessageIcon"),
                        Color = config.HudMessageIndicator.ImageColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.35",
                        AnchorMax = "1 1"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesUnreadText",
                Parent = "phonesUnread",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = messages.ToString(),
                        Color = "1 1 1 1",
                        Align = TextAnchor.LowerRight
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1",
                        AnchorMax = "1 1"
                    }
                }
            });
            return container;
        }

        CuiElementContainer CreateCallIndicator(BasePlayer player, int calls)
        {
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "phonesCalls",
                Parent = "Hud",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = config.HudCallIndicator.AnchorMin,
                        AnchorMax = config.HudCallIndicator.AnchorMax
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesCallsImage",
                Parent = "phonesCalls",
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = ImageLibrary.Call<string>("GetImage", "CallIcon"),
                        Color = config.HudCallIndicator.ImageColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.35",
                        AnchorMax = "1 1"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = "phonesCallsText",
                Parent = "phonesCalls",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = calls.ToString(),
                        Color = "1 1 1 1",
                        Align = TextAnchor.LowerRight
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1",
                        AnchorMax = "1 1"
                    }
                }
            });
            return container;
        }
        #endregion

        #region Functions
        void ShowPhoneUI(BasePlayer player, RegisteredPhone phone)
        {
            HideAllUI(player);
            if (permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                permission.GrantUserPermission(player.UserIDString, PermissionTemp, this);
                CuiElementContainer container1 = CreateHistoryPanel(player, phone);
                CuiHelper.AddUi(player, container1);
                CuiElementContainer container2 = CreateMessagesPanel(player, phone);
                CuiHelper.AddUi(player, container2);
                CuiElementContainer container3 = CreateTrackButton(player, phone);
                CuiHelper.AddUi(player, container3);
            }
        }

        void ShowMessagesUI(BasePlayer player, RegisteredPhone phone)
        {
            HideAllUI(player);
            if (permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                CuiElementContainer container = CreateMessagesPanel(player, phone, true);
                CuiHelper.AddUi(player, container);
            }
        }

        void ShowNotificationHUD(BasePlayer player, string message, RegisteredPhone phone)
        {
            CuiHelper.DestroyUi(player, "phonesNotify");
            if (permission.UserHasPermission(player.UserIDString, PermissionUse) && phoneManager.GetPreference<bool>(player.userID, "notifications"))
            {
                CuiElementContainer container = CreateNotificationPanel(player, message, phone);
                CuiHelper.AddUi(player, container);
                timer.Once(12f, () =>
                {
                    CuiHelper.DestroyUi(player, "phonesNotify");
                });
            }
        }

        void HideNotificationHUD(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "phonesNotify");
        }

        void ShowInputUI(BasePlayer player, int senderNumber, int receiverNumber)
        {
            CuiHelper.DestroyUi(player, "phonesInputOverlay");
            if (permission.UserHasPermission(player.UserIDString, PermissionUse) && !phoneManager.ExceededMessageLimit(player.userID))
            {
                CuiElementContainer container2 = CreateInputPanel(player, senderNumber, receiverNumber);
                CuiHelper.AddUi(player, container2);
            }
        }

        void ShowUnreadIndicator(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "phonesUnread");
            if (permission.UserHasPermission(player.UserIDString, PermissionUse) && phoneManager.GetPreference<bool>(player.userID, "indicators"))
            {
                int count = phoneManager.GetPhoneMessageCount(player.userID);
                if (count > 0)
                {
                    CuiElementContainer container = CreateUnreadIndicator(player, count);
                    CuiHelper.AddUi(player, container);
                }
            }
        }

        void ShowCallIndicator(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "phonesCalls");
            if (permission.UserHasPermission(player.UserIDString, PermissionUse) && phoneManager.GetPreference<bool>(player.userID, "indicators"))
            {
                int count = phoneManager.GetPhoneRecordsCount(player.userID);
                if (count > 0)
                {
                    CuiElementContainer container = CreateCallIndicator(player, count);
                    CuiHelper.AddUi(player, container);
                }
            }
        }

        void HideAllUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "phonesTrackButton");
            CuiHelper.DestroyUi(player, "phonesInputOverlay");
            CuiHelper.DestroyUi(player, "phonesHistory");
            CuiHelper.DestroyUi(player, "phonesMessages");
            permission.RevokeUserPermission(player.UserIDString, PermissionTemp);
        }
        #endregion

        #region Constants
        private readonly ColorUI COLOR_RUST_BODY = new ColorUI(0.15f, 0.14f, 0.11f, 0.9f);
        private readonly ColorUI COLOR_RUST_HEADER = new ColorUI(0.36f, 0.34f, 0.3f, 0.9f);
        private readonly ColorUI COLOR_PP_UI = new ColorUI(0.8f, 0.5f, 0.5f, 0.9f);
        private readonly ColorUI COLOR_PP_WARN = new ColorUI(0.7f, 0.22f, 0.15f, 1f);
        private readonly ColorUI COLOR_PP_SUBMIT = new ColorUI(0.45f, 0.55f, 0.27f, 1f);
        private readonly ColorUI COLOR_PP_ENTRY_BODY = new ColorUI(0.05f, 0.05f, 0.05f, 0.9f);
        private readonly ColorUI COLOR_PP_ENTRY_HEADER = new ColorUI(0.1f, 0.1f, 0.1f, 0.9f);
        private readonly ColorUI COLOR_PP_ENTRY_TITLE_FONT = new ColorUI(0.8f, 0.8f, 0.8f, 1f);
        private readonly ColorUI COLOR_PP_ENTRY_BODY_FONT = new ColorUI(1f, 1f, 1f, 1f);

        class ColorUI
        {
            public float r;
            public float g;
            public float b;
            public float a;

            public ColorUI(float r, float g, float b, float a = 1f)
            {
                this.r = r;
                this.g = g;
                this.b = b;
                this.a = a;
            }

            public string RGBA()
            {
                return RGBA(a);
            }

            public string RGBA(float a)
            {
                return string.Format("{0} {1} {2} {3}", r, g, b, a);
            }
        }
        #endregion

        #endregion
    }

}


// --- End of file: PhonesPlus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/private-crops ---
// --- Original File Path: P/PrivateCrops/PrivateCrops.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

/*
 * This update 1.1.5
 * Updated old methods
 * Added new oxide hook
 *
 * This update 1.2.0
 * Added Clans, Rustio Clans, Friends and team support.
 * Added Plant death prevention option
 * Added More Config Options
 * Added 2 new hooks OnGrowableStateChange, OnEntityBuilt
 */

namespace Oxide.Plugins
{
	[Info("Private Crops", "Khan", "1.2.0")]
	[Description("Protects player's crops from being stolen!")]
	class PrivateCrops : CovalencePlugin
	{
		#region Refrences

		[PluginReference]
		private Plugin Clans, Friends;

		#endregion
		
		#region Variables
		
		private PluginConfig _config;
		
		private const string messagebypass = "privatecrops.message.bypass";
		private const string protectionbypass = "privatecrops.protection.bypass";
		private const string instant = "privatecrops.speed";

		#endregion

		#region Config
		
		private void Init()
		{
			permission.RegisterPermission(messagebypass, this);
			permission.RegisterPermission(protectionbypass, this);
			permission.RegisterPermission(instant, this);
		}

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["message"] = "<color={0}>This crop is not yours! Do not steal from other players!</color>",
			}, this);
		}
		private class PluginConfig
		{
			[JsonProperty("Use Tool Cupboard Protection")]
			public bool EnableTC = true;
			
			[JsonProperty("Set Max Seasons the plant regrows")]
			public int MaxSeasons = 1;
			
			[JsonProperty("Set Max Harvests")]
			public int MaxHarvests = 1;
			
			[JsonProperty("Prevent Plants from dying")]
			public bool Dying = false;

			[JsonProperty("Warning Message Color")]
			public string MessageColor = "#ff0000";
			
			[JsonProperty("Use Clan Protection")]
			public bool EnableClans = false;
			
			[JsonProperty("Use Teams Protection")]
			public bool EnableTeams = false;
			
			[JsonProperty("Use Friends only Protection")]
			public bool EnableFriends = false;

			public string ToJson() => JsonConvert.SerializeObject(this);

			public Dictionary<string, object> ToDictionary() =>
				JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();

			try
			{
				_config = Config.ReadObject<PluginConfig>();

				if (_config == null)
				{
					throw new JsonException();
				}

				if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
				{
					PrintWarning($"Configuration file {Name}.json was Updated");
					SaveConfig();
				}
			}
			catch
			{
				PrintError("Configuration file is corrupt! Loading Default Config");
				LoadDefaultConfig();
			}
		}
		protected override void SaveConfig() => Config.WriteObject(_config, true);
		protected override void LoadDefaultConfig() => _config = new PluginConfig();
		
		#endregion

		#region Hooks
		
		private void OnEntityBuilt(Planner planner, GameObject seed)
		{
			var player = planner.GetOwnerPlayer();
			var plant = seed.GetComponent<GrowableEntity>();

			NextTick(() =>
			{
				if (plant == null || plant.planter == null) return;
				if (player != null && permission.UserHasPermission(player.UserIDString, instant))
				{
					plant.ChangeState(PlantProperties.State.Fruiting, false);
				}
				if (_config.MaxSeasons != 1)
				{
					plant.Properties.MaxSeasons = _config.MaxSeasons;
				}
				if (_config.MaxHarvests != 1)
				{
					plant.Properties.maxHarvests = _config.MaxHarvests;
				}
			});

		}
		
		private object CanTakeCutting(BasePlayer player, GrowableEntity growable)
		{
			if (player == null || growable == null) return null;
			return CropsProtected(player, growable);
		}

		private object OnGrowableGather(GrowableEntity growable, BasePlayer player)
		{
			if (player == null || growable == null) return null;
			return CropsProtected(player, growable);
		}

		private object OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player)
		{
			if (player == null || growable == null || item == null) return null;
			return CropsProtected(player, growable);
		}

		private bool? OnGrowableStateChange(GrowableEntity growableEntity, PlantProperties.State state)
		{
			if (growableEntity == null) return null;
			if (_config.Dying && growableEntity.currentStage.nextState == PlantProperties.State.Dying)
			{
				return true;
			}
			return null;
		}

		#endregion

		#region Helpers
		private object CropsProtected(BasePlayer player, GrowableEntity growable)
		{
			if (player.IPlayer.HasPermission(protectionbypass))
			{
				return null;
			}

			if (_config.EnableTC)
			{
				if (player.IsBuildingBlocked())
				{
					WarnPlayer(player);
					return true;
				}
			}
			else if (!IsOwner(player.userID, growable.OwnerID))
			{
				WarnPlayer(player);
				return true;
			}

			return null;
		}
		public void WarnPlayer(BasePlayer player)
		{
			if (player.IPlayer.HasPermission(messagebypass) == false)
			{
				player.IPlayer.Message(string.Format(lang.GetMessage("message", this, player.IPlayer.Id), Config["MessageColor"]));
			}
		}
		private bool IsOwner(ulong userID, ulong owner)
        {
            if (userID == owner)
            {
                return true;
            }
            
            if (_config.EnableClans && SameClan(userID, owner))
            {
	            return true;
            }
            
            if (_config.EnableTeams && SameTeam(userID, owner))
            {
                return true;
            }

            if (_config.EnableFriends && AreFriends(userID, owner))
            {
                return true;
            }

            return false;
        }
        private bool SameTeam(ulong playerID, ulong friendID)
        {
            if (!RelationshipManager.TeamsEnabled()) return false;
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerID);
            if (playerTeam == null) return false;
            var friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendID);
            if (friendTeam == null) return false;
            return playerTeam == friendTeam;
        }
        private bool AreFriends(ulong playerID, ulong friendID)
        {
            if (Friends == null) return false;

            return (bool)Friends.Call("AreFriends", playerID, friendID);
        }
        private bool SameClan(ulong playerID, ulong friendID)
        {
            if (Clans == null) return false;
            //Clans
            var isMember = Clans.Call("IsClanMember", playerID.ToString(), friendID.ToString());
            if (isMember != null) return (bool)isMember;
            //Rust:IO Clans
            var playerClan = Clans.Call("GetClanOf", playerID);
            if (playerClan == null) return false;
            var friendClan = Clans.Call("GetClanOf", friendID);
            if (friendClan == null) return false;
            return (string)playerClan == (string)friendClan;
        }

        #endregion Helpers

	}
}


// --- End of file: PrivateCrops.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/punish ---
// --- Original File Path: P/Punish/Punish.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Punish", "Wulf", "1.1.1")]
    [Description("Punish players for various actions/events")]
    public class Punish : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Punishment
        {
            [JsonProperty("Enable punishment")]
            public bool Enable = true;

            [JsonProperty("Ban as punishment")]
            public bool Ban = false;

            /*[JsonProperty("Freeze as punishment")] // TODO: Finish implementing
            public bool Freeze = false;

            [JsonProperty("Amount of time to freeze")] // TODO: Finish implementing
            public bool FreezeTime = false;*/

            [JsonProperty("Hurt as punishment")]
            public float Hurt = 0f;

            [JsonProperty("Kick as punishment")]
            public bool Kick = false;

#if RUST
            [JsonProperty("Jail as punishment")]
            public bool Jail = false;

            [JsonProperty("Name of jail/prison to use")]
            public string JailName = "";

            [JsonProperty("Amount of time to jail")]
            public int JailTime = 10;
#endif

            /*[JsonProperty("Mute as punishment")] // TODO: Finish implementing
            public bool Mute = false;

            [JsonProperty("Amount of time to mute")] // TODO: Finish implementing
            public bool MuteTime = false;*/

            [JsonProperty("Slap as punishment")]
            public bool Slap = false;

            [JsonProperty("Amount of damage per slap")]
            public int SlapDamage = 10;

            [JsonProperty("Intensity of each slap")]
            public int SlapIntensity = 5;

            [JsonProperty("Number of times to slap")]
            public int SlapAmount = 1;

            [JsonProperty("Economics withdrawl")]
            public bool Economics = false;

            [JsonProperty("Economics amount")]
            public int EconomicsAmount = 1000;

            [JsonProperty("Server Rewards withdrawl")]
            public bool ServerRewards = false;

            [JsonProperty("Server Rewards amount")]
            public int ServerRewardsAmount = 100;
        }

        public class Configuration
        {
            [JsonProperty("Punish for dying")]
            public Punishment PunishmentDeath = new Punishment();

            //[JsonProperty("Punish for damaging other players")]
            //public Punishment PunishmentPvPDamage = new Punishment(); // TODO: Finish implementing

            [JsonProperty("Punish for killing other players")]
            public Punishment PunishmentPvPDeath = new Punishment();

            [JsonProperty("Include actions from NPCs")]
            public bool IncludeNPCs = true;

            [JsonProperty("Use permission system")]
            public bool UsePermissions = false;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PunishmentBan"] = "You were banned for {0}",
                ["PunishmentHurt"] = "You were hurt for {0}",
                ["PunishmentKick"] = "You were kicked for {0}",
                ["PunishmentJail"] = "You were jailed for {0}",
                ["PunishmentSlap"] = "You were slapped for {0}",
                ["PunishmentEconomics"] = "You lost {0:C} for {1}",
                ["PunishmentServerRewards"] = "You lost {0} RP for {1}",
                ["ReasonDeath"] = "dying",
                //["ReasonPvPDamage"] = "damaging a player",
                ["ReasonPvPDeath"] = "killing a player"
            }, this);
        }

        #endregion Localization

        #region Initialization

        [PluginReference]
        private Plugin Economics, ServerRewards, Jail, Slap;

        private const string permExclude = "punish.exclude";

        private void Init()
        {
            permission.RegisterPermission(permExclude, this);
        }

        #endregion Initialization

        #region Punishment

        private void PunishPlayer(Punishment punishment, IPlayer player, string reason)
        {
            if (config.UsePermissions && player.HasPermission(permExclude))
            {
                return;
            }

            if (punishment.Economics && Economics != null && Economics.IsLoaded)
            {
                if (Economics.Call<bool>("Withdraw", player.Id, (double)(punishment.EconomicsAmount > 0 ? -punishment.EconomicsAmount : punishment.EconomicsAmount)))
                {
                    Message(player, "PunishmentEconomics", punishment.EconomicsAmount, reason);
                }
            }

            if (punishment.ServerRewards && ServerRewards != null && ServerRewards.IsLoaded)
            {
                if (ServerRewards.Call<bool>("TakePoints", player.Id, punishment.ServerRewardsAmount > 0 ? -punishment.ServerRewardsAmount : punishment.ServerRewardsAmount))
                {
                    Message(player, "PunishmentServerRewards", punishment.ServerRewardsAmount, reason);
                }
            }

#if RUST

            if (punishment.Jail && !string.IsNullOrEmpty(punishment.JailName) && Jail != null && Jail.IsLoaded)
            {
                Jail.Call("SendToPrison", player.Object as BasePlayer, punishment.JailName, (double)punishment.JailTime);
                Message(player, "PunishmentJail", reason);
            }

#endif

            if (punishment.Slap && Slap != null && Slap.IsLoaded)
            {
                Slap.Call("SlapPlayer", player.Id, punishment.SlapDamage, punishment.SlapIntensity, punishment.SlapAmount);
                Message(player, "PunishmentSlap", reason);
            }

            if (punishment.Hurt > 0)
            {
                player.Hurt(punishment.Hurt);
                Message(player, "PunishmentHurt", reason);
            }

            if (punishment.Ban)
            {
                player.Ban(GetLang("PunishmentBan", player.Id, reason));
            }

            if (punishment.Kick)
            {
                player.Kick(GetLang("PunishmentKick", player.Id, reason));
            }
        }

        #endregion Punishment

        #region Actions/Events

#if HURTWORLD

        private void OnPlayerDeath(PlayerSession session, EntityEffectSourceData sourceData)
        {
            if (sourceData.EntitySource != null)
            {
                EntityReferenceCache referenceCache = RefTrackedBehavior<EntityReferenceCache>.GetByTransform(sourceData.EntitySource.transform);
                if (referenceCache?.Stats != null)
                {
                    PlayerSession attacker = GameManager.Instance.GetSession(referenceCache.Stats.networkView.owner);
                    PunishPlayer(config.PunishmentPvPDeath, attacker.IPlayer, GetLang("ReasonPvPDeath", attacker.IPlayer.Id));
                }
            }

            PunishPlayer(config.PunishmentDeath, session.IPlayer, GetLang("ReasonDeath", session.IPlayer.Id));
        }

#elif REIGNOFKINGS

        private void OnEntityDeath(CodeHatch.Networking.Events.Entities.EntityDeathEvent evt)
        {
            if (evt.Sender != null)
            {
                PunishPlayer(config.PunishmentPvPDeath, evt.Sender.IPlayer, GetLang("ReasonPvPDeath", evt.Sender.IPlayer.Id));
            }

            PunishPlayer(config.PunishmentDeath, evt.Entity.Owner.IPlayer, GetLang("ReasonDeath", evt.Entity.Owner.IPlayer.Id));
        }

#elif RUST

        private void OnPlayerDeath(BasePlayer basePlayer, HitInfo hitInfo)
        {
            if (basePlayer.IsNpc || (!config.IncludeNPCs && hitInfo.InitiatorPlayer.IsValid() && hitInfo.InitiatorPlayer.IsNpc))
            {
                return;
            }

            if (hitInfo.InitiatorPlayer != null && !hitInfo.InitiatorPlayer.IsNpc)
            {
                BasePlayer attacker = hitInfo.InitiatorPlayer;
                PunishPlayer(config.PunishmentPvPDeath, attacker.IPlayer, GetLang("ReasonPvPDeath", attacker.IPlayer.Id));
            }

            PunishPlayer(config.PunishmentDeath, basePlayer.IPlayer, GetLang("ReasonDeath", basePlayer.IPlayer.Id));
        }

#elif SEVENDAYSTODIE

        private void OnEntityDeath(EntityAlive entity)
        {
            ClientInfo clientInfo = ConnectionManager.Instance.Clients.ForEntityId(entity.entityId);
            if (clientInfo != null)
            {
                if (entity.entityThatKilledMe != null)
                {
                    ClientInfo attackerInfo = ConnectionManager.Instance.Clients.ForEntityId(entity.entityThatKilledMe.entityId);
                    if (attackerInfo != null)
                    {
                        PunishPlayer(config.PunishmentPvPDeath, attackerInfo.IPlayer, GetLang("ReasonPvPDeath", attackerInfo.IPlayer.Id));
                    }
                }

                PunishPlayer(config.PunishmentDeath, clientInfo.IPlayer, GetLang("ReasonDeath", clientInfo.IPlayer.Id));
            }
        }

#endif

        #endregion Actions/Events

        #region Helpers

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: Punish.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/power-spawn ---
// --- Original File Path: P/PowerSpawn/PowerSpawn.cs ---

#if DEBUG
using System.Diagnostics;
using Debug = UnityEngine.Debug;
#endif

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust;
using UnityEngine;
using Random = System.Random;

namespace Oxide.Plugins;

[Info("Power Spawn", "misticos", "1.4.0")]
[Description("Powerful position generation tool with API")]
internal class PowerSpawn : CovalencePlugin
{
    #region Variables

    private static PowerSpawn _ins;

    private readonly Random _random = new();

    private int _halfWorldSize;

    private const string PermissionLocation = "powerspawn.location";

    #endregion

    #region Configuration

    private Configuration _config;

    private class Configuration
    {
        [JsonProperty("Profiles", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, Profile> Profiles { get; set; } = new()
        {
            { string.Empty, new Profile() },
            {
                "No Winter", new Profile
                {
                    BiomesBlocked = new List<TerrainBiome.Enum>
                    {
                        TerrainBiome.Enum.Arctic
                    },
                    SplatBlocked = new List<TerrainSplat.Enum>
                    {
                        TerrainSplat.Enum.Snow
                    }
                }
            },
            {
                "Beach Only", new Profile
                {
                    SplatBlocked = new List<TerrainSplat.Enum>
                    {
                        TerrainSplat.Enum.Snow
                    },
                    TopologiesAllowed = new List<TerrainTopology.Enum>
                    {
                        TerrainTopology.Enum.Beach, TerrainTopology.Enum.Beachside
                    }
                }
            },
            {
                "Snowy Forest", new Profile
                {
                    SplatThresholdMinimum = new Dictionary<TerrainSplat.Enum, float>
                    {
                        { TerrainSplat.Enum.Snow, 0.8f }
                    },
                    TopologiesAllowed = new List<TerrainTopology.Enum>
                    {
                        TerrainTopology.Enum.Forest, TerrainTopology.Enum.Forestside
                    }
                }
            }
        };

        [JsonProperty("Respawn Configurations", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<RespawnConfiguration> RespawnConfigurations { get; set; } = new()
        {
            new RespawnConfiguration()
        };

        [JsonProperty("Respawn Profile", NullValueHandling = NullValueHandling.Ignore)]
        public string RespawnProfileName { get; set; } = null;

        [JsonProperty("Respawn Locations Group", NullValueHandling = NullValueHandling.Ignore)]
        public int? RespawnGroup { get; set; } = null;

        [JsonProperty("Enable Respawn Locations Group", NullValueHandling = NullValueHandling.Ignore)]
        public bool? EnableRespawnGroup { get; set; } = null;

        [JsonProperty("Enable Respawn Management")]
        public bool EnableRespawn { get; set; } = true;

        [JsonProperty("Location Management Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] LocationCommand { get; set; } = { "loc", "location", "ps" };

        public class RespawnConfiguration
        {
            [JsonProperty("Permission")]
            public string Permission { get; set; } = string.Empty;

            [JsonProperty("Profile Name")]
            public string ProfileName { get; set; } = string.Empty;

            [JsonProperty("Locations Group")]
            public int? Group { get; set; } = null;

            [JsonIgnore]
            public Profile Profile = null;
        }

        public class Profile
        {
            [JsonProperty("Minimal Distance To Building")]
            public int DistanceBuilding { get; set; } = 16;

            [JsonProperty("Minimal Distance To Collider")]
            public int DistanceCollider { get; set; } = 8;

            [JsonProperty("Raycast Distance Above")]
            public float DistanceRaycast { get; set; } = 50f;

            [JsonProperty("Number Of Attempts To Find A Position Per Frame")]
            public int AttemptsPerFrame { get; set; } = 160;

            [JsonProperty("Number Of Positions Per Frame")]
            public int PositionsPerFrame { get; set; } = 16;

            [JsonProperty("Number Of Attempts To Find A Pregenerated Position")]
            public int AttemptsPregenerated { get; set; } = 400;

            [JsonProperty("Pregenerated Positions Amount")]
            public int PregeneratedAmount { get; set; } = 4000;

            [JsonProperty("Pregenerated Amount Check Frequency (Seconds)")]
            public float PregeneratedCheck { get; set; } = 90f;

            [JsonProperty("Biomes Threshold", NullValueHandling = NullValueHandling.Ignore)]
            public Dictionary<TerrainBiome.Enum, float> BiomesThresholdOld { get; set; } = null;

            [JsonProperty("Biomes Minimum Threshold", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<TerrainBiome.Enum, float> BiomesThresholdMinimum { get; set; } = new();

            [JsonProperty("Biomes Maximum Threshold",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<TerrainBiome.Enum, float> BiomesThresholdMaximum { get; set; } = new();

            [JsonProperty("Biomes Allowed",
                ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
            public List<TerrainBiome.Enum> BiomesAllowed { get; set; } = new();

            [JsonProperty("Biomes Blocked", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
            public List<TerrainBiome.Enum> BiomesBlocked { get; set; } = new();

            [JsonProperty("Splat Minimum Threshold", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<TerrainSplat.Enum, float> SplatThresholdMinimum { get; set; } = new();

            [JsonProperty("Splat Maximum Threshold", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<TerrainSplat.Enum, float> SplatThresholdMaximum { get; set; } = new();

            [JsonProperty("Splat Allowed", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
            public List<TerrainSplat.Enum> SplatAllowed { get; set; } = new();

            [JsonProperty("Splat Blocked", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
            public List<TerrainSplat.Enum> SplatBlocked { get; set; } = new();

            [JsonProperty("Topologies Allowed", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
            public List<TerrainTopology.Enum> TopologiesAllowed { get; set; } = new();

            [JsonProperty("Topologies Blocked", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
            public List<TerrainTopology.Enum> TopologiesBlocked { get; set; } = new();

            [JsonIgnore]
            public Coroutine Coroutine = null;

#if DEBUG
            [JsonIgnore]
            public uint Calls = 0;

            [JsonIgnore]
            public double CallsTook = 0d;

            [JsonIgnore]
            public uint SkippedGenerations = 0;
#endif

            [JsonIgnore]
            public List<Vector3> Positions = new();

            public bool IsValidPosition(Vector3 position)
            {
                return IsValidColliders(position) && IsValidBuilding(position) && IsValidAbove(position) &&
                       IsValidTopology(position) && IsValidBiome(position) && IsValidSplat(position);
            }

            private const int LayerMaskAbove = ~(Layers.Terrain | Layers.Server.Players);

            public bool IsValidAbove(Vector3 position)
            {
                // Casting from above. If done from below, you could be inside a collider which would not be hit
                position += new Vector3(0f, DistanceRaycast + Mathf.Epsilon, 0f);

                return !Physics.Raycast(position, Vector3.down, DistanceRaycast, LayerMaskAbove);
            }

            private const int LayerMaskBuilding = Layers.Construction;

            public bool IsValidBuilding(Vector3 position)
            {
                return !Physics.CheckSphere(position, DistanceBuilding, LayerMaskBuilding);
            }

            // TODO: Separate option for triggers, perhaps per-mask even
            private const int LayerMaskColliders = ~(Layers.Terrain | Layers.Server.Players | Layers.Construction);

            public bool IsValidColliders(Vector3 position)
            {
                return !Physics.CheckSphere(position, DistanceCollider, LayerMaskColliders);
            }

            public bool IsValidTopology(Vector3 position)
            {
                // TODO: Instead of going through all topologies, make two masks and compare with bitwise operators
                if (TopologiesAllowed.Count > 0)
                {
                    foreach (var topology in TopologiesAllowed)
                        if (TerrainMeta.TopologyMap.GetTopology(position, (int)topology))
                            return true;

                    return false;
                }

                if (TopologiesBlocked.Count > 0)
                {
                    foreach (var topology in TopologiesBlocked)
                        if (TerrainMeta.TopologyMap.GetTopology(position, (int)topology))
                            return false;

                    return true;
                }

                return true;
            }

            public bool IsValidBiome(Vector3 position)
            {
                if (BiomesAllowed.Count > 0 || BiomesBlocked.Count > 0)
                {
                    var biomeHighest = (TerrainBiome.Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(position);

                    if (BiomesAllowed.Count > 0 && !BiomesAllowed.Contains(biomeHighest))
                        return false;

                    if (BiomesBlocked.Count > 0 && BiomesBlocked.Contains(biomeHighest))
                        return false;
                }

                if (BiomesThresholdMinimum.Count > 0)
                {
                    foreach (var threshold in BiomesThresholdMinimum)
                        if (TerrainMeta.BiomeMap.GetBiome(position, (int)threshold.Key) < threshold.Value)
                            return false;
                }

                if (BiomesThresholdMaximum.Count > 0)
                {
                    foreach (var threshold in BiomesThresholdMaximum)
                        if (TerrainMeta.BiomeMap.GetBiome(position, (int)threshold.Key) > threshold.Value)
                            return false;
                }

                return true;
            }

            public bool IsValidSplat(Vector3 position)
            {
                if (SplatAllowed.Count > 0 || SplatBlocked.Count > 0)
                {
                    var splatHighest = (TerrainSplat.Enum)TerrainMeta.SplatMap.GetSplatMaxType(position);

                    if (SplatAllowed.Count > 0 && !SplatAllowed.Contains(splatHighest))
                        return false;

                    if (SplatBlocked.Count > 0 && SplatBlocked.Contains(splatHighest))
                        return false;
                }

                if (SplatThresholdMinimum.Count > 0)
                {
                    foreach (var threshold in SplatThresholdMinimum)
                        if (TerrainMeta.SplatMap.GetSplat(position, (int)threshold.Key) < threshold.Value)
                            return false;
                }

                if (SplatThresholdMaximum.Count > 0)
                {
                    foreach (var threshold in SplatThresholdMaximum)
                        if (TerrainMeta.SplatMap.GetSplat(position, (int)threshold.Key) > threshold.Value)
                            return false;
                }

                return true;
            }
        }
    }

    protected override void LoadConfig()
    {
        base.LoadConfig();
        try
        {
            _config = Config.ReadObject<Configuration>();
            if (_config == null) throw new Exception();

            if (_config.EnableRespawnGroup != null)
            {
                var respawnConfiguration =
                    _config.RespawnConfigurations.FirstOrDefault(x => string.IsNullOrEmpty(x.Permission));
                if (respawnConfiguration == null)
                    _config.RespawnConfigurations.Add(respawnConfiguration =
                        new Configuration.RespawnConfiguration());

                respawnConfiguration.ProfileName = _config.RespawnProfileName;
                respawnConfiguration.Group = _config.EnableRespawnGroup.Value ? _config.RespawnGroup : null;

                _config.RespawnProfileName = null;
                _config.EnableRespawnGroup = null;
                _config.RespawnGroup = null;
            }

            foreach (var profile in _config.Profiles.Values)
            {
                if (profile.BiomesThresholdOld != null)
                {
                    profile.BiomesThresholdMinimum = profile.BiomesThresholdOld;
                    profile.BiomesThresholdOld = null;
                }
            }

            SaveConfig();
        }
        catch (Exception e)
        {
            PrintError("Your configuration file contains an error. Using default configuration values.\n" + e);
            LoadDefaultConfig();
        }

        if (_config == null)
            return;

        foreach (var configuration in _config.RespawnConfigurations)
        {
            configuration.Profile = _config.Profiles.GetValueOrDefault(configuration.ProfileName);

            if (configuration.Profile is null)
                throw new Exception(
                    $"Your configuration file contains an error. Profile '{configuration.ProfileName}' does not exist.");
        }
    }

    protected override void LoadDefaultConfig() => _config = new Configuration();

    protected override void SaveConfig() => Config.WriteObject(_config);

    #endregion

    #region Work with Data

    private PluginData _data = new();

    private class PluginData
    {
        public List<Location> Locations = new();

        [JsonIgnore]
        public Dictionary<int, List<Location>> LocationsByGroup = null;

        // ReSharper disable once MemberCanBePrivate.Local
        public int LastID = 0;

        public void AddLocation(Location location)
        {
            Locations.Add(location);

            if (!LocationsByGroup.TryGetValue(location.Group, out var groupLocations))
                LocationsByGroup[location.Group] = groupLocations = new List<Location>();

            groupLocations.Add(location);
        }

        public void RemoveLocation(int index)
        {
            if (Locations.Count <= index)
                return;

            var location = Locations[index];
            var groupId = location.Group;
            if (LocationsByGroup.TryGetValue(groupId, out var groupLocations))
                groupLocations.Remove(location);

            Locations.RemoveAt(index);
        }

        public class Location
        {
            public string Name;
            public int ID = _ins._data.LastID++;
            public int Group = -1;
            public Vector3 Position;

            public string Format(string player)
            {
                var text = new StringBuilder(GetMsg("Location: Format", player));
                text.Replace("{name}", Name);
                text.Replace("{id}", ID.ToString());
                text.Replace("{group}", Group.ToString());
                text.Replace("{position}", Position.ToString());

                return text.ToString();
            }

            public static int? FindIndexById(int id)
            {
                // TODO: this sucks
                for (var i = 0; i < _ins._data.Locations.Count; i++)
                {
                    if (_ins._data.Locations[i].ID == id)
                        return i;
                }

                return null;
            }

            public static IReadOnlyList<Location> FindByGroup(int group)
            {
                // TODO: static sucks
                return _ins._data.LocationsByGroup.TryGetValue(group, out var locations)
                    ? locations
                    : Array.Empty<Location>();
            }
        }
    }

    private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _data);

    private void LoadData()
    {
        try
        {
            _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
        }
        catch (Exception e)
        {
            PrintError(e.ToString());
        }

        _data ??= new PluginData();

        _data.LocationsByGroup = _data.Locations
            .GroupBy(l => l.Group)
            .ToDictionary(g => g.Key, g => g.ToList());
    }

    #endregion

    #region Hooks

    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            { "No Permission", "nope" },
            {
                "Location: Syntax", "Location Syntax:\n" +
                                    "new (Name) - Create a new location with a specified name\n" +
                                    "delete (ID) - Delete a location with the specified ID\n" +
                                    "edit (ID) <Parameter 1> <Value> <...> - Edit a location with the specified ID\n" +
                                    "update - Apply datafile changes\n" +
                                    "list - Get a list of locations\n" +
                                    "validate location (Profile Name) (ID) - Validate preconfigured location\n" +
                                    "validate generated (Profile Name) (ID) - Validate generated position (from draw)\n" +
                                    "validate position (Profile Name) - Validate your current position\n" +
                                    "debug <Profile Name> - Print minor debug information\n" +
                                    "show <Profile Name> <Radius> - Show all positions"
            },
            {
                "Location: Edit Syntax", "Location Edit Parameters:\n" +
                                         "move (x;y;z / here) - Move a location to the specified position\n" +
                                         "group (ID / reset) - Set group of a location or reset the group"
            },
            { "Location: Debug", "Currently available pre-generated positions: {amount}" },
            { "Location: Shown", "Showing generated positions on screen.." },
            { "Location: Unable To Parse Position", "Unable to parse the position" },
            { "Location: Unable To Parse Group", "Unable to parse the entered group" },
            { "Location: Format", "Location ID: {id}; Group: {group}; Position: {position}; Name: {name}" },
            { "Location: Not Found", "Location was not found." },
            { "Location: Generated Not Found", "Generated position was not found." },
            { "Location: Profile Not Found", "Profile was not found." },
            { "Location: Edit Finished", "Edit was finished." },
            { "Location: Removed", "Location was removed from our database." },
            { "Location: Updated", "Datafile changes were applied." },
            {
                "Location: Validation Format",
                "Validation results:\n" +
                "Buildings: {buildings}\n" +
                "Colliders: {colliders}\n" +
                "Raycast above: {raycast}\n" +
                "Biomes: {biome}\n" +
                "Splat: {splat}\n" +
                "Topologies: {topology}"
            },
            { "Location: Player Only", "This is available only to in-game players." }
        }, this);
    }

    private void Init()
    {
        _ins = this;
        LoadData();

        permission.RegisterPermission(PermissionLocation, this);
        AddCovalenceCommand(_config.LocationCommand, nameof(CommandLocation));

        if (!_config.EnableRespawn)
            Unsubscribe(nameof(OnPlayerRespawn));
        else
        {
            foreach (var configuration in _config.RespawnConfigurations)
            {
                if (!string.IsNullOrEmpty(configuration.Permission))
                    permission.RegisterPermission(configuration.Permission, this);
            }
        }
    }

    private void OnServerInitialized()
    {
        _halfWorldSize = ConVar.Server.worldsize / 2;

        foreach (var kvp in _config.Profiles)
        {
            kvp.Value.Coroutine = InvokeHandler.Instance.StartCoroutine(PositionGeneration(kvp.Value, kvp.Key));
        }
    }

    private void Unload()
    {
        foreach (var kvp in _config.Profiles)
        {
            InvokeHandler.Instance.StopCoroutine(kvp.Value.Coroutine);
        }
    }

    private object OnPlayerRespawn(BasePlayer player)
    {
        Configuration.RespawnConfiguration respawnConfiguration = null;
        foreach (var configuration in _config.RespawnConfigurations)
        {
            if (!string.IsNullOrEmpty(configuration.Permission) &&
                !permission.UserHasPermission(player.UserIDString, configuration.Permission))
                continue;

            respawnConfiguration = configuration;
            break;
        }

        if (respawnConfiguration == null)
            return null;

        Vector3? position = null;
        if (respawnConfiguration.Group is { } groupId)
        {
            var positions = PluginData.Location.FindByGroup(groupId);

            position = positions[_random.Next(0, positions.Count)].Position;
        }
        else if (respawnConfiguration.Profile is { } profile)
        {
            position = FindPregeneratedPosition(profile);
        }

        if (!position.HasValue)
        {
#if DEBUG
            Debug.Log($"{nameof(OnPlayerRespawn)} > Unable to find a position for {player.UserIDString}.");
#endif
            return null;
        }

#if DEBUG
        Debug.Log($"{nameof(OnPlayerRespawn)} > Found position for {player.UserIDString}: {position}.");
#endif

        return new BasePlayer.SpawnPoint
        {
            pos = position.Value
        };
    }

    #endregion

    #region Commands

    private void CommandLocation(IPlayer player, string command, string[] args)
    {
        if (!player.HasPermission(PermissionLocation))
        {
            player.Reply(GetMsg("No Permission", player.Id));
            return;
        }

        if (args.Length == 0)
        {
            goto syntax;
        }

        switch (args[0])
        {
            case "new":
            case "n":
            {
                if (args.Length != 2)
                {
                    goto syntax;
                }

                var location = new PluginData.Location
                {
                    Name = args[1]
                };

                player.Position(out location.Position.x, out location.Position.y, out location.Position.z);
                _data.AddLocation(location);

                player.Reply(location.Format(player.Id));
                goto saveData;
            }

            case "delete":
            case "remove":
            case "d":
            case "r":
            {
                if (args.Length != 2 || !int.TryParse(args[1], out var id))
                {
                    goto syntax;
                }

                var locationIndex = PluginData.Location.FindIndexById(id);
                if (!locationIndex.HasValue)
                {
                    player.Reply(GetMsg("Location: Not Found", player.Id));
                    return;
                }

                _data.RemoveLocation(locationIndex.Value);
                player.Reply(GetMsg("Location: Removed", player.Id));
                goto saveData;
            }

            case "edit":
            case "e":
            {
                if (args.Length < 4 || !int.TryParse(args[1], out var id))
                {
                    player.Reply(GetMsg("Location: Edit Syntax", player.Id));
                    return;
                }

                var locationIndex = PluginData.Location.FindIndexById(id);
                if (!locationIndex.HasValue)
                {
                    player.Reply(GetMsg("Location: Not Found", player.Id));
                    return;
                }

                var locationCd = new CommandLocationData
                {
                    Player = player,
                    Location = _data.Locations[locationIndex.Value]
                };

                locationCd.Apply(args);
                player.Reply(GetMsg("Location: Edit Finished", player.Id));
                goto saveData;
            }

            case "update":
            case "u":
            {
                LoadData();
                player.Reply(GetMsg("Location: Updated", player.Id));
                return;
            }

            case "list":
            case "l":
            {
                var table = new TextTable();
                table.AddColumns("ID", "Name", "Group", "Position");

                foreach (var location in _data.Locations)
                {
                    table.AddRow(location.ID.ToString(), location.Name, location.Group.ToString(),
                        location.Position.ToString());
                }

                player.Reply(table.ToString());
                return;
            }

            case "valid":
            case "validate":
            case "v":
            {
                if (args.Length < 2)
                    goto syntax;

                var profile = _config.Profiles.GetValueOrDefault(args.Length > 2 ? args[2] : string.Empty);
                if (profile == null)
                {
                    player.Reply(GetMsg("Location: Profile Not Found", player.Id));
                    return;
                }

                Vector3 position;

                switch (args[1])
                {
                    case "location":
                    case "l":
                        if (args.Length < 4 || !int.TryParse(args[3], out var id))
                        {
                            goto syntax;
                        }

                        var locationIndex = PluginData.Location.FindIndexById(id);
                        if (!locationIndex.HasValue)
                        {
                            player.Reply(GetMsg("Location: Not Found", player.Id));
                            return;
                        }

                        position = _data.Locations[locationIndex.Value].Position;
                        break;

                    case "generated":
                    case "g":
                        if (args.Length < 4 || !int.TryParse(args[3], out var index))
                        {
                            goto syntax;
                        }

                        if (profile.Positions.Count <= index)
                        {
                            player.Reply(GetMsg("Location: Generated Not Found", player.Id));
                            return;
                        }

                        position = profile.Positions[index];
                        break;

                    case "position":
                    case "p":
                        if (player.Object is not BasePlayer basePlayer)
                        {
                            player.Reply(GetMsg("Location: Player Only", player.Id));
                            return;
                        }

                        position = basePlayer.ServerPosition;
                        break;

                    default:
                        goto syntax;
                }

                player.Reply(GetMsg("Location: Validation Format", player.Id)
                    .Replace("{buildings}", profile.IsValidBuilding(position).ToString())
                    .Replace("{colliders}", profile.IsValidColliders(position).ToString())
                    .Replace("{raycast}", profile.IsValidAbove(position).ToString())
                    .Replace("{biome}", profile.IsValidBiome(position).ToString())
                    .Replace("{topology}", profile.IsValidTopology(position).ToString())
                    .Replace("{splat}", profile.IsValidSplat(position).ToString()));

                return;
            }

            case "debug":
            {
                var profile =
                    _config.Profiles.GetValueOrDefault(args.Length > 1 ? string.Join(" ", args.Skip(1)) : string.Empty);

                if (profile == null)
                {
                    player.Reply(GetMsg("Location: Profile Not Found", player.Id));
                    return;
                }

                player.Reply(GetMsg("Location: Debug", player.Id)
                    .Replace("{amount}", profile.Positions.Count.ToString()));
                return;
            }

            case "show":
            case "draw":
            {
                if (player.Object is not BasePlayer basePlayer)
                {
                    player.Reply(GetMsg("Location: Player Only", player.Id));
                    return;
                }

                var profile = _config.Profiles.GetValueOrDefault(args.Length > 1 ? args[1] : string.Empty);

                if (profile == null)
                {
                    player.Reply(GetMsg("Location: Profile Not Found", player.Id));
                    return;
                }

                if (args.Length <= 2 || !float.TryParse(args[2], out var distance) || distance < 0)
                    distance = float.NaN;
                else
                    distance *= distance;

                var playerPosition = basePlayer.transform.position;
                for (var i = 0; i < profile.Positions.Count; i++)
                {
                    var position = profile.Positions[i];
                    if (!float.IsNaN(distance) &&
                        (playerPosition - position).SqrMagnitude2D() >= distance)
                        continue;

                    DDraw.Text(basePlayer, 10f, from: position, text: $"#{i}");
                }

                player.Reply(GetMsg("Location: Shown", player.Id));
                return;
            }

            default:
            {
                goto syntax;
            }
        }

        syntax:
        player.Reply(GetMsg("Location: Syntax", player.Id));
        return;

        saveData:
        SaveData();
    }

    private class CommandLocationData
    {
        public IPlayer Player;

        public PluginData.Location Location;

        private const int FirstArgumentIndex = 2;

        public void Apply(string[] args)
        {
            for (var i = FirstArgumentIndex; i + 1 < args.Length; i += 2)
            {
                switch (args[i])
                {
                    case "move":
                    {
                        var position = ParseVector(args[i + 1].ToLower());
                        if (!position.HasValue)
                        {
                            Player.Reply(GetMsg("Location: Unable To Parse Position", Player.Id));
                            break;
                        }

                        Location.Position = position.Value;
                        break;
                    }

                    case "group":
                    {
                        var group = -1;
                        if (args[i + 1] != "reset" && !int.TryParse(args[i + 1], out group))
                        {
                            Player.Reply(GetMsg("Location: Unable To Parse Group", Player.Id));
                            break;
                        }

                        Location.Group = group;
                        break;
                    }
                }
            }
        }

        private Vector3? ParseVector(string argument)
        {
            var vector = new Vector3();

            if (argument == "here")
            {
                Player.Position(out vector.x, out vector.y, out vector.z);
            }
            else
            {
                var coordinates = argument.Split(';');
                if (coordinates.Length != 3 || !float.TryParse(coordinates[0], out vector.x) ||
                    !float.TryParse(coordinates[1], out vector.y) || !float.TryParse(coordinates[2], out vector.z))
                {
                    return null;
                }
            }

            return vector;
        }
    }

    #endregion

    #region API

    private Vector3? GetLocation(int id)
    {
        var locationIndex = PluginData.Location.FindIndexById(id);
        if (!locationIndex.HasValue)
            return null;

        return _data.Locations[locationIndex.Value].Position;
    }

    private JObject GetGroupLocations(int group)
    {
        var locations = PluginData.Location.FindByGroup(group);
        return JObject.FromObject(locations);
    }

    private Vector3? GetPregeneratedLocation(string profileName = null)
    {
        if (profileName == null || !_config.Profiles.TryGetValue(profileName, out var profile))
        {
            PrintWarning($"Unknown profile has been retrieved.\n{StackTraceUtility.ExtractStackTrace()}");
            return null;
        }

        return FindPregeneratedPosition(profile);
    }

    #endregion

    #region Helpers

    private IEnumerator PositionGeneration(Configuration.Profile profile, string name)
    {
#if DEBUG
        var watch = Stopwatch.StartNew();
#endif
        while (true)
        {
            if (profile.Positions.Count >= profile.PregeneratedAmount)
            {
#if DEBUG
                Debug.Log(
                    $"{nameof(PositionGeneration)} > {profile.Calls} frames took {profile.CallsTook}ms (AVG: {profile.CallsTook / profile.Calls}ms). Generated (Profile: \"{name}\"): {profile.Positions.Count}+{profile.SkippedGenerations}.");

                profile.Calls = 0;
                profile.CallsTook = 0d;
                profile.SkippedGenerations = 0;
#endif
                yield return new WaitForSeconds(profile.PregeneratedCheck);
                continue;
            }

#if DEBUG
            watch.Start();
#endif

            var attempts = 0;
            var found = 0;
            while (attempts++ < profile.AttemptsPerFrame && found < profile.PositionsPerFrame &&
                   profile.Positions.Count < profile.PregeneratedAmount)
            {
                var position = TryFindPosition(profile);
                if (!position.HasValue)
                {
#if DEBUG
                    profile.SkippedGenerations++;
#endif
                    continue;
                }

                profile.Positions.Add(position.Value);
                found++;
            }

#if DEBUG
            profile.Calls++;
            profile.CallsTook += watch.Elapsed.TotalMilliseconds;

            watch.Reset();
#endif

            yield return null;
        }

        // ReSharper disable once IteratorNeverReturns
    }

    private Vector3? FindPregeneratedPosition(Configuration.Profile profile)
    {
        Vector3? position = null;
        for (var i = 0; i < profile.AttemptsPregenerated; i++)
        {
            if (profile.Positions.Count <= 0)
            {
#if DEBUG
                Debug.Log($"{nameof(FindPregeneratedPosition)} > There are no pregenerated positions.");
#endif
                return null;
            }

            // index. noice, performance for RemoveAt!
            var index = _random.Next(0, profile.Positions.Count);
            position = profile.Positions[index];

            // If it is a good position, break to return it.
            if (profile.IsValidPosition(position.Value))
                break;

            // Remove invalid position
            profile.Positions.RemoveAt(index);

            // Reset position value
            position = null;
        }

        return position;
    }

    private Vector3? TryFindPosition(Configuration.Profile profile)
    {
        var position = new Vector3(GetRandomPosition(), 0, GetRandomPosition());
        var waterInfo = WaterLevel.GetWaterInfo(position, false, false);

        position.y = waterInfo.terrainHeight;

        // Invalid if under the water
        if (waterInfo.isValid)
            return null;

        // Invalid if has buildings or colliders in the configured range
        if (!profile.IsValidPosition(position))
            return null;

        return position;
    }

    private int GetRandomPosition() => _random.Next(-_halfWorldSize, _halfWorldSize);

    private static string GetMsg(string key, string userId = null) => _ins.lang.GetMessage(key, _ins, userId);

    internal static class DDraw
    {
        public static void Line(BasePlayer player, float duration = 0.5f, Color? color = null,
            Vector3? from = null, Vector3? to = null)
        {
            player.SendConsoleCommand("ddraw.line", duration, Format(color), Format(from), Format(to));
        }

        public static void Arrow(BasePlayer player, float duration = 0.5f, Color? color = null,
            Vector3? from = null, Vector3? to = null, float headSize = 0f)
        {
            player.SendConsoleCommand("ddraw.arrow", duration, Format(color), Format(from), Format(to), headSize);
        }

        public static void Sphere(BasePlayer player, float duration = 0.5f, Color? color = null,
            Vector3? from = null, string text = "")
        {
            player.SendConsoleCommand("ddraw.sphere", duration, Format(color), Format(from), text);
        }

        public static void Text(BasePlayer player, float duration = 0.5f, Color? color = null,
            Vector3? from = null, string text = "")
        {
            player.SendConsoleCommand("ddraw.text", duration, Format(color), Format(from), text);
        }

        public static void Box(BasePlayer player, float duration = 0.5f, Color? color = null,
            Vector3? from = null, float size = 0.1f)
        {
            player.SendConsoleCommand("ddraw.box", duration, Format(color), Format(from), size);
        }

        private static string Format(Color? color) => ReferenceEquals(color, null)
            ? string.Empty
            : $"{color.Value.r},{color.Value.g},{color.Value.b},{color.Value.a}";

        private static string Format(Vector3? pos) => ReferenceEquals(pos, null)
            ? string.Empty
            : $"{pos.Value.x} {pos.Value.y} {pos.Value.z}";
    }

    #endregion
}

// --- End of file: PowerSpawn.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/plagued ---
// --- Original File Path: P/Plagued/Plagued.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.SQLite;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Plagued", "Psi|ocybin", "0.3.6", ResourceId = 1991)]
    [Description("Everyone is infected")]

    class Plagued : RustPlugin
    {
        #region Initialization

        static int plagueRange = 20;
        static int plagueIncreaseRate = 5;
        static int plagueDecreaseRate = 1;
        static int plagueMinAffinity = 6000;
        static int affinityIncRate = 10;
        static int affinityDecRate = 1; 
        static int maxKin = 2;
        static int maxKinChanges = 3;
        static int playerLayer;
        static bool disableSleeperAffinity = false;


        Dictionary<ulong, PlayerState> playerStates;

        #endregion

        #region Hooks

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");

            Config.Clear();
            Config["plagueRange"] = 20;
            Config["plagueIncreaseRate"] = 5;
            Config["plagueDecreaseRate"] = 1;
            Config["plagueMinAffinity"] = 6000;
            Config["affinityIncRate"] = 10;
            Config["affinityDecRate"] = 1;
            Config["maxKin"] = 2;
            Config["maxKinChanges"] = 3;
            Config["disableSleeperAffinity"] = false;

            SaveConfig();
        }

        void Unload() => PlayerState.closeDatabase();

        void OnServerInitialized()
        {
            PlayerState.setupDatabase(this);
            // Set the layer that will be used in the radius search. We only want human players in this case
            playerLayer = LayerMask.GetMask("Player (Server)");

            // Reload the player states
            playerStates = new Dictionary<ulong, PlayerState>();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                playerStates.Add(player.userID, new PlayerState(player, null));
            }

            plagueRange = (int)Config["plagueRange"];
            plagueIncreaseRate = (int)Config["plagueIncreaseRate"];
            plagueDecreaseRate = (int)Config["plagueDecreaseRate"];
            plagueMinAffinity = (int)Config["plagueMinAffinity"];
            affinityIncRate = (int)Config["affinityIncRate"];
            affinityDecRate = (int)Config["affinityDecRate"];
            maxKin = (int)Config["maxKin"];
            maxKinChanges = (int)Config["maxKinChanges"];
            disableSleeperAffinity = (bool)Config["disableSleeperAffinity"];
        }

        void OnPlayerInit(BasePlayer player)
        {
            // Add the player to the player state list
            if (!playerStates.ContainsKey(player.userID))
            {
                PlayerState state = new PlayerState(player, stateRef =>
                {
                    // The player was loaded in the current game session
                    playerStates.Add(player.userID, stateRef);
                    SendReply(player, "Welcome to plagued mod. Try the <color=#81F781>/plagued</color> command for more information.");
                    Puts(player.displayName + " has been plagued!");

                    // Add the proximity detector to the player
                    player.gameObject.AddComponent<ProximityDetector>();

                    return true;
                });
            }
            else
            {
                // Add the proximity detector to the player
                player.gameObject.AddComponent<ProximityDetector>();
            }
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            ProximityDetector proximityDetector = player.gameObject.GetComponent<ProximityDetector>();
            proximityDetector.disableProximityCheck();
            //Puts(player.displayName + " is no longer watched!");
        }

        void OnRunPlayerMetabolism(PlayerMetabolism metabolism)
        {
            // 0 - 1000 -> Decreased Health Regen
            // 1000 - 2000 -> Increased hunger
            // 2000 - 3000 -> Increased thirst
            // 3000 - 4000 -> No Health Regen
            // 4000 - 5000 -> No comfort
            // 5000 - 6000 -> Increased Hunger 2
            // 6000 - 7000 -> Increased Thirst 2
            // 7000 - 8000 -> Cold
            // 8000 - 9000 -> Bleeding
            // 9000+ -> Poison

            /*
             * -- ----------------------------
             * -- Rust default rates
             * -- ----------------------------
             * -- healthgain = 0.03
             * -- caloriesloss = 0 - 0.05
             * -- hydrationloss = 0 - 0.025
             * -- ----------------------------
             */
            BasePlayer player = metabolism.GetComponent<BasePlayer>();
            PlayerState state = playerStates[player.userID];
            int plagueLevel = state.getPlagueLevel();
            float defaultHealthGain = 0.03f;
            float defaultCaloriesLoss = 0.05f;
            float defaultHydrationLoss = 0.025f;

            //Puts("Infection stage " + (plagueLevel / 1000).ToString());

            if (plagueLevel == 0) return;

            if (plagueLevel <= 1) return;
            //Puts("Infection stage 1 " + player.displayName + " " + player.userID);
            metabolism.pending_health.value = metabolism.pending_health.value + (defaultHealthGain / 2f);

            if (plagueLevel <= 1000) return;
            //Puts("Infection stage 2");
            metabolism.calories.value = metabolism.calories.value - ((defaultCaloriesLoss * 3f) + (metabolism.heartrate.value / 10f));

            if (plagueLevel <= 2000) return;
            //Puts("Infection stage 3");
            metabolism.hydration.value = metabolism.hydration.value - ((defaultHydrationLoss * 3f) + (metabolism.heartrate.value / 10f));

            if (plagueLevel <= 3000) return;
            metabolism.pending_health.value = metabolism.pending_health.value - (defaultHealthGain / 2f);

            if (plagueLevel <= 4000) return;
            //Puts("Infection stage 5");
            metabolism.comfort.value = -1;

            if (plagueLevel <= 5000) return;
            //Puts("Infection stage 6");
            metabolism.calories.value = metabolism.calories.value - ((defaultCaloriesLoss * 5f) + (metabolism.heartrate.value / 10f));

            if (plagueLevel <= 6000) return;
            //Puts("Infection stage 7");
            metabolism.hydration.value = metabolism.hydration.value - ((defaultHydrationLoss * 5f) + (metabolism.heartrate.value / 10f));

            if (plagueLevel <= 7000) return;
            ///Puts("Infection stage 8");
            metabolism.temperature.value = metabolism.temperature.value - 0.05f;

            if (plagueLevel <= 8000) return;
            //Puts("Infection stage 9");
            metabolism.bleeding.value = metabolism.bleeding.value + 0.2f;

            if (plagueLevel < 10000) return;
            //Puts("Infection stage 10");
            metabolism.poison.value = 2;
        }

        void OnPlayerProximity(BasePlayer player, List<BasePlayer> players)
        {
            if (playerStates.ContainsKey(player.userID))
            {
                playerStates[player.userID].increasePlaguePenalty(players);
                //Puts(player.displayName + " is close to " + (players.Length - 1).ToString() + " other players!");
            }
        }

        void OnPlayerAlone(BasePlayer player)
        {
            if (playerStates.ContainsKey(player.userID))
            {
                playerStates[player.userID].decreasePlaguePenalty();
                //Puts("OnPlayerAlone: "+ player.userID);
            }
        }

        #endregion

        #region Commands

        [ChatCommand("plagued")]
        void cmdPlagued(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                SendReply(player, "<color=#81F781>/plagued addkin</color> => <color=#D8D8D8> Add the player you are looking at to your kin list.</color>");
                SendReply(player, "<color=#81F781>/plagued delkin</color> => <color=#D8D8D8> Remove the player you are looking at from your kin list.</color>");
                SendReply(player, "<color=#81F781>/plagued delkin</color> <color=#F2F5A9> number </color> => <color=#D8D8D8> Remove a player from your kin list by kin number.</color>");
                SendReply(player, "<color=#81F781>/plagued lskin</color> => <color=#D8D8D8> Display your kin list.</color>");
                SendReply(player, "<color=#81F781>/plagued lsassociates</color> => <color=#D8D8D8> Display your associates list.</color>");
                SendReply(player, "<color=#81F781>/plagued info</color> => <color=#D8D8D8> Display information about the workings of this mod.</color>");

                return;
            }

            if (args.Length >= 1)
            {
                switch (args[0])
                {
                    case "addkin":
                        cmdAddKin(player);
                        break;
                    case "delkin":
                        if (args.Length == 2)
                        {
                            int position;
                            if (int.TryParse(args[1], out position))
                            {
                                cmdDelKin(player, position);
                            }
                            else
                            {
                                SendReply(player, "Kin position must be a valid number!");
                            }
                        }
                        else
                        {
                            cmdDelKin(player);
                        }
                        break;
                    case "lskin":
                        cmdListKin(player);
                        break;
                    case "lsassociates":
                        cmdListAssociates(player);
                        break;
                    case "info":
                        cmdInfo(player);
                        break;
                    default:
                        SendReply(player, "Invalid Plagued mod command.");
                        break;
                }
            }
        }

        void cmdAddKin(BasePlayer player)
        {
            BasePlayer targetPlayer;

            if (getPlayerLookedAt(player, out targetPlayer))
            {
                PlayerState state = playerStates[player.userID];
                PlayerState targetPlayerState = playerStates[targetPlayer.userID];

                if (state.isKinByUserID(targetPlayer.userID))
                {
                    SendReply(player, targetPlayer.displayName + " is already your kin!");
                    return;
                }

                if (state.hasKinRequest(targetPlayer.userID))
                {
                    state.addKin(targetPlayer.userID);
                    targetPlayerState.addKin(player.userID);
                    SendReply(player, "You are now kin with " + targetPlayer.displayName + "!");
                    SendReply(targetPlayer, "You are now kin with " + player.displayName + "!");

                    return;
                }
                else
                {
                    targetPlayerState.addKinRequest(player.userID);
                    SendReply(player, "You have requested to be " + targetPlayer.displayName + "'s kin!");
                    SendReply(targetPlayer, player.displayName + " has requested to be your kin. Add him back to become kin!");

                    return;
                }

                SendReply(player, targetPlayer.displayName + " could not be added to kin!");
            }

        }

        bool cmdDelKin(BasePlayer player)
        {
            BasePlayer targetPlayer;

            if (getPlayerLookedAt(player, out targetPlayer))
            {
                PlayerState state = playerStates[player.userID];
                PlayerState targetPlayerState = playerStates[targetPlayer.userID];

                if (!state.isKinByUserID(targetPlayer.userID))
                {
                    SendReply(player, targetPlayer.displayName + " is not your kin!");

                    return false;
                }

                if (state.removeKin(targetPlayer.userID) && targetPlayerState.forceRemoveKin(player.userID))
                {
                    SendReply(player, targetPlayer.displayName + " was removed from you kin list!");
                    SendReply(targetPlayer, player.displayName + " was removed from you kin list!");

                    return true;
                }

                SendReply(player, targetPlayer.displayName + " could not be removed from kin list (Exceeded max kin changes per restart)!");
            }

            return false;
        }

        bool cmdDelKin(BasePlayer player, int id)
        {
            PlayerState state = playerStates[player.userID];

            if (state.removeKinById(id))
            {
                foreach (var item in playerStates)
                {
                    if (item.Value.getId() == id)
                    {
                        item.Value.forceRemoveKin(player.userID);
                    }
                }
                SendReply(player, "Successfully removed kin.");
            }
            else
            {
                SendReply(player, "Could not remove kin.");
            }

            return false;
        }

        void cmdListKin(BasePlayer player)
        {
            List<string> kinList = playerStates[player.userID].getKinList();

            displayList(player, "Kin", kinList);
        }

        void cmdListAssociates(BasePlayer player)
        {
            List<string> associatesList = playerStates[player.userID].getAssociatesList();
            displayList(player, "Associates", associatesList);
        }

        bool cmdInfo(BasePlayer player)
        {
            SendReply(player, " ===== Plagued mod ======");
            SendReply(player, "An unknown airborne pathogen has decimated most of the population. You find yourself on a deserted island, lucky to be among the few survivors. But the biological apocalypse is far from being over. It seems that the virus starts to express itself when certain hormonal changes are triggered by highly social behaviors. It has been noted that small groups of survivor seems to be relatively unaffected, but there isn't one single town or clan that wasn't decimated.");
            SendReply(player, "Workings: \n The longer you hang around others, the sicker you'll get. However, your kin are unaffected, add your friends as kin and you will be able to collaborate. Choose your kin wisely, there are no big families in this world.");
            SendReply(player, "Settings: \n > Max kin : " + maxKin.ToString() + "\n" + " > Max kin changes / Restart : " + maxKinChanges.ToString());

            return false;
        }

        #endregion

        #region Helpers

        public static void MsgPlayer(BasePlayer player, string format, params object[] args)
        {
            if (player?.net != null) player.SendConsoleCommand("chat.add", 0, args.Length > 0 ? string.Format(format, args) : format, 1f);
        }

        public void displayList(BasePlayer player, string listName, List<string> stringList)
        {
            if (stringList.Count == 0)
            {
                SendReply(player, "You have no " + listName.ToLower() + ".");
                return;
            }

            string answerMsg = listName + " list: \n";

            foreach (string text in stringList)
            {
                answerMsg += "> " + text + "\n";
            }

            SendReply(player, answerMsg);
        }

        #endregion

        #region Geometry

        bool getPlayerLookedAt(BasePlayer player, out BasePlayer targetPlayer)
        {
            targetPlayer = null;

            Quaternion currentRot;
            if (!TryGetPlayerView(player, out currentRot))
            {
                SendReply(player, "Couldn't get player rotation");
                return false;
            }

            object closestEnt;
            Vector3 closestHitpoint;
            if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return false;
            targetPlayer = ((Collider)closestEnt).GetComponentInParent<BasePlayer>();

            if (targetPlayer == null)
            {
                SendReply(player, "You aren't looking at a player");
                return false;
            }

            return true;
        }

        bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            /*
             * Credit: Nogrod (HumanNPC)
             */
            Vector3 sourceEye = sourcePos + new Vector3(0f, 1.5f, 0f);
            Ray ray = new Ray(sourceEye, sourceDir * Vector3.forward);

            var hits = Physics.RaycastAll(ray);
            float closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;
            for (var i = 0; i < hits.Length; i++)
            {
                var hit = hits[i];
                if (hit.collider.GetComponentInParent<TriggerBase>() == null && hit.distance < closestdist)
                {
                    closestdist = hit.distance;
                    closestEnt = hit.collider;
                    closestHitpoint = hit.point;
                }
            }

            if (closestEnt is bool) return false;
            return true;
        }

        bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            /*
             * Credit: Nogrod (HumanNPC)
             */
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            var input = player.serverInput;
            if (input.current == null) return false;

            viewAngle = Quaternion.Euler(input.current.aimAngles);
            return true;
        }

        #endregion

        #region Data

        /*
         * This class handles the in-memory state of a player.
         */
        public class PlayerState
        {
            static readonly Core.SQLite.Libraries.SQLite sqlite = Interface.Oxide.GetLibrary<Core.SQLite.Libraries.SQLite>();
            static Core.Database.Connection sqlConnection;
            BasePlayer player;
            int id;
            int plagueLevel;
            int kinChangesCount;
            bool pristine;
            Dictionary<ulong, Association> associations;
            Dictionary<ulong, Kin> kins;
            List<ulong> kinRequests;

            const string UpdateAssociation = "UPDATE associations SET level=@0 WHERE associations.id = @1;";
            const string InsertAssociation = "INSERT INTO associations (player_id,associate_id,level) VALUES (@0,@1,@2);";
            const string CheckAssociationExists = "SELECT id FROM associations WHERE player_id == @0 AND associate_id == @1;";
            const string DeleteAssociation = "DELETE FROM associations WHERE id=@0";
            const string InsertPlayer = "INSERT OR IGNORE INTO players (user_id, name, plague_level, kin_changes_count, pristine) VALUES (@0, @1,0,0,1);";
            const string SelectPlayer = "SELECT * FROM players WHERE players.user_id == @0;";
            const string UpdatePlayerPlagueLevel = "UPDATE players SET plague_level=@0,pristine=@1 WHERE players.user_id == @2;";
            const string SelectAssociations = @"
                SELECT associations.id, associations.player_id, associations.associate_id, associations.level, players.user_id, players.name
                FROM associations
                JOIN players ON associations.associate_id = players.id
                WHERE associations.player_id = @0
            ";
            const string SelectKinList = @"
                SELECT kin.self_id, kin.kin_id, players.name as kin_name, players.user_id as kin_user_id
                FROM kin
                JOIN players ON kin.kin_id = players.id
                WHERE kin.self_id = @0
            ";
            const string InsertKin = "INSERT INTO kin (self_id,kin_id) VALUES (@0,@1);";
            const string DeleteKin = "DELETE FROM kin WHERE self_id=@0 AND kin_id=@1";
            const string SelectKinRequestList = @"";

            /*
             * Retrieves a player from database and restore its store or creates a new database entry
             */
            public PlayerState(BasePlayer newPlayer, Func<PlayerState, bool> callback)
            {
                player = newPlayer;
                Interface.Oxide.LogInfo("Loading player: " + player.displayName);

                var sql = new Core.Database.Sql();
                sql.Append(InsertPlayer, player.userID, player.displayName);
                sqlite.Insert(sql, sqlConnection, create_results =>
                {
                    if (create_results == 1) Interface.Oxide.LogInfo("New user created!");

                    sql = new Core.Database.Sql();
                    sql.Append(SelectPlayer, player.userID);

                    sqlite.Query(sql, sqlConnection, results =>
                    {
                        if (results == null) return;

                        if (results.Count > 0)
                        {
                            foreach (var entry in results)
                            {
                                id = Convert.ToInt32(entry["id"]);
                                plagueLevel = Convert.ToInt32(entry["plague_level"]);
                                kinChangesCount = Convert.ToInt32(entry["kin_changes_count"]);
                                pristine = Convert.ToBoolean(entry["pristine"]);
                                break;
                            }
                        }
                        else
                        {
                            Interface.Oxide.LogInfo("Something wrong has happened: Could not find the player with the given user_id!");
                        }

                        associations = new Dictionary<ulong, Association>();
                        kins = new Dictionary<ulong, Kin>();
                        kinRequests = new List<ulong>();

                        loadAssociations();
                        loadKinList();
                        //loadKinRequestList();
                        callback?.Invoke(this);
                    });
                });
            }

            public static void setupDatabase(RustPlugin plugin)
            {
                sqlConnection = sqlite.OpenDb($"Plagued.db", plugin);

                var sql = new Core.Database.Sql();

                sql.Append(@"CREATE TABLE IF NOT EXISTS players (
                                 id INTEGER PRIMARY KEY   AUTOINCREMENT,
                                 user_id TEXT UNIQUE NOT NULL,
                                 name TEXT,
                                 plague_level INTEGER,
                                 kin_changes_count INTEGER,
                                 pristine INTEGER
                               );");

                sql.Append(@"CREATE TABLE IF NOT EXISTS associations (
                                id INTEGER PRIMARY KEY   AUTOINCREMENT,
                                player_id integer NOT NULL,
                                associate_id integer NOT NULL,
                                level INTEGER,
                                FOREIGN KEY (player_id) REFERENCES players(id),
                                FOREIGN KEY (associate_id) REFERENCES players(id)
                            );");

                sql.Append(@"CREATE TABLE IF NOT EXISTS kin (
                                self_id integer NOT NULL,
                                kin_id integer NOT NULL,
                                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                                FOREIGN KEY (self_id) REFERENCES players(id),
                                FOREIGN KEY (kin_id) REFERENCES players(id),
                                PRIMARY KEY (self_id,kin_id)
                            );");

                sql.Append(@"CREATE TABLE IF NOT EXISTS kin_request (
                                requester_id integer NOT NULL,
                                target_id integer NOT NULL,
                                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                                FOREIGN KEY (requester_id) REFERENCES players(id),
                                FOREIGN KEY (target_id) REFERENCES players(id),
                                PRIMARY KEY (requester_id,target_id)
                            );");


                sqlite.Insert(sql, sqlConnection);
            }

            public static void closeDatabase()
            {
                sqlite.CloseDb(sqlConnection);
            }

            /*
             * Increases the affinity of an associate and returns his new affinity
             */
            Association increaseAssociateAffinity(BasePlayer associate)
            {
                if (associate == null) return null;
                if (player.userID == associate.userID) return null;
                if (disableSleeperAffinity && !BasePlayer.activePlayerList.Contains(associate)) return null;

                Association association = null;

                if (associations.ContainsKey(associate.userID))
                {
                    association = associations[associate.userID];
                    if ((association.level + affinityIncRate) < int.MaxValue) association.level += affinityIncRate;
                }
                else
                {
                    createAssociation(associate.userID, associationRef =>
                    {
                        if (associationRef != null)
                        {
                            association = associationRef;
                            associations.Add(associate.userID, associationRef);
                        }

                        return true;
                    });
                }

                //Puts(player.displayName + " -> " + associate.displayName + " = " + associates[associate.userID].ToString());

                return association;
            }

            /*
             * Increases the affinity of all the associations in the list and increases the plague penalty if some associations are over the plague threshold
             * It also decreases the plague treshold if all the associates are kin or under the threshold
             */
            public void increasePlaguePenalty(List<BasePlayer> associates)
            {
                int contagionVectorsCount = 0;
                var sql = new Core.Database.Sql();

                foreach (BasePlayer associate in associates)
                {
                    if (isKinByUserID(associate.userID)) continue;

                    Association association = increaseAssociateAffinity(associate);

                    if (association == null) continue;

                    sql.Append(UpdateAssociation, association.level, association.id);

                    if (association.level >= plagueMinAffinity)
                    {
                        contagionVectorsCount++;
                    }
                }

                sqlite.Update(sql, sqlConnection);


                if (contagionVectorsCount > 0)
                {
                    increasePlagueLevel(contagionVectorsCount);
                }
                else
                {
                    decreasePlagueLevel();
                }

                //Puts(player.displayName + " -> " + plagueLevel);
            }

            /*
             * Decreases the affinity of all associations and decreases the plague level.
             */
            public void decreasePlaguePenalty()
            {
                decreaseAssociationsLevel();

                if (!pristine) decreasePlagueLevel();
            }

            public void increasePlagueLevel(int contagionVectorCount)
            {
                if ((plagueLevel + (contagionVectorCount * plagueIncreaseRate)) <= 10000)
                {
                    plagueLevel += contagionVectorCount * plagueIncreaseRate;

                    if (pristine == true)
                    {
                        pristine = false;
                        MsgPlayer(player, "I don't feel so good.");
                        //Puts(player.displayName + " is now sick.");
                    }

                    syncPlagueLevel();
                }

                //Puts(player.displayName + "'s new plague level: " + plagueLevel.ToString());
            }

            public void decreasePlagueLevel()
            {
                if ((plagueLevel - plagueDecreaseRate) >= 0)
                {
                    plagueLevel -= plagueDecreaseRate;

                    if (plagueLevel == 0)
                    {
                        pristine = true;
                        MsgPlayer(player, "I feel a bit better now.");
                        //Puts(player.displayName + " is now cured.");
                    }

                    syncPlagueLevel();
                }
            }

            public void decreaseAssociationsLevel()
            {
                if (associations.Count == 0) return;

                List<ulong> to_remove = new List<ulong>();
                var sql = new Core.Database.Sql();

                foreach (ulong key in associations.Keys)
                {
                    Association association = associations[key];
                    int new_affinity = association.level - affinityDecRate;
                    if (new_affinity >= 1)
                    {
                        association.level = association.level - affinityDecRate;
                        sql.Append(UpdateAssociation, association.level, association.id);
                    }
                    else if (new_affinity <= 0)
                    {
                        sql.Append(DeleteAssociation, association.id);
                        to_remove.Add(key);
                    }
                }

                foreach (ulong keyToRemove in to_remove)
                {
                    associations.Remove(keyToRemove);
                }

                sqlite.ExecuteNonQuery(sql, sqlConnection);
            }


            public bool isKinByUserID(ulong userID)
            {
                foreach (var item in kins)
                {
                    if (item.Value.kin_user_id == userID)
                        return true;
                }

                return false;
            }

            public bool hasKinRequest(ulong kinID) => kinRequests.Contains(kinID);

            public bool addKinRequest(ulong kinID)
            {
                if (!kinRequests.Contains(kinID))
                {
                    kinRequests.Add(kinID);

                    return true;
                }

                return false;
            }

            public bool addKin(ulong kinUserID)
            {
                if (kins.Count + 1 <= maxKin && !isKinByUserID(kinUserID))
                {
                    if (kinRequests.Contains(kinUserID)) kinRequests.Remove(kinUserID);
                    Kin newKin = createKin(kinUserID);
                    newKin.kin_user_id = kinUserID;
                    kins.Add(kinUserID, newKin);

                    return true;
                }

                return false;
            }

            public bool removeKinById(int id)
            {
                if ((kinChangesCount + 1) <= maxKinChanges)
                {
                    foreach (Kin kin in kins.Values)
                        if (kin.kin_id == id)
                            return forceRemoveKin(kin.kin_user_id);
                }

                return false;
            }

            public bool removeKin(ulong kinUserID)
            {
                if ((kinChangesCount + 1) <= maxKinChanges)
                    return forceRemoveKin(kinUserID);

                return false;
            }

            public bool forceRemoveKin(ulong kinUserID)
            {
                if (isKinByUserID(kinUserID))
                {
                    kinChangesCount++;
                    Kin kin = kins[kinUserID];

                    var sql = new Core.Database.Sql();
                    sql.Append(DeleteKin, kin.self_id, kin.kin_id);
                    sqlite.ExecuteNonQuery(sql, sqlConnection);

                    kins.Remove(kinUserID);

                    return true;
                }

                return false;
            }

            public List<string> getKinList()
            {
                List<string> kinList = new List<string>();

                foreach (Kin kin in kins.Values)
                    kinList.Add(String.Format("{0} (Id: {1})", kin.kin_name, kin.kin_id));

                return kinList;
            }

            public List<string> getAssociatesList()
            {
                List<string> associatesList = new List<string>();

                foreach (Association association in associations.Values)
                    associatesList.Add(string.Format("{0} (Id: {1} | Level: {2})", association.associate_name, association.associate_id, association.getAffinityLabel()));

                return associatesList;
            }

            public int getPlagueLevel() => plagueLevel;

            public int getId() => id;

            public bool getPristine() => pristine;

            Kin createKin(ulong kinUserId)
            {
                Kin kin = new Kin(id);

                var sql = new Core.Database.Sql();
                sql.Append(SelectPlayer, kinUserId);

                sqlite.Query(sql, sqlConnection, list =>
                {
                    if (list == null) return;

                    foreach (var user in list)
                    {
                        kin.kin_id = Convert.ToInt32(user["id"]);
                        kin.kin_name = Convert.ToString(user["name"]);
                        kin.kin_user_id = kinUserId;
                        break;
                    }

                    kin.create();
                });

                return kin;
            }

            void createAssociation(ulong associate_user_id, Func<Association, bool> callback)
            {
                Association association = new Association();

                var sql = new Core.Database.Sql();
                sql.Append(SelectPlayer, associate_user_id);
                sqlite.Query(sql, sqlConnection, list =>
                {
                    if (list == null) return;
                    if (list.Count == 0)
                    {
                        callback(null);
                        return;
                    };

                    foreach (var user in list)
                    {
                        association.player_id = id;
                        association.associate_id = Convert.ToInt32(user["id"]);
                        association.associate_user_id = associate_user_id;
                        association.associate_name = Convert.ToString(user["name"]);
                        association.level = 0;
                        break;
                    }

                    association.create();
                    callback(association);
                });
            }

            void syncPlagueLevel()
            {
                var sql = new Core.Database.Sql();
                sql.Append(UpdatePlayerPlagueLevel, plagueLevel, (pristine ? 1 : 0), player.userID);
                sqlite.Update(sql, sqlConnection);
            }

            void loadAssociations()
            {
                var sql = new Core.Database.Sql();
                sql.Append(SelectAssociations, id);
                sqlite.Query(sql, sqlConnection, results =>
                {
                    if (results == null) return;

                    foreach (var association_result in results)
                    {
                        Association association = new Association();
                        association.load(association_result);
                        associations[association.associate_user_id] = association;
                    }
                });
            }

            void loadKinList()
            {
                var sql = new Core.Database.Sql();
                sql.Append(SelectKinList, id);
                sqlite.Query(sql, sqlConnection, results =>
                {
                    if (results == null) return;

                    foreach (var kinResult in results)
                    {
                        Kin kin = new Kin(id);
                        kin.load(kinResult);
                        kins[kin.kin_user_id] = kin;
                    }
                });
            }

            void loadKinRequestList()
            {
                var sql = new Core.Database.Sql();
                sql.Append(SelectKinRequestList, id);
                sqlite.Query(sql, sqlConnection, results =>
                {
                    if (results == null) return;

                    foreach (var kinRequest in results)
                    {
                        kinRequests.Add((ulong)Convert.ToInt64(kinRequest["user_id"]));
                    }
                });
            }

            class Association
            {
                public int id;
                public int player_id;
                public int associate_id;
                public ulong associate_user_id;
                public string associate_name;
                public int level;

                public void create()
                {
                    var sql = new Core.Database.Sql();
                    sql.Append(CheckAssociationExists, player_id, associate_id);

                    // Check if the relationship exists before creating it
                    sqlite.Query(sql, sqlConnection, check_results =>
                    {
                        if (check_results.Count > 0) return;

                        sql = new Core.Database.Sql();

                        sql.Append(InsertAssociation, player_id, associate_id, level);
                        sqlite.Insert(sql, sqlConnection, result =>
                        {
                            if (result == null) return;
                            id = (int)sqlConnection.LastInsertRowId;
                        });
                    });
                }

                public void load(Dictionary<string, object> association)
                {
                    id = Convert.ToInt32(association["id"]);
                    associate_name = Convert.ToString(association["name"]);
                    associate_user_id = (ulong)Convert.ToInt64(association["user_id"]);
                    associate_id = Convert.ToInt32(association["associate_id"]);
                    player_id = Convert.ToInt32(association["player_id"]);
                    level = Convert.ToInt32(association["level"]);
                }

                public string getAffinityLabel()
                {
                    if (level >= plagueMinAffinity)
                    {
                        return "Associate";
                    }
                    else
                    {
                        return "Acquaintance";
                    }
                }
            }

            class Kin
            {
                public int self_id;
                public int kin_id;
                public ulong kin_user_id;
                public string kin_name;
                public int player_one_id;
                public int player_two_id;

                Kin()
                {

                }

                public Kin(int p_self_id)
                {
                    self_id = p_self_id;
                }

                public void create()
                {
                    var sql = new Core.Database.Sql();
                    sql.Append(InsertKin, self_id, kin_id);
                    sqlite.Insert(sql, sqlConnection);
                }

                public void load(Dictionary<string, object> kin)
                {
                    self_id = Convert.ToInt32(kin["self_id"]);
                    kin_id = Convert.ToInt32(kin["kin_id"]);
                    kin_name = Convert.ToString(kin["kin_name"]);
                    kin_user_id = (ulong)Convert.ToInt64(kin["kin_user_id"]);
                }
            }
        }

        #endregion

        #region Unity Components

        /*
         * This component adds a timers and collects all players colliders in a given radius. It then triggers custom hooks to reflect the situation of a given player
         */
        public class ProximityDetector : MonoBehaviour
        {
            public BasePlayer player;

            public void disableProximityCheck() => CancelInvoke("CheckProximity");

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                InvokeRepeating("CheckProximity", 0, 2.5f);
            }

            void OnDestroy() => disableProximityCheck();

            void CheckProximity()
            {
                var count = Physics.OverlapSphereNonAlloc(player.transform.position, plagueRange, Vis.colBuffer, playerLayer);

                if (count > 1)
                {
                    List<BasePlayer> playersNear = new List<BasePlayer>();
                    for (int i = 0; i < count; i++)
                    {
                        var collider = Vis.colBuffer[i];
                        Vis.colBuffer[i] = null;
                        var collidingPlayer = collider.GetComponentInParent<BasePlayer>();
                        if (collidingPlayer is NPCPlayer)
                            continue;
                        playersNear.Add(collidingPlayer);
                    }
                    notifyPlayerProximity(playersNear);
                }
                else
                {
                    notifyPlayerAlone();
                }
            }

            void notifyPlayerProximity(List<BasePlayer> players) => Interface.Oxide.CallHook("OnPlayerProximity", player, players);

            void notifyPlayerAlone() => Interface.Oxide.CallHook("OnPlayerAlone", player);
        }

        #endregion
    }
}

// --- End of file: Plagued.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/the-purge ---
// --- Original File Path: P/Purge/Purge.cs ---

﻿/*
 * TODO:
 * Add optional GUI icons to indicate what is enabled/disabled
 * Finish implementing pre-purge warning countdown
 */

using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Purge", "Wulf/lukespragg", "1.2.2", ResourceId = 1102)]
    [Description("Allows damage and killing only between specific in-game hours")]

    class Purge : CovalencePlugin
    {
        #region Initialization

        const string permAllow = "purge.allow";
        const string permProtect = "purge.protect";

        bool configChanged;
        bool purgeActive;
        bool purgeAnimal;
        bool purgeHeli;
        bool purgeLoot;
        bool purgeStructure;
        bool purgeTurret;
        bool purgeWorld;
        bool realTime;
        bool safeAnimal;
        bool safeHeli;
        bool safeLoot;
        bool safeStructure;
        bool safeTurret;
        bool safeWorld;
        //bool warningStarted;

        TimeSpan purgeBegin;
        TimeSpan purgeEnd;
        //int warningPeriod;

        protected override void LoadDefaultConfig()
        {
            // Options
            purgeAnimal = GetConfig("Purge Rules", "Animal Damage (true/false)", true);
            purgeHeli = GetConfig("Purge Rules", "Heli Damage (true/false)", true);
            purgeLoot = GetConfig("Purge Rules", "Loot Damage (true/false)", true);
            purgeStructure = GetConfig("Purge Rules", "Structure Damage (true/false)", true);
            purgeTurret = GetConfig("Purge Rules", "Turret Damage (true/false)", true);
            purgeWorld = GetConfig("Purge Rules", "World Damage (true/false)", true);
            realTime = GetConfig("Real Time (true/false)", false);
            safeAnimal = GetConfig("Safe Rules", "Animal Damage (true/false)", false);
            safeHeli = GetConfig("Safe Rules", "Heli Damage (true/false)", false);
            safeLoot = GetConfig("Safe Rules", "Loot Damage (true/false)", false);
            safeStructure = GetConfig("Safe Rules", "Structure Damage (true/false)", false);
            safeTurret = GetConfig("Safe Rules", "Turret Damage (true/false)", false);
            safeWorld = GetConfig("Safe Rules", "World Damage (true/false)", true);

            // Settings
            TimeSpan.TryParse(GetConfig("Purge Time (24-hour format)", "Begin (00:00:00)", "18:00:00"), out purgeBegin);
            TimeSpan.TryParse(GetConfig("Purge Time (24-hour format)", "End (00:00:00)", "06:00:00"), out purgeEnd);
            //warningPeriod = GetConfig("Warning Seconds (0 - 60)", 10);

            if (!configChanged) return;

            configChanged = false;
            SaveConfig();
        }

        void OnServerInitialized()
        {
            List<PlantEntity> list = Pool.GetList<PlantEntity>();
            foreach (var p in list)
            {
                PrintWarning(p.PrefabName);
            }

            LoadDefaultConfig();
            LoadDefaultMessages();
            permission.RegisterPermission(permAllow, this);
            permission.RegisterPermission(permProtect, this);
        }

        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PurgeEnded"] = "Purge has ended! PvP disabled",
                ["PurgeStarted"] = "Purge has begun! PvP enabled"
            }, this);

            // French
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PurgeEnded"] = "Purge est terminée ! PvP désactivé",
                ["PurgeStarted"] = "Purge a commencé ! PvP activé"
            }, this, "fr");

            // German
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PurgeEnded"] = "Säuberung ist beendet! PvP deaktiviert",
                ["PurgeStarted"] = "Purge hat begonnen! PvP aktiviert"
            }, this, "de");

            // Russian
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PurgeEnded"] = "Продувка закончился! PvP отключен",
                ["PurgeStarted"] = "Продувка началась! PvP включен"
            }, this, "ru");

            // Spanish
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PurgeEnded"] = "¡Ha terminado la purga! PvP desactivado",
                ["PurgeStarted"] = "¡Ha comenzado la purga! PvP activado"
            }, this, "es");
        }

        #endregion

        #region Purging

        /*bool PurgeWarning
        {
            get
            {
                var totalSeconds = purgeBegin.Subtract(server.Time.TimeOfDay).TotalSeconds;
                return totalSeconds > 0 && totalSeconds <= (warningPeriod * ConVar.Server.tickrate);
            }
        }*/

        bool PurgeTime
        {
            get
            {
                var time = realTime ? DateTime.Now.TimeOfDay : server.Time.TimeOfDay;
                return purgeBegin < purgeEnd ? time >= purgeBegin && time < purgeEnd : time >= purgeBegin || time < purgeEnd;
            }
        }

        void OnTick()
        {
            /*if (!purgeActive && PurgeWarning && !warningStarted)
            {
                warningStarted = true;
                var countdown = warningPeriod - 1;
                timer.Repeat((warningPeriod * ConVar.Server.tickrate) / 60, warningPeriod, () =>
                {
                    PrintWarning(countdown.ToString());
                    if (countdown == 0) warningStarted = false;
                    Puts($"Purge commencing in {countdown}...");
                    countdown--;
                });
                return;
            }*/

            if (PurgeTime && !purgeActive)
            {
                Puts(Lang("PurgeStarted"));
                Broadcast("PurgeStarted");
                purgeActive = true;
            }
            else if (!PurgeTime && purgeActive)
            {
                Puts(Lang("PurgeEnded"));
                Broadcast("PurgeEnded");
                purgeActive = false;
            }
        }

        void OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            var target = entity.PrefabName;
            var attacker = info.Initiator;

            if (purgeActive)
            {
                var player = entity.ToPlayer();
                if (player != null && !permission.UserHasPermission(player.UserIDString, permProtect)) return;

                if (purgeAnimal && (target.Contains("animals") || target.Contains("corpse") || (attacker != null && attacker.name.Contains("animals")))) return;
                if (purgeHeli && (entity is BaseHelicopter || attacker is BaseHelicopter)) return;
                if (purgeLoot && (target.Contains("loot") || target.Contains("barrel"))) return;
                if (purgeStructure && attacker != null && (entity is Barricade || entity is BuildingBlock || entity is Door || entity is SimpleBuildingBlock)) return;
                if (purgeTurret && (entity is AutoTurret || attacker is AutoTurret)) return;
                if (purgeWorld && (entity is BasePlayer && attacker == null)) return;
            }
            else
            {
                if (safeAnimal && (target.Contains("animals") || target.Contains("corpse") || (attacker != null && attacker.name.Contains("animals")))) return;
                if (safeHeli && (entity is BaseHelicopter || attacker is BaseHelicopter)) return;
                if (safeLoot && (target.Contains("loot") || target.Contains("barrel"))) return;
                if (safeStructure && attacker != null && (entity is Barricade || entity is BuildingBlock || entity is Door || entity is SimpleBuildingBlock)) return;
                if (safeTurret && (entity is AutoTurret || attacker is AutoTurret)) return;
                if (safeWorld && (entity is BasePlayer && attacker == null)) return;
            }

            info.damageTypes = new DamageTypeList();
            info.PointStart = Vector3.zero;
            info.HitMaterial = 0;
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string parent, string key, T defaultValue)
        {
            var data = Config[parent] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[parent] = data;
                configChanged = true;
            }
            object value;
            if (!data.TryGetValue(key, out value))
            {
                value = defaultValue;
                data[key] = value;
                configChanged = true;
            }
            return (T)Convert.ChangeType(value, typeof(T));
        }

        T GetConfig<T>(string key, T defaultValue)
        {
            if (Config[key] == null)
            {
                Config[key] = defaultValue;
                configChanged = true;
                return defaultValue;
            }
            return (T)Convert.ChangeType(Config[key], typeof(T));
        }

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        void Broadcast(string key, params object[] args)
        {
            foreach (var player in players.Connected) player.Message(Lang(key, player.Id, args));
        }

        #endregion
    }
}

// --- End of file: Purge.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/performance-monitor ---
// --- Original File Path: P/PerformanceMonitor/PerformanceMonitor.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("Performance Monitor", "Orange", "1.2.7")]
    [Description("Tool for collecting information about server performance")]
    public class PerformanceMonitor : RustPlugin
    {
        #region Vars

        private const string commandString = "monitor.createreport";
        private const string commandString2 = "monitor.report";
        private PerformanceDump currentReport;

        #endregion

        #region Oxide Hooks

        private void Init()
        {

            cmd.AddConsoleCommand(commandString, this, nameof(cmdCompleteNow));
            cmd.AddConsoleCommand(commandString2, this, nameof(cmdCompleteNow));
        }

        private void OnServerInitialized()
        {
            if (config.checkTime > 0)
            {
                timer.Every(config.checkTime, CreateReport);
            }
        }

        #endregion

        #region Commands

        private void cmdCompleteNow(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin == false)
            {
                return;
            }

            CreateReport();
        }

        #endregion

        #region Core

        private void CreateReport()
        {
            ServerMgr.Instance.StartCoroutine(CreateActualReport());
        }

        private IEnumerator CreateActualReport()
        {
            if (currentReport != null)
            {
                yield break;
            }

            currentReport = new PerformanceDump();

            Stopwatch sw = new Stopwatch();
            sw.Start();

            CompletePluginsReport();
            ServerMgr.Instance.StartCoroutine(CompleteEntitiesReport());

            while (!currentReport.entities.completed && config.runEntitiesReport)
            {
                Puts($"Report status: {currentReport.statusBar}% [{currentReport.entitiesChecked}/{currentReport.entitiesTotal}]");
                yield return new WaitForEndOfFrame();
            }
            
            SaveReport(currentReport);
            currentReport = null;
            sw.Stop();
            Puts($"Performance report was completed in {sw.Elapsed.Seconds + (sw.Elapsed.Milliseconds / 1000.0)} seconds.");
        }
        
        private void CompletePluginsReport()
        {
            List<string> list = Pool.GetList<string>();

            if (config.runPluginsReport == false)
            {
                return;
            }
            
            if(config.sortByHookTime)
            {
                foreach (var plugin in plugins.GetAll().OrderByDescending(x => x.TotalHookTime))
                {
                    ProcessPlugins(plugin, list);
                }
            }
            else
            {
#if CARBON
                foreach (var plugin in plugins.GetAll().OrderByDescending(x => x.TotalMemoryUsed))
#else
                foreach (var plugin in plugins.GetAll().OrderByDescending(x => x.TotalHookMemory))
#endif
                {
                    ProcessPlugins(plugin, list);
                }
            }
            currentReport.plugins = list.ToArray();
            Pool.FreeList(ref list);
        }

        private void ProcessPlugins(Plugin plugin, List<string> list)
        {
            
            string name = plugin.Name;
            if (name == Name || plugin.IsCorePlugin || config.excludedPlugins.Contains(name))
            {
                return;
            }
#if CARBON
            string memory = FormatBytes(plugin.TotalMemoryUsed);
            double time = Math.Round(plugin.TotalHookTime.TotalSeconds, 6);
#else
            string memory = FormatBytes(plugin.TotalHookMemory);
            double time = Math.Round(plugin.TotalHookTime, 6);
#endif
            VersionNumber version = plugin.Version;
            
            string info = $"{name} ({version}) ({memory}), Total Hook Time = {time}";
            
            list.Add(info);
        }
        
        private IEnumerator CompleteEntitiesReport()
        {
            if (config.runEntitiesReport == false)
            {
                yield break;
            }
            
            // Swapped to serverEntities.OfType<> Instead of UnityEngine.FindObjectOfType<> due to absolute absurdity of time scale between the two.
            // serverEntities took 0.0151 ms, UnityEngine took 201.12 ms.
            var entities = BaseNetworkable.serverEntities.OfType<BaseEntity>();
            var entitiesByShortname = currentReport.entities.list;
            
            currentReport.entitiesTotal = entities.Count();

            int count = 0;
            foreach (BaseEntity entity in entities)
            {
                currentReport.entitiesChecked++;
                currentReport.statusBar = Convert.ToInt32(count * 100 / currentReport.entitiesTotal);

                if (entity.IsValid() == false)
                {
                    continue;
                }

                var shortname = entity.ShortPrefabName;
                if (config.excludedEntities.Contains(shortname))
                {
                    continue;
                }

                EntityInfo info;
                if (entitiesByShortname.TryGetValue(shortname, out info) == false)
                {
                    info = new EntityInfo();
                    entitiesByShortname.Add(shortname, info);
                }


                if (entity.OwnerID == 0)
                {
                    info.countUnowned++;
                    currentReport.entities.countUnowned++;
                }
                else
                {
                    info.countOwned++;
                    currentReport.entities.countOwned++;
                }

                info.countGlobal++;
                currentReport.entities.countGlobal++;
            }

            currentReport.entities.list = currentReport.entities.list.OrderByDescending(x => x.Value.countGlobal).ToDictionary(x => x.Key, y => y.Value);

            currentReport.entities.completed = true;
        }

        #endregion

        #region Utils
        
        private void SaveReport(PerformanceDump dump)
        {
            string name1;
            if(config.EuropeanTimeSave) name1 = DateTime.Now.ToString("dd/MM/yyyy").Replace("/", "-");
            else name1 = DateTime.Now.ToString("MM/dd/yyyy").Replace("/", "-");
            string name2 = DateTime.Now.ToString(Time()).Replace(':', '-');
            string filename = $"PerformanceMonitor/Reports/{name1}/{name2}";
            Interface.Oxide.DataFileSystem.WriteObject(filename, dump);
        }

        private string Time()
        {
            return DateTime.Now.ToString("HH:mm:ss");
        }
        
        // From RustCore Class, thank you Rust/Oxide.
        private static string FormatBytes(long bytes)
        {
            if (bytes < 1024L)
                return $"{bytes} B";
            if (bytes < 1048576L)
                return $"{bytes / 1024.0} KB";
            return bytes < 1073741824L ? $"{Math.Round(bytes / 1048576.0, 3)} MB" : $"{Math.Round(bytes / 1073741824.0, 3)} GB";
        }
        
        private static string FormatBytes(double bytes)
        {
            if (bytes < 1024L)
                return $"{bytes} B";
            if (bytes < 1048576L)
                return $"{bytes / 1024.0} KB";
            return bytes < 1073741824L ? $"{Math.Round(bytes / 1048576.0, 3)} MB" : $"{Math.Round(bytes / 1073741824.0, 3)} GB";
        }

        #endregion
        
        #region Configuration | 2.0.0

        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Save file dates in European Format 27-06-2023 (other format is North American 06-27-2023)")]
            public bool EuropeanTimeSave = false;
            
            [JsonProperty(PropertyName = "Create reports every (seconds)")]
            public int checkTime = 0;

            [JsonProperty(PropertyName = "Create plugins report")]
            public bool runPluginsReport = true;
            
            [JsonProperty(PropertyName = "Sort Plugins By Hook Time (If set false, sorts by Memory Usage)")]
            public bool sortByHookTime = true;

            [JsonProperty(PropertyName = "Create entities report")]
            public bool runEntitiesReport = true;

            [JsonProperty(PropertyName = "Excluded entities")]
            public string[] excludedEntities =
            {
                "shortname here",
                "another here"
            };

            [JsonProperty(PropertyName = "Excluded plugins")]
            public string[] excludedPlugins =
            {
                "name here",
                "another name"
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");

                timer.Every(10f,
                    () =>
                    {
                        PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                    });
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Classes

        private class PerformanceDump
        {
            [JsonProperty(PropertyName = "Online Players")]
            public int onlinePlayers = BasePlayer.activePlayerList.Count;

            [JsonProperty(PropertyName = "Offline Players")]
            public int offlinePlayers = BasePlayer.sleepingPlayerList.Count;

            [JsonProperty(PropertyName = "Entities Report")]
            public EntitiesReport entities = new EntitiesReport();
            
            [JsonProperty(PropertyName = "Plugins Report")]
            public string[] plugins;

            [JsonProperty(PropertyName = "Performance Report")]
            public Performance.Tick performance = Performance.current;
            
            [JsonIgnore] 
            public int statusBar;

            [JsonIgnore] 
            public int entitiesChecked;

            [JsonIgnore]
            public int entitiesTotal;
        }

        private class EntitiesReport
        {
            [JsonProperty(PropertyName = "Total")]
            public int countGlobal;
            
            [JsonProperty(PropertyName = "Owned")]
            public int countOwned;
            
            [JsonProperty(PropertyName = "Unowned")]
            public int countUnowned;
            
            [JsonProperty(PropertyName = "List")]
            public Dictionary<string, EntityInfo> list = new Dictionary<string, EntityInfo>();

            [JsonIgnore] 
            public bool completed;
        }

        private class EntityInfo
        {
            [JsonProperty(PropertyName = "Total")]
            public int countGlobal;
            
            [JsonProperty(PropertyName = "Owned")]
            public int countOwned;
            
            [JsonProperty(PropertyName = "Unowned")]
            public int countUnowned;
        }

        #endregion
    }
}

// --- End of file: PerformanceMonitor.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-names ---
// --- Original File Path: P/PlayerNames/PlayerNames.cs ---

﻿using System.Collections.Generic;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Player Names", "Arainrr", "1.1.2")]
    [Description("Logs and stores all names used by players.")]
    public class PlayerNames : CovalencePlugin
    {
        private const string PERMISSION_USE = "playernames.use";
        private bool changed = false;

        private void Init()
        {
            LoadData();
            permission.RegisterPermission(PERMISSION_USE, this);
        }

        private void Unload() => SaveData();

        private void OnServerSave()
        {
            if (changed)
            {
                SaveData();
                changed = false;
            }
        }

        private void OnUserConnected(IPlayer iPlayer)
        {
            if (playerData.ContainsKey(iPlayer.Id))
            {
                if (!playerData[iPlayer.Id].Contains(iPlayer.Name))
                {
                    playerData[iPlayer.Id].Add(iPlayer.Name);
                    changed = true;
                }
            }
            else
            {
                playerData.Add(iPlayer.Id, new HashSet<string>() { iPlayer.Name });
                changed = true;
            }
        }

        private string GetPlayerNames(string playerID)
        {
            if (playerData.ContainsKey(playerID))
            {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.AppendLine(Lang("Prefix", playerID, playerID));
                foreach (var name in playerData[playerID])
                    stringBuilder.AppendLine(Lang("Name", playerID, name));
                return stringBuilder.ToString();
            }
            return string.Empty;
        }

        #region Command

        [Command("name")]
        private void CmdName(IPlayer iPlayer, string command, string[] args)
        {
            if (!iPlayer.IsAdmin && !iPlayer.HasPermission(PERMISSION_USE))
            {
                iPlayer.Message(Lang("NotAllowed", iPlayer.Id));
                return;
            }
            var target = args.Length == 0 ? iPlayer : players.FindPlayer(args[0]);
            if (target == null)
            {
                iPlayer.Message(Lang("PlayerNotFound", iPlayer.Id, args[0]));
                return;
            }
            var names = GetPlayerNames(target.Id);
            if (string.IsNullOrEmpty(names)) iPlayer.Message(Lang("DataNotFound", target.Id, target.Name));
            else iPlayer.Message(names);
        }

        #endregion Command

        #region DataFile

        private Dictionary<string, HashSet<string>> playerData = new Dictionary<string, HashSet<string>>();

        private void LoadData()
        {
            try
            {
                playerData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, HashSet<string>>>(Name);
            }
            catch
            {
                playerData = new Dictionary<string, HashSet<string>>();
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, playerData);

        #endregion DataFile

        #region LanguageFile

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You do not have permission to use this command.",
                ["Name"] = "{0}",
                ["Prefix"] = "'{0}' used names: ",
                ["DataNotFound"] = "Name data of player '{0}' was not found.",
                ["PlayerNotFound"] = "Player '{0}' not found."
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "您没有权限使用该命令",
                ["Name"] = "{0}",
                ["Prefix"] = "'{0}' 使用过的名字:",
                ["DataNotFound"] = "没有找到玩家 '{0}' 的名字数据",
                ["PlayerNotFound"] = "玩家 '{0}' 没有找到"
            }, this, "zh-CN");
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion LanguageFile
    }
}

// --- End of file: PlayerNames.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pvp-indicator ---
// --- Original File Path: P/PVPIndicator/PVPIndicator.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("PVPIndicator", "Orange", "1.2.0")]
    [Description("Makes logo on entering PVP zones or PVP mode")]
    public class PVPIndicator : RustPlugin
    {
        #region Vars

        [PluginReference] private Plugin ZoneManager;

        #endregion
        
        #region Oxide Hooks
        
        private void Unload()
        {
            OnEnd();
        }

        private void OnEnterZone(string ZoneID, BasePlayer player)
        {
            CheckZone(ZoneID, player, false);
        }

        private void OnExitZone(string ZoneID, BasePlayer player)
        {
            CheckZone(ZoneID, player, true);
        }

        #endregion

        #region Helpers

        private void OnEnd()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyGUI(player);
            }
        }
        
        private void CheckZone(string ZoneID, BasePlayer player, bool leave)
        {
            var name = ZoneManager?.Call<string>("GetZoneName", ZoneID) ?? "null";
            if (name != "DynamicPVP") {return;}

            if (leave)
            {
                DestroyGUI(player, elem);
            }
            else
            {
                DynamicPVPGUI(player);
            }
        }

        #endregion
        
        #region Config

        private ConfigData config;
        
        private class ConfigData
        {
            [JsonProperty(PropertyName = "DynamicPVP settings")]
            public OGUIOptions DynamicPVP = new OGUIOptions();

            public class OGUIOptions
            {
                [JsonProperty(PropertyName = "Mininal Anchor (left bottom coordinate)")]
                public string anchorMin;
                
                [JsonProperty(PropertyName = "Maximal Anchor (right top coordinate)")]
                public string anchorMax;

                [JsonProperty(PropertyName = "Link to image that will pop up (url)")]
                public string link;

                [JsonProperty(PropertyName = "Color of image")]
                public string color;
            }
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                DynamicPVP = new ConfigData.OGUIOptions
                {
                    anchorMin = "0 0",
                    anchorMax = "0.1 0.1",
                    link = "https://i.imgur.com/JWrsJqI.jpg",
                    color = "1 1 1 1"
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region GUI

        private const string elem = "PVPIndicator.DynamicPVP";

        private void DynamicPVPGUI(BasePlayer player)
        {
            DestroyGUI(player, elem);
            
            var container = new CuiElementContainer();
            var cfg = config.DynamicPVP;

            container.Add(new CuiElement
            {
                Name = elem,
                Components =
                {
                    new CuiRawImageComponent {Url = cfg.link, Color = cfg.color},
                    new CuiRectTransformComponent {AnchorMin = cfg.anchorMin, AnchorMax = cfg.anchorMax},
                }
            });

            CuiHelper.AddUi(player, container);
        }

        private void DestroyGUI(BasePlayer player, string element = null)
        {
            if (element == null)
            {
                CuiHelper.DestroyUi(player, elem);
                return;
            }

            CuiHelper.DestroyUi(player, element);
        }

        #endregion
    }
}

// --- End of file: PVPIndicator.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pvp-stats ---
// --- Original File Path: P/PVPStats/PVPStats.cs ---

﻿using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("PVP Stats", "Dana", "1.4.7")]
    class PVPStats : RustPlugin
    {
        #region Declaration

        static PVPStats ins;
        static Dictionary<ulong, PVPStatsData> cachedPlayerStats = new Dictionary<ulong, PVPStatsData>();
        private const string AdminPermission = "pvpstats.admin";
        #endregion

        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PlayerStatisticsMSG"] = "<size=13><color=#ffc300>PVP STATS</color></size>\n<size=12><color=#ffc300>{0}</color> Kills. <color=#ffc300>{1}</color> Deaths. <color=#ffc300>{2}</color> KD Ratio.</size>",
                ["PlayerStatisticsAdminMSG"] = "<size=13><color=#ffc300>PVP STATS</color></size>\n<size=12><color=#13ffa2>{0}</color> • {1}\n\n<color=#ffc300>{2}</color> Kills. <color=#ffc300>{3}</color> Deaths. <color=#ffc300>{4}</color> KD Ratio.</size>",
                ["PlayerStatisticsConsoleMSG"] = "{0} {1} Kills. {2} Deaths. {3} KD.",
                ["ConsoleWipeMSG"] = "{0} Players PVP Stats were wiped",
                ["ConsoleResetMSG"] = "{0} PVP Stats has been reset",
                ["ConsoleNotFoundMSG"] = "{0} not found",
                ["PlayerNotFound"] = "Player not found",
                ["NoPermission"] = "You don't have permission to use this command"
            }, this);
        }

        private void OnServerInitialized()
        {
            ins = this;
            permission.RegisterPermission(AdminPermission, this);
            foreach (BasePlayer player in BasePlayer.activePlayerList) OnPlayerInit(player);
        }

        private void OnPlayerInit(BasePlayer player) => PVPStatsData.TryLoad(player.userID);

        private void OnPlayerDeath(BasePlayer victim, HitInfo info)
        {
            BasePlayer killer = info?.Initiator as BasePlayer;

            if (killer == null || killer == victim) return;
            if (victim.IsNpc || killer.IsNpc) return;

            if (cachedPlayerStats.ContainsKey(killer.userID)) cachedPlayerStats[killer.userID].Kills++;
            if (cachedPlayerStats.ContainsKey(victim.userID)) cachedPlayerStats[victim.userID].Deaths++;

            return;
        }

        private void OnServerShutDown() => Unload();

        private void Unload()
        {
            foreach (var data in cachedPlayerStats) data.Value.Save(data.Key);
        }

        #endregion

        #region Commands

        [ConsoleCommand("stats.wipe")]
        private void WipeStatsCmd(ConsoleSystem.Arg arg)
        {
            if (!arg.IsRcon) return;

            GetAllPlayers().ForEach(ID => PVPStatsData.Reset(ID));
            PrintWarning(string.Format(msg("ConsoleWipeMSG"), new object[] { GetAllPlayers().Count }));
        }

        [ConsoleCommand("stats.reset")]
        private void ResetStatsCmd(ConsoleSystem.Arg arg)
        {
            if (!arg.IsRcon) return;
            if (!arg.HasArgs()) return;

            if (arg.Args.Count() != 1)
            {
                PrintWarning($"Usage : stats.reset <SteamID64>");
                return;
            }

            string ID = arg.Args[0];

            if (!ID.IsSteamId())
            {
                PrintWarning(string.Format(msg("ConsoleNotFoundMSG"), new object[] { ID }));
                return;
            }

            string Name = GetPlayer(ulong.Parse(ID));

            PrintWarning(string.Format(msg("ConsoleResetMSG"), new object[] { Name }));
        }

        [ConsoleCommand("stats")]
        private void ShowStatisticsCmd(ConsoleSystem.Arg arg)
        {
            if (!arg.IsRcon) return;
            if (!arg.HasArgs()) return;

            if (arg.Args.Count() != 1)
            {
                PrintWarning($"Usage : stats <SteamID64>");
                return;
            }

            var player = BasePlayer.FindAwakeOrSleeping(arg.Args[0]);
            if (player == null)
            {
                PrintWarning(msg("PlayerNotFound"));
            }
            if (!cachedPlayerStats.ContainsKey(player.userID))
                PVPStatsData.TryLoad(player.userID);
            PrintWarning(string.Format(msg("PlayerStatisticsConsoleMSG"), $"{player.displayName}[{player.userID}]", cachedPlayerStats[player.userID].Kills, cachedPlayerStats[player.userID].Deaths, cachedPlayerStats[player.userID].KDR));
        }

        [ChatCommand("stats")]
        private void cmdShowStatistics(BasePlayer player, string command, string[] args)
        {
            var targetPlayerId = player.userID;
            BasePlayer targetPlayer = null;
            if (args.Length > 0)
            {
                if (!permission.UserHasPermission(player.UserIDString, AdminPermission))
                {
                    PlayerMsg(player, string.Format(msg("NoPermission", player.userID)));
                    return;
                }

                var nameOrId = args[0];
                targetPlayer = BasePlayer.FindAwakeOrSleeping(nameOrId);
                if (targetPlayer == null)
                {
                    PlayerMsg(player, string.Format(msg("PlayerNotFound", player.userID)));
                    return;
                }
                targetPlayerId = targetPlayer.userID;
            }
            if (!cachedPlayerStats.ContainsKey(targetPlayerId))
                PVPStatsData.TryLoad(targetPlayerId);
            if (targetPlayer != null)
            {
                PlayerMsg(player, string.Format(msg("PlayerStatisticsAdminMSG", player.userID), targetPlayer.displayName, targetPlayer.userID, cachedPlayerStats[targetPlayerId].Kills, cachedPlayerStats[targetPlayerId].Deaths, cachedPlayerStats[targetPlayerId].KDR));
            }
            else
            {
                PlayerMsg(player, string.Format(msg("PlayerStatisticsMSG", player.userID), new object[] { cachedPlayerStats[targetPlayerId].Kills, cachedPlayerStats[targetPlayerId].Deaths, cachedPlayerStats[targetPlayerId].KDR }));
            }
        }

        #endregion

        #region Methods

        public List<ulong> GetAllPlayers()
        {
            List<ulong> PlayersID = new List<ulong>();
            covalence.Players.All.ToList().ForEach(IPlayer => PlayersID.Add(ulong.Parse(IPlayer.Id)));
            return PlayersID;
        }

        public string GetPlayer(ulong id)
        {
            IPlayer player = covalence.Players.FindPlayerById(id.ToString());
            if (player == null) return string.Empty;
            return player.Name;
        }

        public void PlayerMsg(BasePlayer player, string msg) => SendReply(player, msg);

        #endregion

        #region Classes

        private class PVPStatsData
        {
            public int Kills = 0;
            public int Deaths = 0;
            public float KDR => Deaths == 0 ? Kills : (float)Math.Round(((float)Kills) / Deaths, 2);

            internal static void TryLoad(ulong id)
            {
                if (cachedPlayerStats.ContainsKey(id)) return;

                PVPStatsData data = Interface.Oxide.DataFileSystem.ReadObject<PVPStatsData>($"PVPStats/{id}");

                if (data == null) data = new PVPStatsData();

                cachedPlayerStats.Add(id, data);
            }

            internal static void Reset(ulong id)
            {
                PVPStatsData data = Interface.Oxide.DataFileSystem.ReadObject<PVPStatsData>($"PVPStats/{id}");

                if (data == null) return;

                data = new PVPStatsData();
                data.Save(id);
            }

            internal void Save(ulong id) => Interface.Oxide.DataFileSystem.WriteObject(($"PVPStats/{id}"), this, true);
        }

        #endregion

        #region Localization

        public string msg(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId != 0U ? playerId.ToString() : null);

        #endregion
    }
}

// --- End of file: PVPStats.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pollless ---
// --- Original File Path: P/Pollless/Pollless.cs ---

﻿using Oxide.Core;
using System;
using Newtonsoft.Json;
using System.Collections.Generic;
using Rust;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Pollless", "Kechless", "0.0.4")]
    [Description("Players can vote for certain things.")]
    class Pollless : RustPlugin
    {
        #region Variables
        //PERMISSIONS
        const string permission_create = "Pollless.create";
        const string permission_delete = "Pollless.delete";
        const string permission_show = "Pollless.show";

        const string permission_vote = "Pollless.vote";

        const string mainFolder = "Pollless/";
        const string mainFile = "Poll_list";
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Error_Insuffarg"] = "Insufficient arguments!",
                ["Cmd_Noperm"] = "You don't have the permsission to do that!",
                ["Error_NameExists"] = "Name you've chosen already exists.",
                ["Error_Number"] = "ERROR: usage /poll show [PAGENUMBER]",
                ["Error_PollNotFound"] = "ERROR: Poll not found!",
                ["Cmd_AlreadyVoted"] = "You have already voted for this poll.",
                ["Error_UsageVote"] = "ERROR: usage /poll vote [POLLINDEX] [YES/NO]",

            }, this);
        }
        #endregion

        #region Config
        private void Init()
        {
            permission.RegisterPermission(permission_create, this);
            permission.RegisterPermission(permission_delete, this);
            permission.RegisterPermission(permission_show, this);
            permission.RegisterPermission(permission_vote, this);

        }

        #endregion

        #region Commands

        // When player do /vote ...
        [ChatCommand("poll")]
        void pollCommand(BasePlayer player, string command, string[] args)
        {
            if (args.Length != 0)
            {
                switch (args[0].ToLower())
                {
                    case "show":
                        if (hasPerm(player, permission_show))
                        {
                            if (args[1] != null)
                            {
                                int number;
                                if (int.TryParse(args[1], out number))
                                {
                                    showPollList(player, number);
                                }
                                else
                                {
                                    SendMessage(player, "Erorr_Number");
                                }


                            }
                        }
                        break;

                    case "create":
                        if (hasPerm(player, permission_create))
                        {
                            if (args[1] != null && args[2] != null)
                            {
                                try
                                {
                                    createPoll(args[1], args[2], player.displayName);
                                }
                                catch (ArgumentException e)
                                {
                                    PrintToChat(player, e.Message);
                                }
                            }
                            else
                            {

                            }
                        }
                        break;
                    case "delete":
                        if (hasPerm(player, permission_delete))
                        {
                            if (args[1] != null)
                            {

                                int number;
                                if (int.TryParse(args[1], out number))
                                {
                                    deletePoll(number);
                                }
                                else
                                {
                                    SendMessage(player, "Erorr_Number");
                                }
                            }
                        }
                        break;
                    case "info":
                        if (hasPerm(player, permission_show))
                        {
                            if (args[1] != null)
                            {
                                int number;
                                if (int.TryParse(args[1], out number))
                                {
                                    getInfoPollByIndex(number);
                                }
                                else
                                {
                                    SendMessage(player, "Erorr_Number");
                                }
                            }
                        }

                        break;
                    case "vote":
                        if (hasPerm(player, permission_vote))
                        {
                            if (args[1] != null && args[2] != null)
                            {
                                int number;
                                if (int.TryParse(args[1], out number))
                                {
                                    votePollByIndex(player, number, args[2]);
                                }
                                else
                                {
                                    SendMessage(player, "Erorr_Number");
                                }

                            }
                        }

                        break;
                }
            }

            else
            {
                SendMessage(player, "Error_Insuffarg");
            }
        }

        #endregion

        #region Hooks

        #endregion

        #region Methodes

        public void votePollByIndex(BasePlayer player, int index, string vote)
        {
            Poll votedPoll = getPollByindex(index);
            if (votedPoll != null)
            {
                if (!votedPoll.hasVoted(player.UserIDString))
                {
                    if (vote.ToLower() == "yes")
                    {
                        votedPoll.addYesVote(player.UserIDString);
                        UpdatePoll(votedPoll, index);

                    }
                    else if (vote.ToLower() == "no")
                    {
                        votedPoll.addNoVote(player.UserIDString);
                        UpdatePoll(votedPoll, index);

                    }
                    else
                    {
                        SendMessage(player, "Error_UsageVote");
                    }
                }
                else
                {
                    SendMessage(player, "Cmd_AlreadyVoted");
                }
            }
            else
            {
                SendMessage(player, "Error_PollNotFound");
            }

        }



        public void getInfoPollByIndex(int index)
        {
            Poll selectedPoll = getPollByindex(index);
            string infoText =
                "Name: " + selectedPoll.getPollName() + Environment.NewLine +
                "Content: " + selectedPoll.getContent() + Environment.NewLine +
                "Creator: " + selectedPoll.getCreator() + Environment.NewLine +
                "Use /poll vote [POLL_INDEX] [YES/NO]" + Environment.NewLine;

        }

        public void votePoll(int index, Boolean voting, string playerID)
        {
            Poll currentPoll = getPollByindex(index);
            if (voting)
            {
                currentPoll.addYesVote(playerID);
            }
            else
            {
                currentPoll.addNoVote(playerID);
            }
            UpdatePoll(currentPoll, index);
        }

        public void UpdatePoll(Poll item, int index)
        {
            List<Poll> list = getPolls();
            list[index] = item;
            updatePollList(list);
        }

        public Poll getPollByindex(int index)
        {
            try
            {
                return getPolls().ElementAt(index);
            }
            catch (ArgumentOutOfRangeException)
            {
                return null;
            }
        }

        // Deletes a poll by given index.
        public void deletePoll(int index)
        {
            List<Poll> oldList = getPolls();
            oldList.RemoveAt(index);
            updatePollList(oldList);
        }

        // Shows all polls
        public void showPollList(BasePlayer player, int page)
        {
            List<Poll> polls = getPolls();
            List<string> list = new List<string>();
            double x = polls.Count / 5;
            int count = (5 * page) - 5;
            int maxPage = Convert.ToInt32(Math.Ceiling(x));
            for (int i = count; i < 5; i++)
            {
                if (polls[i] != null)
                {
                    list.Add("Index: " + polls.IndexOf(polls[i]) + " " + polls[i].ToString());
                }
                else
                {
                    list.Add("----------------" + Environment.NewLine);
                }
            }
            list.Add("Page " + page + "of " + maxPage);
            SendListMessage(player, list);
        }

        // creating a new poll with name check.
        public void createPoll(string pollName, string content, string creator)
        {
            if (!checkPollName(pollName))
            {
                Poll newPoll = new Poll(pollName, content, creator, DateTime.Now);
                addToPollList(newPoll);
            }
            else
            {
                throw new ArgumentException(lang.GetMessage("Error_NameExists", this));
            }
        }

        // checks whether the chosen name exists
        public Boolean checkPollName(string pollName)
        {
            foreach (Poll item in getPolls())
            {
                if (pollName == item.getPollName())
                {
                    return true;
                }
            }
            return false;
        }

        // get the list of the file.
        public List<Poll> getPolls()
        {
            List<Poll> loadedPolls;
            // check if the file exists or a new one will be created.
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(mainFolder + mainFile))
            {
                loadedPolls = new List<Poll>();
                updatePollList(loadedPolls);
            }
            else
            {
                string raw_poll_file = Interface.Oxide.DataFileSystem.ReadObject<string>(mainFolder + mainFile);
                loadedPolls = JsonConvert.DeserializeObject<List<Poll>>(raw_poll_file);
            }
            return loadedPolls;
        }

        //Rewrites the poll_file
        public void updatePollList(List<Poll> list)
        {
            Interface.Oxide.DataFileSystem.WriteObject<string>(mainFolder + mainFile, JsonConvert.SerializeObject(list));
        }

        // adds a new poll to the list
        public void addToPollList(Poll newPoll)
        {
            List<Poll> currentList = getPolls();
            currentList.Add(newPoll);
            updatePollList(currentList);
        }

        #endregion

        #region Classes
        public class Poll
        {
            private string _pollName;
            private string _content;
            private string _creator;

            private DateTime _dateOfCreation;

            private List<string> _yesVotes;
            private List<string> _noVotes;


            public string getPollName()
            {
                return _pollName;
            }

            public string getContent()
            {
                return _content;
            }

            public string getCreator()
            {
                return _creator;
            }

            public void addYesVote(string playerID)
            {
                _yesVotes.Add(playerID);
            }

            public void addNoVote(string playerID)
            {
                _noVotes.Add(playerID);
            }

            public bool hasVoted(string PlayerID)
            {
                if (_yesVotes.Contains(PlayerID))
                {
                    return true;
                }
                else if (_noVotes.Contains(PlayerID))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }


            public Poll()
            {
            }

            [JsonConstructor]
            public Poll(string pollName, string content, string creator, DateTime date)
            {
                _pollName = pollName;
                _content = content;
                _creator = creator;
                _dateOfCreation = date;

                _yesVotes = new List<string>();
                _noVotes = new List<string>();
            }

            override
            public string ToString()
            {
                return "Name: " + _pollName + "Creator: " + _creator + "Creation: " + _dateOfCreation;
            }
        }

        #endregion

        #region Helpers
        public void SendMessage(BasePlayer player, string message)
        {
            PrintToChat(player, lang.GetMessage(message, this, player.UserIDString));
        }

        public void SendListMessage(BasePlayer player, List<string> list)
        {
            foreach (string item in list)
            {
                PrintToChat(player, item + Environment.NewLine);
            }
        }

        public bool hasPerm(BasePlayer player, string perm)
        {
            return permission.UserHasPermission(player.UserIDString, perm);
        }

        #endregion
    }
}


// --- End of file: Pollless.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/perfect-repair ---
// --- Original File Path: P/PerfectRepair/PerfectRepair.cs ---

﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Perfect Repair", "The Friendly Chap", "1.1.2")]
    [Description("Items will be fully repaired, removing the permanent penalty (red bar)")]
    public class PerfectRepair : RustPlugin
	
/*	MIT License

	©2024 The Friendly Chap

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/	
	
    {
        #region Oxide Hooks

        // Called when the server is fully initialized
        private void OnServerInitialized()
        {
            // Iterate over all item definitions in the game
            foreach (var def in ItemManager.itemList)
            {
                // Set maintainMaxCondition to true to ensure items maintain maximum condition
                def.condition.maintainMaxCondition = true;
            }
            
            // Print a warning to the server log about potential lag
            PrintWarning("All containers will be checked, it can cause small lag");

            // Start the coroutine to check and repair items in all containers
            ServerMgr.Instance.StartCoroutine(CheckContainers());
			// ShowLogo();
        }

        // Coroutine to check and repair items in all containers
        private IEnumerator CheckContainers()
        {
            // Iterate over all network entities on the server
            foreach (var bEntity in BaseNetworkable.serverEntities)
            {
                // Check if the entity is a storage container
                var container = bEntity.GetComponent<StorageContainer>();
                if (container != null)
                {
                    // Iterate over all items in the container's inventory
                    foreach (var item in container.inventory.itemList ?? new List<Item>())
                    {
                        // If the item has a condition, set its max condition and mark it as dirty
                        if (item.hasCondition)
                        {
                            item._maxCondition = item.info.condition.max;
                            item.MarkDirty();
                        }
                    }

                    // Wait for the next frame to avoid lag spikes
                    yield return new WaitForEndOfFrame();
                }

                // Check if the entity is a player
                var player = bEntity.GetComponent<BasePlayer>();
                if (player != null)
                {
                    // Iterate over all items in the player's inventory
                    foreach (var item in player.inventory.AllItems())
                    {
                        // If the item has a condition, set its max condition and mark it as dirty
                        if (item.hasCondition)
                        {
                            item._maxCondition = item.info.condition.max;
                            item.MarkDirty();
                        }
                    }

                    // Wait for the next frame to avoid lag spikes
                    yield return new WaitForEndOfFrame();
                }

                // Check if the entity is a lootable corpse
                var corpse = bEntity.GetComponent<LootableCorpse>();
                if (corpse != null)
                {
                    // Iterate over all items in the corpse's containers
                    foreach (var item in corpse.containers.SelectMany(x => x.itemList))
                    {
                        // If the item has a condition, set its max condition and mark it as dirty
                        if (item.hasCondition)
                        {
                            item._maxCondition = item.info.condition.max;
                            item.MarkDirty();
                        }
                    }

                    // Wait for the next frame to avoid lag spikes
                    yield return new WaitForEndOfFrame();
                }

                // Check if the entity is a dropped item
                var droppedItem = bEntity.GetComponent<DroppedItem>();
                if (droppedItem != null)
                {
                    // If the dropped item has a condition, set its max condition
                    if (droppedItem.item.hasCondition)
                    {
                        droppedItem.item._maxCondition = droppedItem.item.info.condition.max;
                    }

                    // Wait for the next frame to avoid lag spikes
                    yield return new WaitForEndOfFrame();
                }

                // Check if the entity is a dropped item container
                var droppedContainer = bEntity.GetComponent<DroppedItemContainer>();
                if (droppedContainer != null)
                {
                    // Iterate over all items in the dropped container's inventory
                    foreach (var item in droppedContainer.inventory.itemList)
                    {
                        // If the item has a condition, set its max condition and mark it as dirty
                        if (item.hasCondition)
                        {
                            item._maxCondition = item.info.condition.max;
                            item.MarkDirty();
                        }
                    }

                    // Wait for the next frame to avoid lag spikes
                    yield return new WaitForEndOfFrame();
                }

                // Yield at the end of each entity to avoid lag spikes
                yield return new WaitForEndOfFrame();
            }
        }
        		private void ShowLogo()
        {
			Puts(" _______ __               _______        __                 __ __             ______ __           ©2024");
			Puts("|_     _|  |--.-----.    |    ___|.----.|__|.-----.-----.--|  |  |.--.--.    |      |  |--.---.-.-----.");
			Puts("  |   | |     |  -__|    |    ___||   _||  ||  -__|     |  _  |  ||  |  |    |   ---|     |  _  |  _  |");
			Puts("  |___| |__|__|_____|    |___|    |__|  |__||_____|__|__|_____|__||___  |    |______|__|__|___._|   __|");
			Puts("                         Perfect Repair v1.1.1                    |_____| thefriendlychap.co.za |__|");      
        }  
        #endregion
    }
}


// --- End of file: PerfectRepair.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/powerless-turrets ---
// --- Original File Path: P/PowerlessTurrets/PowerlessTurrets.cs ---

using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Powerless Turrets", "August", "3.2.9")]
    [Description("Allows SAMs and autoturrets to operate without electricity")]
    public class PowerlessTurrets : RustPlugin
    {
        #region Fields

        private const string PermUse = "powerlessturrets.use";
        private const string PermUseRadius = "powerlessturrets.radius";
        private const string PermUseSamRadius = "powerlessturrets.samradius";

        private static PowerlessTurrets _instance;
        private TurretManager _turretManager;
        private PluginConfig _config;
        private PluginData _stored;

        #endregion

        #region PluginConfig

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<PluginConfig>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    PrintWarning($"PluginConfig file {Name}.json updated.");
                    SaveConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
                PrintError("Config file contains an error and has been replaced with the default file.");
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Range at which turrets can be toggled")]
            public float Range { get; set; }

            [JsonProperty(PropertyName = "Command for toggling individual turrets")]
            public string ToggleCommand { get; set; }

            [JsonProperty(PropertyName = "Command for toggling turrets in TC zone")]
            public string ToggleTcCommand { get; set; }

            [JsonProperty(PropertyName = "Command for toggling sams in TC zone")]
            public string ToggleSamTcCommand { get; set; }

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        private PluginConfig GetDefaultConfig()
        {

            return new PluginConfig
            {
                Range = 10f,
                ToggleCommand = "turret",
                ToggleTcCommand = "turret.tc",
                ToggleSamTcCommand = "sam.tc"
            };
        }

        #endregion

        #region PluginData

        private class PluginData
        {
            public List<ulong> AutoTurrets = new List<ulong>();
            public List<ulong> SamSites = new List<ulong>();
        }

        private void SaveData()
        {
            _stored.AutoTurrets = _turretManager.OnlineTurrets;
            _stored.SamSites = _turretManager.OnlineSams;

            Interface.Oxide.DataFileSystem.WriteObject(Name, _stored);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "TurretsToggled", "You have toggled {0} turrets." },
                { "NoPermission", "You do not have permission to use this command." },
                { "InvalidEntity", "This is not a valid entity." },
                { "NoTurretsFound", "There are no valid turrets in your area." },
                { "NoPermThisTurret", "You do not have permission to toggle this turret." },
                { "BuildingBlocked", "You do not have building privilege." },
                { "Syntax", "Invalid syntax." }
            }, this);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion

        #region Hooks

        private void Init()
        {
            _instance = this;

            permission.RegisterPermission(PermUse, this);
            permission.RegisterPermission(PermUseRadius, this);
            permission.RegisterPermission(PermUseSamRadius, this);

            cmd.AddChatCommand(_config.ToggleCommand, this, nameof(TurretCommand));
            cmd.AddChatCommand(_config.ToggleTcCommand, this, nameof(ToggleTurretsInTc));
            cmd.AddChatCommand(_config.ToggleSamTcCommand, this, nameof(ToggleSamsInTc));

            _stored = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name) ?? new PluginData();
        }

        private void OnServerInitialized()
        {
            _turretManager = new TurretManager();

            foreach (BaseEntity ent in BaseNetworkable.serverEntities)
            {
                if (ent is AutoTurret)
                {
                    if (_stored.AutoTurrets.Contains(ent.net.ID.Value))
                    {
                        _turretManager.PowerTurretOn(ent as AutoTurret);
                    }
                }
                else if (ent is SamSite)
                {
                    if (_stored.SamSites.Contains(ent.net.ID.Value))
                    {
                        _turretManager.PowerSamsiteOn(ent as SamSite);
                    }
                }
            }
        }

        private void Unload()
        {
            _instance = null;
        }

        private void OnServerSave() => SaveData();

        #endregion

        #region Commands

        private void TurretCommand(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermUse))
            {
                player.ChatMessage(Lang("NoPermission", player.UserIDString));
                return;
            }

            RaycastHit raycastHit;
            if (!Physics.Raycast(player.eyes.position, player.eyes.rotation * Vector3.forward, out raycastHit, _config.Range))
            {
                return;
            }

            BaseEntity entity = raycastHit.GetEntity();
            if (entity is AutoTurret)
            {
                _turretManager.ToggleTurret(entity as AutoTurret, player);
                return;
            }

            if (entity is SamSite)
            {
                _turretManager.ToggleSamsite(entity as SamSite, player);
                return;
            }

            player.ChatMessage(Lang("InvalidEntity", player.UserIDString));
        }

        private void ToggleTurretsInTc(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermUseRadius))
            {
                player.ChatMessage(Lang("NoPermission", player.UserIDString));
                return;
            }

            if (args.Length != 1)
            {
                player.ChatMessage(Lang("Syntax", player.UserIDString));
                return;
            }

            string arg0 = args[0].ToLower();

            if (!(arg0 == "on" || arg0.ToLower() == "off"))
            {
                player.ChatMessage(Lang("Syntax", player.UserIDString));
                return;
            }

            _turretManager.ToggleTurretsInTcRange(player, arg0);
        }

        private void ToggleSamsInTc(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermUseRadius))
            {
                player.ChatMessage(Lang("NoPermission", player.UserIDString));
                return;
            }

            if (args.Length != 1)
            {
                player.ChatMessage(Lang("Syntax", player.UserIDString));
                return;
            }

            string arg0 = args[0].ToLower();

            if (!(arg0 == "on" || arg0.ToLower() == "off"))
            {
                player.ChatMessage(Lang("Syntax", player.UserIDString));
                return;
            }

            _turretManager.ToggleSamsInTcRange(player, arg0);
        }

        #endregion

        #region Turret Manager

        private class TurretManager
        {
            #region Auto Turrets

            private readonly List<AutoTurret> _onlineTurrets = new List<AutoTurret>();

            public List<ulong> OnlineTurrets
            {
                get
                {
                    List<ulong> ids = new List<ulong>();

                    foreach (AutoTurret turret in _onlineTurrets)
                    {
                        if (turret.net != null)
                        {
                            ids.Add(turret.net.ID.Value);
                        }
                    }

                    return ids;
                }

                private set { }
            }

            public void ToggleTurret(AutoTurret turret, BasePlayer player = null)
            {
                if (turret == null)
                {
                    return;
                }

                if (player != null && (!turret.IsAuthed(player) || turret.GetBuildingPrivilege()?.IsAuthed(player) == false))
                {
                    player.ChatMessage(_instance.Lang("NoPermThisTurret", player.UserIDString));
                    return;
                }

                if (turret.IsOnline())
                {
                    PowerTurretOff(turret);
                }
                else
                {
                    PowerTurretOn(turret);
                }
            }

            public void PowerTurretOn(AutoTurret turret)
            {
                turret.SetFlag(BaseEntity.Flags.Reserved8, true);
                turret.InitiateStartup();
                turret.UpdateFromInput(11, 0);

                if (!_onlineTurrets.Contains(turret))
                {
                    _onlineTurrets.Add(turret);
                }
            }

            private void PowerTurretOff(AutoTurret turret)
            {
                turret.SetFlag(BaseEntity.Flags.Reserved8, false);
                turret.InitiateShutdown();
                turret.UpdateFromInput(0, 0);

                if (_onlineTurrets.Contains(turret))
                {
                    _onlineTurrets.Remove(turret);
                }
            }

            public void ToggleTurretsInTcRange(BasePlayer player, string arg)
            {
                List<AutoTurret> turretList = Pool.GetList<AutoTurret>();

                foreach (AutoTurret turret in BaseNetworkable.serverEntities.OfType<AutoTurret>())
                {
                    if (turret?.GetBuildingPrivilege()?.IsAuthed(player) == true && turret.GetBuildingPrivilege() == player.GetBuildingPrivilege() == true)
                    {
                        turretList.Add(turret);
                    }
                }

                if (turretList.Count < 1)
                {
                    return;
                }

                foreach (AutoTurret turret in turretList)
                {
                    if (arg == "on")
                    {
                        PowerTurretOn(turret);
                    }
                    else
                    {
                        PowerTurretOff(turret);
                    }
                }

                player.ChatMessage(_instance.Lang("TurretsToggled", player.UserIDString, turretList.Count));

                Pool.FreeList(ref turretList);
            }

            #endregion

            #region Sam Turrets

            private readonly List<SamSite> _onlineSams = new List<SamSite>();

            public List<ulong> OnlineSams
            {
                get
                {
                    List<ulong> ids = new List<ulong>();

                    foreach (SamSite sam in _onlineSams)
                    {
                        if (sam.net != null)
                        {
                            ids.Add(sam.net.ID.Value);
                        }
                    }

                    return ids;
                }

                private set { }
            }

            public void ToggleSamsite(SamSite samSite, BasePlayer player = null)
            {
                if (samSite == null)
                {
                    return;
                }

                if (player != null && samSite.GetBuildingPrivilege()?.IsAuthed(player) == false)
                {
                    player.ChatMessage(_instance.Lang("NoPermThisTurret", player.UserIDString));
                    return;
                }

                if (samSite.IsPowered())
                {
                    PowerSamsiteOff(samSite);
                }
                else
                {
                    PowerSamsiteOn(samSite);
                }

                samSite.SendNetworkUpdate();
            }

            public void PowerSamsiteOn(SamSite sam)
            {
                sam.UpdateHasPower(25, 0);
                sam.SetFlag(BaseEntity.Flags.Reserved8, true);
                if (!_onlineSams.Contains(sam))
                {
                    _onlineSams.Add(sam);
                }
            }

            private void PowerSamsiteOff(SamSite sam)
            {
                sam.UpdateHasPower(0, 0);
                sam.SetFlag(BaseEntity.Flags.Reserved8, false);
                if (_onlineSams.Contains(sam))
                {
                    _onlineSams.Remove(sam);
                }
            }

            public void ToggleSamsInTcRange(BasePlayer player, string arg)
            {
                List<SamSite> samSiteList = Pool.GetList<SamSite>();

                foreach (SamSite sam in BaseNetworkable.serverEntities.OfType<SamSite>())
                {
                    if (sam?.GetBuildingPrivilege()?.IsAuthed(player) == true && sam.GetBuildingPrivilege() == player.GetBuildingPrivilege())
                    {
                        samSiteList.Add(sam);
                    }
                }

                if (samSiteList.Count < 1)
                {
                    return;
                }

                foreach (SamSite sam in samSiteList)
                {
                    if (arg == "on")
                    {
                        PowerSamsiteOn(sam);
                    }
                    else
                    {
                        PowerSamsiteOff(sam);
                    }
                }

                player.ChatMessage(_instance.Lang("TurretsToggled", player.UserIDString, samSiteList.Count));

                Pool.FreeList(ref samSiteList);
            }

            #endregion
        }

        #endregion
    }
}

// --- End of file: PowerlessTurrets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/plugin-update-notifications ---
// --- Original File Path: P/PluginUpdateNotifications/PluginUpdateNotifications.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info("Plugin Update Notifications", "Whispers88", "1.1.0")]
    [Description("Checks Umod plugins for updates")]
    public class PluginUpdateNotifications : CovalencePlugin
    {
        private const string vurl = "https://umod.org/plugins/{0}/versions.json";
        private IEnumerator coroutine;
        private List<string> mismatchedplugins = new List<string>();

        #region Configuration
        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Frequency to check for updates (hours)")]
            public float CheckFrequency = 12f;

            [JsonProperty("Ignore lower versions (ignores when the official version is a lower version number)")]
            public bool IgnoreLowVer = true;

            [JsonProperty("Check Unloaded Plugins")]
            public bool CheckUnloadedPlugins = false;

            [JsonProperty("Enable Discord Notifications")]
            public bool DiscordNotifications = false;

            [JsonProperty("Discord Webhook URL")]
            public string DiscordWebhookURL = "https://discordapp.com/api/webhooks";

            [JsonProperty("Avatar URL")]
            public string AvatarUrl = "https://i.imgur.com/poRMpyf.png";

            [JsonProperty("Discord Username")]
            public string DiscordUsername = "Plugin Update Notifications";

            [JsonProperty("Automatic Blacklist")]
            public bool AutomaticBacklist = true;

            [JsonProperty("Blacklist of plugins names not to check", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> BlacklistedPlugins = new List<string>() { "RustIO" };

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    Puts("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                Puts($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ErrorLocation"] = "Cannot locate {0} plugin on uMod",
                ["VersionMismatch"] = "{0} version mismatch current {1} uMod Version {2}",
                ["AlreadyRunning"] = "Already Checking for updates",
                //Commands
                ["CheckForUpdatesCommand"] = "CheckforUpdates"

            }, this);
        }

        #endregion Localization

        #region Commands

        private void CheckForUpdatesCommand(IPlayer iplayer, string command, string[] args)
        {
            if (!iplayer.IsServer) return;
            if (coroutine != null)
            {
                PrintError(GetLang("AlreadyRunning", null));
                return;
            }
            coroutine = CheckForUpdates();
            ServerMgr.Instance.StartCoroutine(coroutine);

        }
        #endregion

        #region Core

        void OnServerInitialized()
        {
            AddLocalizedCommand(nameof(CheckForUpdatesCommand));
            coroutine = CheckForUpdates();
            ServerMgr.Instance.StartCoroutine(coroutine);
            timer.Every(config.CheckFrequency * 3600f, () => {
                if (coroutine != null)
                {
                    PrintError(GetLang("AlreadyRunning", null));
                    return;
                }
                coroutine = CheckForUpdates();
                ServerMgr.Instance.StartCoroutine(coroutine);
            });
        }

        private void Unload()
        {
            if (coroutine != null)
                ServerMgr.Instance.StopCoroutine(coroutine);
        }

        private IEnumerator CheckForUpdates()
        {
            var pluginslist = plugins.GetAll().ToList();
            for (int i = 0; i < pluginslist.Count; i++)
            {
                var plugin = pluginslist[i];
                if (!config.CheckUnloadedPlugins && !plugin.IsLoaded || config.BlacklistedPlugins.Contains(plugin.Name) || plugin.IsCorePlugin) continue;

                string downloadHandler;
                UnityWebRequest www = UnityWebRequest.Get(string.Format(vurl, plugin.Name));
                www.SetRequestHeader("Content-Type", "application/json");
                yield return www.SendWebRequest();

                // Verify that the webrequest was succesful.
                if (www.isNetworkError || www.isHttpError)
                {
                    // The webrequest wasn't succesful, print error
                    if (!www.error.ToString().Contains("Too Many Requests"))
                    {
                        PrintError(GetLang("ErrorLocation", null, plugin.Name));
                        if (config.AutomaticBacklist)
                            config.BlacklistedPlugins.Add(plugin.Name);
                        www.Dispose();
                        continue;
                    }
                    www.Dispose();
                    PrintError("waiting 30 seconds for rate limit");
                    i--;
                    yield return new WaitForSeconds(30f);
                    continue;
                }

                downloadHandler = www.downloadHandler.text;

                var json = JsonConvert.DeserializeObject<Root>(downloadHandler);
                string umodversion = json.data[0].version;
                string pluginversion = plugin.Version.ToString();
                //Have to substring here to remove quotations
                umodversion.Substring(1, umodversion.Length - 1);
                if (umodversion.Length < pluginversion.Length)
                    pluginversion = pluginversion.Substring(0, umodversion.Length);

                if (umodversion.Length > pluginversion.Length)
                {
                    string[] umodnums = umodversion.Split('.');
                    for (int j = 0; j < umodnums.Length; j++)
                    {
                        if (umodnums[j].Length > 1 && umodnums[j].First().ToString() == "0")
                        {
                            umodnums[j] = umodnums[j].TrimStart('0');
                        }
                    }
                    umodversion = string.Join(".", umodnums);
                }
                var uModV = new Version();
                var pluginV = new Version();
                if (config.IgnoreLowVer)
                {
                    if (System.Version.TryParse(umodversion, out uModV) && System.Version.TryParse(pluginversion, out pluginV))
                    {
                        if (pluginV.CompareTo(uModV) >= 0)
                            continue;
                    }
                }

                if (umodversion != pluginversion && !mismatchedplugins.Contains(plugin.Name))
                {
                    mismatchedplugins.Add(plugin.Name);
                    PrintWarning(GetLang("VersionMismatch", null, plugin.Name, plugin.Version.ToString(), umodversion));
                    if (config.DiscordNotifications)
                    {
                        var msg = DiscordMessage(ConVar.Server.hostname, plugin.Name, plugin.Version.ToString(), umodversion, StripMarkUp(json.data[0].description), DateTime.UtcNow.ToString());
                        string jsonmsg = JsonConvert.SerializeObject(msg);
                        UnityWebRequest wwwpost = new UnityWebRequest(config.DiscordWebhookURL, "POST");
                        byte[] jsonToSend = new System.Text.UTF8Encoding().GetBytes(jsonmsg.ToString());
                        wwwpost.uploadHandler = (UploadHandler)new UploadHandlerRaw(jsonToSend);
                        wwwpost.SetRequestHeader("Content-Type", "application/json");
                        yield return wwwpost.SendWebRequest();

                        if (wwwpost.isNetworkError || wwwpost.isHttpError)
                        {
                            PrintError(wwwpost.error);
                        }
                        wwwpost.Dispose();
                    }
                }
                else if (mismatchedplugins.Contains(plugin.Name))
                {
                    mismatchedplugins.Remove(plugin.Name);
                }
                yield return new WaitForSeconds(0.5f);
            }
            if (config.AutomaticBacklist)
                SaveConfig();

            coroutine = null;
        }

        #endregion Core

        #region Helpers
        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private Message DiscordMessage(string servername, string pluginname, string curversion, string umodversion, string umodchanges, string time)
        {
            var fields = new List<Message.Fields>()
            {
                new Message.Fields("Current Version", curversion, false),
                new Message.Fields("Umod Version", umodversion, false),
                new Message.Fields("Changes ", umodchanges, false),
                new Message.Fields("Umod Link", "https://umod.org/plugins/" + pluginname, false)
            };
            var footer = new Message.Footer($"Logged @{DateTime.UtcNow:dd/MM/yy HH:mm:ss}");
            var embeds = new List<Message.Embeds>()
            {
                new Message.Embeds("Server - " + servername, "Found an update for " + pluginname, fields, footer)
            };
            Message msg = new Message(config.DiscordUsername, config.AvatarUrl, embeds);
            return msg;
        }

        private static string StripMarkUp(string value)
        {
            value.Replace("/", string.Empty);
            value = Regex.Replace(value, "<.*?>", String.Empty);
            if (value.Length > 1024)
            {
                value = value.Substring(0, 1020) + "..";
            }
            return value;
        }

        #endregion Helpers

        #region Umod Class
        public class Datum
        {
            public string version { get; set; }
            public string description { get; set; }
            public int visible { get; set; }
            public string checksum { get; set; }
            public object tags { get; set; }
            public int downloads { get; set; }
            public string created_at { get; set; }
            public string description_md { get; set; }
            public string download_url { get; set; }
            public string revert_url { get; set; }
            public string toggle_url { get; set; }
            public string delete_url { get; set; }
            public string edit_url { get; set; }
            public bool is_latest { get; set; }
            public string text_class { get; set; }
            public bool revertable { get; set; }
            public string toggle_icon { get; set; }
            public string version_formatted { get; set; }
            public string downloads_shortened { get; set; }
            public string downloads_lang { get; set; }
            public DateTime created_at_atom { get; set; }
            public DateTime updated_at_atom { get; set; }

        }

        public class Root
        {
            public int current_page { get; set; }
            public List<Datum> data { get; set; }
            public string first_page_url { get; set; }
            public int from { get; set; }
            public int last_page { get; set; }
            public string last_page_url { get; set; }
            public object next_page_url { get; set; }
            public string path { get; set; }
            public int per_page { get; set; }
            public object prev_page_url { get; set; }
            public int to { get; set; }
            public int total { get; set; }

        }

        #endregion Umod Class

        #region Discord Class
        public class Message
        {
            public string username { get; set; }
            public string avatar_url { get; set; }
            public List<Embeds> embeds { get; set; }

            public class Fields
            {
                public string name { get; set; }
                public string value { get; set; }
                public bool inline { get; set; }
                public Fields(string name, string value, bool inline)
                {
                    this.name = name;
                    this.value = value;
                    this.inline = inline;
                }
            }

            public class Footer
            {
                public string text { get; set; }
                public Footer(string text)
                {
                    this.text = text;
                }
            }

            public class Embeds
            {
                public string title { get; set; }
                public string description { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Embeds(string title, string description, List<Fields> fields, Footer footer)
                {
                    this.title = title;
                    this.description = description;
                    this.fields = fields;
                    this.footer = footer;
                }
            }

            public Message(string username, string avatar_url, List<Embeds> embeds)
            {
                this.username = username;
                this.avatar_url = avatar_url;
                this.embeds = embeds;
            }
        }

        #endregion

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (!message.Key.Equals(command)) continue;

                    if (string.IsNullOrEmpty(message.Value)) continue;

                    AddCovalenceCommand(message.Value, command);
                }
            }
        }

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        #endregion Helpers
    }
}

// --- End of file: PluginUpdateNotifications.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-location ---
// --- Original File Path: P/PlayerLocation/PlayerLocation.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Player Location", "seacowz", "0.1.7")]
    [Description("Find the location of players on the server")]
    public class PlayerLocation : CovalencePlugin
    {
        #region Variables

        private class PlayerData
        {
            public DateTime lastawaketime { get; set; }
            public DateTime lastdeathtime { get; set; }
            public Vector3 lastdeathloc { get; set; }

            public PlayerData()
            {
                lastawaketime = DateTime.MinValue;
                lastdeathtime = DateTime.MinValue;
                lastdeathloc = Vector3.zero;
            }
        }
        
        private Dictionary<string, PlayerData> playerdict = new Dictionary<string, PlayerData>();

        private const string permAdmin = "playerlocation.admin";

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You do not have permission to use that command.",
                ["NotFound"] = "No players found.",
                ["Usage"] = "Usage: location [-d] [name|id]"
            }, this);
        }

        #endregion Localization

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(permAdmin, this);
            
            LoadDataFile();
            SaveDataFile();
        }

        private void OnPlayerSleep(BasePlayer player)
        {
            PlayerData playerdata;
            if (playerdict.TryGetValue(player.UserIDString, out playerdata))
            {
                playerdata.lastawaketime = DateTime.Now;
            }
            else
            {
                playerdata = new PlayerData();
                playerdata.lastawaketime = DateTime.Now;
                playerdict[player.UserIDString] = playerdata;
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            PlayerData playerdata;
            if (playerdict.TryGetValue(player.UserIDString, out playerdata))
            {
                playerdata.lastawaketime = DateTime.MinValue;
            }
            else
            {
                playerdata = new PlayerData();
                playerdata.lastawaketime = DateTime.MinValue;
                playerdict[player.UserIDString] = playerdata;
            }
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            PlayerData playerdata;
            Vector3 location = player.transform.position;
            if (playerdict.TryGetValue(player.UserIDString, out playerdata))
            {
                playerdata.lastdeathtime = DateTime.Now;
                playerdata.lastdeathloc = location;
            }
            else
            {
                playerdata = new PlayerData();
                playerdata.lastdeathtime = DateTime.Now;
                playerdata.lastdeathloc = location;
                playerdict[player.UserIDString] = playerdata;
            }
        }

        void Unload()
        {
            SaveDataFile();
        }

        #endregion hooks

        #region Commands

        [Command("location")]
        private void LocationCmd(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin))
            {
                player.Reply(lang.GetMessage("NoPermission", this, player.Id));
                return;
            }

            List<Tuple<double, string>> locationlist = new List<Tuple<double, string>>();
            switch (args.Length)
            {
                case 0:
                    FindLocation(player, string.Empty, ref locationlist);
                    break;
                case 1:
                    if (args[0] == "-d")
                    {
                        FindDLocation(player, string.Empty, ref locationlist);
                    }
                    else
                    {
                        FindLocation(player, args[0], ref locationlist);
                    }
                    break;
                case 2:
                    if (args[0] == "-d")
                    {
                        FindDLocation(player, args[1], ref locationlist);
                    }
                    else
                    {
                        player.Reply(lang.GetMessage("Usage", this, player.Id));
                    }
                    break;
                default:
                    player.Reply(lang.GetMessage("Usage", this, player.Id));
                    break;
            }

            if (locationlist.IsEmpty())
            {
                player.Reply(lang.GetMessage("NotFound", this, player.Id));
            }
            else
            {
                foreach (Tuple<double, string> item in locationlist.OrderByDescending(i => i.Item1))
                {
                    player.Reply(item.Item2);
                }
            }
        }

        #endregion Commands

        #region Datafile

        private void LoadDataFile()
        {
            DynamicConfigFile file = Interface.Oxide.DataFileSystem.GetDatafile(Name);
            try
            {
                playerdict = file.ReadObject<Dictionary<string, PlayerData>>();
            }
            catch
            {
                playerdict = new Dictionary<string, PlayerData>();
            }
        }

        private void SaveDataFile()
        {
            DynamicConfigFile file = Interface.Oxide.DataFileSystem.GetDatafile(Name);
            file.WriteObject<Dictionary<string, PlayerData>>(playerdict);
        }

        #endregion Datafile

        #region Helper

        private void FindLocation(IPlayer callingplayer, string search, ref List<Tuple<double, string>> locationlist)
        {
            bool console = false;

            if (callingplayer.LastCommand == CommandType.Console)
            {
                console = true;
            }
            
            foreach (BasePlayer player in BasePlayer.allPlayerList)
            {
                string options = string.Empty;
                string name = player.displayName;
                string id = player.UserIDString;
                PlayerData playerdata;
                double sleeptime = 0;

                if (player.IsNpc)
                {
                    continue;
                }

                if (search.Length > 0 && name.Contains(search, System.Globalization.CompareOptions.IgnoreCase) == false && id.Contains(search) == false)
                {
                    continue;
                }

                if (!playerdict.TryGetValue(id, out playerdata))
                {
                    playerdata = new PlayerData();
                    playerdict[id] = playerdata;
                }

                if (player.IsSleeping())
                {
                    if (playerdata.lastawaketime != DateTime.MinValue)
                    {
                        TimeSpan diff = DateTime.Now - playerdata.lastawaketime;
                        sleeptime = diff.TotalSeconds;
                    }

                    if (!console || sleeptime <= 0)
                    {
                        options += " (sleeping)";
                    }
                    else if (sleeptime < 3600) // hour
                    {
                        options += " (sleeping " + Math.Floor(sleeptime / 60) + " minutes)";
                    }
                    else if (sleeptime < 86400) // day
                    {
                        options += " (sleeping " + Math.Floor(sleeptime / 3600) + " hours)";
                    }
                    else
                    {
                        options += " (sleeping " + Math.Floor(sleeptime / 86400) + " days)";
                    }
                }
                else if (player.IsDead())
                {
                    options += " (dead)";
                }
                else if (player.IsFlying)
                {
                    options += " (flying)";
                }

                if (player.IsAdmin)
                {
                    options += " (admin)";
                }

                if (player.IsGod())
                {
                    options += " (god)";
                }

                Vector3 location = player.transform.position;

                string pos = MapPosition(location);
                string locationstr;

                if (console)
                {
                    locationstr = string.Concat(id, " ", name, options, ": ", pos, ", ", location.x, ", ", location.z);
                }
                else
                {
                    locationstr = string.Concat(name, options, ": ", pos, ", ", location.x, ", ", location.z);
                }

                locationlist.Add(Tuple.Create(sleeptime, locationstr));
            }
        }

        private void FindDLocation(IPlayer callingplayer, string search, ref List<Tuple<double, string>> locationlist)
        {
            bool console = false;

            if (callingplayer.LastCommand == CommandType.Console)
            {
                console = true;
            }

            foreach (BasePlayer player in BasePlayer.allPlayerList)
            {
                string options = string.Empty;
                string name = player.displayName;
                string id = player.UserIDString;
                PlayerData playerdata;
                double deathtime = 0;

                if (player.IsNpc)
                {
                    continue;
                }

                if (search.Length > 0 && name.Contains(search, System.Globalization.CompareOptions.IgnoreCase) == false && id.Contains(search) == false)
                {
                    continue;
                }

                if (!playerdict.TryGetValue(id, out playerdata))
                {
                    playerdata = new PlayerData();
                    playerdict[id] = playerdata;
                }

                if (playerdata.lastdeathtime == DateTime.MinValue)
                {
                    continue;
                }

                TimeSpan diff = DateTime.Now - playerdata.lastdeathtime;
                deathtime = diff.TotalSeconds;

                if (!console || deathtime <= 0)
                {
                    options += " (died)";
                }
                else if (deathtime < 3600) // hour
                {
                    options += " (died " + Math.Floor(deathtime / 60) + " minutes ago)";
                }
                else if (deathtime < 86400) // day
                {
                    options += " (died " + Math.Floor(deathtime / 3600) + " hours ago)";
                }
                else
                {
                    options += " (died " + Math.Floor(deathtime / 86400) + " days ago)";
                }

                Vector3 location = playerdata.lastdeathloc;

                string pos = MapPosition(location);
                string locationstr;

                if (console)
                {
                    locationstr = string.Concat(id, " ", name, options, ": ", pos, ", ", location.x, ", ", location.z);
                }
                else
                {
                    locationstr = string.Concat(name, options, ": ", pos, ", ", location.x, ", ", location.z);
                }

                locationlist.Add(Tuple.Create(deathtime, locationstr));
            }
        }

        private string MapPosition (Vector3 position)
        {
            string[] chars = new string[] { "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "AA", "AB", "AC", "AD", "AE", "AF", "AG", "AH", "AI", "AJ", "AK", "AL", "AM", "AN", "AO", "AP", "AQ", "AR", "AS", "AT", "AU", "AV", "AW", "AX", "AY", "AZ" };

            const float block = 146;

            float size = ConVar.Server.worldsize;
            float offset = size / 2;

            float xpos = position.x + offset;
            float zpos = position.z + offset;

            int maxgrid = (int)(size / block);

            float xcoord = Mathf.Clamp(xpos / block, 0, maxgrid - 1);
            float zcoord = Mathf.Clamp(maxgrid - (zpos / block), 0, maxgrid - 1);

            string pos = string.Concat(chars[(int)xcoord], (int)zcoord);

            return (pos);
        }

        #endregion Helper
    }
}


// --- End of file: PlayerLocation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pets ---
// --- Original File Path: P/Pets/Pets.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Oxide.Plugins
{
    [Info("Pets", "Nogrod/k1lly0u", "0.6.5"), Description("Gives players the ability to tame and have pets")]
    class Pets : RustPlugin
    {
        #region Fields        
        private static Pets ins;
        private BUTTON Main;
        private BUTTON Secondary;
        private Dictionary<ulong, PetData> npcSaveList = new Dictionary<ulong, PetData>();

        private enum Action { Move, Attack, Eat, Drink, Follow, Sleep, Idle }
        #endregion

        #region Oxide Hooks       
        private void OnServerInitialized()
        {
            ins = this;
            lang.RegisterMessages(Messages, this);
            RegisterPermissions();
            LoadData();

            Main = ConvertToButton(configData.UserControl.Main);
            Secondary = ConvertToButton(configData.UserControl.Secondary);

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null)
                return;

            if (entity is BaseNpc)
                entity.GetComponent<NpcAI>()?.OnAttacked(hitInfo);
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null)
                return;

            if (entity is BaseNpc)
                entity.GetComponent<NpcAI>()?.OnDeath();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2f, () => OnPlayerConnected(player));
                return;
            }
            PetData info;
            if (!npcSaveList.TryGetValue(player.userID, out info) || !info.NeedToSpawn)
                return;

            Puts("Loading pet...");
            BaseEntity pet = InstantiateEntity(StringPool.Get(info.prefabID), new Vector3(info.x, info.y, info.z), new Quaternion());
            if (pet == null) return;

            NPCController controller = player.gameObject.AddComponent<NPCController>();
            pet.enableSaving = false;
            pet.Spawn();

            controller.npcAi = pet.gameObject.AddComponent<NpcAI>();
            controller.npcAi.owner = controller;
            controller.npcAi.inventory.Load(ProtoBuf.ItemContainer.Deserialize(info.inventory));
            info.NeedToSpawn = false;
        }

        private object OnNpcAttack(BaseNpc entity, BaseEntity target)
        {
            BasePlayer player = target?.ToPlayer();
            if (entity == null || player == null)
                return null;

            return CanAnimalAttack(entity, player);
        }

        private object OnNpcTarget(BaseNpc entity, BaseEntity target)
        {
            BasePlayer player = target?.ToPlayer();
            if (entity == null || player == null)
                return null;

            return CanAnimalAttack(entity, player);
        }

        private object CanNpcEat(BaseNpc entity, BaseEntity target)
        {
            BasePlayer player = target?.ToPlayer();
            if (entity == null || player == null)
                return null;

            return CanAnimalAttack(entity, player);
        }

        private void OnServerSave()
        {
            var pets = UnityEngine.Object.FindObjectsOfType<NpcAI>();
            if (pets == null) return;
            foreach (var pet in pets)
                npcSaveList[pet.owner.player.userID] = new PetData(pet);
            SaveData();
        }

        private void Unload()
        {
            OnServerSave();
            DestroyAll<NPCController>();
            DestroyAll<NpcAI>();
            ins = null;
        }
        #endregion

        #region Functions
        private object CanAnimalAttack(BaseNpc entity, BasePlayer player)
        {
            NpcAI npcAi = entity.GetComponent<NpcAI>();
            if (npcAi != null && npcAi.owner.player == player)
                return false;
            return null;
        }

        private object CanNPCEat(BaseNpc entity, BaseEntity target)
        {
            NpcAI npcAi = entity.GetComponent<NpcAI>();
            if (npcAi != null)            
                return npcAi.action == Action.Eat;            
            return null;
        }

        private void RegisterPermissions()
        {
            string[] names = new string[] { "bear", "boar", "chicken", "horse", "polarbear", "stag", "wolf" };
            foreach (var name in names)
                permission.RegisterPermission($"pets.{name}", this);
        }

        private BUTTON ConvertToButton(string button)
        {
            try
            {
                return (BUTTON)Enum.Parse(typeof(BUTTON), button);
            }
            catch (Exception)
            {
                return BUTTON.USE;
            }
        }

        private void DestroyAll<T>()
        {
            var objects = UnityEngine.Object.FindObjectsOfType(typeof(T));
            if (objects == null) return;
            foreach (var gameObj in objects)
                UnityEngine.Object.Destroy(gameObj);
        }

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            var days = dateDifference.Days;
            var hours = dateDifference.Hours;
            hours += (days * 24);
            var mins = dateDifference.Minutes;
            var secs = dateDifference.Seconds;
            return string.Format("{0:00}:{1:00}:{2:00}", hours, mins, secs);
        }

        private BaseEntity InstantiateEntity(string type, Vector3 position, Quaternion rotation)
        {
            var gameObject = Facepunch.Instantiate.GameObject(GameManager.server.FindPrefab(type), position, rotation);
            gameObject.name = type;

            SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);

            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());

            if (!gameObject.activeSelf)
                gameObject.SetActive(true);

            BaseEntity component = gameObject.GetComponent<BaseEntity>();
            return component;
        }
        #endregion

        #region Components
        private class NPCController : MonoBehaviour
        {
            public BasePlayer player;
            public NpcAI npcAi;

            private float nextPressTime = 0;
            private float nextDrawTime = 0;
            private float nextControlTime = 0;

            private float lootDistance;
            private float tameTimer;
            private float lastTpTime;
                        
            private bool usePermissions;
            internal bool drawEnabled;

            private void Awake()
            {
                enabled = false;
                player = GetComponent<BasePlayer>();
                drawEnabled = ins.configData.Options.UseDrawSystem;
                tameTimer = ins.configData.Options.TameTimer;
                lootDistance = ins.configData.Options.LootDistance;
                usePermissions = ins.configData.Options.UsePermissions;
            }
            private void Update()
            {
                if (player == null || player.IsDead())
                    return;

                float time = Time.realtimeSinceStartup;

                if (player.serverInput.WasJustPressed(ins.Main))
                {
                    if (nextPressTime < time)
                    {
                        nextPressTime = time + 0.2f;
                        UpdateAction();
                    }
                }
                else if (player.serverInput.WasJustPressed(ins.Secondary))
                {
                    if (npcAi != null && nextPressTime < time)
                    {
                        nextPressTime = time + 0.2f;
                        ChangeFollowAction();
                    }
                }

                if (drawEnabled && npcAi != null && npcAi.action < Action.Follow && nextDrawTime < time)
                {
                    nextDrawTime = time + 0.05f;
                    UpdateDraw();
                }                
            }

            private void UpdateDraw()
            {
                var drawpos = (npcAi.action == Action.Move || npcAi.action == Action.Drink ? npcAi.targetPos : (npcAi.targetEnt == null ? Vector3.zero : npcAi.targetEnt.transform.position));
                if (drawpos != Vector3.zero)
                {
                    bool tempAdmin = false;
                    if (!player.IsAdmin)
                    {
                        tempAdmin = true;
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                        player.SendNetworkUpdateImmediate();
                    }
                    player.SendConsoleCommand("ddraw.arrow", 0.05f + 0.02f, npcAi.action == Action.Move ? Color.cyan : npcAi.action == Action.Attack ? Color.red : Color.yellow, drawpos + new Vector3(0, 5f, 0), drawpos, 1.5f);
                    if (tempAdmin)
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                }
            }

            private void UpdateAction()
            {               
                RaycastHit hit;
                if (Physics.SphereCast(player.eyes.position, 0.5f, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward, out hit) || hit.transform == transform)
                {
                    if (npcAi == null)
                    {
                        BaseNpc npcPet = hit.GetEntity()?.GetComponent<BaseNpc>();
                        if (npcPet == null)
                            return;

                        if (hit.distance >= 10)
                        {
                            UserMessage(player, "tooFar");
                            return;
                        }

                        TryGetNewPet(npcPet);
                        return;
                    }

                    if (hit.collider?.gameObject.layer == 4)
                    {
                        if (npcAi.entity.Hydration.Level < 1)
                        {
                            UserMessage(player, "isDrinking");
                            npcAi.targetPos = hit.point;
                            npcAi.action = Action.Drink;                           
                        }
                        else UserMessage(player, "notThirsty");
                        return;
                    }

                    BaseCombatEntity targetEnt = hit.GetEntity()?.GetComponent<BaseCombatEntity>();                    
                    if (targetEnt == null)
                    {
                        npcAi.targetPos = hit.point;
                        npcAi.action = Action.Move;                        
                        return;
                    }

                    if (targetEnt == npcAi.entity)
                    {
                        if (hit.distance <= lootDistance)
                            OpenPetInventory();
                    }
                    else if (targetEnt is BaseCorpse)
                    {
                        UserMessage(player, "isEating");
                        npcAi.entity.FoodTarget = targetEnt;
                        npcAi.Attack(targetEnt, Action.Eat);
                    }
                    else
                    {
                        UserMessage(player, "isAttacking");
                        npcAi.Attack(targetEnt);
                    }
                }
            }

            private void OpenPetInventory()
            {                
                player.inventory.loot.Clear();
                player.inventory.loot.entitySource = npcAi.entity;
                player.inventory.loot.itemSource = null;
                player.inventory.loot.AddContainer(npcAi.inventory);
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "generic");
                player.SendNetworkUpdate();

                UserMessage(player, "openInv");
            }

            private void ChangeFollowAction()
            {
                if (npcAi == null) return;
                if (!npcAi.stopFollow)
                {
                    UserMessage(player, "stopFollow");
                    npcAi.action = Action.Idle;
                    npcAi.stopFollow = true;
                }
                else
                {
                    UserMessage(player, "startFollow");
                    npcAi.Attack(player, Action.Follow);
                    npcAi.stopFollow = false;
                }
            }

            internal void TeleportToPlayer()
            {
                float currentTime = Time.realtimeSinceStartup;
                if (currentTime < lastTpTime)
                {
                    UserMessage(player, "tpcooldown", new string[] { ins.FormatTime(lastTpTime - currentTime) });
                    return;
                }

                if (npcAi == null || npcAi.entity == null)
                {
                    UserMessage(player, "nopet");
                    return;
                }

                lastTpTime = currentTime + ins.configData.Options.TpCooldown;
                npcAi.entity.transform.position = player.transform.position + (player.eyes.BodyForward() * 2);
                npcAi.entity.SendNetworkUpdate();
            }

            private void TryGetNewPet(BaseNpc npcPet)
            {
                NpcAI ownedAi = npcPet.GetComponent<NpcAI>();
                if (ownedAi != null)
                {
                    if (ownedAi.owner != this)
                        UserMessage(player, "isPet");
                    else UserMessage(player, "isYourPet");
                    return;
                }

                if (nextControlTime >= Time.realtimeSinceStartup)
                {
                    UserMessage(player, "tooFast");
                    return;
                }

                if (usePermissions && !ins.permission.UserHasPermission(player.UserIDString, $"pets.{npcPet.ShortPrefabName}"))
                {
                    UserMessage(player, "noPerms");
                    return;
                }

                nextControlTime = Time.realtimeSinceStartup + tameTimer;

                npcAi = npcPet.gameObject.AddComponent<NpcAI>();
                npcAi.owner = this;

                UserMessage(player, "petSet");
            }
        }

        private class NpcAI : MonoBehaviour
        {
            internal Action action;
            internal Vector3 targetPos = Vector3.zero;
            internal BaseCombatEntity targetEnt;
            internal bool stopFollow = false;

            public NPCController owner;
            public ItemContainer inventory;
            public BaseNpc entity;

            private double attackRange;
            private float targetIgnoreDistance;
            private float healthModifier;
            private float speedModifier;
            private float attackModifier;

            private float nextMessageTime;

            private void Awake()
            {
                entity = GetComponent<BaseNpc>();
                action = Action.Idle;

                targetIgnoreDistance = ins.configData.Options.AttackDistance;
                healthModifier = ins.configData.NPCMods.Health;
                speedModifier = ins.configData.NPCMods.Speed;
                attackModifier = ins.configData.NPCMods.Attack;
                nextMessageTime = Time.realtimeSinceStartup;

                inventory = new ItemContainer();
                inventory.ServerInitialize(null, 6);
                if ((int)inventory.uid == 0)
                    inventory.GiveUID();

                entity.InitializeHealth(entity.Health() * healthModifier, entity.MaxHealth() * healthModifier);

                entity.AttackDamage *= attackModifier;
                entity.Stats.TurnSpeed *= speedModifier;
                entity.Stats.Speed *= speedModifier;
            }

            private void OnDestroy()
            {
                DropUtil.DropItems(inventory, transform.position);
                owner.npcAi = null;

                if (entity.health <= 0)
                    return;
                
                entity.InitializeHealth(entity.Health() / healthModifier, entity.MaxHealth() / healthModifier);

                entity.AttackDamage /= attackModifier;
                entity.Stats.TurnSpeed /= speedModifier;
                entity.Stats.Speed /= speedModifier;

                entity.Kill();
            }

            internal void OnAttacked(HitInfo info)
            {
                if (entity == null || entity.IsDead())
                    return;

                if (info.Initiator.GetComponent<BaseCombatEntity>() && info.Initiator != owner.player && action != Action.Attack)
                    Attack(info.Initiator.GetComponent<BaseCombatEntity>(), Action.Attack);
            }

            internal void OnDeath()
            {
                if (owner != null)
                {
                    owner.enabled = false;
                    owner.npcAi = null;
                    UserMessage(owner.player, "ondeath");
                    Destroy(owner);
                }

                Destroy(this);
            }

            private void Update()
            {                
                if (entity.Sleep < 0.01f)
                {
                    SetBehaviour(BaseNpc.Behaviour.Sleep);
                    action = Action.Sleep;

                    float time = Time.realtimeSinceStartup;
                    if (owner.player.enabled && nextMessageTime < time)
                    {
                        UserMessage(owner.player, "isTired");
                        nextMessageTime = time + 60f;
                    }
                    return;
                }

                if (entity.Energy.Level < 0.01f)
                {
                    var time = Time.realtimeSinceStartup;
                    if (owner.player.enabled && nextMessageTime < time)
                    {
                        UserMessage(owner.player, "isHungry");
                        nextMessageTime = time + 60f;
                    }
                }

                if (action == Action.Idle || action == Action.Follow)
                {
                    SetBehaviour(BaseNpc.Behaviour.Idle);
                    
                    if (stopFollow)                    
                        StopMoving();
                    else
                    {
                        if (owner != null)
                        {
                            float distance = Vector3.Distance(transform.position, owner.transform.position);
                            if (distance > 3)                            
                                UpdateDestination(owner.transform.position + (-owner.player.eyes.HeadForward() * 2), distance > 10);                            
                            else StopMoving();                            
                        }
                    }                    
                    return;
                }

                if (action == Action.Move)
                {
                    float distance = Vector3.Distance(transform.position, targetPos);

                    if (distance < 1)
                        action = Action.Idle;
                    else
                    {
                        SetBehaviour(BaseNpc.Behaviour.Wander);
                        UpdateDestination(targetPos, distance > 5);                        
                    }
                }
                else if (action == Action.Drink)
                {
                    if (entity.Hydration.Level >= 1)
                    {
                        SetBehaviour(BaseNpc.Behaviour.Idle);
                        action = Action.Idle;
                        return;
                    }
                    
                    float distance = Vector3.Distance(transform.position, targetPos);
                    if (distance < 1)
                    {
                        SetBehaviour(BaseNpc.Behaviour.Eat);
                        entity.Hydration.Level += 0.005f;
                        entity.Hydration.Level = Mathf.Clamp01(entity.Hydration.Level);
                    }
                    else UpdateDestination(targetPos, distance > 5); 
                }
                else if (action == Action.Sleep)
                {
                    StopMoving();
                    SetBehaviour(BaseNpc.Behaviour.Sleep);

                    entity.health += 0.003f;
                    entity.health = Mathf.Clamp(entity.health, 0, entity.MaxHealth());

                    entity.Sleep += 0.003f;
                    entity.Sleep = Mathf.Clamp01(entity.Sleep);                    
                }
                else
                {
                    if (targetEnt == null)
                    {
                        if (!stopFollow)
                            targetEnt = owner.player;

                        action = Action.Idle;
                    }
                    else
                    {
                        float distance = Vector3.Distance(transform.position, targetEnt.transform.position);
                        if (distance > targetIgnoreDistance)
                        {
                            action = Action.Idle;
                            SetBehaviour(BaseNpc.Behaviour.Idle);
                            return;
                        }  
                        
                        if ((action == Action.Eat || entity.Energy.Level < 0.25f) && targetEnt != owner.player)
                        {
                            SetBehaviour(BaseNpc.Behaviour.Eat);

                            if (distance <= attackRange)
                            {
                                entity.FoodTarget = targetEnt;
                                if (distance <= 2)                                
                                    entity.Eat();                                
                            }
                            else UpdateDestination(targetEnt.transform.position, distance > 5);                              
                        }

                        if (action == Action.Attack && targetEnt != owner.player && distance < targetIgnoreDistance)
                        {
                            if (entity.AttackTarget != targetEnt)
                                entity.AttackTarget = targetEnt;

                            SetBehaviour(BaseNpc.Behaviour.Attack);

                            if (distance <= entity.AttackRange)                            
                                entity.StartAttack();
                            else UpdateDestination(targetEnt.transform.position, true);                           
                        }                       
                    }
                }
            }


            private void UpdateDestination(Vector3 position, bool run)
            {
                entity.UpdateDestination(position);
                entity.TargetSpeed = run ? entity.Stats.Speed : entity.Stats.Speed * 0.3f;
            }

            private void StopMoving()
            {
                entity.IsStopped = true;
                entity.ChaseTransform = null;
                entity.SetFact(BaseNpc.Facts.PathToTargetStatus, 0, true, true);
            }

            private void SetBehaviour(BaseNpc.Behaviour behaviour)
            {
                if (entity.CurrentBehaviour != behaviour)
                    entity.CurrentBehaviour = behaviour;
            }

            internal void Attack(BaseCombatEntity targetEnt, Action action = Action.Attack)
            {
                if (targetEnt == null)
                    return;

                this.targetEnt = targetEnt;
                this.action = action;
                entity.AttackTarget = targetEnt;                
            }
        }
        #endregion

        #region Commands
        [ChatCommand("pet")]
        private void pet(BasePlayer player, string command, string[] args)
        {
            NPCController component = player.GetComponent<NPCController>() ?? player.gameObject.AddComponent<NPCController>();
            if (args.Length == 0)
            {
                component.enabled = !component.enabled;
                UserMessage(player, component.enabled ? "isEnabled" : "isDisabled");                
                return;
            }

            if (args[0].ToLower() == "help")
            {
                UserMessage(player, "help0", new string[] {Title, Version.ToString()});
                UserMessage(player, "help1");
                UserMessage(player, "help2");
                UserMessage(player, "help3");
                UserMessage(player, "help4");
                UserMessage(player, "help5");
                UserMessage(player, "help7");
                UserMessage(player, "help6");
                return;
            }
            if (args[0] == "draw")
            {
                if (configData.Options.UseDrawSystem)
                {
                    component.drawEnabled = !component.drawEnabled;
                    UserMessage(player, component.drawEnabled ? "drawEnabled" : "drawDisabled");                    
                }
                else UserMessage(player, "noDdraw");
            }

            if (component.npcAi != null)
            {
                switch (args[0].ToLower())
                {
                    case "free":
                        UnityEngine.Object.Destroy(component.npcAi);
                        component.npcAi = null;
                        UserMessage(player, "hasReleased");
                        return;
                    case "sleep":
                        if (component.npcAi.action == Action.Sleep)
                        {
                            component.npcAi.action = Action.Idle;
                            UserMessage(player, "awoken");
                        }
                        else
                        {
                            component.npcAi.action = Action.Sleep;
                            UserMessage(player, "sleeping");
                        }
                        return;
                    case "come":
                        component.TeleportToPlayer();
                        return;
                    case "info":
                        UserMessage(player, "statistics", new string[] {
                            Math.Round(component.npcAi.entity.health, 2).ToString(),
                            Math.Round(component.npcAi.entity.Energy.Level * 100, 2).ToString(),
                            Math.Round(component.npcAi.entity.Hydration.Level * 100, 2).ToString(),
                            Math.Round(component.npcAi.entity.Stamina.Level * 100, 2).ToString(),
                            Math.Round(component.npcAi.entity.Sleep * 100, 2).ToString()
                        });
                        return;
                    default:
                        break;
                }
            }
            else UserMessage(player, "nopet");
        }
        #endregion

        #region Config        
        private ConfigData configData;        
        class ConfigData
        {
            [JsonProperty(PropertyName = "Pet statistic modifiers")]
            public Modifiers NPCMods { get; set; }
            [JsonProperty(PropertyName = "Control buttons")]
            public Controls UserControl { get; set; }
            public OtherOptions Options { get; set; }

            public class Modifiers
            {
                [JsonProperty(PropertyName = "Attack damage")]
                public float Attack { get; set; }
                public float Health { get; set; }
                public float Speed { get; set; }
            }
            public class Controls
            {
                [JsonProperty(PropertyName = "Npc command control button")]
                public string Main { get; set; }
                [JsonProperty(PropertyName = "Follow player toggle button")]
                public string Secondary { get; set; }
            }
            public class OtherOptions
            {
                [JsonProperty(PropertyName = "Maximum distance to tame an pet")]
                public float TameDistance { get; set; }
                [JsonProperty(PropertyName = "Teleport to player cooldown (seconds)")]
                public int TpCooldown { get; set; }
                [JsonProperty(PropertyName = "Time between taming pets")]
                public float TameTimer { get; set; }
                [JsonProperty(PropertyName = "Maximum distance to open your pets inventory")]
                public float LootDistance { get; set; }
                [JsonProperty(PropertyName = "Maximum distance before your pet will ignore a target")]
                public float AttackDistance { get; set; }
                [JsonProperty(PropertyName = "Use the permission system")]
                public bool UsePermissions { get; set; }
                [JsonProperty(PropertyName = "Use the Ddraw system")]
                public bool UseDrawSystem { get; set; }
            }
            public Oxide.Core.VersionNumber Version { get; set; }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                NPCMods = new ConfigData.Modifiers
                {
                    Attack = 2f,
                    Health = 1.5f,
                    Speed = 1f
                },
                Options = new ConfigData.OtherOptions
                {
                    AttackDistance = 70,
                    LootDistance = 1f,
                    TameDistance = 10f,
                    TameTimer = 60f,
                    TpCooldown = 600,
                    UsePermissions = false,
                    UseDrawSystem = true
                },
                UserControl = new ConfigData.Controls
                {
                    Main = "USE",
                    Secondary = "RELOAD"
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(0, 6, 2))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }        
        #endregion

        #region Data Management
        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("Pets_data", npcSaveList);
        void LoadData()
        {
            try
            {
                npcSaveList = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, PetData>>("Pets_data");
            }
            catch
            {
                npcSaveList = new Dictionary<ulong, PetData>();
            }
        }

        class PetData
        {
            public uint prefabID;
            public float x, y, z;
            public byte[] inventory;
            internal bool NeedToSpawn;

            public PetData()
            {
                NeedToSpawn = true;
            }

            public PetData(NpcAI pet)
            {
                x = pet.transform.position.x;
                y = pet.transform.position.y;
                z = pet.transform.position.z;
                prefabID = pet.entity.prefabID;
                inventory = pet.inventory.Save().ToProtoBytes();
                NeedToSpawn = false;
            }
        }
        #endregion

        #region Localization
        static void UserMessage(BasePlayer player, string key, string[] args = null) => player.ChatMessage(args == null ? ins.lang.GetMessage(key, ins, player.UserIDString) : string.Format(ins.lang.GetMessage(key, ins, player.UserIDString), args));

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"tooFar", "<color=#939393>You are too far away</color>"},
            {"isTired", "<color=#939393>Your pet tired and needs to rest</color>"},
            {"isHungry", "<color=#939393>Your pet is hungry and needs to eat</color>"},
            {"isEating", "<color=#939393>Your pet is now eating</color>"},
            {"isDrinking", "<color=#939393>Your pet is going to get a drink</color>"},
            {"notThirsty", "<color=#939393>Your pet is not thirsty</color>"},
            {"isAttacking", "<color=#939393>Your pet is now attacking</color>"},
            {"openInv", "<color=#939393>Opening your pets inventory</color>"},
            {"stopFollow", "<color=#939393>Your pet has stopped following you</color>"},
            {"startFollow", "<color=#939393>Your pet is now following you</color>"},
            {"isPet", "<color=#939393>This animal is already someones a pet</color>"},
            {"isYourPet", "<color=#939393>This animal is already your pet</color>"},
            {"tooFast", "<color=#939393>You are trying to tame animals too fast</color>"},
            {"noPerms", "<color=#939393>You do not have the required permissions to tame this animal</color>"},
            {"petSet", "<color=#939393>You have set this animal as your pet</color>"},
            {"isEnabled", "<color=#939393>Pet control activated\nType </color><color=#ce422b>\"/pet help\" </color><color=#939393>to show the help menu!</color>"},
            {"isDisabled", "<color=#939393>Pet control deactivated</color>"},
            {"help0", "<color=#ce422b>{0}  </color><color=#939393>v</color><color=#ce422b>{1}</color>" },
            {"help1", "<color=#ce422b>/pet </color><color=#939393>- Enable/disable pet control</color>"},
            {"help2", "<color=#ce422b>/pet help </color><color=#939393>- Show this menu</color>"},
            {"help3", "<color=#ce422b>/pet draw </color><color=#939393>- Enable/disable ddraw control markers</color>"},
            {"help4", "<color=#ce422b>/pet free </color><color=#939393>- Release your pet back into the wild</color>"},
            {"help5", "<color=#ce422b>/pet sleep </color><color=#939393>- Put your pet to sleep, or wake them up</color>"},
            {"help7", "<color=#ce422b>/pet come </color><color=#939393>- Teleport your pet to your position</color>"},
            {"help6", "<color=#ce422b>/pet info </color><color=#939393>- Display statistics for your pet</color>"},
            {"drawEnabled", "<color=#939393>Activated ddraw display</color>"},
            {"drawDisabled", "<color=#939393>Deactivated ddraw display</color>"},
            {"noDdraw", "<color=#939393>DDraw display is not enabled on this server</color>"},
            {"hasReleased", "<color=#939393>You released your pet back into the wild</color>"},
            {"awoken", "<color=#939393>Your pet has awoken</color>"},
            {"ondeath", "<color=#939393>Your pet has died!</color>"},
            {"sleeping", "<color=#939393>Your pet is sleeping</color>"},
            {"tpcooldown", "<color=#939393>You must wait another <color=#ce422b>{0}</color> to user this command!</color>" },
            {"nopet", "<color=#939393>You dont currently have a pet</color>" },
            {"statistics", "<color=#ce422b>Pet Statistics:</color><color=#939393>\nHealth :</color><color=#ce422b>{0}</color><color=#939393>\nEnergy :</color><color=#ce422b>{1}</color><color=#939393>\nHydration :</color><color=#ce422b>{2}</color><color=#939393>\nStamina :</color><color=#ce422b>{3}</color><color=#939393>\nSleep :</color><color=#ce422b>{4}</color>"}
        };
        #endregion
    }


}

// --- End of file: Pets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/phone-rename ---
// --- Original File Path: P/PhoneRename/PhoneRename.cs ---

﻿using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Oxide.Core.Libraries;

namespace Oxide.Plugins
{
    [Info("Phone Rename", "Bazz3l", "0.0.4")]
    [Description("Ability to rename naughty named phones and changes to discord.")]
    public class PhoneRename : CovalencePlugin
    {
        [PluginReference] private Plugin DiscordMessages;
        
        #region Fields

        private const string PermUse = "phonerename.use";

        private readonly Dictionary<string, string> _headers = new Dictionary<string, string> { { "Content-Type", "application/json" } };
        
        private PluginConfig _pluginConfig;

        #endregion
        
        #region Config

        protected override void LoadDefaultConfig() => _pluginConfig = new PluginConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _pluginConfig = Config.ReadObject<PluginConfig>();

                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                LoadDefaultConfig();

                PrintError("Config file contains an error and has been replaced with the default file.");
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_pluginConfig);
        
        private class PluginConfig
        {
            [JsonProperty("DiscordWebhook (discord webhook url here)")]
            public string DiscordWebhook = "https://discord.com/api/webhooks/webhook-here";

            [JsonProperty("DiscordColor (discord embed color)")]
            public int DiscordColor = 65535;

            [JsonProperty("DiscordAuthor (discord embed author name)")]
            public string DiscordAuthor = "Phone Rename";
            
            [JsonProperty("DiscordAuthorImageUrl (discord embed author image url)")]
            public string DiscordAuthorImageUrl = "https://assets.umod.org/images/icons/plugin/5fa92b3f428d1.png";
            
            [JsonProperty("DiscordAuthorUrl (discord embed author url)")]
            public string DiscordAuthorUrl = "https://umod.org/plugins/phone-rename";
            
            [JsonProperty("LogToDiscord (log updated phone names to a discord channel)")]
            public bool LogToDiscord;

            [JsonProperty("WordList (list of ad words)")]
            public List<string> WordList = new List<string>
            {
                "fucker",
                "fuck",
                "cunt",
                "twat",
                "wanker",
                "bastard"
            };
        }

        #endregion
        
        #region Oxide

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string> {
                { "NoPermission", "No permission" },
                { "InvalidSyntax", "Invalid syntax, renamephone <phone-number> <new-name>" },
                { "NotFound", "No telephone found by that phone number." },
                { "Updated", "Phone was updated to {0}." },
                { "PhoneNumber", "Phone Number" },
                { "PhoneName", "Phone Name" },
                { "Connect", "Connect" },
                { "Server", "Server" },
                { "Profile", "Profile" }
            }, this);
        }
        
        private void Init()
        {
            permission.RegisterPermission(PermUse, this);
        }

        private object OnPhoneNameUpdate(PhoneController phoneController, string phoneName, BasePlayer player) => UpdatePhoneName(player.IPlayer, phoneController, phoneName);

        #endregion
        
        #region Core

        private object UpdatePhoneName(IPlayer player, PhoneController phoneController, string phoneName)
        {
            phoneController.PhoneName = FilterWord(phoneName);
            phoneController._baseEntity.SendNetworkUpdate();
            
            if (_pluginConfig.LogToDiscord)
            {
                SendDiscordMessage(player, phoneName, phoneController.PhoneNumber.ToString());
            }

            return false;
        }
        
        private string FilterWord(string phoneName)
        {
            foreach (string filteredWord in _pluginConfig.WordList)
            {
                string strReplace = "";
                
                for (int i = 0; i <= filteredWord.Length; i++)
                {
                    strReplace += "*";
                }
                
                phoneName = Regex.Replace(phoneName, filteredWord, strReplace, RegexOptions.IgnoreCase);
            }
            
            return phoneName;
        }
        
        private Telephone FindByPhoneNumber(int phoneNumber)
        {
            foreach (Telephone telephone in BaseNetworkable.serverEntities.OfType<Telephone>())
            {
                if (telephone.Controller.PhoneNumber == phoneNumber)
                {
                    return telephone;
                }
            }

            return null;
        }

        #endregion

        #region Command

        [Command("renamephone")]
        private void RenamePhoneCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermUse))
            {
                player.Message(Lang("NoPermission", player.Id));
                return;
            }
            
            if (args.Length < 2)
            {
                player.Message(Lang("InvalidSyntax", player.Id));
                return;
            }
            
            int phoneNumber;
            if (!int.TryParse(args[0], out phoneNumber))
            {
                player.Message(Lang("InvalidSyntax", player.Id));
                return;
            }
            
            Telephone telephone = FindByPhoneNumber(phoneNumber);
            if (telephone == null)
            {
                player.Message(Lang("NotFound", player.Id));
                return;
            }

            string phoneName = string.Join(" ", args.Skip(1).ToArray());

            UpdatePhoneName(player, telephone.Controller, phoneName);
            
            player.Message(Lang("Updated", player.Id, phoneName));
        }

        #endregion

        #region Discord

        private void SendDiscordMessage(IPlayer player, string phoneName, string phoneNumber)
        {
            webrequest.Enqueue(_pluginConfig.DiscordWebhook, new DiscordMessage("", new List<Embed>
            {
                new Embed
                {
                    Color = _pluginConfig.DiscordColor,
                    Author = new Author
                    {
                        Name = _pluginConfig.DiscordAuthor,
                        Url = _pluginConfig.DiscordAuthorUrl,
                        IconUrl = _pluginConfig.DiscordAuthorImageUrl,
                    },
                    Fields = new List<Field>
                    {
                        new Field(Lang("Server"), ConVar.Server.hostname, false),
                        new Field(Lang("PhoneNumber"), phoneNumber, false),
                        new Field(Lang("PhoneName"), phoneName, false),
                        new Field(Lang("Profile"), $"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})", false),
                        new Field(Lang("Connect"), $"steam://connect/{covalence.Server.Address}:{covalence.Server.Port}", false),
                    }
                }
            }).ToJson(), ( code, response ) => {}, this, RequestMethod.POST, _headers);
        }

        private class DiscordMessage
        {
            [JsonProperty("content")]
            public string Content { get; set; }

            [JsonProperty("embeds")]
            public List<Embed> Embeds { get; set; } = new List<Embed>();
            
            public DiscordMessage(string content, List<Embed> embeds)
            {
                Content = content;
                Embeds = embeds;
            }

            public string ToJson()
            {
                return JsonConvert.SerializeObject(this);
            }
        }

        private class Embed
        {
            [JsonProperty("author")]
            public Author Author;
            
            [JsonProperty("title")]
            public string Title { get; set; }

            [JsonProperty("description")]
            public string Description { get; set; }

            [JsonProperty("color")]
            public int Color { get; set; }

            [JsonProperty("fields")]
            public List<Field> Fields { get; set; } = new List<Field>();
        }

        private class Author
        {
            [JsonProperty("icon_url")]
            public string IconUrl;
            
            [JsonProperty("name")]
            public string Name;
            
            [JsonProperty("url")]
            public string Url;
        }

        private class Field
        {
            public Field(string name, string value, bool inline)
            {
                Name = name;
                Value = value;
                Inline = inline;
            }

            [JsonProperty("name")] 
            public string Name { get; set; }

            [JsonProperty("value")] 
            public string Value { get; set; }

            [JsonProperty("inline")] 
            public bool Inline { get; set; }
        }

        #endregion
        
        #region Helpers

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}

// --- End of file: PhoneRename.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/permission-notifications ---
// --- Original File Path: P/PermissionNotifications/PermissionNotifications.cs ---

﻿using System.Linq;
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
	[Info("Permission Notifications", "klauz24", "1.0.5"), Description("Allows you to notify players when they get or lose some permission.")]
	internal class PermissionNotifications : CovalencePlugin
	{
		private Configuration _config;

		private class Configuration
		{
			[JsonProperty(PropertyName = "Granted (permission or group, lang key)")]
			public Dictionary<string, string> Granted = new Dictionary<string, string>()
			{
				{"permissionOrGroup", "GotExample"}
			};

			[JsonProperty(PropertyName = "Revoked (permission or group, lang key)")]
			public Dictionary<string, string> Revoked = new Dictionary<string, string>()
			{
				{"permissionOrGroup", "LostExample"}
			};

			public string ToJson() => JsonConvert.SerializeObject(this);

			public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
		}

		protected override void LoadDefaultConfig() => _config = new Configuration();

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				_config = Config.ReadObject<Configuration>();
				if (_config == null)
				{
					throw new JsonException();
				}

				if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
				{
					Puts("Configuration appears to be outdated; updating and saving");
					SaveConfig();
				}
			}
			catch
			{
				Puts($"Configuration file {Name}.json is invalid; using defaults");
				LoadDefaultConfig();
			}
		}

		protected override void SaveConfig()
		{
			Puts($"Configuration changes saved to {Name}.json");
			Config.WriteObject(_config, true);
		}

		// Borrowed from Wulf's Auto Broadcast plugin
		private void OnServerInitialized()
		{
			if (lang.GetLanguages(this).Length == 0 || lang.GetMessages(lang.GetServerLanguage(), this)?.Count == 0)
			{
				lang.RegisterMessages(new Dictionary<string, string>
				{
					{"GotExample", "Yo you just got a permission or a group!"},
					{"LostExample", "F you just lost a permission or a group!"}
				}, this, lang.GetServerLanguage());
			}
			else
			{
				foreach (var language in lang.GetLanguages(this))
				{
					var messages = new Dictionary<string, string>();
					foreach (var message in lang.GetMessages(language, this)) messages.Add(message.Key, message.Value);
					lang.RegisterMessages(messages, this, language);
				}
			}
		}

		private void OnUserPermissionGranted(string id, string permName) => NotifyPlayer(_config.Granted, id, permName, true);

		private void OnUserPermissionRevoked(string id, string permName) => NotifyPlayer(_config.Revoked, id, permName, true);

		private void OnUserGroupAdded(string id, string groupName) => NotifyPlayer(_config.Granted, id, groupName, false);

		private void OnUserGroupRemoved(string id, string groupName) => NotifyPlayer(_config.Revoked, id, groupName, false);

		private void NotifyPlayer(Dictionary<string, string> dict, string id, string str, bool isPerm)
		{
			if (dict.ContainsKey(str))
			{
				var exists = false;
				if (isPerm)
				{
					exists = permission.PermissionExists(str);
				}
				else
				{
					exists = permission.GroupExists(str);
				}
				if (exists)
				{
					var player = players.FindPlayer(id);
					if (player?.IsConnected == true)
					{
						var message = GetLang(player, dict[str]);
						if (message != null)
						{
							player.Message(message);
						}
						else
						{
							PrintError($"Failed to get a message for {str}.");
						}
					}
				}
				else
				{
					PrintError($"{str} doesn't exist?");
				}
			}
		}

		private string GetLang(IPlayer player, string langKey) => lang.GetMessage(langKey, this, player.Id);
	}
}

// --- End of file: PermissionNotifications.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/perma-map ---
// --- Original File Path: P/PermaMap/PermaMap.cs ---

﻿using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Perma Map", "Wulf", "1.0.8")]
    [Description("Makes sure that players always have access to a map")]
    public class PermaMap : CovalencePlugin
    {
        #region Initialization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UnableToCraft"] = "You already have a map hidden in your inventory! Press your map button to use it"
            }, this);
        }

        private const float checkTime = 5f;
        private const string permUse = "permamap.use";

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }

        #endregion Initialization

        #region Crafting Block

        private object CanCraft(ItemCrafter itemCrafter, ItemBlueprint blueprint)
        {
            if (blueprint.name != "map.item")
            {
                return null;
            }

            BasePlayer player = itemCrafter.containers[0]?.GetOwnerPlayer();
            if (player == null)
            {
                return false;
            }

            if (permission.UserHasPermission(player.UserIDString, permUse))
            {
                player.ChatMessage(GetLang("UnableToCraft", player.UserIDString));
                return false;
            }

            return null;
        }

        #endregion Crafting Block

        #region Permament Map

        private void AddMap(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permUse))
            {
                return;
            }

            player.inventory.containerBelt.capacity = 7;
            if (player.inventory.containerBelt.GetSlot(6) != null)
            {
                return;
            }

            Item item = ItemManager.CreateByItemID(107868, 1);
            if (item != null)
            {
                item.MoveToContainer(player.inventory.containerBelt, 6);
            }
        }

        private void RemoveMap(BasePlayer player)
        {
            Item item = player.inventory.containerBelt.GetSlot(6);
            if (item != null)
            {
                item.RemoveFromContainer();
                item.Remove();
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            timer.Once(checkTime, () =>
            {
                if (player.IsReceivingSnapshot || player.IsSleeping())
                {
                    OnPlayerConnected(player);
                    return;
                }

                AddMap(player);
            });
        }

        private void OnPlayerDeath(BasePlayer player) => RemoveMap(player);

        private void OnPlayerRespawned(BasePlayer player) => AddMap(player);

        private void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            if (item.info.itemid != 107868)
            {
                return;
            }

            BasePlayer player = container.GetOwnerPlayer();
            if (player == null)
            {
                return;
            }

            if (container == player.inventory.containerBelt)
            {
                NextTick(() =>
                {
                    if (container.GetSlot(6) != null)
                    {
                        Item unknownItem = container.GetSlot(6);
                        if (unknownItem.info.itemid == 107868)
                        {
                            return;
                        }

                        if (!player.inventory.containerMain.IsFull())
                        {
                            unknownItem.MoveToContainer(player.inventory.containerMain);
                        }
                        else
                        {
                            unknownItem.Drop(player.transform.position, Vector3.down);
                        }
                    }
                    item.MoveToContainer(container, 6);
                });
            }
        }

        #endregion Permament Map

        #region Event Hooks

        private void JoinedEvent(BasePlayer player)
        {
            timer.Once(checkTime, () =>
            {
                if (player.IsSleeping())
                {
                    JoinedEvent(player);
                }
                else
                {
                    RemoveMap(player);
                }
            });
        }

        private void LeftEvent(BasePlayer player) => AddMap(player);

        #endregion Event Hooks

        #region Helpers

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        #endregion Helpers
    }
}


// --- End of file: PermaMap.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/phantom-sleepers ---
// --- Original File Path: P/PhantomSleepers/PhantomSleepers.cs ---

﻿using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Phantom Sleepers", "nivex", "1.0.0")]
    [Description("Create phantom sleepers to use as bait against suspected cheaters.")]
    class PhantomSleepers : RustPlugin
    {
        private const string playerPrefab = "assets/prefabs/player/player.prefab";
        private const string permissionName = "phantomsleepers.use";
        private const ulong phantomId = 612306;

        private Dictionary<ulong, Phantom> phantoms = new();

        private class Phantom : BasePlayer
        {
            internal BasePlayer phantom;
            internal BasePlayer sleeper;
            internal PhantomSleepers _instance;
            internal List<Item> items = new();
            internal Vector3 spawnPos;
            internal bool Invisibility;
            internal bool NoLooting;
            internal bool NoCorpse;
            internal bool NoCorpseLoot;
            internal ulong networkId;
            internal float nextUpdateCheck;

            //FieldInfo _inventoryValue = typeof(BasePlayer).GetField("inventoryValue", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            private void Awake()
            {
                phantom = GetComponent<BasePlayer>();

                //HiddenValue<PlayerInventory> inventoryValue = _inventoryValue.GetValue(phantom) as HiddenValue<PlayerInventory>;
                //inventoryValue.Set(GetComponent<PlayerInventory>());
                spawnPos = phantom.transform.position;
            }

            private void OnDestroy()
            {
                if (phantom != null && !phantom.IsDestroyed)
                {
                    phantom.Kill();
                }

                _instance.phantoms.Remove(networkId);

                SendShouldNetworkToUpdateImmediate();
            }

            private void FixedUpdate()
            {
                if (Invisibility && Time.time > nextUpdateCheck)
                {
                    if (sleeper == null || sleeper.IsConnected)
                    {
                        SendShouldNetworkToUpdateImmediate();
                        Invisibility = false;
                    }
                    nextUpdateCheck = Time.time + 1f;
                }
            }

            public void EntityDestroyOnClient(BasePlayer target)
            {
                if (target.IsValid() && target.net.group != null)
                {
                    target.OnNetworkSubscribersLeave(target.net.group.subscribers);
                }
                target.limitNetworking = true;
                target.syncPosition = false;
                sleeper = target;
                Invisibility = true;
            }

            public void SendShouldNetworkToUpdateImmediate()
            {
                if (sleeper)
                {
                    sleeper.limitNetworking = false;
                    sleeper.syncPosition = true;
                    sleeper.SendNetworkUpdateImmediate();
                }
            }

            public override bool ShouldDropActiveItem() => false;

            public override bool CanBeLooted(BasePlayer player)
            {
                if (NoLooting)
                {
                    return player.IsAdmin;
                }
                return base.CanBeLooted(player);
            }

            public override void OnDied(HitInfo info)
            {
                if (NoCorpseLoot)
                {
                    foreach (Item item in items)
                    {
                        if (item == null) continue;
                        item.RemoveFromContainer();
                        item.Remove(0f);
                    }
                    ItemManager.DoRemoves();
                }

                items.Clear();

                base.OnDied(info);
            }

            public override BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
            {
                if (NoCorpse)
                {
                    return null;
                }
                return base.CreateCorpse(flagsOnDeath, posOnDeath, rotOnDeath, triggersOnDeath, forceServerSide);
            }
        }

        private void ccmdCreatePhantom(ConsoleSystem.Arg arg)
        {
            void CopySerializableFields<T>(T src, T dst)
            {
                foreach (FieldInfo field in typeof(T).GetFields(BindingFlags.Instance | BindingFlags.Public))
                {
                    field.SetValue(dst, field.GetValue(src));
                }
            }

            BasePlayer player = arg.Player();

            if (player == null)
            {
                arg.ReplyWith("Type it in game");
                return;
            }

            if (!arg.IsAdmin && !permission.UserHasPermission(player.userID.ToString(), permissionName))
            {
                player.ChatMessage(LangAPI("NoPermission", player.UserIDString));
                return;
            }

            if (!Physics.Raycast(player.eyes.HeadRay(), out var hit, config.Settings.MaxRaycastDistance))
            {
                player.ChatMessage(LangAPI("LookElsewhere", player.UserIDString));
                return;
            }

            GameObject prefab = GameManager.server.FindPrefab(playerPrefab);
            GameObject go = Facepunch.Instantiate.GameObject(prefab, hit.point, player.transform.rotation);

            go.SetActive(false);

            go.name = playerPrefab;

            BasePlayer target = go.GetComponent<BasePlayer>();
            Phantom phantom = go.AddComponent<Phantom>();

            CopySerializableFields(target, phantom);

            UnityEngine.Object.DestroyImmediate(target, true);

            UnityEngine.SceneManagement.SceneManager.MoveGameObjectToScene(go, Rust.Server.EntityScene);

            go.SetActive(true);

            phantom._instance = this;
            phantom.userID = phantomId;
            phantom.UserIDString = phantomId.ToString(); 
            phantom.NoCorpseLoot = config.Settings.StripPhantomsOnDeath;
            phantom.NoCorpse = config.Settings.DestroyPhantomCorpses;
            phantom.NoLooting = config.Settings.PreventPhantomLooting;

            phantom.Spawn();

            phantom.networkId = phantom.net.ID.Value;

            phantoms[phantom.net.ID.Value] = phantom;

            if (config.Settings.RandomHealth)
            {
                phantom.health = (float)Math.Round(UnityEngine.Random.Range(35f, 100f), 2);
            }
            else phantom.health = 100f;
            
            if (config.Settings.PhantomsSpawnSleeping)
            {
                phantom.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            }

            if (config.Settings.RandomNames.Count == 0)
            {
                List<BasePlayer> sleepers = new(BasePlayer.sleepingPlayerList);

                if (sleepers.Count > 0)
                {
                    float sqrDistance = Mathf.Pow(config.Settings.MinDistanceFromRealSleeper, 2f);

                    BasePlayer sleeper;

                    do
                    {
                        sleeper = sleepers.GetRandom();
                        sleepers.Remove(sleeper);
                    } while ((sleeper.transform.position - phantom.transform.position).sqrMagnitude < sqrDistance && sleepers.Count > 0);

                    if (config.Invisibility.HideRealSleepers)
                    {
                        phantom.EntityDestroyOnClient(sleeper);
                    }

                    phantom.displayName = sleeper.displayName;
                }
                else phantom.displayName = config.Settings.DefaultNameIfNoSleepers;
            }
            else phantom.displayName = config.Settings.RandomNames.GetRandom();

            Equip(phantom);

            phantom.SendNetworkUpdateImmediate(true);
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permissionName, this);
            cmd.AddConsoleCommand(config.Settings.ConsoleCommand, this, nameof(ccmdCreatePhantom));
        }

        private void Unload()
        {
            List<Phantom> objects = new(phantoms.Values);
            foreach (var obj in objects)
            {
                UnityEngine.Object.Destroy(obj);
            }
            phantoms.Clear();
        }

        private void Equip(Phantom phantom)
        {
            EquipItem(phantom, config.Gear.Gloves);
            EquipItem(phantom, config.Gear.Boots);
            EquipItem(phantom, config.Gear.Helms);
            EquipItem(phantom, config.Gear.Vests);
            EquipItem(phantom, config.Gear.Shirts);
            EquipItem(phantom, config.Gear.Pants);
            EquipItem(phantom, config.Gear.Weapons);
        }

        private void EquipItem(Phantom phantom, List<string> itemNames)
        {
            if (itemNames.Count == 0)
            {
                return;
            }
            Item item = ItemManager.CreateByName(itemNames.GetRandom());
            if (item == null)
            {
                return;
            }
            if (!item.info.skins2.IsNullOrEmpty())
            {
                item.skin = item.info.skins2.GetRandom().WorkshopId;
                item.MarkDirty();
            }
            ItemContainer container = phantom.inventory.containerWear;
            if (item.GetHeldEntity() is HeldEntity heldEntity)
            {
                container = phantom.inventory.containerBelt;
                heldEntity.skinID = item.skin;
                heldEntity.SendNetworkUpdateImmediate();
            }
            if (item.MoveToContainer(container, -1, false))
            {
                phantom.items.Add(item);
            }
            else
            {
                item.Remove();
            }
        }

        #region Config

        private Configuration config;

        private class Configuration
        {
            [JsonProperty("Invisibility")]
            public InvisibilityConfig Invisibility { get; set; } = new();

            [JsonProperty("Settings")]
            public SettingsConfig Settings { get; set; } = new();

            [JsonProperty("Gear")]
            public GearConfig Gear { get; set; } = new();
        }

        private class InvisibilityConfig
        {
            [JsonProperty("Hide Real Sleepers")]
            public bool HideRealSleepers { get; set; }
        }

        private class SettingsConfig
        {
            [JsonProperty("Random Names", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> RandomNames { get; set; } = new();

            [JsonProperty("Strip Phantoms On Death")]
            public bool StripPhantomsOnDeath { get; set; } = true;

            [JsonProperty("Destroy Phantom Corpses")]
            public bool DestroyPhantomCorpses { get; set; } = true;

            [JsonProperty("Prevent Phantom Looting")]
            public bool PreventPhantomLooting { get; set; } = true;

            [JsonProperty("Console Command")]
            public string ConsoleCommand { get; set; } = "createphantom";

            [JsonProperty("Max Raycast Distance")]
            public float MaxRaycastDistance { get; set; } = 100f;

            [JsonProperty("Min Distance From Real Sleeper")]
            public float MinDistanceFromRealSleeper { get; set; } = 450f;

            [JsonProperty("Default Name If No Sleepers")]
            public string DefaultNameIfNoSleepers { get; set; } = "luke";

            [JsonProperty("Phantoms Spawn Sleeping")]
            public bool PhantomsSpawnSleeping { get; set; } = true;

            [JsonProperty("Random Starting Health")]
            public bool RandomHealth { get; set; }
        }

        private class GearConfig
        {
            [JsonProperty("Shirts", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Shirts { get; set; } = new() { "tshirt", "tshirt.long", "shirt.tanktop", "shirt.collared" };

            [JsonProperty("Pants", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Pants { get; set; } = new() { "pants" };

            [JsonProperty("Helms", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Helms { get; set; } = new() { "metal.facemask" };

            [JsonProperty("Vests", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Vests { get; set; } = new() { "metal.plate.torso" };

            [JsonProperty("Gloves", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Gloves { get; set; } = new() { "burlap.gloves" };

            [JsonProperty("Boots", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Boots { get; set; } = new() { "shoes.boots" };

            [JsonProperty("Weapons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Weapons { get; set; } = new() { "pistol.semiauto" };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            canSaveConfig = false;
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                canSaveConfig = true;
                SaveConfig();
            }
            catch (Exception ex)
            {
                Puts(ex.ToString());
                LoadDefaultConfig();
            }
        }

        private bool canSaveConfig = true;

        protected override void SaveConfig()
        {
            if (canSaveConfig)
            {
                Config.WriteObject(config);
            }
        }

        protected override void LoadDefaultConfig() => config = new();

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new()
            {
                ["LookElsewhere"] = "Unable to find a position. Try looking at the ground or another object.",
                ["NoPermission"] = "You do not have permission to use this command.",
            }, this);
        }

        private string LangAPI(string key, string id = null, params object[] args) => args.Length > 0 ? string.Format(lang.GetMessage(key, this, id), args) : lang.GetMessage(key, this, id);

        #endregion Config
    }
}


// --- End of file: PhantomSleepers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pvp-toggle ---
// --- Original File Path: P/PvpToggle/PvpToggle.cs ---

﻿using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("PvP Toggle", "0x89A", "1.1.5")]
    [Description("Allows PvP to be toggled on and off ")]
    class PvpToggle : CovalencePlugin 
    {
        private bool pvpActive;

        private const string canuse = "pvptoggle.use";

        void Init()
        {
            permission.RegisterPermission(canuse, this);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string> 
            { 
                ["SyntaxError"] = "Syntax error: '/pvp <true/false>'",
                ["SetActive"] = "Pvp is now enabled",
                ["SetInactive"] = "Pvp is now disabled",
                ["NoPermission"] = "You do not have permission to use this command"
            }, this);
        }

        [Command("pvp")]
        void ConsoleToggle(IPlayer player, string command, string[] args)
        {
            if (player.IsAdmin || permission.UserHasPermission(player.Id, canuse))
            {
                if (args.Length == 1)
                {
                    TogglePvp(player, args[0]);
                }
                else
                {
                    player.Message(lang.GetMessage("SyntaxError", this, player.Id));
                }

                return;
            }

            player.Message(lang.GetMessage("NoPermission", this, player.Id));
        }

        void TogglePvp(IPlayer player, string args)
        {
            bool set;
            if (!bool.TryParse(args, out set))
            {
                player.Message(lang.GetMessage("SyntaxError", this));
                return;
            }

            pvpActive = set;

            player.Message(lang.GetMessage(pvpActive ? "SetActive" : "SetInactive", this, player.Id));
        }

        object OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (hitInfo != null && ((hitInfo.Initiator != null && hitInfo.Initiator.IsNpc) || (hitInfo.HitEntity != null && hitInfo.HitEntity.IsNpc)))
            {
                return null;
            }
            
            if (hitInfo == null || (!pvpActive && hitInfo.Initiator != null && !hitInfo.Initiator.IsNpc))
            {
                return true;
            }

            return null;
        }
    }
}

// --- End of file: PvpToggle.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/prod ---
// --- Original File Path: P/Prod/Prod.cs ---

﻿using System;
using System.Collections.Generic;
using System.Reflection;
using Oxide.Core.Plugins;
using Oxide.Core;
using Oxide.Core.Configuration;
using UnityEngine;
using System.Text;

namespace Oxide.Plugins
{
    [Info("Prod", "Quapi", "2.5.4")]
    class Prod : RustPlugin
    {
        private DynamicConfigFile BuildingData;
        private int prodAuth;
        private string helpProd;
        private string noAccess;
        private string noTargetfound;
        private string noCupboardPlayers;
        private string Toolcupboard;
        private string noBlockOwnerfound;
        private string noCodeAccess;
        private string codeLockList;
        private string informationAdded;
        private bool passiveMode;
        private string passive_Codelock_List;
        private string boxNeedsCode;
        private string boxCode;
        private static bool serverInitialized = false;
        private bool printToConsoleInsteadOfChat;

        private FieldInfo serverinput;
        private FieldInfo codelockwhitelist;
        private FieldInfo codenum;
        //private FieldInfo meshinstances;

        private Vector3 eyesAdjust;
        private bool Changed;

        [PluginReference]
        Plugin PlayerDatabase;

        void Loaded()
        {
            LoadVariables();

            permission.RegisterPermission("prod.passive.use", this);

            cmd.AddChatCommand(prodCommand, this, "cmdChatProd");

            BuildingData = Interface.GetMod().DataFileSystem.GetDatafile("Prod_BuildingData");

            eyesAdjust = new Vector3(0f, 1.5f, 0f);
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            codelockwhitelist = typeof(CodeLock).GetField("whitelistPlayers", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            codenum = typeof(CodeLock).GetField("code", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            //meshinstances = typeof(MeshColliderLookup).GetField("instances", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        private bool isPluginDev;
        private bool dumpAll;
        private string prodCommand;
        private void LoadVariables()
        {
            printToConsoleInsteadOfChat = Convert.ToBoolean(GetConfig("Prod", "Print to player console instead of chat? ", false));
            prodAuth = Convert.ToInt32(GetConfig("Prod", "authLevel", 1));
            prodCommand = Convert.ToString(GetConfig("Prod", "Command", "prod"));
            passiveMode = Convert.ToBoolean(GetConfig("Prod", "Passive Mode", false));
            isPluginDev = Convert.ToBoolean(GetConfig("Plugin Dev", "Are you are plugin dev?", false));
            dumpAll = Convert.ToBoolean(GetConfig("Plugin Dev", "Dump all components of all entities that you are looking at? (false will do only the closest one)", false));
            informationAdded = Convert.ToString(GetConfig("Messages", "Information added message (Only works with printToConsole option on.)", "New information was printed to your console. (Press F1)"));
            helpProd = Convert.ToString(GetConfig("Messages", "helpProd", "/prod on a building or tool cupboard to know who owns it."));
            noAccess = Convert.ToString(GetConfig("Messages", "noAccess", "You don't have access to this command"));
            noTargetfound = Convert.ToString(GetConfig("Messages", "noTargetfound", "You must look at a tool cupboard or building"));
            noCupboardPlayers = Convert.ToString(GetConfig("Messages", "noCupboardPlayers", "No players has access to this cupboard"));
            Toolcupboard = Convert.ToString(GetConfig("Messages", "Toolcupboard", "Tool Cupboard"));
            noBlockOwnerfound = Convert.ToString(GetConfig("Messages", "noBlockOwnerfound", "No owner found for this building block"));
            noCodeAccess = Convert.ToString(GetConfig("Messages", "noCodeAccess", "No players has access to this Lock"));
            codeLockList = Convert.ToString(GetConfig("Messages", "codeLockList", "CodeLock whitelist:"));
            boxNeedsCode = Convert.ToString(GetConfig("Messages", "boxNeedsCode", "Can't find owners of an item without a Code Lock"));
            passive_Codelock_List = Convert.ToString(GetConfig("Messages", "Passive Mode: Codelock List", "Codelock Whitelist:"));
            boxCode = Convert.ToString(GetConfig("Messages", "Code", "Code is: {0}"));

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Prod: Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        #region -random-
        void OnServerInitialized() { serverInitialized = true; }

        void OnServerSave()
        {
            SaveData();
        }

        void OnServerQuit()
        {
            SaveData();
        }

        void OnEntityBuilt(HeldEntity heldentity, GameObject gameobject)
        {
            if (!serverInitialized) return;

            var block = gameobject.GetComponent<BuildingBlock>();
            if (block == null) return;

            var player = heldentity.GetOwnerPlayer();
            if (player == null) return;

            var blockdata = FindBlockData(block);
            if (blockdata is string) return;

            SetBlockData(block, player.IPlayer.Id);
        }
        #endregion

        #region -Building Data-
        void SaveData()
        {
            Interface.GetMod().DataFileSystem.SaveDatafile("Prod_BuildingData");
        }

        void SetBlockData(BuildingBlock block, string steamid)
        {
            BuildingData[block.buildingID.ToString()] = steamid;
        }

        object FindBlockData(BuildingBlock block)
        {
            var buildingid = block.buildingID.ToString();
            if (BuildingData[buildingid] != null) return BuildingData[buildingid];
            return false;
        }
        #endregion

        #region -General-
        private bool hasAccess(BasePlayer player)
        {
            return player.net.connection.authLevel >= prodAuth;
        }

        void cmdChatProd(BasePlayer player, string command, string[] args)
        {
            if (printToConsoleInsteadOfChat)
            {
                player.IPlayer.Message(informationAdded);
            }

            var target = DoRay(player.eyes.HeadRay());

            if (!hasAccess(player))
            {
                if (passiveMode)
                    if (player.IPlayer.HasPermission("prod.passive.use"))
                    {
                        if (target == null)
                        {
                            SendReply(player, noTargetfound);
                            return;
                        }
                       
                        if (target.GetComponentInParent<BuildingBlock>())
                        {
                            Passive_GetBuildingBlockOwner(player, target.GetComponentInParent<BuildingBlock>());
                            return;
                        }

                        if (target.HasSlot(BaseEntity.Slot.Lock))
                        {
                            Passive_GetCodelockWhitelisted(player, target);
                            return;
                        }

                        return;
                    }
                    else
                    {
                        SendReply(player, noAccess);
                        return;
                    }
                else
                {
                    SendReply(player, noAccess);
                    return;
                }
            }

            if (target == null)
            {
                SendReply(player, noTargetfound);
                return;
            }

            if (isPluginDev && !dumpAll)
            {
                Dump(target);
            }

            if (target.OwnerID != 0L)
            {
                SendReply(player, string.Format("Entity Owner (Builder): {0} {1}", FindPlayerName(target.OwnerID), target.OwnerID));
            }


            var block = target.GetComponentInParent<BuildingBlock>();
            if (block)
            {
                GetBuildingblockOwner(player, block);
                return;
            }

            var priv = target.GetComponentInParent<BuildingPrivlidge>();
            if (priv)
            {
                GetToolCupboardUsers(player, priv);
                return;
            }

            var bag = target.GetComponentInParent<SleepingBag>();
            if (bag)
            {
                GetDeployedItemOwner(player, bag);
                return;
            }

            if (target.HasSlot(BaseEntity.Slot.Lock))
            {
                GetDeployableCode(player, target);
                return;
            }        
        }

        private void GetDeployableCode(BasePlayer player, BaseEntity block)
        {
            BaseEntity slotent = block.GetSlot(BaseEntity.Slot.Lock);
            CodeLock codelock = slotent?.GetComponent<CodeLock>();
            if (codelock != null)
            {
                List<ulong> whitelisted = codelockwhitelist.GetValue(codelock) as List<ulong>;
                string codevalue = codenum.GetValue(codelock) as string;
                SendReply(player, string.Format(boxCode, codevalue));
                SendReply(player, codeLockList);
                if (whitelisted.Count == 0)
                {
                    SendReply(player, noCodeAccess);
                    return;
                }
                SendBasePlayerFind(player, whitelisted);
            }
        }

        private void GetDeployedItemOwner(BasePlayer player, SleepingBag ditem)
        {
            SendReply(player, string.Format("Sleeping Bag '{0}': {1} - {2}", ditem.niceName, FindPlayerName(ditem.deployerUserID), ditem.deployerUserID));
        }

        private object FindOwnerBlock(BuildingBlock block)
        {
            object returnhook = FindBlockData(block);
            if (returnhook != null)
            {
                if (!(returnhook is bool))
                {
                    ulong ownerid = Convert.ToUInt64(returnhook);
                    return ownerid;
                }
            }
            Puts("Prod: Owner not found.");
            return false;
        }

        private string FindPlayerName(ulong userId)
        {
            BasePlayer player = BasePlayer.FindByID(userId);
            if (player)
                return player.displayName + " (Online)";

            player = BasePlayer.FindSleeping(userId);
            if (player)
                return player.displayName + " (Sleeping)";

            var iplayer = covalence.Players.FindPlayer(userId.ToString());
            if (iplayer != null)
                return iplayer.Name + " (Dead)";

            var name2 = PlayerDatabase?.Call("GetPlayerData", userId.ToString(), "default");
            if (name2 is Dictionary<string, object>)
                return ((name2 as Dictionary<string, object>)["name"] as string) + " (Dead)";

            return "Unknown player";
        }

        private void SendBasePlayerFind(BasePlayer player, List<ulong> ownerid)
        {
            StringBuilder stringBuilder = new StringBuilder();
            foreach (ulong id in ownerid)
            {
                stringBuilder.AppendLine(string.Format("{0} {1}", FindPlayerName(id), id));
            }
            SendReply(player, stringBuilder.ToString());
        }

        private void GetBuildingblockOwner(BasePlayer player, BuildingBlock block)
        {
            if (block.GetComponent<Door>() != null)
            {
                if (block.HasSlot(BaseEntity.Slot.Lock))
                {
                    BaseEntity slotent = block.GetSlot(BaseEntity.Slot.Lock);
                    CodeLock codelock = slotent?.GetComponent<CodeLock>();
                    if (codelock != null)
                    {
                        List<ulong> whitelisted = codelockwhitelist.GetValue(codelock) as List<ulong>;
                        string codevalue = codenum.GetValue(codelock) as string;
                        SendReply(player, string.Format(boxCode, codevalue));
                        SendReply(player, codeLockList);
                        if (whitelisted.Count == 0)
                        {
                            SendReply(player, noCodeAccess);
                            return;
                        }
                        foreach (ulong userid in whitelisted)
                        {
                            SendReply(player, string.Format("{0} {1}", FindPlayerName(userid), userid));
                        }
                    }

                }
            }

            object findownerblock = FindOwnerBlock(block);
            if (findownerblock is bool)
            {
                SendReply(player, noBlockOwnerfound);
                return;
            }
            ulong ownerid = (ulong)findownerblock;
            SendReply(player, string.Format("Building Owner: {0} {1}", FindPlayerName(ownerid), ownerid));
            List<ulong> list = new List<ulong>();
            list.Add(ownerid);
            SendBasePlayerFind(player, list);
        }

        private void GetToolCupboardUsers(BasePlayer player, BuildingPrivlidge cupboard)
        {
            SendReply(player, string.Format("{0} - {1} {2} {3}", Toolcupboard, Math.Round(cupboard.transform.position.x), Math.Round(cupboard.transform.position.y), Math.Round(cupboard.transform.position.z)));
            if (cupboard.authorizedPlayers.Count == 0)
            {
                SendReply(player, noCupboardPlayers);
                return;
            }
            foreach (ProtoBuf.PlayerNameID pnid in cupboard.authorizedPlayers)
            {
                SendReply(player, string.Format("{0} - {1}", pnid.username, pnid.userid));
            }
        }

        private void Dump(BaseEntity col)
        {
            Puts(col.GetComponent<StabilityEntity>().ToString());
            Puts("==================================================");
            Puts(col + " " + LayerMask.LayerToName(col.gameObject.layer));
            Puts("========= NORMAL ===========");
            foreach (Component com in col.GetComponents(typeof(Component)))
            {
                Puts(com.GetType() + " " + com);
            }
            Puts("========= PARENT ===========");
            foreach (Component com in col.GetComponentsInParent(typeof(Component)))
            {
                Puts(com.GetType() + " " + com);
            }
            Puts("========= CHILDREN ===========");
            foreach (Component com in col.GetComponentsInChildren(typeof(Component)))
            {
                Puts(com.GetType() + " " + com);
            }
        }

        private BaseEntity DoRay(Ray ray)
        {
            float distance = 100000f;
            BaseEntity target = null;
            var hits = Physics.RaycastAll(ray);
            foreach (var hit in hits)
            {
                if (hit.collider != null && isPluginDev && dumpAll)
                    Dump(hit.GetEntity());
                if (hit.distance < distance)
                {
                    distance = hit.distance;
                    target = hit.GetEntity();
                }
            }
            return target;
        }

        void SendHelpText(BasePlayer player)
        {
            if (hasAccess(player)) SendReply(player, helpProd);
        }


        public new void SendReply(BasePlayer player, string format, params object[] args)
        {
            if (printToConsoleInsteadOfChat)
            {
                player.ConsoleMessage(String.Format(format, args));
            } else
            {
                player.ChatMessage(String.Format(format, args));
            }
        }
        #endregion

        #region -Passive Mode-
        private void Passive_GetBuildingBlockOwner(BasePlayer player, BuildingBlock block)
        {
            object findownerblock = FindOwnerBlock(block);
            if (findownerblock is bool)
            {
                SendReply(player, noBlockOwnerfound);
                return;
            }
            ulong ownerid = (ulong)findownerblock;
            SendReply(player, string.Format("Building Owner: {0}", FindPlayerName(ownerid)));
        }

        private void Passive_GetCodelockWhitelisted(BasePlayer player, BaseEntity block)
        {
            BaseEntity slotent = block.GetSlot(BaseEntity.Slot.Lock);
            CodeLock codelock = slotent?.GetComponent<CodeLock>();
            if (codelock != null)
            {
                List<ulong> whitelisted = codelockwhitelist.GetValue(codelock) as List<ulong>;
                SendReply(player, codeLockList);
                if (whitelisted.Count == 0)
                {
                    SendReply(player, noCodeAccess);
                    return;
                }
                foreach (ulong userid in whitelisted)
                {
                    Passive_SendBasePlayerFind(player, userid);
                }
            } else
            {
                SendReply(player, "Codelock was not found.");
                return;
            }
        }

        private void Passive_SendBasePlayerFind(BasePlayer player, ulong ownerid)
        {
            SendReply(player, string.Format("{0}", FindPlayerName(ownerid)));
        }
        #endregion
    }
}
  

// --- End of file: Prod.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/play-fx ---
// --- Original File Path: P/PlayFX/PlayFX.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Network;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Play FX", "misticos", "2.0.1")]
    [Description("Play any effect on a player, such as an explosion sound.")]
    class PlayFX : CovalencePlugin
    {
        #region Variables

        private const string PermissionUse = "playfx.use";
        
        #endregion
        
        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] Commands = { "playfx.run", "playfx" };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion
        
        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Command: Syntax", "Syntax:\n" +
                                    "player (Name or ID) (Prefab) - Play this prefab for one player\n" +
                                    "all (Prefab) - Play this prefab for all players"},
                {"Command: User Not Found", "The user you've specified was not found."},
                {"Command: Prefab Not Found", "Prefab was not found."},
                {"Command: Effect Played", "The effect has been played."},
                {"Command: No Permission", "You do not have enough permissions."}
            }, this);
        }

        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
            
            AddCovalenceCommand(_config.Commands, nameof(CommandRun));
        }

        #endregion
        
        #region Commands

        private void CommandRun(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionUse))
            {
                player.Reply(GetMsg("Command: No Permission", player.Id));
                return;
            }
            
            if (args.Length < 2)
                goto syntax;

            IEnumerable<BasePlayer> targets;
            string effect;
            
            switch (args[0].ToLower())
            {
                case "player":
                {
                    if (args.Length < 3)
                        goto syntax;
                    
                    var target = players.FindPlayer(args[1])?.Object as BasePlayer;
                    if (target == null)
                    {
                        player.Reply(GetMsg("Command: User Not Found", player.Id));
                        return;
                    }

                    effect = string.Join(" ", args.Skip(2));
                    targets = new[] {target};
                    break;
                }

                case "all":
                {
                    effect = string.Join(" ", args.Skip(1));
                    targets = BasePlayer.activePlayerList;
                    break;
                }
                
                default:
                    goto syntax;
            }

            var effectId = StringPool.Get(effect);
            if (effectId == 0)
            {
                player.Reply(GetMsg("Command: Prefab Not Found", player.Id));
                return;
            }
            
            RunEffect(targets, effect, effectId);

            player.Reply(GetMsg("Command: Effect Played", player.Id));
            return;
            
            syntax:
            player.Reply(GetMsg("Command: Syntax", player.Id));
        }
        
        #endregion
        
        #region Helpers

        private Effect _effect = new Effect {broadcast = true};

        private void RunEffect(IEnumerable<BasePlayer> targets, string prefab, uint prefabId)
        {
            _effect.Init(Effect.Type.Generic, Vector3.zero, Vector3.zero);
            _effect.pooledString = prefab;
            _effect.pooledstringid = prefabId;

            foreach (var target in targets)
            {
                var write = Net.sv.StartWrite();
                
                write.PacketID(Message.Type.Effect);

                _effect.entity = target.net.ID;
                _effect.worldPos = target.transform.position;
                _effect.WriteToStream(write);

                write.Send(new SendInfo(target.net.connection));
            }
        }

        private string GetMsg(string key, string id = null) => lang.GetMessage(key, this, id);

        #endregion
    }
}

// --- End of file: PlayFX.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/permission-group-sync ---
// --- Original File Path: P/PermissionGroupSync/PermissionGroupSync.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core.Database;

namespace Oxide.Plugins {

    [Info("Permission Group Sync", "Apec", "2.1.1")]
    [Description("Synchronizes sets of Groups and Permissions with customizable Commands across multiple Servers")]

    public class PermissionGroupSync : CovalencePlugin {

        #region Globals

        private const string PermissionGroupSyncPerm = "permissiongroupsync";
        private const string PermissionGroupSyncPermAdmin = "permissiongroupsync.globaladmin";
        private const string sql_table = "permissiongroupsync";
        private const string ServerIdAll = "_ALL";

        private readonly Core.MySql.Libraries.MySql _mySql = new Core.MySql.Libraries.MySql();
		private Connection _mySqlConnection = null;

        private bool PluginLoaded = false;

        #endregion Globals

        #region Config

        Configuration _cfg;

        private void InitializeConfig() {
            try {
                _cfg = Config.ReadObject<Configuration>();
            } catch {
                try {
                    LoadDefaultConfig();
                    SaveConfig();
                } catch {
                    PrintError(Lang("ErrorConfig"));
                }
            }
        }
        
        protected override void LoadDefaultConfig() => _cfg = new Configuration();
        protected override void SaveConfig() => Config.WriteObject(_cfg);

        #endregion Config

        #region Lang

        private new void LoadDefaultMessages() {
            lang.RegisterMessages(new Dictionary<string, string> {
                ["ErrorConfig"] = "Error: Could not read config values or invalid / empty options specified.",
                ["ErrorDatabaseConnect"] = "Error: Could not connect to Database {0}. Check Connection and Service.",
                ["ErrorDatabase"] = "Error: Could not read or write from Database {0}: {1}",
                ["ErrorCommand"] = "Error: Could not modify Group Permissions for Player {0}.",
                ["ConnectedDatabase"] = "Connected to Database {0}.",
                ["NoPermissions"] = "You don't have Permissions to use this Command.",
                ["InvalidSyntax"] = "Invalid Syntax. Use /{0} <add or remove> <steamId> <optional:serverId>.",
                ["InvalidSteamId"] = "No valid SteamId provided.",
                ["GroupAdded"] = "Added {0} to Group {1} for ServerId: {2}",
                ["GroupRemoved"] = "Removed {0} from Group {1}  for ServerId: {2}",
                ["NoAction"] = "No action needed because {0} is already in Group or removed.",
                ["PermissionChanged"] = "Your ingame Permissions have changed. Please relog so they can apply.",
                ["NoLongerInDB"] = "Removing {0} from {1} because no longer in Database.",
                ["NotRemovedProtected"] = "Could not remove {0} from Group {1} because Group is protected.",
                ["NotAddedGroup"] = "Permissions could not be added to Group. Retrying.",
                ["PermissionChangedLog"] = "Changed AuthLevel for User {0} to {1}.",
            }, this);
        }

        #endregion Lang

        #region Init

        private void Init() {
            InitializeConfig();

			permission.RegisterPermission(PermissionGroupSyncPermAdmin, this);

            foreach (GroupPermission entry in _cfg.GroupPermissions) {
                AddCovalenceCommand(entry.CommandName, nameof(Command_PermissionGroupSync));

                if (entry.PermissionUse)
                    permission.RegisterPermission($"{PermissionGroupSyncPerm}.{entry.CommandName}", this);
            }
        }

        void OnServerInitialized() {
            InitializeDatabase();

            if (PluginLoaded) {
                foreach(GroupPermission entry in _cfg.GroupPermissions)
                    InitializeGroup(entry.GroupName, entry.PermissionsOxide);
                
                RunTimer();
            }
        }

		private void InitializeDatabase() {
			if (_mySqlConnection == null)
			{
                if (_cfg.DatabaseConfiguration.Host == "") {
                    PrintWarning(Lang("The configuration has not been set up yet. Plugin not laoded."));
                    return;
                }

                try {
				    _mySqlConnection = _mySql.OpenDb(_cfg.DatabaseConfiguration.Host, _cfg.DatabaseConfiguration.Port, _cfg.DatabaseConfiguration.Database, _cfg.DatabaseConfiguration.Username, _cfg.DatabaseConfiguration.Password, this);
                    PluginLoaded = true;

				    Puts(string.Format(Lang("ConnectedDatabase"), _cfg.DatabaseConfiguration.Database));
                } catch {
                    PrintError(string.Format(Lang("ErrorDatabaseConnect"), _cfg.DatabaseConfiguration.Database));
                    return;
                }

                try {
                    var sql = Sql.Builder.Append($"SHOW TABLES LIKE '{sql_table}'");
                    _mySql.Query(sql, _mySqlConnection, list => {
                        if ((list == null) || ((list != null) && (list.Count == 0)))
                        {
                            _mySql.Insert(Sql.Builder.Append("SET SQL_MODE = 'NO_AUTO_VALUE_ON_ZERO'"), _mySqlConnection);
                            _mySql.Insert(Sql.Builder.Append($"CREATE TABLE IF NOT EXISTS {sql_table} ( `id` int(32) NOT NULL, `steamid` varchar(17) DEFAULT NULL, `groupname` varchar(255) DEFAULT NULL, `serverid` VARCHAR(255) NOT NULL DEFAULT '{ServerIdAll}' ) ENGINE=InnoDB DEFAULT CHARSET=latin1;"), _mySqlConnection);
                            _mySql.Insert(Sql.Builder.Append($"ALTER TABLE {sql_table} ADD PRIMARY KEY (`id`);"), _mySqlConnection);
                            _mySql.Insert(Sql.Builder.Append($"ALTER TABLE {sql_table} MODIFY `id` int(32) NOT NULL AUTO_INCREMENT;"), _mySqlConnection);
                        }
                    });
                } catch (Exception ex) {
                    PrintError(string.Format(Lang("ErrorDatabase"), _cfg.DatabaseConfiguration.Database, ex.Message));
                }
			}
		}

        private void RunTimer() {
			timer.Every(_cfg.PollIntervalSeconds, SyncPermissions);
		}

        #endregion Init

		#region Chat Command
		
        private void Command_PermissionGroupSync(IPlayer player, string command, string[] args) {
            GroupPermission groupPermission = null;

            foreach (GroupPermission entry in _cfg.GroupPermissions) {
                if (entry.CommandName.ToLower() == command.ToLower()) {
                    groupPermission = entry;
                    break;
                }
            }
            if (groupPermission == null) {
                PrintError(Lang("ErrorConfig"));
                return;
            }
			if ((!permission.UserHasPermission(player.Id, PermissionGroupSyncPermAdmin) || ((groupPermission.PermissionUse) && (!permission.UserHasPermission(player.Id, $"{PermissionGroupSyncPerm}.{groupPermission.GroupName}"))))) {
                player.Reply(Lang("NoPermissions"));
                return;
			}
            
			if (args == null || args.Length < 2 || args.Length > 3) {
                player.Reply(Lang("InvalidSyntax"));
                return;
            } else {
                
                HashSet<string> usersGroupsCurrent = GetCurrentUserIds(groupPermission.GroupName);

                string steamId = args[1];
                ulong steamIdNumber = CheckUserSteamId(steamId);
                string mode = args[0].ToLower();
                string commandExec, queryExec, response = "";
                string serverId = ServerIdAll;

                if (steamIdNumber == 0) {
                    player.Reply(Lang("InvalidSteamId"));
                    return;
                }

                if ((args.Length == 3) && (args[2] != null))
                    serverId = args[2];

                List<GroupPermissionDb> groupPermissionsDb = new List<GroupPermissionDb>(); 
                string sqlTextQuery = String.Format("SELECT steamid, groupname, serverid FROM {0} ORDER BY groupname ASC, serverid ASC", sql_table);

                var sqlQuery = Sql.Builder.Append(sqlTextQuery);
                _mySql.Query(sqlQuery, _mySqlConnection, list => {
                    if (list == null)
                        return;

                    foreach (var entry in list) {
                        GroupPermissionDb groupPermissionDb = new GroupPermissionDb
                        {
                            SteamId = CheckUserSteamId(entry["steamid"].ToString()),
                            GroupName = entry["groupname"].ToString(),
                            ServerId = entry["serverid"].ToString(),
                        };
                        groupPermissionsDb.Add(groupPermissionDb);
                    }

                    switch (mode) {
                        case "add":
                            if (groupPermissionsDb.Where(x => ((x.SteamId == steamIdNumber) && (x.GroupName == groupPermission.GroupName) && (x.ServerId == serverId))).Count() > 0) {
                                player.Reply(String.Format(Lang("NoAction"), steamId));
                                return;
                            }

                            queryExec = $"INSERT INTO {sql_table} (steamid, groupname, serverid) SELECT * FROM (SELECT @0, @1, @2) AS tmp WHERE NOT EXISTS (SELECT steamid FROM {sql_table} WHERE steamid=@0 AND groupname=@1 AND serverid=@2) LIMIT 1";
                            response = Lang("GroupAdded");
                            break;

                        case "remove":
                            if (groupPermissionsDb.Where(x => ((x.SteamId == steamIdNumber) && (x.GroupName == groupPermission.GroupName) && (x.ServerId == serverId))).Count() == 0) {
                                player.Reply(String.Format(Lang("NoAction"), steamId));
                                return;
                            }

                            queryExec = $"DELETE FROM {sql_table} WHERE steamid=@0 AND groupname=@1 AND serverid=@2";
                            response = Lang("GroupRemoved");
                            break;

                        default:
                            player.Reply(Lang("InvalidSyntax"));
                            return;
                    }

                    try {
                        executeQuery(queryExec, steamId.ToString(), groupPermission.GroupName, serverId);
                        player.Reply(String.Format(response, steamId.ToString(), groupPermission.GroupName, serverId));
                    } catch (Exception ex) {
                        player.Reply(String.Format(Lang("ErrorDatabase"), sql_table, ex.Message));
                    }

                });
            }
        }

        #endregion Chat Command

        #region Helpers

        private string Lang(string key, string userId = null) => lang.GetMessage(key, this, userId);

		public void SyncPermissions() {

            List<GroupPermissionDb> groupPermissionsDb = new List<GroupPermissionDb>();

            string sqlTextQuery = String.Format("SELECT steamid, groupname, serverid FROM {0} ORDER BY groupname ASC, serverid ASC", sql_table);

            var sqlQuery = Sql.Builder.Append(sqlTextQuery);
            _mySql.Query(sqlQuery, _mySqlConnection, list => {
                if (list == null)
                    return;

                foreach (var entry in list) {
                    GroupPermissionDb groupPermissionDb = new GroupPermissionDb
                    {
                        SteamId = CheckUserSteamId(entry["steamid"].ToString()),
                        GroupName = entry["groupname"].ToString(),
                        ServerId = entry["serverid"].ToString(),
                    };
                    groupPermissionsDb.Add(groupPermissionDb);
                }

                HashSet<string> queryList = new HashSet<string>();
                HashSet<string> commandList = new HashSet<string>();
                List<GroupPermissionRustDb> groupPermissionsRustDb = new List<GroupPermissionRustDb>(); 
                bool executeWriteCommand = false;

                foreach(GroupPermission groupPermission in _cfg.GroupPermissions) {

                    List<GroupPermissionDb> usersGroupChecked = new List<GroupPermissionDb>();
                    HashSet<string> usersGroupCurrent = GetCurrentUserIds(groupPermission.GroupName);

                    foreach (GroupPermissionDb groupPermissionDb in groupPermissionsDb.Where(x => ((x.GroupName == groupPermission.GroupName) && ((x.ServerId == ServerIdAll) || (x.ServerId.Contains(_cfg.ServerId)))))) {
                        string steamId = groupPermissionDb.SteamId.ToString();
                        ulong steamIdNumber = groupPermissionDb.SteamId;
                        bool skipPermission = false;
                        bool executeAdditionalCommands = false;

                        if (steamIdNumber == 0)
                            break;

                        if ((!groupPermission.OverrideServerIdCheck) && (groupPermission.ExtendedPermissionHandling)) {
                            if (groupPermissionDb.ServerId == ServerIdAll) {
                                foreach (GroupPermissionDb groupPermissionDbTmp in groupPermissionsDb.Where(x => ((x.SteamId == groupPermissionDb.SteamId) && (x.ServerId != ServerIdAll) && (x.ServerId == _cfg.ServerId)))) {
                                    if (_cfg.GroupPermissions.Where(x => ((x.GroupName == groupPermissionDbTmp.GroupName) && (x.ExtendedPermissionHandling))).Count() > 0) {
                                        skipPermission = true;
                                        break;
                                    }
                                }
                            }
                        }

                        if ((CheckGroupExclude(groupPermission, steamId)) || (skipPermission))
                            continue;

                        if ((!CheckUserPermissionRust(steamIdNumber, groupPermission.PermissionRust)) && (groupPermission.ExtendedPermissionHandling)) {
                            if(SetUserPermissionRust(steamIdNumber, groupPermission.PermissionRust)) {
                                executeWriteCommand = true;
                                executeAdditionalCommands = true;
                            }
                        }

                        usersGroupChecked.Add(groupPermissionDb);
                        if ((usersGroupCurrent == null) || (!usersGroupCurrent.Contains(steamId))) {
                            permission.AddUserGroup(steamId, groupPermission.GroupName);
                            executeAdditionalCommands = true;
                        }

                        if ((groupPermission.GroupsRemove.Count > 0) && (groupPermission.ExtendedPermissionHandling))
                            queryList = RemoveGroups(groupPermission, steamId);

                        if ((queryList.Count > 0) || (executeAdditionalCommands)) {
                            foreach (string additionalCommand in groupPermission.AdditionalCommands) {
                                string additionalCommandRun = String.Format(additionalCommand, steamId);
                                commandList.Add(additionalCommandRun);
                            }
                        }
                    }

                    foreach (string userGroup in usersGroupCurrent) {
                        if (CheckGroupExclude(groupPermission, userGroup))
                            continue;

                        ulong steamIdNumber = CheckUserSteamId(userGroup);

                        if (steamIdNumber == 0)
                            return;

                        if (groupPermission.ExtendedPermissionHandling) {
                            if (usersGroupChecked.Where(x => ((x.SteamId == steamIdNumber) && (x.GroupName == groupPermission.GroupName) && ((x.ServerId == ServerIdAll) || (x.ServerId.Contains(_cfg.ServerId))))).Count() == 0) {
                                
                                if (!CheckUserPermissionRust(steamIdNumber, 0)) {
                                    bool _tmp = SetUserPermissionRust(steamIdNumber, 0);
                                }

                                permission.RemoveUserGroup(userGroup, groupPermission.GroupName);
                                PrintWarning(String.Format(Lang("NoLongerInDB"), userGroup, groupPermission.GroupName));
                            }

                            if (groupPermission.PermissionRust != 0) {
                                GroupPermissionRustDb groupPermissionRustDb = new GroupPermissionRustDb
                                {
                                    SteamId = steamIdNumber,
                                    PermissionRust = groupPermission.PermissionRust
                                };
                                groupPermissionsRustDb.Add(groupPermissionRustDb);
                            }
                        }
                    }
                }

                if (queryList.Count > 0) {
                    try {
                        executeQuery(String.Join("; ", queryList));
                    } catch (Exception ex) {
                        PrintError(String.Format(Lang("ErrorDatabase"), sql_table, ex.Message));
                    }
                }

                List<GroupPermissionRustDb> removeRustPerms = new List<GroupPermissionRustDb>(); 
                var userObjectsModerators = ServerUsers.GetAll(ServerUsers.UserGroup.Moderator);
                foreach (var userObject in userObjectsModerators) {
                    bool foundDb = false;

                    foreach (GroupPermissionRustDb groupPermissionRustDb in groupPermissionsRustDb) {
                        if ((groupPermissionRustDb.SteamId == userObject.steamid) && (groupPermissionRustDb.PermissionRust == 1)) {
                            foundDb = true;
                            break;
                        }
                    }

                    if (!foundDb) {
                        GroupPermissionRustDb removeRustPerm = new GroupPermissionRustDb
                        {
                            SteamId = userObject.steamid,
                            PermissionRust = 0
                        };
                        removeRustPerms.Add(removeRustPerm);
                    }
                }

                var userObjectsOwners = ServerUsers.GetAll(ServerUsers.UserGroup.Owner);
                foreach (var userObject in userObjectsOwners) {
                    bool foundDb = false;

                    foreach (GroupPermissionRustDb groupPermissionRustDb in groupPermissionsRustDb) {
                        if ((groupPermissionRustDb.SteamId == userObject.steamid) && (groupPermissionRustDb.PermissionRust == 2)) {
                            foundDb = true;
                            break;
                        }
                    }

                    if (!foundDb) {
                        GroupPermissionRustDb removeRustPerm = new GroupPermissionRustDb
                        {
                            SteamId = userObject.steamid,
                            PermissionRust = 0
                        };
                        removeRustPerms.Add(removeRustPerm);
                    }
                }

                foreach (GroupPermissionRustDb removeRustPerm in removeRustPerms) {
                        executeWriteCommand = true;
                        bool _tmp = SetUserPermissionRust(removeRustPerm.SteamId, removeRustPerm.PermissionRust);
                }

                foreach (string command in commandList)
                    server.Command(command);

                if (executeWriteCommand) {
                    timer.Once(10f, () =>
                    {
                        server.Command("writecfg");
                    });
                }
            });
        }

        public bool SetUserPermissionRust(ulong steamIdNumber, int permissionRust) {
            if ((steamIdNumber == null) || (steamIdNumber == 0) || (permissionRust == null))
                return false;

            switch(permissionRust) {
                case 0:
                    ServerUsers.Set(steamIdNumber, ServerUsers.UserGroup.None, "", "");
                break;
                case 1:
                    ServerUsers.Set(steamIdNumber, ServerUsers.UserGroup.Moderator, "", "");
                break;
                case 2:
                    ServerUsers.Set(steamIdNumber, ServerUsers.UserGroup.Owner, "", "");
                break;
                default:
                    PrintError(Lang("ErrorConfig"));
                    return false;
            }

            foreach (BasePlayer playerRespond in BasePlayer.activePlayerList.Where(x => x.userID == steamIdNumber))
                playerRespond.ChatMessage(Lang("PermissionChanged"));

            Puts(String.Format(Lang("PermissionChangedLog"), steamIdNumber.ToString(), permissionRust.ToString()));

            return true;
        }

        public bool CheckUserPermissionRust(ulong steamIdNumber, int permissionNumber) {
            try {
                var userObject = ServerUsers.Get(steamIdNumber);

                switch(permissionNumber) {
                    case 0:
                    if (userObject.group == ServerUsers.UserGroup.None)
                        return true;
                    break;
                    case 1:
                    if (userObject.group == ServerUsers.UserGroup.Moderator)
                        return true;
                    break;
                    case 2:
                    if (userObject.group == ServerUsers.UserGroup.Owner)
                        return true;
                    break;
                }

            } catch {
                if (permissionNumber == 0)
                    return true;
            }

            return false;
        }

        public bool CheckGroupExclude(GroupPermission groupPermission, string steamId) {

            HashSet<string> userGroups = GetCurrentUserGroups(steamId);

            foreach (string userGroup in userGroups) {
                if (groupPermission.GroupsCheckExcludedSync.Contains(userGroup, StringComparer.OrdinalIgnoreCase))
                    return true;
            }

            return false;
        }

        public ulong CheckUserSteamId(string steamId) {
            if ((steamId.Length == 17) && (steamId.StartsWith("7656119"))) {
                try { return Convert.ToUInt64(steamId); }
                catch { return 0; }
            }

            return 0;
        }

        public HashSet<string> GetCurrentUserIds(string groupNameSearch) {
            HashSet<string> usersGroupCurrentTemp = new HashSet<string>();

            foreach (string userGroup in permission.GetUsersInGroup(groupNameSearch)) {
                if (userGroup.Length >= 17)
                    usersGroupCurrentTemp.Add(userGroup.Substring(0, 17));
            }

            return usersGroupCurrentTemp;
        }

        public HashSet<string> GetCurrentUserGroups(string steamIdSearch) {
            HashSet<string> userGroupsCurrentTemp = new HashSet<string>(permission.GetUserGroups(steamIdSearch));
            return userGroupsCurrentTemp;
        }

        public void InitializeGroup(string groupName, HashSet<string> groupPermissions) {
            if (!permission.GroupExists(groupName)) {
                PrintWarning(String.Format("Permission Group {0} didn't existed. Creating it.", groupName));
                permission.CreateGroup(groupName, "", 0);
            }

            timer.Every(5, () =>
            {
                if (groupPermissions.Count == 0)
                    return;
                
                foreach (string perm in groupPermissions) {
                    permission.GrantGroupPermission(groupName, perm, null);
                }

                string[] perms = permission.GetGroupPermissions(groupName);

                if (perms.Length > 0)
                    return;

                PrintWarning(Lang("NotAddedGroup"));

            });
        }

        public HashSet<string> RemoveGroups(GroupPermission groupPermission, string steamId) {
            HashSet<string> queryList = new HashSet<string>();
            HashSet<string> currentUserGroups = GetCurrentUserGroups(steamId);

            bool isProtected = false;

            foreach (string groupRemove in groupPermission.GroupsRemove) {
                if (currentUserGroups.Contains(groupRemove, StringComparer.OrdinalIgnoreCase)) {
                    foreach(var checkProtectedGroup in _cfg.GroupPermissions.Where(x => x.GroupName.ToLower() == groupRemove.ToLower())) {
                        if (checkProtectedGroup.ProtectedGroup) {
                            isProtected = true;
                            break;
                        }
                    }

                    if (!isProtected) {
                        permission.RemoveUserGroup(steamId, groupRemove);
                        queryList.Add(String.Format("DELETE FROM {0} WHERE steamid={1} AND groupname='{2}' AND ( serverid='{3}' OR serverid LIKE '%{4}%' )", sql_table, steamId, groupRemove, ServerIdAll, _cfg.ServerId));
                    } else {
                        PrintWarning(String.Format(Lang("NotRemovedProtected"), steamId, groupRemove));
                        isProtected = false;
                    }
                }
            }

            return queryList;
        }

		public void executeQuery(string query, params object[] data) {
            try {
				var sql = Sql.Builder.Append(query, data);
				_mySql.Update(sql, _mySqlConnection);
			}
			catch (Exception ex)
			{
                PrintError(string.Format(Lang("ErrorDatabase"), _cfg.DatabaseConfiguration.Database, ex.Message));
			}
		}

		public void executeQuery(string query) {
            try {
				var sql = Sql.Builder.Append(query);
				_mySql.Update(sql, _mySqlConnection);
			}
			catch (Exception ex)
			{
                PrintError(string.Format(Lang("ErrorDatabase"), _cfg.DatabaseConfiguration.Database, ex.Message));
			}
		}

        #endregion Helpers

        #region Classes

        private class Configuration
        {
            [JsonProperty(PropertyName = "ServerId")]
            public string ServerId { get; set; } = "yourid";

            [JsonProperty(PropertyName = "PollIntervalSeconds")]
            public int PollIntervalSeconds { get; set; } = 300;

            [JsonProperty(PropertyName = "DatabaseConfiguration")]
            public DatabaseConfiguration DatabaseConfiguration { get; set; } = new DatabaseConfiguration
            {
                Host = "",
                Port = 3306,
                Username = "username",
                Password = "password",
                Database = "PermissionGroupSync"
            };

            [JsonProperty(PropertyName = "GroupPermissions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<GroupPermission> GroupPermissions { get; set; } = new List<GroupPermission>
            {
                new GroupPermission
                {
                    CommandName = "yourCommand1",
                    GroupName = "PermissionGroupSync",
                    ExtendedPermissionHandling = true,
                    PermissionUse = true,
                    ProtectedGroup = false,
                    OverrideServerIdCheck = false,
                    GroupsCheckExcludedSync = new HashSet<string>
                    {
                        "admin",
                        "testgroup"
                    },
                    GroupsRemove = new HashSet<string>
                    {
                        "moderator"
                    },
                    PermissionRust = 0,
                    PermissionsOxide = new HashSet<string>
                    {
                        "plugin.permission1",
                        "plugin.permission2"
                    },
                    AdditionalCommands = new HashSet<string>
                    {
                        "writefg"
                    }
                },
                new GroupPermission
                {
                    CommandName = "yourCommand2",
                    GroupName = "PermissionGroupSync2",
                    ExtendedPermissionHandling = false,
                    PermissionUse = false,
                    ProtectedGroup = false,
                    OverrideServerIdCheck = false,
                    GroupsCheckExcludedSync = new HashSet<string>
                    {
                        "admin",
                        "testgroup"
                    },
                    GroupsRemove = new HashSet<string>
                    {
                        "moderator"
                    },
                    PermissionRust = 0,
                    PermissionsOxide = new HashSet<string>
                    {
                        "plugin.permission1",
                        "plugin.permission2"
                    },
                    AdditionalCommands = new HashSet<string>
                    {
                        "writefg"
                    }
                }
            };
        }

        public class DatabaseConfiguration
        {
            [JsonProperty(PropertyName = "Host")]
            public string Host { get; set; }

            [JsonProperty(PropertyName = "Port")]
            public int Port { get; set; }

            [JsonProperty(PropertyName = "Username")]
            public string Username { get; set; }

            [JsonProperty(PropertyName = "Password")]
            public string Password { get; set; }

            [JsonProperty(PropertyName = "Database")]
            public string Database { get; set; }
        }

        public class GroupPermission
        {
            [JsonProperty(PropertyName = "CommandName")]
            public string CommandName { get; set; }

            [JsonProperty(PropertyName = "GroupName")]
            public string GroupName { get; set; }

            [JsonProperty(PropertyName = "ExtendedPermissionHandling")]
            public bool ExtendedPermissionHandling { get; set; }

            [JsonProperty(PropertyName = "PermissionUse")]
            public bool PermissionUse { get; set; }

            [JsonProperty(PropertyName = "ProtectedGroup")]
            public bool ProtectedGroup { get; set; }

            [JsonProperty(PropertyName = "OverrideServerIdCheck")]
            public bool OverrideServerIdCheck { get; set; }

            [JsonProperty(PropertyName = "GroupsCheckExcludedSync")]
            public HashSet<string> GroupsCheckExcludedSync { get; set; } = new HashSet<string>();

            [JsonProperty(PropertyName = "GroupsRemove")]
            public HashSet<string> GroupsRemove { get; set; } = new HashSet<string>();

            [JsonProperty(PropertyName = "PermissionsRust")]
            public int PermissionRust { get; set; }

            [JsonProperty(PropertyName = "PermissionsOxide")]
            public HashSet<string> PermissionsOxide { get; set; } = new HashSet<string>();

            [JsonProperty(PropertyName = "AdditionalCommands")]
            public HashSet<string> AdditionalCommands { get; set; } = new HashSet<string>();
        }

        public class GroupPermissionDb
        {
            [JsonProperty(PropertyName = "SteamId")]
            public ulong SteamId { get; set; }

            [JsonProperty(PropertyName = "GroupName")]
            public string GroupName { get; set; }

            [JsonProperty(PropertyName = "ServerId")]
            public string ServerId { get; set; }
        }

        public class GroupPermissionRustDb
        {
            [JsonProperty(PropertyName = "SteamId")]
            public ulong SteamId { get; set; }

            [JsonProperty(PropertyName = "PermissionsRust")]
            public int PermissionRust { get; set; }
        }

        #endregion Classes
    }
}

// --- End of file: PermissionGroupSync.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/popup-notifications ---
// --- Original File Path: P/PopupNotifications/PopupNotifications.cs ---

using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Popup Notifications", "emu / k1lly0u", "0.2.0", ResourceId = 1252)]
    public class PopupNotifications : RustPlugin
    {
        private static PopupNotifications ins;       
        const string popupPanel = "PopupNotification";

        private string panelColor;
        private string buttonColor;
        private string font;
        private int fontSize;

        #region Oxide Hooks
        private void OnServerInitialized()
        {
            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("popupnotifications.send", this);

            panelColor = UI.Color(configData.Options.Color, configData.Options.Alpha);
            buttonColor = UI.Color(configData.Options.CloseColor, configData.Options.CloseAlpha);
            font = configData.Options.Font;
            fontSize = configData.Options.FontSize;

            ins = this;            
        }

        private void Unload()
        {
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                Notifier notifier = player.GetComponent<Notifier>();
                if (notifier != null)
                    UnityEngine.Object.Destroy(notifier);
            }

            ins = null;
        }
        #endregion

        #region Functions
        private Notifier GetPlayerNotifier(BasePlayer player) => player.GetComponent<Notifier>() ?? player.gameObject.AddComponent<Notifier>();

        private void CreatePopupOnPlayer(string message, BasePlayer player, float duration = 0f) => GetPlayerNotifier(player).PopupMessage(message, duration);        

        private void CreateGlobalPopup(string message, float duration = 0f)
        {
            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
            {
                CreatePopupOnPlayer(message, activePlayer, duration);
            }
        }
        #endregion     

        #region API
        [HookMethod("CreatePopupNotification")]
        private void CreatePopupNotification(string message, BasePlayer player = null, float duration = 0f)
		{
			if(player != null)			
				CreatePopupOnPlayer(message, player, (float)duration);			
			else CreateGlobalPopup(message, (float)duration);			
		}
        #endregion

        #region Component
        private class Notifier : MonoBehaviour
		{
            private BasePlayer player;

            private List<string> openPanels = new List<string>();
            private List<MessageData> messageQueue = new List<MessageData>();

            private Vector2 initialPos;
            private Vector2 dimensions;

            private int lastElementId;
            private int activeElements;
            private int maxElements;

            private void Awake()
			{
				player = GetComponent<BasePlayer>();
                enabled = false;

                initialPos = new Vector2(ins.configData.Position.PositionX, ins.configData.Position.PositionY);
                dimensions = new Vector2(ins.configData.Position.Width, ins.configData.Position.Height);
                maxElements = ins.configData.MaximumMessages;
            }		

            private void OnDestroy()
            {
                messageQueue.Clear();

                foreach (string panel in openPanels)
                    CuiHelper.DestroyUi(player, panel);
            }

            public void PopupMessage(string message, float duration)
            {
                messageQueue.Add(new MessageData(message, popupPanel + lastElementId, duration == 0f ? duration = ins.configData.Duration : duration));
                lastElementId++;
                if (activeElements < maxElements)
                    UpdateMessages();
            }

            private void UpdateMessages()
            {
                if (activeElements < maxElements)
                {
                    ClearAllElements();
                    for (int i = 0; i < maxElements; i++)
                    {
                        if (messageQueue.Count - 1 < i)
                            break;

                        MessageData messageData = messageQueue.ElementAt(i);

                        CuiElementContainer container = CreateNotification(messageData, i);

                        AddUi(container, messageData.elementId);

                        if (!messageData.started)
                        {
                            messageData.started = true;
                            StartCoroutine(DestroyNotification(messageData));
                        }
                    }
                }
            }

            private IEnumerator DestroyNotification(MessageData messageData)
            {
                yield return new WaitForSeconds(messageData.duration);

                if (messageData == null)
                    yield break;

                messageQueue.Remove(messageData);
                DestroyUi(messageData.elementId);

                if (messageQueue.Count > 0)
                    UpdateMessages();
            }

            public void DestroyNotification(string elementId)
            {
                MessageData messageData = messageQueue.Find(x => x.elementId == elementId) ?? null;
                if (messageData == null)
                    return;

                messageQueue.Remove(messageData);
                DestroyUi(messageData.elementId);

                if (messageQueue.Count > 0)
                    UpdateMessages();
            }

            private void AddUi(CuiElementContainer container, string elementId)
            {
                openPanels.Add(elementId);
                CuiHelper.AddUi(player, container);
                activeElements++;
            }

            private void DestroyUi(string elementId)
            {
                openPanels.Remove(elementId);
                CuiHelper.DestroyUi(player, elementId);
                activeElements--;
            }

            private void ClearAllElements()
            {
                foreach (string elementId in openPanels)
                    CuiHelper.DestroyUi(player, elementId);
                openPanels.Clear();
                activeElements = 0;
            }

            private float[] GetFeedPosition(int number)
            {               
                float yPos = initialPos.y - ((dimensions.y + ins.configData.Position.Spacing) * number);
                return new float[] { initialPos.x, yPos, initialPos.x + dimensions.x, yPos + dimensions.y };
            }

            private CuiElementContainer CreateNotification(MessageData messageData, int number)
            {
                float[] position = GetFeedPosition(number);

                CuiElementContainer container = UI.Container(messageData.elementId, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}");
                UI.Label(ref container, messageData.elementId, messageData.message);

                if (ins.configData.Options.Close)
                    UI.Button(ref container, messageData.elementId, "X", $"popupmsg.close {messageData.elementId}");

                return container;
            }

            public class MessageData
            {
                public string message { get; private set; }
                public string elementId { get; private set; }
                public float duration { get; private set; }
                public bool started { get; set; }

                public MessageData(string message, string elementId, float duration)
                {
                    this.message = message;
                    this.elementId = elementId;
                    this.duration = duration;
                    started = false;                    
                }
            }
        }
        #endregion

        #region UI
        static public class UI
        {
            static public CuiElementContainer Container(string panel, string aMin, string aMax)
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = { Color = ins.panelColor },
                            RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                            CursorEnabled = false
                        },
                        new CuiElement().Parent = "Overlay",
                        panel
                    }
                };
                return container;
            }
            
            static public void Label(ref CuiElementContainer container, string panel, string text)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = ins.fontSize, Align = TextAnchor.MiddleCenter, Text = text, Font = ins.font },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
                },
                panel);
            }

            static public void Button(ref CuiElementContainer container, string panel, string text, string command)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = ins.buttonColor, Command = command },
                    RectTransform = { AnchorMin = "0.89 0.79", AnchorMax = "0.99 0.99" },
                    Text = { Text = text, FontSize = 10, Align = TextAnchor.MiddleCenter, Font = ins.font }
                },
                panel);
            }
           
            static public string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.Substring(1);
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        #endregion

        #region Commands
        [ChatCommand("popupmsg")]
        private void cmdSendPopupMessage(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, "popupnotifications.send"))
            {
                if (args.Length == 1)
                {
                    CreateGlobalPopup(args[0]);
                }
                else if (args.Length == 2)
                {
                    var target = GetPlayerByName(args[0]);
                    if (target is string)
                    {
                        SendReply(player, (string)target);
                        return;
                    }
                    if (target as BasePlayer != null)
                        CreatePopupOnPlayer(args[1], target as BasePlayer);
                }
                else
                    SendReply(player, msg("Usage: /popupmsg \"Your message here.\" OR /popupmsg \"player name\" \"You message here.\"", player.UserIDString));
            }
        }

        [ConsoleCommand("popupmsg.global")]
        private void ccmdPopupMessageGlobal(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
                return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                Puts(msg("Usage: popupmsg.global \"Your message here.\" <duration>"));
                return;
            }

            if (arg.Args.Length == 1)
                CreateGlobalPopup(arg.Args[0]);
            
            else if (arg.Args.Length == 2)
            {
                float duration;
                if (float.TryParse(arg.Args[1], out duration))
                    CreateGlobalPopup(arg.Args[0], duration);
                else
                    Puts(msg("Invalid duration"));
            }           
        }

        [ConsoleCommand("popupmsg.toplayer")]
        private void ccmdPopupMessageToPlayer(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin || arg.Connection != null)
                return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                Puts(msg("Usage: popupmsg.toplayer \"Your message here.\" \"Player name\" <duration>"));
                return;
            }

            if (arg.Args.Length >= 1)
            {
                var player = GetPlayerByName(arg.Args[1]);
                if (player is string)
                {
                    SendReply(arg, (string)player);
                    return;
                }

                if (arg.Args.Length == 2)
                {
                    if (player as BasePlayer != null && (player as BasePlayer).IsConnected)
                        CreatePopupOnPlayer(arg.Args[0], player as BasePlayer);
                    else Puts(msg("Couldn't send popup notification to player"));
                }
                else if (arg.Args.Length == 3)
                {

                    if (player as BasePlayer != null && (player as BasePlayer).IsConnected)
                    {
                        float duration;
                        if (float.TryParse(arg.Args[2], out duration))
                            CreatePopupOnPlayer(arg.Args[0], player as BasePlayer, duration);
                        else Puts(msg("Invalid duration"));
                    }
                    else Puts(msg("Couldn't send popup notification to player"));
                }                
            }
        }

        private object GetPlayerByName(string name)
        {
            var players = covalence.Players.FindPlayers(name);
            if (players != null)
            {
                if (players.ToList().Count == 0)
                    return msg("No players found with that name");
                else if (players.ToList().Count > 1)
                    return msg("Multiple players found with that name");
                else if (players.ToArray()[0].Object is BasePlayer)
                {
                    if (!(players.ToArray()[0].Object as BasePlayer).IsConnected)
                        return string.Format(msg("{0} is not online"), players.ToArray()[0].Name);
                    return players.ToArray()[0].Object as BasePlayer;
                }
            }
            return msg("Unable to find a valid player");
        }

        [ConsoleCommand("popupmsg.close")]
        private void ccmdCloseCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (arg.Args.Length == 1)
            {
                string elementId = arg.Args[0];

                GetPlayerNotifier(player).DestroyNotification(elementId);
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Notification duration (in seconds)")]
            public int Duration { get; set; }
            [JsonProperty(PropertyName = "Maximum notifications shown at any time")]
            public int MaximumMessages { get; set; }            
            [JsonProperty(PropertyName = "UI Positioning")]
            public UIPosition Position { get; set; }
            [JsonProperty(PropertyName = "UI Options")]
            public UIOptions Options { get; set; }

            public class UIPosition
            {
                [JsonProperty(PropertyName = "Position of the left side of notification (0.0 - 1.0)")]
                public float PositionX { get; set; }
                [JsonProperty(PropertyName = "Position of the bottom of noticiation (0.0 - 1.0)")]
                public float PositionY { get; set; }
                [JsonProperty(PropertyName = "Width (0.0 - 1.0)")]
                public float Width { get; set; }
                [JsonProperty(PropertyName = "Height (0.0 - 1.0)")]
                public float Height { get; set; }
                [JsonProperty(PropertyName = "Space between notification (0.0 - 1.0)")]
                public float Spacing { get; set; }
            }
            public class UIOptions
            {
                [JsonProperty(PropertyName = "Show close button")]
                public bool Close { get; set; }
                [JsonProperty(PropertyName = "Panel color (hex)")]
                public string Color { get; set; }
                [JsonProperty(PropertyName = "Panel transparency (0.0 - 1.0)")]
                public float Alpha { get; set; }
                [JsonProperty(PropertyName = "Close button color (hex)")]
                public string CloseColor { get; set; }
                [JsonProperty(PropertyName = "Close button transparency (0.0 - 1.0)")]
                public float CloseAlpha { get; set; }                
                [JsonProperty(PropertyName = "Font")]
                public string Font { get; set; }
                [JsonProperty(PropertyName = "Font size")]
                public int FontSize { get; set; }
            }
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {                
                Duration = 8,               
                MaximumMessages = 6,               
                Options = new ConfigData.UIOptions
                {
                    Alpha = 0.5f,
                    CloseAlpha = 0.5f,
                    Close = true,
                    CloseColor = "#d85540",
                    Color = "#2b2b2b",
                    Font = "droidsansmono.ttf",
                    FontSize = 12
                },
                Position = new ConfigData.UIPosition
                {
                    Height = 0.1f,
                    PositionX = 0.8f,
                    PositionY = 0.78f,
                    Spacing = 0.01f,
                    Width = 0.19f
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();
            if (configData.Version < new Core.VersionNumber(0, 2, 0))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion        

        #region Localization
        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);

        Dictionary<string, string> Messages = new Dictionary<string, string>
            {
            {"Usage: /popupmsg \"Your message here.\" OR /popupmsg \"player name\" \"You message here.\"","Usage: /popupmsg \"Your message here.\" OR /popupmsg \"player name\" \"You message here.\"" },
            {"Invalid duration","Invalid duration" },
            {"Usage: popupmsg.global \"Your message here.\" duration","Usage: popupmsg.global \"Your message here.\" duration" },
            {"Couldn't send popup notification to player","Couldn't send popup notification to player" },
            {"Usage: popupmsg.toplayer \"Your message here.\" \"Player name\" <duration>","Usage: popupmsg.toplayer \"Your message here.\" \"Player name\" <duration>" },
            {"No players found with that name","No players found with that name" },
            {"Multiple players found with that name","Multiple players found with that name" },
            {"{0} is not online","{0} is not online" },
            {"Unable to find a valid player","Unable to find a valid player" }
            };
        #endregion
    }
}

// --- End of file: PopupNotifications.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/police-sedan ---
// --- Original File Path: P/PoliceSedan/PoliceSedan.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Network;
using Oxide.Core;
using System;

namespace Oxide.Plugins
{
    [Info("Police Sedan", "NotBad", "1.0.9")]
    [Description("Spawn a police sedan with police lights")]
    public class PoliceSedan : RustPlugin
    {
        #region Variables
        private StoredData storedData;

        public HashSet<uint> LightsON = new HashSet<uint>();

        public string bluelight = "assets/prefabs/deployable/playerioents/lights/flasherlight/electric.flasherlight.deployed.prefab";
        public string redlight = "assets/prefabs/deployable/playerioents/lights/sirenlight/electric.sirenlight.deployed.prefab";
        public string orangelight = "assets/prefabs/io/electric/lights/sirenlightorange.prefab";
        public string strobelight = "assets/content/props/strobe light/strobelight.prefab";
        public string hornSound = "assets/prefabs/tools/pager/effects/beep.prefab";
        public string buttonPrefab = "assets/prefabs/deployable/playerioents/button/button.prefab";

        #endregion

        #region Initialization

        private void Init()
        {
            permission.RegisterPermission("policesedan.spawn", this);
            //permission.RegisterPermission("policesedan.nocooldown", this);

            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
        }

        private void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }


        #endregion

        #region Hooks

        void OnButtonPress(PressButton button, BasePlayer player)
        {
            if (button == null || player == null)
            {
                return;
            }

            var result = player.GetMounted();

            if (result == null)
            {
                return;
            }

            if (result.ShortPrefabName == "driverseat")
            {
                var mountedveh = player.GetMountedVehicle();

                if (LightsON.Contains(mountedveh.net.ID))
                {
                    SirenTurnONorOFF(player, mountedveh, false);
                    LightsON.Remove(mountedveh.net.ID);
                    return;
                }
                else
                {
                    SirenTurnONorOFF(player, mountedveh, true);
                    LightsON.Add(mountedveh.net.ID);
                    return;
                }
            }
        }

        void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            if (entity == null || player == null)
            {
                return;
            }

            var mounted = player.GetMounted();

            if (mounted == null)
            {
                return;
            }

            if (mounted.ShortPrefabName != "driverseat")
            {
                return;
            }

            if (storedData.sedan.ContainsKey(player.UserIDString))
            {
                return;
            }

            //if (!permission.UserHasPermission(player.UserIDString, "policesedan.nocooldown"))
            //{
            //    storedData.cooldown.Add(player.UserIDString, DateTime.Now);
            //}

            if (permission.UserHasPermission(player.UserIDString, "policesedan.spawn"))
            {
                CreateSiren(player);
            }
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null)
            {
                return;
            }

            var policesedan = entity.GetComponent<BaseVehicle>();

            if (policesedan == null)
            {
                return;
            }

            if (storedData.sedan.ContainsValue(policesedan.net.ID))
            {
                string key = storedData.sedan.FirstOrDefault(x => x.Value == policesedan.net.ID).Key;

                ulong result;
                ulong.TryParse(key, out result);
                BasePlayer player = BasePlayer.FindByID(result);

                if (player != null)
                {
                    player.ChatMessage(lang.GetMessage("SedanDestroyed", this, player.UserIDString));
                }

                storedData.sedan.Remove(key);

                Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
            }
        }

        #endregion

        #region Helpers

        public void CreateSiren(BasePlayer player)
        {
            var mountedveh = player.GetMountedVehicle();

            MakeSiren(mountedveh, buttonPrefab, config.ButtonPosition);
            MakeSiren(mountedveh, bluelight, config.BlueLightPosition);
            MakeSiren(mountedveh, bluelight, config.BlueLightPosition2);
            if (config.CreateRedLight == true)
            {
                MakeSiren(mountedveh, redlight, config.RedLightPosition);
            }
            MakeSiren(mountedveh, strobelight, config.StrobeLightPosition);
            MakeSiren(mountedveh, strobelight, config.StrobeLightPosition2);
            if (config.CreateOrangeLight == true)
            {
                MakeSiren(mountedveh, orangelight, config.OrangeLightPosition);
            }

            storedData.sedan.Add(player.UserIDString, mountedveh.net.ID);

            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        void MakeSiren(BaseVehicle vehicle, string entityToSpawn, Vector3 position)
        {
            BaseEntity entity = GameManager.server.CreateEntity(entityToSpawn, vehicle.transform.position);
            if (entity == null) return;
            entity.transform.localPosition = position;
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
            entity.SetParent(vehicle);
            entity.transform.localPosition = position;
            entity.Spawn();
            vehicle.AddChild(entity);
        }

        void SirenTurnONorOFF(BasePlayer player, BaseVehicle vehicle, bool turnON)
        {
            Effect.server.Run(hornSound, player.transform.position);

            foreach (var childern in vehicle.children)
            {
                if (childern.name == strobelight)
                {
                    childern.SetFlag(BaseEntity.Flags.On, turnON);
                }
                if (childern.name == bluelight || childern.name == redlight || childern.name == orangelight)
                {
                    childern.SetFlag(BaseEntity.Flags.Reserved8, turnON);
                }
            }
        }

        #endregion

        #region Commands

        [ChatCommand("policesedan")]
        private void CommandSpawnSedan(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "policesedan.spawn"))
            {
                player.ChatMessage(lang.GetMessage("NotAllowed", this, player.UserIDString));
                return;
            }

            if (storedData.sedan.ContainsKey(player.UserIDString))
            {
                player.ChatMessage(lang.GetMessage("AlreadyHaveCar", this, player.UserIDString));
                return;
            }

            BaseVehicle car = (BaseVehicle)GameManager.server.CreateEntity("assets/content/vehicles/sedan_a/sedantest.entity.prefab", player.transform.position);
            if (car == null)
            {
                return;
            }

            car.Spawn();

            foreach (var mount in car.mountPoints)
            {
                if (mount.isDriver)
                {
                    mount.mountable.AttemptMount(player);
                }
            }
        }

        [ChatCommand("destroyps")]
        private void CommandDestroySedan(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "policesedan.spawn"))
            {
                player.ChatMessage(lang.GetMessage("NotAllowed", this, player.UserIDString));
                return;
            }

            if (storedData.sedan.ContainsKey(player.UserIDString))
            {
                uint value = storedData.sedan.FirstOrDefault(x => x.Key == player.UserIDString).Value;
                var entity = BaseNetworkable.serverEntities.Find(value);
                if (entity == null)
                {
                    storedData.sedan.Remove(value.ToString());
                }
                else
                {
                    entity.Kill();
                }
            }
        }

        #endregion

        #region Helpers
        private TimeSpan CeilingTimeSpan(TimeSpan timeSpan) =>
            new TimeSpan((long)Math.Ceiling(1.0 * timeSpan.Ticks / 10000000) * 10000000);
        #endregion

        #region Data
        public class StoredData
        {
            public Dictionary<string, uint> sedan = new Dictionary<string, uint>();
            //public Dictionary<string, DateTime> cooldown = new Dictionary<string, DateTime>();
        }

        #endregion

        #region Configuration

        private ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Create Red Light")]
            public bool CreateRedLight = true;

            [JsonProperty(PropertyName = "Create Orange Light")]
            public bool CreateOrangeLight = true;

            [JsonProperty(PropertyName = "Blue Light Position")]
            public Vector3 BlueLightPosition = new Vector3(-0.4f, 1.65f, 0.5f);

            [JsonProperty(PropertyName = "Blue Light Position 2")]
            public Vector3 BlueLightPosition2 = new Vector3(0.4f, 1.65f, 0.5f);

            [JsonProperty(PropertyName = "Red Light Position")]
            public Vector3 RedLightPosition = new Vector3(0f, 0.25f, 0.28f);

            [JsonProperty(PropertyName = "Strobe Light Position")]
            public Vector3 StrobeLightPosition = new Vector3(0.9f, 0.72f, 3.305f);

            [JsonProperty(PropertyName = "Strobe Light Position 2")]
            public Vector3 StrobeLightPosition2 = new Vector3(-0.9f, 0.72f, 3.305f);

            [JsonProperty(PropertyName = "Orange Light Position")]
            public Vector3 OrangeLightPosition = new Vector3(0.6f, 1.05f, -2.0f);

            [JsonProperty(PropertyName = "Button Position")]
            public Vector3 ButtonPosition = new Vector3(-0.4f, -0.3f, 1.32f);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You do not have permission to use this command!",
                ["OnCoolDown"] = "You are on cooldown!",
                ["AlreadyHaveCar"] = "You already have a police sedan. To destroy it type /destroyps",
                ["SedanDestroyed"] = "Your police sedan have been destroyed.",
                ["DoNotOwnSedan"] = "You do not own police sedan."
            }, this, "en");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "Nemas opravneni na to, aby si mohl pouzit tento prikaz!",
                ["OnCoolDown"] = "Musis pockat jeste ",
                ["AlreadyHaveCar"] = "Jiz vlastnis policejni auto. Muzes ho znicit pomoci /destroyps",
                ["SedanDestroyed"] = "Tve policejni vozidlo bylo zniceno.",
                ["DoNotOwnSedan"] = "Nevlastnis policejni vozidlo."
            }, this, "cs");
        }

        #endregion
    }
}

// --- End of file: PoliceSedan.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/political-survival ---
// --- Original File Path: P/PoliticalSurvival/PoliticalSurvival.cs ---

using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("PoliticalSurvival", "Pho3niX90", "0.9.15")]
    [Description("Political Survival - Become the ruler, tax your subjects and keep them in line!")]
    class PoliticalSurvival : RustPlugin
    {
        bool firstRun = false;
        public bool DebugMode = false;
        Ruler ruler;
        private PSConfig config;
        private Core.Libraries.Time _time = GetLibrary<Core.Libraries.Time>();
        static PoliticalSurvival _instance;
        private List<Ruler> rulerList = new List<Ruler>();
        private Dictionary<ulong, MapMarkerGenericRadius> _mapMarker;
        private VendingMachineMapMarker _mapMarkerVending;

        #region Settings Class
        public class TaxSource
        {
            public bool DispenserGather;
            public bool CropGather;
            public bool DispenserBonus;
            public bool QuarryGather;
            public bool ExcavatorGather;
            public bool CollectiblePickup;
            public bool SurveyGather;
            public bool RecyclerScrap;

            public TaxSource createDefault() {
                DispenserGather = true;
                CropGather = true;
                DispenserBonus = true;
                QuarryGather = true;
                ExcavatorGather = true;
                CollectiblePickup = true;
                SurveyGather = true;
                RecyclerScrap = true;
                return this;
            }
        }

        public class Ruler
        {
            public Vector3 taxContainerVector3;
            public NetworkableId taxContainerID;
            public double tax;
            public ulong userId;
            public string displayName;
            public ulong rulerId;
            public uint rulerSince;
            public int resourcesGot;
            public string realm;

            public Ruler(Vector3 tcv4, NetworkableId txId, double tx, ulong rlr, string rlrname, string rlm, ulong rid) {
                taxContainerVector3 = tcv4;
                taxContainerID = txId;
                tax = tx;
                userId = rlr;
                displayName = rlrname;
                realm = rlm;
                rulerId = rid;
            }

            public Ruler() { }

            public int GetResourceCount() {
                return resourcesGot;
            }

            public Ruler SetRulerSince(uint since) {
                rulerSince = since;
                return this;
            }

            public Ruler SetResourcesGot(int amnt) {
                resourcesGot = amnt;
                return this;
            }

            public long GetRulerSince() {
                return rulerSince;
            }

            public Ruler SetTaxContainerVector3(Vector3 vec) {
                taxContainerVector3 = vec;
                return this;
            }

            public Vector3 GetTaxContainerVector3() {
                return taxContainerVector3;
            }

            public Ruler SetTaxContainerID(NetworkableId storage) {
                taxContainerID = storage;
                return this;
            }

            public NetworkableId GetTaxContainerID() {
                return taxContainerID;
            }

            public Ruler SetTaxLevel(double tx) {
                tax = tx;
                return this;
            }

            public double GetTaxLevel() {
                return tax;
            }

            public Ruler SetRuler(ulong rlr) {
                userId = rlr;
                rulerId = rlr;
                rulerSince = (new Core.Libraries.Time()).GetUnixTimestamp();
                return this;
            }

            public ulong GetRuler() {
                return userId;
            }

            public double GetRuleLengthInMinutes() {
                return (new Core.Libraries.Time().GetUnixTimestamp() - rulerSince) / 60.0;
            }

            public double GetRulerOfflineMinutes() {
                return _instance.rulerOfflineAt == 0 ? 0.0 : ((new Core.Libraries.Time().GetUnixTimestamp() - _instance.rulerOfflineAt) / 60.0);
            }

            public Ruler SetRulerName(string name) {
                displayName = name;
                return this;
            }

            public string GetRulerName() {
                return displayName;
            }

            public Ruler SetRealmName(string rlm) {
                realm = rlm;
                return this;
            }

            public string GetRealmName() {
                return realm;
            }
        }
        #endregion

        #region Components

        #region Heli Vars
        public int HeliLifeTimeMinutes = 5;
        public float HeliBaseHealth = 50000.0f;
        public float HeliSpeed = 50f;
        public float HeliSpeedMax = 200f;
        public int NumRockets = 50;
        public float ScanFrequencySeconds = 5;
        public float TargetVisible = 1000;
        public float MaxTargetRange = 300;
        public bool NotifyPlayers = true;
        public BasePlayer target;
        #endregion

        class HeliComponent : FacepunchBehaviour
        {
            private BaseHelicopter heli;
            private PatrolHelicopterAI AI;
            private bool isFlying = true;
            private bool isRetiring = false;
            float timer;
            float timerAdd;

            void Awake() {
                heli = GetComponent<BaseHelicopter>();
                AI = heli.GetComponent<PatrolHelicopterAI>();
                heli.startHealth = _instance.HeliBaseHealth;
                AI.maxSpeed = Mathf.Clamp(_instance.HeliSpeed, 0.1f, _instance.HeliSpeedMax);
                AI.numRocketsLeft = _instance.NumRockets;

                attachGuns(AI);
                timerAdd = (Time.realtimeSinceStartup + Convert.ToSingle(_instance.HeliLifeTimeMinutes * 60));
                InvokeRepeating("ScanForTargets", _instance.ScanFrequencySeconds, _instance.ScanFrequencySeconds);
            }

            void FixedUpdate() {
                timer = Time.realtimeSinceStartup;

                if (timer >= timerAdd && !isRetiring) {
                    isRetiring = true;
                }
                if (isRetiring && isFlying) {
                    CancelInvoke("ScanForTargets");
                    isFlying = false;
                    heliRetire();
                }
            }

            internal void ScanForTargets() {
                foreach (ulong targetSteamId in _instance.target.Team.members) {
                    BasePlayer teamMemberToAttack = BasePlayer.Find(targetSteamId.ToString());

                    if (teamMemberToAttack.IsConnected) {
                        UpdateTargets(teamMemberToAttack);
                        _instance.DebugLog("Heli target found " + teamMemberToAttack);
                    }
                    UpdateAi();
                }
            }

            void UpdateAi() {
                _instance.DebugLog("Heli updating AI");
                AI.UpdateTargetList();
                AI.MoveToDestination();
                AI.UpdateRotation();
                AI.UpdateSpotlight();
                AI.AIThink();
                AI.DoMachineGuns();
            }

            void UpdateTargets(BasePlayer Player) {
                AI._targetList.Add(new PatrolHelicopterAI.targetinfo((BaseEntity)Player, Player));
            }

            internal void attachGuns(PatrolHelicopterAI helicopter) {
                if (helicopter == null) return;
                var guns = new List<HelicopterTurret>();
                guns.Add(helicopter.leftGun);
                guns.Add(helicopter.rightGun);
                for (int i = 0; i < guns.Count; i++) {
                    // Leave these as hardcoded for now
                    var turret = guns[i];
                    turret.fireRate = 0.125f;
                    turret.timeBetweenBursts = 3f;
                    turret.burstLength = 3f;
                    turret.maxTargetRange = _instance.MaxTargetRange;
                }
            }

            internal void heliRetire() {
                AI.Retire();
            }

            public void UnloadComponent() {
                Destroy(this);
            }

            void OnDestroy() {
                CancelInvoke("ScanForTargets");
            }
        }
        #endregion

        #region Variables
        Dictionary<string, string> serverMessages;
        int worldSize = ConVar.Server.worldsize;
        BasePlayer currentRuler;
        uint rulerOfflineAt = 0;
        private ILocator liveLocator = null;
        private ILocator locator = null;
        private bool Changed = false;
        protected Dictionary<string, Timer> Timers { get; } = new Dictionary<string, Timer>();
        #endregion
        void Init() {
            config = new PSConfig(this);
            _mapMarker = new Dictionary<ulong, MapMarkerGenericRadius>();
        }

        private void Loaded() {
            LoadServerMessages();

            LoadRuler();
            _instance = this;

            Puts("Political Survival is starting...");
            if (ConVar.Server.worldsize == 0)
                Puts("WARNING: worldsize is reporting as 0, this is not possible and will default to config size. Please make sure the config has the correct size.");
            if (ConVar.Server.worldsize > 0) { worldSize = ConVar.Server.worldsize; config.worldSize = ConVar.Server.worldsize; }

            liveLocator = new RustIOLocator(worldSize);
            locator = new LocatorWithDelay(liveLocator, 60);


            if (ruler.GetRulerSince() == 0) {
                ruler.SetRulerSince(_time.GetUnixTimestamp());
            }

            Puts("Realm name is " + ruler.GetRealmName());
            Puts("Tax level is " + ruler.GetTaxLevel());
            Puts("TaxChest is set " + !ruler.GetTaxContainerVector3().Equals(Vector3.negativeInfinity));
            Puts("Political Survival: Started");
            currentRuler = GetPlayer(ruler.GetRuler().ToString());
            Puts("Current ruler " + (currentRuler != null ? "is set" : "is null"));
            if (currentRuler != null) Puts("Ruler is " + ruler.GetRuler() + " (" + currentRuler.displayName + ")");

            Timers.Add("AdviseRulerPosition", timer.Repeat(Math.Max(config.broadcastRulerPositionEvery, 60), 0, () => AdviseRulerPosition()));

            SaveRuler();
            Puts($"Ruler offline at {rulerOfflineAt}");
            timer.Once(300, () => {
                if (rulerOfflineAt != 0 || currentRuler == null || currentRuler.IsConnected) {
                    if (config.chooseNewRulerOnDisconnect && (ruler.GetRulerOfflineMinutes() >= (1 * config.chooseNewRulerOnDisconnectMinutes) || (rulerOfflineAt == 0 && (currentRuler == null || !currentRuler.IsConnected)))) {
                        TryForceNewRuler(true);
                    }
                }
            });
            RemoveMarkersForce();
        }

        void Unload() {
            SaveRuler();

            RemoveMarkers();

            foreach (Timer t in Timers.Values)
                t.Destroy();
            Timers.Clear();
        }

        void OnPlayerConnected(BasePlayer player) {
            if (config.showWelcomeMsg) PrintToChat(player.displayName + " " + GetMsg("PlayerConnected") + " " + ruler.GetRealmName());
            if (currentRuler != null && ruler.userId == currentRuler.userID) {
                rulerOfflineAt = 0;
            }
        }

        void OnPlayerDisconnected(BasePlayer player, string reason) {
            if (config.showWelcomeMsg) PrintToChat(player.displayName + " " + GetMsg("PlayerDisconnected") + " " + ruler.GetRealmName());
            if (currentRuler != null && player.userID == currentRuler.userID) {
                rulerOfflineAt = _time.GetUnixTimestamp();
                timer.Once(60 * config.chooseNewRulerOnDisconnectMinutes, () => {
                    if (rulerOfflineAt != 0) TryForceNewRuler(true);
                });
            }
        }

        #region GatheringHooks
        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item) {
            DebugLog("OnDispenserGather start");
            //if (!config.taxSource.DispenserGather || dispenser == null || entity == null || Item == null || ruler.GetTaxContainerID() == 0) return;

            BasePlayer player = entity as BasePlayer;
            if (player != null) {
                DebugLog("OnDispenserGather stage 2 " + item.flags.ToString() + " " + item.amount + " " + player.displayName);
                AddToTaxContainer(item, player.displayName, out item.amount);
            }
        }

        private void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item) {
            //if (!config.taxSource.DispenserBonus) return;

            BasePlayer player = entity as BasePlayer;
            DebugLog("OnDispenserBonus start");
            AddToTaxContainer(item, player.displayName, out item.amount);
        }

        void OnGrowableGather(GrowableEntity plant, Item item, BasePlayer player) {
            //if (!config.taxSource.CropGather) return;

            DebugLog("OnPlantGather start");
            AddToTaxContainer(item, player.displayName, out item.amount);
        }

        private void OnQuarryGather(MiningQuarry quarry, Item item) {
            DebugLog("OnQuarryGather start");
            //if (!config.taxSource.QuarryGather) return;

            AddToTaxContainer(item, quarry.name, out item.amount);
        }


        private void OnExcavatorGather(ExcavatorArm excavator, Item item) {
            DebugLog("OnExcavatorGather start");
            //if (!config.taxSource.ExcavatorGather) return;

            AddToTaxContainer(item, excavator.name, out item.amount);
        }

        private void OnCollectiblePickup(Item item, BasePlayer player) {
            DebugLog("OnCollectiblePickup start");
            //if (!config.taxSource.CollectiblePickup) return;

            AddToTaxContainer(item, player.displayName, out item.amount);
        }

        private void OnSurveyGather(SurveyCharge surveyCharge, Item item) {
            DebugLog("OnSurveyGather start");
            //if (!config.taxSource.SurveyGather) return;

            AddToTaxContainer(item, surveyCharge.name, out item.amount);
        }

        private int OnRecycleItemOutput(string itemName, int itemAmount) {
            if (itemAmount <= 1 || !IsChestSet()) return itemAmount;
            Item item = ItemManager.CreateByName(itemName, itemAmount);
            DebugLog("OnRecycleItemOutput start");

            AddToTaxContainer(item, null, out item.amount);
            return item.amount;
        }

        #endregion

        void AddToTaxContainer(Item item, string displayName, out int netAmount) {
            try {
                if (!IsChestSet() || item == null || ruler.GetTaxContainerID().IsValid || ruler.GetRuler() == 0 || ruler.GetTaxLevel() == 0 || ruler.GetTaxContainerVector3() == Vector3.negativeInfinity) {
                    netAmount = item.amount;
                    return;
                }

                ItemDefinition ToAdd = ItemManager.FindItemDefinition(item.info.itemid);
                int Tax = Convert.ToInt32(Math.Ceiling((item.amount * ruler.GetTaxLevel()) / 100));

                ItemContainer container = FindStorageContainer(ruler.GetTaxContainerID()).inventory;
                if (ToAdd != null && container != null) {
                    if (item.CanMoveTo(container)) {
                        container.AddItem(ToAdd, Tax);
                        ruler.resourcesGot += Tax;
                    }
                }

                DebugLog("User " + displayName + " gathered " + item.amount + " x " + item.info.shortname + ", and " + Tax + " was taxed");
                DebugLog("items added to tax container");
                netAmount = item.amount - Tax;
            } catch (Exception e) {
                netAmount = item.amount;
            }
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info) {

            if (entity == null) return;
            BasePlayer player = entity as BasePlayer;

            if (player != null) {
                if (IsRuler(player.userID)) {
                    BasePlayer killer = null;
                    if (info != null) killer = info.Initiator as BasePlayer;

                    if (killer != null && killer.userID != player.userID && !(killer is NPCPlayer)) {
                        RemoveMarkers();
                        SetRuler(killer);
                        PrintToChat(string.Format(GetMsg("RulerMurdered"), killer.displayName));
                    } else {
                        ruler.SetRuler(0).SetRulerName(null);
                        currentRuler = null;
                        PrintToChat(string.Format(GetMsg("RulerDied")));
                        if (TryForceNewRuler(true)) PrintToChat(GetMsg("NewRuler"), currentRuler.displayName);
                    }
                    SaveRuler();
                }
            }
        }

        public void TryForceRuler() {
            if ((currentRuler == null && TryForceNewRuler(false)) || ruler.GetRulerOfflineMinutes() >= config.chooseNewRulerOnDisconnectMinutes) {
                RemoveMarkers();
                PrintToChat(GetMsg("NewRuler"), currentRuler.displayName);
            }
        }


        public bool TryForceNewRuler(bool force) {
            if (currentRuler != null && !force) return false;
            BasePlayer player = GetRandomPlayer();
            if (player != null) {
                RemoveMarkers();
                SetRuler(player);
                PrintToChat(GetMsg("NewRuler"), currentRuler.displayName);
                return true;
            }
            return false;
        }

        #region Commands
        [ChatCommand("fnr")]
        void TryForceRulerCmd(BasePlayer player, string command, string[] args) {

            if (!player.IsAdmin) {
                Puts($"Player {player.displayName} tried using fnr");
                return;
            }

            if (args.Length != 1) {
                if (TryForceNewRuler(true)) {
                    PrintToChat(GetMsg("NewRuler"), currentRuler.displayName);
                } else {
                    PrintToChat(GetMsg("ForceRullerErr"));
                }
            } else if (args.Length == 1) {
                BasePlayer ruler = null;
                try {
                    ruler = BasePlayer.Find(args[0]);
                } catch (Exception e) {
                    if (player != null)
                        PrintToChat(player, "ERR: " + GetMsg("PlayerNotFound"), args[0]);
                    return;
                }

                if (ruler == null) { PrintToChat(GetMsg("PlayerNotFound"), args[0]); return; }
                SetRuler(ruler);
                PrintToChat(GetMsg("NewRuler"), currentRuler.displayName);
            }
        }

        [ConsoleCommand("forcenewruler")]
        void TryForceNewRulerConsoleCommand(BasePlayer player, string command, string[] args) {
            TryForceRulerCmd(player, command, args);
        }

        [ChatCommand("heli")]
        void HeliCommmand(BasePlayer player, string command, string[] args) {
            if (!IsRuler(player.userID)) { PrintToChat(player, "You aren't the ruler"); return; }
            if (args.Length != 1) { PrintToChat(player, "Usage '/heli player' where player can also be partial name"); return; }

            BasePlayer playerToAttack = GetPlayer(args[0]);
            if (playerToAttack == null) { PrintToChat(player, GetMsg("PlayerNotFound"), args[0]); return; }

            Puts("Can afford heli?");
            if (!CanAffordheliStrike(player)) {
                PrintToChat(player, GetMsg("OrderingHeliCost"), config.heliItemCostQty, ItemManager.FindItemDefinition(config.heliItemCost).displayName.english); return;
            }

            int heliCount = UnityEngine.Object.FindObjectsOfType<BaseHelicopter>().Count();
            if (heliCount >= config.maxHelis) {
                PrintToChat(player, GetMsg("NomoreAirspace"), config.maxHelis); return;
            }

            Puts("OrderheliStrike");
            OrderheliStrike(playerToAttack);
            PrintToChat(player, GetMsg("HeliInbound"));
        }

        [ChatCommand("taxrange")]
        void AdmSetTaxChestCommand(BasePlayer player, string command, string[] args) {
            if (player.IsAdmin && args.Length == 2) {
                int taxMin = 0;
                int taxMax = 10;
                int.TryParse(args[0], out taxMin);
                int.TryParse(args[1], out taxMax);
                config.taxMin = taxMin;
                config.taxMax = taxMax;
                PrintToChat(player, $"Tax range set to Min:{config.taxMin}% - Max:{config.taxMax}%");
                SaveConfig();
                SaveRuler();
            }
        }

        [ChatCommand("settaxchest")]
        void SetTaxChestCommand(BasePlayer player, string command, string[] arguments) {
            if (!IsRuler(player.userID)) {
                SendReply(player, GetMsg("RulerError"), player.UserIDString);
                return;
            }
            var layers = LayerMask.GetMask("Deployed");
            RaycastHit hit = new RaycastHit();
            if (Player != null && Physics.Raycast(player.eyes.HeadRay(), out hit, 50, layers)) {
                BaseEntity entity = hit.GetEntity();
                if (entity != null && (entity.ShortPrefabName.Contains("box.wooden") || entity.ShortPrefabName.Contains("cupboard.tool.deployed") || entity.ShortPrefabName.Contains("vending.machine"))) {
                    Vector3 boxPosition = entity.transform.position;
                    StorageContainer boxStorage = FindStorageContainer(boxPosition);

                    if (boxStorage != null) {
                        ruler.SetTaxContainerVector3(boxPosition).SetTaxContainerID(entity.net.ID);

                        if (entity.ShortPrefabName.Contains("box.wooden")) {
                            entity.skinID = config.taxBoxSkinId; //https://steamcommunity.com/sharedfiles/filedetails/?id=1482844040&searchtext=
                            entity.SendNetworkUpdate();
                        }

                        DebugLog("Chest set");
                        SaveRuler();
                        SendReply(player, GetMsg("SetNewTaxChest"), player.UserIDString);
                    }
                } else {
                    DebugLog("Looking at " + entity.ShortPrefabName);
                    SendReply(player, GetMsg("SetNewTaxChestNotFound"), player.UserIDString);
                    SendReply(player, GetMsg("SettingNewTaxChest"), player.UserIDString);
                }
            } else {
                SendReply(player, GetMsg("SetNewTaxChestNotFound"), player.UserIDString);
                SendReply(player, GetMsg("SettingNewTaxChest"), player.UserIDString);
            }
        }

        [ChatCommand("tax")]
        void InfoCommand2(BasePlayer player, string command, string[] arguments) {
            InfoCommand(player, command, arguments);
        }
        [ChatCommand("rinfo")]
        void InfoCommand(BasePlayer player, string command, string[] arguments) {
            string RulerName = string.Empty;

            if (ruler.GetRuler() > 0) {
                BasePlayer BaseRuler = BasePlayer.FindAwakeOrSleeping(ruler.GetRuler().ToString());
                RulerName = BaseRuler != null ? BaseRuler.displayName : GetMsg("ClaimRuler", player.UserIDString);
            } else {
                RulerName = GetMsg("ClaimRuler", player.UserIDString);
            }


            if (ruler.GetRuler() != 0) {
                SendReply(player, GetMsg("RulerName"), ruler.GetRulerName());
            } else {
                SendReply(player, GetMsg("ClaimRuler", player.UserIDString));
            }

            SendReply(player, GetMsg("InfoRealmName", player.UserIDString), ruler.GetRealmName());
            SendReply(player, GetMsg("InfoTaxLevel", player.UserIDString), ruler.GetTaxLevel() + "%" + ((!IsChestSet()) ? " (0%, chest not set)" : ""));
            SendReply(player, GetMsg("InfoRuleLength", player.UserIDString), Math.Round(ruler.GetRuleLengthInMinutes()) + " minutes");
            SendReply(player, GetMsg("InfoResources", player.UserIDString), ruler.GetResourceCount());
            if (IsRuler(player.userID)) {
                SendReply(player, GetMsg("SettingNewTaxChest", player.UserIDString));
                SendReply(player, GetMsg("InfoTaxCmd", player.UserIDString), config.taxMin, config.taxMax + ": " + ruler.GetTaxLevel() + "%");
            }
        }

        [ChatCommand("claimruler")]
        void ClaimRuler(BasePlayer player, string command, string[] arguments) {
            if (currentRuler == null) {
                PrintToChat(GetMsg("IsNowRuler"), player.displayName);
                SetRuler(player);
            }
        }

        [ChatCommand("settax")]
        void SetTaxCommand(BasePlayer player, string command, string[] args) {
            if (IsRuler(player.userID)) {
                int newTaxLevel = 0;
                if (int.TryParse(args[0], out newTaxLevel)) {
                    double oldTax = ruler.GetTaxLevel();
                    if (newTaxLevel == ruler.GetTaxLevel())
                        return;
                    Puts("Tax have been changed by " + player.displayName + " from " + ruler.GetTaxLevel() + " to " + newTaxLevel);
                    Puts($"Tax {config.taxMin} {config.taxMax}");
                    if (newTaxLevel > config.taxMax) {
                        SendReply(player, GetMsg("MaxTax"), config.taxMax);
                        newTaxLevel = config.taxMax;
                    } else if (newTaxLevel < config.taxMin) {
                        SendReply(player, GetMsg("MinTax"), config.taxMin);
                        newTaxLevel = config.taxMin;
                    }

                    SetTaxLevel(newTaxLevel);
                    PrintToChat(GetMsg("UpdateTaxMessage"), oldTax, newTaxLevel);
                }
            } else {
                SendReply(player, GetMsg("RulerError", player.UserIDString));
            }
        }
        //TODO ended here with case renaming to camelCase
        [ChatCommand("realmname")]
        void RealmNameCommand(BasePlayer player, string command, string[] arguments) {
            if (IsRuler(player.userID)) {
                string NewName = MergeParams(0, arguments);

                if (!String.IsNullOrEmpty(NewName)) {
                    SetRealmName(NewName);
                }
            } else
                SendReply(player, GetMsg("RulerError", player.UserIDString));
        }

        [ChatCommand("rplayers")]
        void PlayersCommand(BasePlayer player, string command, string[] arguments) {
            StringBuilder builder = new StringBuilder();
            int playerCount = BasePlayer.activePlayerList.Count;

            builder.Append(string.Format(GetMsg("OnlinePlayers"), playerCount) + " ");
            List<string> players = new List<string>();

            foreach (BasePlayer pl in BasePlayer.activePlayerList) {
                players.Add("<color=#ff0000ff>" + pl.displayName + "</color>");
            }
            builder.Append(String.Join(", ", players));

            SendReply(player, builder.ToString());
        }
        #endregion

        bool IsPlayerOnline(string partialNameOrID) {
            return GetPlayer(partialNameOrID).IsConnected;
        }

        bool IsChestSet() {
            return ruler.taxContainerID.IsValid;
        }

        BasePlayer GetPlayer(string partialNameOrID) {
            return BasePlayer.Find(partialNameOrID);
        }

        string MergeParams(int start, string[] paramz) {
            var merged = new StringBuilder();
            for (int i = start; i < paramz.Length; i++) {
                if (i > start) merged.Append(" ");
                merged.Append(paramz[i]);
            }

            return merged.ToString();
        }

        bool IsRuler(ulong steamId) {
            return currentRuler != null && currentRuler.userID == steamId;
        }

        public bool CanAffordheliStrike(BasePlayer player) {
            Item item = player.inventory.FindItemByItemID(config.heliItemCost);
            return item != null ? item.amount >= config.heliItemCostQty : false;
        }

        public void OrderheliStrike(BasePlayer playerToAttack) {
            // Deduct the cost
            if (currentRuler == null) currentRuler = GetPlayer(ruler.GetRuler().ToString());
            List<Item> collector = new List<Item>();

            Item item = currentRuler.inventory.FindItemByItemID(config.heliItemCost);
            if (item != null) {
                currentRuler.inventory.Take(collector, item.info.itemid, config.heliItemCostQty);

                Puts("Spawn the birdie");
                //spawn the birdie
                BaseHelicopter ent = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", new Vector3(), new Quaternion(), true) as BaseHelicopter;
                if (ent != null && playerToAttack != null) {
                    target = playerToAttack;
                    ent.GetComponent<PatrolHelicopterAI>().SetInitialDestination(playerToAttack.transform.position + new Vector3(0.0f, 10f, 0.0f), 0.25f);
                    ent.Spawn();
                    ent.gameObject.AddComponent<HeliComponent>();

                    timer.Once(HeliLifeTimeMinutes * 60, () => ent.GetComponent<HeliComponent>().heliRetire());
                }
            } else {
                SendReply(currentRuler, "Something went wrong");
            }
        }

        void SetRuler(BasePlayer bpruler) {
            Puts("New Ruler! " + bpruler.displayName);
            ruler
                .SetRuler(bpruler.userID)
                .SetRulerName(bpruler.displayName)
                .SetTaxContainerID(new NetworkableId())
                .SetTaxLevel(config.taxMin)
                .SetTaxContainerVector3(Vector3.negativeInfinity)
                .SetRealmName(GetMsg("DefaultRealm"))
                .SetRulerSince(_time.GetUnixTimestamp())
                .SetResourcesGot(0);
            currentRuler = bpruler;
            SaveRuler();
        }

        void SetTaxLevel(double newTaxLevel) {
            ruler.SetTaxLevel(newTaxLevel);
            SaveRuler();
        }

        void SetRealmName(string newName) {
            if (newName.Length > 36)
                newName = newName.Substring(0, 36);
            PrintToChat(string.Format(GetMsg("RealmRenamed"), newName));
            ruler.SetRealmName(newName);
            SaveRuler();
        }

        StorageContainer FindStorageContainer(Vector3 position) {
            foreach (StorageContainer cont in StorageContainer.FindObjectsOfType<StorageContainer>()) {
                Vector3 ContPosition = cont.transform.position;
                if (ContPosition == position) {
                    Puts("Tax Container instance found: " + cont.GetEntity().GetInstanceID());
                    ruler.SetTaxContainerID(cont.net.ID);
                    return cont;
                }
            }
            return null;
        }

        StorageContainer FindStorageContainer(NetworkableId netid) {
            return (StorageContainer)BaseNetworkable.serverEntities.Find(netid);
        }

        #region Player Grid Coordinates and Locators
        public interface ILocator
        {
            string GridReference(Vector3 component, out bool moved);
        }

        public class RustIOLocator : ILocator
        {
            public RustIOLocator(int worldSize) {
                worldSize = (worldSize != 0) ? worldSize : (ConVar.Server.worldsize > 0) ? ConVar.Server.worldsize : _instance.config.worldSize;
                translate = worldSize / 2f; //offset
                gridWidth = (worldSize * 0.0066666666666667f);
                scale = worldSize / gridWidth;
            }

            private readonly float translate;
            private readonly float scale;
            private readonly float gridWidth;

            public string GridReference(Vector3 pos, out bool moved) {
                float x = pos.x + translate;
                float z = pos.z + translate;

                int lat = (int)Math.Floor(x / scale); //letter
                char latChar = (char)('A' + lat);
                int lon = (int)Math.Round(gridWidth) - (int)Math.Floor(z / scale); //number
                moved = false; // We dont know, so just return false
                return string.Format("{0}{1}", latChar, lon);
            }
        }

        public class LocatorWithDelay : ILocator
        {
            public LocatorWithDelay(ILocator liveLocator, int updateInterval) {
                this.liveLocator = liveLocator;
                this.updateInterval = updateInterval;
            }

            private readonly ILocator liveLocator;
            private readonly int updateInterval;
            private readonly Dictionary<Vector3, ExpiringCoordinates> locations = new Dictionary<Vector3, ExpiringCoordinates>();

            public string GridReference(Vector3 pos, out bool moved) {
                ExpiringCoordinates item = null;
                bool m;

                if (locations.ContainsKey(pos)) {
                    item = locations[pos];
                    if (item.Expires < DateTime.Now) {
                        string location = liveLocator.GridReference(pos, out m);
                        item.GridChanged = item.Location != location;
                        item.Location = location;
                        item.Expires = DateTime.Now.AddSeconds(updateInterval);
                    }
                } else {
                    item = new ExpiringCoordinates();
                    item.Location = liveLocator.GridReference(pos, out m);
                    item.GridChanged = true;
                    item.Expires = DateTime.Now.AddSeconds(updateInterval);
                    locations.Add(pos, item);
                }

                moved = item.GridChanged;
                return item.Location;
            }

            class ExpiringCoordinates
            {
                public string Location { get; set; }
                public bool GridChanged { get; set; }
                public DateTime Expires { get; set; }
            }
        }

        #endregion

        #region Misc
        private MonumentInfo FindMonument(Vector3 pos) {
            MonumentInfo monumentClosest;

            foreach (var monument in TerrainMeta.Path.Monuments) {
                if (monument.name.Contains("oil", CompareOptions.IgnoreCase) || monument.name.Contains("cargo", CompareOptions.IgnoreCase)) {
                    float dist = Vector3.Distance(monument.transform.position, pos);
                    if (dist <= 80) {
                        monumentClosest = monument;
                        return monumentClosest;
                    }
                } else {
                    continue;
                }
            }
            return null;
        }
        #endregion

        #region Timers and Events

        void UpdateMarker(BasePlayer ruler) {
            if (ruler != null) {
                VendingMachineMapMarker marker = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", ruler.transform.position).GetComponent<VendingMachineMapMarker>();
                marker.markerShopName = "The ruler was last spotted here";
                marker.OwnerID = ruler.userID;
                _mapMarkerVending = marker;
                marker.Spawn();

                foreach (BasePlayer player in BasePlayer.activePlayerList) {

                    MapMarkerGenericRadius marker2 = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", ruler.transform.position).GetComponent<MapMarkerGenericRadius>();
                    marker2.alpha = 0.8f;
                    marker2.color1 = Color.red;
                    marker2.color2 = Color.green;
                    marker2.OwnerID = player.userID;
                    marker2.radius = 0.3f;
                    marker2.enabled = true;
                    marker2.Spawn();
                    marker2.SendUpdate();
                    if (!_mapMarker.ContainsKey(player.userID))
                        _mapMarker.Add(player.userID, marker2);
                }
            }
        }

        void RemoveMarkers() {

            foreach (MapMarkerGenericRadius marker in _mapMarker.Values) {
                marker.Kill();
            }
            if (_mapMarkerVending != null)
                _mapMarkerVending.Kill();

            _mapMarker.Clear();
            _mapMarkerVending = null;
        }

        void RemoveMarkersForce() {
            MapMarkerGenericRadius[] markers = GameObject.FindObjectsOfType<MapMarkerGenericRadius>();
            foreach (MapMarkerGenericRadius marker in markers) {
                marker.Kill();
            }
            VendingMachineMapMarker[] markers2 = GameObject.FindObjectsOfType<VendingMachineMapMarker>();
            foreach (VendingMachineMapMarker marker in markers2) {
                if (marker.markerShopName.Equals("The ruler was last spotted here")) {
                    marker.Kill();
                }
            }
        }

        void AdviseRulerPosition() {
            try {
                if (currentRuler != null && currentRuler.IsConnected) {
                    if (config.reasignOnAfk) {
                        double afkMinutes = currentRuler.IdleTime / 60d;
                        Puts("AFK: " + afkMinutes);
                        if (afkMinutes >= (config.reasignAfterMinutes - 2) && afkMinutes < config.reasignAfterMinutes) {
                            SendReply(currentRuler, $"You have been afk for {afkMinutes} minutes, new ruler will be chosen in a minute if you do not move");
                        }
                        if (afkMinutes >= 5) {
                            PrintToChat("A new ruler was chosen, as the previous ruler was AFK for 5mins");
                            TryForceNewRuler(true);
                        }
                    }

                    if ((config.broadcastRulerPosition || (config.broadcastRulerPositionAfterPercentage > 0 && ruler.GetTaxLevel() > config.broadcastRulerPositionAfterPercentage))) {
                        bool moved;

                        if (currentRuler == null) return;
                        string rulerMonument = FindMonument(currentRuler.transform.position)?.displayPhrase.english;
                        string rulerGrid = locator.GridReference(currentRuler.transform.position, out moved);
                        string rulerCoords = rulerMonument != null && rulerMonument.Length > 0 ? rulerMonument : rulerGrid;


                        if (moved) {
                            RemoveMarkers();
                            UpdateMarker(currentRuler);
                            PrintToChat(GetMsg("RulerLocation_Moved"), currentRuler.displayName, rulerCoords);
                        } else {
                            PrintToChat(GetMsg("RulerLocation_Static"), currentRuler.displayName, rulerCoords);
                        }
                    } else {

                    }
                    if (config.chooseNewRulerOnDisconnect && (currentRuler == null && BasePlayer.activePlayerList.Count > 0)) {
                        timer.Once((60 * config.chooseNewRulerOnDisconnectMinutes) - 5, () => TryForceRuler());
                    }
                } else {
                    if (BasePlayer.activePlayerList.Count > 0) {
                        PrintToChat(GetMsg("RulerOffline"));
                        TryForceNewRuler(true);
                    }
                }
            } catch (Exception e) {

            }
        }

        BasePlayer GetRandomPlayer() {
            ListHashSet<BasePlayer> players = BasePlayer.activePlayerList;
            int activePlayers = players.Count;
            if (activePlayers > 1) {
                return players[Core.Random.Range(0, activePlayers - 1)];
            }
            return activePlayers == 1 ? players.First() : null;
        }

        #endregion

        void SaveRuler() {
            Interface.Oxide.DataFileSystem.WriteObject<Ruler>("PoliticalSurvival", ruler, true);
        }

        void LoadRuler() {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("PoliticalSurvival")) {
                ruler = Interface.Oxide.DataFileSystem.ReadObject<Ruler>("PoliticalSurvival");
                Puts("ruler loaded");
            } else {
                Puts("Settings doesn't exist, creating default");
                ruler = new Ruler()
                .SetRuler(0)
                .SetRealmName(GetMsg("DefaultRealm"))
                .SetTaxLevel(0.0)
                .SetTaxContainerID(new NetworkableId())
                .SetResourcesGot(0)
                .SetTaxContainerVector3(Vector3.negativeInfinity);
                SaveRuler();
            }
        }

        void DebugLog(string msg) {
            if (DebugMode) Puts(msg);
        }

        string GetMsg(string msg, string userId = null) => userId != null ? lang.GetMessage(msg, this, userId) : lang.GetMessage(msg, this);
        void LoadServerMessages() {
            serverMessages = new Dictionary<string, string>();
            serverMessages.Add("StartingInformation", "<color=yellow>Welcome to {0}</color>. If you are new, we run a custom plugin where you can become the server Ruler, tax players, and control the economy. Type <color=#008080ff>/rinfo</color> for more information.");
            serverMessages.Add("PlayerConnected", "has connected to");
            serverMessages.Add("PlayerDisconnected", "has disconnected from");
            serverMessages.Add("RulerDied", "<color=#ff0000ff>The Ruler has died!</color>");
            serverMessages.Add("RulerMurdered", "<color=#ff0000ff>The Ruler has been murdered by {0}, who is now the new Ruler.</color>");
            serverMessages.Add("RealmRenamed", "The realm has been renamed to <color=#008080ff>{0}</color>");
            serverMessages.Add("DefaultRealm", "Land of the cursed");
            serverMessages.Add("OnlinePlayers", "Online players ({0}):");
            serverMessages.Add("PrivateError", "is either offline or you typed the name wrong.");
            serverMessages.Add("PrivateFrom", "PM from");
            serverMessages.Add("PrivateTo", "PM sent to");
            serverMessages.Add("RulerError", "You need to be the Ruler to do that!");
            serverMessages.Add("SettingNewTaxChest", "Look at a Wooden box  or TC and type <color=#008080ff>/settaxchest</color>");
            serverMessages.Add("SetNewTaxChestNotFound", "You must look at a wooden box or TC to set tax chest");
            serverMessages.Add("SetNewTaxChest", "You have set the new tax chest.");
            serverMessages.Add("ClaimRuler", "There is no ruler! <color=#008080ff>/claimruler</color> to become the new Ruler!");
            serverMessages.Add("IsNowRuler", "<color=#008080ff><b>{0}</b></color> is now the Ruler!");

            serverMessages.Add("InfoRuler", "Ruler");
            serverMessages.Add("InfoRealmName", "<color=#008080ff>Realm Name</color> {0}");
            serverMessages.Add("InfoTaxLevel", "<color=#008080ff>Tax level</color> {0}");
            serverMessages.Add("InfoRuleLength", "<color=#008080ff>Rule Length</color> {0}");
            serverMessages.Add("InfoResources", "<color=#008080ff>Resources Received</color> {0}");
            serverMessages.Add("InfoTaxCmd", "Use <color=#008080ff>/settax {0}-{1}</color> to set tax level");

            serverMessages.Add("RulerLocation_Moved", "Ruler <color=#ff0000ff>{0}</color> is on the move, now at <color=#ff0000ff>{1}</color>.");
            serverMessages.Add("RulerLocation_Static", "Ruler <color=#ff0000ff>{0}</color> is camping out at <color=#ff0000ff>{1}</color>");
            serverMessages.Add("UpdateTaxMessage", "The ruler has changed the tax from <color=#ff0000ff>{0}%</color> to <color=#ff0000ff>{1}%</color>");
            serverMessages.Add("PlayerNotFound", "player \"{0}\" not found, or ambiguous");

            serverMessages.Add("NewRuler", "<color=#008080ff>{0}</color> has been made the new Ruler. Kill him!");
            serverMessages.Add("ForceRullerErr", "Couldn't force a new ruler :(");

            serverMessages.Add("MinTax", "Min allowed tax is {0}");
            serverMessages.Add("MaxTax", "Max allowed tax is {0}");
            serverMessages.Add("RulerName", "<color=#008080ff>Ruler: </color> {0}");
            serverMessages.Add("NomoreAirspace", "Insufficient airspace for more than {0} helicopters, please wait for existing patrols to complete");
            serverMessages.Add("OrderingHeliCost", "Ordering a heli strike costs {0} {1}");
            serverMessages.Add("HeliInbound", "The heli is inbound");
            serverMessages.Add("RulerOffline", "Ruler went offline!");

            lang.RegisterMessages(serverMessages, this);
        }

        #region Config
        private class PSConfig
        {
            // Config default vars
            public bool Debug = false;
            public bool showWelcomeMsg = false;

            public int maxHelis = 2;
            public string heliItemCost = "metal.refined";
            public int heliItemCostQty = 500;

            public bool broadcastRulerPosition = true;
            public int broadcastRulerPositionEvery = 60;
            public int broadcastRulerPositionAfterPercentage = 10;
            public bool chooseNewRulerOnDisconnect = true;
            public int chooseNewRulerOnDisconnectMinutes = 5;

            public int taxMin = 0;
            public int taxMax = 15;
            //public TaxSource taxSource = new TaxSource().createDefault();
            public ulong taxBoxSkinId = 1482844040;
            public int reasignAfterMinutes = 5;
            public bool reasignOnAfk = true;

            public int worldSize = ConVar.Server.worldsize;

            // Plugin reference
            private PoliticalSurvival plugin;
            public PSConfig(PoliticalSurvival plugin) {
                this.plugin = plugin;
                /**
                 * Load all saved config values
                 * */
                GetConfig(ref Debug, "Debug: Show additional debug console logs");
                GetConfig(ref showWelcomeMsg, "Show connect welcome message");

                GetConfig(ref maxHelis, "Maximum helis allowed out at the same time");
                GetConfig(ref heliItemCost, "Currency of heli cost, shortname");
                GetConfig(ref heliItemCostQty, "Currency of heli cost, quantity");

                GetConfig(ref broadcastRulerPosition, "Ruler: Broadcast ruler position");
                GetConfig(ref broadcastRulerPositionEvery, "Ruler: Broadcast ruler position every x seconds");
                GetConfig(ref broadcastRulerPositionAfterPercentage, "Ruler: Broadcast ruler if tax higher than");
                GetConfig(ref chooseNewRulerOnDisconnect, "Ruler: Choose new ruler after disconnect");
                GetConfig(ref chooseNewRulerOnDisconnectMinutes, "Ruler: Disconnect: Choose new ruler after x minutes");

                GetConfig(ref taxMin, "TAX: Minimum");
                GetConfig(ref taxMax, "TAX: Maximum");
                //GetConfig(ref taxSource, "TAX: Source");
                GetConfig(ref taxBoxSkinId, "TAX: Taxbox skin id");
                GetConfig(ref reasignOnAfk, "AFK: Reasign Ruler When Player");
                GetConfig(ref reasignAfterMinutes, "AFK: Reasign After Minutes");

                GetConfig(ref worldSize, "MAP: World size");

                plugin.SaveConfig();
            }

            private void GetConfig<T>(ref T variable, params string[] path) {
                if (path.Length == 0) return;

                if (plugin.Config.Get(path) == null) {
                    SetConfig(ref variable, path);
                    plugin.PrintWarning($"Added new field to config: {string.Join("/", path)}");
                }

                variable = (T)Convert.ChangeType(plugin.Config.Get(path), typeof(T));
            }
            private void SetConfig<T>(ref T variable, params string[] path) => plugin.Config.Set(path.Concat(new object[] { variable }).ToArray());
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file.");
        #endregion 
    }
}

// --- End of file: PoliticalSurvival.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/perm-rewards ---
// --- Original File Path: P/PermRewards/PermRewards.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Perm Rewards", "Ryan", "1.0.2")]
    [Description("Gives players a kit-like reward if they're in an Oxide group")]
    internal class PermRewards : RustPlugin
    {
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #region Lang

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["DayFormat"] = "<color=orange>{0}</color> day and <color=orange>{1}</color> hours",
                ["DaysFormat"] = "<color=orange>{0}</color> days and <color=orange>{1}</color> hours",
                ["HourFormat"] = "<color=orange>{0}</color> hour and <color=orange>{1}</color> minutes",
                ["HoursFormat"] = "<color=orange>{0}</color> hours and <color=orange>{1}</color> minutes",
                ["MinFormat"] = "<color=orange>{0}</color> minute and <color=orange>{1}</color> seconds",
                ["MinsFormat"] = "<color=orange>{0}</color> minutes and <color=orange>{1}</color> seconds",
                ["SecsFormat"] = "<color=orange>{0}</color> seconds",
                ["Cooldown"] = "Try again in {0}",
                ["AlreadyUsed"] = "You've already claimed all of your rewards!",
                ["Reward"] = "Thanks for being in our steam group {0}!",
                ["NotAllowed"] = "You're not in our steam group!",
                ["FullInventory"] = "<color=#ff6666>You don't have enough room for your reward items</color>"
            }, this);
        }

        #endregion Lang

        #region Data

        private static Cooldowns cooldowns;

        public class Cooldowns
        {
            public Dictionary<ulong, DateTime> PlayerCooldowns = new Dictionary<ulong, DateTime>();
        }

        public class Data
        {
            public static void Add(BasePlayer player)
            {
                if (cooldowns.PlayerCooldowns.ContainsKey(player.userID))
                    return;
                else
                {
                    cooldowns.PlayerCooldowns.Add(player.userID, DateTime.UtcNow);
                    Save();
                }
            }
            public static bool Exists(BasePlayer player)
            {
                if (cooldowns.PlayerCooldowns.ContainsKey(player.userID))
                    return true;
                else
                    return false;
            }
            public static void Remove(BasePlayer player)
            {
                if (cooldowns.PlayerCooldowns.ContainsKey(player.userID))
                {
                    cooldowns.PlayerCooldowns.Remove(player.userID);
                    Save();
                }
            }
            public static void Clear()
            {
                cooldowns.PlayerCooldowns.Clear();
                Save();
            }

            public static void Save() => Interface.Oxide.DataFileSystem.WriteObject("PermRewards", cooldowns);
        }

        #endregion Data

        #region Config

        private ConfigFile _Config;

        public class Items
        {
            public string ItemName { get; set; }
            public int Amount { get; set; }
        }

        public class ConfigFile
        {
            [JsonProperty(PropertyName = "Item names and their amounts")]
            public List<Items> ItemInfo;

            [JsonProperty(PropertyName = "Command to use the reward")]
            public string Command;

            [JsonProperty(PropertyName = "Reward cooldown (seconds)")]
            public float Cooldown;

            [JsonProperty(PropertyName = "Enable the cooldown (true/false)")]
            public bool UseCooldown;

            [JsonProperty(PropertyName = "Oxide permission group")]
            public string OxideGroup;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    OxideGroup = "steam",
                    Command = "steam",
                    UseCooldown = true,
                    Cooldown = 600,
                    ItemInfo = new List<Items>()
                    {
                        new Items
                        {
                            ItemName = "explosive.timed",
                            Amount = 2
                        },
                        new Items
                        {
                            ItemName = "gunpowder",
                            Amount = 250
                        },
                        new Items
                        {
                            ItemName = "lowgradefuel",
                            Amount = 500
                        }
                    }
                };
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating default configuration file...");
            _Config = ConfigFile.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _Config = Config.ReadObject<ConfigFile>();
        }

        protected override void SaveConfig() => Config.WriteObject(_Config);

        #endregion Config

        #region Methods

        private void GiveItem(BasePlayer player)
        {
            foreach (var item in _Config.ItemInfo)
                player.GiveItem(ItemManager.CreateByName(item.ItemName, item.Amount));
            LogToFile("Redeems", $"[{DateTime.Now}] {player.displayName} ({player.UserIDString}) has redeemed their reward", this);
            PrintToChat(player, Lang("Reward", player.UserIDString, player.displayName));
        }

        public double GetCooldown(BasePlayer player)
        {
            if (Data.Exists(player))
                return Math.Floor((cooldowns.PlayerCooldowns[player.userID].AddSeconds(_Config.Cooldown) - DateTime.UtcNow).TotalSeconds);
            else return 0;
        }

        private string GetFormattedMsg(double cooldown)
        {
            TimeSpan timeSpan = TimeSpan.FromSeconds(cooldown);

            if (timeSpan == null) return null;

            if (Math.Floor(timeSpan.TotalDays) >= 1)
                return string.Format(timeSpan.Days > 1 ? Lang("DaysFormat", null, timeSpan.Days, timeSpan.Hours) : Lang("DayFormat", null, timeSpan.Days, timeSpan.Hours));

            if (Math.Floor(ti