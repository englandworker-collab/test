meSpan.TotalMinutes) > 60)
                return string.Format(timeSpan.Hours > 1 ? Lang("HoursFormat", null, timeSpan.Hours, timeSpan.Minutes) : Lang("HourFormat", null, timeSpan.Hours, timeSpan.Minutes));

            if (Math.Floor(timeSpan.TotalSeconds) > 60)
                return string.Format(timeSpan.Minutes > 1 ? Lang("MinsFormat", null, timeSpan.Minutes, timeSpan.Seconds) : Lang("MinFormat", null, timeSpan.Minutes, timeSpan.Seconds));

            return Lang("SecsFormat", null, timeSpan.Seconds);
        }

        #endregion Methods

        #region Hooks

        private void OnNewSave(string filename) => Data.Clear();

        private void Loaded()
        {
            cooldowns = Interface.Oxide.DataFileSystem.ReadObject<Cooldowns>(Name);
            cmd.AddChatCommand(_Config.Command, this, "chatCmd");
            SaveConfig();
        }
        private bool CanUse(BasePlayer player)
        {
            if (!permission.UserHasGroup(player.UserIDString, _Config.OxideGroup))
            {
                PrintToChat(player, Lang("NotMember", player.UserIDString));
                return false;
            }
            if (Data.Exists(player))
            {
                if (!_Config.UseCooldown)
                {
                    PrintToChat(Lang("AlreadyUsed", player.UserIDString));
                    return false;
                }
                if (cooldowns.PlayerCooldowns[player.userID].AddSeconds(_Config.Cooldown) > DateTime.UtcNow)
                {
                    PrintToChat(Lang("Cooldown", player.UserIDString, GetFormattedMsg(GetCooldown(player))));
                    return false;
                }
                else if (cooldowns.PlayerCooldowns[player.userID].AddSeconds(_Config.Cooldown) < DateTime.UtcNow)
                {
                    if (!player.inventory.containerMain.IsFull() && !player.inventory.containerBelt.IsFull())
                    {
                        Data.Remove(player);
                        return true;
                    }
                    PrintToChat(player, Lang("FullInventory", player.UserIDString));
                    return false;
                }
            }
            if (!Data.Exists(player))
            {
                if (!player.inventory.containerMain.IsFull() && !player.inventory.containerBelt.IsFull())
                {
                    Data.Add(player);
                    return true;
                }
                PrintToChat(player, Lang("FullInventory", player.UserIDString));
                return false;
            }
            return true;
        }

        private void chatCmd(BasePlayer player, string command, string[] args)
        {
            if (!CanUse(player)) return;
            GiveItem(player);
        }

        #endregion Hooks
    }
}


// --- End of file: PermRewards.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/promocodes ---
// --- Original File Path: P/Promocodes/Promocodes.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Promocodes", "LaserHydra", "3.0.0", ResourceId = 1471)]
    [Description("Create promotion codes which run commands when redeemed by players")]
    public sealed class Promocodes : CovalencePlugin
    {
        private static Promocodes _instance;
        private List<PromocodeGroup> _promocodeGroups;

        #region Initialization

        private void Init()
        {
            _instance = this;
            _promocodeGroups.ForEach(p => p.FillCodes());
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Invalid Code"] = "The code you entered seems to be either invalid or already redeemed.",
                ["Code Redeemed"] = "You redeemed a code with and received {amount} reward packages."
            }, this);
        }

        #endregion

        #region Config Handling

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _promocodeGroups = Config.ReadObject<List<PromocodeGroup>>();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_promocodeGroups);

        protected override void LoadDefaultConfig() => _promocodeGroups = new List<PromocodeGroup> { PromocodeGroup.GetDefaultGroup() };

        #endregion

        #region Commands

        [Command("redeem")]
        private void RedeemCommand(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 1)
            {
                player.Reply("Syntax: redeem <code>");
                return;
            }

            string code = args[0];

            int i = 0;
            foreach (var promocodeGroup in _promocodeGroups)
            {
                if (promocodeGroup.IsValidCode(code))
                {
                    promocodeGroup.RedeemCode(player, code);
                    i++;
                }
            }

            player.Reply(i == 0
                ? lang.GetMessage("Invalid Code", this, player.Id)
                : lang.GetMessage("Code Redeemed", this, player.Id).Replace("{amount}", i.ToString()));
        }

        #endregion

        #region Classes

        private sealed class PromocodeGroup
        {
            [JsonProperty("Automatically Fill To (Amount)")]
            private int _fillAmount = 5;

            [JsonProperty("Codes")]
            private List<string> _codes = new List<string>();

            [JsonProperty("Commands")]
            private CommandCall[] _commands = new CommandCall[0];

            public bool IsValidCode(string code) => _codes.Contains(code);

            public void RedeemCode(IPlayer player, string code)
            {
                if (!IsValidCode(code))
                    return;

                foreach (var command in _commands)
                    _instance.server.Command(command.Command, command.GetParameters(player));

                _codes.Remove(code);

                FillCodes();

                _instance?.SaveConfig();
            }

            public void FillCodes()
            {
                if (_codes == null)
                    return;

                while (_codes.Count < _fillAmount)
                    _codes.Add(GenerateCode());

                _instance?.SaveConfig();
            }

            private static string GenerateCode() => Guid.NewGuid().ToString();

            public static PromocodeGroup GetDefaultGroup() => new PromocodeGroup
            {
                _commands = new[]
                {
                    new CommandCall("say", new[] {"{username} just redeemed a code!"})
                }
            };
        }

        public sealed class CommandCall
        {
            [JsonProperty("Parameters")]
            private string[] _parameters;

            [JsonProperty("Command")]
            public string Command { get; private set; }

            public string[] GetParameters(IPlayer player)
            {
                return _parameters.Select(parameter =>
                    parameter.Replace("{id}", player.Id).Replace("{username}", player.Name)
                ).ToArray();
            }

            public CommandCall()
            {   
            }

            public CommandCall(string command, string[] parameters)
            {
                Command = command;
                _parameters = parameters;
            }
        }

        #endregion
    }
}

// --- End of file: Promocodes.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/private-messages ---
// --- Original File Path: P/PrivateMessages/PrivateMessages.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("PrivateMessages", "MisterPixie", "1.1.11")]
    [Description("Allows users to send private messages to each other")]
    class PrivateMessages : CovalencePlugin
    {
        private readonly Dictionary<string, string> pmHistory = new Dictionary<string, string>();
        private Dictionary<string, double> cooldown = new Dictionary<string, double>();
        private List<LastFivePms> lastFivePms = new List<LastFivePms>();
        private const string allowPerm = "privatemessages.allow";

        class LastFivePms
        {
            public string target { get; set; }
            public string sender { get; set; }
            public List<string> messages { get; set; }
        }

        [PluginReference] private Plugin Ignore, UFilter, BetterChatMute;

        #region lang

        private string Lang(string key, string id = null, params object[] args) =>
            string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"PMTo", "[#00FFFF]PM to {0}[/#]: {1}"},
                {"PMFrom", "[#00FFFF]PM from {0}[/#]: {1}"},
                {"PlayerNotOnline", "{0} is not online."},
                {"NotOnlineAnymore", "The last person you was talking to is not online anymore."},
                {"NotMessaged", "You haven't messaged anyone or they haven't messaged you."},
                {"IgnoreYou", "[#FF0000]{0} is ignoring you and cant receive your PMs[/#]"},
                {"SelfPM", "You can not send messages to yourself."},
                {"SyntaxR", "Incorrect Syntax use: /r <msg>"},
                {"HistorySyntax", "Incorrect Syntax use: /pmhistory <name>"},
                {"SyntaxPM", "Incorrect Syntax use: /{0} <name> <msg>"},
                {"NotAllowedToChat", "You are not allowed to chat here"},
                {"History", "Your History:\n{0}"},
                {"CooldownMessage", "You will be able to send a private message in {0} seconds"},
                {"NoHistory", "There is not any saved pm history with this player."},
                {"CannotFindUser", "Cannot find this user"},
                {"CommandDisabled", "This command has been disabled"},
                {"IsMuted", "You are currently muted & cannot send private messages"},
                {"TargetMuted", "This person is muted & cannot receive your private message"},
                {"NoPermission", "You don't have the correct permissions to run this command"},
                {"HistoryPM", "[#00FFFF]{0}[/#]: {1}"},
                {"Logging", "[PM]{0}->{1}:{2}"}
            }, this);
        }

        #endregion

        private void Init()
        {
            LoadVariables();

            if(string.IsNullOrEmpty(configData.PmCommand))
                AddCovalenceCommand("pm", "cmdPm");
            else
                AddCovalenceCommand(configData.PmCommand, "cmdPm");

            AddCovalenceCommand("r", "cmdPmReply");
            AddCovalenceCommand("pmhistory", "cmdPmHistory");
            permission.RegisterPermission(allowPerm, this);
        }

        private void OnUserDisconnected(IPlayer player)
        {
            if (pmHistory.ContainsKey(player.Id))
            {
                pmHistory.Remove(player.Id);
            }
        }

        private void cmdPm(IPlayer player, string command, string[] args)
        {
            if (configData.UsePermission)
            {
                if (!player.HasPermission(allowPerm))
                {
                    player.Reply(Lang("NoPermission", player.Id));
                    return;
                }
            }

            if (args.Length > 1)
            {
                var name = args[0];
                var p = FindPlayer(name);
                if (p != null)
                {
                    if (p.Id == player.Id)
                    {
                        player.Reply(Lang("SelfPM", player.Id));
                        return;
                    }

                    if (!(bool)(Interface.Oxide.CallHook("CanChat", player) ?? true))
                    {
                        player.Reply(Lang("NotAllowedToChat", player.Id));
                        return;
                    }

                    if (configData.UseBetterChatMute && BetterChatMute != null && CheckMuteStatus(player, p))
                    {
                        return;
                    }

                    if (IsCooldowned(player))
                    {
                        return;
                    }

                    if (IsIgnored(player, p))
                    {
                        return;
                    }

                    var msg = RemoveRichText(IsUFilter(args));

                    if (Interface.Oxide.CallHook("OnPMProcessed", player, p, msg) != null)
                    {
                        return;
                    }

                    AddPmHistory(player.Id, p.Id);

                    player.Reply(Lang("PMTo", player.Id, p.Name, msg));
                    p.Reply(Lang("PMFrom", p.Id, player.Name, msg));

                    AddHistoryAndLogging(player, p, msg);
                }
                else
                {
                    player.Reply(Lang("PlayerNotOnline", player.Id, name));
                }
            }
            else
            {
                player.Reply(Lang("SyntaxPM", player.Id, configData.PmCommand));
            }
        }

        private void cmdPmReply(IPlayer player, string command, string[] args)
        {
            if (configData.UsePermission)
            {
                if (!player.HasPermission(allowPerm))
                {
                    player.Reply(Lang("NoPermission", player.Id));
                    return;
                }
            }

            if (args.Length > 0)
            {
                string steamid;
                if (pmHistory.TryGetValue(player.Id, out steamid))
                {
                    var p = FindPlayer(steamid);
                    if (p != null)
                    {
                        if (!(bool)(Interface.Oxide.CallHook("CanChat", player) ?? true))
                        {
                            player.Reply(Lang("NotAllowedToChat", player.Id));
                            return;
                        }

                        if (configData.UseBetterChatMute && BetterChatMute != null && CheckMuteStatus(player, p))
                        {
                            return;
                        }

                        if (IsCooldowned(player))
                        {
                            return;
                        }

                        if (IsIgnored(player, p))
                        {
                            return;
                        }

                        var msg = RemoveRichText(IsUFilter(args, true));

                        if (Interface.Oxide.CallHook("OnPMProcessed", player, p, msg) != null)
                        {
                            return;
                        }

                        AddPmHistory(player.Id, p.Id);

                        player.Reply(Lang("PMTo", player.Id, p.Name, msg));
                        p.Reply(Lang("PMFrom", p.Id, player.Name, msg));

                        AddHistoryAndLogging(player, p, msg);
                    }
                    else
                    {
                        player.Reply(Lang("NotOnlineAnymore", player.Id));
                    }
                }
                else
                {
                    player.Reply(Lang("NotMessaged", player.Id));
                }
            }
            else
            {
                player.Reply(Lang("SyntaxR", player.Id));
            }
        }

        private void AddHistoryAndLogging(IPlayer initiator, IPlayer target, string message)
        {
            if (configData.EnableHistory)
                AddToHistory(initiator.Id, target.Id, Lang("HistoryPM", null, initiator.Name, message));

            if (configData.EnableLogging)
                Puts(Lang("Logging", null, initiator.Name, target.Name, message));
        }

        private void AddPmHistory(string initiatorId, string targetId)
        {
            pmHistory[initiatorId] = targetId;
            pmHistory[targetId] = initiatorId;
        }

        private bool CheckMuteStatus(IPlayer player, IPlayer target)
        {
            if ((bool)BetterChatMute.CallHook("API_IsMuted", player))
            {
                player.Reply(Lang("IsMuted", player.Id));
                return true;
            }

            if ((bool)BetterChatMute.CallHook("API_IsMuted", target))
            {
                player.Reply(Lang("TargetMuted", player.Id));
                return true;
            }

            return false;
        }

        private void cmdPmHistory(IPlayer player, string command, string[] args)
        {
            if (configData.EnableHistory)
            {
                if (args.Length == 0)
                {
                    player.Reply(Lang("HistorySyntax", player.Id));
                    return;
                }

                if (args.Length == 1)
                {
                    var p = covalence.Players.FindPlayer(args[0]);

                    if (p != null)
                    {
                        var History = GetLastFivePms(player.Id, p.Id);

                        if (History == null)
                        {
                            player.Reply(Lang("NoHistory", player.Id));
                            return;
                        }

                        string msg = string.Join(Environment.NewLine, History.messages.ToArray());

                        player.Reply(Lang("History", player.Id, msg));
                    }
                    else
                    {
                        player.Reply(Lang("CannotFindUser", player.Id));
                    }
                }
            }
            else
            {
                player.Reply(Lang("CommandDisabled", player.Id));
            }
        }

        private string RemoveRichText(string message)
        {
            char[] fullArray = new char[message.Length];
            int arrayIndex = 0;
            bool tags = false;
            char c;
            for (int i = 0; i < message.Length; i++)
            {
                c = message[i];
                if (c == '<')
                {
                    tags = true;
                    continue;
                }

                if (c == '>')
                {
                    tags = false;
                    continue;
                }

                if (!tags)
                {
                    fullArray[arrayIndex] = c;
                    arrayIndex++;
                }
            }

            return new string(fullArray, 0, arrayIndex);
        }

        private IPlayer FindPlayer(string nameOrIdOrIp)
        {
            foreach (var activePlayer in covalence.Players.Connected)
            {
                if (activePlayer.Id == nameOrIdOrIp)
                    return activePlayer;
                if (activePlayer.Name.Contains(nameOrIdOrIp))
                    return activePlayer;
                if (activePlayer.Name.ToLower().Contains(nameOrIdOrIp.ToLower()))
                    return activePlayer;
                if (activePlayer.Address == nameOrIdOrIp)
                    return activePlayer;
            }

            return null;
        }

        private void AddToHistory(string sender, string target, string msg)
        {
            var value = GetLastFivePms(sender, target);

            if (value == null)
            {
                lastFivePms.Add(new LastFivePms
                {
                    sender = sender,
                    target = target,
                    messages = new List<string>
                    {
                        msg
                    }
                });
            }
            else
            {
                value.messages.Add(msg);

                if (value.messages.Count == 6)
                {
                    value.messages.Remove(value.messages.First());
                }
            }
        }

        private LastFivePms GetLastFivePms(string sender, string target) => lastFivePms.Find(x =>
            x.sender == sender && x.target == target || x.sender == target && x.target == sender);

        private bool IsIgnored(IPlayer sender, IPlayer target)
        {
            if (configData.UseIgnore)
            {
                var hasIgnore = Ignore?.CallHook("HasIgnored", target.Id, sender.Id);

                if (hasIgnore != null && (bool)hasIgnore)
                {
                    sender.Reply(Lang("IgnoreYou", sender.Id, target.Name));
                    return true;
                }
            }

            return false;
        }

        private string IsUFilter(string[] args, bool isR = false)
        {
            string message = string.Join(" ", args.Skip(1).ToArray());

            if (isR)
                message = string.Join(" ", args.Skip(0).ToArray());

            if (configData.UseUFilter)
            {
                var hasUFilter = (object)UFilter?.Call("ProcessText", message);

                if (hasUFilter != null)
                {
                    message = hasUFilter.ToString();
                }
            }

            return message;
        }

        private bool IsCooldowned(IPlayer player)
        {
            if (configData.UseCooldown)
            {
                double time;
                if (cooldown.TryGetValue(player.Id, out time))
                {
                    if (time > GetTimeStamp())
                    {
                        player.Reply(Lang("CooldownMessage", player.Id, Math.Round(time - GetTimeStamp(), 2)));
                        return true;
                    }

                    cooldown.Remove(player.Id);
                }

                cooldown.Add(player.Id, GetTimeStamp() + configData.CooldownTime);
            }

            return false;
        }

        private double GetTimeStamp()
        {
            return (DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;
        }

        #region Config

        private ConfigData configData;

        private class ConfigData
        {
            public bool UseUFilter;
            public bool UseIgnore;
            public bool UseCooldown;
            public bool UseBetterChatMute;
            public bool EnableLogging;
            public bool EnableHistory;
            public bool UsePermission;
            public int CooldownTime;
            public string PmCommand;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                UseIgnore = false,
                UseCooldown = false,
                UseUFilter = false,
                UsePermission = false,
                UseBetterChatMute = false,
                EnableLogging = true,
                EnableHistory = false,
                CooldownTime = 3,
                PmCommand = "pm"
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

        #endregion
    }
}

// --- End of file: PrivateMessages.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/privilege-deploy ---
// --- Original File Path: P/PrivilegeDeploy/PrivilegeDeploy.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{ 
    [Info("PrivilegeDeploy", "k1lly0u", "0.1.7")]
    [Description("Choose which deployable items require building privilege to deploy")]
    class PrivilegeDeploy : RustPlugin
    {
        private readonly Hash<string, ItemDefinition> prefabToItem = new Hash<string, ItemDefinition>();
        private readonly Hash<string, List<ItemAmount>> constructionToIngredients = new Hash<string, List<ItemAmount>>();

        #region Hooks
        private void Loaded() => Unsubscribe(nameof(OnEntitySpawned));

        private void OnServerInitialized()
        {
            LoadVariables();
            InitValidList();

            Subscribe(nameof(OnEntitySpawned));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["blocked"] = "You can not build this outside of a building privileged area!"
            }, this);
        }

        private void OnEntitySpawned(BaseEntity baseEntity)
        {
            if (baseEntity is ResourceEntity || baseEntity is BaseNpc || baseEntity is LootContainer)
                return;

            if (configData.Deployables.Contains(baseEntity.ShortPrefabName) || configData.Deployables.Contains(baseEntity.PrefabName))
            {
                if (!baseEntity.OwnerID.IsSteamId())
                    return;

                BasePlayer player = BasePlayer.FindByID(baseEntity.OwnerID);
                if (player == null || player.IsAdmin || player.IsBuildingAuthed())
                    return;

                List<ItemAmount> items = Facepunch.Pool.GetList<ItemAmount>();

                if (baseEntity is BuildingBlock && constructionToIngredients.ContainsKey(baseEntity.PrefabName))                
                    items.AddRange(constructionToIngredients[baseEntity.PrefabName]);                   
                
                else if (prefabToItem.ContainsKey(baseEntity.PrefabName))
                    items.Add(new ItemAmount(prefabToItem[baseEntity.PrefabName], 1));
                         
                NextTick(() =>
                {
                    if (baseEntity == null || baseEntity.IsDestroyed)
                    {
                        Facepunch.Pool.FreeList(ref items);
                        return;
                    }
                                        
                    (baseEntity as StorageContainer)?.inventory?.Clear();

                    if (baseEntity is BaseTrap || !(baseEntity is BaseCombatEntity))
                        baseEntity.Kill();
                    else (baseEntity as BaseCombatEntity).DieInstantly();

                    if (player != null && player.IsConnected)
                    {
                        for (int i = 0; i < items.Count; i++)
                        {
                            ItemAmount itemAmount = items[i];

                            Item item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount);

                            ItemModDeployable deployable = item.info.GetComponent<ItemModDeployable>();
                            if (deployable != null)
                            {
                                BaseOven oven = deployable.entityPrefab.Get()?.GetComponent<BaseOven>();
                                if (oven != null)
                                    oven.startupContents = System.Array.Empty<ItemAmount>();
                            }

                            player.inventory.GiveItem(item, player.inventory.containerBelt);
                            player.Command("note.inv", new object[] { item.info.itemid, 1, item.name, 0 });
                        }

                        player.ChatMessage(lang.GetMessage("blocked", this, player.UserIDString));
                    }

                    Facepunch.Pool.FreeList(ref items);
                });                
            }
        }
        #endregion

        #region Prefab to Item links
        private void InitValidList()
        {
            foreach (ItemDefinition itemDefinition in ItemManager.GetItemDefinitions())
            {
                ItemModDeployable deployable = itemDefinition?.GetComponent<ItemModDeployable>();
                if (deployable == null)
                    continue;
                
                if (!prefabToItem.ContainsKey(deployable.entityPrefab.resourcePath))                
                    prefabToItem.Add(deployable.entityPrefab.resourcePath, itemDefinition);                
            }

            foreach (Construction construction in GetAllPrefabs<Construction>())
            {
                if (construction.deployable == null && !string.IsNullOrEmpty(construction.fullName))
                {
                    if (!constructionToIngredients.ContainsKey(construction.fullName))                    
                        constructionToIngredients.Add(construction.fullName, construction.defaultGrade.costToBuild);
                }
            }
        }

        private T[] GetAllPrefabs<T>()
        {
            Dictionary<uint, PrefabAttribute.AttributeCollection> prefabs = PrefabAttribute.server.prefabs;
            if (prefabs == null)
                return new T[0];

            List<T> results = new List<T>();
            foreach (PrefabAttribute.AttributeCollection prefab in prefabs.Values)
            {
                T[] arrayCache = prefab.Find<T>();
                if (arrayCache == null || !arrayCache.Any())
                    continue;

                results.AddRange(arrayCache);
            }

            return results.ToArray();
        }
        #endregion

        #region Config
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "deployables")]
            public List<string> Deployables { get; set; }
        }

        private void LoadVariables()
        {           
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                Deployables = new List<string>
                {
                    "barricade.concrete",
                    "barricade.metal",
                    "barricade.sandbags",
                    "barricade.stone",
                    "barricade.wood",
                    "barricade.woodwire",
                    "campfire",
                    "gates.external.high.stone",
                    "gates.external.high.wood",
                    "wall.external.high",
                    "wall.external.high.stone",
                    "landmine",
                    "beartrap"
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}



// --- End of file: PrivilegeDeploy.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pumpkin-bombs ---
// --- Original File Path: P/PumpkinBombs/PumpkinBombs.cs ---

﻿using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("PumpkinBombs", "k1lly0u", "0.1.2", ResourceId = 2070)]
    class PumpkinBombs : RustPlugin
    {
        #region Fields      
        static PumpkinBombs ins; 
         
        private Dictionary<string, ItemDefinition> itemDefs;
        private List<ulong> craftedBombs;

        const string jackAngry = "jackolantern.angry";
        const string jackHappy = "jackolantern.happy";
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            permission.RegisterPermission("pumpkinbombs.use", this);
            permission.RegisterPermission("pumpkinbombs.free", this);
            lang.RegisterMessages(Messages, this);
            craftedBombs = new List<ulong>();
        }
        void OnServerInitialized()
        {
            ins = this;
            LoadVariables();
            itemDefs = ItemManager.itemList.ToDictionary(i => i.shortname);
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (craftedBombs.Contains(player.userID))
            {
                if (player != null)
                {
                    foreach (var item in configData.Costs)
                        player.GiveItem(ItemManager.CreateByItemID(itemDefs[item.Name].itemid, item.Amount), BaseEntity.GiveItemReason.PickedUp);
                }
                craftedBombs.Remove(player.userID);
            }
        }
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity is BaseOven)
            {
                if (entity.ShortPrefabName == "jackolantern.happy" || entity.ShortPrefabName == "jackolantern.angry")
                {
                    var baseOven = entity as BaseOven;
                    if (craftedBombs.Contains(baseOven.OwnerID))
                    {
                        baseOven.gameObject.AddComponent<BombLight>();                        
                        craftedBombs.Remove(baseOven.OwnerID);
                    }
                }
            }
        }
        #endregion

        #region Helpers
        bool CanUse(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "pumpkinbombs.use") || player.IsAdmin;
        bool IsFree(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "pumpkinbombs.free");
        private bool HasEnoughRes(BasePlayer player, int itemid, int amount) => player.inventory.GetAmount(itemid) >= amount;
        private void TakeResources(BasePlayer player, int itemid, int amount) => player.inventory.Take(null, itemid, amount);
        #endregion

        #region Classes
        class BombLight : MonoBehaviour
        {
            private BaseOven entity;
            private bool lastOn;

            public void Awake()
            {
                entity = GetComponent<BaseOven>();
                lastOn = false;
                entity.SetFlag(BaseEntity.Flags.On, false);

                var expEnt = GameManager.server.CreateEntity("assets/prefabs/tools/c4/explosive.timed.deployed.prefab", entity.transform.position, new Quaternion(), true);
                TimedExplosive explosive = expEnt.GetComponent<TimedExplosive>();
                explosive.timerAmountMax = ins.configData.Explosives.Timer;
                explosive.timerAmountMin = ins.configData.Explosives.Timer;
                explosive.explosionRadius = ins.configData.Explosives.Radius;
                explosive.damageTypes = new List<Rust.DamageTypeEntry> { new Rust.DamageTypeEntry {amount = ins.configData.Explosives.Amount, type = Rust.DamageType.Explosion } };
                explosive.Spawn();

                entity.InvokeRepeating(this.ToggleLight, 0.5f, 0.5f);
            }

            public void OnDestroy()
            {
                entity.CancelInvoke();
            }

            private void ToggleLight()
            {
                if (lastOn)                
                    entity.SetFlag(BaseEntity.Flags.On, false);
                else entity.SetFlag(BaseEntity.Flags.On, true);

                lastOn = !lastOn;
            }            
        }
        #endregion

        #region Chat Commands
        [ChatCommand("pb")]
        void cmdPB(BasePlayer player, string command, string[] args)
        {
            if (!CanUse(player)) return;
            if (craftedBombs.Contains(player.userID))
            {
                if (!HasEnoughRes(player, -1284735799, 1))
                {
                    SendReply(player, $"<color={configData.Main}>{msg("lostBomb", player.UserIDString)}</color>");
                    craftedBombs.Remove(player.userID);
                    return;
                }
                SendReply(player, $"<color={configData.Main}>{msg("alreadyhave", player.UserIDString)}</color>");
                return;
            }
            if (!IsFree(player))
            {
                bool canCraft = true;
                foreach (var item in configData.Costs)
                {
                    if (!HasEnoughRes(player, itemDefs[item.Name].itemid, item.Amount)) { canCraft = false; break; }
                }
                if (canCraft)
                {
                    foreach (var item in configData.Costs)
                        TakeResources(player, itemDefs[item.Name].itemid, item.Amount);
                }
                else
                {
                    SendReply(player, $"<color={configData.Main}>{msg("noRes", player.UserIDString)}</color>");
                    foreach (var item in configData.Costs)
                        SendReply(player, $"<color={configData.Main}>{item.Amount}x {itemDefs[item.Name].displayName.english}</color>");
                    return;
                }
            }
            craftedBombs.Add(player.userID);
            player.inventory.GiveItem(ItemManager.CreateByItemID(-1284735799, 1));
            SendReply(player, $"<color={configData.Main}>{msg("readyMsg", player.UserIDString)}</color>");
        }
        #endregion

        #region Config         
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Explosive Settings")]
            public Explosive Explosives { get; set; }
            [JsonProperty(PropertyName = "Crafting Costs")]
            public List<CraftCost> Costs { get; set; }
            [JsonProperty(PropertyName = "Message Color (hex)")]
            public string Main { get; set; }

            public class CraftCost
            {
                [JsonProperty(PropertyName = "Item shortname")]
                public string Name;
                [JsonProperty(PropertyName = "Amount required")]
                public int Amount;
            }
            public class Explosive
            {
                [JsonProperty(PropertyName = "Detonation timer (seconds)")]
                public int Timer { get; set; }
                [JsonProperty(PropertyName = "Explosive radius")]
                public float Radius { get; set; }
                [JsonProperty(PropertyName = "Damage amount")]
                public float Amount { get; set; }
            }            
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Costs = new List<ConfigData.CraftCost>
                {
                    new ConfigData.CraftCost
                    {
                        Amount = 1,
                        Name = "explosive.timed"
                    },
                    new ConfigData.CraftCost
                    {
                        Amount = 1,
                        Name = "pumpkin"
                    }
                },
                Explosives = new ConfigData.Explosive
                {
                    Timer = 10,
                    Radius = 5,
                    Amount = 70
                },
                Main = "#D85540"
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messaging
        string msg(string key, string id = null) => lang.GetMessage(key, this, id);
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"readyMsg","Your pumpkin bomb is ready. Simply place the Jack'O'Lantern you just received on the floor to activate it" },
            { "noRes","You do not have enough resources to create a pumpkin bomb. You will need the following;"},
            {"alreadyhave", "You already have a pumpkin bomb ready for deployment" },
            {"lostBomb", "It seems you have lost your bomb. Now you must create a new one..." }
        };
        #endregion
    }
}

// --- End of file: PumpkinBombs.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/parachute ---
// --- Original File Path: P/Parachute/Parachute.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Parachute", "Rustoholics", "0.2.2")]
    [Description("Give players a parachute")]

    public class Parachute : CovalencePlugin
    {
        
        #region  Dependencies

        [PluginReference] private Plugin Chute;
        
        #endregion
        
        #region Config

        private double _fallSpeed = 1d;
        private float _fallTimer = 0.2f;
        private int _coolDown = 5;
        private float _packCheckTimer = 60f;
        private string _backpackPrefab = "assets/prefabs/misc/item drop/item_drop_backpack.prefab";

        private Dictionary<string, Timer> _fallTimers = new Dictionary<string, Timer>();

        private Configuration _config;
        protected override void SaveConfig() => Config.WriteObject(_config);
        protected override void LoadDefaultConfig() => _config = new Configuration();

        private class Configuration
        {
            public bool ShowBackpack = true;
            public ulong ParachuteSkinId = 1901976770;

            public string ParachuteName = "Parachute";

            public string ParachuteShortname = "attire.hide.poncho";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();

                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }
        #endregion
        
        #region Language
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["InvalidPlayer"] = "Invalid player",
                ["ParachuteGiveTo"] = "Parachute given to {0}",
            }, this);
        }
        
        #endregion

        # region Hooks
        private void OnServerInitialized()
        {
            permission.RegisterPermission("parachute.admin", this);
            
            foreach (var p in players.Connected)
            {
                MonitorPlayerFall(p.Object as BasePlayer);
                WearSetupAndTimer(p.Object as BasePlayer);
            }
        }
        
        private void OnPlayerConnected(BasePlayer player)
        {
            MonitorPlayerFall(player);
            WearSetupAndTimer(player);
        }

        private void WearSetupAndTimer(BasePlayer player)
        {
            WearParachutePack(player);
        }
        
        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (info != null && info.HitEntity != null && info.HitEntity.ToPlayer() != null && info.HitEntity.ToPlayer().userID.IsSteamId())
            {
                if (info.damageTypes.Has(DamageType.Fall) && IsWearingParachute(info.HitEntity.ToPlayer()))
                {
                    return true;
                }
            }
            return null;
        }
        
        private void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            DoPackWearing(container.playerOwner, item);
        }
        
        private void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            DoPackWearing(container.playerOwner, item);
        }
        
        #endregion

        #region Functions

        private void MonitorPlayerFall(BasePlayer player)
        {
            if (Chute == null || !Chute.IsLoaded) return;
            
            if (_fallTimers.ContainsKey(player.UserIDString))
            {
                _fallTimers[player.UserIDString].Destroy();
            }
            
            var d = 0d;
            DateTime lastChute = default(DateTime);
            
            _fallTimers[player.UserIDString] = timer.Every(_fallTimer, () =>
            {
                
                if (d > 0 && !player.IsFlying && d - player.transform.position.y > _fallSpeed)
                {
                    
                    if (IsWearingParachute(player)
                        && !player.isMounted
                        && (default(DateTime) == lastChute || lastChute.AddSeconds(_coolDown) < DateTime.Now)
                        && !Chute.Call<bool>("ActiveChutePlayerList", player) 
                        && Chute.Call<bool>("IsAboveGround", player))
                    {
                        Chute.Call("ExternalAddPlayerChute", player, "");
                        lastChute = DateTime.Now;
                    }
                }
                d = player.transform.position.y;
            });
        }
        
        private bool IsWearingParachute(BasePlayer player)
        {
            foreach (var item in player.inventory.containerWear.itemList)
            {
                if (ItemIsParachute(item)) return true;
            }

            return false;
        }

        private bool ItemIsParachute(Item item)
        {
            if (item == null) return false;
            return item.info.shortname == _config.ParachuteShortname && item.skin == _config.ParachuteSkinId;
        }
        
        private void WearParachutePack(BasePlayer player)
        {
            if (!_config.ShowBackpack || !IsWearingParachute(player)) return;
            
            UnwearParachutePack(player);
            
            var parachute = GameManager.server.CreateEntity(_backpackPrefab, new Vector3(), new Quaternion(-3f, 0f, 3f, 1f), false) ;
            parachute.SetParent(player, "spine3");
            parachute?.Spawn();

        }
        
        private void UnwearParachutePack(BasePlayer player)
        {
            for (var x = player.children.Count-1; x >= 0;x--)
            {
                if (player.children[x].PrefabName == _backpackPrefab)
                {
                    player.children[x].parentBone = 0; 
                    player.children[x].Kill();
                }
            }
        }

        private bool? OnEntityKill(BaseNetworkable entity)
        {
            if (entity != null && entity.PrefabName != null && entity.PrefabName == _backpackPrefab)
            {
                var e = (entity as BaseEntity);
                if (e != null && e.parentBone > 0)
                {
                    return false;
                }
            }

            return null;
        }

        private void DoPackWearing(BasePlayer player, Item item)
        {
            if (!_config.ShowBackpack) return;
            if (!ItemIsParachute(item) || player == null || !player.userID.IsSteamId()) return;
            
            if (IsWearingParachute(player))
            {
                WearParachutePack(player);
            }
            else
            {
                UnwearParachutePack(player);
                if (player.isMounted && Chute != null && Chute.IsLoaded)
                {
                    player.GetMounted().Kill();
                    Chute.Call("RemovePlayerID", player);
                }

            }
        }
        
        private void GiveParachute(BasePlayer player)
        {

            var itemDefinition = ItemManager.FindItemDefinition(_config.ParachuteShortname);
            if (itemDefinition == null) return;
            var item = ItemManager.Create(itemDefinition, 1, _config.ParachuteSkinId);
            item.name = _config.ParachuteName;
            
            var wearAvailable = player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count;
            var beltAvailable = player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count;
            if (wearAvailable > 0)
            {
                item.MoveToContainer(player.inventory.containerWear);
                return;
            }
            if (beltAvailable > 0)
            {
                item.MoveToContainer(player.inventory.containerBelt);
                return;
            }
            player.inventory.GiveItem(item);
            
        }
        #endregion

        #region Commands
        [Command("parachute.give"), Permission("parachute.admin")]
        private void GivePackCommand(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player;
            if (args == null || args.Length == 0)
            {
                player = iplayer.Object as BasePlayer;
            }
            else
            {
                ulong playerid;
                if (UInt64.TryParse(args[0], out playerid)){
                    player = BasePlayer.FindByID(playerid);
                }
                else
                {
                    player = null;
                }
            }

            if (player == null)
            {
                iplayer.Reply(Lang("InvalidPlayer", iplayer.Id));
                return;
            }

            GiveParachute(player);

            iplayer.Reply(Lang("ParachuteGiveTo", iplayer.Id, player.displayName));

        }
        #endregion
    }
}

// --- End of file: Parachute.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/prevent-quarry-toggle ---
// --- Original File Path: P/PreventQuarryToggle/PreventQuarryToggle.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Prevent Quarry Toggle", "Rezx", "1.0.2")]
    [Description("This plugin prevents players that are not in a team with the owner from turning quarry/pumpjacks off")]
    internal class PreventQuarryToggle : CovalencePlugin
    {
        private static bool SameTeam(ulong playerId, ulong friendId)
        {
            if (!RelationshipManager.TeamsEnabled())
            {
                return false;
            }

            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerId);
            if (playerTeam == null)
            {
                return false;
            }

            var friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendId);
            if (friendTeam == null)
            {
                return false;
            }

            return playerTeam == friendTeam;
        }

        void OnQuarryToggled(MiningQuarry quarry, BasePlayer player)
        {
            if (quarry.OwnerID == 0)
            {
                // Ignore default quarry
                return;
            }

            if (quarry.OwnerID == player.userID)
            {
                // Player is the owner, allow the quarry to be toggled
            }
            else if (SameTeam(player.userID, quarry.OwnerID))
            {
                // Player is on the same team as the owner, allow the quarry to be toggled
            }
            else
            {
                // Turn the engine back on if it was turned off by an unauthorized player
                if (!quarry.IsEngineOn())
                {

                    if (!Config.Get<bool>("DisableChatMessage"))
                    {
                        var ownerName = covalence.Players.FindPlayerById(quarry.OwnerID.ToString())?.Name ?? quarry.OwnerID.ToString();
                        var unauthorizedMessage = string.Format(lang.GetMessage("UnauthorizedMessage", this), ownerName);
                        player.ChatMessage(unauthorizedMessage);
                    }

                    quarry.EngineSwitch(true);
                }

            }
        }

        


        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UnauthorizedMessage"] = "You are not authorized to toggle this, it is owned by {0}"
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            if (Config.Get("DisableChatMessage") == null)
            {
                Config["DisableChatMessage"] = false;
            }
            SaveConfig();
        }
    }
}


// --- End of file: PreventQuarryToggle.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-rankings ---
// --- Original File Path: P/PlayerRankings/PlayerRankings.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Player Rankings", "Ankawi", "3.0.3")]
    [Description("Gives players ranks based on playtime on a server")]
    class PlayerRankings : RustPlugin
    {
        [PluginReference]
        Plugin ConnectionDB, PlaytimeTracker, BetterChat;

        #region Plugin Related

        void OnServerInitialized()
        {
            if (!BetterChat)
                PrintWarning("Better Chat required in order to grant group titles; http://umod.org/plugins/better-chat/");

            SaveConfig();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                UpdateGroups(player);

            timer.Every(15f, () =>
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                    UpdateGroups(player);
            });

            foreach (var rank in Config)
            {
                if (rank.Key == "Settings")
                    continue;

                if (Config[rank.Key, "Oxide Group"] == null)
                {
                    PrintWarning(rank.Key + " does not have an Oxide Group specified");
                    continue;
                }

                if (!GroupExists(Config[rank.Key, "Oxide Group"].ToString()))
                    CreateGroup(Config[rank.Key, "Oxide Group"].ToString());
            }
        }

        #endregion

        #region Helpers

        bool IsUserInGroup(BasePlayer player, string group)
        {
            return permission.UserHasGroup(player.UserIDString, group);
        }

        void AddUserToGroup(BasePlayer player, string group) => permission.AddUserGroup(player.UserIDString, group);

        void RemoveUserFromGroup(BasePlayer player, string group) => permission.RemoveUserGroup(player.UserIDString, group);

        void CreateGroup(string group) => permission.CreateGroup(group, string.Empty, 0);

        bool GroupExists(string group) => permission.GroupExists(group);

        #endregion

        #region Configuration

        new void LoadConfig()
        {
            SetConfig("A", "Oxide Group", "Regular");
            SetConfig("A", "Playtime", 10D);

            SetConfig("B", "Oxide Group", "Pro");
            SetConfig("B", "Playtime", 25D);

            SetConfig("Settings", "Ignore Admins", false);

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            LoadConfig();
            PrintWarning("Creating a new configuration file...");
        }

        ////////////////////////////////////////
        ///  Config Setup - by LaserHydra
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);
            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        #endregion

        #region Commands

        [ChatCommand("ranks")]
        private void RanksCommand(BasePlayer player, string command, string[] args)
        {
            foreach (var rank in Config)
            {
                if (rank.Key == "Settings")
                    continue;
                PrintToChat(player, $"<color=#ff0000>Rank</color>: " + Convert.ToString(Config[rank.Key, "Oxide Group"]) + "\n<color=#00FF00>Playtime Required:</color> " + Convert.ToString(Config[rank.Key, "Playtime"]) + " hours");
            }
            PrintToChat(player, $"<color=#ff0000>Your Playtime</color>: " + Math.Round(GetPlayTime(player), 2) + " hours");
        }

        #endregion

        #region Subject Related

        void UpdateGroups(BasePlayer player)
        {
            if (player.net.connection.authLevel != 0 && (bool)Config["Settings", "Ignore Admins"]) return;

            double playTime = GetPlayTime(player);

            Dictionary<string, object> newRank = new Dictionary<string, object>{
                {"Oxide Group", ""},
                {"Playtime", 0.0},
                {"Name", "none"}
            };

            foreach (KeyValuePair<string, object> rank in Config)
            {
                if (rank.Key == "Settings")
                    continue;

                double time = Convert.ToDouble(Config[rank.Key, "Playtime"]);

                if (playTime >= time && time > Convert.ToDouble(newRank["Playtime"]))
                {
                    newRank = rank.Value as Dictionary<string, object>;
                    newRank["Name"] = rank.Key;
                }
            }

            if (!IsUserInGroup(player, (string)newRank["Oxide Group"]) && GroupExists((string)newRank["Oxide Group"]))
            {
                SendReply(player, $"<color=#ff0000>PlayerRankings</color>: You have been ranked up to {newRank["Oxide Group"] as string}");
                Puts($"{player.displayName} has been ranked up to {newRank["Oxide Group"] as string}");

                AddUserToGroup(player, (string)newRank["Oxide Group"]);

                RevokeLower(player, Convert.ToDouble(newRank["Playtime"]));
            }
        }

        void RevokeLower(BasePlayer player, double time)
        {
            foreach (var rank in Config)
            {
                if (rank.Key == "Settings")
                    continue;
                if (time > Convert.ToDouble(Config[rank.Key, "Playtime"]) && IsUserInGroup(player, (string)Config[rank.Key, "Oxide Group"]))
                    RemoveUserFromGroup(player, (string)Config[rank.Key, "Oxide Group"]);
            }
        }

        double GetPlayTime(BasePlayer player)
        {
            double playTime;
            if (PlaytimeTracker)
            {
                playTime = Convert.ToDouble(PlaytimeTracker.Call("GetPlayTime", player.UserIDString)) / 60 / 60;
                return playTime;
            }
            if (ConnectionDB)
            {
                playTime = ConnectionDB.Call<uint>("API_GetSecondsPlayed", player.userID) / 60 / 60;
                return playTime;
            }
            Puts("There is no plugin tracking the playtime for players");
            return 0f;
        }

        #endregion
    }
}

// --- End of file: PlayerRankings.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-administration ---
// --- Original File Path: P/PlayerAdministration/PlayerAdministration.cs ---

/* --- Contributor information ---
 * Please follow the following set of guidelines when working on this plugin,
 * this to help others understand this file more easily.
 *
 * NOTE: On Authors, new entries go BELOW the existing entries. As with any other software header comment.
 *
 * -- Authors --
 * Thimo (ThibmoRozier) <thibmorozier@live.nl> 2018-03-27 +
 * rfc1920 <no@email.com>
 * Mheetu <no@email.com>
 * Pho3niX90 <shan@jvn.sx> 2020-06 +
 *
 * -- Naming --
 * Avoid using non-alphabetic characters, eg: _
 * Avoid using numbers in method and class names (Upgrade methods are allowed to have these, for readability)
 * Private constants -------------------- SHOULD start with a uppercase "C" (PascalCase)
 * Private readonly fields -------------- SHOULD start with a uppercase "C" (PascalCase)
 * Private fields ----------------------- SHOULD start with a uppercase "F" (PascalCase)
 * Arguments/Parameters ----------------- SHOULD start with a lowercase "a" (camelCase)
 * Classes ------------------------------ SHOULD start with a uppercase character (PascalCase)
 * Methods ------------------------------ SHOULD start with a uppercase character (PascalCase)
 * Public properties (constants/fields) - SHOULD start with a uppercase character (PascalCase)
 * Variables ---------------------------- SHOULD start with a lowercase character (camelCase)
 *
 * -- Style --
 * Max-line-width ------- 160
 * Single-line comments - // Single-line comment
 * Multi-line comments -- Just like this comment block!
 */

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Game.Rust.Libraries;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using UnityEngine;
using RustLib = Oxide.Game.Rust.Libraries.Rust;

namespace Oxide.Plugins
{
    [Info("PlayerAdministration", "ThibmoRozier", "1.6.9")]
    [Description("Allows server admins to moderate users using a GUI from within the game.")]
    public class PlayerAdministration : CovalencePlugin
    {
        #region Plugin References
#pragma warning disable IDE0044, CS0649
        [PluginReference]
        private Plugin Economics;
        [PluginReference]
        private Plugin ServerRewards;
        [PluginReference]
        private Plugin Freeze;
        [PluginReference]
        private Plugin PermissionsManager;
        [PluginReference]
        private Plugin DiscordMessages;
        [PluginReference]
        private Plugin BetterChatMute;
        [PluginReference]
        private Plugin Backpacks;
        [PluginReference]
        private Plugin InventoryViewer;
        [PluginReference]
        private Plugin ServerArmour;
        [PluginReference]
        private Plugin Godmode;

#pragma warning restore IDE0044, CS0649
        #endregion Plugin References

        #region Library Imports
        private readonly RustLib rust = Interface.Oxide.GetLibrary<RustLib>();
        private readonly Player Player = Interface.Oxide.GetLibrary<Player>();
        #endregion Library Imports

        #region GUI
        #region Types
        /// <summary>
        /// UI Color object
        /// </summary>
        private class CuiColor
        {
            public byte R { get; set; }
            public byte G { get; set; }
            public byte B { get; set; }
            public float A { get; set; }

            public CuiColor(byte aRed = 255, byte aGreen = 255, byte aBlue = 255, float aAlpha = 1f) {
                R = aRed;
                G = aGreen;
                B = aBlue;
                A = aAlpha;
            }

            public override string ToString() => $"{(double)R / 255} {(double)G / 255} {(double)B / 255} {A}";

            public static readonly CuiColor Background = new CuiColor(240, 240, 240, 0.3f);
            public static readonly CuiColor BackgroundMedium = new CuiColor(76, 74, 72, 0.83f);
            public static readonly CuiColor BackgroundDark = new CuiColor(42, 42, 42, 0.93f);
            public static readonly CuiColor Button = new CuiColor(42, 42, 42, 1f);
            public static readonly CuiColor ButtonInactive = new CuiColor(168, 168, 168, 1f);
            public static readonly CuiColor ButtonDecline = new CuiColor(192, 0, 0, 1f);
            public static readonly CuiColor ButtonDanger = new CuiColor(193, 46, 42, 1f);
            public static readonly CuiColor ButtonWarning = new CuiColor(213, 133, 18, 1f);
            public static readonly CuiColor ButtonSuccess = new CuiColor(57, 132, 57, 1f);
            public static readonly CuiColor Text = new CuiColor(0, 0, 0, 1f);
            public static readonly CuiColor TextAlt = new CuiColor(255, 255, 255, 1f);
            public static readonly CuiColor TextTitle = new CuiColor(206, 66, 43, 1f);
            public static readonly CuiColor None = new CuiColor(0, 0, 0, 0f);
        }

        /// <summary>
        /// Element position object
        /// </summary>
        private class CuiPoint
        {
            public float X { get; set; }
            public float Y { get; set; }

            public CuiPoint(float aX = 0f, float aY = 0f) {
                X = aX;
                Y = aY;
            }

            public override string ToString() => $"{X} {Y}";

            public static readonly CuiPoint Zero = new CuiPoint();
        }

        /// <summary>
        /// UI pages to make the switching more humanly readable
        /// </summary>
        private enum UiPage
        {
            Main = 0,
            PlayersOnline,
            PlayersOffline,
            PlayersBanned,
            PlayerPage,
            PlayerPageBanned
        }
        #endregion Types

        #region UI object definitions
        /// <summary>
        /// Input field object
        /// </summary>
        private class CuiInputField
        {
            public CuiInputFieldComponent InputField { get; } = new CuiInputFieldComponent();
            public CuiRectTransformComponent RectTransform { get; } = new CuiRectTransformComponent();
            public float FadeOut { get; set; }
        }
        #endregion UI object definitions

        #region Component container
        /// <summary>
        /// Custom version of the CuiElementContainer to add InputFields
        /// </summary>
        private class CustomCuiElementContainer : CuiElementContainer
        {
            private readonly Action<string> LogError;

            /// <summary>
            /// Constructor
            /// </summary>
            /// <param name="aLogErrorFunc">Error logging procedure</param>
            /// <returns></returns>
            public CustomCuiElementContainer(Action<string> aLogErrorFunc) : base() {
                LogError = aLogErrorFunc;
            }

            public string Add(CuiInputField aInputField, string aParent = Cui.ParentHud, string aName = "") {
                if (string.IsNullOrEmpty(aName))
                    aName = CuiHelper.GetGuid();

                if (aInputField == null) {
                    LogError($"CustomCuiElementContainer::Add > Parameter 'aInputField' is null");
                    return string.Empty;
                }

                Add(new CuiElement {
                    Name = aName,
                    Parent = aParent,
                    FadeOut = aInputField.FadeOut,
                    Components = {
                        aInputField.InputField,
                        aInputField.RectTransform
                    }
                });
                return aName;
            }
        }
        #endregion Component container

        /// <summary>
        /// Rust UI object
        /// </summary>
        private class Cui
        {
            public const string ParentHud = "Hud";
            public const string ParentOverlay = "Overlay";

            private readonly Action<string> LogDebug;
            private readonly Action<string> LogError;
            private readonly CustomCuiElementContainer FContainer;
            private readonly BasePlayer FPlayer;
            public readonly ulong PlayerId;
            public readonly string PlayerIdString;
            public readonly float StartTime = Time.realtimeSinceStartup;

            /// <summary>
            /// Constructor
            /// </summary>
            /// <param name="aPlayer">The player this object is meant for</param>
            /// <param name="aLogDebugFunc">Debug logging procedure</param>
            /// <param name="aLogInfoFunc">Info logging procedure</param>
            /// <param name="aLogErrorFunc">Error logging procedure</param>
            /// <returns></returns>
            public Cui(BasePlayer aPlayer, Action<string> aLogDebugFunc, Action<string> aLogErrorFunc) {
                LogDebug = aLogDebugFunc;
                LogError = aLogErrorFunc;

                if (aPlayer == null) {
                    LogError("Cui::Cui > Parameter 'aPlayer' is null");
                    return;
                }

                FContainer = new CustomCuiElementContainer(aLogErrorFunc);
                FPlayer = aPlayer;
                PlayerId = aPlayer.userID;
                PlayerIdString = aPlayer.UserIDString;
                LogDebug("Cui instance created");
            }

            /// <summary>
            /// Add a new panel
            /// </summary>
            /// <param name="aParent">The parent object name</param>
            /// <param name="aLeftBottomAnchor">Left(x)-Bottom(y) relative position</param>
            /// <param name="aRightTopAnchor">Right(x)-Top(y) relative position</param>
            /// <param name="aIndCursorEnabled">The panel requires the cursor</param>
            /// <param name="aColor">Image color</param>
            /// <param name="aName">The object's name</param>
            /// <param name="aPng">Image PNG file path</param>
            /// <returns>New object name</returns>
            public string AddPanel(
                string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, bool aIndCursorEnabled, CuiColor aColor = null, string aName = "",
                string aPng = ""
            ) => AddPanel(aParent, aLeftBottomAnchor, aRightTopAnchor, CuiPoint.Zero, CuiPoint.Zero, aIndCursorEnabled, aColor, aName, aPng);

            /// <summary>
            /// Add a new panel
            /// </summary>
            /// <param name="aParent">The parent object name</param>
            /// <param name="aLeftBottomAnchor">Left(x)-Bottom(y) relative position</param>
            /// <param name="aRightTopAnchor">Right(x)-Top(y) relative position</param>
            /// <param name="aLeftBottomOffset">Left(x)-Bottom(y) relative offset</param>
            /// <param name="aRightTopOffset">Right(x)-Top(y) relative offset</param>
            /// <param name="aIndCursorEnabled">The panel requires the cursor</param>
            /// <param name="aColor">Image color</param>
            /// <param name="aName">The object's name</param>
            /// <param name="aPng">Image PNG file path</param>
            /// <returns>New object name</returns>
            public string AddPanel(
                string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiPoint aLeftBottomOffset, CuiPoint aRightTopOffset,
                bool aIndCursorEnabled, CuiColor aColor = null, string aName = "", string aPng = ""
            ) {
                if (aLeftBottomAnchor == null || aRightTopAnchor == null || aLeftBottomOffset == null || aRightTopOffset == null) {
                    LogError($"Cui::AddPanel > One of the required parameters is null");
                    return string.Empty;
                }

                CuiPanel panel = new CuiPanel {
                    RectTransform =
                    {
                        AnchorMin = aLeftBottomAnchor.ToString(),
                        AnchorMax = aRightTopAnchor.ToString(),
                        OffsetMin = aLeftBottomOffset.ToString(),
                        OffsetMax = aRightTopOffset.ToString()
                    },
                    CursorEnabled = aIndCursorEnabled
                };

                if (!string.IsNullOrEmpty(aPng))
                    panel.Image = new CuiImageComponent { Png = aPng };

                if (aColor != null) {
                    if (panel.Image == null) {
                        panel.Image = new CuiImageComponent { Color = aColor.ToString() };
                    } else {
                        panel.Image.Color = aColor.ToString();
                    }
                }

                LogDebug("Added panel to container");
                return FContainer.Add(panel, aParent, string.IsNullOrEmpty(aName) ? null : aName);
            }

            /// <summary>
            /// Add a new label
            /// </summary>
            /// <param name="aParent">The parent object name</param>
            /// <param name="aLeftBottomAnchor">Left(x)-Bottom(y) relative position</param>
            /// <param name="aRightTopAnchor">Right(x)-Top(y) relative position</param>
            /// <param name="aColor">Text color</param>
            /// <param name="aText">Text to show</param>
            /// <param name="aName">The object's name</param>
            /// <param name="aFontSize">Font size</param>
            /// <param name="aAlign">Text alignment</param>
            /// <returns>New object name</returns>
            public string AddLabel(
                string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiColor aColor, string aText, string aName = "", int aFontSize = 14,
                TextAnchor aAlign = TextAnchor.UpperLeft
            ) => AddLabel(aParent, aLeftBottomAnchor, aRightTopAnchor, CuiPoint.Zero, CuiPoint.Zero, aColor, aText, aName, aFontSize, aAlign);

            /// <summary>
            /// Add a new label
            /// </summary>
            /// <param name="aParent">The parent object name</param>
            /// <param name="aLeftBottomAnchor">Left(x)-Bottom(y) relative position</param>
            /// <param name="aRightTopAnchor">Right(x)-Top(y) relative position</param>
            /// <param name="aLeftBottomOffset">Left(x)-Bottom(y) relative offset</param>
            /// <param name="aRightTopOffset">Right(x)-Top(y) relative offset</param>
            /// <param name="aColor">Text color</param>
            /// <param name="aText">Text to show</param>
            /// <param name="aName">The object's name</param>
            /// <param name="aFontSize">Font size</param>
            /// <param name="aAlign">Text alignment</param>
            /// <returns>New object name</returns>
            public string AddLabel(
                string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiPoint aLeftBottomOffset, CuiPoint aRightTopOffset, CuiColor aColor,
                string aText, string aName = "", int aFontSize = 14, TextAnchor aAlign = TextAnchor.UpperLeft
            ) {
                if (aLeftBottomAnchor == null || aRightTopAnchor == null || aLeftBottomOffset == null || aRightTopOffset == null || aColor == null) {
                    LogError($"Cui::AddLabel > One of the required parameters is null");
                    return string.Empty;
                }

                LogDebug("Added label to container");
                return FContainer.Add(
                    new CuiLabel {
                        Text =
                        {
                            Text = aText ?? string.Empty,
                            FontSize = aFontSize,
                            Align = aAlign,
                            Color = aColor.ToString()
                        },
                        RectTransform =
                        {
                            AnchorMin = aLeftBottomAnchor.ToString(),
                            AnchorMax = aRightTopAnchor.ToString(),
                            OffsetMin = aLeftBottomOffset.ToString(),
                            OffsetMax = aRightTopOffset.ToString()
                        }
                    },
                    aParent,
                    string.IsNullOrEmpty(aName) ? null : aName
                );
            }

            /// <summary>
            /// Add a new button
            /// </summary>
            /// <param name="aParent">The parent object name</param>
            /// <param name="aLeftBottomAnchor">Left(x)-Bottom(y) relative position</param>
            /// <param name="aRightTopAnchor">Right(x)-Top(y) relative position</param>
            /// <param name="aButtonColor">Button background color</param>
            /// <param name="aTextColor">Text color</param>
            /// <param name="aText">Text to show</param>
            /// <param name="aCommand">OnClick event callback command</param>
            /// <param name="aClose">Panel to close</param>
            /// <param name="aName">The object's name</param>
            /// <param name="aFontSize">Font size</param>
            /// <param name="aAlign">Text alignment</param>
            /// <returns>New object name</returns>
            public string AddButton(
                string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiColor aButtonColor, CuiColor aTextColor, string aText,
                string aCommand = "", string aClose = "", string aName = "", int aFontSize = 14, TextAnchor aAlign = TextAnchor.MiddleCenter
            ) => AddButton(
                    aParent, aLeftBottomAnchor, aRightTopAnchor, CuiPoint.Zero, CuiPoint.Zero, aButtonColor, aTextColor, aText, aCommand, aClose, aName,
                    aFontSize, aAlign
                );

            /// <summary>
            /// Add a new button
            /// </summary>
            /// <param name="aParent">The parent object name</param>
            /// <param name="aLeftBottomAnchor">Left(x)-Bottom(y) relative position</param>
            /// <param name="aRightTopAnchor">Right(x)-Top(y) relative position</param>
            /// <param name="aLeftBottomOffset">Left(x)-Bottom(y) relative offset</param>
            /// <param name="aRightTopOffset">Right(x)-Top(y) relative offset</param>
            /// <param name="aButtonColor">Button background color</param>
            /// <param name="aTextColor">Text color</param>
            /// <param name="aText">Text to show</param>
            /// <param name="aCommand">OnClick event callback command</param>
            /// <param name="aClose">Panel to close</param>
            /// <param name="aName">The object's name</param>
            /// <param name="aFontSize">Font size</param>
            /// <param name="aAlign">Text alignment</param>
            /// <returns>New object name</returns>
            public string AddButton(
                string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiPoint aLeftBottomOffset, CuiPoint aRightTopOffset,
                CuiColor aButtonColor, CuiColor aTextColor, string aText, string aCommand = "", string aClose = "", string aName = "", int aFontSize = 14,
                TextAnchor aAlign = TextAnchor.MiddleCenter
            ) {
                if (
                    aLeftBottomAnchor == null || aRightTopAnchor == null || aLeftBottomOffset == null || aRightTopOffset == null || aButtonColor == null ||
                    aTextColor == null
                ) {
                    LogError($"Cui::AddButton > One of the required parameters is null");
                    return string.Empty;
                }

                LogDebug("Added button to container");
                return FContainer.Add(
                    new CuiButton {
                        Button =
                        {
                            Command = aCommand ?? string.Empty,
                            Close = aClose ?? string.Empty,
                            Color = aButtonColor.ToString()
                        },
                        RectTransform =
                        {
                            AnchorMin = aLeftBottomAnchor.ToString(),
                            AnchorMax = aRightTopAnchor.ToString(),
                            OffsetMin = aLeftBottomOffset.ToString(),
                            OffsetMax = aRightTopOffset.ToString()
                        },
                        Text =
                        {
                            Text = aText ?? string.Empty,
                            FontSize = aFontSize,
                            Align = aAlign,
                            Color = aTextColor.ToString()
                        }
                    },
                    aParent,
                    string.IsNullOrEmpty(aName) ? null : aName
                );
            }

            /// <summary>
            /// Add a new input field
            /// </summary>
            /// <param name="aParent">The parent object name</param>
            /// <param name="aLeftBottomAnchor">Left(x)-Bottom(y) relative position</param>
            /// <param name="aRightTopAnchor">Right(x)-Top(y) relative position</param>
            /// <param name="aColor">Text color</param>
            /// <param name="aText">Text to show</param>
            /// <param name="aCharsLimit">Max character count</param>
            /// <param name="aCommand">OnChanged event callback command</param>
            /// <param name="aIndPassword">Indicates that this input should show password chars</param>
            /// <param name="aName">The object's name</param>
            /// <param name="aFontSize">Font size</param>
            /// <param name="aAlign">Text alignment</param>
            /// <returns>New object name</returns>
            public string AddInputField(
                string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiColor aColor, string aText = "", int aCharsLimit = 100,
                string aCommand = "", bool aIndPassword = false, string aName = "", int aFontSize = 14, TextAnchor aAlign = TextAnchor.MiddleLeft
            ) => AddInputField(
                    aParent, aLeftBottomAnchor, aRightTopAnchor, CuiPoint.Zero, CuiPoint.Zero, aColor, aText, aCharsLimit, aCommand, aIndPassword, aName,
                    aFontSize, aAlign
                );

            /// <summary>
            /// Add a new input field
            /// </summary>
            /// <param name="aParent">The parent object name</param>
            /// <param name="aLeftBottomAnchor">Left(x)-Bottom(y) relative position</param>
            /// <param name="aRightTopAnchor">Right(x)-Top(y) relative position</param>
            /// <param name="aLeftBottomOffset">Left(x)-Bottom(y) relative offset</param>
            /// <param name="aRightTopOffset">Right(x)-Top(y) relative offset</param>
            /// <param name="fadeOut">Fade-out time</param>
            /// <param name="aColor">Text color</param>
            /// <param name="aText">Text to show</param>
            /// <param name="aCharsLimit">Max character count</param>
            /// <param name="aCommand">OnChanged event callback command</param>
            /// <param name="aIndPassword">Indicates that this input should show password chars</param>
            /// <param name="aName">The object's name</param>
            /// <param name="aFontSize">Font size</param>
            /// <returns>New object name</returns>
            public string AddInputField(
                string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiPoint aLeftBottomOffset, CuiPoint aRightTopOffset, CuiColor aColor,
                string aText = "", int aCharsLimit = 100, string aCommand = "", bool aIndPassword = false, string aName = "", int aFontSize = 14,
                TextAnchor aAlign = TextAnchor.MiddleLeft
            ) {
                if (aLeftBottomAnchor == null || aRightTopAnchor == null || aLeftBottomOffset == null || aRightTopOffset == null || aColor == null) {
                    LogError($"Cui::AddInputField > One of the required parameters is null");
                    return string.Empty;
                }

                LogDebug("Added input field to container");
                return FContainer.Add(
                    new CuiInputField {
                        InputField =
                        {
                            Text = aText ?? string.Empty,
                            FontSize = aFontSize,
                            Align = aAlign,
                            Color = aColor.ToString(),
                            CharsLimit = aCharsLimit,
                            Command = aCommand ?? string.Empty,
                            IsPassword = aIndPassword
                        },
                        RectTransform =
                        {
                            AnchorMin = aLeftBottomAnchor.ToString(),
                            AnchorMax = aRightTopAnchor.ToString(),
                            OffsetMin = aLeftBottomOffset.ToString(),
                            OffsetMax = aRightTopOffset.ToString()
                        }
                    },
                    aParent,
                    string.IsNullOrEmpty(aName) ? null : aName
                );
            }

            /// <summary>
            /// Add a new element
            /// </summary>
            /// <param name="aParent">The parent object name</param>
            /// <param name="aElement">The object itself</param>
            /// <param name="aName">The object's name</param>
            /// <returns>New object name</returns>
            public string AddElement(string aParent, CuiPanel aElement, string aName = "") =>
                FContainer.Add(aElement, aParent, string.IsNullOrEmpty(aName) ? null : aName);

            /// <summary>
            /// Add a new element
            /// </summary>
            /// <param name="aParent">The parent object name</param>
            /// <param name="aElement">The object itself</param>
            /// <param name="aName">The object's name</param>
            /// <returns>New object name</returns>
            public string AddElement(string aParent, CuiLabel aElement, string aName = "") =>
                FContainer.Add(aElement, aParent, string.IsNullOrEmpty(aName) ? null : aName);

            /// <summary>
            /// Add a new element
            /// </summary>
            /// <param name="aParent">The parent object name</param>
            /// <param name="aElement">The object itself</param>
            /// <param name="aName">The object's name</param>
            /// <returns>New object name</returns>
            public string AddElement(string aParent, CuiButton aElement, string aName = "") =>
                FContainer.Add(aElement, aParent, string.IsNullOrEmpty(aName) ? null : aName);

            /// <summary>
            /// Add a new element
            /// </summary>
            /// <param name="aParent">The parent object name</param>
            /// <param name="aElement">The object itself</param>
            /// <param name="aName">The object's name</param>
            /// <returns>New object name</returns>
            public string AddElement(string aParent, CuiInputField aElement, string aName = "") =>
                FContainer.Add(aElement, aParent, string.IsNullOrEmpty(aName) ? null : aName);

            /// <summary>
            /// Draw the UI to the player's client
            /// </summary>
            /// <returns></returns>
            public bool Draw() => CuiHelper.AddUi(FPlayer, CuiHelper.ToJson(FContainer));

            public string JSON {
                get { return CuiHelper.ToJson(FContainer, true); }
            }
        }
        #endregion GUI

        #region Utility methods
        /// <summary>
        /// Add a button to the tab menu
        /// </summary>
        /// <param name="aUIObj">Cui object</param>
        /// <param name="aParent">Name of the parent object</param>
        /// <param name="aCaption">Text to show</param>
        /// <param name="aCommand">Button to execute</param>
        /// <param name="aPos">Bounds of the button</param>
        /// <param name="aIndActive">To indicate whether or not the button is active</param>
        private void AddTabMenuBtn(ref Cui aUIObj, string aParent, string aCaption, string aCommand, int aPos, bool aIndActive) {
            Vector2 dimensions = new Vector2(0.096f, 0.75f);
            Vector2 offset = new Vector2(0.005f, 0.1f);
            CuiColor btnColor = (aIndActive ? CuiColor.ButtonInactive : CuiColor.Button);
            CuiPoint lbAnchor = new CuiPoint(((dimensions.x + offset.x) * aPos) + offset.x, offset.y);
            CuiPoint rtAnchor = new CuiPoint(lbAnchor.X + dimensions.x, offset.y + dimensions.y);
            aUIObj.AddButton(aParent, lbAnchor, rtAnchor, btnColor, CuiColor.TextAlt, aCaption, (aIndActive ? string.Empty : aCommand));
        }

        /// <summary>
        /// Add a set of user buttons to the parent object
        /// </summary>
        /// <param name="aUIObj">Cui object</param>
        /// <param name="aParent">Name of the parent object</param>
        /// <param name="aUserList">List of entities</param>
        /// <param name="aCommandFmt">Base format of the command to execute (Will be completed with the user ID</param>
        /// <param name="aPage">User list page</param>
        private void AddPlayerButtons(ref Cui aUIObj, string aParent, ref IEnumerable<KeyValuePair<ulong, string>> aUserList, string aCommandFmt, int aPage) {
            IEnumerable<KeyValuePair<ulong, string>> userRange = aUserList.Skip(aPage * CMaxPlayerButtons).Take(CMaxPlayerButtons);
            Vector2 dimensions = new Vector2(0.194f, 0.06f);
            Vector2 offset = new Vector2(0.005f, 0.01f);
            int col = -1;
            int row = 0;
            float margin = 0.09f;
            List<string> addedNames = new List<string>();

            foreach (KeyValuePair<ulong, string> user in userRange) {
                if (++col >= CMaxPlayerCols) {
                    row++;
                    col = 0;
                }

                float calcTop = (1f - margin) - (((dimensions.y + offset.y) * row) + offset.y);
                float calcLeft = ((dimensions.x + offset.x) * col) + offset.x;
                CuiPoint lbAnchor = new CuiPoint(calcLeft, calcTop - dimensions.y);
                CuiPoint rtAnchor = new CuiPoint(calcLeft + dimensions.x, calcTop);
                int suffix = 0;

                string btnTextTemp = EscapeString(user.Value ?? string.Empty);
                string btnCommand = string.Format(aCommandFmt, user.Key);

                if (string.IsNullOrEmpty(btnTextTemp) || CUnknownNameList.Contains(btnTextTemp.ToLower()))
                    btnTextTemp = user.Key.ToString();

                string btnText = btnTextTemp;

                while (addedNames.FindIndex(item => btnText.Equals(item, StringComparison.OrdinalIgnoreCase)) >= 0) {
                    btnText = $"{btnTextTemp} {++suffix}";
                }

                aUIObj.AddButton(aParent, lbAnchor, rtAnchor, CuiColor.Button, CuiColor.TextAlt, btnText, btnCommand, string.Empty, string.Empty, 16);
                addedNames.Add(btnText);
            }

            LogDebug("Added the player buttons to the container");
        }

        /// <summary>
        /// Log an error message to the logfile
        /// </summary>
        /// <param name="aMessage"></param>
        private void LogError(string aMessage) => LogToFile(string.Empty, $"[{DateTime.Now:hh:mm:ss}] ERROR > {aMessage}", this);

        /// <summary>
        /// Log an informational message to the logfile
        /// </summary>
        /// <param name="aMessage"></param>
        private void LogInfo(string aMessage) => LogToFile(string.Empty, $"[{DateTime.Now:hh:mm:ss}] INFO > {aMessage}", this);

        /// <summary>
        /// Log a debugging message to the logfile
        /// </summary>
        /// <param name="aMessage"></param>
        private void LogDebug(string aMessage) {
#pragma warning disable CS0162
            if (CDebugEnabled)
                LogToFile(string.Empty, $"[{DateTime.Now:hh:mm:ss}] DEBUG > {aMessage}", this);
#pragma warning restore CS0162
        }

        /// <summary>
        /// Verify if a user has the specified permission
        /// </summary>
        /// <param name="aPlayer">The player</param>
        /// <param name="aPermission">Pass <see cref="string.Empty"/> to only verify <see cref="CPermUiShow"/></param>
        /// <param name="aIndReport">Indicates that issues should be reported</param>
        /// <returns></returns>
        private bool VerifyPermission(ref BasePlayer aPlayer, string aPermission, bool aIndReport = false) {
            bool result = permission.UserHasPermission(aPlayer.UserIDString, CPermUiShow);
            aPermission = aPermission ?? string.Empty; // We need to get rid of possible null values

            if (FConfigData.UsePermSystem && result && aPermission.Length > 0)
                result = permission.UserHasPermission(aPlayer.UserIDString, aPermission);

            if (aIndReport && !result) {
                rust.SendChatMessage(aPlayer, string.Empty, lang.GetMessage("Permission Error Text", this, aPlayer.UserIDString));
                LogError(string.Format(lang.GetMessage("Permission Error Log Text", this, aPlayer.UserIDString), aPlayer.displayName, aPermission));
            }

            return result;
        }

        /// <summary>
        /// Verify if a user has the specified permission
        /// Note that base-type comparison is WAY faster then String comparison
        /// </summary>
        /// <param name="aPlayerId">The player's ID</param>
        /// <param name="aPermission">Pass <see cref="string.Empty"/> to only verify <see cref="CPermUiShow"/></param>
        /// <returns></returns>
        private bool VerifyPermission(ulong aPlayerId, string aPermission) {
            BasePlayer player = BasePlayer.FindByID(aPlayerId);
            return VerifyPermission(ref player, aPermission);
        }

        /// <summary>
        /// Retrieve server users
        /// </summary>
        /// <param name="aIndFiltered">Indicates if the output should be filtered</param>
        /// <param name="aUserId">User ID for retrieving filter text</param>
        /// <param name="aIndOffline">Retrieve the list of sleepers (offline players)</param>
        /// <returns></returns>
        private IEnumerable<KeyValuePair<ulong, string>> GetServerUserList(bool aIndFiltered, ulong aUserId, bool aIndOffline = false) {
            IEnumerable<KeyValuePair<ulong, string>> result = (aIndOffline ? FOfflineUserList : FOnlineUserList).AsEnumerable();

            if (aIndFiltered && FUserBtnPageSearchInputText.ContainsKey(aUserId))
                result = result.Where(x =>
                        x.Value.IndexOf(FUserBtnPageSearchInputText[aUserId], StringComparison.OrdinalIgnoreCase) >= 0 ||
                        x.Key.ToString().IndexOf(FUserBtnPageSearchInputText[aUserId], StringComparison.OrdinalIgnoreCase) >= 0
                    );

            LogDebug("Retrieved the server user list");
            return result.OrderBy(x => x.Value).ThenBy(x => x.Key);
        }

        /// <summary>
        /// Retrieve server users
        /// </summary>
        /// <param name="aIndFiltered">Indicates if the output should be filtered</param>
        /// <param name="aUserId">User ID for retrieving filter text</param>
        /// <returns></returns>
        private IEnumerable<KeyValuePair<ulong, string>> GetBannedUserList(bool aIndFiltered, ulong aUserId) {
            IEnumerable<KeyValuePair<ulong, string>> result = ServerUsers.GetAll(ServerUsers.UserGroup.Banned).Select(
                x => new KeyValuePair<ulong, string>(x.steamid, x.username)
            );

            if (aIndFiltered && FUserBtnPageSearchInputText.ContainsKey(aUserId))
                result = result.Where(x =>
                        x.Value.IndexOf(FUserBtnPageSearchInputText[aUserId], StringComparison.OrdinalIgnoreCase) >= 0 ||
                        x.Key.ToString().IndexOf(FUserBtnPageSearchInputText[aUserId], StringComparison.OrdinalIgnoreCase) >= 0
                    ).ToList();

            LogDebug("Retrieved the banned user list");
            return result.OrderBy(x => x.Value).ThenBy(x => x.Key);
        }

        /// <summary>
        /// Retrieve the target player ID from the arguments and report success
        /// </summary>
        /// <param name="aArg">Argument object</param>
        /// <param name="aTarget">Player ID</param>
        /// <returns></returns>
        private bool GetTargetFromArg(string[] aArgs, out ulong aTarget) {
            aTarget = 0;
            return aArgs.Length > 0 && ulong.TryParse(aArgs[0], out aTarget);
        }

        /// <summary>
        /// Retrieve the target player ID and amount from the arguments and report success
        /// </summary>
        /// <param name="aArg">Argument object</param>
        /// <param name="aTarget">Player ID</param>
        /// <param name="aAmount">Amount</param>
        /// <returns></returns>
        private bool GetTargetAmountFromArg(string[] aArgs, out ulong aTarget, out float aAmount) {
            aTarget = 0;
            aAmount = 0;
            return aArgs.Length >= 2 && ulong.TryParse(aArgs[0], out aTarget) && float.TryParse(aArgs[1], out aAmount);
        }

        /// <summary>
        /// Check if the player has the ChatMute flag set
        /// </summary>
        /// <param name="aPlayer">The player</param>
        /// <returns></returns>
        private bool GetIsMuted(ref BasePlayer aPlayer) {
            bool isServerMuted = aPlayer.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute);

            if (BetterChatMute != null) {
                return isServerMuted || (bool)BetterChatMute.Call("API_IsMuted", aPlayer.IPlayer);
            } else {
                return isServerMuted;
            }
        }

        /// <summary>
        /// Check if the player has the freeze.frozen permission
        /// </summary>
        /// <param name="aPlayerId">The player's ID</param>
        /// <returns></returns>
        private bool GetIsFrozen(ulong aPlayerId) => permission.UserHasPermission(aPlayerId.ToString(), CPermFreezeFrozen);

        /// <summary>
        /// Send either a kick or a ban message to Discord via the DiscordMessages plugin
        /// </summary>
        /// <param name="aAdminName">The name of the admin</param>
        /// <param name="aAdminId">The ID of the admin</param>
        /// <param name="aTargetName">The name of the target player</param>
        /// <param name="aTargetId">The ID of the target player</param>
        /// <param name="aReason">The reason message</param>
        /// <param name="aIndIsBan">If this is true a ban message is sent, else a kick message is sent</param>
        private void SendDiscordKickBanMessage(string aAdminName, ulong aAdminId, string aTargetName, ulong aTargetId, string aReason, bool aIndIsBan) {
            if (DiscordMessages != null) {
                if (CUnknownNameList.Contains(aTargetName.ToLower()))
                    aTargetName = aTargetId.ToString();

                object fields = new[]
                {
                    new {
                        name = "Player",
                        value = $"[{aTargetName}](https://steamcommunity.com/profiles/{aTargetId})",
                        inline = true
                    },
                    new {
                        name = aIndIsBan ? "Banned by" : "Kicked by",
                        value = $"[{aAdminName}](https://steamcommunity.com/profiles/{aAdminId})",
                        inline = true
                    },
                    new {
                        name = "Reason",
                        value = aReason,
                        inline = false
                    }
                };
                DiscordMessages.Call(
                    "API_SendFancyMessage",
                    aIndIsBan ? FConfigData.BanMsgWebhookUrl : FConfigData.KickMsgWebhookUrl,
                    aIndIsBan ? "Player Ban" : "Player Kick",
                    3329330,
                    JsonConvert.SerializeObject(fields)
                );
            }
        }

        /// <summary>
        /// Transform a string array into a printable string.
        /// </summary>
        /// <param name="aObj"></param>
        /// <returns></returns>
        private string StringArrToString(ref string[] aObj) => $"[ {string.Join(", ", aObj)} ]";

        /// <summary>
        /// Transform a dictionary of strings into a printable string.
        /// </summary>
        /// <param name="aObj"></param>
        /// <returns></returns>
        private string StringDictToString(ref Dictionary<string, string> aObj) {
            StringBuilder result = new StringBuilder("{\n");

            foreach (KeyValuePair<string, string> item in aObj)
                result.Append($"'{item.Key}': '{item.Value}'\n");

            result.Append('}');
            return result.ToString();
        }

        /// <summary>
        /// Escape strings to make them usable in the UI.
        /// </summary>
        /// <param name="aStr"></param>
        /// <returns></returns>
        private string EscapeString(string aStr) => aStr.Replace("\0", string.Empty)
            .Replace("\a", string.Empty)
            .Replace("\b", string.Empty)
            .Replace("\f", string.Empty)
            .Replace("\r", string.Empty)
            .Replace('\n', ' ')
            .Replace('\t', ' ')
            .Replace("\v", string.Empty)
            .Replace('"', '\u02EE')
            .Replace('/', '\u2215')
            .Replace('\\', '\u2216');

        /// <summary>
        /// Gets the reason from the input box on the players screen.
        /// </summary>
        /// <param name="playerId">The player ID that entered the reason.</param>
        /// <param name="targetId">The target ID the reason is for.</param>
        /// <returns></returns>
        private string GetReason(ulong playerId, string targetId = "", bool indIsKick = false) {
            string reasonMsg;

            if (FUserPageReasonInputText.ContainsKey(playerId)) {
                reasonMsg = FUserPageReasonInputText[playerId].Trim();

                if (string.IsNullOrEmpty(reasonMsg))
                    reasonMsg = lang.GetMessage(indIsKick ? "Kick Reason Message Text" : "Ban Reason Message Text", this, targetId);
            } else {
                reasonMsg = lang.GetMessage(indIsKick ? "Kick Reason Message Text" : "Ban Reason Message Text", this, targetId);
            }

            return reasonMsg;
        }

        private void BroadcastKickBan(string aAdminId, ulong aTargetId, string aReason, bool aIndIsKick) {
            string broadcastMessage = aIndIsKick
                ? lang.GetMessage("Kick Broadcast Message Format", this, aAdminId)
                : lang.GetMessage("Ban Broadcast Message Format", this, aAdminId);
            string targetName = ServerUsers.Get(aTargetId)?.username;

            if (string.IsNullOrEmpty(targetName) || CUnknownNameList.Contains(targetName.ToLower()))
                targetName = aTargetId.ToString();

            rust.BroadcastChat(string.Empty, String.Format(broadcastMessage, targetName, aReason));
        }
        #endregion Utility methods

        #region Upgrade methods
        /// <summary>
        /// Upgrade the config to 1.3.10 if needed
        /// </summary>
        /// <returns></returns>
        private bool UpgradeTo1310() {
            bool result = false;
            Config.Load();

            if (Config["Use Permission System"] == null) {
                FConfigData.UsePermSystem = true;
                result = true;
            }

            // Remove legacy config items
            if (
                Config["Enable kick action"] != null || Config["Enable ban action"] != null || Config["Enable unban action"] != null ||
                Config["Enable kill action"] != null || Config["Enable inventory clear action"] != null || Config["Enable blueprint reset action"] != null ||
                Config["Enable metabolism reset action"] != null || Config["Enable hurt action"] != null || Config["Enable heal action"] != null ||
                Config["Enable mute action"] != null || Config["Enable perms action"] != null || Config["Enable freeze action"] != null
            )
                result = true;

            Config.Clear();

            if (result)
                Config.WriteObject(FConfigData);

            return result;
        }

        /// <summary>
        /// Upgrade the config to 1.3.13 if needed
        /// </summary>
        /// <returns></returns>
        private bool UpgradeTo1313() {
            bool result = false;
            Config.Load();

            if (Config["Discord Webhook url for ban messages"] == null) {
                FConfigData.BanMsgWebhookUrl = string.Empty;
                result = true;
            }

            if (Config["Discord Webhook url for kick messages"] == null) {
                FConfigData.KickMsgWebhookUrl = string.Empty;
                result = true;
            }

            Config.Clear();

            if (result)
                Config.WriteObject(FConfigData);

            return result;
        }

        /// <summary>
        /// Upgrade the config to 1.5.6 if needed
        /// </summary>
        /// <returns></returns>
        private bool UpgradeTo156() {
            bool result = false;
            Dictionary<string, string> oldPerms = new Dictionary<string, string>() {
                { "playeradministration.show", CPermUiShow },
                { "playeradministration.kick", CPermKick },
                { "playeradministration.ban", CPermBan },
                { "playeradministration.kill", CPermKill },
                { "playeradministration.perms", CPermPerms },
                { "playeradministration.voicemute", CPermMute },
                { "playeradministration.chatmute", CPermMute },
                { "playeradministration.freeze", CPermFreeze },
                { "playeradministration.clearinventory", CPermClearInventory },
                { "playeradministration.resetblueprint", CPermResetBP },
                { "playeradministration.resetmetabolism", CPermResetMetabolism },
                { "playeradministration.recovermetabolism", CPermRecoverMetabolism },
                { "playeradministration.hurt", CPermHurt },
                { "playeradministration.heal", CPermHeal },
                { "playeradministration.teleport", CPermTeleport },
                { "playeradministration.spectate", CPermSpectate }
            };
            LogDebug($"Old Perms: {StringDictToString(ref oldPerms)}");

            foreach (KeyValuePair<string, string> item in oldPerms) {
                string[] groups = permission.GetPermissionGroups(item.Key);
                LogDebug($"Groups: {StringArrToString(ref groups)}");
                string[] users = permission.GetPermissionUsers(item.Key);
                LogDebug($"Users: {StringArrToString(ref users)}");

                if (groups.Length + users.Length <= 0) {
                    LogDebug("Counts are zero");
                    continue;
                }

                result = true;

                foreach (string group in groups) {
                    permission.RevokeGroupPermission(group, item.Key);
                    permission.GrantGroupPermission(group, item.Value, this);
                    LogInfo($"Fixed group permission: {group} (OLD) {item.Key} -> (NEW) {item.Value}");
                }

                foreach (string user in users) {
                    string uid = user.Substring(0, user.IndexOf('('));
                    permission.RevokeUserPermission(uid, item.Key);
                    permission.GrantUserPermission(uid, item.Value, this);
                    LogInfo($"Fixed user permission: {user} (OLD) {item.Key} -> (NEW) {item.Value}");
                }
            }

            permission.SaveData();
            return result;
        }

        /// <summary>
        /// Upgrade the config to 1.5.19 if needed
        /// </summary>
        /// <returns></returns>
        private bool UpgradeTo1519() {
            bool result = false;
            Dictionary<string, string> oldPerms = new Dictionary<string, string>() {
                { "playeradministration.access.voicemute", CPermMute },
                { "playeradministration.access.chatmute", CPermMute }
            };
            LogDebug($"Old Perms: {StringDictToString(ref oldPerms)}");

            foreach (KeyValuePair<string, string> item in oldPerms) {
                string[] groups = permission.GetPermissionGroups(item.Key);
                LogDebug($"Groups: {StringArrToString(ref groups)}");
                string[] users = permission.GetPermissionUsers(item.Key);
                LogDebug($"Users: {StringArrToString(ref users)}");

                if (groups.Length + users.Length <= 0) {
                    LogDebug("Counts are zero");
                    continue;
                }

                result = true;

                foreach (string group in groups) {
                    permission.RevokeGroupPermission(group, item.Key);
                    permission.GrantGroupPermission(group, item.Value, this);
                    LogInfo($"Fixed group permission: {group} (OLD) {item.Key} -> (NEW) {item.Value}");
                }

                foreach (string user in users) {
                    string uid = user.Substring(0, user.IndexOf('('));
                    permission.RevokeUserPermission(uid, item.Key);
                    permission.GrantUserPermission(uid, item.Value, this);
                    LogInfo($"Fixed user permission: {user} (OLD) {item.Key} -> (NEW) {item.Value}");
                }
            }

            permission.SaveData();
            return result;
        }

        /// <summary>
        /// Upgrade the config to 1.6.4 if needed
        /// </summary>
        /// <returns></returns>
        private bool UpgradeTo164() {
            bool result = false;
            Config.Load();

            if (Config["Broadcast Kicks"] == null) {
                FConfigData.BroadcastKicks = true;
                result = true;
            }

            if (Config["Broadcast Bans"] == null) {
                FConfigData.BroadcastBans = true;
                result = true;
            }

            Config.Clear();

            if (result)
                Config.WriteObject(FConfigData);

            return result;
        }
        #endregion

        #region GUI build methods
        /// <summary>
        /// Build the tab nav-bar
        /// </summary>
        /// <param name="aUIObj">Cui object</param>
        /// <param name="aPageType">The active page type</param>
        private void BuildTabMenu(ref Cui aUIObj, UiPage aPageType) {
            // Add the panels and title label
            string headerPanel = aUIObj.AddElement(CMainPanelName, CTabHeaderPanel);
            string tabBtnPanel = aUIObj.AddElement(CMainPanelName, CTabTabBtnPanel);
            aUIObj.AddElement(headerPanel, CTabMenuHeaderLbl);
            aUIObj.AddElement(headerPanel, CTabMenuCloseBtn);
            // Add the tab menu buttons
            AddTabMenuBtn(
                ref aUIObj, tabBtnPanel, lang.GetMessage("Main Tab Text", this, aUIObj.PlayerIdString), $"{CSwitchUiCmd} {CCmdArgMain}", 0,
                aPageType == UiPage.Main
            );
            AddTabMenuBtn(
                ref aUIObj, tabBtnPanel, lang.GetMessage("Online Player Tab Text", this, aUIObj.PlayerIdString), $"{CSwitchUiCmd} {CCmdArgPlayersOnline} 0", 1,
                aPageType == UiPage.PlayersOnline
            );
            AddTabMenuBtn(
                ref aUIObj, tabBtnPanel, lang.GetMessage("Offline Player Tab Text", this, aUIObj.PlayerIdString), $"{CSwitchUiCmd} {CCmdArgPlayersOffline} 0",
                2, aPageType == UiPage.PlayersOffline
            );
            AddTabMenuBtn(
                ref aUIObj, tabBtnPanel, lang.GetMessage("Banned Player Tab Text", this, aUIObj.PlayerIdString), $"{CSwitchUiCmd} {CCmdArgPlayersBanned} 0", 3,
                aPageType == UiPage.PlayersBanned
            );
            LogDebug("Built the tab menu");
        }

        /// <summary>
        /// Build the main-menu
        /// </summary>
        /// <param name="aUIObj">Cui object</param>
        private void BuildMainPage(ref Cui aUIObj) {
            // Add the panels and title
            string panel = aUIObj.AddElement(CMainPanelName, CMainPagePanel);
            aUIObj.AddElement(panel, CMainPageTitleLbl);
            // Add the ban by ID group
            aUIObj.AddLabel(
                panel, CMainPageLblBanByIdTitleLbAnchor, CMainPageLblBanByIdTitleRtAnchor, CuiColor.TextTitle,
                lang.GetMessage("Ban By ID Title Text", this, aUIObj.PlayerIdString), string.Empty, 16, TextAnchor.MiddleLeft
            );
            aUIObj.AddLabel(
                panel, CMainPageLblBanByIdLbAnchor, CMainPageLblBanByIdRtAnchor, CuiColor.TextAlt,
                lang.GetMessage("Ban By ID Label Text", this, aUIObj.PlayerIdString), string.Empty, 14, TextAnchor.MiddleLeft
            );
            string panelBanByIdGroup = aUIObj.AddElement(panel, CBanByIdGroupPanel);

            if (VerifyPermission(aUIObj.PlayerId, CPermBan)) {
                aUIObj.AddElement(panelBanByIdGroup, CBanByIdEdt);
                aUIObj.AddElement(panel, CBanByIdActiveBtn);
            } else {
                aUIObj.AddElement(panel, CBanByIdInactiveBtn);
            }

            LogDebug("Built the main page");
            LogDebug($"Elapsed time (BuildMainPage): {Time.realtimeSinceStartup - aUIObj.StartTime:F8}");
        }

        /// <summary>
        /// Build the current user buttons
        /// </summary>
        /// <param name="aUIObj">Cui object</param>
        /// <param name="aParent">The active page type</param>
        /// <param name="aPageType">The active page type</param>
        /// <param name="aPage">User list page</param>
        /// <param name="aBtnCommandFmt">Command format for the buttons</param>
        /// <param name="aUserCount">Total user count</param>
        /// <param name="aIndFiltered">Indicates if the output should be filtered</param>
        private void BuildUserButtons(
            ref Cui aUIObj, string aParent, UiPage aPageType, ref int aPage, out string aBtnCommandFmt, out int aUserCount, bool aIndFiltered
        ) {
            string commandFmt = $"{CSwitchUiCmd} {CCmdArgPlayerPage} {{0}}";
            IEnumerable<KeyValuePair<ulong, string>> userList = GetServerUserList(aIndFiltered, aUIObj.PlayerId, aPageType == UiPage.PlayersOffline);

            aBtnCommandFmt = aPageType == UiPage.PlayersOnline
                ? $"{CSwitchUiCmd} {(aIndFiltered ? CCmdArgPlayersOnlineSearch : CCmdArgPlayersOnline)} {{0}}"
                : $"{CSwitchUiCmd} {(aIndFiltered ? CCmdArgPlayersOfflineSearch : CCmdArgPlayersOffline)} {{0}}";
            aUserCount = userList.Count();

            if ((aPage != 0) && (aUserCount <= CMaxPlayerButtons))
                aPage = 0; // Reset page to 0 if user count is lower or equal to max button count

            AddPlayerButtons(ref aUIObj, aParent, ref userList, commandFmt, aPage);
            LogDebug("Built the current page of user buttons");
        }

        /// <summary>
        /// Build a page of user buttons
        /// </summary>
        /// <param name="aUIObj">Cui object</param>
        /// <param name="aPageType">The active page type</param>
        /// <param name="aPage">User list page</param>
        /// <param name="aIndFiltered">Indicates if the output should be filtered</param>
        private void BuildUserBtnPage(ref Cui aUIObj, UiPage aPageType, int aPage, bool aIndFiltered) {
            string npBtnCommandFmt;
            int userCount;

            string panel = aUIObj.AddElement(CMainPanelName, CMainPagePanel);
            aUIObj.AddLabel(
                panel, CUserBtnPageLblTitleLbAnchor, CUserBtnPageLblTitleRtAnchor, CuiColor.TextAlt,
                lang.GetMessage("User Button Page Title Text", this, aUIObj.PlayerIdString), string.Empty, 18, TextAnchor.MiddleLeft
            );
            // Add search elements
            aUIObj.AddLabel(
                panel, CUserBtnPageLblSearchLbAnchor, CUserBtnPageLblSearchRtAnchor, CuiColor.TextAlt,
                lang.GetMessage("Search Label Text", this, aUIObj.PlayerIdString), string.Empty, 16, TextAnchor.MiddleLeft
            );
            string panelSearchGroup = aUIObj.AddElement(panel, CUserBtnPageSearchInputPanel);
            aUIObj.AddInputField(
                panelSearchGroup, CUserBtnPageEdtSearchInputLbAnchor, CUserBtnPageEdtSearchInputRtAnchor, CuiColor.TextAlt,
                (FUserBtnPageSearchInputText.ContainsKey(aUIObj.PlayerId) ? FUserBtnPageSearchInputText[aUIObj.PlayerId] : string.Empty), 100,
                CUserBtnPageSearchInputTextCmd, false, string.Empty, 16
            );

            switch (aPageType) {
                case UiPage.PlayersOnline: {
                        aUIObj.AddButton(
                            panel, CUserBtnPageBtnSearchLbAnchor, CUserBtnPageBtnSearchRtAnchor, CuiColor.Button, CuiColor.TextAlt,
                            lang.GetMessage("Go Button Text", this, aUIObj.PlayerIdString), $"{CSwitchUiCmd} {CCmdArgPlayersOnlineSearch} 0", string.Empty,
                            string.Empty, 16
                        );
                        BuildUserButtons(ref aUIObj, panel, aPageType, ref aPage, out npBtnCommandFmt, out userCount, aIndFiltered);
                        break;
                    }
                case UiPage.PlayersOffline: {
                        aUIObj.AddButton(
                            panel, CUserBtnPageBtnSearchLbAnchor, CUserBtnPageBtnSearchRtAnchor, CuiColor.Button, CuiColor.TextAlt,
                            lang.GetMessage("Go Button Text", this, aUIObj.PlayerIdString), $"{CSwitchUiCmd} {CCmdArgPlayersOfflineSearch} 0", string.Empty,
                            string.Empty, 16
                        );
                        BuildUserButtons(ref aUIObj, panel, aPageType, ref aPage, out npBtnCommandFmt, out userCount, aIndFiltered);
                        break;
                    }
                default: {
                        aUIObj.AddButton(
                            panel, CUserBtnPageBtnSearchLbAnchor, CUserBtnPageBtnSearchRtAnchor, CuiColor.Button, CuiColor.TextAlt,
                            lang.GetMessage("Go Button Text", this, aUIObj.PlayerIdString), $"{CSwitchUiCmd} {CCmdArgPlayersBannedSearch} 0", string.Empty,
                            string.Empty, 16
                        );

                        string commandFmt = $"{CSwitchUiCmd} {CCmdArgPlayerPageBanned} {{0}}";
                        IEnumerable<KeyValuePair<ulong, string>> userList = GetBannedUserList(aIndFiltered, aUIObj.PlayerId);
                        npBtnCommandFmt = $"{CSwitchUiCmd} {(aIndFiltered ? CCmdArgPlayersBannedSearch : CCmdArgPlayersBanned)} {{0}}";
                        userCount = userList.Count();

                        if ((aPage != 0) && (userCount <= CMaxPlayerButtons))
                            aPage = 0; // Reset page to 0 if user count is lower or equal to max button count

                        AddPlayerButtons(ref aUIObj, panel, ref userList, commandFmt, aPage);
                        LogDebug("Built the current page of banned user buttons");
                        break;
                    }
            }

            // Decide whether or not to activate the "previous" button
            if (aPage == 0) {
                aUIObj.AddElement(panel, CUserBtnPagePreviousInactiveBtn);
            } else {
                aUIObj.AddButton(
                    panel, CUserBtnPageBtnPreviousLbAnchor, CUserBtnPageBtnPreviousRtAnchor, CuiColor.Button, CuiColor.TextAlt, "<<",
                    string.Format(npBtnCommandFmt, aPage - 1), string.Empty, string.Empty, 18
                );
            }

            // Decide whether or not to activate the "next" button
            if (userCount > CMaxPlayerButtons * (aPage + 1)) {
                aUIObj.AddButton(
                    panel, CUserBtnPageBtnNextLbAnchor, CUserBtnPageBtnNextRtAnchor, CuiColor.Button, CuiColor.TextAlt, ">>",
                    string.Format(npBtnCommandFmt, aPage + 1), string.Empty, string.Empty, 18
                );
            } else {
                aUIObj.AddElement(panel, CUserBtnPageNextInactiveBtn);
            }

            LogDebug("Built the user button page");
            LogDebug($"Elapsed time (BuildUserBtnPage): {Time.realtimeSinceStartup - aUIObj.StartTime:F8}");
        }

        /// <summary>
        /// Add the user information labels to the parent element
        /// </summary>
        /// <param name="aUIObj">Cui object</param>
        /// <param name="aParent">Parent panel name</param>
        /// <param name="aPlayerId">Player ID (SteamId64)</param>
        /// <param name="aPlayer">Player who's information we need to display</param>
        private void AddUserPageInfoLabels(ref Cui aUIObj, string aParent, ulong aPlayerId, ref BasePlayer aPlayer) {
            string lastCheatStr = lang.GetMessage("Never Label Text", this, aUIObj.PlayerIdString);
            string authLevel = ServerUsers.Get(aPlayerId)?.group.ToString() ?? "None";        
            string CpAddress = lang.GetMessage("OffLine Label Text", this, aUIObj.PlayerIdString);
            string CpPing = lang.GetMessage("OffLine Label Text", this, aUIObj.PlayerIdString);

            // Recover & pre-process user connection data(player should be connected so calls are safe)
            if (aPlayer.IsConnected)
            {
                CpAddress = aPlayer.net.connection.ipaddress.Split(':')[0];
                CpPing = Network.Net.sv.GetAveragePing(aPlayer.net.connection).ToString();
            }

            // Pre-calc last admin cheat
            if (aPlayer.lastAdminCheatTime > 0f) {
                TimeSpan lastCheatSinceStart = new TimeSpan(0, 0, (int)(Time.realtimeSinceStartup - aPlayer.lastAdminCheatTime));
                lastCheatStr = $"{DateTime.UtcNow.Subtract(lastCheatSinceStart):yyyy-MM-dd HH:mm:ss} UTC";
            }

            LogDebug("AddUserPageInfoLabels > Time since last admin cheat has been determined.");
            aUIObj.AddLabel(
                aParent, CUserPageLblIdLbAnchor, CUserPageLblIdRtAnchor, CuiColor.TextAlt, string.Format(
                    lang.GetMessage("Id Label Format", this, aUIObj.PlayerIdString), aPlayerId,
                    (aPlayer.IsDeveloper ? lang.GetMessage("Dev Label Text", this, aUIObj.PlayerIdString) : string.Empty)
                ), string.Empty, 14, TextAnchor.MiddleLeft
            );
            aUIObj.AddLabel(
                aParent, CUserPageLblAuthLbAnchor, CUserPageLblAuthRtAnchor, CuiColor.TextAlt,
                string.Format(lang.GetMessage("Auth Level Label Format", this, aUIObj.PlayerIdString), authLevel), string.Empty, 14, TextAnchor.MiddleLeft
            );
            aUIObj.AddLabel(
                aParent, CUserPageLblConnectLbAnchor, CUserPageLblConnectRtAnchor, CuiColor.TextAlt, string.Format(lang.GetMessage(
                    "Connection Label Format", this, aUIObj.PlayerIdString),
                    (
                        aPlayer.IsConnected
                            ? lang.GetMessage("Connected Label Text", this, aUIObj.PlayerIdString)
                            : lang.GetMessage("Disconnected Label Text", this, aUIObj.PlayerIdString)
                    )
                ), string.Empty, 14, TextAnchor.MiddleLeft
            );
            aUIObj.AddLabel(
                aParent, CUserPageLblSleepLbAnchor, CUserPageLblSleepRtAnchor, CuiColor.TextAlt, string.Format(lang.GetMessage(
                    "Status Label Format", this, aUIObj.PlayerIdString),
                    (
                        aPlayer.IsSleeping()
                            ? lang.GetMessage("Sleeping Label Text", this, aUIObj.PlayerIdString)
                            : lang.GetMessage("Awake Label Text", this, aUIObj.PlayerIdString)
                    ),
                    (
                        aPlayer.IsAlive()
                            ? lang.GetMessage("Alive Label Text", this, aUIObj.PlayerIdString)
                            : lang.GetMessage("Dead Label Text", this, aUIObj.PlayerIdString)
                    )
                ), string.Empty, 14, TextAnchor.MiddleLeft
            );

            LogDebug("AddUserPageInfoLabels > Generic info has been added.");

            if (VerifyPermission(aUIObj.PlayerId, CPermDetailInfo)) {
                aUIObj.AddLabel(
                    aParent, CUserPageLblFlagLbAnchor, CUserPageLblFlagRtAnchor, CuiColor.TextAlt, string.Format(lang.GetMessage(
                        "Flags Label Format", this, aUIObj.PlayerIdString),
                        (aPlayer.IsFlying ? lang.GetMessage("Flying Label Text", this, aUIObj.PlayerIdString) : string.Empty),
                        (aPlayer.isMounted ? lang.GetMessage("Mounted Label Text", this, aUIObj.PlayerIdString) : string.Empty)
                    ), string.Empty, 14, TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblPosLbAnchor, CUserPageLblPosRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Position Label Format", this, aUIObj.PlayerIdString), aPlayer.ServerPosition), string.Empty, 14,
                    TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblRotLbAnchor, CUserPageLblRotRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Rotation Label Format", this, aUIObj.PlayerIdString), aPlayer.GetNetworkRotation()), string.Empty, 14,
                    TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblAdminCheatLbAnchor, CUserPageLblAdminCheatRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Last Admin Cheat Label Format", this, aUIObj.PlayerIdString), lastCheatStr), string.Empty, 14,
                    TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblIdleLbAnchor, CUserPageLblIdleRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Idle Time Label Format", this, aUIObj.PlayerIdString), Math.Round(aPlayer.IdleTime, 2)), string.Empty, 14,
                    TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblUsrNetAddrLbAnchor, CUserPageLblUsrNetAddrRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Player Address Label Format", this, aUIObj.PlayerIdString), CpAddress), string.Empty, 14,
                    TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                  aParent, CUserPageLblUsrAvrPingLbAnchor, CUserPageLblUsrAvrPingRtAnchor, CuiColor.TextAlt,
                  string.Format(lang.GetMessage("Player Ping Label Format", this, aUIObj.PlayerIdString), CpPing), string.Empty, 14,
                  TextAnchor.MiddleLeft
              );

                if (Economics != null) {
                    aUIObj.AddLabel(
                        aParent, CUserPageLblBalanceLbAnchor, CUserPageLblBalanceRtAnchor, CuiColor.TextAlt,
                        string.Format(lang.GetMessage("Economics Balance Label Format", this, aUIObj.PlayerIdString),
                        Math.Round((double)(Economics.Call("Balance", aPlayerId) ?? 0), 2)), string.Empty, 14, TextAnchor.MiddleLeft
                    );
                } else {
                    aUIObj.AddLabel(
                        aParent, CUserPageLblBalanceLbAnchor, CUserPageLblBalanceRtAnchor, CuiColor.TextAlt,
                        string.Format(lang.GetMessage("Economics Balance Label Format", this, aUIObj.PlayerIdString), "N/A"), string.Empty, 14,
                        TextAnchor.MiddleLeft
                    );
                }

                LogDebug("AddUserPageInfoLabels > Economics info has been added.");

                if (ServerRewards != null) {
                    aUIObj.AddLabel(
                        aParent, CUserPageLblRewardPointsLbAnchor, CUserPageLblRewardPointsRtAnchor, CuiColor.TextAlt,
                        string.Format(lang.GetMessage("ServerRewards Points Label Format", this, aUIObj.PlayerIdString),
                        (int)(ServerRewards.Call("CheckPoints", aPlayerId) ?? 0)), string.Empty, 14, TextAnchor.MiddleLeft
                    );
                } else {
                    aUIObj.AddLabel(
                        aParent, CUserPageLblRewardPointsLbAnchor, CUserPageLblRewardPointsRtAnchor, CuiColor.TextAlt,
                        string.Format(lang.GetMessage("ServerRewards Points Label Format", this, aUIObj.PlayerIdString), "N/A"), string.Empty, 14,
                        TextAnchor.MiddleLeft
                    );
                }

                LogDebug("AddUserPageInfoLabels > ServerRewards info has been added.");

                if (Godmode != null && Godmode.Version.Major >= 4 && Godmode.Version.Minor >= 2 && Godmode.Version.Patch >= 9) {
                    aUIObj.AddLabel(
                        aParent, CUserPageLblGodmodeLbAnchor, CUserPageLblGodmodeRtAnchor, CuiColor.TextAlt,
                        string.Format(lang.GetMessage("Godmode Status Label Format", this, aUIObj.PlayerIdString),
                        (bool)(Godmode.Call("IsGod", aPlayerId) ?? false)), string.Empty, 14, TextAnchor.MiddleLeft
                    );
                } else {
                    aUIObj.AddLabel(
                        aParent, CUserPageLblGodmodeLbAnchor, CUserPageLblGodmodeRtAnchor, CuiColor.TextAlt,
                        string.Format(lang.GetMessage("Godmode Status Label Format", this, aUIObj.PlayerIdString), "N/A"), string.Empty, 14,
                        TextAnchor.MiddleLeft
                    );
                }

                LogDebug("AddUserPageInfoLabels > Godmode info has been added.");
                aUIObj.AddLabel(
                    aParent, CUserPageLblHealthLbAnchor, CUserPageLblHealthRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Health Label Format", this, aUIObj.PlayerIdString), aPlayer.health), string.Empty, 14, TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblCalLbAnchor, CUserPageLblCalRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Calories Label Format", this, aUIObj.PlayerIdString), aPlayer.metabolism?.calories?.value), string.Empty,
                    14, TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblHydraLbAnchor, CUserPageLblHydraRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Hydration Label Format", this, aUIObj.PlayerIdString), aPlayer.metabolism?.hydration?.value), string.Empty,
                    14, TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblTempLbAnchor, CUserPageLblTempRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Temp Label Format", this, aUIObj.PlayerIdString), aPlayer.metabolism?.temperature?.value), string.Empty, 14,
                    TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblWetLbAnchor, CUserPageLblWetRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Wetness Label Format", this, aUIObj.PlayerIdString), aPlayer.metabolism?.wetness?.value), string.Empty, 14,
                    TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblComfortLbAnchor, CUserPageLblComfortRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Comfort Label Format", this, aUIObj.PlayerIdString),100* aPlayer.metabolism?.comfort?.value), string.Empty, 14,
                    TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblBleedLbAnchor, CUserPageLblBleedRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Bleeding Label Format", this, aUIObj.PlayerIdString), aPlayer.metabolism?.bleeding?.value), string.Empty,
                    14, TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblRads1LbAnchor, CUserPageLblRads1RtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Radiation Label Format", this, aUIObj.PlayerIdString), aPlayer.metabolism?.radiation_poison?.value),
                    string.Empty, 14, TextAnchor.MiddleLeft
                );
                aUIObj.AddLabel(
                    aParent, CUserPageLblRads2LbAnchor, CUserPageLblRads2RtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Radiation Protection Label Format", this, aUIObj.PlayerIdString), aPlayer.RadiationProtection()),
                    string.Empty, 14, TextAnchor.MiddleLeft
                );
                LogDebug("AddUserPageInfoLabels > Player statistics info has been added.");
            }
        }

        /// <summary>
        /// Build the user information and administration page
        /// This kind of method will always be complex, so ignore metrics about it, please. :)
        /// </summary>
        /// <param name="aUIObj">Cui object</param>
        /// <param name="aPageType">The active page type</param>
        /// <param name="aPlayerId">Player ID (SteamId64)</param>
        private void BuildUserPage(ref Cui aUIObj, UiPage aPageType, ulong aPlayerId) {
            // Add panels
            string panel = aUIObj.AddPanel(CMainPanelName, CMainPanelLbAnchor, CMainPanelRtAnchor, false, CuiColor.Background);
            string infoPanel = aUIObj.AddPanel(panel, CUserPageInfoPanelLbAnchor, CUserPageInfoPanelRtAnchor, false, CuiColor.BackgroundMedium);
            string actionPanel = aUIObj.AddPanel(panel, CUserPageActionPanelLbAnchor, CUserPageActionPanelRtAnchor, false, CuiColor.BackgroundMedium);
            LogDebug("BuildUserPage > Panels have been added.");

            // Add title labels
            aUIObj.AddLabel(
                infoPanel, CUserPageLblinfoTitleLbAnchor, CUserPageLblinfoTitleRtAnchor, CuiColor.TextTitle,
                lang.GetMessage("Player Info Label Text", this, aUIObj.PlayerIdString), string.Empty, 14, TextAnchor.MiddleLeft
            );
            aUIObj.AddLabel(
                actionPanel, CUserPageLblActionTitleLbAnchor, CUserPageLblActionTitleRtAnchor, CuiColor.TextTitle,
                lang.GetMessage("Player Actions Label Text", this, aUIObj.PlayerIdString), string.Empty, 14, TextAnchor.MiddleLeft
            );
            LogDebug("BuildUserPage > Title lables have been added.");

            if (aPageType == UiPage.PlayerPage) {
                BasePlayer player = BasePlayer.FindByID(aPlayerId) ?? BasePlayer.FindSleeping(aPlayerId);
                bool isPlayerNull = player == null;
                bool isPlayerConnected = false;

                if (isPlayerNull) {
                    LogInfo($"BuildUserPage > player [{aPlayerId}] is null, no info");
                    aUIObj.AddLabel(
                        panel, CMainLblTitleLbAnchor, CMainLblTitleRtAnchor, CuiColor.TextAlt, $"Player [{aPlayerId}] is null, no info", string.Empty, 18,
                        TextAnchor.MiddleLeft
                    );
                } else {
                    aUIObj.AddLabel(
                        panel, CMainLblTitleLbAnchor, CMainLblTitleRtAnchor, CuiColor.TextAlt,
                        string.Format(lang.GetMessage("User Page Title Format", this, aUIObj.PlayerIdString), EscapeString(player.displayName), string.Empty),
                        string.Empty, 18, TextAnchor.MiddleLeft
                    );
                    // Add user info labels
                    AddUserPageInfoLabels(ref aUIObj, infoPanel, aPlayerId, ref player);
                    isPlayerConnected = player.IsConnected;
                }

                // --- Build player action panel
                // Ban, Kick
                if (aPlayerId != aUIObj.PlayerId && VerifyPermission(aUIObj.PlayerId, CPermBan)) { // No need to check for null, as we ban the ID and don't attempt retrieval
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnBanLbAnchor, CUserPageBtnBanRtAnchor, CuiColor.ButtonDanger, CuiColor.TextAlt,
                        lang.GetMessage("Ban Button Text", this, aUIObj.PlayerIdString), $"{CBanUserCmd} {aPlayerId}"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnBanLbAnchor, CUserPageBtnBanRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Ban Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                if (isPlayerConnected && aPlayerId != aUIObj.PlayerId && VerifyPermission(aUIObj.PlayerId, CPermKick)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnKickLbAnchor, CUserPageBtnKickRtAnchor, CuiColor.ButtonDanger, CuiColor.TextAlt,
                        lang.GetMessage("Kick Button Text", this, aUIObj.PlayerIdString), $"{CKickUserCmd} {aPlayerId}"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnKickLbAnchor, CUserPageBtnKickRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Kick Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                aUIObj.AddLabel(
                    actionPanel, CUserPageLblReasonLbAnchor, CUserPageLblReasonRtAnchor, CuiColor.TextAlt,
                    lang.GetMessage("Reason Input Label Text", this, aUIObj.PlayerIdString), string.Empty, 14, TextAnchor.MiddleLeft
                );

                string panelReasonGroup = aUIObj.AddPanel(actionPanel, CUserPagePanelReasonLbAnchor, CUserPagePanelReasonRtAnchor, false, CuiColor.BackgroundDark);
                aUIObj.AddInputField(
                    panelReasonGroup, CUserPageEdtReasonLbAnchor, CUserPageEdtReasonRtAnchor, CuiColor.TextAlt, string.Empty, 24, CUserPageReasonInputTextCmd
                );

                // Unmute, Mute (And timed ones if BetterChat is available)
                if (isPlayerConnected && aPlayerId != aUIObj.PlayerId && VerifyPermission(aUIObj.PlayerId, CPermMute)) {
                    if (GetIsMuted(ref player)) {
                        aUIObj.AddButton(
                            actionPanel, CUserPageBtnUnmuteLbAnchor, CUserPageBtnUnmuteRtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                            lang.GetMessage("Unmute Button Text", this, aUIObj.PlayerIdString), $"{CUnmuteUserCmd} {aPlayerId}"
                        );
                        aUIObj.AddButton(
                            actionPanel, CUserPageBtnMuteLbAnchor, CUserPageBtnMuteRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                            lang.GetMessage("Mute Button Text", this, aUIObj.PlayerIdString)
                        );

                        if (BetterChatMute != null) {
                            aUIObj.AddButton(
                                actionPanel, CUserPageBtnMuteFifteenLbAnchor, CUserPageBtnMuteFifteenRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                                lang.GetMessage("Mute Button Text 15", this, aUIObj.PlayerIdString)
                            );
                            aUIObj.AddButton(
                                actionPanel, CUserPageBtnMuteThirtyLbAnchor, CUserPageBtnMuteThirtyRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                                lang.GetMessage("Mute Button Text 30", this, aUIObj.PlayerIdString)
                            );
                            aUIObj.AddButton(
                                actionPanel, CUserPageBtnMuteSixtyLbAnchor, CUserPageBtnMuteSixtyRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                                lang.GetMessage("Mute Button Text 60", this, aUIObj.PlayerIdString)
                            );
                        }
                    } else {
                        aUIObj.AddButton(
                            actionPanel, CUserPageBtnUnmuteLbAnchor, CUserPageBtnUnmuteRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                            lang.GetMessage("Unmute Button Text", this, aUIObj.PlayerIdString)
                        );
                        aUIObj.AddButton(
                            actionPanel, CUserPageBtnMuteLbAnchor, CUserPageBtnMuteRtAnchor, CuiColor.ButtonDanger, CuiColor.TextAlt,
                            lang.GetMessage("Mute Button Text", this, aUIObj.PlayerIdString), $"{CMuteUserCmd} {aPlayerId} 0"
                        );

                        if (BetterChatMute != null) {
                            aUIObj.AddButton(
                                actionPanel, CUserPageBtnMuteFifteenLbAnchor, CUserPageBtnMuteFifteenRtAnchor, CuiColor.ButtonDanger, CuiColor.TextAlt,
                                lang.GetMessage("Mute Button Text 15", this, aUIObj.PlayerIdString), $"{CMuteUserCmd} {aPlayerId} 15"
                            );
                            aUIObj.AddButton(
                                actionPanel, CUserPageBtnMuteThirtyLbAnchor, CUserPageBtnMuteThirtyRtAnchor, CuiColor.ButtonDanger, CuiColor.TextAlt,
                                lang.GetMessage("Mute Button Text 30", this, aUIObj.PlayerIdString), $"{CMuteUserCmd} {aPlayerId} 30"
                            );
                            aUIObj.AddButton(
                                actionPanel, CUserPageBtnMuteSixtyLbAnchor, CUserPageBtnMuteSixtyRtAnchor, CuiColor.ButtonDanger, CuiColor.TextAlt,
                                lang.GetMessage("Mute Button Text 60", this, aUIObj.PlayerIdString), $"{CMuteUserCmd} {aPlayerId} 60"
                            );
                        }
                    }
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnUnmuteLbAnchor, CUserPageBtnUnmuteRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Unmute Button Text", this, aUIObj.PlayerIdString)
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnMuteLbAnchor, CUserPageBtnMuteRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Mute Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                // Unfreeze, Freeze
                if (Freeze == null) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnFreezeLbAnchor, CUserPageBtnFreezeRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Freeze Not Installed Button Text", this, aUIObj.PlayerIdString)
                    );
                } else if (isPlayerConnected && aPlayerId != aUIObj.PlayerId && VerifyPermission(aUIObj.PlayerId, CPermFreeze)) {
                    if (GetIsFrozen(aPlayerId)) {
                        aUIObj.AddButton(
                            actionPanel, CUserPageBtnUnFreezeLbAnchor, CUserPageBtnUnFreezeRtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                            lang.GetMessage("UnFreeze Button Text", this, aUIObj.PlayerIdString), $"{CUnFreezeCmd} {aPlayerId}"
                        );
                        aUIObj.AddButton(
                            actionPanel, CUserPageBtnFreezeLbAnchor, CUserPageBtnFreezeRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                            lang.GetMessage("Freeze Button Text", this, aUIObj.PlayerIdString)
                        );
                    } else {
                        aUIObj.AddButton(
                            actionPanel, CUserPageBtnUnFreezeLbAnchor, CUserPageBtnUnFreezeRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                            lang.GetMessage("UnFreeze Button Text", this, aUIObj.PlayerIdString)
                        );
                        aUIObj.AddButton(
                            actionPanel, CUserPageBtnFreezeLbAnchor, CUserPageBtnFreezeRtAnchor, CuiColor.ButtonDanger, CuiColor.TextAlt,
                            lang.GetMessage("Freeze Button Text", this, aUIObj.PlayerIdString), $"{CFreezeCmd} {aPlayerId}"
                        );
                    }
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnUnFreezeLbAnchor, CUserPageBtnUnFreezeRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("UnFreeze Button Text", this, aUIObj.PlayerIdString)
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnFreezeLbAnchor, CUserPageBtnFreezeRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Freeze Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                // Clear inventory, Reset BP, Reset metabolism
                if ((!isPlayerNull) && VerifyPermission(aUIObj.PlayerId, CPermClearInventory)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnClearInventoryLbAnchor, CUserPageBtnClearInventoryRtAnchor, CuiColor.ButtonWarning, CuiColor.TextAlt,
                        lang.GetMessage("Clear Inventory Button Text", this, aUIObj.PlayerIdString), $"{CClearUserInventoryCmd} {aPlayerId}"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnClearInventoryLbAnchor, CUserPageBtnClearInventoryRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Clear Inventory Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                if ((!isPlayerNull) && VerifyPermission(aUIObj.PlayerId, CPermResetBP)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnResetBPLbAnchor, CUserPageBtnResetBPRtAnchor, CuiColor.ButtonWarning, CuiColor.TextAlt,
                        lang.GetMessage("Reset Blueprints Button Text", this, aUIObj.PlayerIdString), $"{CResetUserBPCmd} {aPlayerId}"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnResetBPLbAnchor, CUserPageBtnResetBPRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Reset Blueprints Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                if ((!isPlayerNull) && VerifyPermission(aUIObj.PlayerId, CPermResetMetabolism)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnResetMetabolismLbAnchor, CUserPageBtnResetMetabolismRtAnchor, CuiColor.ButtonWarning, CuiColor.TextAlt,
                        lang.GetMessage("Reset Metabolism Button Text", this, aUIObj.PlayerIdString), $"{CResetUserMetabolismCmd} {aPlayerId}"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnResetMetabolismLbAnchor, CUserPageBtnResetMetabolismRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Reset Metabolism Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                if ((!isPlayerNull) && VerifyPermission(aUIObj.PlayerId, CPermRecoverMetabolism)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnRecoverMetabolismLbAnchor, CUserPageBtnRecoverMetabolismRtAnchor, CuiColor.ButtonWarning, CuiColor.TextAlt,
                        lang.GetMessage("Recover Metabolism Button Text", this, aUIObj.PlayerIdString), $"{CRecoverUserMetabolismCmd} {aPlayerId}"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnRecoverMetabolismLbAnchor, CUserPageBtnRecoverMetabolismRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Recover Metabolism Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                // Teleport to, Teleport, Spectate
                if ((!isPlayerNull) && aPlayerId != aUIObj.PlayerId && VerifyPermission(aUIObj.PlayerId, CPermTeleport)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnTeleportToLbAnchor, CUserPageBtnTeleportToRtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                        lang.GetMessage("Teleport To Player Button Text", this, aUIObj.PlayerIdString), $"{CTeleportToUserCmd} {aPlayerId}"
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnTeleportLbAnchor, CUserPageBtnTeleportRtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                        lang.GetMessage("Teleport Player Button Text", this, aUIObj.PlayerIdString), $"{CTeleportUserCmd} {aPlayerId}"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnTeleportToLbAnchor, CUserPageBtnTeleportToRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Teleport To Player Button Text", this, aUIObj.PlayerIdString)
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnTeleportLbAnchor, CUserPageBtnTeleportRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Teleport Player Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                if ((!isPlayerNull) && aPlayerId != aUIObj.PlayerId && VerifyPermission(aUIObj.PlayerId, CPermSpectate)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnSpectateLbAnchor, CUserPageBtnSpectateRtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                        lang.GetMessage("Spectate Player Button Text", this, aUIObj.PlayerIdString), $"{CSpectateUserCmd} {aPlayerId}"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnSpectateLbAnchor, CUserPageBtnSpectateRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Spectate Player Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                // Perms & Backpacks & Inventory
                if (PermissionsManager == null) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnPermsLbAnchor, CUserPageBtnPermsRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Perms Not Installed Button Text", this, aUIObj.PlayerIdString)
                    );
                } else if ((!isPlayerNull) && VerifyPermission(aUIObj.PlayerId, CPermPerms)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnPermsLbAnchor, CUserPageBtnPermsRtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                        lang.GetMessage("Perms Button Text", this, aUIObj.PlayerIdString), $"{CPermsCmd} {aPlayerId}"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnPermsLbAnchor, CUserPageBtnPermsRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Perms Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                if (Backpacks == null) {
                    aUIObj.AddButton(
                    actionPanel, CUserPageBtnBackpacksLbAnchor, CUserPageBtnBackpacksRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                    lang.GetMessage("Backpacks Not Installed Button Text", this, aUIObj.PlayerIdString));
                } else if ((!isPlayerNull) && VerifyPermission(aUIObj.PlayerId, CPermBackpacks)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnBackpacksLbAnchor, CUserPageBtnBackpacksRtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                        lang.GetMessage("Backpacks Button Text", this, aUIObj.PlayerIdString), $"{CBackpackViewCmd} {aPlayerId}");
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnBackpacksLbAnchor, CUserPageBtnBackpacksRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Backpacks Button Text", this, aUIObj.PlayerIdString));
                }

                if (InventoryViewer == null) {
                    aUIObj.AddButton(
                    actionPanel, CUserPageBtnInventoryLbAnchor, CUserPageBtnInventoryRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                    lang.GetMessage("Inventory Not Installed Button Text", this, aUIObj.PlayerIdString));
                } else if ((!isPlayerNull) && VerifyPermission(aUIObj.PlayerId, CPermInventory)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnInventoryLbAnchor, CUserPageBtnInventoryRtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                        lang.GetMessage("Inventory Button Text", this, aUIObj.PlayerIdString), $"{CInventoryViewCmd} {aPlayerId}");
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnInventoryLbAnchor, CUserPageBtnInventoryRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Inventory Button Text", this, aUIObj.PlayerIdString));
                }

                // UnGodmode & Godmode
                if (Godmode == null || !(Godmode.Version.Major >= 4 && Godmode.Version.Minor >= 2 && Godmode.Version.Patch >= 9)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnGodmodeLbAnchor, CUserPageBtnGodmodeRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Godmode Not Installed Button Text", this, aUIObj.PlayerIdString)
                    );
                } else if (isPlayerConnected && VerifyPermission(aUIObj.PlayerId, CPermGodmode)) {
                    if ((bool)(Godmode.Call("IsGod", aPlayerId) ?? false)) {
                        aUIObj.AddButton(
                            actionPanel, CUserPageBtnUnGodmodeLbAnchor, CUserPageBtnUnGodmodeRtAnchor, CuiColor.ButtonWarning, CuiColor.TextAlt,
                            lang.GetMessage("UnGodmode Button Text", this, aUIObj.PlayerIdString), $"{CUnGodmodeCmd} {aPlayerId}"
                        );
                        aUIObj.AddButton(
                            actionPanel, CUserPageBtnGodmodeLbAnchor, CUserPageBtnGodmodeRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                            lang.GetMessage("Godmode Button Text", this, aUIObj.PlayerIdString)
                        );
                    } else {
                        aUIObj.AddButton(
                            actionPanel, CUserPageBtnUnGodmodeLbAnchor, CUserPageBtnUnGodmodeRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                            lang.GetMessage("UnGodmode Button Text", this, aUIObj.PlayerIdString)
                        );
                        aUIObj.AddButton(
                            actionPanel, CUserPageBtnGodmodeLbAnchor, CUserPageBtnGodmodeRtAnchor, CuiColor.ButtonWarning, CuiColor.TextAlt,
                            lang.GetMessage("Godmode Button Text", this, aUIObj.PlayerIdString), $"{CGodmodeCmd} {aPlayerId}"
                        );
                    }
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnUnGodmodeLbAnchor, CUserPageBtnUnGodmodeRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("UnGodmode Button Text", this, aUIObj.PlayerIdString)
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnGodmodeLbAnchor, CUserPageBtnGodmodeRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Godmode Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                // Hurt 25, Hurt 50, Hurt 75, Hurt 100, Kill
                if ((!isPlayerNull) && VerifyPermission(aUIObj.PlayerId, CPermHurt)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHurt25LbAnchor, CUserPageBtnHurt25RtAnchor, CuiColor.ButtonDanger, CuiColor.TextAlt,
                        lang.GetMessage("Hurt 25 Button Text", this, aUIObj.PlayerIdString), $"{CHurtUserCmd} {aPlayerId} 25"
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHurt50LbAnchor, CUserPageBtnHurt50RtAnchor, CuiColor.ButtonDanger, CuiColor.TextAlt,
                        lang.GetMessage("Hurt 50 Button Text", this, aUIObj.PlayerIdString), $"{CHurtUserCmd} {aPlayerId} 50"
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHurt75LbAnchor, CUserPageBtnHurt75RtAnchor, CuiColor.ButtonDanger, CuiColor.TextAlt,
                        lang.GetMessage("Hurt 75 Button Text", this, aUIObj.PlayerIdString), $"{CHurtUserCmd} {aPlayerId} 75"
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHurt100LbAnchor, CUserPageBtnHurt100RtAnchor, CuiColor.ButtonDanger, CuiColor.TextAlt,
                        lang.GetMessage("Hurt 100 Button Text", this, aUIObj.PlayerIdString), $"{CHurtUserCmd} {aPlayerId} 100"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHurt25LbAnchor, CUserPageBtnHurt25RtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Hurt 25 Button Text", this, aUIObj.PlayerIdString)
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHurt50LbAnchor, CUserPageBtnHurt50RtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Hurt 50 Button Text", this, aUIObj.PlayerIdString)
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHurt75LbAnchor, CUserPageBtnHurt75RtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Hurt 75 Button Text", this, aUIObj.PlayerIdString)
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHurt100LbAnchor, CUserPageBtnHurt100RtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Hurt 100 Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                if ((!isPlayerNull) && VerifyPermission(aUIObj.PlayerId, CPermKill)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnKillLbAnchor, CUserPageBtnKillRtAnchor, CuiColor.ButtonDanger, CuiColor.TextAlt,
                        lang.GetMessage("Kill Button Text", this, aUIObj.PlayerIdString), $"{CKillUserCmd} {aPlayerId}"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnKillLbAnchor, CUserPageBtnKillRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Kill Button Text", this, aUIObj.PlayerIdString)
                    );
                }

                // Heal 25, Heal 50, Heal 75, Heal 100, Heal wounds
                if ((!isPlayerNull) && VerifyPermission(aUIObj.PlayerId, CPermHeal)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHeal25LbAnchor, CUserPageBtnHeal25RtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                        lang.GetMessage("Heal 25 Button Text", this, aUIObj.PlayerIdString), $"{CHealUserCmd} {aPlayerId} 25"
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHeal50LbAnchor, CUserPageBtnHeal50RtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                        lang.GetMessage("Heal 50 Button Text", this, aUIObj.PlayerIdString), $"{CHealUserCmd} {aPlayerId} 50"
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHeal75LbAnchor, CUserPageBtnHeal75RtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                        lang.GetMessage("Heal 75 Button Text", this, aUIObj.PlayerIdString), $"{CHealUserCmd} {aPlayerId} 75"
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHeal100LbAnchor, CUserPageBtnHeal100RtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                        lang.GetMessage("Heal 100 Button Text", this, aUIObj.PlayerIdString), $"{CHealUserCmd} {aPlayerId} 100"
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHealWoundsLbAnchor, CUserPageBtnHealWoundsRtAnchor, CuiColor.ButtonSuccess, CuiColor.TextAlt,
                        lang.GetMessage("Heal Wounds Button Text", this, aUIObj.PlayerIdString), $"{CHealUserCmd} {aPlayerId} 0"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHeal25LbAnchor, CUserPageBtnHeal25RtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Heal 25 Button Text", this, aUIObj.PlayerIdString)
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHeal50LbAnchor, CUserPageBtnHeal50RtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Heal 50 Button Text", this, aUIObj.PlayerIdString)
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHeal75LbAnchor, CUserPageBtnHeal75RtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Heal 75 Button Text", this, aUIObj.PlayerIdString)
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHeal100LbAnchor, CUserPageBtnHeal100RtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Heal 100 Button Text", this, aUIObj.PlayerIdString)
                    );
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnHealWoundsLbAnchor, CUserPageBtnHealWoundsRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Heal Wounds Button Text", this, aUIObj.PlayerIdString)
                    );
                }
            } else {
                ServerUsers.User serverUser = ServerUsers.Get(aPlayerId);
                aUIObj.AddLabel(
                    panel, CMainLblTitleLbAnchor, CMainLblTitleRtAnchor, CuiColor.TextAlt,
                    string.Format(
                        // If the username is null, we print the Steam64ID
                        lang.GetMessage("User Page Title Format", this, aUIObj.PlayerIdString), serverUser.username ?? aPlayerId.ToString(),
                        lang.GetMessage("Banned Label Text", this, aUIObj.PlayerIdString)
                    ), string.Empty, 18, TextAnchor.MiddleLeft
                );
                // Add user info labels
                aUIObj.AddLabel(
                    infoPanel, CUserPageLblIdLbAnchor, CUserPageLblIdRtAnchor, CuiColor.TextAlt,
                    string.Format(lang.GetMessage("Id Label Format", this, aUIObj.PlayerIdString), aPlayerId, string.Empty), string.Empty, 14,
                    TextAnchor.MiddleLeft
                );

                // --- Build player action panel
                if (VerifyPermission(aUIObj.PlayerId, CPermBan)) {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnBanLbAnchor, CUserPageBtnBanRtAnchor, CuiColor.Button, CuiColor.TextAlt,
                        lang.GetMessage("Unban Button Text", this, aUIObj.PlayerIdString), $"{CUnbanUserCmd} {aPlayerId}"
                    );
                } else {
                    aUIObj.AddButton(
                        actionPanel, CUserPageBtnBanLbAnchor, CUserPageBtnBanRtAnchor, CuiColor.ButtonInactive, CuiColor.Text,
                        lang.GetMessage("Unban Button Text", this, aUIObj.PlayerIdString)
                    );
                }
            }

            LogDebug("Built user information page");
            LogDebug($"Elapsed time (BuildUserPage): {Time.realtimeSinceStartup - aUIObj.StartTime:F8}");
        }

        /// <summary>
        /// Initiate the building of the UI page to show
        /// </summary>
        /// <param name="aPlayer">UI destination player</param>
        /// <param name="aPageType">Type of the page</param>
        /// <param name="aArg">Argument</param>
        /// <param name="aIndFiltered">Indicates if the output should be filtered</param>
        private void BuildUI(BasePlayer aPlayer, UiPage aPageType, string aArg = "", bool aIndFiltered = false) {
            // Initiate the new UI and panel
            Cui newUiLib = new Cui(aPlayer, LogDebug, LogError);
            newUiLib.AddElement(CBasePanelName, CMainPanel, CMainPanelName);
            BuildTabMenu(ref newUiLib, aPageType);
            LogDebug($"Elapsed time (BuildTabMenu): {Time.realtimeSinceStartup - newUiLib.StartTime:F8}");

            switch (aPageType) {
                case UiPage.Main: {
                        BuildMainPage(ref newUiLib);
                        break;
                    }
                case UiPage.PlayersOnline:
                case UiPage.PlayersOffline:
                case UiPage.PlayersBanned: {
                        int page = 0;

                        if (!string.IsNullOrEmpty(aArg))
                            int.TryParse(aArg, out page);

                        BuildUserBtnPage(ref newUiLib, aPageType, page, aIndFiltered);
                        break;
                    }
                case UiPage.PlayerPage:
                case UiPage.PlayerPageBanned: {
                        ulong playerId = aPlayer.userID;

                        if (!string.IsNullOrEmpty(aArg))
                            ulong.TryParse(aArg, out playerId);

                        BuildUserPage(ref newUiLib, aPageType, playerId);
                        break;
                    }
            }

            LogDebug($"BuildUI JSON value: \n{newUiLib.JSON}");
            // Cleanup any old/active UI and draw the new one
            CuiHelper.DestroyUi(aPlayer, CMainPanelName);
            LogDebug($"Elapsed time (CuiHelper.DestroyUi): {Time.realtimeSinceStartup - newUiLib.StartTime:F8}");
            newUiLib.Draw();
            LogDebug($"Elapsed time (newUiLib.Draw): {Time.realtimeSinceStartup - newUiLib.StartTime:F8}");
        }
        #endregion GUI build methods

        #region Config
        /// <summary>
        /// The config type class
        /// </summary>
        private class ConfigData
        {
            [DefaultValue(true)]
            [JsonProperty("Use Permission System", DefaultValueHandling = DefaultValueHandling.Populate)]
            public bool UsePermSystem { get; set; }
            [DefaultValue("")]
            [JsonProperty("Discord Webhook url for ban messages", DefaultValueHandling = DefaultValueHandling.Populate)]
            public string BanMsgWebhookUrl { get; set; }
            [DefaultValue("")]
            [JsonProperty("Discord Webhook url for kick messages", DefaultValueHandling = DefaultValueHandling.Populate)]
            public string KickMsgWebhookUrl { get; set; }
            [DefaultValue(true)]
            [JsonProperty("Broadcast Kicks", DefaultValueHandling = DefaultValueHandling.Populate)]
            public bool BroadcastKicks { get; set; }
            [DefaultValue(true)]
            [JsonProperty("Broadcast Bans", DefaultValueHandling = DefaultValueHandling.Populate)]
            public bool BroadcastBans { get; set; }
        }
        #endregion

        #region Constants
        private const bool CDebugEnabled = false;
        private const int CMaxPlayerCols = 5;
        private const int CMaxPlayerRows = 12;
        private const int CMaxPlayerButtons = CMaxPlayerCols * CMaxPlayerRows;
        private const string CBasePanelName = "PAdm_BasePanel";
        private const string CMainPanelName = "PAdm_MainPanel";
        private static readonly List<string> CUnknownNameList = new List<string> { "unnamed", "unknown" };

        #region Local commands
        private const string CPadminCmd = "padmin";
        private const string CCloseUiCmd = "playeradministration.closeui";
        private const string CSwitchUiCmd = "playeradministration.switchui";
        private const string CKickUserCmd = "playeradministration.kickuser";
        private const string CBanUserCmd = "playeradministration.banuser";
        private const string CMainPageBanByIdCmd = "playeradministration.mainpagebanbyid";
        private const string CUnbanUserCmd = "playeradministration.unbanuser";
        private const string CPermsCmd = "playeradministration.perms";
        private const string CMuteUserCmd = "playeradministration.muteuser";
        private const string CUnmuteUserCmd = "playeradministration.unmuteuser";
        private const string CFreezeCmd = "playeradministration.freeze";
        private const string CUnFreezeCmd = "playeradministration.unfreeze";
        private const string CClearUserInventoryCmd = "playeradministration.clearuserinventory";
        private const string CResetUserBPCmd = "playeradministration.resetuserblueprints";
        private const string CResetUserMetabolismCmd = "playeradministration.resetusermetabolism";
        private const string CRecoverUserMetabolismCmd = "playeradministration.recoverusermetabolism";
        private const string CHurtUserCmd = "playeradministration.hurtuser";
        private const string CKillUserCmd = "playeradministration.killuser";
        private const string CHealUserCmd = "playeradministration.healuser";
        private const string CTeleportToUserCmd = "playeradministration.tptouser";
        private const string CTeleportUserCmd = "playeradministration.tpuser";
        private const string CSpectateUserCmd = "playeradministration.spectateuser";
        private const string CMainPageBanIdInputTextCmd = "playeradministration.mainpagebanidinputtext";
        private const string CUserBtnPageSearchInputTextCmd = "playeradministration.userbtnpagesearchinputtext";
        private const string CUserPageReasonInputTextCmd = "playeradministration.userpagereasoninputtext";
        private const string CBackpackViewCmd = "playeradministration.viewbackpack";
        private const string CInventoryViewCmd = "playeradministration.viewinventory";
        private const string CGodmodeCmd = "playeradministration.godmode";
        private const string CUnGodmodeCmd = "playeradministration.ungodmode";
        #endregion Local commands

        #region Foreign commands
        private const string CFreezeFreezeCmd = "freeze";
        private const string CFreezeUnfreezeCmd = "unfreeze";
        #endregion Foreign commands

        #region Local Command Static Arguments
        private const string CCmdArgMain = "main";
        private const string CCmdArgPlayersOnline = "playersonline";
        private const string CCmdArgPlayersOnlineSearch = "playersonlinesearch";
        private const string CCmdArgPlayersOffline = "playersoffline";
        private const string CCmdArgPlayersOfflineSearch = "playersofflinesearch";
        private const string CCmdArgPlayersBanned = "playersbanned";
        private const string CCmdArgPlayersBannedSearch = "playersbannedsearch";
        private const string CCmdArgPlayerPage = "playerpage";
        private const string CCmdArgPlayerPageBanned = "playerpagebanned";
        #endregion Local Command Static Arguments

        #region Local permissions
        private const string CPermUiShow = "playeradministration.access.show";
        private const string CPermKick = "playeradministration.access.kick";
        private const string CPermBan = "playeradministration.access.ban";
        private const string CPermKill = "playeradministration.access.kill";
        private const string CPermPerms = "playeradministration.access.perms";
        private const string CPermMute = "playeradministration.access.mute";
        private const string CPermFreeze = "playeradministration.access.allowfreeze";
        private const string CPermClearInventory = "playeradministration.access.clearinventory";
        private const string CPermResetBP = "playeradministration.access.resetblueprint";
        private const string CPermResetMetabolism = "playeradministration.access.resetmetabolism";
        private const string CPermRecoverMetabolism = "playeradministration.access.recovermetabolism";
        private const string CPermHurt = "playeradministration.access.hurt";
        private const string CPermHeal = "playeradministration.access.heal";
        private const string CPermTeleport = "playeradministration.access.teleport";
        private const string CPermSpectate = "playeradministration.access.spectate";
        private const string CPermDetailInfo = "playeradministration.access.detailedinfo";
        private const string CPermProtectBan = "playeradministration.protect.ban";
        private const string CPermProtectHurt = "playeradministration.protect.hurt";
        private const string CPermProtectKick = "playeradministration.protect.kick";
        private const string CPermProtectKill = "playeradministration.protect.kill";
        private const string CPermProtectReset = "playeradministration.protect.reset";
        #endregion Local permissions

        #region Foreign permissions
        private const string CPermFreezeFrozen = "freeze.frozen";
        private const string CPermBackpacks = "backpacks.admin";
        private const string CPermInventory = "inventoryviewer.allowed";
        private const string CPermGodmode = "godmode.admin";
        #endregion Foreign permissions

        /* Define layout */
        #region Main bounds
        private static readonly CuiPoint CMainLbAnchor = new CuiPoint(0.03f, 0.15f);
        private static readonly CuiPoint CMainRtAnchor = new CuiPoint(0.97f, 0.97f);
        private static readonly CuiPoint CMainMenuHeaderContainerLbAnchor = new CuiPoint(0.005f, 0.937f);
        private static readonly CuiPoint CMainMenuHeaderContainerRtAnchor = new CuiPoint(0.995f, 0.99f);
        private static readonly CuiPoint CMainMenuTabBtnContainerLbAnchor = new CuiPoint(0.005f, 0.867f);
        private static readonly CuiPoint CMainMenuTabBtnContainerRtAnchor = new CuiPoint(0.995f, 0.927f);
        private static readonly CuiPoint CMainMenuHeaderLblLbAnchor = new CuiPoint(0f, 0f);
        private static readonly CuiPoint CMainMenuHeaderLblRtAnchor = new CuiPoint(1f, 1f);
        private static readonly CuiPoint CMainMenuCloseBtnLbAnchor = new CuiPoint(0.965f, 0f);
        private static readonly CuiPoint CMainMenuCloseBtnRtAnchor = new CuiPoint(1f, 1f);
        private static readonly CuiPoint CMainPanelLbAnchor = new CuiPoint(0.005f, 0.01f);
        private static readonly CuiPoint CMainPanelRtAnchor = new CuiPoint(0.995f, 0.857f);
        private static readonly CuiPoint CMainLblTitleLbAnchor = new CuiPoint(0.005f, 0.93f);
        private static readonly CuiPoint CMainLblTitleRtAnchor = new CuiPoint(0.995f, 0.99f);
        #endregion Main bounds

        #region Main page bounds
        private static readonly CuiPoint CMainPageLblBanByIdTitleLbAnchor = new CuiPoint(0.005f, 0.84f);
        private static readonly CuiPoint CMainPageLblBanByIdTitleRtAnchor = new CuiPoint(0.995f, 0.89f);
        private static readonly CuiPoint CMainPageLblBanByIdLbAnchor = new CuiPoint(0.005f, 0.76f);
        private static readonly CuiPoint CMainPageLblBanByIdRtAnchor = new CuiPoint(0.05f, 0.81f);
        private static readonly CuiPoint CMainPagePanelBanByIdLbAnchor = new CuiPoint(0.055f, 0.76f);
        private static readonly CuiPoint CMainPagePanelBanByIdRtAnchor = new CuiPoint(0.305f, 0.81f);
        private static readonly CuiPoint CMainPageEdtBanByIdLbAnchor = new CuiPoint(0.005f, 0f);
        private static readonly CuiPoint CMainPageEdtBanByIdRtAnchor = new CuiPoint(0.995f, 1f);
        private static readonly CuiPoint CMainPageBtnBanByIdLbAnchor = new CuiPoint(0.315f, 0.76f);
        private static readonly CuiPoint CMainPageBtnBanByIdRtAnchor = new CuiPoint(0.365f, 0.81f);
        #endregion Main page bounds

        #region User button page bounds
        private static readonly CuiPoint CUserBtnPageLblTitleLbAnchor = new CuiPoint(0.005f, 0.93f);
        private static readonly CuiPoint CUserBtnPageLblTitleRtAnchor = new CuiPoint(0.495f, 0.99f);
        private static readonly CuiPoint CUserBtnPageLblSearchLbAnchor = new CuiPoint(0.52f, 0.93f);
        private static readonly CuiPoint CUserBtnPageLblSearchRtAnchor = new CuiPoint(0.565f, 0.99f);
        private static readonly CuiPoint CUserBtnPagePanelSearchInputLbAnchor = new CuiPoint(0.57f, 0.94f);
        private static readonly CuiPoint CUserBtnPagePanelSearchInputRtAnchor = new CuiPoint(0.945f, 0.99f);
        private static readonly CuiPoint CUserBtnPageEdtSearchInputLbAnchor = new CuiPoint(0.005f, 0f);
        private static readonly CuiPoint CUserBtnPageEdtSearchInputRtAnchor = new CuiPoint(0.995f, 1f);
        private static readonly CuiPoint CUserBtnPageBtnSearchLbAnchor = new CuiPoint(0.95f, 0.94f);
        private static readonly CuiPoint CUserBtnPageBtnSearchRtAnchor = new CuiPoint(0.995f, 0.99f);
        private static readonly CuiPoint CUserBtnPageBtnPreviousLbAnchor = new CuiPoint(0.005f, 0.01f);
        private static readonly CuiPoint CUserBtnPageBtnPreviousRtAnchor = new CuiPoint(0.035f, 0.06f);
        private static readonly CuiPoint CUserBtnPageBtnNextLbAnchor = new CuiPoint(0.96f, 0.01f);
        private static readonly CuiPoint CUserBtnPageBtnNextRtAnchor = new CuiPoint(0.995f, 0.06f);
        #endregion User button page bounds

        #region User page panel bounds
        private static readonly CuiPoint CUserPageInfoPanelLbAnchor = new CuiPoint(0.005f, 0.01f);
        private static readonly CuiPoint CUserPageInfoPanelRtAnchor = new CuiPoint(0.28f, 0.92f);
        private static readonly CuiPoint CUserPageActionPanelLbAnchor = new CuiPoint(0.285f, 0.01f);
        private static readonly CuiPoint CUserPageActionPanelRtAnchor = new CuiPoint(0.995f, 0.92f);
        #region User page title label bounds
        private static readonly CuiPoint CUserPageLblinfoTitleLbAnchor = new CuiPoint(0.025f, 0.94f);
        private static readonly CuiPoint CUserPageLblinfoTitleRtAnchor = new CuiPoint(0.975f, 0.99f);
        private static readonly CuiPoint CUserPageLblActionTitleLbAnchor = new CuiPoint(0.01f, 0.94f);
        private static readonly CuiPoint CUserPageLblActionTitleRtAnchor = new CuiPoint(0.99f, 0.99f);
        #endregion User page title label bounds
        #region User page info label bounds
        // Top part
        private static readonly CuiPoint CUserPageLblIdLbAnchor = new CuiPoint(0.025f, 0.88f);
        private static readonly CuiPoint CUserPageLblIdRtAnchor = new CuiPoint(0.975f, 0.92f);
        private static readonly CuiPoint CUserPageLblAuthLbAnchor = new CuiPoint(0.025f, 0.835f);
        private static readonly CuiPoint CUserPageLblAuthRtAnchor = new CuiPoint(0.975f, 0.875f);
        private static readonly CuiPoint CUserPageLblConnectLbAnchor = new CuiPoint(0.025f, 0.79f);
        private static readonly CuiPoint CUserPageLblConnectRtAnchor = new CuiPoint(0.975f, 0.83f);
        private static readonly CuiPoint CUserPageLblSleepLbAnchor = new CuiPoint(0.025f, 0.745f);
        private static readonly CuiPoint CUserPageLblSleepRtAnchor = new CuiPoint(0.975f, 0.785f);
        private static readonly CuiPoint CUserPageLblFlagLbAnchor = new CuiPoint(0.025f, 0.70f);
        private static readonly CuiPoint CUserPageLblFlagRtAnchor = new CuiPoint(0.975f, 0.74f);
        private static readonly CuiPoint CUserPageLblPosLbAnchor = new CuiPoint(0.025f, 0.655f);
        private static readonly CuiPoint CUserPageLblPosRtAnchor = new CuiPoint(0.975f, 0.695f);
        private static readonly CuiPoint CUserPageLblRotLbAnchor = new CuiPoint(0.025f, 0.61f);
        private static readonly CuiPoint CUserPageLblRotRtAnchor = new CuiPoint(0.975f, 0.65f);
        private static readonly CuiPoint CUserPageLblAdminCheatLbAnchor = new CuiPoint(0.025f, 0.555f);
        private static readonly CuiPoint CUserPageLblAdminCheatRtAnchor = new CuiPoint(0.975f, 0.605f);
        private static readonly CuiPoint CUserPageLblIdleLbAnchor = new CuiPoint(0.025f, 0.51f);
        private static readonly CuiPoint CUserPageLblIdleRtAnchor = new CuiPoint(0.975f, 0.55f);
        private static readonly CuiPoint CUserPageLblUsrNetAddrLbAnchor = new CuiPoint(0.025f, 0.465f);
        private static readonly CuiPoint CUserPageLblUsrNetAddrRtAnchor = new CuiPoint(0.975f, 0.505f);
        private static readonly CuiPoint CUserPageLblUsrAvrPingLbAnchor = new CuiPoint(0.025f, 0.42f);
        private static readonly CuiPoint CUserPageLblUsrAvrPingRtAnchor = new CuiPoint(0.975f, 0.46f);

        private static readonly CuiPoint CUserPageLblBalanceLbAnchor = new CuiPoint(0.025f, 0.375f);
        private static readonly CuiPoint CUserPageLblBalanceRtAnchor = new CuiPoint(0.975f, 0.415f);
        private static readonly CuiPoint CUserPageLblRewardPointsLbAnchor = new CuiPoint(0.025f, 0.33f);
        private static readonly CuiPoint CUserPageLblRewardPointsRtAnchor = new CuiPoint(0.975f, 0.37f);
        private static readonly CuiPoint CUserPageLblGodmodeLbAnchor = new CuiPoint(0.025f, 0.285f);
        private static readonly CuiPoint CUserPageLblGodmodeRtAnchor = new CuiPoint(0.975f, 0.325f);
        // Bottom part
        private static readonly CuiPoint CUserPageLblHealthLbAnchor = new CuiPoint(0.025f, 0.195f);
        private static readonly CuiPoint CUserPageLblHealthRtAnchor = new CuiPoint(0.975f, 0.235f);
        private static readonly CuiPoint CUserPageLblCalLbAnchor = new CuiPoint(0.025f, 0.145f);
        private static readonly CuiPoint CUserPageLblCalRtAnchor = new CuiPoint(0.5f, 0.19f);
        private static readonly CuiPoint CUserPageLblHydraLbAnchor = new CuiPoint(0.5f, 0.145f);
        private static readonly CuiPoint CUserPageLblHydraRtAnchor = new CuiPoint(0.975f, 0.19f);
        private static readonly CuiPoint CUserPageLblTempLbAnchor = new CuiPoint(0.025f, 0.10f);
        private static readonly CuiPoint CUserPageLblTempRtAnchor = new CuiPoint(0.5f, 0.14f);
        private static readonly CuiPoint CUserPageLblWetLbAnchor = new CuiPoint(0.5f, 0.10f);
        private static readonly CuiPoint CUserPageLblWetRtAnchor = new CuiPoint(0.975f, 0.14f);
        private static readonly CuiPoint CUserPageLblComfortLbAnchor = new CuiPoint(0.025f, 0.055f);
        private static readonly CuiPoint CUserPageLblComfortRtAnchor = new CuiPoint(0.5f, 0.095f);
        private static readonly CuiPoint CUserPageLblBleedLbAnchor = new CuiPoint(0.5f, 0.055f);
        private static readonly CuiPoint CUserPageLblBleedRtAnchor = new CuiPoint(0.975f, 0.095f);
        private static readonly CuiPoint CUserPageLblRads1LbAnchor = new CuiPoint(0.025f, 0.01f);
        private static readonly CuiPoint CUserPageLblRads1RtAnchor = new CuiPoint(0.5f, 0.05f);
        private static readonly CuiPoint CUserPageLblRads2LbAnchor = new CuiPoint(0.5f, 0.01f);
        private static readonly CuiPoint CUserPageLblRads2RtAnchor = new CuiPoint(0.975f, 0.05f);
        #endregion User page info label bounds
        #region User page button bounds
        // Row 1
        private static readonly CuiPoint CUserPageBtnBanLbAnchor = new CuiPoint(0.01f, 0.86f);
        private static readonly CuiPoint CUserPageBtnBanRtAnchor = new CuiPoint(0.16f, 0.92f);
        private static readonly CuiPoint CUserPageBtnKickLbAnchor = new CuiPoint(0.17f, 0.86f);
        private static readonly CuiPoint CUserPageBtnKickRtAnchor = new CuiPoint(0.32f, 0.92f);
        private static readonly CuiPoint CUserPageLblReasonLbAnchor = new CuiPoint(0.33f, 0.86f);
        private static readonly CuiPoint CUserPageLblReasonRtAnchor = new CuiPoint(0.48f, 0.92f);
        private static readonly CuiPoint CUserPagePanelReasonLbAnchor = new CuiPoint(0.49f, 0.86f);
        private static readonly CuiPoint CUserPagePanelReasonRtAnchor = new CuiPoint(0.99f, 0.92f);
        private static readonly CuiPoint CUserPageEdtReasonLbAnchor = new CuiPoint(0.005f, 0f);
        private static readonly CuiPoint CUserPageEdtReasonRtAnchor = new CuiPoint(0.995f, 1f);
        // Row 2
        private static readonly CuiPoint CUserPageBtnUnmuteLbAnchor = new CuiPoint(0.01f, 0.78f);
        private static readonly CuiPoint CUserPageBtnUnmuteRtAnchor = new CuiPoint(0.16f, 0.84f);
        private static readonly CuiPoint CUserPageBtnMuteLbAnchor = new CuiPoint(0.17f, 0.78f);
        private static readonly CuiPoint CUserPageBtnMuteRtAnchor = new CuiPoint(0.32f, 0.84f);
        private static readonly CuiPoint CUserPageBtnMuteFifteenLbAnchor = new CuiPoint(0.33f, 0.78f);
        private static readonly CuiPoint CUserPageBtnMuteFifteenRtAnchor = new CuiPoint(0.48f, 0.84f);
        private static readonly CuiPoint CUserPageBtnMuteThirtyLbAnchor = new CuiPoint(0.49f, 0.78f);
        private static readonly CuiPoint CUserPageBtnMuteThirtyRtAnchor = new CuiPoint(0.64f, 0.84f);
        private static readonly CuiPoint CUserPageBtnMuteSixtyLbAnchor = new CuiPoint(0.65f, 0.78f);
        private static readonly CuiPoint CUserPageBtnMuteSixtyRtAnchor = new CuiPoint(0.80f, 0.84f);
        // Row 3
        private static readonly CuiPoint CUserPageBtnUnFreezeLbAnchor = new CuiPoint(0.01f, 0.70f);
        private static readonly CuiPoint CUserPageBtnUnFreezeRtAnchor = new CuiPoint(0.16f, 0.76f);
        private static readonly CuiPoint CUserPageBtnFreezeLbAnchor = new CuiPoint(0.17f, 0.70f);
        private static readonly CuiPoint CUserPageBtnFreezeRtAnchor = new CuiPoint(0.32f, 0.76f);
        // Row 4
        private static readonly CuiPoint CUserPageBtnClearInventoryLbAnchor = new CuiPoint(0.01f, 0.62f);
        private static readonly CuiPoint CUserPageBtnClearInventoryRtAnchor = new CuiPoint(0.16f, 0.68f);
        private static readonly CuiPoint CUserPageBtnResetBPLbAnchor = new CuiPoint(0.17f, 0.62f);
        private static readonly CuiPoint CUserPageBtnResetBPRtAnchor = new CuiPoint(0.32f, 0.68f);
        private static readonly CuiPoint CUserPageBtnResetMetabolismLbAnchor = new CuiPoint(0.33f, 0.62f);
        private static readonly CuiPoint CUserPageBtnResetMetabolismRtAnchor = new CuiPoint(0.48f, 0.68f);
        private static readonly CuiPoint CUserPageBtnRecoverMetabolismLbAnchor = new CuiPoint(0.49f, 0.62f);
        private static readonly CuiPoint CUserPageBtnRecoverMetabolismRtAnchor = new CuiPoint(0.64f, 0.68f);
        // Row 5
        private static readonly CuiPoint CUserPageBtnTeleportToLbAnchor = new CuiPoint(0.01f, 0.54f);
        private static readonly CuiPoint CUserPageBtnTeleportToRtAnchor = new CuiPoint(0.16f, 0.60f);
        private static readonly CuiPoint CUserPageBtnTeleportLbAnchor = new CuiPoint(0.17f, 0.54f);
        private static readonly CuiPoint CUserPageBtnTeleportRtAnchor = new CuiPoint(0.32f, 0.60f);
        private static readonly CuiPoint CUserPageBtnSpectateLbAnchor = new CuiPoint(0.33f, 0.54f);
        private static readonly CuiPoint CUserPageBtnSpectateRtAnchor = new CuiPoint(0.48f, 0.60f);
        // Row 6
        private static readonly CuiPoint CUserPageBtnPermsLbAnchor = new CuiPoint(0.01f, 0.46f);
        private static readonly CuiPoint CUserPageBtnPermsRtAnchor = new CuiPoint(0.16f, 0.52f);
        private static readonly CuiPoint CUserPageBtnBackpacksLbAnchor = new CuiPoint(0.17f, 0.46f);
        private static readonly CuiPoint CUserPageBtnBackpacksRtAnchor = new CuiPoint(0.32f, 0.52f);
        private static readonly CuiPoint CUserPageBtnInventoryLbAnchor = new CuiPoint(0.33f, 0.46f);
        private static readonly CuiPoint CUserPageBtnInventoryRtAnchor = new CuiPoint(0.48f, 0.52f);
        // Row 7
        private static readonly CuiPoint CUserPageBtnGodmodeLbAnchor = new CuiPoint(0.01f, 0.38f);
        private static readonly CuiPoint CUserPageBtnGodmodeRtAnchor = new CuiPoint(0.16f, 0.44f);
        private static readonly CuiPoint CUserPageBtnUnGodmodeLbAnchor = new CuiPoint(0.17f, 0.38f);
        private static readonly CuiPoint CUserPageBtnUnGodmodeRtAnchor = new CuiPoint(0.32f, 0.44f);

        // Row 11
        private static readonly CuiPoint CUserPageBtnHurt25LbAnchor = new CuiPoint(0.01f, 0.10f);
        private static readonly CuiPoint CUserPageBtnHurt25RtAnchor = new CuiPoint(0.16f, 0.16f);
        private static readonly CuiPoint CUserPageBtnHurt50LbAnchor = new CuiPoint(0.17f, 0.10f);
        private static readonly CuiPoint CUserPageBtnHurt50RtAnchor = new CuiPoint(0.32f, 0.16f);
        private static readonly CuiPoint CUserPageBtnHurt75LbAnchor = new CuiPoint(0.33f, 0.10f);
        private static readonly CuiPoint CUserPageBtnHurt75RtAnchor = new CuiPoint(0.48f, 0.16f);
        private static readonly CuiPoint CUserPageBtnHurt100LbAnchor = new CuiPoint(0.49f, 0.10f);
        private static readonly CuiPoint CUserPageBtnHurt100RtAnchor = new CuiPoint(0.64f, 0.16f);
        private static readonly CuiPoint CUserPageBtnKillLbAnchor = new CuiPoint(0.65f, 0.10f);
        private static readonly CuiPoint CUserPageBtnKillRtAnchor = new CuiPoint(0.80f, 0.16f);
        // Row 12
        private static readonly CuiPoint CUserPageBtnHeal25LbAnchor = new CuiPoint(0.01f, 0.02f);
        private static readonly CuiPoint CUserPageBtnHeal25RtAnchor = new CuiPoint(0.16f, 0.08f);
        private static readonly CuiPoint CUserPageBtnHeal50LbAnchor = new CuiPoint(0.17f, 0.02f);
        private static readonly CuiPoint CUserPageBtnHeal50RtAnchor = new CuiPoint(0.32f, 0.08f);
        private static readonly CuiPoint CUserPageBtnHeal75LbAnchor = new CuiPoint(0.33f, 0.02f);
        private static readonly CuiPoint CUserPageBtnHeal75RtAnchor = new CuiPoint(0.48f, 0.08f);
        private static readonly CuiPoint CUserPageBtnHeal100LbAnchor = new CuiPoint(0.49f, 0.02f);
        private static readonly CuiPoint CUserPageBtnHeal100RtAnchor = new CuiPoint(0.64f, 0.08f);
        private static readonly CuiPoint CUserPageBtnHealWoundsLbAnchor = new CuiPoint(0.65f, 0.02f);
        private static readonly CuiPoint CUserPageBtnHealWoundsRtAnchor = new CuiPoint(0.80f, 0.08f);
        #endregion User page button bounds
        #endregion User page panel bounds

        #region Predefined UI elements
        private static readonly CuiPanel CBasePanel = new CuiPanel {
            RectTransform =
            {
                AnchorMin = "0 0",
                AnchorMax = "1 1",
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            },
            CursorEnabled = true,
            Image = new CuiImageComponent { Color = CuiColor.None.ToString() }
        };

        private static readonly CuiPanel CMainPanel = new CuiPanel {
            RectTransform =
            {
                AnchorMin = CMainLbAnchor.ToString(),
                AnchorMax = CMainRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            },
            CursorEnabled = true,
            Image = new CuiImageComponent { Color = CuiColor.BackgroundDark.ToString() }
        };

        private static readonly CuiPanel CTabHeaderPanel = new CuiPanel {
            RectTransform =
            {
                AnchorMin = CMainMenuHeaderContainerLbAnchor.ToString(),
                AnchorMax = CMainMenuHeaderContainerRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            },
            CursorEnabled = true,
            Image = new CuiImageComponent { Color = CuiColor.None.ToString() }
        };

        private static readonly CuiPanel CTabTabBtnPanel = new CuiPanel {
            RectTransform =
            {
                AnchorMin = CMainMenuTabBtnContainerLbAnchor.ToString(),
                AnchorMax = CMainMenuTabBtnContainerRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            },
            CursorEnabled = true,
            Image = new CuiImageComponent { Color = CuiColor.Background.ToString() }
        };

        private static readonly CuiPanel CMainPagePanel = new CuiPanel {
            RectTransform =
            {
                AnchorMin = CMainPanelLbAnchor.ToString(),
                AnchorMax = CMainPanelRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            },
            CursorEnabled = true,
            Image = new CuiImageComponent { Color = CuiColor.Background.ToString() }
        };

        private static readonly CuiPanel CBanByIdGroupPanel = new CuiPanel {
            RectTransform =
            {
                AnchorMin = CMainPagePanelBanByIdLbAnchor.ToString(),
                AnchorMax = CMainPagePanelBanByIdRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            },
            CursorEnabled = true,
            Image = new CuiImageComponent { Color = CuiColor.BackgroundDark.ToString() }
        };

        private static readonly CuiPanel CUserBtnPageSearchInputPanel = new CuiPanel {
            RectTransform =
            {
                AnchorMin = CUserBtnPagePanelSearchInputLbAnchor.ToString(),
                AnchorMax = CUserBtnPagePanelSearchInputRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            },
            CursorEnabled = true,
            Image = new CuiImageComponent { Color = CuiColor.BackgroundDark.ToString() }
        };

        private static readonly CuiLabel CTabMenuHeaderLbl = new CuiLabel {
            Text =
            {
                Text = "Player Administration",
                FontSize = 22,
                Align = TextAnchor.MiddleCenter,
                Color = CuiColor.TextTitle.ToString()
            },
            RectTransform =
            {
                AnchorMin = CMainMenuHeaderLblLbAnchor.ToString(),
                AnchorMax = CMainMenuHeaderLblRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            }
        };

        private static readonly CuiLabel CMainPageTitleLbl = new CuiLabel {
            Text =
            {
                Text = "Main",
                FontSize = 18,
                Align = TextAnchor.MiddleLeft,
                Color = CuiColor.TextAlt.ToString()
            },
            RectTransform =
            {
                AnchorMin = CMainLblTitleLbAnchor.ToString(),
                AnchorMax = CMainLblTitleRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            }
        };

        private static readonly CuiButton CTabMenuCloseBtn = new CuiButton {
            Button =
            {
                Command = CCloseUiCmd,
                Close = string.Empty,
                Color = CuiColor.ButtonDecline.ToString()
            },
            RectTransform =
            {
                AnchorMin = CMainMenuCloseBtnLbAnchor.ToString(),
                AnchorMax = CMainMenuCloseBtnRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            },
            Text =
            {
                Text = "X",
                FontSize = 22,
                Align = TextAnchor.MiddleCenter,
                Color = CuiColor.TextAlt.ToString()
            }
        };

        private static readonly CuiButton CBanByIdActiveBtn = new CuiButton {
            Button =
            {
                Command = CMainPageBanByIdCmd,
                Close = string.Empty,
                Color = CuiColor.ButtonDanger.ToString()
            },
            RectTransform =
            {
                AnchorMin = CMainPageBtnBanByIdLbAnchor.ToString(),
                AnchorMax = CMainPageBtnBanByIdRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            },
            Text =
            {
                Text = "Ban",
                FontSize = 14,
                Align = TextAnchor.MiddleCenter,
                Color = CuiColor.TextAlt.ToString()
            }
        };

        private static readonly CuiButton CBanByIdInactiveBtn = new CuiButton {
            Button =
            {
                Command = string.Empty,
                Close = string.Empty,
                Color = CuiColor.ButtonInactive.ToString()
            },
            RectTransform =
            {
                AnchorMin = CMainPageBtnBanByIdLbAnchor.ToString(),
                AnchorMax = CMainPageBtnBanByIdRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            },
            Text =
            {
                Text = "Ban",
                FontSize = 14,
                Align = TextAnchor.MiddleCenter,
                Color = CuiColor.TextAlt.ToString()
            }
        };

        private static readonly CuiButton CUserBtnPagePreviousInactiveBtn = new CuiButton {
            Button =
            {
                Command = string.Empty,
                Close = string.Empty,
                Color = CuiColor.ButtonInactive.ToString()
            },
            RectTransform =
            {
                AnchorMin = CUserBtnPageBtnPreviousLbAnchor.ToString(),
                AnchorMax = CUserBtnPageBtnPreviousRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            },
            Text =
            {
                Text = "<<",
                FontSize = 18,
                Align = TextAnchor.MiddleCenter,
                Color = CuiColor.TextAlt.ToString()
            }
        };

        private static readonly CuiButton CUserBtnPageNextInactiveBtn = new CuiButton {
            Button =
            {
                Command = string.Empty,
                Close = string.Empty,
                Color = CuiColor.ButtonInactive.ToString()
            },
            RectTransform =
            {
                AnchorMin = CUserBtnPageBtnNextLbAnchor.ToString(),
                AnchorMax = CUserBtnPageBtnNextRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            },
            Text =
            {
                Text = ">>",
                FontSize = 18,
                Align = TextAnchor.MiddleCenter,
                Color = CuiColor.TextAlt.ToString()
            }
        };

        private static readonly CuiInputField CBanByIdEdt = new CuiInputField {
            InputField =
            {
                Text = string.Empty,
                FontSize = 14,
                Align = TextAnchor.MiddleLeft,
                Color = CuiColor.TextAlt.ToString(),
                CharsLimit = 24,
                Command = CMainPageBanIdInputTextCmd,
                IsPassword = false
            },
            RectTransform =
            {
                AnchorMin = CMainPageEdtBanByIdLbAnchor.ToString(),
                AnchorMax = CMainPageEdtBanByIdRtAnchor.ToString(),
                OffsetMin = "0 0",
                OffsetMax = "0 0"
            }
        };
        #endregion Predefined UI elements
        #endregion Constants

        #region Variables
        private ConfigData FConfigData;
        private readonly Dictionary<ulong, string> FMainPageBanIdInputText = new Dictionary<ulong, string>();     // Format: <userId, text>
        private readonly Dictionary<ulong, string> FUserBtnPageSearchInputText = new Dictionary<ulong, string>(); // Format: <userId, text>
        private readonly Dictionary<ulong, string> FUserPageReasonInputText = new Dictionary<ulong, string>();    // Format: <userId, text>
        private readonly Dictionary<ulong, string> FOnlineUserList = new Dictionary<ulong, string>();             // Format: <userId, username>
        private readonly Dictionary<ulong, string> FOfflineUserList = new Dictionary<ulong, string>();            // Format: <userId, username>
        #endregion Variables

#pragma warning disable IDE0051, IDE0060 // Remove unused private members, unused parameter
        #region Hooks
        void Loaded() {
            LoadConfig();
            permission.RegisterPermission(CPermUiShow, this);
            permission.RegisterPermission(CPermKick, this);
            permission.RegisterPermission(CPermBan, this);
            permission.RegisterPermission(CPermKill, this);
            permission.RegisterPermission(CPermPerms, this);
            permission.RegisterPermission(CPermMute, this);
            permission.RegisterPermission(CPermFreeze, this);
            permission.RegisterPermission(CPermClearInventory, this);
            permission.RegisterPermission(CPermResetBP, this);
            permission.RegisterPermission(CPermResetMetabolism, this);
            permission.RegisterPermission(CPermRecoverMetabolism, this);
            permission.RegisterPermission(CPermHurt, this);
            permission.RegisterPermission(CPermHeal, this);
            permission.RegisterPermission(CPermTeleport, this);
            permission.RegisterPermission(CPermSpectate, this);
            permission.RegisterPermission(CPermDetailInfo, this);
            permission.RegisterPermission(CPermProtectBan, this);
            permission.RegisterPermission(CPermProtectHurt, this);
            permission.RegisterPermission(CPermProtectKick, this);
            permission.RegisterPermission(CPermProtectKill, this);
            permission.RegisterPermission(CPermProtectReset, this);

            if (UpgradeTo156())
                LogDebug("Upgraded the config to version 1.5.6");

            if (UpgradeTo1519())
                LogDebug("Upgraded the config to version 1.5.19");
        }

        void Unload() {
            foreach (BasePlayer player in Player.Players) {
                CuiHelper.DestroyUi(player, CBasePanelName);

                if (FMainPageBanIdInputText.ContainsKey(player.userID))
                    FMainPageBanIdInputText.Remove(player.userID);

                if (FUserBtnPageSearchInputText.ContainsKey(player.userID))
                    FUserBtnPageSearchInputText.Remove(player.userID);

                if (FUserPageReasonInputText.ContainsKey(player.userID))
                    FUserPageReasonInputText.Remove(player.userID);
            }

            FOnlineUserList.Clear();
            FOfflineUserList.Clear();
        }

        void OnServerInitialized() {
            foreach (BasePlayer user in Player.Players) {
                if (user.IsNpc)
                    continue;

                ServerUsers.User servUser = ServerUsers.Get(user.userID);

                if (servUser == null || servUser?.group != ServerUsers.UserGroup.Banned)
                    FOnlineUserList[user.userID] = user.displayName;
            }

            foreach (BasePlayer user in Player.Sleepers) {
                if (user.IsNpc)
                    continue;

                ServerUsers.User servUser = ServerUsers.Get(user.userID);

                if (servUser == null || servUser?.group != ServerUsers.UserGroup.Banned)
                    FOfflineUserList[user.userID] = user.displayName;
            }
        }

        void OnUserConnected(IPlayer aPlayer) {
            BasePlayer user = BasePlayer.Find(aPlayer.Id) ?? BasePlayer.FindSleeping(aPlayer.Id);

            if (user.IsNpc)
                return;

            if (FOfflineUserList.ContainsKey(user.userID))
                FOfflineUserList.Remove(user.userID);

            FOnlineUserList[user.userID] = user.displayName;
        }

        void OnUserDisconnected(IPlayer aPlayer) {
            BasePlayer user = BasePlayer.Find(aPlayer.Id) ?? BasePlayer.FindSleeping(aPlayer.Id);

            if (user.IsNpc)
                return;

            if (FMainPageBanIdInputText.ContainsKey(user.userID))
                FMainPageBanIdInputText.Remove(user.userID);

            if (FUserBtnPageSearchInputText.ContainsKey(user.userID))
                FUserBtnPageSearchInputText.Remove(user.userID);

            if (FUserPageReasonInputText.ContainsKey(user.userID))
                FUserPageReasonInputText.Remove(user.userID);

            if (FOnlineUserList.ContainsKey(user.userID))
                FOnlineUserList.Remove(user.userID);

            FOfflineUserList[user.userID] = user.displayName;
        }

        void OnUserNameUpdated(string aId, string aOldName, string aNewName) {
            ulong userId;

            if (!ulong.TryParse(aId, out userId)) {
                LogError($"OnUserNameUpdated > Unable to parse aId \"{aId}\" into ulong");
                return;
            }

            if (FOnlineUserList.ContainsKey(userId))
                FOnlineUserList[userId] = aNewName;

            if (FOfflineUserList.ContainsKey(userId))
                FOfflineUserList[userId] = aNewName;
        }

        protected override void LoadConfig() {
            base.LoadConfig();

            try {
                FConfigData = Config.ReadObject<ConfigData>();

                if (FConfigData == null)
                    LoadDefaultConfig();

                if (UpgradeTo1310())
                    LogDebug("Upgraded the config to version 1.3.10");

                if (UpgradeTo1313())
                    LogDebug("Upgraded the config to version 1.3.13");

                if (UpgradeTo164())
                    LogDebug("Upgraded the config to version 1.6.4");
            } catch {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() {
            FConfigData = new ConfigData {
                UsePermSystem = true,
                BanMsgWebhookUrl = string.Empty,
                KickMsgWebhookUrl = string.Empty,
                BroadcastKicks = true,
                BroadcastBans = true
            };
            LogDebug("Default config loaded");
        }

        protected override void LoadDefaultMessages() {
            lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    { "Permission Error Text", "You do not have the required permissions to use this command." },
                    { "Permission Error Log Text", "{0}: Tried to execute a command requiring the '{1}' permission" },
                    { "Kick Reason Message Text", "Administrative decision" },
                    { "Ban Reason Message Text", "Administrative decision" },
                    { "Protection Active Text", "Unable to perform this action, protection is enabled for this user" },
                    { "Dead Player Error Text", "Unable to perform this action, the target player is dead" },

                    { "Kick Broadcast Message Format", "Player {0} has been kicked: {1}" },
                    { "Ban Broadcast Message Format", "Player {0} has been banned: {1}" },

                    { "Never Label Text", "Never" },
                    { "OffLine Label Text", "Offline" },
                    { "Banned Label Text", " (Banned)" },
                    { "Dev Label Text", " (Developer)" },
                    { "Connected Label Text", "Connected" },
                    { "Disconnected Label Text", "Disconnected" },
                    { "Sleeping Label Text", "Sleeping" },
                    { "Awake Label Text", "Awake" },
                    { "Alive Label Text", "Alive" },
                    { "Dead Label Text", "Dead" },
                    { "Flying Label Text", " Flying" },
                    { "Mounted Label Text", " Mounted" },

                    { "User Button Page Title Text", "Click a username to go to the player's control page" },
                    { "User Page Title Format", "Control page for player '{0}'{1}" },

                    { "Ban By ID Title Text", "Ban a user by ID" },
                    { "Ban By ID Label Text", "User ID:" },
                    { "Search Label Text", "Search:" },
                    { "Player Info Label Text", "Player information:" },
                    { "Player Actions Label Text", "Player actions:" },

                    { "Id Label Format", "ID: {0}{1}" },
                    { "Auth Level Label Format", "Auth level: {0}" },
                    { "Connection Label Format", "Connection: {0}" },
                    { "Status Label Format", "Status: {0} and {1}" },
                    { "Flags Label Format", "Flags:{0}{1}" },
                    { "Position Label Format", "Position: {0}" },
                    { "Rotation Label Format", "Rotation: {0}" },
                    { "Last Admin Cheat Label Format", "Last admin cheat: {0}" },
                    { "Idle Time Label Format", "Idle time: {0} seconds" },
                    { "Player Ping Label Format", "Avr. Ping: {0} ms" },
                    { "Player Address Label Format", "IP Address: {0} " },
                    { "Economics Balance Label Format", "Balance: {0} coins" },
                    { "ServerRewards Points Label Format", "Reward points: {0}" },
                    { "Health Label Format", "Health: {0}" },
                    { "Calories Label Format", "Calories: {0}" },
                    { "Hydration Label Format", "Hydration: {0}" },
                    { "Temp Label Format", "Temperature: {0}" },
                    { "Wetness Label Format", "Wetness: {0}" },
                    { "Comfort Label Format", "Comfort: {0}" },
                    { "Bleeding Label Format", "Bleeding: {0}" },
                    { "Radiation Label Format", "Radiation: {0}" },
                    { "Radiation Protection Label Format", "Protection: {0}" },
                    { "Godmode Status Label Format", "Godmode active: {0}" },

                    { "Main Tab Text", "Main" },
                    { "Online Player Tab Text", "Online Players" },
                    { "Offline Player Tab Text", "Offline Players" },
                    { "Banned Player Tab Text", "Banned Players" },

                    { "Go Button Text", "Go" },

                    { "Unban Button Text", "Unban" },
                    { "Ban Button Text", "Ban" },
                    { "Kick Button Text", "Kick" },
                    { "Reason Input Label Text", "Reason:" },

                    { "Unmute Button Text", "Unmute" },
                    { "Mute Button Text", "Mute" },
                    { "Mute Button Text 15", "Mute 15 Min" },
                    { "Mute Button Text 30", "Mute 30 Min" },
                    { "Mute Button Text 60", "Mute 60 Min" },

                    { "UnFreeze Button Text", "UnFreeze" },
                    { "Freeze Button Text", "Freeze" },
                    { "Freeze Not Installed Button Text", "Freeze Not Installed" },

                    { "Clear Inventory Button Text", "Clear Inventory" },
                    { "Reset Blueprints Button Text", "Reset Blueprints" },
                    { "Reset Metabolism Button Text", "Reset Metabolism" },
                    { "Recover Metabolism Button Text", "Recover Metabolism" },

                    { "Teleport To Player Button Text", "Teleport To Player" },
                    { "Teleport Player Button Text", "Teleport Player" },
                    { "Spectate Player Button Text", "Spectate Player" },

                    { "Perms Button Text", "Permissions" },
                    { "Perms Not Installed Button Text", "Perms Not Installed" },

                    { "Backpacks Button Text", "View Backpack" },
                    { "Backpacks Not Installed Button Text", "Backpacks Not Installed" },

                    { "Inventory Button Text", "View Inventory" },
                    { "Inventory Not Installed Button Text", "Inventory Viewer Not Installed" },

                    { "UnGodmode Button Text", "Disable Godmode" },
                    { "Godmode Button Text", "Enable Godmode" },
                    { "Godmode Not Installed Button Text", "Godmode Not Installed" },

                    { "Hurt 25 Button Text", "Hurt 25" },
                    { "Hurt 50 Button Text", "Hurt 50" },
                    { "Hurt 75 Button Text", "Hurt 75" },
                    { "Hurt 100 Button Text", "Hurt 100" },
                    { "Kill Button Text", "Kill" },

                    { "Heal 25 Button Text", "Heal 25" },
                    { "Heal 50 Button Text", "Heal 50" },
                    { "Heal 75 Button Text", "Heal 75" },
                    { "Heal 100 Button Text", "Heal 100" },
                    { "Heal Wounds Button Text", "Heal Wounds" }
                }, this, "en"
            );
            LogDebug("Default messages loaded");
        }

        protected override void SaveConfig() => Config.WriteObject(FConfigData);
        #endregion Hooks

        #region Command Callbacks
        [Command(CPadminCmd)]
        private void PlayerAdministrationUICallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationUICallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            CuiHelper.DestroyUi(player, CBasePanelName);

            if (!VerifyPermission(ref player, string.Empty, true))
                return;

            LogInfo($"{player.displayName}: Opened the menu");
            CuiHelper.AddUi(player, CuiHelper.ToJson(new CuiElementContainer { { CBasePanel, Cui.ParentOverlay, CBasePanelName } }, false));
            BuildUI(player, UiPage.Main);
        }

        [Command(CCloseUiCmd)]
        private void PlayerAdministrationCloseUICallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationCloseUICallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            CuiHelper.DestroyUi(player, CBasePanelName);

            if (FMainPageBanIdInputText.ContainsKey(player.userID))
                FMainPageBanIdInputText.Remove(player.userID);

            if (FUserBtnPageSearchInputText.ContainsKey(player.userID))
                FUserBtnPageSearchInputText.Remove(player.userID);
        }

        [Command(CSwitchUiCmd)]
        private void PlayerAdministrationSwitchUICallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationSwitchUICallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);

            if (aArgs.Length <= 0 || !VerifyPermission(ref player, string.Empty, true))
                return;

            bool twoOrMore = aArgs.Length >= 2; // .Length has less overhead then it's extension counterpart .Count()

            switch (aArgs[0].ToLower()) {
                case CCmdArgPlayersOnline: {
                        BuildUI(player, UiPage.PlayersOnline, (twoOrMore ? aArgs[1] : string.Empty));
                        break;
                    }
                case CCmdArgPlayersOnlineSearch: {
                        BuildUI(player, UiPage.PlayersOnline, (twoOrMore ? aArgs[1] : string.Empty), true);
                        break;
                    }
                case CCmdArgPlayersOffline: {
                        BuildUI(player, UiPage.PlayersOffline, (twoOrMore ? aArgs[1] : string.Empty));
                        break;
                    }
                case CCmdArgPlayersOfflineSearch: {
                        BuildUI(player, UiPage.PlayersOffline, (twoOrMore ? aArgs[1] : string.Empty), true);
                        break;
                    }
                case CCmdArgPlayersBanned: {
                        BuildUI(player, UiPage.PlayersBanned, (twoOrMore ? aArgs[1] : string.Empty));
                        break;
                    }
                case CCmdArgPlayersBannedSearch: {
                        BuildUI(player, UiPage.PlayersBanned, (twoOrMore ? aArgs[1] : string.Empty), true);
                        break;
                    }
                case CCmdArgPlayerPage: {
                        BuildUI(player, UiPage.PlayerPage, (twoOrMore ? aArgs[1] : string.Empty));
                        break;
                    }
                case CCmdArgPlayerPageBanned: {
                        BuildUI(player, UiPage.PlayerPageBanned, (twoOrMore ? aArgs[1] : string.Empty));
                        break;
                    }
                default: { // Main is the default for everything
                        BuildUI(player, UiPage.Main);
                        break;
                    }
            }
        }

        [Command(CUnbanUserCmd)]
        private void PlayerAdministrationUnbanUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationUnbanUserCallback was called");
            ulong targetId;

            if (!GetTargetFromArg(aArgs, out targetId))
                return;

            if (aPlayer.IsServer) {
                Player.Unban(targetId);
                LogInfo($"{aPlayer.Name}: Unbanned user ID {targetId}");
            } else {
                BasePlayer player = BasePlayer.Find(aPlayer.Id);

                if (!VerifyPermission(ref player, CPermBan, true))
                    return;

                Player.Unban(targetId);
                LogInfo($"{player.displayName}: Unbanned user ID {targetId}");
                timer.Once(0.01f, () => BuildUI(player, UiPage.Main));
            }
        }

        [Command(CBanUserCmd)]
        private void PlayerAdministrationBanUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationBanUserCallback was called");
            ulong targetId;
            string banReasonMsg;

            if (!GetTargetFromArg(aArgs, out targetId))
                return;

            if (aPlayer.IsServer) {
                if (permission.UserHasPermission(targetId.ToString(), CPermProtectBan)) {
                    aPlayer.Reply(lang.GetMessage("Protection Active Text", this));
                    return;
                }

                banReasonMsg = lang.GetMessage("Ban Reason Message Text", this, targetId.ToString());
                Player.Ban(targetId, banReasonMsg);
                LogInfo($"{aPlayer.Name}: Banned user ID {targetId}");
                BroadcastKickBan(aPlayer.Id, targetId, banReasonMsg, false);
                SendDiscordKickBanMessage(aPlayer.Name, 0, ServerUsers.Get(targetId)?.username ?? targetId.ToString(), targetId, banReasonMsg, true);
                return;
            }

            BasePlayer player = BasePlayer.Find(aPlayer.Id);

            if (!VerifyPermission(ref player, CPermBan, true))
                return;

            if (permission.UserHasPermission(targetId.ToString(), CPermProtectBan)) {
                rust.SendChatMessage(player, string.Empty, lang.GetMessage("Protection Active Text", this, aPlayer.Id));
                return;
            }

            banReasonMsg = GetReason(player.userID, targetId.ToString());

            if (ServerArmour != null) {
                //API_BanPlayer(player, playerId, reason, length, ignoreSearch);
                ServerArmour.Call("API_BanPlayer", targetId, banReasonMsg, "30y");
            } else {
                Player.Ban(targetId, banReasonMsg);
            }

            LogInfo($"{player.displayName}: Banned user ID {targetId}");
            BroadcastKickBan(aPlayer.Id, targetId, banReasonMsg, false);
            SendDiscordKickBanMessage(
                player.displayName, player.userID, ServerUsers.Get(targetId)?.username ?? targetId.ToString(), targetId, banReasonMsg, true
            );
            timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
        }

        [Command(CMainPageBanByIdCmd)]
        private void PlayerAdministrationMainPageBanByIdCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationMainPageBanByIdCallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            ulong targetId;

            if (
                !VerifyPermission(ref player, CPermBan, true) || !FMainPageBanIdInputText.ContainsKey(player.userID) ||
                !ulong.TryParse(FMainPageBanIdInputText[player.userID], out targetId)
            )
                return;

            if (permission.UserHasPermission(targetId.ToString(), CPermProtectBan)) {
                rust.SendChatMessage(player, string.Empty, lang.GetMessage("Protection Active Text", this, player.UserIDString));
                return;
            }

            string banReasonMsg = lang.GetMessage("Ban Reason Message Text", this, targetId.ToString());
            Player.Ban(targetId, banReasonMsg);
            LogInfo($"{player.displayName}: Banned user ID {targetId}");
            BroadcastKickBan(aPlayer.Id, targetId, banReasonMsg, false);
            SendDiscordKickBanMessage(
                player.displayName, player.userID, ServerUsers.Get(targetId)?.username ?? targetId.ToString(), targetId, banReasonMsg, true
            );
            timer.Once(0.01f, () => BuildUI(player, UiPage.Main));
        }

        [Command(CKickUserCmd)]
        private void PlayerAdministrationKickUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationKickUserCallback was called");
            ulong targetId;
            string kickReasonMsg;

            if (!GetTargetFromArg(aArgs, out targetId))
                return;

            BasePlayer targetPlayer = BasePlayer.FindByID(targetId);

            if (aPlayer.IsServer) {
                if (permission.UserHasPermission(targetId.ToString(), CPermProtectKick)) {
                    aPlayer.Reply(lang.GetMessage("Protection Active Text", this));
                    return;
                }

                kickReasonMsg = lang.GetMessage("Kick Reason Message Text", this, targetId.ToString());
                targetPlayer?.Kick(kickReasonMsg);
                LogInfo($"{aPlayer.Name}: Kicked user ID {targetId}");
                BroadcastKickBan(aPlayer.Id, targetId, kickReasonMsg, true);
                SendDiscordKickBanMessage(aPlayer.Name, 0, targetPlayer.displayName, targetId, kickReasonMsg, false);
                return;
            }

            BasePlayer player = BasePlayer.Find(aPlayer.Id);

            if (!VerifyPermission(ref player, CPermKick, true))
                return;

            if (permission.UserHasPermission(targetId.ToString(), CPermProtectKick)) {
                rust.SendChatMessage(player, string.Empty, lang.GetMessage("Protection Active Text", this, aPlayer.Id));
                return;
            }

            kickReasonMsg = GetReason(player.userID, targetId.ToString(), true);
            targetPlayer?.Kick(kickReasonMsg);
            LogInfo($"{player.displayName}: Kicked user ID {targetId}");
            BroadcastKickBan(aPlayer.Id, targetId, kickReasonMsg, true);
            SendDiscordKickBanMessage(player.displayName, player.userID, targetPlayer.displayName, targetId, kickReasonMsg, false);
            timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
        }

        [Command(CUnmuteUserCmd)]
        private void PlayerAdministrationUnmuteUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationUnmuteUserCallback was called");
            ulong targetId;

            if (!GetTargetFromArg(aArgs, out targetId))
                return;

            if (aPlayer.IsServer) {
                BasePlayer target = BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId);

                if (BetterChatMute != null && target != null) {
                    BetterChatMute.Call("API_Unmute", target.IPlayer, aPlayer);
                } else {
                    target?.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, false);
                }

                LogInfo($"{aPlayer.Name}: Unmuted user ID {targetId}");
            } else {
                BasePlayer player = BasePlayer.Find(aPlayer.Id);

                if (!VerifyPermission(ref player, CPermMute, true))
                    return;

                BasePlayer target = BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId);

                if (BetterChatMute != null && target != null) {
                    BetterChatMute.Call("API_Unmute", target.IPlayer, aPlayer);
                } else {
                    target?.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, false);
                }

                LogInfo($"{player.displayName}: Unmuted user ID {targetId}");
                timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
            }
        }

        [Command(CMuteUserCmd)]
        private void PlayerAdministrationMuteUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationMuteUserCallback was called");
            ulong targetId;
            float time;

            if (!GetTargetAmountFromArg(aArgs, out targetId, out time))
                return;

            if (aPlayer.IsServer) {
                BasePlayer target = BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId);

                if (BetterChatMute != null && target != null) {
                    if (time.Equals(0f)) {
                        BetterChatMute.Call("API_Mute", target.IPlayer, aPlayer, true, false);
                    } else {
                        BetterChatMute.Call("API_TimeMute", target.IPlayer, aPlayer, TimeSpan.FromMinutes(time), true, false);
                    }
                } else {
                    target?.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, true);
                }

                LogInfo($"{aPlayer.Name}: Muted user ID {targetId}");
            } else {
                BasePlayer player = BasePlayer.Find(aPlayer.Id);

                if (!VerifyPermission(ref player, CPermMute, true))
                    return;

                BasePlayer target = BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId);

                if (BetterChatMute != null && target != null) {
                    string inputReason = GetReason(player.userID, targetId.ToString());

                    if (time.Equals(0f)) {
                        BetterChatMute.Call("API_Mute", target.IPlayer, aPlayer, inputReason, true, false);
                    } else {
                        BetterChatMute.Call("API_TimeMute", target.IPlayer, aPlayer, TimeSpan.FromMinutes(time), inputReason, true, false);
                    }
                } else {
                    target?.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, true);
                }

                LogInfo($"{player.displayName}: Muted user ID {targetId}");
                timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
            }
        }

        [Command(CUnFreezeCmd)]
        private void PlayerAdministrationUnfreezeCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationUnfreezeCallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            ulong targetId;

            if (!VerifyPermission(ref player, CPermFreeze, true) || !GetTargetFromArg(aArgs, out targetId))
                return;

            player.SendConsoleCommand($"{CFreezeUnfreezeCmd} {targetId}");
            LogInfo($"{player.displayName}: Unfroze user ID {targetId}");
            // Let code execute, then reload screen
            timer.Once(0.1f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
        }

        [Command(CFreezeCmd)]
        private void PlayerAdministrationFreezeCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationFreezeCallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            ulong targetId;

            if (!VerifyPermission(ref player, CPermFreeze, true) || !GetTargetFromArg(aArgs, out targetId))
                return;

            player.SendConsoleCommand($"{CFreezeFreezeCmd} {targetId}");
            LogInfo($"{player.displayName}: Froze user ID {targetId}");
            // Let code execute, then reload screen
            timer.Once(0.1f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
        }

        [Command(CBackpackViewCmd)]
        private void PlayerAdministrationViewBackpackCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationViewBackpackCallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            ulong targetId;

            if (!VerifyPermission(ref player, CPermBackpacks, true) || !GetTargetFromArg(aArgs, out targetId))
                return;

            player.SendConsoleCommand($"chat.say \"/viewbackpack {targetId}\"");
            LogInfo($"{player.displayName}: Viewed backpack of {targetId}");
            PlayerAdministrationCloseUICallback(player.IPlayer, string.Empty, new[] { string.Empty });
        }

        [Command(CInventoryViewCmd)]
        private void PlayerAdministrationViewInventoryCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationViewInventoryCallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            ulong targetId;

            if (!VerifyPermission(ref player, CPermInventory, true) || !GetTargetFromArg(aArgs, out targetId))
                return;

            InventoryViewer.Call("ViewInventoryCommand", player, targetId.ToString(), new[] { targetId.ToString() });
            LogInfo($"{player.displayName}: Viewed inventory of {targetId}");
            PlayerAdministrationCloseUICallback(player.IPlayer, string.Empty, new[] { string.Empty });
        }

        [Command(CGodmodeCmd)]
        private void PlayerAdministrationGodmodeCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationGodmodeCallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            ulong targetId;

            if (!VerifyPermission(ref player, CPermGodmode, true) || !GetTargetFromArg(aArgs, out targetId))
                return;

            Godmode.Call("EnableGodmode", targetId);
            LogInfo($"{player.displayName}: Enabled GodMode for {targetId}");
            // Let code execute, then reload screen
            timer.Once(0.1f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
        }

        [Command(CUnGodmodeCmd)]
        private void PlayerAdministrationUnGodmodeCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationUnGodmodeCallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            ulong targetId;

            if (!VerifyPermission(ref player, CPermGodmode, true) || !GetTargetFromArg(aArgs, out targetId))
                return;

            Godmode.Call("DisableGodmode", targetId);
            LogInfo($"{player.displayName}: Disabled GodMode for {targetId}");
            // Let code execute, then reload screen
            timer.Once(0.1f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
        }

        [Command(CClearUserInventoryCmd)]
        private void PlayerAdministrationClearUserInventoryCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationClearUserInventoryCallback was called");
            ulong targetId;

            if (!GetTargetFromArg(aArgs, out targetId))
                return;

            if (aPlayer.IsServer) {
                if (permission.UserHasPermission(targetId.ToString(), CPermProtectReset)) {
                    aPlayer.Reply(lang.GetMessage("Protection Active Text", this));
                    return;
                }

                (BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId))?.inventory.Strip();
                LogInfo($"{aPlayer.Name}: Cleared the inventory of user ID {targetId}");
            } else {
                BasePlayer player = BasePlayer.Find(aPlayer.Id);

                if (!VerifyPermission(ref player, CPermClearInventory, true))
                    return;

                if (permission.UserHasPermission(targetId.ToString(), CPermProtectReset)) {
                    rust.SendChatMessage(player, string.Empty, lang.GetMessage("Protection Active Text", this, aPlayer.Id));
                    return;
                }

                (BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId))?.inventory.Strip();
                LogInfo($"{player.displayName}: Cleared the inventory of user ID {targetId}");
                timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
            }
        }

        [Command(CResetUserBPCmd)]
        private void PlayerAdministrationResetUserBlueprintsCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationResetUserBlueprintsCallback was called");
            ulong targetId;

            if (!GetTargetFromArg(aArgs, out targetId))
                return;

            if (aPlayer.IsServer) {
                if (permission.UserHasPermission(targetId.ToString(), CPermProtectReset)) {
                    aPlayer.Reply(lang.GetMessage("Protection Active Text", this));
                    return;
                }

                (BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId))?.blueprints.Reset();
                LogInfo($"{aPlayer.Name}: Reset the blueprints of user ID {targetId}");
            } else {
                BasePlayer player = BasePlayer.Find(aPlayer.Id);

                if (!VerifyPermission(ref player, CPermResetBP, true))
                    return;

                if (permission.UserHasPermission(targetId.ToString(), CPermProtectReset)) {
                    rust.SendChatMessage(player, string.Empty, lang.GetMessage("Protection Active Text", this, player.UserIDString));
                    return;
                }

                (BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId))?.blueprints.Reset();
                LogInfo($"{player.displayName}: Reset the blueprints of user ID {targetId}");
                timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
            }
        }

        [Command(CResetUserMetabolismCmd)]
        private void PlayerAdministrationResetUserMetabolismCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationResetUserMetabolismCallback was called");
            ulong targetId;

            if (!GetTargetFromArg(aArgs, out targetId))
                return;

            if (aPlayer.IsServer) {
                if (permission.UserHasPermission(targetId.ToString(), CPermProtectReset)) {
                    aPlayer.Reply(lang.GetMessage("Protection Active Text", this));
                    return;
                }

                (BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId))?.metabolism.Reset();
                LogInfo($"{aPlayer.Name}: Reset the metabolism of user ID {targetId}");
            } else {
                BasePlayer player = BasePlayer.Find(aPlayer.Id);

                if (!VerifyPermission(ref player, CPermResetMetabolism, true))
                    return;

                if (permission.UserHasPermission(targetId.ToString(), CPermProtectReset)) {
                    rust.SendChatMessage(player, string.Empty, lang.GetMessage("Protection Active Text", this, aPlayer.Id));
                    return;
                }

                (BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId))?.metabolism.Reset();
                LogInfo($"{player.displayName}: Reset the metabolism of user ID {targetId}");
                timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
            }
        }

        [Command(CRecoverUserMetabolismCmd)]
        private void PlayerAdministrationRecoverUserMetabolismCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationRecoverUserMetabolismCallback was called");
            ulong targetId;
            BasePlayer player = null;

            if (!GetTargetFromArg(aArgs, out targetId))
                return;

            if (!aPlayer.IsServer) {
                player = BasePlayer.Find(aPlayer.Id);

                if (!VerifyPermission(ref player, CPermRecoverMetabolism, true))
                    return;
            }

            PlayerMetabolism playerState = (BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId))?.metabolism;
            playerState.bleeding.value = playerState.bleeding.min;
            playerState.calories.value = playerState.calories.max;
            playerState.comfort.value = 0;
            playerState.hydration.value = playerState.hydration.max;
            playerState.oxygen.value = playerState.oxygen.max;
            playerState.poison.value = playerState.poison.min;
            playerState.radiation_level.value = playerState.radiation_level.min;
            playerState.radiation_poison.value = playerState.radiation_poison.min;
            playerState.temperature.value = (PlayerMetabolism.HotThreshold + PlayerMetabolism.ColdThreshold) / 2;
            playerState.wetness.value = playerState.wetness.min;

            if (aPlayer.IsServer) {
                LogInfo($"{aPlayer.Name}: Recovered the metabolism of user ID {targetId}");
            } else {
                LogInfo($"{player.displayName}: Recovered the metabolism of user ID {targetId}");
                timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
            }
        }

        [Command(CTeleportToUserCmd)]
        private void PlayerAdministrationTeleportToUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationTeleportToUserCallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            ulong targetId;

            if (aPlayer.IsServer || !VerifyPermission(ref player, CPermTeleport, true) || !GetTargetFromArg(aArgs, out targetId))
                return;

            BasePlayer targetPlayer = BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId);

            if (player.IsAlive() && targetPlayer.IsAlive()) {
                player.Teleport(targetPlayer); //.Teleport(targetPlayer.transform.position); // Let uMod decide what's best
                LogInfo($"{player.displayName}: Teleported to user ID {targetId}");
            } else {
                aPlayer.Reply(lang.GetMessage("Dead Player Error Text", this, aPlayer.Id));
            }

            timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
        }

        [Command(CTeleportUserCmd)]
        private void PlayerAdministrationTeleportUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationTeleportUserCallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            ulong targetId;

            if (!VerifyPermission(ref player, CPermTeleport, true) || !GetTargetFromArg(aArgs, out targetId))
                return;

            BasePlayer targetPlayer = BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId);

            if (player.IsAlive() && targetPlayer.IsAlive()) {
                targetPlayer.Teleport(player); //.Teleport(player.transform.position); // Let uMod decide what's best
                LogInfo($"{targetPlayer.displayName}: Teleported to admin {player.displayName}");
            } else {
                aPlayer.Reply(lang.GetMessage("Dead Player Error Text", this, aPlayer.Id));
            }

            timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
        }

        [Command(CSpectateUserCmd)]
        private void PlayerAdministrationSpectateUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationSpectateUserCallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            ulong targetId;

            if (!VerifyPermission(ref player, CPermSpectate, true) || !GetTargetFromArg(aArgs, out targetId))
                return;

            if (!player.IsDead())
                player.DieInstantly();

            player.StartSpectating();
            player.UpdateSpectateTarget(targetId.ToString());
            LogInfo($"{player.displayName}: Started spectating user ID {targetId}");
            timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
        }

        [Command(CPermsCmd)]
        private void PlayerAdministrationRunPermsCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            LogDebug("PlayerAdministrationRunPermsCallback was called");
            BasePlayer player = BasePlayer.Find(aPlayer.Id);
            ulong targetId;

            if (!VerifyPermission(ref player, CPermPerms, true) || !GetTargetFromArg(aArgs, out targetId))
                return;

            if (PermissionsManager != null && PermissionsManager.IsLoaded)
                PermissionsManager.Call(
                    (PermissionsManager.Version.Major > 0 ? "CmdPerms" : "cmdPerms"), player, string.Empty, new[] { "player", targetId.ToString() }
                );

            LogInfo($"{player.displayName}: Opened the permissions manager for user ID {targetId}");
        }

        [Command(CHurtUserCmd)]
        private void PlayerAdministrationHurtUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationHurtUserCallback was called");
            ulong targetId;
            float amount;

            if (!GetTargetAmountFromArg(aArgs, out targetId, out amount))
                return;

            if (aPlayer.IsServer) {
                if (permission.UserHasPermission(targetId.ToString(), CPermProtectHurt)) {
                    aPlayer.Reply(lang.GetMessage("Protection Active Text", this));
                    return;
                }

                (BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId))?.Hurt(amount);
                LogInfo($"{aPlayer.Name}: Hurt user ID {targetId} for {amount} points");
            } else {
                BasePlayer player = BasePlayer.Find(aPlayer.Id);

                if (!VerifyPermission(ref player, CPermHurt, true))
                    return;

                if (permission.UserHasPermission(targetId.ToString(), CPermProtectHurt)) {
                    rust.SendChatMessage(player, string.Empty, lang.GetMessage("Protection Active Text", this, aPlayer.Id));
                    return;
                }

                (BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId))?.Hurt(amount);
                LogInfo($"{player.displayName}: Hurt user ID {targetId} for {amount} points");
                timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
            }
        }

        [Command(CKillUserCmd)]
        private void PlayerAdministrationKillUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationKillUserCallback was called");
            ulong targetId;

            if (!GetTargetFromArg(aArgs, out targetId))
                return;

            if (aPlayer.IsServer) {
                if (permission.UserHasPermission(targetId.ToString(), CPermProtectKill)) {
                    aPlayer.Reply(lang.GetMessage("Protection Active Text", this));
                    return;
                }

                (BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId))?.Die();
                LogInfo($"{aPlayer.Name}: Killed user ID {targetId}");
            } else {
                BasePlayer player = BasePlayer.Find(aPlayer.Id);

                if (!VerifyPermission(ref player, CPermKill, true))
                    return;

                if (permission.UserHasPermission(targetId.ToString(), CPermProtectKill)) {
                    rust.SendChatMessage(player, string.Empty, lang.GetMessage("Protection Active Text", this, player.UserIDString));
                    return;
                }

                (BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId))?.Die();
                LogInfo($"{player.displayName}: Killed user ID {targetId}");
                timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
            }
        }

        [Command(CHealUserCmd)]
        private void PlayerAdministrationHealUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            LogDebug("PlayerAdministrationHealUserCallback was called");
            ulong targetId;
            float amount;

            if (!GetTargetAmountFromArg(aArgs, out targetId, out amount))
                return;

            BasePlayer targetPlayer = BasePlayer.FindByID(targetId) ?? BasePlayer.FindSleeping(targetId);

            if (aPlayer.IsServer) {
                if (targetPlayer.IsWounded())
                    targetPlayer.StopWounded();

                targetPlayer.Heal(amount);
                LogInfo($"{aPlayer.Name}: Healed user ID {targetId} for {amount} points");
            } else {
                BasePlayer player = BasePlayer.Find(aPlayer.Id);

                if (!VerifyPermission(ref player, CPermHeal, true))
                    return;

                if (targetPlayer.IsWounded())
                    targetPlayer.StopWounded();

                targetPlayer.Heal(amount);
                LogInfo($"{player.displayName}: Healed user ID {targetId} for {amount} points");
                timer.Once(0.01f, () => BuildUI(player, UiPage.PlayerPage, targetId.ToString()));
            }
        }
        #endregion Command Callbacks

        #region Text Update Callbacks
        [Command(CMainPageBanIdInputTextCmd)]
        private void PlayerAdministrationMainPageBanIdInputTextCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            BasePlayer player = BasePlayer.Find(aPlayer.Id);

            if (aArgs.Length <= 0 || !VerifyPermission(ref player, CPermUiShow)) {
                if (FMainPageBanIdInputText.ContainsKey(player.userID))
                    FMainPageBanIdInputText.Remove(player.userID);

                return;
            }

            if (FMainPageBanIdInputText.ContainsKey(player.userID)) {
                FMainPageBanIdInputText[player.userID] = aArgs[0];
            } else {
                FMainPageBanIdInputText.Add(player.userID, aArgs[0]);
            }
        }

        [Command(CUserBtnPageSearchInputTextCmd)]
        private void PlayerAdministrationUserBtnPageSearchInputTextCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            BasePlayer player = BasePlayer.Find(aPlayer.Id);

            if (aArgs.Length <= 0 || !VerifyPermission(ref player, CPermUiShow)) {
                if (FUserBtnPageSearchInputText.ContainsKey(player.userID))
                    FUserBtnPageSearchInputText.Remove(player.userID);

                return;
            }

            if (FUserBtnPageSearchInputText.ContainsKey(player.userID)) {
                FUserBtnPageSearchInputText[player.userID] = aArgs[0];
            } else {
                FUserBtnPageSearchInputText.Add(player.userID, aArgs[0]);
            }
        }

        [Command(CUserPageReasonInputTextCmd)]
        private void PlayerAdministrationUserPageReasonInputTextCallback(IPlayer aPlayer, string aCommand, string[] aArgs) {
            if (aPlayer.IsServer)
                return;

            BasePlayer player = BasePlayer.Find(aPlayer.Id);

            if (aArgs.Length <= 0 || !VerifyPermission(ref player, CPermUiShow)) {
                if (FUserPageReasonInputText.ContainsKey(player.userID))
                    FUserPageReasonInputText.Remove(player.userID);

                return;
            }

            if (FUserPageReasonInputText.ContainsKey(player.userID)) {
                FUserPageReasonInputText[player.userID] = aArgs[0];
            } else {
                FUserPageReasonInputText.Add(player.userID, aArgs[0]);
            }
        }
        #endregion Text Update Callbacks
#pragma warning restore IDE0051, IDE0060 // Remove unused private members, unused parameter
    }
}


// --- End of file: PlayerAdministration.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/phone-commands ---
// --- Original File Path: P/PhoneCommands/PhoneCommands.cs ---

﻿using Facepunch;
using Oxide.Core;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Phone Commands", "marcuzz", "0.0.10")]
    [Description("Bind commands to phone numbers")]
    public class PhoneCommands : CovalencePlugin
    {
        private static PluginConfig _config;

        private static ListDictionary<int, PhoneCommand> _phoneCommands;

        private static StoredData _storedData;

        private static Regex _chatCommandRegex;

        private static Dictionary<string, int> _blockedChatCommands;

        private static Dictionary<ulong, int> _allowedCommands;

        #region Hooks

        void Init() 
        {
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            _phoneCommands = new ListDictionary<int, PhoneCommand>();
            _blockedChatCommands = new Dictionary<string, int>();
            _chatCommandRegex = new Regex("(?<=\\A^/)(\\w+)", RegexOptions.Compiled);
            _allowedCommands = new Dictionary<ulong, int>();
        }

        void OnServerInitialized()
        {
            if (!_config.BlockChatCommandsBoundToPhoneNumber)
                Unsubscribe(nameof(OnPlayerCommand));

            RegisterPhoneComands();
        }

        void Unload()
        {
            if (_phoneCommands != null)
            {
                foreach (var phoneCommand in _phoneCommands.Values)
                {
                    var phone = TelephoneManager.GetTelephone(phoneCommand.Config.PhoneNumber);
                    if (phone == null)
                        continue;

                    TelephoneManager.DeregisterTelephone(phone);
                    if (phoneCommand.Telephone.IsDestroyed == false)
                    {
                        phoneCommand.Telephone.Kill();
                    }

                    _storedData.UsedNumbers.Remove(phoneCommand.Config.PhoneNumber);
                }
            }

            SaveData();

            _config = null;
            _phoneCommands = null;
            _storedData = null;
            _blockedChatCommands = null;
            _chatCommandRegex = null;
            _allowedCommands = null;
        }

        object OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return null;

            if (_allowedCommands.ContainsKey(player.userID) && _allowedCommands[player.userID] > 0)
            {
                _allowedCommands[player.userID]--;
                return null;
            }

            if (_blockedChatCommands.ContainsKey(command))
            {
                var translatedMessage = lang.GetMessage("ChatCommandBlocked", this, player.UserIDString);
                player.ChatMessage(string.Format(translatedMessage, _blockedChatCommands[command]));
                return false;
            }

            return null;
        }

        object OnPhoneDial(PhoneController callerPhone, PhoneController receiverPhone, BasePlayer player)
        {
            if (player == null)
                return null;

            if (!_phoneCommands.Keys.Contains(receiverPhone.PhoneNumber))
                return null;

            var command = _phoneCommands[receiverPhone.PhoneNumber];

            var prefab = callerPhone.ParentEntity.PrefabName;
            if (prefab == "assets/prefabs/voiceaudio/mobilephone/mobilephone.weapon.prefab" 
                && command.Config.RestrictMobilePhones)
            {
                RestrictedDevice(player);
                return false;
            }
            
            if (prefab == "assets/bundled/prefabs/autospawn/phonebooth/phonebooth.static.prefab" 
                && command.Config.RestrictPublicPhones)
            {
                RestrictedDevice(player);
                return false;
            }

            if (prefab == "assets/prefabs/voiceaudio/telephone/telephone.deployed.prefab" 
                && command.Config.RestrictLandlinePhones)
            {
                RestrictedDevice(player);
                return false;
            }

            callerPhone.serverState = Telephone.CallState.Idle;
            callerPhone.activeCallTo = null;

            string message;
            if (!CheckPermission(command, player))
            {
                message = lang.GetMessage("PermissionRequired", this, player.UserIDString);
                player.ChatMessage(message);
                PlayEffect(player, true);

                return false;
            }

            if (!CheckCooldown(command, player, out message))
            {
                player.ChatMessage(message);
                PlayEffect(player, true);

                return false;
            }

            RunCommand(player, command);

            return true;
        }

        void OnEntitySpawned(MobilePhone phone)
        {
            AddCommandsToContactList(phone.Controller);
        }

        void OnEntitySpawned(Telephone phone)
        {
            if (phone.ShortPrefabName != "phonebooth.static.prefab")
                AddCommandsToContactList(phone.Controller);
        }

        void OnNewSave()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, new StoredData());
        }

        #endregion

        #region Command Registration

        private void RegisterPhoneComands()
        {
            var createdPhones = new Dictionary<int, PhoneController>();
            foreach (var phoneCommand in _config.PhoneCommands)
            {
                if (!IsConfigurationValid(phoneCommand))
                {
                    Puts($"Phone command {phoneCommand.PhoneNumber} ({phoneCommand.PhoneName}) has invalid configuration, skipping");
                    continue;
                }

                if (TelephoneManager.allTelephones.ContainsKey(phoneCommand.PhoneNumber))
                {
                    if (_storedData.UsedNumbers.Contains(phoneCommand.PhoneNumber))
                    {
                        var phone = TelephoneManager.GetTelephone(phoneCommand.PhoneNumber);
                        TelephoneManager.DeregisterTelephone(phone);
                        var existing = phone.ParentEntity as Telephone;
                        _storedData.UsedNumbers.Remove(phoneCommand.PhoneNumber);

                        RegisterCommand(phoneCommand, existing, createdPhones);
                        continue;
                    }
                    else
                    {
                        Puts($"Phone number {phoneCommand.PhoneNumber} ({phoneCommand.PhoneName}) is already in use, skipping");
                        continue;
                    }
                }

                Telephone telephone;
                if (!SpawnPhone(out telephone))
                {
                    Puts($"Failed to register phone number {phoneCommand.PhoneNumber} ({phoneCommand.PhoneName}), skipping");
                    continue;
                }

                RegisterCommand(phoneCommand, telephone, createdPhones);
            }

            foreach (var item in TelephoneManager.allTelephones)
            {
                createdPhones[item.Key] = item.Value;
            }

            TelephoneManager.allTelephones = createdPhones;
        }

        private void RegisterCommand(PhoneCommandConfig command, Telephone telephone, Dictionary<int, PhoneController> phones)
        {
            telephone.Controller.PhoneNumber = command.PhoneNumber;
            telephone.Controller.PhoneName = command.PhoneName;

            _phoneCommands.Add(command.PhoneNumber, new PhoneCommand
            {
                Telephone = telephone,
                Config = command
            });

            if (command.Permission != null && !permission.PermissionExists(command.Permission))
                permission.RegisterPermission(command.Permission, this);

            if (_config.BlockChatCommandsBoundToPhoneNumber)
                SetBlockedCommands(command);

            phones.Add(telephone.Controller.PhoneNumber, telephone.Controller);
            _storedData.UsedNumbers.Add(telephone.Controller.PhoneNumber);
            SaveData();
        }

        private void SetBlockedCommands(PhoneCommandConfig command)
        {
            foreach (var action in command.PhoneActions)
            {
                if (action.Type == CommandActionType.PlayerChat)
                {
                    var match = _chatCommandRegex.Match(action.Command);
                    if (match.Success)
                        _blockedChatCommands[match.ToString()] = command.PhoneNumber;
                }
            }
        }

        private static bool SpawnPhone(out Telephone telephone)
        {
            telephone = GameManager.server.CreateEntity("assets/bundled/prefabs/autospawn/phonebooth/phonebooth.static.prefab") as Telephone;
            if (telephone == null)
                return false;

            telephone.Spawn();
            TelephoneManager.DeregisterTelephone(telephone.Controller);

            return true;
        }

        private static bool IsConfigurationValid(PhoneCommandConfig command)
        {
            if (command.PhoneName.Length <= 0 || command.PhoneName.Length > 20)
                return false;
            

            if (command.PhoneNumber < 10000000 || command.PhoneNumber >= 100000000)
                return false;

            return true;
        }

        //Not using Pool.Free as it is exact logic copy of PhoneController.Server_AddSavedNumber
        private void AddCommandsToContactList(PhoneController phone)
        {
            if (_phoneCommands == null || !_config.AddCommandsToContactList)
                return;

            var count = 0;
            foreach (var command in _phoneCommands.Values)
            {
                AddCommandToContactList(phone, command.Config);
                count++;
            }

            if (count > 0)
            {
                phone.savedNumbers.ShouldPool = false;
                phone.baseEntity.SendNetworkUpdate();
            }
        }

        //Not using Pool.Free as it is exact logic copy of PhoneController.Server_AddSavedNumber
        private static void AddCommandToContactList(PhoneController controller, PhoneCommandConfig command)
        {
            if (controller.savedNumbers == null)
                controller.savedNumbers = Pool.Get<PhoneDirectory>();

            if (controller.savedNumbers.entries == null)
                controller.savedNumbers.entries = Pool.GetList<PhoneDirectory.DirectoryEntry>();

            if (controller.IsSavedContactValid(command.PhoneName, command.PhoneNumber))
            {
                var directoryEntry = Pool.Get<PhoneDirectory.DirectoryEntry>();
                directoryEntry.phoneName = command.PhoneName;
                directoryEntry.phoneNumber = command.PhoneNumber;
                directoryEntry.ShouldPool = false;
                controller.savedNumbers.entries.Add(directoryEntry);
            }
        }

        #endregion

        #region Command Execution

        private void RestrictedDevice(BasePlayer player) 
        {
            var message = lang.GetMessage("DeviceRestricted", this, player.UserIDString);
            player.ChatMessage(message);
            PlayEffect(player, true);
        }

        private bool CheckCooldown(PhoneCommand command, BasePlayer player, out string message)
        {
            message = null;

            if (command.Config.Cooldown == 0 || player.IsAdmin)
                return true;

            if (!_storedData.PlayerCooldowns.ContainsKey(player.userID))
                _storedData.PlayerCooldowns.Add(player.userID, new Dictionary<int, long>());

            var playerCooldwns = _storedData.PlayerCooldowns[player.userID];
            if (!playerCooldwns.ContainsKey(command.Config.PhoneNumber))
            {
                playerCooldwns.Add(command.Config.PhoneNumber, DateTime.Now.ToBinary());
                SaveData();
                return true;
            }

            var dt = DateTime.FromBinary(playerCooldwns[command.Config.PhoneNumber]);
            if (dt.AddSeconds(command.Config.Cooldown) > DateTime.Now)
            {
                var diff = dt.AddSeconds(command.Config.Cooldown) - DateTime.Now;
                var cooldownTranslatedMessage = lang.GetMessage("CommandCooldown", this, player.UserIDString);
                message = string.Format(cooldownTranslatedMessage, (int)diff.TotalMinutes);

                return false;
            }

            playerCooldwns[command.Config.PhoneNumber] = DateTime.Now.ToBinary();
            SaveData();

            return true;
        }

        private bool CheckPermission(PhoneCommand command, BasePlayer player)
        {
            if (command.Config.Permission != null)
            {
                var hasPerm = permission.UserHasPermission(player.UserIDString, command.Config.Permission);
                if (!hasPerm && !player.IsAdmin)
                    return false;
            }

            return true;
        }

        private void RunCommand(BasePlayer player, PhoneCommand command)
        {
            foreach (var action in command.Config.PhoneActions)
            {
                var grid = PhoneController.PositionToGridCoord(player.activeTelephone.transform.position);
                var formated = string.Format(
                    action.Command,
                    player.UserIDString,
                    player.displayName,
                    player.transform.position.x,
                    player.transform.position.y,
                    player.transform.position.z,
                    grid,
                    command.Config.PhoneNumber
                );

                switch (action.Type)
                {
                    case CommandActionType.ServerCommand:
                        server.Command(formated);
                        break;
                    case CommandActionType.Broadcast:
                        server.Broadcast(formated);
                        break;
                    case CommandActionType.Reply:
                        player.ChatMessage(formated);
                        break;
                    case CommandActionType.PlayerChat:
                        if (_config.BlockChatCommandsBoundToPhoneNumber)
                            if (_allowedCommands.ContainsKey(player.userID))
                                _allowedCommands[player.userID]++;
                            else
                                _allowedCommands.Add(player.userID, 1);
                        player.Command($"chat.say \"{formated}\"");
                        break;
                    default:
                        continue;
                }
            }

            PlayEffect(player);
        }

        private void PlayEffect(BasePlayer player, bool failed = false)
        {
            NextFrame(() =>
            {
                if (player.HasActiveTelephone)
                    player.activeTelephone.ClearCurrentUser();
            });

            if (!_config.EffectEnabled)
                return;

            if (!failed)
                Effect.server.Run(_config.EffectSuccess, player.transform.position, Vector3.zero);
            else
                Effect.server.Run(_config.EffectFailed, player.transform.position, Vector3.zero);
        }

        private static class CommandActionType 
        {
            public const string ServerCommand = "command";
            public const string PlayerChat = "playerchat";
            public const string Broadcast = "broadcast";
            public const string Reply = "reply";
        }

        #endregion

        #region Data and Configuration

        private struct PhoneCommand
        {
            public Telephone Telephone { get; set; }
            public PhoneCommandConfig Config { get; set; }
        }

        private static PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                EffectEnabled = true,
                EffectFailed = "assets/prefabs/npc/scientist/sound/death.prefab",
                EffectSuccess = "assets/prefabs/npc/scientist/sound/respondok.prefab",
                AddCommandsToContactList = true,
                BlockChatCommandsBoundToPhoneNumber = false,
                PhoneCommands = new List<PhoneCommandConfig>
                {
                   new PhoneCommandConfig
                   {
                       PhoneNumber = 12345678,
                       PhoneName = "Hourly gift",
                       Cooldown = 3600,
                       Permission = "phonecommands.vip",
                       RestrictLandlinePhones = false,
                       RestrictMobilePhones = false,
                       RestrictPublicPhones = false,
                       PhoneActions = new List<PhoneAction>
                       {
                           new PhoneAction
                           {
                               Type = CommandActionType.ServerCommand,
                               Command = "inventory.giveto {0} xmas.present.large 1"
                           },
                           new PhoneAction
                           {
                               Type = CommandActionType.Broadcast,
                               Command = "{1} just recieved large gift! Call {6:#### ####} to get it too."
                           }
                       }
                   },
                   new PhoneCommandConfig
                   {
                       PhoneNumber = 87654321,
                       PhoneName = "Another example",
                       Cooldown = 0,
                       Permission = null,
                       RestrictLandlinePhones = false,
                       RestrictMobilePhones = false,
                       RestrictPublicPhones = false,
                       PhoneActions = new List<PhoneAction>
                       {
                           new PhoneAction
                           {
                               Type = CommandActionType.Reply,
                               Command = "Command executed - player id: {0}, player name: {1}, position x,y,z: {2},{3},{4}, grid coord: {5}, called number: {6:#### ####}"
                           }
                       }
                   }
                }
            };
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config.WriteObject(GetDefaultConfig(), true);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
        }

        private void UpdateConfig()
        {
            Config.WriteObject(_config, true);
        }

        private class PluginConfig
        {
            public bool EffectEnabled { get; set; }
            public string EffectSuccess { get; set; }
            public string EffectFailed { get; set; }
            public bool AddCommandsToContactList { get; set; }
            public bool BlockChatCommandsBoundToPhoneNumber { get; set; }
            public List<PhoneCommandConfig> PhoneCommands { get; set; }
        }

        private struct PhoneCommandConfig
        {
            public int PhoneNumber { get; set; }
            public string PhoneName { get; set; }
            public int Cooldown { get; set; }
            public string Permission { get; set; }
            public bool RestrictMobilePhones { get; set; }
            public bool RestrictLandlinePhones { get; set; }
            public bool RestrictPublicPhones { get; set; }
            public List<PhoneAction> PhoneActions { get; set; }
        }

        private struct PhoneAction
        {
            public string Type { get; set; }
            public string Command { get; set; }
        }

        private class StoredData
        {
            public List<int> UsedNumbers = new List<int>();
            public Dictionary<ulong, Dictionary<int, long>> PlayerCooldowns = new Dictionary<ulong, Dictionary<int, long>>();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandCooldown"] = "Cooldown remaining: {0} minutes",
                ["PermissionRequired"] = "Not allowed!",
                ["ChatCommandBlocked"] = "This chat command is disabled. Call {0:#### ####} instead.",
                ["DeviceRestricted"] = "This number cannot be called from your device. Try another.",
            }, this);
        }
    }

    #endregion
}

// --- End of file: PhoneCommands.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pvp-caps ---
// --- Original File Path: P/PVPCaps/PVPCaps.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Facepunch;
using Oxide.Core;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("PVP Caps", "WhiteDragon", "1.1.5")]
    [Description("Applies a PvP damage handicap to players, based on PvP kills/deaths.")]
    internal class PVPCaps : RustPlugin
    {
        #region _fields_

        internal static PVPCaps instance;

        // configuration: change flag
        private static bool config_changed = false;

        // configuration: data
        private static Configuration config;

        // attack info
        private static Dictionary<ulong, List<AttackInfo>> attacks = new Dictionary<ulong, List<AttackInfo>>();

        // online team member counts
        private static Dictionary<ulong, ulong> teams = new Dictionary<ulong, ulong>();

        // plugin database
        private static DB db;

        // oxide permissions
        private const string PERMISSIONADMIN    = "pvpcaps.admin";    // allowed to use admin commands
        private const string PERMISSIONEXCLUDED = "pvpcaps.excluded"; // exclude player from handicaps
        private const string PERMISSIONUSE      = "pvpcaps.use";      // allows player to see handicaps

        // prefab names
        private const string MAP_LABEL = "assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab";
        private const string MAP_ICON  = "assets/prefabs/tools/map/genericradiusmarker.prefab";

        #endregion

        #region _weapons_

        protected readonly Dictionary<int, WeaponStats> weapons = new Dictionary<int, WeaponStats>
        {
            [174866732] = new WeaponStats{
                displayname = "16x Zoom Scope",
                shortname = "weapon.mod.8x.scope",
                accuracy = 0.15,
                recoil = -0.2,
                zoom = 16.0,
                aimcone = -0.3
            },
            [567235583] = new WeaponStats{
                displayname = "8x Zoom Scope",
                shortname = "weapon.mod.small.scope",
                accuracy = 0.15,
                recoil = -0.2,
                zoom = 8.0,
                aimcone = -0.3
            },
            [1545779598] = new WeaponStats{
                displayname = "Assault Rifle",
                shortname = "rifle.ak",
                damage = 50.0,
                accuracy = 4.0,
                recoil = 36.4,
                attack_rate = 450.0 / 60.0,
                range = 188.0,
                attachments = 3.0,
                aimcone = 0.2,
                capacity = 30.0,
                reload = 4.4,
                draw = 1.0
            },
            [1840822026] = new WeaponStats{
                displayname = "Beancan Grenade",
                shortname = "grenade.beancan",
                explosive_dmg = 15.0,
                lethality = 115.0,
                throw_distance = 26.0,
                fuse_length_min = 3.5,
                fuse_length_max = 4.0,
                blast_radius = 4.5,
                dud_chance = 0.15
            },
            [-1262185308] = new WeaponStats{
                displayname = "Binoculars",
                shortname = "tool.binoculars"
            },
            [1973165031] = new WeaponStats{
                displayname = "Birthday Cake",
                shortname = "cakefiveyear",
                damage = 15.0,
                attack_rate = 46.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [1588298435] = new WeaponStats{
                displayname = "Bolt Action Rifle",
                shortname = "rifle.bolt",
                damage = 80.0,
                accuracy = 2.0,
                recoil = 7.0,
                attack_rate = 35.0 / 60.0,
                range = 574.0,
                attachments = 3.0,
                aimcone = 0.0,
                capacity = 4.0,
                reload = 5.0,
                draw = 1.0
            },
            [1711033574] = new WeaponStats{
                displayname = "Bone Club",
                shortname = "bone.club",
                damage = 12.0,
                attack_rate = 86.0 / 60.0,
                attack_size = 0.2,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [1814288539] = new WeaponStats{
                displayname = "Bone Knife",
                shortname = "knife.bone",
                damage = 16.0,
                attack_rate = 86.0 / 60.0,
                attack_size = 0.2,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [-194509282] = new WeaponStats{
                displayname = "Butcher Knife",
                shortname = "knife.butcher",
                damage = 20.0,
                attack_rate = 86.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [-1316706473] = new WeaponStats{
                displayname = "Camera",
                shortname = "tool.camera"
            },
            [1789825282] = new WeaponStats{
                displayname = "Candy Cane Club",
                shortname = "candycaneclub",
                damage = 18.0,
                attack_rate = 60.0 / 60.0,
                attack_size = 0.4,
                range = 1.6,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [1104520648] = new WeaponStats{
                displayname = "Chainsaw",
                shortname = "chainsaw",
                damage = 12.0,
                attack_rate = 300.0 / 60.0,
                attack_size = 0.4,
                range = 1.5,
                draw = 1.0,
                melee = true
            },
            [2040726127] = new WeaponStats{
                displayname = "Combat Knife",
                shortname = "knife.combat",
                damage = 35.0,
                attack_rate = 86.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [884424049] = new WeaponStats{
                displayname = "Compound Bow",
                shortname = "bow.compound",
                damage = 100.0,
                accuracy = 0.0,
                recoil = 9.0,
                attack_rate = 60.0 / 60.0,
                range = 60.0,
                attachments = 0.0,
                aimcone = 0.2,
                capacity = 1.0,
                reload = 1.0,
                draw = 1.0
            },
            [1965232394] = new WeaponStats{
                displayname = "Crossbow",
                shortname = "crossbow",
                damage = 60.0,
                accuracy = 3.0,
                recoil = 9.0,
                attack_rate = 17.0 / 60.0,
                range = 34.0,
                attachments = 2.0,
                aimcone = 1.0,
                capacity = 1.0,
                reload = 3.6,
                draw = 1.6
            },
            [1796682209] = new WeaponStats{
                displayname = "Custom SMG",
                shortname = "smg.2",
                damage = 30.0,
                accuracy = 3.0,
                recoil = 8.0,
                attack_rate = 600.0 / 60.0,
                range = 50.0,
                attachments = 3.0,
                aimcone = 0.5,
                capacity = 24.0,
                reload = 4.0,
                draw = 1.0
            },
            [-765183617] = new WeaponStats{
                displayname = "Double Barrel Shotgun",
                shortname = "shotgun.double",
                damage = 180.0,
                accuracy = 15.0,
                recoil = 30.0,
                attack_rate = 120.0 / 60.0,
                range = 10.0,
                attachments = 2.0,
                aimcone = 0.5,
                capacity = 2.0,
                reload = 5.5,
                draw = 1.75
            },
            [-75944661] = new WeaponStats{
                displayname = "Eoka Pistol",
                shortname = "pistol.eoka",
                damage = 180.0,
                accuracy = 17.0,
                recoil = 7.0,
                attack_rate = 30.0 / 60.0,
                range = 10.0,
                attachments = 0.0,
                aimcone = 2.0,
                capacity = 1.0,
                reload = 2.0,
                draw = 0.5
            },
            [143803535] = new WeaponStats{
                displayname = "F1 Grenade",
                shortname = "grenade.f1",
                lethality = 100.0,
                throw_distance = 26.0,
                fuse_length_min = 3.0,
                fuse_length_max = 3.0,
                blast_radius = 6.0,
                thrown = true
            },
            [-1215753368] = new WeaponStats{
                displayname = "Flame Thrower",
                shortname = "flamethrower",
                damage = 8.0,
                attack_rate = 240.0 / 60.0,
                range = 1.0,
                attachments = 0.0,
                capacity = 100.0,
                reload = 3.5,
                draw = 1.8
            },
            [304481038] = new WeaponStats{
                displayname = "Flare",
                shortname = "flare",
                throw_distance = 26.0,
                fuse_length_min = 110.0,
                fuse_length_max = 120.0,
                thrown = true
            },
            [-196667575] = new WeaponStats{
                displayname = "Flashlight",
                shortname = "flashlight.held",
                damage = 15.0,
                attack_rate = 60.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true
            },
            [999690781] = new WeaponStats{
                displayname = "Geiger Counter",
                shortname = "geiger.counter"
            },
            [1569882109] = new WeaponStats{
                displayname = "Handmade Fishing Rod",
                shortname = "fishingrod.handmade"
            },
            [200773292] = new WeaponStats{
                displayname = "Hammer",
                shortname = "hammer",
                damage = 10.0,
                attack_rate = 120.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [-1252059217] = new WeaponStats{
                displayname = "Hatchet",
                shortname = "hatchet",
                damage = 25.0,
                attack_rate = 67.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [442289265] = new WeaponStats{
                displayname = "Holosight",
                shortname = "weapon.mod.holosight",
                accuracy = 0.7,
                zoom = 2.0,
                aimcone = -0.7,
                aimcone_hip = -0.7
            },
            [1443579727] = new WeaponStats{
                displayname = "Hunting Bow",
                shortname = "bow.hunting",
                damage = 50.0,
                accuracy = 2.0,
                recoil = 9.0,
                attack_rate = 60.0 / 60.0,
                range = 15.0,
                attachments = 0.0,
                aimcone = 1.0,
                capacity = 1.0,
                reload = 1.0,
                draw = 1.0
            },
            [1488979457] = new WeaponStats{
                displayname = "Jackhammer",
                shortname = "jackhammer",
                damage = 15.0,
                attack_rate = 400.0,
                attack_size = 0.3,
                range = 2.0,
                draw = 1.0,
                melee = true
            },
            [-778367295] = new WeaponStats{
                displayname = "L96 Rifle",
                shortname = "rifle.l96",
                damage = 80.0,
                accuracy = 2.0,
                recoil = 3.5,
                attack_rate = 23.0 / 60.0,
                range = 1125.0,
                attachments = 3.0,
                aimcone = 0.0,
                capacity = 5.0,
                reload = 3.0,
                draw = 1.0
            },
            [-1469578201] = new WeaponStats{
                displayname = "Longsword",
                shortname = "longsword",
                damage = 75.0,
                attack_rate = 30.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [-1469578201] = new WeaponStats{
                displayname = "LR-300 Assault Rifle",
                shortname = "longsword",
                damage = 40.0,
                accuracy = 4.0,
                recoil = 15.9,
                attack_rate = 500.0 / 60.0,
                range = 188.0,
                attachments = 3.0,
                aimcone = 0.2,
                capacity = 30.0,
                reload = 4.0,
                draw = 2.0
            },
            [-2069578888] = new WeaponStats{
                displayname = "M249",
                shortname = "lmg.m249",
                damage = 65.0,
                accuracy = 7.0,
                recoil = 7.0,
                attack_rate = 500.0 / 60.0,
                range = 317.0,
                attachments = 3.0,
                aimcone = 0.2,
                capacity = 100.0,
                reload = 7.5,
                draw = 1.8
            },
            [28201841] = new WeaponStats{
                displayname = "M39 Rifle",
                shortname = "rifle.m39",
                damage = 50.0,
                accuracy = 4.0,
                recoil = 8.5,
                attack_rate = 300.0 / 60.0,
                range = 352.0,
                attachments = 3.0,
                aimcone = 0.1,
                capacity = 20.0,
                reload = 3.25,
                draw = 1.0
            },
            [-852563019] = new WeaponStats{
                displayname = "M92 Pistol",
                shortname = "pistol.m92",
                damage = 45.0,
                accuracy = 4.0,
                recoil = 9.0,
                attack_rate = 600.0 / 60.0,
                range = 90.0,
                attachments = 3.0,
                aimcone = 1.0,
                capacity = 15.0,
                reload = 2.2,
                draw = 0.5
            },
            [-1966748496] = new WeaponStats{
                displayname = "Mace",
                shortname = "mace",
                damage = 50.0,
                attack_rate = 30.0 / 60.0,
                attack_size = 0.4,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [-1137865085] = new WeaponStats{
                displayname = "Machete",
                shortname = "machete",
                damage = 35.0,
                attack_rate = 60.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [1318558775] = new WeaponStats{
                displayname = "MP5A4",
                shortname = "smg.mp5",
                damage = 35.0,
                accuracy = 5.0,
                recoil = 14.1,
                attack_rate = 600.0 / 60.0,
                range = 72.0,
                attachments = 3.0,
                aimcone = 0.5,
                capacity = 30.0,
                reload = 4.0,
                draw = 1.6
            },
            [-1123473824] = new WeaponStats{
                displayname = "Multiple Grenade Launcher",
                shortname = "multiplegrenadelauncher",
                damage = 125.0,
                accuracy = 4.0,
                recoil = 30.0,
                attack_rate = 150.0 / 60.0,
                range = 1.0,
                attachments = 2.0,
                aimcone = 2.25,
                capacity = 6.0,
                reload = 6.0,
                draw = 1.0
            },
            [-1405508498] = new WeaponStats{
                displayname = "Muzzle Boost",
                shortname = "weapon.mod.muzzleboost",
                attack_rate = 0.1,
                velocity = -0.1,
                damage = -0.1
            },
            [1478091698] = new WeaponStats{
                displayname = "Muzzle Brake",
                shortname = "weapon.mod.muzzlebrake",
                velocity = -0.2,
                damage = -0.2,
                accuracy = -0.38,
                recoil = -0.5,
                aimcone = 0.5,
                aimcone_hip = 2.0,
                aimcone_degrees = true
            },
            [1953903201] = new WeaponStats{
                displayname = "Nailgun",
                shortname = "pistol.nailgun",
                damage = 18.0,
                accuracy = 4.0,
                recoil = 7.0,
                attack_rate = 400.0 / 60.0,
                range = 6.0,
                attachments = 0.0,
                aimcone = 0.75,
                capacity = 16.0,
                reload = 3.4,
                draw = 0.5
            },
            [-1302129395] = new WeaponStats{
                displayname = "Pickaxe",
                shortname = "pickaxe",
                damage = 30.0,
                attack_rate = 40.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [1090916276] = new WeaponStats{
                displayname = "Pitchfork",
                shortname = "pitchfork",
                damage = 40.0,
                attack_rate = 40.0 / 60.0,
                attack_size = 0.4,
                range = 2.8,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [795371088] = new WeaponStats{
                displayname = "Pump Shotgun",
                shortname = "shotgun.pump",
                damage = 210.0,
                accuracy = 14.0,
                recoil = 22.0,
                attack_rate = 55.0 / 60.0,
                range = 45.0,
                attachments = 2.0,
                aimcone = 0.0,
                capacity = 6.0,
                reload = 5.5,
                draw = 1.0
            },
            [1373971859] = new WeaponStats{
                displayname = "Python Revolver",
                shortname = "pistol.python",
                damage = 55.0,
                accuracy = 6.0,
                recoil = 18.0,
                attack_rate = 400.0 / 60.0,
                range = 72.0,
                attachments = 3.0,
                aimcone = 0.5,
                capacity = 6.0,
                reload = 3.75,
                draw = 0.5
            },
            [649912614] = new WeaponStats{
                displayname = "Revolver",
                shortname = "pistol.revolver",
                damage = 35.0,
                accuracy = 5.0,
                recoil = 7.0,
                attack_rate = 343.0 / 60.0,
                range = 36.0,
                attachments = 1.0,
                aimcone = 0.75,
                capacity = 8.0,
                reload = 3.4,
                draw = 0.5
            },
            [596469572] = new WeaponStats{
                displayname = "RF Transmitter",
                shortname = "rf.detonator"
            },
            [963906841] = new WeaponStats{
                displayname = "Rock",
                shortname = "rock",
                damage = 10.0,
                attack_rate = 46.0 / 60.0,
                attack_size = 0.2,
                range = 1.3,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [442886268] = new WeaponStats{
                displayname = "Rocket Launcher",
                shortname = "rocket.launcher",
                damage = 350.0,
                accuracy = 4.0,
                recoil = 30.0,
                attack_rate = 10.0 / 60.0,
                range = 1.0,
                attachments = 0.0,
                aimcone = 2.25,
                capacity = 1.0,
                reload = 6.0,
                draw = 1.0
            },
            [-262590403] = new WeaponStats{
                displayname = "Salvaged Axe",
                shortname = "axe.salvaged",
                damage = 40.0,
                attack_rate = 48.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [-1978999529] = new WeaponStats{
                displayname = "Salvaged Cleaver",
                shortname = "salvaged.cleaver",
                damage = 60.0,
                attack_rate = 30.0 / 60.0,
                attack_size = 0.4,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [-1506397857] = new WeaponStats{
                displayname = "Salvaged Hammer",
                shortname = "hammer.salvaged",
                damage = 30.0,
                attack_rate = 60.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [-1780802565] = new WeaponStats{
                displayname = "Salvaged Icepick",
                shortname = "icepick.salvaged",
                damage = 40.0,
                attack_rate = 48.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [1326180354] = new WeaponStats{
                displayname = "Salvaged Sword",
                shortname = "salvaged.sword",
                damage = 50.0,
                attack_rate = 48.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [-1878475007] = new WeaponStats{
                displayname = "Satchel Charge",
                shortname = "explosive.satchel",
                explosive_dmg = 75.0,
                lethality = 475.0,
                throw_distance = 20.0,
                fuse_length_min = 6.0,
                fuse_length_max = 12.0,
                blast_radius = 4.0,
                dud_chance = 0.2
            },
            [818877484] = new WeaponStats{
                displayname = "Semi-Automatic Pistol",
                shortname = "pistol.semiauto",
                damage = 40.0,
                accuracy = 4.0,
                recoil = 10.0,
                attack_rate = 400.0 / 60.0,
                range = 45.0,
                attachments = 3.0,
                aimcone = 0.75,
                capacity = 10.0,
                reload = 2.9,
                draw = 0.5
            },
            [-904863145] = new WeaponStats{
                displayname = "Semi-Automatic Rifle",
                shortname = "rifle.semiauto",
                damage = 40.0,
                accuracy = 4.0,
                recoil = 7.0,
                attack_rate = 343.0 / 60.0,
                range = 188.0,
                attachments = 3.0,
                aimcone = 0.25,
                capacity = 16.0,
                reload = 4.4,
                draw = 1.6
            },
            [-1850571427] = new WeaponStats{
                displayname = "Silencer",
                shortname = "weapon.mod.silencer",
                velocity = -0.25,
                damage = -0.25,
                accuracy = 0.33,
                recoil = -0.2,
                aimcone = -0.3,
                aimcone_hip = -0.3,
                aim_sway = -0.2
            },
            [-855748505] = new WeaponStats{
                displayname = "Simple Handmade Sight",
                shortname = "weapon.mod.simplesight",
                zoom = -0.5
            },
            [1263920163] = new WeaponStats{
                displayname = "Smoke Grenade",
                shortname = "grenade.smoke",
                throw_distance = 20.0,
                fuse_length_min = 1.0,
                fuse_length_max = 1.0
            },
            [-363689972] = new WeaponStats{
                displayname = "Snowball",
                shortname = "snowball",
                damage = 30.0,
                attack_rate = 46.0 / 60.0,
                attack_size = 0.2,
                range = 1.3,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [-41440462] = new WeaponStats{
                displayname = "Spas-12 Shotgun",
                shortname = "shotgun.spas12",
                damage = 137.0,
                accuracy = 14.0,
                recoil = 22.0,
                attack_rate = 180.0 / 60.0,
                range = 45.0,
                attachments = 3.0,
                aimcone = 0.0,
                capacity = 6.0,
                reload = 5.8,
                draw = 1.6
            },
            [-1583967946] = new WeaponStats{
                displayname = "Stone Hatchet",
                shortname = "stonehatchet",
                damage = 15.0,
                attack_rate = 67.0 / 60.0,
                attack_size = 0.3,
                range = 1.5,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [171931394] = new WeaponStats{
                displayname = "Stone Pickaxe",
                shortname = "stone.pickaxe",
                damage = 17.0,
                attack_rate = 67.0 / 60.0,
                attack_size = 0.3,
                range = 2.8,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [1602646136] = new WeaponStats{
                displayname = "Stone Spear",
                shortname = "spear.stone",
                damage = 35.0,
                attack_rate = 40.0 / 60.0,
                attack_size = 0.2,
                range = 2.8,
                draw = 1.0,
                melee = true,
                thrown = true
            },
            [1397052267] = new WeaponStats{
                displayname = "Supply Signal",
                shortname = "supply.signal",
                throw_distance = 20.0,
                fuse_length_min = 4.0,
                fuse_length_max = 4.0
            },
            [1975934948] = new WeaponStats{
                displayname = "Survey Charge",
                shortname = "surveycharge",
                explosive_dmg = 8.0,
                lethality = 20.0,
                throw_distance = 8.0,
                fuse_length_min = 5.0,
                fuse_length_max = 5.0,
                blast_radius = 5.0
            },
            [1248356124] = new WeaponStats{
                displayname = "Timed Explosive Charge",
                shortname = "explosive.timed",
                explosive_dmg = 550.0,
                lethality = 550.0,
                throw_distance = 20.0,
                fuse_length_min = 10.0,
                fuse_length_max = 10.0,
                blast_radius = 4.0
            },
            [795236088] = new WeaponStats{
                displayname = "Torch",
                shortname = "torch",
                damage = 5.0,
                attack_rate = 46.0 / 60.0,
                attack_size = 0.2,
                range = 1.5,
                draw = 1.0,
                melee = true
            },
            [-1758372725] = new WeaponStats{
                displayname = "Thompson",
                shortname = "smg.thompson",
                damage = 38.0,
                accuracy = 3.0,
                recoil = 8.0,
                attack_rate = 462.0 / 60.0,
                range = 90.0,
                attachments = 3.0,
                aimcone = 0.5,
                capacity = 20.0,
                reload = 4.0,
                draw = 1.0
            },
            [1424075905] = new WeaponStats{
                displayname = "Water Bucket",
                shortname = "bucket.water"
            },
            [-1367281941] = new WeaponStats{
                displayname = "Waterpipe Shotgun",
                shortname = "shotgun.waterpipe",
                damage = 180.0,
                accuracy = 15.0,
                recoil = 22.0,
                attack_rate = 13.0 / 60.0,
                range = 10.0,
                attachments = 2.0,
                aimcone = 1.0,
                capacity = 1.0,
                reload = 4.5,
                draw = 2.4
            },
            [952603248] = new WeaponStats{
                displayname = "Weapon Flashlight",
                shortname = "weapon.mod.flashlight"
            },
            [-132516482] = new WeaponStats{
                displayname = "Weapon Laserlight",
                shortname = "weapon.mod.lasersight",
                accuracy = 0.44,
                aimcone = -0.2,
                aimcone_hip = -0.4,
                aim_sway = -0.9
            },
            [1540934679] = new WeaponStats{
                displayname = "Wooden Spear",
                shortname = "spear.wooden",
                damage = 25.0,
                attack_rate = 40.0 / 60.0,
                attack_size = 0.2,
                range = 2.6,
                draw = 1.0,
                melee = true,
                thrown = true
            }
        };
        
        #endregion

        #region _local_classes_

        internal class AddressInfo
        {
            public List<ulong> userid;
            public bool        whitelist;
        }

        internal class AttackInfo
        {
            public DateTime time;
            public ulong    userid;
            public double   penalty;
        }

        internal class DB
        {
            public Dictionary<ulong, Handicap>     handicaps;
            public Dictionary<string, AddressInfo> ip_table;

            public DB()
            {
                handicaps = new Dictionary<ulong, Handicap>();
                ip_table  = new Dictionary<string, AddressInfo>();
            }
        }

        internal class Fire : MonoBehaviour
        {
            public BaseEntity Initiator;
        }

        internal class Handicap
        {
            public string   display_name;
            public double   damage_amount;
            public DateTime decay_timer;
            public DateTime online_time;
            public ulong    warning_count;
            public DateTime warning_time;
            public ulong    cripple_count;
            public DateTime cripple_timer;
            public bool     crippled;
            public ulong    ban_count;
            public DateTime ban_timer;
            public bool     banned;

            public void processDeath(double penalty)
            {
                if(damage_amount < config.handicap_damage_max)
                {
                    if((damage_amount *= (1.0 + penalty)) > config.handicap_damage_max)
                    {
                        damage_amount = config.handicap_damage_max;
                    }

                    decay_timer = DateTime.UtcNow;
                }
            }

            public void processKill(double penalty)
            {
                if(damage_amount > config.handicap_damage_min)
                {
                    if((damage_amount /= (1.0 + penalty)) < config.handicap_damage_min)
                    {
                        damage_amount = config.handicap_damage_min;
                    }

                    decay_timer = DateTime.UtcNow;
                }
            }
        }

        internal class WeaponStats
        {
            public double accuracy;
            public double aim_sway;
            public double aimcone;
            public bool   aimcone_degrees;
            public double aimcone_hip;
            public double attachments;
            public double attack_rate;
            public double attack_size;
            public double blast_radius;
            public double capacity;
            public double damage;
            public string displayname;
            public double draw;
            public double dud_chance;
            public double explosive_dmg;
            public double fuse_length_min;
            public double fuse_length_max;
            public double lethality;
            public bool   melee;
            public double range;
            public double recoil;
            public double reload;
            public string shortname;
            public double throw_distance;
            public bool   thrown;
            public double velocity;
            public double zoom;
        }

        #endregion

        #region _configuration_

        internal class Configuration
        {
            // configuration: version
            public ulong config_version;

            // configuration: general settings
            public bool general_pvp_enabled;    // enables pvp damage on the server
            public bool general_pvp_ff_enabled; // enables pvp friendly fire damage on the server
            public bool general_pvp_team_scale; // scale damage by online team sizes

            // configuration: handicap adjustments
            public double handicap_assist_scale;    // per-assist penalty scale (0.0, 1.0]
            public ulong  handicap_ban_count;       // auto-ban ban count, (0 disabled)
            public ulong  handicap_ban_time;        // auto-ban time, in hours
            public double handicap_build_authed;    // build authed penalty scale [0.0, 1.0]
            public ulong  handicap_cripple_count;   // auto-ban cripple count (0 disabled)
            public double handicap_cripple_limit;   // auto-cripple threshold [0.0, 1.0]
            public ulong  handicap_cripple_time;    // auto-cripple time, in minutes
            public double handicap_damage_max;      // maximum damage multiplier [0.0, 1.0]
            public double handicap_damage_min;      // minimum damage multiplier (0.0, 1.0]
            public double handicap_decay_amount;    // handicap decay amount (0.0, 1.0]
            public ulong  handicap_decay_time;      // handicap decay time, in seconds
            public double handicap_killer_scale;    // per-kill penalty scale (0.0, 1.0]
            public double handicap_penalty_head;    // per-hit penalty [0.0, 1.0]
            public double handicap_penalty_chest;   // per-hit penalty [0.0, 1.0]
            public double handicap_penalty_arm;     // per-hit penalty [0.0, 1.0]
            public double handicap_penalty_stomach; // per-hit penalty [0.0, 1.0]
            public double handicap_penalty_leg;     // per-hit penalty [0.0, 1.0]
            public double handicap_penalty_hand;    // per-hit penalty [0.0, 1.0]
            public double handicap_penalty_foot;    // per-hit penalty [0.0, 1.0]
            public double handicap_penalty_generic; // per-hit penalty [0.0, 1.0]
            public double handicap_movement_rate;   // normal movement rate in meters/second
            public double handicap_range_normal;    // normal weapon range (0.0, 1.0]
            public ulong  handicap_warning_count;   // auto-cripple warning count (0 disabled)
            public double handicap_warning_limit;   // admin warning threshold [0.0, 1.0]

            // configuration: diagnostic outputs
            public bool output_console; // output event details to the server console
            public bool output_logfile; // output event details to the server logfile

            public static Configuration Defaults()
            {
                return new Configuration
                {
                    config_version = 10101,

                    general_pvp_enabled    = true,
                    general_pvp_ff_enabled = true,
                    general_pvp_team_scale = true,

                    handicap_assist_scale    = 0.5,
                    handicap_ban_count       = 3,
                    handicap_ban_time        = 24,
                    handicap_build_authed    = 0.5,
                    handicap_cripple_count   = 3,
                    handicap_cripple_limit   = 0.0625,
                    handicap_cripple_time    = 60,
                    handicap_damage_max      = 1.0,
                    handicap_damage_min      = 0.0001,
                    handicap_decay_amount    = 0.5,
                    handicap_decay_time      = 180,
                    handicap_killer_scale    = 0.75,
                    handicap_penalty_head    = 1.00,
                    handicap_penalty_chest   = 0.75,
                    handicap_penalty_arm     = 0.5,
                    handicap_penalty_stomach = 0.5,
                    handicap_penalty_leg     = 0.5,
                    handicap_penalty_hand    = 0.25,
                    handicap_penalty_foot    = 0.25,
                    handicap_penalty_generic = 0.5,
                    handicap_movement_rate   = 2.5,
                    handicap_range_normal    = 0.25,
                    handicap_warning_count   = 3,
                    handicap_warning_limit   = 0.125,

                    output_console = true,
                    output_logfile = true
                };
            }
        }

        private void CheckRange(ref double value, double min, double max)
        {
            if(value < min)
            {
                value = min; config_changed = true;
            }
            else if(value > max)
            {
                value = max; config_changed = true;
            }
        }

        private void CheckRange(ref ulong value, ulong min, ulong max)
        {
            if(value < min)
            {
                value = min; config_changed = true;
            }
            else if(value > max)
            {
                value = max; config_changed = true;
            }
        }

        protected override void LoadDefaultConfig() { }

        private void LoadConfiguration()
        {
            try
            {
                if(Config["Config", "Version"] is string)
                {
                    throw new Exception();
                }

                config = Config.ReadObject<Configuration>();
            }
            catch(Exception)
            {
                Puts(lang.GetMessage(c_error_bad_config, this));

                config = Configuration.Defaults();

                config_changed = true;
            }

            CheckRange(ref config.handicap_assist_scale,    double.Epsilon, 1.0);
            CheckRange(ref config.handicap_build_authed,    0.0,            1.0);
            CheckRange(ref config.handicap_ban_count,       0,              100);
            CheckRange(ref config.handicap_ban_time,        0,              720);
            CheckRange(ref config.handicap_cripple_count,   0,              100);
            CheckRange(ref config.handicap_cripple_limit,   0.0,            1.0);
            CheckRange(ref config.handicap_cripple_time,    0,              10080);
            CheckRange(ref config.handicap_damage_max,      double.Epsilon, 1.0);
            CheckRange(ref config.handicap_damage_min,      double.Epsilon, 1.0);
            CheckRange(ref config.handicap_decay_amount,    double.Epsilon, 1.0);
            CheckRange(ref config.handicap_decay_time,      15,             3600);
            CheckRange(ref config.handicap_killer_scale,    double.Epsilon, 1.0);
            CheckRange(ref config.handicap_penalty_head,    0.0,            1.0);
            CheckRange(ref config.handicap_penalty_chest,   0.0,            1.0);
            CheckRange(ref config.handicap_penalty_arm,     0.0,            1.0);
            CheckRange(ref config.handicap_penalty_stomach, 0.0,            1.0);
            CheckRange(ref config.handicap_penalty_leg,     0.0,            1.0);
            CheckRange(ref config.handicap_penalty_hand,    0.0,            1.0);
            CheckRange(ref config.handicap_penalty_foot,    0.0,            1.0);
            CheckRange(ref config.handicap_penalty_generic, 0.0,            1.0);
            CheckRange(ref config.handicap_movement_rate,   1.5,            4.5);
            CheckRange(ref config.handicap_range_normal,    double.Epsilon, 1.0);
            CheckRange(ref config.handicap_warning_count,   0,              100);
            CheckRange(ref config.handicap_warning_limit,   0.0,            1.0);

            SaveConfiguration();
        }

        private void SaveConfiguration()
        {
            if(config_changed)
            {
                Config.WriteObject(config);

                config_changed = false;
            }
        }

        #endregion

        #region _localization_

        // localization string identifiers
        private const string c_assist                    = "CAssist";
        private const string c_auto_ban_cripple_count    = "CAutoBanCrippleCount";
        private const string c_auto_ban_inherited        = "CAutoBanInherited";
        private const string c_ban_no_reason             = "CBanNoReason";
        private const string c_error_bad_config          = "CErrorBadConfig";
        private const string c_killer                    = "CKiller";
        private const string c_pvp_admin_banned_perm     = "CPvpAdminBannedPerm";
        private const string c_pvp_admin_banned_time     = "CPvpAdminBannedTime";
        private const string c_pvp_admin_crippled_perm   = "CPvpAdminCrippledPerm";
        private const string c_pvp_admin_crippled_time   = "CPvpAdminCrippledTime";
        private const string c_status                    = "CStatus";
        private const string c_victim                    = "CVictim";
        private const string m_error_admin_ipshare       = "MErrorAdminIPShare";
        private const string m_error_admin_syntax        = "MErrorAdminSyntax";
        private const string m_error_no_permission       = "MErrorNoPermission";
        private const string m_handicap_admin            = "MHandicapAdmin";
        private const string m_prefix                    = "MPrefix";
        private const string m_pvp_admin_ambiguous       = "MPvpAdminAmbiguous";
        private const string m_pvp_admin_ban             = "MPvpAdminBan";
        private const string m_pvp_admin_cripple         = "MPvpAdminCripple";
        private const string m_pvp_admin_disabled        = "MPvpAdminDisabled";
        private const string m_pvp_admin_disabled_reason = "MPvpAdminDisabledReason";
        private const string m_pvp_admin_enabled         = "MPvpAdminEnabled";
        private const string m_pvp_admin_ff_disabled     = "MPvpAdminFfDisabled";
        private const string m_pvp_admin_ff_enabled      = "MPvpAdminFfEnabled";
        private const string m_pvp_admin_ipshare_list    = "MPvpAdminIPShareList";
        private const string m_pvp_admin_ipshare_off     = "MPvpAdminIPShareOff";
        private const string m_pvp_admin_ipshare_on      = "MPvpAdminIPShareOn";
        private const string m_pvp_admin_modifier        = "MPvpAdminModifier";
        private const string m_pvp_admin_not_crippled    = "MPvpAdminNotCrippled";
        private const string m_pvp_admin_not_handicapped = "MPvpAdminNotHandicapped";
        private const string m_pvp_admin_not_found       = "MPvpAdminNotFound";
        private const string m_pvp_admin_reset           = "MPvpAdminReset";
        private const string m_pvp_admin_reset_all       = "MPvpAdminResetAll";
        private const string m_pvp_admin_team_disabled   = "MPvpAdminTeamDisabled";
        private const string m_pvp_admin_team_enabled    = "MPvpAdminTeamEnabled";
        private const string m_pvp_admin_team_list       = "MPvpAdminTeamList";
        private const string m_pvp_admin_unban           = "MPvpAdminUnban";
        private const string m_pvp_admin_unban_all       = "MPvpAdminUnbanAll";
        private const string m_pvp_admin_uncripple       = "MPvpAdminUncripple";
        private const string m_pvp_admin_uncripple_all   = "MPvpAdminUncrippleAll";
        private const string m_pvp_admin_warning         = "MPvpAdminWarning";
        private const string m_pvp_damage_decrease       = "MPvpDamageDecrease";
        private const string m_pvp_damage_increase       = "MPvpDamageIncrease";
        private const string m_pvp_damage_modifier       = "MPvpDamageModifier";
        private const string m_pvp_ff_is_disabled        = "MPvpFfIsDisabled";
        private const string m_pvp_ff_is_enabled         = "MPvpFfIsEnabled";
        private const string m_pvp_is_disabled           = "MPvpIsDisabled";
        private const string m_pvp_is_enabled            = "MPvpIsEnabled";
        private const string m_pvp_team_is_disabled      = "MPvpTeamIsDisabled";
        private const string m_pvp_team_is_enabled       = "MPvpTeamIsEnabled";
        private const string m_suffix                    = "MSuffix";

        // localization strings
        private readonly Dictionary<string, string> messages = new Dictionary<string, string>
        {
            [c_assist]                    = "assist",
            [c_auto_ban_cripple_count]    = "Too many violations (cripple limit reached)",
            [c_auto_ban_inherited]        = "Alternate account (ban inherited)",
            [c_ban_no_reason]             = "No reason given",
            [c_error_bad_config]          = "Configuration file bad or missing. Loading default configuration.",
            [c_killer]                    = "killer",
            [c_pvp_admin_banned_perm]     = " (banned permanently)",
            [c_pvp_admin_banned_time]     = " (banned for {0}h)",
            [c_pvp_admin_crippled_perm]   = " (crippled permanently)",
            [c_pvp_admin_crippled_time]   = " (crippled for {0}m)",
            [c_status]                    = "status",
            [c_victim]                    = "victim",
            [m_error_admin_ipshare]       = "<color=#ff7f7f>IP address not found for {0}.</color>",
            [m_error_admin_syntax]        = "<color=#ffff7f>Usage:\n   /pvp * [ff [off | on] | list | off [message] | on | reset | team [off | on] | unban | uncripple]\n   /pvp (steamid | displayname) [ban [hours] [reason] | cripple [minutes] | reset | unban | uncripple]\n   /pvp (steamid | displayname) ipshare [ban [hours] [reason] | list | off | on | unban]\n   /pvp (steamid | displayname) team [ban [hours] [reason] | cripple [minutes] | reset | unban | uncripple]</color>",
            [m_error_no_permission]       = "<color=#ff0000>You do not have permission to use this command.</color>",
            [m_handicap_admin]            = "{0}",
            [m_prefix]                    = "<size=12><color=#ff1f1f>[</color><color=#ff3f1f>P</color><color=#ff5f1f>v</color><color=#ff7f1f>P</color><color=#ff9f1f>C</color><color=#ff7f1f>a</color><color=#ff5f1f>p</color><color=#ff3f1f>s</color><color=#ff1f1f>]</color> ",
            [m_pvp_admin_ambiguous]       = "<color=#ff7f7f>Multiple players found:{0}</color>",
            [m_pvp_admin_ban]             = "<color=#ff7f7f>{0} has BANNED {1}.</color>",
            [m_pvp_admin_cripple]         = "<color=#ff7f7f>{0} has CRIPPLED {1}.</color>",
            [m_pvp_admin_disabled]        = "<color=#ff7f7f>{0} has DISABLED PvP damage on the server.</color>",
            [m_pvp_admin_disabled_reason] = "<color=#ff7f7f>{0} has DISABLED PvP damage on the server. (Reason: {1})</color>",
            [m_pvp_admin_enabled]         = "<color=#7fff00>{0} has ENABLED PvP damage on the server.</color>",
            [m_pvp_admin_ff_disabled]     = "<color=#ff7f7f>{0} has DISABLED friendly fire damage on the server.</color>",
            [m_pvp_admin_ff_enabled]      = "<color=#7fff00>{0} has ENABLED friendly fire damage on the server.</color>",
            [m_pvp_admin_ipshare_list]    = "<color=#ffff00>Connection history for {0}:{1}</color>",
            [m_pvp_admin_ipshare_off]     = "<color=#ffff00>IP sharing is DISABLED for {0}.</color>",
            [m_pvp_admin_ipshare_on]      = "<color=#ffff00>IP sharing is ENABLED for {0}.</color>",
            [m_pvp_admin_modifier]        = "<color=#ffff00>{0}'s PvP damage modifier is {1}%.</color><color=#ff7f7f>{2}</color>",
            [m_pvp_admin_not_crippled]    = "<color=#ffff00>No crippled players found.</color>",
            [m_pvp_admin_not_handicapped] = "<color=#ffff00>No handicapped players found.</color>",
            [m_pvp_admin_not_found]       = "<color=#ff7f7f>Player not found: {0}</color>",
            [m_pvp_admin_reset]           = "<color=#ffff00>{0} has RESET the handicap for {1}.</color>",
            [m_pvp_admin_reset_all]       = "<color=#ffff00>{0} has RESET the handicaps for all players.</color>",
            [m_pvp_admin_team_disabled]   = "<color=#ff7f7f>{0} has DISABLED team size scaling on the server.</color>",
            [m_pvp_admin_team_enabled]    = "<color=#7fff00>{0} has ENABLED team size scaling on the server.</color>",
            [m_pvp_admin_team_list]       = "<color=#ffff00>{0}'s team members:</color>",
            [m_pvp_admin_unban]           = "<color=#7fff00>{0} has UNBANNED {1}.</color>",
            [m_pvp_admin_unban_all]       = "<color=#7fff00>{0} has UNBANNED all players.</color>",
            [m_pvp_admin_uncripple]       = "<color=#7fff00>{0} has UNCRIPPLED {1}.</color>",
            [m_pvp_admin_uncripple_all]   = "<color=#7fff00>{0} has UNCRIPPLED all players.</color>",
            [m_pvp_admin_warning]         = "<color=#ffff00>WARNING: {0} received a penalty of -{1}%.</color>",
            [m_pvp_damage_decrease]       = "<color=#ff7f00>Your PvP damage modifier decreased to {0}%.</color>",
            [m_pvp_damage_increase]       = "<color=#7fff00>Your PvP damage modifier increased to {0}%.</color>",
            [m_pvp_damage_modifier]       = "<color=#ffff00>Your PvP damage modifier is {0}%.</color>",
            [m_pvp_ff_is_disabled]        = "<color=#ff7f7f>Friendly fire is disabled.</color>",
            [m_pvp_ff_is_enabled]         = "<color=#7fff00>Friendly fire is enabled.</color>",
            [m_pvp_is_disabled]           = "<color=#ff7f7f>PvP is disabled.</color>",
            [m_pvp_is_enabled]            = "<color=#7fff00>PvP is enabled.</color>",
            [m_pvp_team_is_disabled]      = "<color=#ff7f7f>Team size scaling is disabled.</color>",
            [m_pvp_team_is_enabled]       = "<color=#7fff00>Team size scaling is enabled.</color>",
            [m_suffix]                    = "</size>"
        };

        internal static void ChatMessage(BasePlayer player, string key, params object[] args)
        {
            if(player == null)
            {
                instance.Puts(string.Format(ToPlaintext(instance.lang.GetMessage(key, instance)), args));
            }
            else if(player.IsConnected)
            {
                string prefix = GetMessage(m_prefix, player.UserIDString);

                string middle = GetMessage(key, player.UserIDString, args);

                string suffix = GetMessage(m_suffix, player.UserIDString);

                StringBuilder message = new StringBuilder(prefix.Length + middle.Length + suffix.Length);
                
                message.Append(prefix).Append(middle).Append(suffix);

                player.ChatMessage(message.ToString());
            }
        }

        internal static void ChatMessageAdmin(string key, params object[] args)
        {
            foreach(var player in BasePlayer.activePlayerList)
            {
                if(instance.permission.UserHasPermission(player.UserIDString, PERMISSIONADMIN))
                {
                    ChatMessage(player, key, args);
                }
            }
        }

        internal static void ChatMessageBroadcast(string key, params object[] args)
        {
            foreach(var player in BasePlayer.activePlayerList)
            {
                ChatMessage(player, key, args);
            }
        }

        internal static string CrippleStatus(ulong userid, string admin_id = null)
        {
            if(db.handicaps[userid].banned)
            {
                if(db.handicaps[userid].ban_timer == DateTime.MinValue)
                {
                    return GetMessage(c_pvp_admin_banned_perm, admin_id);
                }
                else
                {
                    double hours = db.handicaps[userid].ban_timer.Subtract(DateTime.UtcNow).TotalMinutes / 60.0;

                    return GetMessage(c_pvp_admin_banned_time, admin_id, hours.ToString("0.0"));
                }
            }
            else if(db.handicaps[userid].crippled)
            {
                if(db.handicaps[userid].cripple_timer == DateTime.MinValue)
                {
                    return GetMessage(c_pvp_admin_crippled_perm, admin_id);
                }
                else
                {
                    double minutes = db.handicaps[userid].cripple_timer.Subtract(DateTime.UtcNow).TotalMinutes;

                    return GetMessage(c_pvp_admin_crippled_time, admin_id, minutes.ToString("0.0"));
                }
            }

            return string.Empty;
        }

        internal static string DamagePercent(ulong userid)
        {
            return (db.handicaps[userid].damage_amount * 100.0).ToString("0.00");
        }

        internal static string HandicapInfoAdmin(ulong userid, string admin_id = null)
        {
            if(admin_id == null)
            {
                string format = ToPlaintext(instance.lang.GetMessage(m_pvp_admin_modifier, instance));

                return string.Format(format, NameAndID(userid), DamagePercent(userid), CrippleStatus(userid));
            }
            else
            {
                return GetMessage(m_pvp_admin_modifier, admin_id, NameAndID(userid), DamagePercent(userid), CrippleStatus(userid, admin_id));
            }
        }

        internal static string HandicapInfoConsole(string key, ulong userid)
        {
            string label = instance.lang.GetMessage(key, instance);

            return string.Format("{0}[{1}: {2}%{3}]", label, NameAndID(userid), DamagePercent(userid), CrippleStatus(userid));
        }

        protected static string GetMessage(string key, string userid, params object[] args) => string.Format(instance.lang.GetMessage(key, instance, userid), args);

        protected static string GetMessagePlain(string key) => ToPlaintext(instance.lang.GetMessage(key, instance));

        protected override void LoadDefaultMessages() => lang.RegisterMessages(messages, this, "en");

        internal static void LogMessage(string key, params object[] args)
        {
            if(config.output_console || config.output_logfile)
            {
                string message = string.Format(GetMessagePlain(key), args);

                if(config.output_console)
                {
                    instance.Puts(message);
                }

                if(config.output_logfile)
                {
                    string time = DateTime.Now.ToString("T", DateTimeFormatInfo.InvariantInfo);

                    instance.LogToFile("log", string.Format("{0}: {1}", time, message), instance);
                }
            }
        }

        internal static string NameAndID(ulong userid)
        {
            return string.Format("{0}({1})", db.handicaps[userid].display_name, userid.ToString());
        }

        internal static string ToPlaintext(string message)
        {
            string result = string.Empty;

            if(message != null)
            {
                StringBuilder sb_result = new StringBuilder(Regex.Replace(message, "<[^>]+>", ""));

                sb_result.Replace("&lt;", "<");
                sb_result.Replace("&gt;", ">");
                sb_result.Replace("&amp;", "&");

                result = sb_result.ToString();
            }

            return result;
        }

        #endregion

        #region _commands_

        [ChatCommand("pvp")]
        private void ChatCmdPvP(BasePlayer player, string cmd, string[] args)
        {
            bool console = (player == null);

            string admin_id = console ? null : player.UserIDString;

            string admin_name = console ? "CONSOLE" : player.displayName;

            if((args == null) || args.Length == 0)
            {
                if(console)
                {
                    bool entry_found = false;

                    foreach(var entry in db.handicaps)
                    {
                        if(entry.Value.crippled || entry.Value.damage_amount != config.handicap_damage_max)
                        {
                            ChatMessage(player, m_handicap_admin, HandicapInfoAdmin(entry.Key, admin_id));

                            entry_found = true;
                        }
                    }

                    if(!entry_found)
                    {
                        ChatMessage(player, m_pvp_admin_not_handicapped);
                    }
                }
                else
                {
                    if(permission.UserHasPermission(player.UserIDString, PERMISSIONUSE))
                    {
                        ChatMessage(player, m_pvp_damage_modifier, DamagePercent(player.userID));
                    }
                    else
                    {
                        ChatMessage(player, m_error_no_permission);
                    }
                }

                return;
            }

            if(!console && !permission.UserHasPermission(player.UserIDString, PERMISSIONADMIN))
            {
                ChatMessage(player, m_error_no_permission);

                return;
            }

            if(args[0] == "*")
            {
                if(args.Length == 1)
                {
                    ChatMessage(player, config.general_pvp_enabled ? m_pvp_is_enabled : m_pvp_is_disabled);

                    return;
                }

                if(args.Length > 3)
                {
                    goto syntax_error;
                }

                switch(args[1].ToLower())
                {
                case "ff":

                    if(args.Length == 2)
                    {
                        ChatMessage(player, config.general_pvp_ff_enabled ? m_pvp_ff_is_enabled : m_pvp_ff_is_disabled);

                        return;
                    }

                    switch(args[2].ToLower())
                    {
                    case "off":

                        config.general_pvp_ff_enabled = false; config_changed = true;

                        ChatMessageBroadcast(m_pvp_admin_ff_disabled, admin_name);

                        if(!config.output_console && console)
                        {
                            ChatMessage(player, m_pvp_admin_ff_disabled, admin_name);
                        }

                        LogMessage(m_pvp_admin_ff_disabled, admin_name);

                        return;

                    case "on":

                        config.general_pvp_ff_enabled = true; config_changed = true;

                        ChatMessageBroadcast(m_pvp_admin_ff_enabled, admin_name);

                        if(!config.output_console && console)
                        {
                            ChatMessage(player, m_pvp_admin_ff_enabled, admin_name);
                        }

                        LogMessage(m_pvp_admin_ff_enabled, admin_name);

                        return;

                    default:

                        goto syntax_error;
                    }

                case "list":

                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    bool entry_found = false;

                    foreach(var entry in db.handicaps)
                    {
                        if(entry.Value.crippled)
                        {
                            ChatMessage(player, m_handicap_admin, HandicapInfoAdmin(entry.Key, admin_id));

                            entry_found = true;
                        }
                    }

                    if(!entry_found)
                    {
                        ChatMessage(player, m_pvp_admin_not_crippled);
                    }

                    return;

                case "off":

                    if(args.Length == 2)
                    {
                        config.general_pvp_enabled = false; config_changed = true;

                        ChatMessageAdmin(m_pvp_admin_disabled, admin_name);

                        if(!config.output_console && console)
                        {
                            ChatMessage(player, m_pvp_admin_disabled, admin_name);
                        }

                        LogMessage(m_pvp_admin_disabled, admin_name);

                        return;
                    }

                    config.general_pvp_enabled = false; config_changed = true;

                    ChatMessageBroadcast(m_pvp_admin_disabled_reason, admin_name, args[2]);

                    if(!config.output_console && console)
                    {
                        ChatMessage(player, m_pvp_admin_disabled_reason, admin_name, args[2]);
                    }

                    LogMessage(m_pvp_admin_disabled_reason, admin_name, args[2]);

                    return;

                case "on":

                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    config.general_pvp_enabled = true; config_changed = true;

                    ChatMessageBroadcast(m_pvp_admin_enabled, admin_name);

                    if(!config.output_console && console)
                    {
                        ChatMessage(player, m_pvp_admin_enabled, admin_name);
                    }

                    LogMessage(m_pvp_admin_enabled, admin_name);

                    return;

                case "reset":

                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var entry in db.handicaps)
                    {
                        AdminReset(admin_name, entry.Key, true);
                    }

                    ChatMessageAdmin(m_pvp_admin_reset_all, admin_name);

                    if(!config.output_console && console)
                    {
                        ChatMessage(player, m_pvp_admin_reset_all, admin_name);
                    }

                    LogMessage(m_pvp_admin_reset_all, admin_name);

                    return;

                case "team":

                    if(args.Length == 2)
                    {
                        ChatMessage(player, config.general_pvp_team_scale ? m_pvp_team_is_enabled : m_pvp_team_is_disabled);

                        return;
                    }

                    switch(args[2].ToLower())
                    {
                    case "off":

                        config.general_pvp_team_scale = false; config_changed = true;

                        ChatMessageAdmin(m_pvp_admin_team_disabled, admin_name);

                        if(!config.output_console && console)
                        {
                            ChatMessage(player, m_pvp_admin_team_disabled, admin_name);
                        }

                        LogMessage(m_pvp_admin_team_disabled, admin_name);

                        return;

                    case "on":

                        config.general_pvp_team_scale = true; config_changed = true;

                        ChatMessageAdmin(m_pvp_admin_team_enabled, admin_name);

                        if(!config.output_console && console)
                        {
                            ChatMessage(player, m_pvp_admin_team_enabled, admin_name);
                        }

                        LogMessage(m_pvp_admin_team_enabled, admin_name);

                        return;

                    default:

                        goto syntax_error;
                    }

                case "unban":

                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var entry in covalence.Players.All.ToList())
                    {
                        if(covalence.Server.IsBanned(entry.Id))
                        {
                            ulong entryid = ulong.Parse(entry.Id);

                            if(db.handicaps.ContainsKey(entryid) && db.handicaps[entryid].banned)
                            {
                                AdminUnban(admin_name, entryid, true);

                                db.handicaps[entryid].ban_count = 0;
                            }
                            else
                            {
                                ExecuteUnban(entry.Id);
                            }
                        }
                    }

                    ChatMessageAdmin(m_pvp_admin_unban_all, admin_name);

                    if(!config.output_console && console)
                    {
                        ChatMessage(player, m_pvp_admin_unban_all, admin_name);
                    }

                    LogMessage(m_pvp_admin_unban_all, admin_name);

                    return;

                case "uncripple":

                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var entry in db.handicaps)
                    {
                        AdminUncripple(admin_name, entry.Key, true);
                    }

                    ChatMessageAdmin(m_pvp_admin_uncripple_all, admin_name);

                    if(!config.output_console && console)
                    {
                        ChatMessage(player, m_pvp_admin_uncripple_all, admin_name);
                    }

                    LogMessage(m_pvp_admin_uncripple_all, admin_name);

                    return;

                default:

                    goto syntax_error;
                }
            }

            List<ulong> found = FindPlayer(args[0]);

            if(found.Count == 0)
            {
                ChatMessage(player, m_pvp_admin_not_found, args[0]);

                return;
            }
            else if(found.Count > 1)
            {
                StringBuilder entries = new StringBuilder();

                foreach(var entry in found)
                {
                    entries.Append("\n - ").Append(NameAndID(entry));
                }

                ChatMessage(player, m_pvp_admin_ambiguous, entries.ToString());

                return;
            }

            ulong userid = found[0];

            if(args.Length == 1)
            {
                ChatMessage(player, m_handicap_admin, HandicapInfoAdmin(userid, admin_id));

                return;
            }

            ulong duration = 0; string reason;

            switch(args[1].ToLower())
            {
            case "ban":

                if(!ParseDurationAndReason(ref args, 2, out duration, out reason))
                {
                    goto syntax_error;
                }

                AdminBan(admin_name, userid, duration, reason, console);

                ChatMessage(player, m_handicap_admin, HandicapInfoAdmin(userid, admin_id));

                return;

            case "cripple":

                if(args.Length > 2)
                {
                    if(args.Length > 3 || !ulong.TryParse(args[2], out duration))
                    {
                        goto syntax_error;
                    }
                }

                AdminCripple(admin_name, userid, duration, console);

                ChatMessage(player, m_handicap_admin, HandicapInfoAdmin(userid, admin_id));

                return;

            case "ipshare":

                string ip_address = FindIPAddress(userid);

                if(ip_address == null)
                {
                    ChatMessage(player, m_error_admin_ipshare, NameAndID(userid));

                    return;
                }

                if(args.Length != 3)
                {
                    goto syntax_error;
                }

                switch(args[2].ToLower())
                {
                case "ban":

                    if(!ParseDurationAndReason(ref args, 3, out duration, out reason))
                    {
                        goto syntax_error;
                    }

                    foreach(var entry in db.ip_table[ip_address].userid)
                    {
                        AdminBan(admin_name, entry, duration, reason, console);
                    }

                    return;

                case "list":

                    StringBuilder entries = new StringBuilder();

                    foreach(var entry in db.ip_table[ip_address].userid)
                    {
                        entries.Append("\n - ").Append(NameAndID(entry));
                    }

                    ChatMessage(player, m_pvp_admin_ipshare_list, ip_address, entries.ToString());

                    break;

                case "off":

                    db.ip_table[ip_address].whitelist = false;

                    break;

                case "on":

                    db.ip_table[ip_address].whitelist = true;

                    break;

                case "unban":

                    if(args.Length != 3)
                    {
                        goto syntax_error;
                    }

                    foreach(var entry in db.ip_table[ip_address].userid)
                    {
                        AdminUnban(admin_name, entry, false, console);

                        db.handicaps[entry].ban_count = 0;
                    }

                    return;

                default:

                    goto syntax_error;
                }

                ChatMessage(player, db.ip_table[ip_address].whitelist ? m_pvp_admin_ipshare_on : m_pvp_admin_ipshare_off, NameAndID(userid));

                return;

            case "reset":

                if(args.Length != 2)
                {
                    goto syntax_error;
                }

                AdminReset(admin_name, userid, false, console);

                ChatMessage(player, m_handicap_admin, HandicapInfoAdmin(userid, admin_id));

                return;

            case "team":

                List<ulong> team = TeamList(userid);

                if(args.Length == 2)
                {
                    ChatMessage(player, m_pvp_admin_team_list, NameAndID(userid));

                    foreach(var entry in team)
                    {
                        ChatMessage(player, m_handicap_admin, HandicapInfoAdmin(entry, admin_id));
                    }

                    return;
                }

                switch(args[2].ToLower())
                {
                case "ban":

                    if(!ParseDurationAndReason(ref args, 3, out duration, out reason))
                    {
                        goto syntax_error;
                    }

                    foreach(var entry in team)
                    {
                        AdminBan(admin_name, entry, duration, reason, console);
                    }

                    return;

                case "cripple":

                    if(args.Length > 3)
                    {
                        if((args.Length > 4) || !ulong.TryParse(args[3], out duration))
                        {
                            goto syntax_error;
                        }
                    }

                    foreach(var entry in team)
                    {
                        AdminCripple(admin_name, entry, duration, console);
                    }

                    return;

                case "reset":

                    if(args.Length != 3)
                    {
                        goto syntax_error;
                    }

                    foreach(var entry in team)
                    {
                        AdminReset(admin_name, entry, false, console);
                    }

                    return;

                case "unban":

                    if(args.Length != 3)
                    {
                        goto syntax_error;
                    }

                    foreach(var entry in team)
                    {
                        AdminUnban(admin_name, entry, false, console);

                        db.handicaps[entry].ban_count = 0;
                    }

                    return;

                case "uncripple":

                    if(args.Length != 3)
                    {
                        goto syntax_error;
                    }

                    foreach(var entry in team)
                    {
                        AdminUncripple(admin_name, entry, false, console);
                    }

                    return;

                default:

                    goto syntax_error;
                }

            case "unban":

                if(args.Length != 2)
                {
                    goto syntax_error;
                }

                AdminUnban(admin_name, userid, false, console);

                db.handicaps[userid].ban_count = 0;

                ChatMessage(player, m_handicap_admin, HandicapInfoAdmin(userid, admin_id));

                return;

            case "uncripple":

                if(args.Length != 2)
                {
                    goto syntax_error;
                }

                AdminUncripple(admin_name, userid, false, console);

                ChatMessage(player, m_handicap_admin, HandicapInfoAdmin(userid, admin_id));

                return;

            default:

                goto syntax_error;
            }

        syntax_error:

            ChatMessage(player, m_error_admin_syntax);
        }

        [ConsoleCommand("pvp")]
        private void ConsoleCmdPvp(ConsoleSystem.Arg arg)
        {
            if(arg.IsRcon)
            {
                ChatCmdPvP(null, null, arg.Args);
            }
        }

        #endregion

        #region _helpers_

        internal void AdminBan(string admin_name, ulong userid, ulong duration, string reason, bool console = false)
        {
            if(permission.UserHasPermission(userid.ToString(), PERMISSIONADMIN))
            {
                return;
            }

            db.handicaps[userid].warning_count = 0;
            db.handicaps[userid].cripple_count = 0;
            db.handicaps[userid].cripple_timer = DateTime.MinValue;
            db.handicaps[userid].crippled      = false;
            db.handicaps[userid].banned        = true;

            if(duration > 0)
            {
                db.handicaps[userid].ban_timer = DateTime.UtcNow + TimeSpan.FromSeconds(3600.0 * duration);
            }
            else
            {
                db.handicaps[userid].ban_timer = DateTime.MinValue;
            }

            ExecuteBan(userid.ToString(), reason);

            ChatMessageAdmin(m_pvp_admin_ban, admin_name, NameAndID(userid));

            if(!config.output_console && console)
            {
                ChatMessage(null, m_pvp_admin_ban, admin_name, NameAndID(userid));
            }

            LogMessage(m_pvp_admin_ban, admin_name, NameAndID(userid));
        }

        internal void AdminBanInherited(string admin_name, ulong userid)
        {
            db.handicaps[userid].warning_count = 0;
            db.handicaps[userid].cripple_count = 0;
            db.handicaps[userid].cripple_timer = DateTime.MinValue;
            db.handicaps[userid].crippled      = false;

            ExecuteBan(userid.ToString(), GetMessagePlain(c_auto_ban_inherited));

            ChatMessageAdmin(m_pvp_admin_ban, admin_name, NameAndID(userid));

            LogMessage(m_pvp_admin_ban, admin_name, NameAndID(userid));
        }

        internal void AdminCripple(string admin_name, ulong userid, ulong duration, bool console = false)
        {
            db.handicaps[userid].crippled = true;

            if(duration > 0)
            {
                db.handicaps[userid].cripple_timer = DateTime.UtcNow + TimeSpan.FromSeconds(60.0 * duration);
            }
            else
            {
                db.handicaps[userid].cripple_timer = DateTime.MinValue;
            }

            ChatMessageAdmin(m_pvp_admin_cripple, admin_name, NameAndID(userid));

            if(!config.output_console && console)
            {
                ChatMessage(null, m_pvp_admin_cripple, admin_name, NameAndID(userid));
            }

            LogMessage(m_pvp_admin_cripple, admin_name, NameAndID(userid));
        }

        internal void AdminReset(string admin_name, ulong userid, bool silent = false, bool console = false)
        {
            if((db.handicaps[userid].damage_amount == config.handicap_damage_max) && !db.handicaps[userid].crippled)
            {
                return;
            }

            db.handicaps[userid].damage_amount = config.handicap_damage_max;
            db.handicaps[userid].decay_timer   = DateTime.UtcNow;
            db.handicaps[userid].warning_count = 0;
            db.handicaps[userid].cripple_count = 0;
            db.handicaps[userid].cripple_timer = DateTime.MinValue;
            db.handicaps[userid].crippled      = false;

            if(permission.UserHasPermission(userid.ToString(), PERMISSIONUSE))
            {
                ChatMessage(BasePlayer.FindByID(userid), m_pvp_damage_modifier, DamagePercent(userid));
            }

            if(!silent)
            {
                ChatMessageAdmin(m_pvp_admin_reset, admin_name, NameAndID(userid));

                if(!config.output_console && console)
                {
                    ChatMessage(null, m_pvp_admin_reset, admin_name, NameAndID(userid));
                }

                LogMessage(m_pvp_admin_reset, admin_name, NameAndID(userid));
            }
        }

        internal void AdminUnban(string admin_name, ulong userid, bool silent = false, bool console = false)
        {
            if(db.handicaps[userid].banned)
            {
                db.handicaps[userid].damage_amount = config.handicap_damage_max;
                db.handicaps[userid].decay_timer   = DateTime.UtcNow;
                db.handicaps[userid].warning_count = 0;
                db.handicaps[userid].cripple_count = 0;
                db.handicaps[userid].cripple_timer = DateTime.MinValue;
                db.handicaps[userid].crippled      = false;
                db.handicaps[userid].ban_timer     = DateTime.MinValue;
                db.handicaps[userid].banned        = false;
            }

            ExecuteUnban(userid.ToString());

            if(!silent)
            {
                ChatMessageAdmin(m_pvp_admin_unban, admin_name, NameAndID(userid));

                if(!config.output_console && console)
                {
                    ChatMessage(null, m_pvp_admin_unban, admin_name, NameAndID(userid));
                }

                LogMessage(m_pvp_admin_unban, admin_name, NameAndID(userid));
            }
        }

        internal void AdminUncripple(string admin_name, ulong userid, bool silent = false, bool console = false)
        {
            if(!db.handicaps[userid].crippled)
            {
                return;
            }

            db.handicaps[userid].decay_timer   = DateTime.UtcNow;
            db.handicaps[userid].cripple_timer = DateTime.MinValue;
            db.handicaps[userid].crippled      = false;

            if(!silent)
            {
                ChatMessageAdmin(m_pvp_admin_uncripple, admin_name, NameAndID(userid));

                if(!config.output_console && console)
                {
                    ChatMessage(null, m_pvp_admin_uncripple, admin_name, NameAndID(userid));
                }

                LogMessage(m_pvp_admin_uncripple, admin_name, NameAndID(userid));
            }
        }

        internal bool AutoBanCountReached(ulong userid)
        {
            return ((config.handicap_ban_count != 0) && (db.handicaps[userid].ban_count >= config.handicap_ban_count));
        }

        internal bool AutoCrippleCountReached(ulong userid)
        {
            return ((config.handicap_cripple_count != 0) && (db.handicaps[userid].cripple_count >= config.handicap_cripple_count));
        }

        internal bool AutoWarningCountReached(ulong userid)
        {
            return ((config.handicap_warning_count != 0) && (db.handicaps[userid].warning_count >= config.handicap_warning_count));
        }

        internal bool CanLoot(BasePlayer looter, ulong target)
        {
            if(target == looter.userID)
            {
                return true;
            }

            if(db.handicaps[looter.userID].crippled)
            {
                if(permission.UserHasPermission(looter.UserIDString, PERMISSIONADMIN))
                {
                    return true;
                }

                if(permission.UserHasPermission(looter.UserIDString, PERMISSIONEXCLUDED))
                {
                    return true;
                }

                return false;
            }

            return true;
        }

        internal object CanLootHelper(BasePlayer looter, ulong target)
        {
            if(!CanLoot(looter, target))
            {
                return false;
            }

            return null;
        }

        internal void DBLoad()
        {
            if((db = Interface.Oxide.DataFileSystem.ReadObject<DB>(this.Name)) == null)
            {
                db = new DB();
            }
        }

        internal void DBStore()
        {
            Interface.Oxide.DataFileSystem.WriteObject(this.Name, db);
        }

        internal void ExecuteBan(string user, string reason)
        {
            Server.Command("ban", user, reason);
        }

        internal void ExecuteUnban(string user)
        {
            Server.Command("unban", user);
        }

        internal string FindIPAddress(ulong userid)
        {
            foreach(var entry in db.ip_table)
            {
                foreach(var entry_id in entry.Value.userid)
                {
                    if(entry_id == userid)
                    {
                        return entry.Key;
                    }
                }
            }

            return null;
        }

        internal List<ulong> FindPlayer(string input)
        {
            string input_lower = input.ToLower();

            List<ulong> found = new List<ulong>();

            foreach(var entry in db.handicaps)
            {
                if(entry.Key.ToString() == input)
                {
                    found.Clear(); found.Add(entry.Key);

                    break;
                }
                else if(entry.Value.display_name.ToLower() == input_lower)
                {
                    found.Add(entry.Key);
                }
                else if(entry.Value.display_name.ToLower().Contains(input_lower))
                {
                    found.Add(entry.Key);
                }
            }

            return found;
        }

        internal double GetHitPenalty(BasePlayer attacker, BasePlayer victim, HitInfo info)
        {
            double penalty, range = 0.0, distance = attacker.Distance(victim);

            Item item = info?.Weapon?.GetItem();

            switch(info.boneArea)
            {
            case HitArea.Head:
                penalty = config.handicap_penalty_head; break;
            case HitArea.Chest:
                penalty = config.handicap_penalty_chest; break;
            case HitArea.Arm:
                penalty = config.handicap_penalty_arm; break;
            case HitArea.Stomach:
                penalty = config.handicap_penalty_stomach; break;
            case HitArea.Leg:
                penalty = config.handicap_penalty_leg; break;
            case HitArea.Hand:
                penalty = config.handicap_penalty_hand; break;
            case HitArea.Foot:
                penalty = config.handicap_penalty_foot; break;
            default:
                penalty = config.handicap_penalty_generic; break;
            }

            if((item != null) && weapons.ContainsKey(item.info.itemid))
            {
                WeaponStats weapon = weapons[item.info.itemid];

                if(weapon.melee)
                {
                    if((distance > (weapon.range + weapon.attack_size)) && weapon.thrown)
                    {
                        range = 10.0;
                    }
                    else
                    {
                        range = weapon.range + weapon.attack_size;
                    }
                }
                else
                {
                    double mod_zoom = 1.0;

                    if(attacker.IsAiming && (item.contents != null))
                    {
                        foreach(var weapon_mod in item.contents.itemList)
                        {
                            if(weapons.ContainsKey(weapon_mod.info.itemid))
                            {
                                WeaponStats mod = weapons[weapon_mod.info.itemid];

                                if(mod.zoom != 0.0)
                                {
                                    mod_zoom += mod.zoom * 0.0625;

                                    break;
                                }
                            }
                        }
                    }

                    range = weapon.range * mod_zoom * config.handicap_range_normal;
                }
            }

            if((range > 0.0) && (distance > range))
            {
                double distance_mod = distance / range;

                penalty *= distance_mod * distance_mod;
            }

            penalty *= GetSpeedModifier(attacker.estimatedSpeed, victim.estimatedSpeed, config.handicap_movement_rate);

            return penalty;
        }

        internal double GetSpeedModifier(double speed_a, double speed_b, double normal)
        {
            return ((speed_a < normal) ? 1.0 : (speed_a / normal)) * ((speed_b < normal) ? 1.0 : (speed_b / normal));
        }

        internal void HandicapsDecay()
        {
            TimeSpan interval = TimeSpan.FromSeconds((double)config.handicap_decay_time);

            foreach(var entry in db.handicaps)
            {
                if(entry.Value.banned)
                {
                    if(entry.Value.ban_timer != DateTime.MinValue && DateTime.UtcNow >= entry.Value.ban_timer)
                    {
                        AdminUnban("SERVER", entry.Key);
                    }

                    continue;
                }

                var player = BasePlayer.FindByID(entry.Key);

                if(entry.Value.crippled)
                {
                    if(entry.Value.cripple_timer != DateTime.MinValue && DateTime.UtcNow >= entry.Value.cripple_timer)
                    {
                        AdminUncripple("SERVER", entry.Key);
                    }
                }
                else
                {
                    if(entry.Value.damage_amount < config.handicap_damage_max)
                    {
                        var elapsed = DateTime.UtcNow.Subtract(entry.Value.decay_timer);

                        while((elapsed >= interval) && (entry.Value.damage_amount < config.handicap_damage_max))
                        {
                            entry.Value.processDeath(config.handicap_decay_amount);

                            if((player != null) && permission.UserHasPermission(player.UserIDString, PERMISSIONUSE))
                            {
                                ChatMessage(player, m_pvp_damage_increase, DamagePercent(entry.Key));
                            }

                            LogMessage(m_handicap_admin, HandicapInfoConsole(c_status, entry.Key));

                            elapsed -= interval;
                        }
                    }
                }

                if((player != null) && player.IsConnected)
                {
                    entry.Value.online_time = DateTime.UtcNow;
                }
            }
        }

        internal void OnLootHelper(BasePlayer looter, ulong target)
        {
            if(!CanLoot(looter, target))
            {
                NextTick(looter.EndLooting);
            }
        }

        internal bool ParseDurationAndReason(ref string[] args, int offset, out ulong duration, out string reason)
        {
            switch(args.Length - offset)
            {
            case 0:

                duration = 0;  reason = GetMessagePlain(c_ban_no_reason);

                return true;

            case 1:

                if(ulong.TryParse(args[offset], out duration))
                {
                    reason = GetMessagePlain(c_ban_no_reason);
                }
                else
                {
                    duration = 0; reason = args[offset];
                }

                return true;

            case 2:

                if(!ulong.TryParse(args[offset], out duration))
                {
                    goto syntax_error;
                }

                reason = args[offset + 1];

                return true;

            default:

                goto syntax_error;
            }

        syntax_error:

            duration = 0; reason = string.Empty;

            return false;
        }
        
        internal static double TeamDamageModifier(BasePlayer victim, BasePlayer attacker)
        {
            ulong attacker_count = TeamMembersOnline(attacker.currentTeam);

            ulong victim_count = TeamMembersOnline(victim.currentTeam);

            victim_count = (victim_count > 0) ? victim_count : 1;

            if(attacker_count > victim_count)
            {
                return ((double)victim_count) / ((double)attacker_count);
            }

            return 1.0;
        }

        internal static List<ulong> TeamList(ulong userid)
        {
            ulong teamid = 0;

            BasePlayer player = BasePlayer.FindByID(userid);

            if(player != null)
            {
                teamid = player.currentTeam;
            }
            else
            {
                foreach(var team in RelationshipManager.Instance.teams)
                {
                    if(team.Value.members.Contains(userid))
                    {
                        teamid = team.Key;
                    }
                }
            }

            if(teamid != 0)
            {
                return RelationshipManager.Instance.teams[teamid].members;
            }

            return new List<ulong> { userid };
        }
        
        internal static ulong TeamMembersOnline(ulong teamid)
        {
            if((teamid != 0) && teams.ContainsKey(teamid))
            {
                return teams[teamid];
            }
            
            return 0;
        }
        
        internal void TeamMonitor()
        {
            if(!config.general_pvp_team_scale)
            {
                return;
            }

            Dictionary<ulong, ulong> new_teams = new Dictionary<ulong, ulong>();

            foreach(var team in RelationshipManager.Instance.teams)
            {
                ulong count = 0;

                foreach(var userid in team.Value.members)
                {
                    OnPlayerConnected(userid, null);

                    BasePlayer player = BasePlayer.FindByID(userid);

                    if((player != null) && player.IsConnected)
                    {
                        ++count;
                    }
                }

                if(count > 0)
                {
                    new_teams.Add(team.Key, count);
                }
            }

            teams = new_teams;
        }

        internal void WorkTimer()
        {
            HandicapsDecay();

            TeamMonitor();

            timer.Once(5.0f, WorkTimer);
        }

        #endregion

        #region _hooks_

        private object CanLootEntity(BasePlayer looter, DroppedItemContainer target) => CanLootHelper(looter, target.playerSteamID);

        private object CanLootEntity(BasePlayer looter, LootableCorpse target) => CanLootHelper(looter, target.playerSteamID);

        private object CanLootPlayer(BasePlayer target, BasePlayer looter) => CanLootHelper(looter, target.userID);

        private void Init()
        {
            instance = this;

            permission.RegisterPermission(PERMISSIONADMIN, this);
            permission.RegisterPermission(PERMISSIONEXCLUDED, this);
            permission.RegisterPermission(PERMISSIONUSE, this);

            LoadConfiguration();

            DBLoad();
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if(entity == null || info == null)
            {
                return;
            }
                
            if(entity is BasePlayer)
            {
                BasePlayer victim = entity.ToPlayer();

                if(!victim.userID.IsSteamId())
                {
                    return;
                }

                if(!attacks.ContainsKey(victim.userID))
                {
                    attacks.Add(victim.userID, new List<AttackInfo>());
                }

                Dictionary<ulong, List<AttackInfo>> attackers = new Dictionary<ulong, List<AttackInfo>>();

                bool kill_excluded = false, kill_pvp = false;

                ulong last_attacker = 0;

                foreach(AttackInfo attackinfo in attacks[victim.userID])
                {
                    if(DateTime.UtcNow.Subtract(attackinfo.time) < TimeSpan.FromSeconds(config.handicap_decay_time))
                    {
                        if(!attackers.ContainsKey(attackinfo.userid))
                        {
                            attackers.Add(attackinfo.userid, new List<AttackInfo>());

                            if(permission.UserHasPermission(attackinfo.userid.ToString(), PERMISSIONEXCLUDED))
                            {
                                kill_excluded = true;

                                break;
                            }

                            kill_pvp = true;
                        }

                        attackers[last_attacker = attackinfo.userid].Add(attackinfo);
                    }
                }

                attacks[victim.userID].Clear();

                if(!kill_pvp || kill_excluded)
                {
                    return;
                }

                foreach(var attacklist in attackers)
                {
                    BasePlayer attacker = BasePlayer.FindByID(attacklist.Key);

                    if((attacker != null) && (attacklist.Value.Count > 0))
                    {
                        ulong hit_count = 0;
                        double hit_penalty = 0.0;

                        foreach(var attack in attacklist.Value)
                        {
                            ++hit_count; hit_penalty += attack.penalty;
                        }

                        hit_penalty /= hit_count;

                        double damage_scale = 1.0 / (1.0 + hit_penalty);

                        if(damage_scale <= config.handicap_warning_limit)
                        {
                            db.handicaps[attacker.userID].warning_time = DateTime.UtcNow;

                            string penalty = (100.0 * (1.0 - damage_scale)).ToString("0.00");

                            ChatMessageAdmin(m_pvp_admin_warning, NameAndID(attacker.userID), penalty);

                            LogMessage(m_pvp_admin_warning, NameAndID(attacker.userID), penalty);

                            if(config.handicap_warning_count != 0)
                            {
                                db.handicaps[attacker.userID].warning_count++;
                            }
                        }

                        if((damage_scale <= config.handicap_cripple_limit) || AutoWarningCountReached(attacker.userID))
                        {
                            AdminCripple("SERVER", attacker.userID, config.handicap_cripple_time);

                            db.handicaps[attacker.userID].warning_count = 0;

                            if(config.handicap_cripple_count != 0)
                            {
                                db.handicaps[attacker.userID].cripple_count++;
                            }
                        }

                        if(AutoCrippleCountReached(attacker.userID))
                        {
                            AdminBan("SERVER", attacker.userID, config.handicap_ban_time, GetMessagePlain(c_auto_ban_cripple_count));

                            if(config.handicap_ban_count != 0)
                            {
                                db.handicaps[attacker.userID].ban_count++;
                            }

                            if(AutoBanCountReached(attacker.userID))
                            {
                                db.handicaps[attacker.userID].ban_timer = DateTime.MinValue;
                            }
                        }

                        if(attacker.IsBuildingAuthed())
                        {
                            hit_penalty *= config.handicap_build_authed;
                        }

                        if(attacker.userID == last_attacker)
                        {
                            hit_penalty *= config.handicap_killer_scale;
                        }
                        else
                        {
                            hit_penalty *= config.handicap_assist_scale;
                        }

                        db.handicaps[attacker.userID].processKill(hit_penalty);

                        if(permission.UserHasPermission(attacker.UserIDString, PERMISSIONUSE))
                        {
                            ChatMessage(attacker, m_pvp_damage_decrease, DamagePercent(attacker.userID));
                        }
                    }
                }

                if(!db.handicaps[victim.userID].crippled)
                {
                    db.handicaps[victim.userID].processDeath(config.handicap_decay_amount);

                    if(permission.UserHasPermission(victim.UserIDString, PERMISSIONUSE))
                    {
                        ChatMessage(victim, m_pvp_damage_increase, DamagePercent(victim.userID));
                    }
                }

                StringBuilder message = new StringBuilder(HandicapInfoConsole(c_victim, victim.userID));

                foreach(var attacklist in attackers)
                {
                    if(attacklist.Key == last_attacker)
                    {
                        message.Append(' ').Append(HandicapInfoConsole(c_killer, attacklist.Key));
                    }
                }

                foreach(var attacklist in attackers)
                {
                    if(attacklist.Key != last_attacker)
                    {
                        message.Append(' ').Append(HandicapInfoConsole(c_assist, attacklist.Key));
                    }
                }

                LogMessage(m_handicap_admin, message.ToString());
            }
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if(entity == null || info == null)
            {
                return null;
            }

            if(entity is BasePlayer)
            {
                BasePlayer victim = entity.ToPlayer();

                if(!victim.userID.IsSteamId() || (victim.lastDamage == DamageType.Bleeding))
                {
                    return null;
                }

                if(!db.handicaps.ContainsKey(victim.userID))
                {
                    OnPlayerConnected(victim);
                }

                BasePlayer attacker = info.InitiatorPlayer ?? info.Initiator?.gameObject?.GetComponent<Fire>()?.Initiator?.ToPlayer();

                if(attacker == null || attacker == victim)
                {
                    return null;
                }
                
                if(attacker.userID.IsSteamId())
                {
                    if(!db.handicaps.ContainsKey(attacker.userID))
                    {
                        OnPlayerConnected(attacker);
                    }

                    if(!permission.UserHasPermission(attacker.UserIDString, PERMISSIONEXCLUDED))
                    {
                        bool cancel_attack = db.handicaps[attacker.userID].crippled;

                        if(!cancel_attack && (config.general_pvp_ff_enabled == false) && (victim.currentTeam != 0))
                        {
                            cancel_attack = (victim.currentTeam == attacker.currentTeam);
                        }

                        if(config.general_pvp_enabled && !cancel_attack)
                        {
                            if(!attacks.ContainsKey(victim.userID))
                            {
                                attacks.Add(victim.userID, new List<AttackInfo>());
                            }

                            attacks[victim.userID].Add(new AttackInfo
                            {
                                time    = DateTime.UtcNow,
                                userid  = attacker.userID,
                                penalty = GetHitPenalty(attacker, victim, info)
                            });

                            double damage_amount = db.handicaps[attacker.userID].damage_amount;

                            if(config.general_pvp_team_scale)
                            {
                                damage_amount *= TeamDamageModifier(victim, attacker);
                            }

                            info.damageTypes.ScaleAll((float)damage_amount);
                        }
                        else
                        {
                            info.damageTypes  = new DamageTypeList();
                            info.DidHit       = false;
                            info.HitBone      = 0;
                            info.DoHitEffects = false;
                            info.HitEntity    = null;
                            info.HitMaterial  = 0;
                            info.PointStart   = Vector3.zero;

                            return true;
                        }
                    }
                }
            }

            return null;
        }

        private void OnFireBallDamage(FireBall fireball, BaseCombatEntity target, HitInfo info)
        {
            info.Initiator = fireball;
        }

        private void OnFireBallSpread(FireBall fireball, BaseEntity entity)
        {
            entity.gameObject.AddComponent<Fire>().Initiator = fireball.GetComponent<Fire>()?.Initiator;
        }

        private void OnFlameExplosion(FlameExplosive explosive, BaseEntity entity)
        {
            entity.gameObject.AddComponent<Fire>().Initiator = explosive.creatorEntity;
        }

        private void OnFlameThrowerBurn(FlameThrower flamethrower, BaseEntity entity)
        {
            entity.gameObject.AddComponent<Fire>().Initiator = flamethrower.GetOwnerPlayer();
        }

        private void OnLootEntity(BasePlayer looter, BaseEntity target)
        {
            if(target is LootableCorpse)
            {
                OnLootHelper(looter, (target as LootableCorpse).playerSteamID);
            }
            else if(target is DroppedItemContainer)
            {
                OnLootHelper(looter, (target as DroppedItemContainer).playerSteamID);
            }
        }

        private void OnLootPlayer(BasePlayer looter, BasePlayer target) => OnLootHelper(looter, target.userID);

        object OnMeleeAttack(BasePlayer attacker, HitInfo info)
        {
            if(!attacker.userID.IsSteamId() || !(info.HitEntity is BasePlayer))
            {
                return null;
            }

            bool cancel_attack = false;

            var victim = info.HitEntity as BasePlayer;

            if(victim.userID.IsSteamId())
            {
                if(!db.handicaps.ContainsKey(attacker.userID))
                {
                    OnPlayerConnected(attacker);
                }
                else
                {
                    cancel_attack = db.handicaps[attacker.userID].crippled;
                }
            }

            if(!cancel_attack)
            {
                double range = 0.0;

                Item item = info?.Weapon?.GetItem();

                if((item != null) && weapons.ContainsKey(item.info.itemid))
                {
                    WeaponStats weapon = weapons[item.info.itemid];

                    if(weapon.melee)
                    {
                        range = weapon.range + weapon.attack_size;
                    }
                }

                if(attacker.Distance(info.HitEntity) <= range)
                {
                    Ray ray = new Ray(attacker.eyes.position, Quaternion.Euler(attacker.eyes.HeadRay().direction) * Vector3.forward);

                    RaycastHit hit;

                    if(Physics.Raycast(ray, out hit, (float)range))
                    {
                        if(hit.collider.GetComponentInParent<BaseEntity>() == info.HitEntity)
                        {
                            return null;
                        }
                    }
                }
            }

            info.damageTypes = new DamageTypeList();
            info.DoHitEffects = false;

            return true;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            OnPlayerConnected(player.userID, player.displayName);

            if(!player.IsConnected)
            {
                return;
            }

            db.handicaps[player.userID].online_time = DateTime.UtcNow;

            int port_separator = player.Connection.ipaddress.IndexOf(':');

            if(port_separator < 0)
            {
                port_separator = player.Connection.ipaddress.Length;
            }

            string ip_address = player.Connection.ipaddress.Substring(0, port_separator);

            if(!db.ip_table.ContainsKey(ip_address))
            {
                db.ip_table.Add(ip_address, new AddressInfo
                {
                    userid    = new List<ulong> { player.userID },
                    whitelist = false
                });
            }
            else
            {
                if(!db.ip_table[ip_address].userid.Contains(player.userID))
                {
                    db.ip_table[ip_address].userid.Add(player.userID);
                }

                if(!db.ip_table[ip_address].whitelist)
                {
                    foreach(var alt_userid in db.ip_table[ip_address].userid)
                    {
                        if((player.userID != alt_userid) && db.handicaps.ContainsKey(alt_userid))
                        {
                            BasePlayer alt_player = BasePlayer.FindByID(alt_userid);

                            if(alt_player != null && alt_player.IsConnected)
                            {
                                db.ip_table[ip_address].whitelist = true;

                                break;
                            }
                        }
                    }
                }

                if(!db.ip_table[ip_address].whitelist)
                {
                    foreach(var alt_userid in db.ip_table[ip_address].userid)
                    {
                        if((player.userID != alt_userid) && db.handicaps.ContainsKey(alt_userid))
                        {
                            if(db.handicaps[alt_userid].banned)
                            {
                                db.handicaps[player.userID].banned = true;

                                if(db.handicaps[alt_userid].ban_timer == DateTime.MinValue)
                                {
                                    db.handicaps[player.userID].ban_timer = DateTime.MinValue;
                                }
                                else if(db.handicaps[player.userID].ban_timer < db.handicaps[alt_userid].ban_timer)
                                {
                                    db.handicaps[player.userID].ban_timer = db.handicaps[alt_userid].ban_timer;
                                }
                            }

                            if(db.handicaps[player.userID].ban_count < db.handicaps[alt_userid].ban_count)
                            {
                                db.handicaps[player.userID].ban_count = db.handicaps[alt_userid].ban_count;
                            }

                            if(db.handicaps[alt_userid].crippled)
                            {
                                db.handicaps[player.userID].crippled = true;

                                if(db.handicaps[alt_userid].cripple_timer == DateTime.MinValue)
                                {
                                    db.handicaps[player.userID].cripple_timer = DateTime.MinValue;
                                }
                                else if(db.handicaps[player.userID].cripple_timer < db.handicaps[alt_userid].cripple_timer)
                                {
                                    db.handicaps[player.userID].cripple_timer = db.handicaps[alt_userid].cripple_timer;
                                }
                            }

                            if(db.handicaps[player.userID].damage_amount > db.handicaps[alt_userid].damage_amount)
                            {
                                db.handicaps[player.userID].damage_amount = db.handicaps[alt_userid].damage_amount;
                            }

                            if(db.handicaps[player.userID].decay_timer < db.handicaps[alt_userid].decay_timer)
                            {
                                db.handicaps[player.userID].decay_timer = db.handicaps[alt_userid].decay_timer;
                            }
                        }
                    }
                }
            }

            if(db.handicaps[player.userID].banned)
            {
                AdminBanInherited("SERVER", player.userID);
            }

            if(permission.UserHasPermission(player.UserIDString, PERMISSIONUSE))
            {
                ChatMessage(player, m_pvp_damage_modifier, DamagePercent(player.userID));
            }
        }

        private void OnPlayerConnected(ulong userid, string name)
        {
            name = name ?? covalence.Players.FindPlayerById(userid.ToString())?.Name ?? string.Empty;

            if(!db.handicaps.ContainsKey(userid))
            {
                db.handicaps.Add(userid, new Handicap
                {
                    display_name  = name,
                    damage_amount = config.handicap_damage_max,
                    decay_timer   = DateTime.UtcNow,
                    online_time   = DateTime.MinValue,
                    warning_count = 0,
                    warning_time  = DateTime.MinValue,
                    cripple_count = 0,
                    cripple_timer = DateTime.MinValue,
                    crippled      = false,
                    ban_count     = 0,
                    ban_timer     = DateTime.MinValue,
                    banned        = false
                });
            }
            else
            {
                db.handicaps[userid].display_name = name;
            }
        }

        private void OnServerInitialized()
        {
            foreach(var player in BasePlayer.activePlayerList.ToList()) OnPlayerConnected(player);

            foreach(var player in BasePlayer.sleepingPlayerList.ToList()) OnPlayerConnected(player);

            foreach(var player in covalence.Players.All.ToList())
            {
                if(covalence.Server.IsBanned(player.Id))
                {
                    ulong userid = ulong.Parse(player.Id);

                    if(db.handicaps.ContainsKey(userid) && !db.handicaps[userid].banned)
                    {
                        db.handicaps[userid].cripple_count = 0;
                        db.handicaps[userid].cripple_timer = DateTime.MinValue;
                        db.handicaps[userid].warning_count = 0;
                        db.handicaps[userid].banned        = true;
                    }
                }
            }

            WorkTimer();
        }

        private void OnServerSave()
        {
            DBStore();

            SaveConfiguration();
        }

        private void OnUserBanned(string name, string userid_string, string ip, string reason)
        {
            ulong userid = ulong.Parse(userid_string);

            OnPlayerConnected(userid, name);

            if(!db.handicaps[userid].banned)
            {
                db.handicaps[userid].warning_count = 0;
                db.handicaps[userid].cripple_count = 0;
                db.handicaps[userid].cripple_timer = DateTime.MinValue;
                db.handicaps[userid].banned        = true;
            }
        }

        private void OnUserUnbanned(string name, string userid_string, string ip)
        {
            ulong userid = ulong.Parse(userid_string);

            OnPlayerConnected(userid, name);

            if(db.handicaps[userid].banned)
            {
                db.handicaps[userid].damage_amount = config.handicap_damage_max;
                db.handicaps[userid].decay_timer   = DateTime.UtcNow;
                db.handicaps[userid].warning_count = 0;
                db.handicaps[userid].cripple_count = 0;
                db.handicaps[userid].cripple_timer = DateTime.MinValue;
                db.handicaps[userid].crippled      = false;
                db.handicaps[userid].ban_count     = 0;
                db.handicaps[userid].ban_timer     = DateTime.MinValue;
                db.handicaps[userid].banned        = false;
            }
        }

        private void OnWeaponFired(BaseProjectile weapon, BasePlayer attacker, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles)
        {
            if((attacker == null) || !attacker.userID.IsSteamId())
            {
                return;
            }

            if(!db.handicaps.ContainsKey(attacker.userID))
            {
                OnPlayerConnected(attacker);

                return;
            }

            if(!db.handicaps[attacker.userID].crippled)
            {
                return;
            }

            var ray = new Ray(attacker.eyes.position, Quaternion.Euler(attacker.eyes.HeadRay().direction) * Vector3.forward);

            RaycastHit hit;

            if(Physics.Raycast(ray, out hit, weapon.effectiveRange))
            {
                var destination = hit.collider.GetComponentInParent<BaseEntity>();

                List<BaseEntity> list = Pool.GetList<BaseEntity>();
                Vis.Entities(destination.transform.position, 10.0f, list);

                foreach(var entity in list)
                {
                    var victim = entity as BasePlayer;

                    if((victim != null) && victim.userID.IsSteamId())
                    {
                        foreach(var projectile in projectiles.projectiles)
                        {
                            projectile.startVel = Vector3.zero;
                        }

                        return;
                    }
                }
            }
        }

        private void Unload()
        {
            DBStore();

            SaveConfiguration();
        }

        #endregion
    }
}


// --- End of file: PVPCaps.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-gravestone ---
// --- Original File Path: P/PlayerGravestone/PlayerGravestone.cs ---

using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using UnityEngine;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Player Gravestone", "Lincoln", "1.2.2")]
    [Description("Spawns a gravestone at a player's death location")]
    class PlayerGravestone : RustPlugin
    {
        private const string PermUse = "playergravestone.use";
        private const string GravestonePrefab = "assets/prefabs/misc/halloween/deployablegravestone/gravestone.stone.deployed.prefab";
        private const string GravestoneShortName = "gravestone.stone.deployed";

        private Dictionary<ulong, KillInfo> killInfos = new Dictionary<ulong, KillInfo>();

        private PluginConfig config;

        #region Configuration
        private class PluginConfig
        {
            public int GraveStoneDespawnTimeInSeconds = 60;
            public int KillInfoPersistenceTimeInSeconds = 300; // New config option
            public bool SpawnGraveStoneInAuthZone = false;
            public bool OnlyOwnerCanDamageGraveStone = false;
            public bool BroadcastDeathMessageToServer = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            Config.WriteObject(config, true);
        }
        #endregion

        #region Hooks
        private void Init()
        {
            permission.RegisterPermission(PermUse, this);
            LoadConfig();
        }

        private object OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
        {
            if (!player.userID.IsSteamId() || hitInfo == null || !permission.UserHasPermission(player.UserIDString, PermUse))
                return null;

            if (!config.SpawnGraveStoneInAuthZone && player.IsBuildingAuthed())
                return null;

            RemoveExistingGravestones(player.userID);
            SpawnGravestone(player, hitInfo);

            return null;
        }

        private void OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            if (entity.ShortPrefabName != GravestoneShortName || !config.OnlyOwnerCanDamageGraveStone)
                return;

            if (entity.OwnerID != 0uL && entity.OwnerID != info.InitiatorPlayer?.userID)
                info.damageTypes.ScaleAll(0f);
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermUse) || !input.WasJustPressed(BUTTON.USE))
                return;

            RaycastHit hit;
            if (Physics.Raycast(player.eyes.HeadRay(), out hit, 5f))
            {
                BaseEntity entity = hit.GetEntity();
                if (entity?.ShortPrefabName == GravestoneShortName)
                {
                    DisplayDeathMessage(player, entity.OwnerID);
                }
            }
        }
        #endregion

        #region Helper Methods
        private void RemoveExistingGravestones(ulong playerID)
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var gravestone = entity as BaseEntity;
                if (gravestone?.ShortPrefabName == GravestoneShortName && gravestone.OwnerID == playerID)
                {
                    gravestone.Kill();
                }
            }
        }

        private void SpawnGravestone(BasePlayer player, HitInfo hitInfo)
        {
            Vector3 gravestonePos = player.transform.position + (player.transform.forward * -1f);
            var grave = GameManager.server.CreateEntity(GravestonePrefab, gravestonePos, Quaternion.identity, true);

            if (grave != null && !player.IsNpc && hitInfo.Initiator != null)
            {
                grave.OwnerID = player.userID;
                grave.Spawn();

                string attackerName = ExtractAttackerName(hitInfo.Initiator.ToString());
                killInfos[player.userID] = new KillInfo { VictimName = player.displayName, AttackerName = attackerName };

                if (config.BroadcastDeathMessageToServer)
                {
                    rust.BroadcastChat(null, $" <color=#ff6666>R.I.P</color>: <color=#ffc34d>{player.displayName}</color> was killed by a wild <color=orange>{attackerName}</color>");
                }

                // Schedule removal of kill info
                timer.Once(config.KillInfoPersistenceTimeInSeconds, () => killInfos.Remove(player.userID));

                // Schedule despawn of gravestone
                timer.Once(config.GraveStoneDespawnTimeInSeconds, () => grave.Kill());
            }
        }

        private string ExtractAttackerName(string attackerString)
        {
            return Regex.Replace(attackerString, @"\[|\]|\d", "");
        }

        private void DisplayDeathMessage(BasePlayer player, ulong gravestoneOwnerID)
        {
            if (killInfos.TryGetValue(gravestoneOwnerID, out KillInfo killInfo))
            {
                ChatMessage(player, "DeathMessage", killInfo.VictimName, killInfo.AttackerName);
            }
            else
            {
                ChatMessage(player, "UnknownDeathMessage");
            }
        }
        #endregion

        #region Localization
        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(lang.GetMessage(messageName, this, player.UserIDString), args));

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["DeathMessage"] = "<color=#ff6666>R.I.P</color>\n<color=#ffc34d>{0}</color> was killed by a wild <color=orange>{1}</color>.",
                ["UnknownDeathMessage"] = "<color=#ff6666>R.I.P</color>\nThe details of this death have been lost to time."
            }, this);
        }
        #endregion

        private class KillInfo
        {
            public string VictimName { get; set; }
            public string AttackerName { get; set; }
        }
    }
}

// --- End of file: PlayerGravestone.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/prefab-sniffer ---
// --- Original File Path: P/PrefabSniffer/PrefabSniffer.cs ---

using System;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using UnityEngine;

// TODO: Look into utilizing CommunityEntity.ServerInstance.StartCoroutine

namespace Oxide.Plugins
{
    [Info("Prefab Sniffer", "Wulf", "2.0.2")]
    [Description("Searches the game files for prefab file locations")]
    public class PrefabSniffer : CovalencePlugin
    {
        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandPrefab"] = "prefab",
                ["NoResultsFound"] = "No results found for {0}",
                ["ResultsSaved"] = "Prefab results saved to logs/{0}.txt",
                ["UsagePrefab"] = "Usage: {0} <build, find, fx, or all> [keyword]",
                ["UsagePrefabFind"] = "Usage: prefabs find <keyword>"
            }, this);
        }

        #endregion Localization

        #region Initializaton

        private const string permissionUse = "prefabsniffer.use";

        private Dictionary<string, UnityEngine.Object> files;
        private GameManifest.PooledString[] manifest;

        private void OnServerInitialized()
        {
            AddLocalizedCommand(nameof(CommandPrefab));
            permission.RegisterPermission(permissionUse, this);

            files = FileSystem.Backend.cache;
            manifest = GameManifest.Current.pooledStrings;
        }

        #endregion Initialization

        #region Commands

        private void CommandPrefab(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permissionUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length == 0)
            {
                Message(player, "UsagePrefab", command);
                return;
            }

            List<string> resourcesList = new List<string>();
            string argName = "";

            switch (args[0].ToLower())
            {
                case "find":
                    if (args.Length > 2)
                    {
                        Message(player, "UsagePrefabFind", command);
                    }
                    foreach (GameManifest.PooledString asset in manifest)
                    {
                        if (asset.str.Contains(args[1]) && asset.str.EndsWith(".prefab"))
                        {
                            resourcesList.Add(asset.str);
                        }
                    }
                    argName = "find";
                    break;

                case "build":
                    foreach (string asset in files.Keys)
                    {
                        if ((!asset.StartsWith("assets/content/")
                            && !asset.StartsWith("assets/bundled/")
                            && !asset.StartsWith("assets/prefabs/"))
                            || !asset.EndsWith(".prefab")) continue;

                        if (asset.Contains(".worldmodel.")
                            || asset.Contains("/fx/")
                            || asset.Contains("/effects/")
                            || asset.Contains("/build/skins/")
                            || asset.Contains("/_unimplemented/")
                            || asset.Contains("/ui/")
                            || asset.Contains("/sound/")
                            || asset.Contains("/world/")
                            || asset.Contains("/env/")
                            || asset.Contains("/clothing/")
                            || asset.Contains("/skins/")
                            || asset.Contains("/decor/")
                            || asset.Contains("/monument/")
                            || asset.Contains("/crystals/")
                            || asset.Contains("/projectiles/")
                            || asset.Contains("/meat_")
                            || asset.EndsWith(".skin.prefab")
                            || asset.EndsWith(".viewmodel.prefab")
                            || asset.EndsWith("_test.prefab")
                            || asset.EndsWith("_collision.prefab")
                            || asset.EndsWith("_ragdoll.prefab")
                            || asset.EndsWith("_skin.prefab")
                            || asset.Contains("/clutter/")) continue;

                        GameObject go = GameManager.server.FindPrefab(asset);
                        if (go?.GetComponent<BaseEntity>() != null)
                        {
                            resourcesList.Add(asset);
                        }
                    }
                    argName = "build";
                    break;

                case "fx":
                    foreach (GameManifest.PooledString asset in manifest)
                    {
                        if ((!asset.str.StartsWith("assets/content/")
                            && !asset.str.StartsWith("assets/bundled/")
                            && !asset.str.StartsWith("assets/prefabs/"))
                            || !asset.str.EndsWith(".prefab")) continue;

                        if (asset.str.Contains("/fx/"))
                        {
                            resourcesList.Add(asset.str);
                        }
                    }
                    argName = "fx";
                    break;

                case "all":
                    foreach (GameManifest.PooledString asset in manifest)
                    {
                        resourcesList.Add(asset.str);
                    }
                    argName = "all";
                    break;

                default:
                    Message(player, "UsagePrefab", command);
                    break;
            }

            if (!string.IsNullOrEmpty(argName))
            {
                if (resourcesList.Count > 0)
                {
                    for (int i = 0; i < resourcesList.Count; i++)
                    {
                        player.Reply($"{i} - {resourcesList[i]}");
                        LogToFile(argName, $"{i} - {resourcesList[i]}", this);
                    }
                    Message(player, "ResultsSaved", $"{Name}/{Name.ToLower()}/{argName}-{DateTime.Now:yyyy-MM-dd}");
                } else {
                    Message(player, "NoResultsFound", args[1]);
                }
            }
        }

        #endregion Commands

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}

// --- End of file: PrefabSniffer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/perf-timings ---
// --- Original File Path: P/PerfTimings/PerfTimings.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace Oxide.Plugins
{

    [Info("Perf Timings", "Rockioux", "1.0.0")]
    [Description("Rudimentary performance timer allowing to get min, max, cumul and average processing time for a block of code. Meant to be used by plugin developers.")]
    public class PerfTimings : CovalencePlugin
    {

        #region Inner Classes

        /// <summary>
        /// Disposable object to use to record performance timings. Writes the time
        /// it took to execute once the object is disposed of.
        /// </summary>
        public class PerfTimer : IDisposable
        {
            private readonly Stopwatch _timer;
            private readonly PerfTimings _plugin;
            private readonly string _key;

            public PerfTimer(PerfTimings plugin, string key)
            {
                _timer = new Stopwatch();
                _timer.Start();
                _plugin = plugin;
                _key = key;
            }

            public void Dispose()
            {
                _timer.Stop();
                _plugin.AddPerfMetrics(_key, _timer.Elapsed.TotalMilliseconds);
            }
        }

        /// <summary>
        /// Contains the metrics gathered for a specific metrics's key.
        /// </summary>
        private class PerfMetrics
        {
            public double Cumul { get; private set; } = 0;
            public double Min { get; private set; } = double.MaxValue;
            public double Max { get; private set; } = 0;
            public int TotalCalls { get; private set; } = 0;
            public double Avg => Cumul / TotalCalls;

            public void AddValue(double value)
            {
                Cumul += value;
                Min = Math.Min(Min, value);
                Max = Math.Max(Max, value);
                TotalCalls++;
            }
        }

        #endregion // Inner Classes

        #region Fields

        private readonly Dictionary<string, PerfMetrics> _perfMetricsByTag = new Dictionary<string, PerfMetrics>();
        private PerfMetrics _framePerfMetrics;
        private double _captureDurationMs = 0;
        private int _maxKeyStrLen = 0;
        private bool _isCurrentlyCapturing = false;

        private const double kDefaultCaptureDurationMs = 30000;
        private const int kColumnAlignment = 8;

        #endregion // Fields

        #region Public Methods

        /// <summary>
        /// Function used to create a performance timer to measure performance on a 
        /// bit of code. Timer start at the timer's creation, and stops when the timer is disposed of
        /// (usually when it runs out of a using block).
        /// </summary>
        /// <param name="tags">Tags to be merged together that will be the unique name for the timer</param>
        /// <returns>Performance timer</returns>
        public PerfTimer CreatePerfTimer(params string[] tags)
        {
            string key = string.Join("::", tags);
            return _isCurrentlyCapturing ? new PerfTimer(this, key) : null;
        }

        #endregion // Public Methods

        #region Commands

        /// <summary>
        /// Command used to start a timed performance capture.
        /// </summary>
        /// <param name="player">Requester</param>
        /// <param name="command">Command</param>
        /// <param name="args">Duration of the capture in ms</param>
        [Command("perfcapture"), Permission("perftimings.capture")]
        private void PerfTimingsCapture(IPlayer player, string command, string[] args)
        {
            if (args.Length > 1)
            {
                Puts($"Invalid number of arguments {args.Length} when it should be 1");
                return;
            }

            int duration = 0;
            if (args.Length > 0 && !int.TryParse(args[0], out duration))
            {
                Puts($"Invalid duration specified {args[0]}, should be an integer in milliseconds");
                return;
            }

            PerfTimingsCapture_Internal(duration);
        }

        #endregion // Commands

        #region UMod Hooks

        /// <summary>
        /// Captures the frame stats so we can compare timer stats with frame. Useful
        /// to know if there are frame spikes.
        /// </summary>
        /// <param name="delta">Delta is in seconds</param>
        private void OnFrame(float delta)
        {
            if (!_isCurrentlyCapturing) return;

            _framePerfMetrics.AddValue(delta * 1000f);

            if (_framePerfMetrics.Cumul >= _captureDurationMs)
            {
                PrintStats();
                Reset();
            }
        }

        #endregion // UMod Hooks

        #region Private Methods

        /// <summary>
        /// Used by the timer to add it's running duration to the perf metrics class.
        /// </summary>
        /// <param name="key">Unique identifier for the timer</param>
        /// <param name="value">Duration in ms</param>
        private void AddPerfMetrics(string key, double value)
        {
            if (!_perfMetricsByTag.ContainsKey(key))
            {
                _maxKeyStrLen = Math.Max(_maxKeyStrLen, key.Length);
                _perfMetricsByTag[key] = new PerfMetrics();
            }

            _perfMetricsByTag[key].AddValue(value);
        }

        /// <summary>
        /// Resets all the values and clears the performance metrics.
        /// </summary>
        private void Reset()
        {
            _isCurrentlyCapturing = false;
            _framePerfMetrics = null;
            _perfMetricsByTag.Clear();
        }

        /// <summary>
        /// Sets everything for the capture to start.
        /// </summary>
        /// <param name="duration">Duration in ms</param>
        private void PerfTimingsCapture_Internal(int duration = 0)
        {
            _captureDurationMs = duration != 0 ? duration : kDefaultCaptureDurationMs;
            _framePerfMetrics = new PerfMetrics();
            _isCurrentlyCapturing = true;
        }

        /// <summary>
        /// Print the stats for all performance metrics objects. Prints it in one big block since printing lines
        /// in succession caused quite a bit of lag.
        /// </summary>
        private void PrintStats()
        {
            StringBuilder stringBuilder = new StringBuilder();
            string header = $"| {"Name".PadRight(_maxKeyStrLen)} | {"Min",-kColumnAlignment} | {"Max",-kColumnAlignment} | {"Avg",-kColumnAlignment} | {"Cumul",-kColumnAlignment} | {"Calls",-kColumnAlignment} |";
            stringBuilder.AppendLine(header);
            stringBuilder.AppendLine(new string('-', header.Length));

            Func <double, string> formatDuration = duration =>
            {
                string unit = "ms";
                double number = duration;
                if (duration > 1000d)
                {
                    unit = "s";
                    number = duration / 1000d;
                }
                else if (duration < 1d)
                {
                    number = duration * 1000d;
                    unit = "us";

                    if (number < 1d)
                    {
                        number = number * 1000d;
                        unit = "ns";
                    }
                }
                return $"{number:F2}{unit}";
            };

            List<KeyValuePair<string, PerfMetrics>> orderedMetrics = _perfMetricsByTag.OrderByDescending(pair => pair.Value.Cumul).ToList();
            foreach(KeyValuePair<string, PerfMetrics> pair in orderedMetrics)
            {
                stringBuilder.AppendLine($"| {pair.Key.PadRight(_maxKeyStrLen)} | {formatDuration(pair.Value.Min),kColumnAlignment} | {formatDuration(pair.Value.Max),kColumnAlignment} | {formatDuration(pair.Value.Avg),kColumnAlignment} | {formatDuration(pair.Value.Cumul),kColumnAlignment} | {pair.Value.TotalCalls,kColumnAlignment} |");
            }

            stringBuilder.AppendLine(new string('-', header.Length));
            stringBuilder.AppendLine($"| {"Total".PadRight(_maxKeyStrLen)} | {formatDuration(_framePerfMetrics.Min),kColumnAlignment} | {formatDuration(_framePerfMetrics.Max),kColumnAlignment} | {formatDuration(_framePerfMetrics.Avg),kColumnAlignment} | {formatDuration(_framePerfMetrics.Cumul),kColumnAlignment} | {_framePerfMetrics.TotalCalls,kColumnAlignment} |");
            Puts(stringBuilder.ToString());
        }
    }

    #endregion // Private Methods

}


// --- End of file: PerfTimings.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pvx-selector ---
// --- Original File Path: P/PvXSelector/PvXSelector.cs ---

using System;                      //DateTime
using System.Linq;
//using System.Data;
//using Oxide.Plugins;
//using Oxide.Core.CSharp;
//using System.Reflection;
//using System.Collections;
//using System.Globalization;
using System.Collections.Generic;  //Required for Whilelist
//using System.Text.RegularExpressions;
//using System.Runtime.CompilerServices;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
//using Oxide.Core.Database;
//using Oxide.Core.Libraries;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence; //Requrired for IPlayer stuff
using Rust;
//using Rust.Ai;
//using Rust.AI;
//using RustNative;
//using Rust.Registry;
using UnityEngine;
//using UnityEngine.AI;
//using ConVar;
//using Facepunch;
//using Network;
//using ProtoBuf;

namespace Oxide.Plugins
{
    [Info("PvX Selector", "Alphawar", "0.1.0")]
    [Description("Allow players to play both PvP and PvE on the same server.")]
    class PvXSelector : RustPlugin
    {
        private readonly string PluginName = "pvxselector";
        //temp variables
        


        private HashSet<BaseHelicopter> BaseHelicopters = new HashSet<BaseHelicopter>();
        private HashSet<CH47HelicopterAIController> ChinooksHelicopters = new HashSet<CH47HelicopterAIController>();
        private HashSet<BradleyAPC> BradleyAPCs = new HashSet<BradleyAPC>();
        private HashSet<FireBall> HeliFireBalls = new HashSet<FireBall>();
        private HashSet<FireBall> HeliRocket = new HashSet<FireBall>();

        private readonly string heliPrefab = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";
        private readonly string chinookPrefab = "assets/prefabs/npc/ch47/ch47scientists.entity.prefab";

        private readonly int groundLayer = LayerMask.GetMask("Terrain", "World", "Default");
        //Dictionary

        // Enums
        private enum PvXState { NA, PvP, PvE, AI, Unknown, Sleeper };
        private enum PvXNotification { NA, Accepted, Delcined, Timed, NoMode }

        // Variables.
        #region Variables
        bool initialized = false;

        static readonly string PvxIndicatorUI = "PvXPlayerStateIndicator"; // used to show player their mode
        static readonly string PvxAdminUI = "pvxAdminTicketCountUI"; //admin gui to indicate tickets.
        static readonly string[] GuiList = new string[] {
            PvxIndicatorUI,
            PvxAdminUI
        };

        #endregion

        #region Config
        private ConfigData configData;
        class ConfigData
        {
            public Options Options { get; set; }
            public Gui Gui { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

        class Options
        {
            public bool AllowTickets { get; set; }
            public bool AllowCooldowns { get; set; }
            public float ModeSwitchCooldown { get; set; }
        }
        class Gui
        {
            public bool DisableUI_FadeIn;
            public float playerIndicatorMinWid;
            public float playerIndicatorMinHei;
            public float adminIndicatorMinWid;
            public float adminIndicatorMinHei;
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Options = new Options
                {
                    AllowTickets = true,
                    AllowCooldowns = true,
                    ModeSwitchCooldown = 2f,
                },
                Gui = new Gui
                {
                    DisableUI_FadeIn = false,
                    playerIndicatorMinWid = 0.484f,
                    playerIndicatorMinHei = 0.111f,
                    adminIndicatorMinWid = 0.16f,
                    adminIndicatorMinHei = 0.06f,
                }
            };
            SaveConfig(config);
        }
        #endregion

        #region Data
        private static PvXSelector PvX;

        private static Dictionary<ulong, PvXPlayer> PvXPlayers = new Dictionary<ulong, PvXPlayer>();
        private static Dictionary<ulong, double> PvXCooldowns = new Dictionary<ulong, double>();
        private static Dictionary<int, PvXTicket> PvXTickets = new Dictionary<int, PvXTicket>();
        private static Dictionary<int, PvXLog> PvXLogs = new Dictionary<int, PvXLog>();

        private static readonly List<object> BuildEntityList = new List<object>() {
            typeof(AutoTurret),typeof(Barricade),typeof(BaseCombatEntity),
            typeof(BaseOven),typeof(BearTrap),typeof(BuildingBlock),
            typeof(BuildingPrivlidge),typeof(CeilingLight),typeof(Door),
            typeof(Landmine),typeof(LiquidContainer),typeof(ReactiveTarget),
            typeof(RepairBench),typeof(ResearchTable),typeof(Signage),
            typeof(SimpleBuildingBlock),typeof(SleepingBag),typeof(StabilityEntity),
            typeof(StorageContainer),typeof(SurvivalFishTrap),typeof(WaterCatcher),
            typeof(WaterPurifier)};
        private static readonly List<object> BasePartEntityList = new List<object>() {
            typeof(BaseOven),typeof(BuildingBlock),typeof(BuildingPrivlidge),
            typeof(CeilingLight),typeof(Door),typeof(LiquidContainer),
            typeof(RepairBench),typeof(ResearchTable),typeof(Signage),
            typeof(SimpleBuildingBlock),typeof(SleepingBag),typeof(StabilityEntity),
            typeof(StorageContainer),typeof(SurvivalFishTrap),typeof(WaterCatcher),
            typeof(WaterPurifier)};
        private static readonly List<object> CombatPartEntityList = new List<object>() {
            typeof(AutoTurret),typeof(Barricade),typeof(BearTrap),typeof(Landmine),
            typeof(ReactiveTarget),typeof(BaseCombatEntity)};
        private static readonly List<object> AnimalList = new List<object>() {
            typeof(Bear),
            typeof(Boar),
            typeof(Chicken),
            typeof(Horse),
            typeof(Stag),
            typeof(Wolf)
        };

        private static List<ulong> AdminsActive = new List<ulong>();
        private static List<ulong> AdminsOnline = new List<ulong>();
        private static Dictionary<ulong,PvXTicket> AdminViewedTicket = new Dictionary<ulong, PvXTicket>();

        TicketDataManager ticketManager;
        PlayerDataManager playerManager;
        LogDataManager logManager;

        #endregion

        #region Classes
        private class PvXPlayer
        {
            public string Username { get; set; }
            public string ConnectionFirst { get; set; }
            public string ConnectionLast { get; set; }
            public PvXState State { get; set; }
            public PvXNotification Notification { get; set; }
            public int TicketID { get; set; }
            public bool Ticket { get; set; }
            public double LastRequestStamp { get; set; }
        }
        private class PvXTicket
        {
            public ulong ID { get; set; }
            public string Name { get; set; }
            public string Reason { get; set; }
            public string TimeStampString { get; set; }
            public double TimeStamp { get; set; }
            public int TicketID { get; set; }
        }
        private class PvXLog
        {
            public ulong PlayerID { get; set; }
            public string PlayerName { get; set; }
            public ulong AdminID { get; set; }
            public string AdminName { get; set; }
            public string Reason { get; set; }
            public string CreatedTimeStamp { get; set; }
            public string ReviewedTimeStamp { get; set; }
            public string Outcome { get; set; }
        }
        class PlayerDataManager
        {
            //Variables
            private PlayerData playerData;
            private DynamicConfigFile PlayerDataFile;

            //Classes
            class PlayerData
            {
                public Dictionary<ulong, PvXPlayer> StoredPlayers = new Dictionary<ulong, PvXPlayer>();
                public Dictionary<ulong, double> StoredCooldowns = new Dictionary<ulong, double>();
            }

            //Functions
            internal PlayerDataManager()
            {
                //Load Mod, Start any timers
                PvX.Puts("Creating TicketManager Class");
                Initiate();
                Load();
            }
            private void Initiate()
            {
                PlayerDataFile = Interface.Oxide.DataFileSystem.GetFile("PvX/PlayerData");
            }
            private void Load()
            {
                try
                {
                    PvX.Puts("Loading Player Data");
                    playerData = PlayerDataFile.ReadObject<PlayerData>();
                    PvXPlayers = playerData.StoredPlayers;
                    PvXCooldowns = playerData.StoredCooldowns;
                }
                catch
                {
                    PvX.Puts("Couldn't load Player Data, Creating New file");
                    playerData = new PlayerData();
                    PvXPlayers = playerData.StoredPlayers;
                    PvXCooldowns = playerData.StoredCooldowns;
                }
            }
            public void Save()
            {
                playerData.StoredPlayers = PvXPlayers;
                playerData.StoredCooldowns = PvXCooldowns;
                PlayerDataFile.WriteObject(playerData);
            }
        }
        class TicketDataManager
        {
            //Variables
            private TicketData ticketData;
            private DynamicConfigFile TicketDataFile;

            //Classes
            class TicketData
            {
                public Dictionary<int, PvXTicket> StoredTickets = new Dictionary<int, PvXTicket>();
            }

            //Functions
            public TicketDataManager()
            {
                //Load Mod, Start any timers
                PvX.Puts("Creating TicketManager Class");
                Initiate();
                Load();
            }
            private void Initiate()
            {
                TicketDataFile = Interface.Oxide.DataFileSystem.GetFile("PvX/TicketData");
            }
            private void Load()
            {
                try
                {
                    PvX.Puts("Loading Ticket Data");
                    ticketData = TicketDataFile.ReadObject<TicketData>();
                    PvXTickets = ticketData.StoredTickets;
                }
                catch
                {
                    PvX.Puts("Couldn't load Ticket Data, Creating New file");
                    ticketData = new TicketData();
                    PvXTickets = ticketData.StoredTickets;
                }
            }
            public void Save()
            {
                ticketData.StoredTickets = PvXTickets;
                TicketDataFile.WriteObject(ticketData);
            }
        }
        class LogDataManager
        {
            //Variables
            private LogData logData;
            private DynamicConfigFile LogDataFile;

            //Classes
            class LogData
            {
                public Dictionary<int, PvXLog> StoredLogs = new Dictionary<int, PvXLog>();
            }

            //Functions
            internal LogDataManager()
            {
                //Load Mod, Start any timers
                PvX.Puts("Creating LogManager Class");
                Initiate();
                Load();
            }
            private void Initiate()
            {
                LogDataFile = Interface.Oxide.DataFileSystem.GetFile("PvX/LogData");
            }
            private void Load()
            {
                try
                {
                    PvX.Puts("Loading Log Data");
                    logData = LogDataFile.ReadObject<LogData>();
                    PvXLogs = logData.StoredLogs;
                }
                catch
                {
                    PvX.Puts("Couldn't load Log Data, Creating New file");
                    logData = new LogData();
                    PvXLogs = logData.StoredLogs;
                }
            }
            public void Save()
            {
                logData.StoredLogs = PvXLogs;
                LogDataFile.WriteObject(logData);
            }

        }
        #endregion

        #region Functions

        void Init()
        {
            PvX = this;
            LoadDefaultMessages();
            RegisterPermissions();
            //AddCovalenceCommand();
            ticketManager = new TicketDataManager();
            playerManager = new PlayerDataManager();
            logManager = new LogDataManager();
            lang.RegisterMessages(Messages, this);
        }

        void OnServerInitialized()
        {
            LoadVariables();

            timer.Every(20f, () => CheckHelicopter());
            BaseHelicopters = new HashSet<BaseHelicopter>(GameObject.FindObjectsOfType<BaseHelicopter>());
            ChinooksHelicopters = new HashSet<CH47HelicopterAIController>(GameObject.FindObjectsOfType<CH47HelicopterAIController>());
            BradleyAPCs = new HashSet<BradleyAPC>(GameObject.FindObjectsOfType<BradleyAPC>());
            HeliFireBalls = new HashSet<FireBall>(BaseNetworkable.serverEntities?.Where(p => p != null && p is FireBall && (p.PrefabName.Contains("napalm") || p.PrefabName.Contains("oil")))?.Select(p => p as FireBall) ?? null);

            initialized = true;
            foreach (BasePlayer Player in BasePlayer.activePlayerList)
            {
                OnPlayerInit(Player);
            }
        }

        // Need to save data when mod is unloaded
        void Unload()
        {
            SaveAll();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                DestroyAllPvXUI(player);
            }
        }

        void OnPlayerInit(BasePlayer player)
        {
            Puts("OnPlayerInit being called");
            IPlayer iplayer = FindIPlayer(player.UserIDString);
            if (IsNPC(player.userID)) return; // Then check if NPC
            else if (!player.IsConnected)
            {
                timer.Once(3f, () =>
                {
                    OnPlayerInit(player);
                });
                return;
            }//Since player make sure they have "Joined" the game"
            else PlayerLoaded(iplayer); // Now run PvX PlayerLoaded function
        }

        void PlayerLoaded(IPlayer iplayer)
        {
            BasePlayer player = FindBasePlayer(iplayer.Id);
            //Functions to check if new player, old player, unknown/sleeper player.
            if (PvXPlayers.ContainsKey(player.userID))
            {
                Puts("PvXPlayers Contains player");
                if (PvXPlayers[player.userID].State == PvXState.Unknown || PvXPlayers[player.userID].State == PvXState.Sleeper)
                {
                    // Remove player to read clean version, keepingh specific date info.
                    PvXPlayers.Remove(player.userID);
                    PvXPlayers.Add(player.userID, CreatePlayerData(player));
                }
            }
            else
            {
                PvXPlayers.Add(player.userID, CreatePlayerData(player));
                iplayer.Reply(GetMSG("WelcomeMessage", iplayer.Id));
            }

            if (HasPerm(player, "admin"))
            {
                AdminsOnline.Add(player.userID);
                AdminIndicatorGui(player);
            }

            // Update players last connection time to today
            PvXPlayers[player.userID].ConnectionLast = GetDateStamp();
            
            if (PvXPlayers[player.userID].State == PvXState.NA)
            {
                PlayerNotification(iplayer);
            }
            else if (PvXPlayers[player.userID].Notification != PvXNotification.NA)
            {
                PlayerNotification(iplayer);
            }
            PlayerIndicatorGui(player);
        }

        void RegisterPermissions()
        {
            string[] Permissionarray = { "admin", "moderator", "wipe" }; //DO NOT EVER TOUCH THIS EVER!!!!!!
            foreach (string i in Permissionarray)
            {
                string regPerm = PluginName.ToLower() + "." + i;
                if (!permission.PermissionExists(regPerm))
                {
                    permission.RegisterPermission(regPerm, this);
                }
            }
        }

        private PvXPlayer CreatePlayerData(BasePlayer player)
        {
            PvXPlayer Player = new PvXPlayer
            {
                ConnectionFirst = GetDateStamp(),
                ConnectionLast = GetDateStamp(),
                LastRequestStamp = 0,
                Notification = PvXNotification.NoMode,
                State = PvXState.NA,
                Username = player.displayName,
                Ticket = false,
                TicketID = 0
            };
            return Player;
        }
        private PvXTicket CreateTicketData(BasePlayer player, int ticketnumber)
        {
            PvXTicket ticket = new PvXTicket
            {
                ID = player.userID,
                Name = player.displayName,
                Reason = "Null",
                TimeStamp = GetTimeStamp(),
                TimeStampString = GetDateStamp(),
                TicketID = ticketnumber
            };
            return ticket;
        }


        private int GetNewLogID()
        {
            if (PvXLogs.Count > 1000)
            {
                return 0;
            }
            for (int _i = 1; _i <= 1000; _i++)
            {
                if (PvXLogs.ContainsKey(_i))
                {

                }
                else
                {
                    //Puts("Key {0} doesnt exist, Returning ticket number", _i); //debug
                    return _i;
                }
            }
            return 0;
        }
        private int GetNewTicketID()
        {
            if (PvXTickets.Count > 1000)
            {
                return 0;
            }
            for (int _i = 1; _i <= 1000; _i++)
            {
                if (PvXTickets.ContainsKey(_i))
                {

                }
                else
                {
                    return _i;
                }
            }
            return 0;
        }

        private string GetDateStamp()
        {
            return DateTime.Now.ToString("HH:mm dd-MM-yyyy");
        }
        private double GetTimeStamp()
        {
            return (DateTime.Now.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;
        }

        
        private bool HasPerm(BasePlayer Player, string perm, string reason = null)
        {
            string regPerm = Title.ToLower() + "." + perm; //pvxselector.admin
            if (permission.UserHasPermission(Player.UserIDString, regPerm)) return true;
            if (reason != "null")
                SendReply(Player, reason);
            return false;
        }

        public static BasePlayer FindBasePlayer(string StringID)
        {
            ulong ID = Convert.ToUInt64(StringID);
            BasePlayer BasePlayer = BasePlayer.FindByID(ID);
            if (BasePlayer == null) BasePlayer = BasePlayer.FindSleeping(ID);
            return BasePlayer;
        }
        public static IPlayer FindIPlayer(string StringID)
        {
            return PvX.covalence.Players.FindPlayerById(StringID);
        }


        private PvXState GetObjectPvXState(BaseEntity baseEntity)
        {
            if (baseEntity is BasePlayer)
            {
                BasePlayer player = (BasePlayer)baseEntity;
                if (player == null) return PvXState.Unknown;
                else if (PvXPlayers.ContainsKey(player.userID))
                {
                    return PvXPlayers[player.userID].State;
                }
                else return PvXState.Unknown;
            }
            else return PvXState.NA;
        }


        private string GetPvXStateString (PvXState state)
        {
            string value;
            switch (state)
            {
                case PvXState.AI:
                    value = "AI";
                    break;

                case PvXState.NA:
                    value = "NA";
                    break;

                case PvXState.PvE:
                    value = "PvE";
                    break;

                case PvXState.PvP:
                    value = "PvP";
                    break;

                case PvXState.Sleeper:
                    value = "Sleeper";
                    break;

                case PvXState.Unknown:
                    value = "Unknown";
                    break;
                default:
                    value = "Error";
                    break;
            }
            return value;
        }

        private void SaveAll()
        {
            playerManager.Save();
            ticketManager.Save();
            logManager.Save();
        }
        private void SavePlayerTicket()
        {
            playerManager.Save();
            ticketManager.Save();
        }


        private void CheckHelicopter()
        {
            BaseHelicopters.RemoveWhere(p => (p?.IsDestroyed ?? true));
            ChinooksHelicopters.RemoveWhere(p => (p?.IsDestroyed ?? true));
            HeliFireBalls.RemoveWhere(p => (p?.IsDestroyed ?? true));
            BradleyAPCs.RemoveWhere(p => (p?.IsDestroyed ?? true));
        }

        private int BaseHeliCount { get { return BaseHelicopters.Count; } }

        private int CH47Count { get { return ChinooksHelicopters.Count; } }

        private int BradleyCount { get { return BradleyAPCs.Count; } }

        private int HeliCounts ()
        {
            return (BaseHeliCount + CH47Count);
        }

        #endregion

        #region Chat Commands
        [ChatCommand("pvx")]
        void PvXChatCmd(BasePlayer player, string cmd, string[] args)
        {
            SaveAll();
               IPlayer iplayer = FindIPlayer(player.UserIDString);
            if (args.Count() == 0)
            {
                iplayer.Reply(GetMSG("PvX Chat Instructions 1", player.UserIDString));
                iplayer.Reply(GetMSG("PvX Chat Instructions 2", player.UserIDString));
                iplayer.Reply(GetMSG("PvX Chat Instructions 3", player.UserIDString));
            }
            else if (args.Count() > 0)
            {
                double CalculatedCooldown = (PvXPlayers[player.userID].LastRequestStamp + (configData.Options.ModeSwitchCooldown * 60f));
                switch (args[0].ToLower())
                {
                    case "pve":
                        if (PvXPlayers[player.userID].State == PvXState.NA)
                        {
                            PvXPlayers[player.userID].State = PvXState.PvE;
                            PvXPlayers[player.userID].Notification = PvXNotification.NA;
                            PvXPlayers[player.userID].LastRequestStamp = GetTimeStamp();
                            
                            playerManager.Save();
                            iplayer.Reply(GetMSG("PlayerModeChange", iplayer.Id, "PvE"));
                            UpdatePlayersGui(player);
                        }
                        else
                        {
                            iplayer.Reply(GetMSG("ChatInstructionChange",iplayer.Id));
                        }
                        break;

                    case "pvp":
                        if (PvXPlayers[player.userID].State == PvXState.NA)
                        {
                            PvXPlayers[player.userID].State = PvXState.PvP;
                            PvXPlayers[player.userID].Notification = PvXNotification.NA;
                            PvXPlayers[player.userID].LastRequestStamp = GetTimeStamp();

                            playerManager.Save();
                            iplayer.Reply(GetMSG("PlayerModeChange", iplayer.Id, "PvP"));
                            UpdatePlayersGui(player);
                        }
                        else
                        {
                            iplayer.Reply(GetMSG("ChatInstructionChange", iplayer.Id));
                        }

                        break;

                    case "change":
                        if (!PvXPlayers.ContainsKey(player.userID))
                        {
                            iplayer.Reply(GetMSG("ChatInstructionPvX", iplayer.Id));
                            return;
                        }

                        if (configData.Options.AllowCooldowns)
                        {
                            if (CalculatedCooldown <= GetTimeStamp())
                            {
                                if (PvXPlayers[player.userID].State == PvXState.PvP)
                                {
                                    PvXPlayers[player.userID].State = PvXState.PvE;
                                    PvXPlayers[player.userID].LastRequestStamp = GetTimeStamp();
                                    iplayer.Reply(GetMSG("PlayerModeChange", iplayer.Id, "PvE"));
                                    playerManager.Save();
                                    UpdatePlayersGui(player);
                                }
                                else if (PvXPlayers[player.userID].State == PvXState.PvE)
                                {
                                    PvXPlayers[player.userID].State = PvXState.PvP;
                                    PvXPlayers[player.userID].LastRequestStamp = GetTimeStamp();
                                    iplayer.Reply(GetMSG("PlayerModeChange", iplayer.Id, "PvP"));
                                    playerManager.Save();
                                    UpdatePlayersGui(player);
                                }
                                else
                                {
                                    iplayer.Reply(GetMSG("ChatInstructionPvX", iplayer.Id));
                                }
                            }
                            else if (configData.Options.AllowTickets)
                            {
                                int TicketNumber = GetNewTicketID();
                                PvXTickets.Add(TicketNumber, CreateTicketData(player, TicketNumber));
                                iplayer.Reply(GetMSG("PlayerTicketCreated",iplayer.Id));
                                PvXPlayers[player.userID].Ticket = true;
                                PvXPlayers[player.userID].TicketID = TicketNumber;
                                SavePlayerTicket();
                                UpdateAdminsGui();
                                UpdatePlayersGui(player);
                            }
                            else
                            {
                                double TimeRemaining = (CalculatedCooldown-GetTimeStamp())/60f;
                                // Notify player of remaining time before they can 
                                iplayer.Reply(GetMSG("PlayerTimeRemainingVar",iplayer.Id, TimeRemaining.ToString("n2")));
                            }
                        }
                        else if (configData.Options.AllowTickets)
                        {
                            int TicketNumber = GetNewTicketID();
                            PvXTickets.Add(TicketNumber, CreateTicketData(player, TicketNumber));
                            iplayer.Reply(GetMSG("PlayerTicketCreated", iplayer.Id));
                            PvXPlayers[player.userID].Ticket = true;
                            PvXPlayers[player.userID].TicketID = TicketNumber;
                            UpdateAdminsGui();
                        }
                        else
                        {
                            Puts("you fked up, no ticket or cooldown option set for PvX");
                        }
                        break;

                    case "ticket":
                        if (PvXPlayers[player.userID].Ticket)
                        {
                            iplayer.Reply(GetMSG("PlayerHasTicketVar", iplayer.Id, PvXPlayers[player.userID].TicketID));
                        }
                        else
                        {
                            iplayer.Reply(GetMSG("PlayerNoTicket", iplayer.Id));
                        }

                        break;

                    case "tickets":
                        if (HasPerm(player, "admin", GetMSG("MissingPermisionVar", iplayer.Id, "admin")))
                        {
                            if (args.Count() > 1)
                            {
                                switch (args[1].ToLower())
                                {
                                    case "list":
                                        if (PvXTickets.Count() == 0)
                                        {
                                            iplayer.Reply(GetMSG("AdminNoTickets",iplayer.Id));
                                        }
                                        foreach (int TicketNumber in PvXTickets.Keys)
                                        {
                                            iplayer.Reply(GetMSG("TicketList1", iplayer.Id, TicketNumber));
                                            iplayer.Reply(GetMSG("TicketList2", iplayer.Id, PvXTickets[TicketNumber].Name, GetPvXStateString(PvXPlayers[PvXTickets[TicketNumber].ID].State)));
                                        }

                                        break;

                                    case "view":
                                        if (args.Count() > 2)
                                        {
                                            int TicketNumber = 0;

                                            if (Int32.TryParse(args[2], out TicketNumber))
                                            {
                                                if (PvXTickets.ContainsKey(TicketNumber))
                                                {
                                                    //Add or Update Ticket View to adminviewlist.
                                                    if (AdminViewedTicket.ContainsKey(player.userID))
                                                    {
                                                        AdminViewedTicket[player.userID] = PvXTickets[TicketNumber];
                                                    }
                                                    else
                                                    {
                                                        AdminViewedTicket.Add(player.userID, PvXTickets[TicketNumber]);
                                                    }

                                                    iplayer.Reply(GetMSG("AdminViewTicket1Var", iplayer.Id, TicketNumber));
                                                    iplayer.Reply(GetMSG("AdminViewTicket2Var", iplayer.Id, PvXTickets[TicketNumber].Name));
                                                    iplayer.Reply(GetMSG("AdminViewTicket3Var", iplayer.Id, PvXTickets[TicketNumber].TimeStampString));
                                                    iplayer.Reply(GetMSG("AdminViewTicket4Var", iplayer.Id, PvXTickets[TicketNumber].Reason));
                                                    iplayer.Reply(GetMSG("AdminViewTicket5", iplayer.Id));
                                                }
                                            }
                                        }

                                        break;

                                    default:

                                        break;
                                }
                            }
                        }

                        break;

                    case "accept":
                        if (HasPerm(player, "admin", GetMSG("MissingPermisionVar", iplayer.Id, "admin")))
                        {
                            if (AdminViewedTicket.ContainsKey(player.userID))
                            {
                                PvXTicket ViewedTicket = AdminViewedTicket[player.userID];
                                if (PvXTickets[ViewedTicket.TicketID] == ViewedTicket)
                                {
                                    int TicketNumber = ViewedTicket.TicketID;
                                    ulong TicketPlayerID = PvXTickets[TicketNumber].ID;
                                    IPlayer TicketIplayer = FindIPlayer(TicketPlayerID.ToString());
                                    BasePlayer TicketPlayer = FindBasePlayer(TicketPlayerID.ToString());

                                    iplayer.Reply(GetMSG("AdminTicketAcceptedVar", iplayer.Id, ViewedTicket.Name));
                                    PvXLog log = new PvXLog
                                    {
                                        AdminID = player.userID,
                                        AdminName = player.displayName,
                                        CreatedTimeStamp = PvXTickets[TicketNumber].TimeStampString,
                                        PlayerID = PvXTickets[TicketNumber].ID,
                                        PlayerName = PvXTickets[TicketNumber].Name,
                                        Reason = PvXTickets[TicketNumber].Reason,
                                        ReviewedTimeStamp = GetDateStamp(),
                                        Outcome = "Accepted"
                                    };
                                    PvXLogs.Add(GetNewLogID(), log);
                                    PvXTickets.Remove(TicketNumber);
                                    if (PvXPlayers[TicketPlayerID].State == PvXState.PvP)
                                    {
                                        PvXPlayers[TicketPlayerID].State = PvXState.PvE;
                                        PvXPlayers[TicketPlayerID].LastRequestStamp = GetTimeStamp();
                                    }
                                    else
                                    {
                                        PvXPlayers[TicketPlayerID].State = PvXState.PvP;
                                        PvXPlayers[TicketPlayerID].LastRequestStamp = GetTimeStamp();
                                    }
                                    PvXPlayers[TicketPlayerID].Ticket = false;
                                    PvXPlayers[TicketPlayerID].TicketID = 0;

                                    if (TicketPlayer.IsConnected)
                                    {
                                        UpdatePlayersGui(player);
                                        TicketIplayer.Reply(GetMSG("PlayerTicketAcceptedVar", TicketIplayer.Id, GetPvXStateString(PvXPlayers[TicketPlayerID].State)));
                                    }
                                    else
                                    {
                                        PvXPlayers[TicketPlayerID].Notification = PvXNotification.Accepted;
                                    }
                                    SaveAll();
                                }
                                else
                                {
                                    iplayer.Reply(GetMSG("AdminTicketsDontMatch", iplayer.Id));
                                    AdminViewedTicket.Remove(player.userID);
                                }
                                AdminViewedTicket.Remove(player.userID);
                            }
                            else
                            {
                                iplayer.Reply(GetMSG("AdminNoViewTicket", iplayer.Id));
                            }
                        }

                        break;

                    case "decline":
                        if (HasPerm(player, "admin", GetMSG("MissingPermisionVar", iplayer.Id, "admin")))
                        {
                            if (AdminViewedTicket.ContainsKey(player.userID))
                            {
                                PvXTicket ViewedTicket = AdminViewedTicket[player.userID];
                                if (PvXTickets[ViewedTicket.TicketID] == ViewedTicket)
                                {

                                    iplayer.Reply(GetMSG("AdminTicketDeclinedVar", iplayer.Id, ViewedTicket.Name));
                                    int TicketNumber = ViewedTicket.TicketID;
                                    ulong TicketPlayerID = PvXTickets[TicketNumber].ID;
                                    IPlayer TicketIplayer = FindIPlayer(TicketPlayerID.ToString());
                                    BasePlayer TicketPlayer = FindBasePlayer(TicketPlayerID.ToString());

                                    PvXLog log = new PvXLog
                                    {
                                        AdminID = player.userID,
                                        AdminName = player.displayName,
                                        CreatedTimeStamp = PvXTickets[TicketNumber].TimeStampString,
                                        PlayerID = PvXTickets[TicketNumber].ID,
                                        PlayerName = PvXTickets[TicketNumber].Name,
                                        Reason = PvXTickets[TicketNumber].Reason,
                                        ReviewedTimeStamp = GetDateStamp(),
                                        Outcome = "Declined"
                                        
                                    };
                                    PvXLogs.Add(GetNewLogID(), log);
                                    PvXTickets.Remove(TicketNumber);
                                    PvXPlayers[TicketPlayerID].Ticket = false;
                                    PvXPlayers[TicketPlayerID].TicketID = 0;

                                    if (TicketPlayer.IsConnected)
                                    {
                                        UpdatePlayersGui(player);
                                        TicketIplayer.Reply(GetMSG("PlayerTicketDeclined", TicketIplayer.Id, GetPvXStateString(PvXPlayers[TicketPlayerID].State)));
                                    }
                                    else
                                    {
                                        PvXPlayers[TicketPlayerID].Notification = PvXNotification.Delcined;
                                    }
                                    SaveAll();
                                }
                                else
                                {
                                    iplayer.Reply(GetMSG("AdminTicketsDontMatch", iplayer.Id));
                                }
                                AdminViewedTicket.Remove(player.userID);
                            }
                            else
                            {
                                iplayer.Reply(GetMSG("AdminNoViewTicket", iplayer.Id));
                            }
                        }

                        break;

                    case "reason":
                        if (args.Count() == 2)
                        {
                            if (PvXPlayers[player.userID].Ticket)
                            {
                                int TicketNumber = PvXPlayers[player.userID].TicketID;
                                PvXTickets[TicketNumber].Reason = args[1];
                                ticketManager.Save();
                            }
                        }
                        else
                        {
                            iplayer.Reply(GetMSG("PlayerReasonIncorrect", iplayer.Id));
                        }

                        break;

                    default:

                        break;
                }
            }
        }

        #endregion

        #region Combat Handle
        
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null || !initialized) return;
            var prefabname = entity?.ShortPrefabName ?? string.Empty;
            var longprefabname = entity?.PrefabName ?? string.Empty;
            if (string.IsNullOrEmpty(prefabname) || string.IsNullOrEmpty(longprefabname)) return;
            
            if (entity is CH47HelicopterAIController)
            {
                ChinooksHelicopters.Add((entity as CH47HelicopterAIController));
                return;
            }

            if (entity is BradleyAPC)
            {
                BradleyAPCs.Add((entity as BradleyAPC));
            }

            if (prefabname.Contains("patrolhelicopter") && !prefabname.Contains("gibs"))
            {
                var AIHeli = entity?.GetComponent<PatrolHelicopterAI>() ?? null;
                var BaseHeli = entity?.GetComponent<BaseHelicopter>() ?? null;
                if (AIHeli == null || BaseHeli == null) return;
                BaseHelicopters.Add(BaseHeli);
                return;
            }

            var ownerID = (entity as BaseEntity)?.OwnerID ?? 0;

            if ((prefabname.Contains("napalm") || prefabname.Contains("oilfireball")) && !prefabname.Contains("rocket"))
            {
                var fireball = entity?.GetComponent<FireBall>() ?? null;
                if (fireball == null) return;
                Puts("Entity is Fireball from helicopter");
                return;
            }

            if (prefabname.Contains("rocket_heli"))
            {
                //Puts(prefabname.ToString());
                //entity.Kill();
            }

            if (prefabname.Contains("maincannonshell")){
                if (entity is TimedExplosive)
                {
                    if (BradleyAPCs.Count > 0)
                    {
                        // maybe do something here
                    }
                    else
                    {
                        // Delete the item
                    }
                }
            }

            //else
            //{
            //    Puts("Entity Name: " + entity.name);
            //    Puts("Entity Prefab Name: " + entity.PrefabName);
            //    Puts("Entity Short Prefab Name: " + entity.ShortPrefabName);
            //    Puts("Entity GameObject: " + entity.gameObject);
            //}


            //if (entity is BaseEntity)
            //{
            //    BaseEntity thing = (BaseEntity)entity;
            //    if (thing is BaseCombatEntity)
            //    {
            //        BaseCombatEntity baseCombatEntity;
            //    }
            //    Puts("OwnerID");
            //    Puts(thing.OwnerID.ToString());
            //    Puts("Creator entity");
            //}
        }

        //void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        //{
        //    Puts("OnEntityDeath works!");
        //}

        //void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
        //{
        //    Puts("OnEntityEnter works!");
        //}

        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null) return;
            var name = entity?.ShortPrefabName ?? string.Empty;
            if (name.Contains("patrolhelicopter") && !name.Contains("gib"))
            {
                var baseHeli = entity?.GetComponent<BaseHelicopter>() ?? null;
                if (baseHeli == null) return;
                if (BaseHelicopters.Contains(baseHeli)) BaseHelicopters.Remove(baseHeli);
            }
            if (entity is CH47HelicopterAIController)
            {
                var CH47 = entity?.GetComponent<CH47HelicopterAIController>() ?? null;
                if (CH47 == null) return;
                if (ChinooksHelicopters.Contains(CH47)) ChinooksHelicopters.Remove(CH47);
            }
            if (entity is BradleyAPC)
            {
                var bradley = entity?.GetComponent<BradleyAPC>() ?? null;
                if (bradley == null) return;
                if (BradleyAPCs.Contains(bradley)) BradleyAPCs.Remove(bradley);
            }
            if (entity is FireBall || name.Contains("fireball") || name.Contains("napalm"))
            {
                var fireball = entity?.GetComponent<FireBall>() ?? null;
                if (fireball != null && HeliFireBalls.Contains(fireball)) HeliFireBalls.Remove(fireball);
            }
            //if (entity.ToString().Contains("maincannonshell"))
            //{

            //}
        }

        //private void FireRocket(PatrolHelicopterAI heliAI)
        //{
        //    Puts("Heli Fire rocket being called");
        //}

        void OnEntityTakeDamage(BaseCombatEntity Target, HitInfo HitInfo)
        {
            if (HitInfo.damageTypes.Has(Rust.DamageType.Decay)) return;
            if (initialized == false)
            {
                ModifyDamage(HitInfo, 0f);
                return;
            }
            if (Target == null || HitInfo == null || Target.GetComponent<ResourceDispenser>() != null) return;

            BaseEntity Attacker = HitInfo?.Initiator;
            Type attackerType = Attacker?.GetType();
            Type targetType = Target?.GetType();
            String Weapon = HitInfo?.WeaponPrefab?.ShortPrefabName;

            //  Handle Attacks with Null damage
            if ((Attacker == null || attackerType == null || targetType == null) && Weapon == null)
            {
                Puts("return");
                return;
            }
            else if ((Attacker == null || attackerType == null || targetType == null) && Weapon == "maincannonshell") BradleyAPCAttacker(Target, HitInfo);
            else if ((Attacker == null || attackerType == null || targetType == null) && Weapon == "rocket_heli_napalm") HelicopterAttacker(Target, HitInfo);
            else if (Attacker == null || attackerType == null || targetType == null)
            {
                if (Weapon != null)
                {
                    Puts("Weapon: " + Weapon);
                }
                if (Attacker == null)
                {
                    HitInfo hitinfocopy = HitInfo;
                    ModifyDamage(HitInfo, 0f);
                    DamageDebuger(hitinfocopy);
                    return;
                }
                if (attackerType == null)
                {
                    HitInfo hitinfocopy = HitInfo;
                    ModifyDamage(HitInfo, 0f);
                    DamageDebuger(hitinfocopy);
                    return;
                }
                if (targetType == null)
                {
                    ModifyDamage(HitInfo, 0f);
                    return;
                }
                return;
            }


            if (targetType == typeof(HelicopterDebris) || targetType == typeof(DroppedItemContainer)) return;
            else if (Attacker is BasePlayer) PlayerAttacker(Target, (BasePlayer)Attacker, HitInfo);
            else if (Attacker is FireBall) FireBallAttacker(Target, HitInfo);
            else if (Attacker is BaseHelicopter) HelicopterAttacker(Target, HitInfo);
            else if (Attacker is BradleyAPC) BradleyAPCAttacker(Target, HitInfo);
            else if (AnimalList.Contains(attackerType)) AnimalAttacker(Target, HitInfo);
            else if (Attacker is MotorRowboat) return; //removes debugging spam
        }

        void PlayerAttacker(BaseEntity Target, BasePlayer Attacker, HitInfo HitInfo)
        {
            if (Target is Scientist)
            {
                if (Attacker is Scientist) return;
                return;

                //BasePlayer BaseTarget = (BasePlayer)Target;
                //BasePlayer BaseAttacker = (BasePlayer)Attacker;
                //if (BaseTarget.userID == BaseAttacker.userID) return;

                //if (PvXPlayers[BaseTarget.userID].State == PvXState.PvP && PvXPlayers[BaseAttacker.userID].State == PvXState.PvP)
                //{
                //    return;
                //}
                //else if (PvXPlayers[BaseTarget.userID].State == PvXState.PvE)
                //{
                //    ModifyDamage(HitInfo, 0f);
                //    IPlayer IplayerAttacker = FindIPlayer(BaseAttacker.UserIDString);
                //    IplayerAttacker.Reply(GetMSG("EnemyPvE", IplayerAttacker.Id));
                //    return;
                //}
                //else
                //{
                //    ModifyDamage(HitInfo, 0f);
                //    IPlayer IplayerAttacker = FindIPlayer(BaseAttacker.UserIDString);
                //    IplayerAttacker.Reply(GetMSG("PlayerPvE", IplayerAttacker.Id));
                //    return;
                //}
            }
            if (Target is BasePlayer)
            {
                if (Attacker is Scientist) return;
                BasePlayer BaseTarget = (BasePlayer)Target;
                BasePlayer BaseAttacker = (BasePlayer)Attacker;
                if (BaseTarget.userID == BaseAttacker.userID) return;

                if (PvXPlayers[BaseTarget.userID].State == PvXState.PvP && PvXPlayers[BaseAttacker.userID].State == PvXState.PvP)
                {
                    return;
                }
                else if (PvXPlayers[BaseTarget.userID].State == PvXState.PvE)
                {
                    ModifyDamage(HitInfo, 0f);
                    IPlayer IplayerAttacker = FindIPlayer(BaseAttacker.UserIDString);
                    IplayerAttacker.Reply(GetMSG("EnemyPvE", IplayerAttacker.Id));
                    return;
                }
                else
                {
                    ModifyDamage(HitInfo, 0f);
                    IPlayer IplayerAttacker = FindIPlayer(BaseAttacker.UserIDString);
                    IplayerAttacker.Reply(GetMSG("PlayerPvE", IplayerAttacker.Id));
                    return;
                }
            }
            else if (BuildEntityList.Contains(Target.GetType()))
            {
                BasePlayer BaseTarget = FindBasePlayer(Target.OwnerID.ToString());
                BasePlayer BaseAttacker = (BasePlayer)Attacker;
                if (Target.OwnerID == 0) return;
                if (BaseTarget.userID == BaseAttacker.userID) return;

                if (PvXPlayers[BaseTarget.userID].State == PvXState.PvP && PvXPlayers[BaseAttacker.userID].State == PvXState.PvP)
                {
                    return;
                }
                else if (PvXPlayers[BaseTarget.userID].State == PvXState.PvE)
                {
                    ModifyDamage(HitInfo, 0f);
                    IPlayer IplayerAttacker = FindIPlayer(BaseAttacker.UserIDString);
                    IplayerAttacker.Reply(GetMSG("EnemyPvE", IplayerAttacker.Id));
                    return;
                }
                else
                {
                    ModifyDamage(HitInfo, 0f);
                    IPlayer IplayerAttacker = FindIPlayer(BaseAttacker.UserIDString);
                    IplayerAttacker.Reply(GetMSG("PlayerPvE", IplayerAttacker.Id));
                    return;
                }
            }
            else if (AnimalList.Contains(Target.GetType()))
            {
                return;
            }
            else if (Target is BaseHelicopter)
            {
                BasePlayer BaseAttacker = (BasePlayer)Attacker;

                if (PvXPlayers[BaseAttacker.userID].State == PvXState.PvP)
                {
                    return;
                }
                else if (PvXPlayers[BaseAttacker.userID].State == PvXState.PvE)
                {
                    ModifyDamage(HitInfo, 0f);
                    IPlayer IplayerAttacker = FindIPlayer(BaseAttacker.UserIDString);
                    IplayerAttacker.Reply(GetMSG("EnemyPvE", IplayerAttacker.Id));
                    return;
                }
                else
                {
                    ModifyDamage(HitInfo, 0f);
                    IPlayer IplayerAttacker = FindIPlayer(BaseAttacker.UserIDString);
                    IplayerAttacker.Reply(GetMSG("PlayerPvE", IplayerAttacker.Id));
                    return;
                }
            }
            else if (Target is BradleyAPC)
            {
                BasePlayer BaseAttacker = (BasePlayer)Attacker;

                if (PvXPlayers[BaseAttacker.userID].State == PvXState.PvP)
                {
                    return;
                }
                else if (PvXPlayers[BaseAttacker.userID].State == PvXState.PvE)
                {
                    ModifyDamage(HitInfo, 0f);
                    IPlayer IplayerAttacker = FindIPlayer(BaseAttacker.UserIDString);
                    IplayerAttacker.Reply(GetMSG("EnemyPvE", IplayerAttacker.Id));
                    return;
                }
                else
                {
                    ModifyDamage(HitInfo, 0f);
                    IPlayer IplayerAttacker = FindIPlayer(BaseAttacker.UserIDString);
                    IplayerAttacker.Reply(GetMSG("PlayerPvE", IplayerAttacker.Id));
                    return;
                }
            }
        }
        void FireBallAttacker(BaseEntity Target, HitInfo hitInfo)
        {
            FireBall fireBall = (FireBall)hitInfo.Initiator;
            var prefabname = fireBall?.ShortPrefabName ?? string.Empty;

            if ((prefabname.Contains("napalm") || prefabname.Contains("oilfireball")) && !prefabname.Contains("rocket")) HelicopterAttacker(Target, hitInfo);
        }
        void HelicopterAttacker(BaseEntity Target, HitInfo hitInfo)
        {
            if (Target is BasePlayer)
            {
                BasePlayer BaseTarget = (BasePlayer)Target;

                if (PvXPlayers[BaseTarget.userID].State == PvXState.PvP)
                {
                    return;
                }
                else if (PvXPlayers[BaseTarget.userID].State == PvXState.PvE)
                {
                    ModifyDamage(hitInfo, 0f);
                    return;
                }
                else
                {
                    ModifyDamage(hitInfo, 0f);
                    return;
                }
            }
            else if (BuildEntityList.Contains(Target?.GetType()))
            {
                BasePlayer BaseTarget = FindBasePlayer(Target.OwnerID.ToString());

                if (PvXPlayers[BaseTarget.userID].State == PvXState.PvP)
                {
                    return;
                }
                else if (PvXPlayers[BaseTarget.userID].State == PvXState.PvE)
                {
                    ModifyDamage(hitInfo, 0f);
                    return;
                }
                else
                {
                    ModifyDamage(hitInfo, 0f);
                    return;
                }
            }
        }
        void BradleyAPCAttacker(BaseEntity Target, HitInfo hitInfo)
        {
            if (Target is BasePlayer)
            {
                BasePlayer BaseTarget = (BasePlayer)Target;

                if (PvXPlayers[BaseTarget.userID].State == PvXState.PvP)
                {
                    return;
                }
                else if (PvXPlayers[BaseTarget.userID].State == PvXState.PvE)
                {
                    ModifyDamage(hitInfo, 0f);
                    return;
                }
                else
                {
                    ModifyDamage(hitInfo, 0f);
                    return;
                }
            }
            else if (BuildEntityList.Contains(Target.GetType()))
            {
                BasePlayer BaseTarget = FindBasePlayer(Target.OwnerID.ToString());

                if (PvXPlayers[BaseTarget.userID].State == PvXState.PvP)
                {
                    return;
                }
                else if (PvXPlayers[BaseTarget.userID].State == PvXState.PvE)
                {
                    ModifyDamage(hitInfo, 0f);
                    return;
                }
                else
                {
                    ModifyDamage(hitInfo, 0f);
                    return;
                }
            }
        }
        void AnimalAttacker(BaseEntity Target, HitInfo hitInfo)
        {
            if (Target is BasePlayer)
            {
                return;
            }
        }

        void DamageDebuger(HitInfo hitInfo) // Need to handle Nills better
        {
            //Puts("HitInfo Data:");
            //if (hitInfo.Initiator != null)
            //{
            //    Puts("Initiatior: " + hitInfo.Initiator?.ToString());
            //    var prefabname1 = hitInfo?.Initiator.PrefabName ?? null;
            //    if (prefabname1 != null) Puts(prefabname1.ToString());
            //}
            //if (hitInfo.GetType() != null)
            //{
            //    Puts("HitInfo Type: " + hitInfo.GetType().ToString());
            //}
            //Puts("ProjectilePrefab:");
            //if (hitInfo.ProjectilePrefab != null)
            //{
            //    Puts("ProjectilePrefab: " + hitInfo.ProjectilePrefab.GetType().ToString() );
            //}
            
            // Puts(hitInfo.HitEntity.name.ToString());
        }
        
        void ModifyDamage(HitInfo HitInfo, float scale)
        {
            if (scale == 0f)
            {
                HitInfo.damageTypes = new DamageTypeList();
                HitInfo.DoHitEffects = false;
                HitInfo.HitMaterial = 0;
                HitInfo.PointStart = Vector3.zero;
                HitInfo.PointEnd = Vector3.zero;
            }
            else if (scale == 1) return;
            else
            {
                //Puts("Modify Damabe by: {0}", scale);
                HitInfo.damageTypes.ScaleAll(scale);
            }
        }
        
        //void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles)
        //{
        //    Puts("OnWeaponFired works!");
        //}

        //void OnRocketLaunched()
        //{
        //    Puts("OnRocketLaunched being Called");
        //}

        //void OnRocketLaunched(BaseHelicopter baseHelicopter, BaseEntity baseEntity)
        //{
        //    Puts("OnRocketLaunched being Called by heli");
        //}

        //void OnCreateWorldProjectile()
        //{
        //    Puts("OnCreateWorldProjectile being Called");
        //    //Puts(item.GetType().ToString());
        //}
        #endregion

        #region Plugin Compatability

        [PluginReference]
        public Plugin HumanNPC;
        internal static bool IsNPC(ulong Player)
        {
            if (PvX.HumanNPC == null) return false;
            else if (Player < 76560000000000000L) return true;
            else return false;
        }
        internal static bool IsNPC(BaseCombatEntity Player)
        {
            BasePlayer _test = (BasePlayer)Player;
            if (PvX.HumanNPC == null) return false;
            else if (_test.userID < 76560000000000000L) return true;
            else return false;
        }
        internal static bool IsNPC(PlayerCorpse Corpse)
        {
            if (PvX.HumanNPC == null) return false;
            else if (Corpse.playerSteamID < 76560000000000000L) return true;
            else return false;
        }

        #endregion

        #region Messaging

        private void PlayerNotification(IPlayer iplayer)
        {
            BasePlayer player = FindBasePlayer(iplayer.Id);
            if (iplayer.IsConnected)
            {
                PvXNotification notification = PvXPlayers[player.userID].Notification;
                switch (notification)
                {
                    case PvXNotification.NoMode:
                        iplayer.Reply(GetMSG("PlayerNotificationNA", iplayer.Id));
                        PvX.timer.Once(10, () => PlayerNotification(iplayer));
                        break;

                    case PvXNotification.Accepted:

                        //remove notification
                        iplayer.Reply(GetMSG("PlayerNotificationAccepted", iplayer.Id));
                        PvXPlayers[player.userID].Notification = PvXNotification.NA;
                        break;

                    case PvXNotification.Delcined:

                        //remove notification
                        iplayer.Reply(GetMSG("PlayerNotificationDeclined", iplayer.Id));
                        PvXPlayers[player.userID].Notification = PvXNotification.NA;
                        break;

                    case PvXNotification.Timed:

                        //remove notification
                        iplayer.Reply(GetMSG("PlayerNotificationTimed", iplayer.Id));
                        PvXPlayers[player.userID].Notification = PvXNotification.NA;
                        break;

                    default:

                        break;
                }
            }
        }

        private string GetMSG(string key, string userid = null, params object[] args) => string.Format(lang.GetMessage(key, this, userid), args);
        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"AdminViewTicket1Var","Ticket {0} Details"},
            {"AdminViewTicket2Var","Player Name: {0}"},
            {"AdminViewTicket3Var","Time Stamp: {0}"},
            {"AdminViewTicket4Var","Reason: {0}"},
            {"AdminViewTicket5","Please use /pvx [accept/decline] to confirm."},
            {"AdminNoTickets", "No tickets to display."},
            {"AdminTicketsDontMatch","This ticket is no longer available, please view another one."},
            {"AdminTicketAcceptedVar","You have accepted the ticket for: {0}"},
            {"AdminTicketDeclinedVar","You have declined the ticket for: {0}"},
            {"AdminNoViewTicket","No ticket has been selected, please view a ticket."},
            {"Name", "Message"},
            {"EnemyPvE", "Target is PvE"},
            {"PlayerPvE", "You are PvE"},
            {"PlayerNotificationNA", "This server is running PvX, please select a mode: ''/pvx''"},
            {"PlayerModeChange", "You have changed to {0}"},
            {"PlayerAlreadyHasTicket","You already have a ticket, please contact the admin"},
            {"PlayerNotificationAccepted", "Welcome back, A admin has accepted your ticket"},
            {"PlayerNotificationDeclined", "Welcome back, A admin has declined your ticket"},
            {"PlayerNotificationTimed", "Welcome back, your ticket has auto accepted"},
            {"PlayerTicketAcceptedVar", "Your ticket has closed and you are now a {0} player"},
            {"PlayerTicketDeclined", "Your ticket has been declined by an admin."},
            {"PlayerNoTicket", "You do not have a ticket."},
            {"PlayerTimeRemainingVar", "Unable to change, Minutes remaining: {0}."},
            {"PlayerTicketCreated", "Creating Ticket."},
            {"PlayerHasTicketVar", "Your ticket number is: {0}"},
            {"NoValidTicket", "Warning, No valid ticket was located please check data file"},
            {"WelcomeMessage", "Welcome, this server runs PvX, Please type /Command for more information"},
            {"why is this here", "Because I am lazy"},
            {"ChatInstructionChange", "Please use command: /pvx change"},
            {"ChatInstructionPvX", "Please use command: /pvx [PvE/PvP]"},
            {"PvX Chat Instructions 1", "PvX Commands"},
            {"PvX Chat Instructions 2", "Select Mode /pvx [pve/pvx]"},
            {"PvX Chat Instructions 3", "Change Mode /pvx ''change''"},
            {"MissingPermisionVar", "You do not have the required permision: {0}"},
            {"TicketList1", "Ticket Number: {0}"},
            {"TicketList2", "Requester: {0}, Current mode: {1}"},
            {"PlayerReasonIncorrect","Incorrect format please use /pvx reason ''Reason for change''"},
            {"xx","xx"},
            {"x", "Warning, invalid LANG code called"}
        };
        
        #endregion

        #region QUI
        class UIColours
        {
            public static readonly UIColours Black_100 = new UIColours("0.00 0.00 0.00 1.00"); //Black
            public static readonly UIColours Black_050 = new UIColours("0.00 0.00 0.00 0.50");
            public static readonly UIColours Black_015 = new UIColours("0.00 0.00 0.00 0.15");
            public static readonly UIColours Grey2_100 = new UIColours("0.20 0.20 0.20 1.00"); //Grey 2
            public static readonly UIColours Grey2_050 = new UIColours("0.20 0.20 0.20 0.50");
            public static readonly UIColours Grey2_015 = new UIColours("0.20 0.20 0.20 0.15");
            public static readonly UIColours Grey5_100 = new UIColours("0.50 0.50 0.50 1.00"); //Grey 5
            public static readonly UIColours Grey5_050 = new UIColours("0.50 0.50 0.50 0.50");
            public static readonly UIColours Grey5_015 = new UIColours("0.50 0.50 0.50 0.15");
            public static readonly UIColours Grey8_100 = new UIColours("0.80 0.80 0.80 1.00"); //Grey 8
            public static readonly UIColours Grey8_050 = new UIColours("0.80 0.80 0.80 0.50");
            public static readonly UIColours Grey8_015 = new UIColours("0.80 0.80 0.80 0.15");
            public static readonly UIColours White_100 = new UIColours("1.00 1.00 1.00 1.00"); //White
            public static readonly UIColours White_050 = new UIColours("1.00 1.00 1.00 0.50");
            public static readonly UIColours White_015 = new UIColours("1.00 1.00 1.00 0.15");
            public static readonly UIColours Red_100 = new UIColours("0.70 0.20 0.20 1.00");   //Red
            public static readonly UIColours Red_050 = new UIColours("0.70 0.20 0.20 0.50");
            public static readonly UIColours Red_015 = new UIColours("0.70 0.20 0.20 0.15");
            public static readonly UIColours Green_100 = new UIColours("0.20 0.70 0.20 1.00");  //Green
            public static readonly UIColours Green_050 = new UIColours("0.20 0.70 0.20 0.50");
            public static readonly UIColours Green_015 = new UIColours("0.20 0.70 0.20 0.15");
            public static readonly UIColours Blue_100 = new UIColours("0.20 0.20 0.70 1.00");  //Blue
            public static readonly UIColours Blue_050 = new UIColours("0.20 0.20 0.70 0.50");
            public static readonly UIColours Blue_015 = new UIColours("0.20 0.20 0.70 0.15");
            public static readonly UIColours Yellow_100 = new UIColours("0.90 0.90 0.20 1.00");  //Yellow
            public static readonly UIColours Yellow_050 = new UIColours("0.90 0.90 0.20 0.50");
            public static readonly UIColours Yellow_015 = new UIColours("0.90 0.90 0.20 0.15");
            public static readonly UIColours Gold_100 = new UIColours("0.745 0.550 0.045 1.00"); //Gold

            public string Value;
            public int Index;

            private UIColours(string value)
            {
                Value = value;
            }
            public static implicit operator string(UIColours uiColours)
            {
                return uiColours.Value;
            }
        }
        public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool useCursor = false, string parent = "Hud")
        {
            var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }
        public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
        public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, float fadein = 1.0f, TextAnchor align = TextAnchor.MiddleCenter)
            {
                if (configData.Gui.DisableUI_FadeIn)
                    fadein = 0;
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
        public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, float fadein = 1.0f, TextAnchor align = TextAnchor.MiddleCenter)
            {
                if (configData.Gui.DisableUI_FadeIn)
                    fadein = 0;
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = fadein },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
        public void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
        public void CreateTextOverlay(ref CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
        {
            if (configData.Gui.DisableUI_FadeIn)
                fadein = 0;
            container.Add(new CuiLabel
            {
                Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
            },
            panel);

        }
        
        #endregion

        #region GUI
        public void AdminIndicatorGui(BasePlayer Player)
        {
            Vector2 dimension = new Vector2(0.174F, 0.028F);
            Vector2 posMin = new Vector2(configData.Gui.adminIndicatorMinWid, configData.Gui.adminIndicatorMinHei);
            Vector2 posMax = posMin + dimension;
            var adminCountContainer = CreateElementContainer(
                PvxAdminUI,
                UIColours.Black_050,
                $"{posMin.x} {posMin.y}",
                $"{posMax.x} {posMax.y}");
            CreateLabel(ref adminCountContainer, PvxAdminUI, UIColours.White_100, "PvX Tickets", 10, "0.0 0.1", "0.3 0.90");
            CreateLabel(ref adminCountContainer, PvxAdminUI, UIColours.White_100, string.Format("Open: {0}", PvXTickets.Count.ToString()), 10, "0.301 0.1", "0.65 0.90");
            CreateLabel(ref adminCountContainer, PvxAdminUI, UIColours.White_100, string.Format("Closed: {0}", PvXLogs.Count.ToString()), 10, "0.651 0.1", "1 0.90");

            CuiHelper.AddUi(Player, adminCountContainer);
        }
        public void PlayerIndicatorGui(BasePlayer Player)
        {
            Vector2 dimension = new Vector2(0.031F, 0.028F);
            Vector2 posMin = new Vector2(configData.Gui.playerIndicatorMinWid, configData.Gui.playerIndicatorMinHei);
            Vector2 posMax = posMin + dimension;
            var indicatorContainer = CreateElementContainer(
                PvxIndicatorUI,
                UIColours.Black_050,
                "0.48 0.11",
                "0.52 0.14"
                );
            if (PvXPlayers[Player.userID].State == PvXState.NA)
                indicatorContainer = CreateElementContainer(
                    PvxIndicatorUI,
                    UIColours.Red_100,
                    "0.48 0.11",
                    "0.52 0.14");
            else if (PvXPlayers[Player.userID].Ticket == true)
                indicatorContainer = CreateElementContainer(
                    PvxIndicatorUI,
                    UIColours.Yellow_015,
                    "0.48 0.11",
                    "0.52 0.14");
            if (AdminsActive.Contains(Player.userID))
            {
                CreateLabel(
                    ref indicatorContainer,
                    PvxIndicatorUI,
                    UIColours.Green_100,
                    GetPvXStateString(PvXPlayers[Player.userID].State),
                    15,
                    "0.1 0.1",
                    "0.90 0.99");
            }
            else
            {
                CreateLabel(ref indicatorContainer,
                    PvxIndicatorUI,
                    UIColours.White_100,
                    GetPvXStateString(PvXPlayers[Player.userID].State),
                    15,
                    "0.1 0.1",
                    "0.90 0.99");
            }
            CuiHelper.AddUi(Player, indicatorContainer);
        }
        private void UpdatePlayersGui(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PvxIndicatorUI);
            PlayerIndicatorGui(player);
        }
        private void UpdateAdminsGui()
        {
            BasePlayer Player;
            foreach (ulong PlayerID in AdminsOnline)
            {
                Player = FindBasePlayer(PlayerID.ToString());
                CuiHelper.DestroyUi(Player, PvxAdminUI);
                AdminIndicatorGui(Player);
            }
        }
        private void UpdateAdminGui(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PvxAdminUI);
            AdminIndicatorGui(player);
        }
        private void DestroyAllPvXUI(BasePlayer player)
        {
            foreach (string _v in GuiList)
            {
                CuiHelper.DestroyUi(player, _v);
            }
            //DestroyEntries(player);
        }
        private void DestroyUIElement(BasePlayer player, string _ui)
        {
            CuiHelper.DestroyUi(player, _ui);
        }
        #endregion

    }
}

// --- End of file: PvXSelector.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/puzzle-bypass ---
// --- Original File Path: P/PuzzleBypass/PuzzleBypass.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Puzzle Bypass", "Def", "1.0.0")]
    [Description("Allows players to pass through security doors using only a keycard")]
    public class PuzzleBypass : RustPlugin
    {
        #region Fields

        private Cfg _cfg;
        private static readonly Dictionary<uint, int> DoorToKeyLevelMap = new Dictionary<uint, int> { { 4094102585u, 1 }, { 184980835u, 2 }, { 4111973013u, 3 } };
        private static readonly List<string> KeyToLang = new List<string> { "CardGreen", "CardBlue", "CardRed" };

        #endregion

        #region Config

        private class Cfg
        {
            [JsonProperty("Door close delay, if opened from Outside (seconds)")]
            public int CloseDelayOutside;
            [JsonProperty("Door close delay, if opened from Inside (seconds)")]
            public int CloseDelayInside;
            [JsonProperty("How much condition key card will lose when used (default 1)")]
            public float LoseConditionAmt;
        }

        protected override void LoadDefaultConfig()
        {
            _cfg = new Cfg
            {
                CloseDelayOutside = 180,
                CloseDelayInside = 8,
                LoseConditionAmt = 1f
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _cfg = Config.ReadObject<Cfg>();
        }

        protected override void SaveConfig() => Config.WriteObject(_cfg);

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"CardGreen", "<color=#26BE00>green</color>"},
                {"CardBlue", "<color=#0094FF>blue</color>"},
                {"CardRed", "<color=#D12700>red</color>"},
                {"NoCard", "To open this door, you must hold a {0} key card."},
                {"InvalidCard", "This {0} card does not fit this door. You need a {1} card."},
                {"ExitHint", "Hint: To exit - knock again on this door."},
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"CardGreen", "<color=#26BE00>зелёная</color>"},
                {"CardBlue", "<color=#0094FF>синяя</color>"},
                {"CardRed", "<color=#D12700>красная</color>"},
                {"NoCard", "Для прохода в Ваших руках должна быть {0} карта."},
                {"InvalidCard", "Эта {0} карта не подходит. Нужна {1} карта."},
                {"ExitHint", "Подсказка: Чтобы выйти - постучите в дверь ещё раз."},
            }, this, "ru");
        }

        private string _(string key, BasePlayer player = null, params object[] args)
        {
            var message = lang.GetMessage(key, this, player?.UserIDString);
            return message != null ? args.Length > 0 ? string.Format(message, args) : message : key;
        }

        #endregion

        #region Hooks

        private void OnDoorKnocked(Door door, BasePlayer player)
        {
            if (player == null || door == null || !door.isSecurityDoor || door.IsOpen())
                return;
            if (Vector3.Dot(-door.transform.right, (player.transform.position - door.transform.position).normalized) > 0f)
            {
                OpenSecurityDoor(door, _cfg.CloseDelayInside);
                return;
            }
            int doorCardLevel;
            if (!DoorToKeyLevelMap.TryGetValue(door.prefabID, out doorCardLevel))
                return;
            var proxcard = player.GetActiveItem()?.GetHeldEntity() as Keycard;
            if (proxcard == null || proxcard.IsBroken())
            {
                Player.Message(player, _("NoCard", player, GetNiceCardName(doorCardLevel, player)));
                return;
            }
            if (proxcard.accessLevel != doorCardLevel)
            {
                Player.Message(player, _("InvalidCard", player,
                    GetNiceCardName(proxcard.accessLevel, player), GetNiceCardName(doorCardLevel, player)));
                return;
            }
            proxcard.GetItem().LoseCondition(_cfg.LoseConditionAmt);
            OpenSecurityDoor(door, _cfg.CloseDelayOutside);
            Player.Message(player, _("ExitHint", player));
        }

        private void Unload()
        {
            foreach (var door in UnityEngine.Object.FindObjectsOfType<Door>().Where(d => d.isSecurityDoor))
                door.SetOpen(false);
        }

        #endregion

        #region Logic

        private void OpenSecurityDoor(Door door, int closeIn)
        {
            door.SetOpen(true);
            timer.In(Mathf.Max(1, closeIn), () => door.SetOpen(false));
        }

        #endregion

        #region Utils

        private string GetNiceCardName(int aLevel, BasePlayer player) => _(KeyToLang[aLevel - 1], player);

        #endregion

    }
}


// --- End of file: PuzzleBypass.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-challenges ---
// --- Original File Path: P/PlayerChallenges/PlayerChallenges.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;
using UnityEngine;
using System.Linq;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("Player Challenges", "k1lly0u", "2.0.52")]
    [Description("Keep track of various statistics and set titles to players when certain criteria have been met or when they are a leader of a challenge category")]
    class PlayerChallenges : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin BetterChat;
        [PluginReference] Plugin EventManager;
        [PluginReference] Plugin LustyMap;
        [PluginReference] Plugin Clans;
        [PluginReference] Plugin Friends;

        ChallengeData chData;
        private DynamicConfigFile data;

        private Dictionary<ulong, StatData> statCache = new Dictionary<ulong, StatData>();
        private Dictionary<Challenges, LeaderData> titleCache = new Dictionary<Challenges, LeaderData>();
        private Dictionary<ulong, WoundedData> woundedData = new Dictionary<ulong, WoundedData>();

        private Hash<ulong, Hash<ulong, float>> damageData = new Hash<ulong, Hash<ulong, float>>();

        private static Dictionary<string, string> uiColors = new Dictionary<string, string>();

        private bool UIDisabled = false;
        #endregion

        #region UI Creation
        public static class UI
        {
            public static CuiElementContainer Container(string panelName, string aMin, string aMax, bool cursor = false)
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = uiColors["background"]},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = cursor
                        },
                        new CuiElement().Parent = "Overlay",
                        panelName
                    }
                };
                return container;
            }

            public static void Panel(ref CuiElementContainer container, string panel, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = uiColors["panel"]},
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }

            public static void Label(ref CuiElementContainer container, string panel, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 0f)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }

            public static void Button(ref CuiElementContainer container, string panel, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 0f)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = uiColors["button"], Command = command, FadeIn = fadein },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.Substring(1);
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        #endregion

        #region UI Leaderboard
        private string UIMain = "PCUI_Main";

        private void CreateMenu(BasePlayer player)
        {
            CloseMap(player);
            CuiHelper.DestroyUi(player, UIMain);
            CreateMenuContents(player, 0);
        }

        private void CreateMenuContents(BasePlayer player, int page = 0)
        {
            CuiElementContainer container = UI.Container(UIMain, "0 0", "1 1", true);
            UI.Panel(ref container, UIMain, "0.005 0.93", "0.995 0.99");
            UI.Label(ref container, UIMain, $"<color={configData.Colors.TextColor1}>{MSG("UITitle").Replace("{Version}", Version.ToString())}</color>", 22, "0.05 0.93", "0.6 0.99", TextAnchor.MiddleLeft);

            KeyValuePair<Challenges, ConfigData.ChallengeInfo>[] elements = configData.ChallengeSettings.Where(x => x.Value.Enabled).OrderByDescending(x => x.Value.UIPosition).Reverse().ToArray();
            int count = page * 5;
            int number = 0;
            float dimension = 0.19f;
            for (int i = count; i < count + 5; i++)
            {
                if (elements.Length < i + 1) continue;
                float leftPos = 0.005f + (number * (dimension + 0.01f));
                AddMenuStats(ref container, UIMain, elements[i].Key, leftPos, 0.01f, leftPos + dimension, 0.92f);
                number++;
            }

            if (page > 0)
                UI.Button(ref container, UIMain, "Previous", 16, "0.63 0.94", "0.73 0.98", $"PCUI_ChangePage {page - 1}");
            if (elements.Length > count + 5)
                UI.Button(ref container, UIMain, "Next", 16, "0.74 0.94", "0.84 0.98", $"PCUI_ChangePage {page + 1}");

            UI.Button(ref container, UIMain, "Close", 16, "0.85 0.94", "0.95 0.98", "PCUI_DestroyAll");
            CuiHelper.AddUi(player, container);
        }

        private void AddMenuStats(ref CuiElementContainer MenuElement, string panel, Challenges type, float left, float bottom, float right, float top)
        {
            if (configData.ChallengeSettings[type].Enabled)
            {
                UI.Panel(ref MenuElement, UIMain, $"{left} {bottom}", $"{right} {top}");
                UI.Label(ref MenuElement, UIMain, GetLeaders(type), 16, $"{left + 0.005f} {bottom + 0.01f}", $"{right - 0.005f} {top - 0.01f}", TextAnchor.UpperLeft);
            }
        }

        #region UI Commands
        [ConsoleCommand("PCUI_ChangePage")]
        private void cmdChangePage(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            CuiHelper.DestroyUi(player, UIMain);
            CreateMenuContents(player, arg.GetInt(0));
        }
        [ConsoleCommand("PCUI_DestroyAll")]
        private void cmdDestroyAll(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            DestroyUI(player);
            OpenMap(player);
        }
        #endregion

        #region UI Functions
        private string GetLeaders(Challenges type)
        {
            string listNames = $" -- <color={configData.Colors.TextColor1}>{MSG(type.ToString()).ToUpper()}</color>\n\n";

            List<KeyValuePair<string, int>> userStats = new List<KeyValuePair<string, int>>();

            foreach (KeyValuePair<ulong, StatData> entry in statCache)
            {
                string name = entry.Value.DisplayName;
                userStats.Add(new KeyValuePair<string, int>(name, entry.Value.Stats[type]));
            }

            IEnumerable<KeyValuePair<string, int>> leaders = userStats.OrderByDescending(a => a.Value).Take(25);

            int i = 1;

            foreach (KeyValuePair<string, int> entry in leaders)
            {
                listNames += $"{i}.  - <color={configData.Colors.TextColor1}>{entry.Value}</color> -  {entry.Key}\n";
                i++;
            }
            return listNames;
        }

        private object GetTypeFromString(string name)
        {
            foreach(object type in Enum.GetValues(typeof(Challenges)))
            {
                if (type.ToString() == name)
                    return type;
            }
            return null;
        }

        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIMain);
        }
        #endregion
        #endregion

        #region External Calls
        private void CloseMap(BasePlayer player)
        {
            if (LustyMap && LustyMap.IsLoaded)
            {
                LustyMap.Call("DisableMaps", player);
            }
        }
        private void OpenMap(BasePlayer player)
        {
            if (LustyMap && LustyMap.IsLoaded)
            {
                LustyMap.Call("EnableMaps", player);
            }
        }
        private bool IsPlaying(BasePlayer player)
        {
            if (EventManager && EventManager.IsLoaded)
            {
                object isPlaying = EventManager.Call("isPlaying", player);
                if (isPlaying is bool && (bool)isPlaying)
                    return true;
            }
            return false;
        }
        private bool IsClanmate(ulong playerId, ulong friendId)
        {
            if (!Clans || !Clans.IsLoaded) return false;
            object playerTag = Clans?.Call("GetClanOf", playerId);
            object friendTag = Clans?.Call("GetClanOf", friendId);
            if (playerTag is string && friendTag is string)
                if (playerTag == friendTag) return true;
            return false;
        }
        private bool IsFriend(ulong playerId, ulong friendId)
        {
            if (!Friends || !Friends.IsLoaded) return false;
            object isFriend = Friends?.Call("IsFriend", playerId, friendId);
            if (isFriend is bool && (bool)isFriend)
                return true;
            return false;
        }
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("challenge_data");
            lang.RegisterMessages(Messages, this);
        }

        private void OnServerInitialized()
        {
            LoadData();
            CheckValidData();
            RegisterTitles();
            RegisterGroups();
            AddAllUsergroups();

            configData.ChallengeSettings[Challenges.NPCKills].Enabled = configData.Options.NPCKillSeperate;

            uiColors = new Dictionary<string, string>()
            {
                ["background"] = UI.Color(configData.Colors.Background.Color, configData.Colors.Background.Alpha),
                ["button"] = UI.Color(configData.Colors.Button.Color, configData.Colors.Button.Alpha),
                ["panel"] = UI.Color(configData.Colors.Panel.Color, configData.Colors.Panel.Alpha),
            };

            if (!configData.ChallengeSettings[Challenges.RocketsFired].Enabled)
                Unsubscribe(nameof(OnRocketLaunched));

            if (!configData.ChallengeSettings[Challenges.PlayersHealed].Enabled)
                Unsubscribe(nameof(OnHealingItemUse));

            if (!configData.ChallengeSettings[Challenges.PlantsGathered].Enabled)
            {
                Unsubscribe(nameof(OnGrowableGather));
                Unsubscribe(nameof(OnCollectiblePickup));
            }

            if (!configData.ChallengeSettings[Challenges.StructuresBuilt].Enabled)
                Unsubscribe(nameof(OnEntityBuilt));

            if (!configData.ChallengeSettings[Challenges.ExplosivesThrown].Enabled)
                Unsubscribe(nameof(OnExplosiveThrown));

            if (!configData.ChallengeSettings[Challenges.StructuresRepaired].Enabled)
                Unsubscribe(nameof(OnStructureRepair));

            if (configData.Options.UseUpdateTimer)
                CheckUpdateTimer();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void Unload()
        {
            SaveData();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                DestroyUI(player);
            RemoveAllUsergroups();
            uiColors = null;
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin?.Title == "BetterChat")
                RegisterTitles();
        }

        private void OnServerSave() => SaveData();

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null)
                return;

            if (statCache.ContainsKey(player.userID))
            {
                if (statCache[player.userID].DisplayName != player.displayName)
                    statCache[player.userID].DisplayName = player.displayName;
            }
        }

        private void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            if (player == null || player is NPCPlayer)
                return;

            AddPoints(player, Challenges.RocketsFired, 1);
        }

        private void OnHealingItemUse(HeldEntity item, BasePlayer target)
        {
            BasePlayer player = item.GetOwnerPlayer();
            if (player == null || player is NPCPlayer)
                return;

            if (player != target)
            {
                if (target.health == target.MaxHealth())
                    return;

                AddPoints(player, Challenges.PlayersHealed, 1);
            }
        }

        private void OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter itemCrafter)
        {
            if (!itemCrafter)
                return;
            
            BasePlayer player = itemCrafter.owner;
            if (!player || player is NPCPlayer) 
                return;

            if (item.info.category == ItemCategory.Attire && configData.ChallengeSettings[Challenges.ClothesCrafted].Enabled)
                AddPoints(player, Challenges.ClothesCrafted, 1);
            if (item.info.category == ItemCategory.Weapon && configData.ChallengeSettings[Challenges.WeaponsCrafted].Enabled)
                AddPoints(player, Challenges.WeaponsCrafted, 1);
        }

        private void OnGrowableGather(GrowableEntity growable, Item item, BasePlayer player)
        {
            if (player == null || player is NPCPlayer)
                return;

            AddPoints(player, Challenges.PlantsGathered, 1);
        }

        private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
        {
            if (collectible == null)
                return;

            if (player == null || player is NPCPlayer)
                return;

            foreach (ItemAmount itemAmount in collectible.itemList)
            {
                if (plantShortnames.Contains(itemAmount?.itemDef?.shortname))
                    AddPoints(player, Challenges.PlantsGathered, 1);
            }
        }

        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();

            if (player == null || player is NPCPlayer || dispenser == null)
                return;

            if (dispenser.gatherType == ResourceDispenser.GatherType.Tree && configData.ChallengeSettings[Challenges.WoodGathered].Enabled)
                AddPoints(player, Challenges.WoodGathered, item.amount);

            if (dispenser.gatherType == ResourceDispenser.GatherType.Ore && configData.ChallengeSettings[Challenges.RocksGathered].Enabled)
                AddPoints(player, Challenges.RocksGathered, item.amount);
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            BasePlayer player = plan?.GetOwnerPlayer();
            if (player == null || player is NPCPlayer)
                return;

            BaseEntity entity = go.ToBaseEntity();
            if (entity == null)
                return;

            if ((entity is BuildingBlock) || (entity is SimpleBuildingBlock))
                AddPoints(player, Challenges.StructuresBuilt, 1);
        }

        private void CanBeWounded(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || player is NPCPlayer || hitInfo == null) return;

            BasePlayer attacker = hitInfo.InitiatorPlayer;
            if (attacker != null)
            {
                if (attacker == player || IsPlaying(attacker) || IsFriend(attacker.userID, player.userID) || IsClanmate(attacker.userID, player.userID))
                    return;

                woundedData[player.userID] = new WoundedData {distance = Vector3.Distance(player.transform.position, attacker.transform.position), attackerId = attacker.userID };
            }
        }

        private void OnPlayerRecover(BasePlayer player)
        {
            if (player == null || player is NPCPlayer)
                return;

            if (woundedData.ContainsKey(player.userID))
                woundedData.Remove(player.userID);
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null)
                return;

            if (entity is PatrolHelicopter || entity is BradleyAPC)
            {
                BasePlayer attacker = info.InitiatorPlayer;
                if (attacker == null)
                    return;

                Hash<ulong, float> entityAttackers;
                if (!damageData.TryGetValue(entity.net.ID.Value, out entityAttackers))
                    entityAttackers = damageData[entity.net.ID.Value] = new Hash<ulong, float>();

                entityAttackers[attacker.userID] += info.damageTypes.Total();
            }
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null)
                return;

            BasePlayer attacker = info.InitiatorPlayer;
            if (attacker != null)
            {
                if (!attacker.IsNpc && attacker.userID.IsSteamId())
                    CheckEntry(attacker);
            }

            if (entity is BasePlayer)
            {
                BasePlayer victim = entity.ToPlayer();

                if (attacker == null || attacker is NPCPlayer || victim == null)
                    return;

                if (attacker == victim || IsPlaying(attacker) || IsFriend(attacker.userID, victim.userID) || IsClanmate(attacker.userID, victim.userID) || (configData.Options.IgnoreSleepers && victim.IsSleeping()))
                    return;

                if (info.isHeadshot && configData.ChallengeSettings[Challenges.Headshots].Enabled && !attacker.IsNpc)
                    AddPoints(attacker, Challenges.Headshots, 1);

                string weapon = info?.Weapon?.GetItem()?.info?.shortname;
                if (!string.IsNullOrEmpty(weapon) && !attacker.IsNpc)
                {
                    if (victim.IsNpc && configData.Options.NPCKillSeperate)
                    {
                        if (configData.ChallengeSettings[Challenges.NPCKills].Enabled)
                            AddPoints(attacker, Challenges.NPCKills, 1);
                    }
                    else
                    {
                        if (bladeShortnames.Contains(weapon) && configData.ChallengeSettings[Challenges.BladeKills].Enabled)
                            AddPoints(attacker, Challenges.BladeKills, 1);
                        else if (meleeShortnames.Contains(weapon) && configData.ChallengeSettings[Challenges.MeleeKills].Enabled)
                            AddPoints(attacker, Challenges.MeleeKills, 1);
                        else if ((weapon == "bow.hunting" || weapon == "bow.compound") && configData.ChallengeSettings[Challenges.ArrowKills].Enabled)
                            AddPoints(attacker, Challenges.ArrowKills, 1);
                        else if (weapon == "pistol.revolver" && configData.ChallengeSettings[Challenges.RevolverKills].Enabled)
                            AddPoints(attacker, Challenges.RevolverKills, 1);
                        else if (configData.ChallengeSettings[Challenges.PlayersKilled].Enabled)
                            AddPoints(attacker, Challenges.PlayersKilled, 1);
                    }

                    float distance = Vector3.Distance(attacker.transform.position, entity.transform.position);

                    WoundedData woundData;
                    if (woundedData.TryGetValue(victim.userID, out woundData))
                    {
                        if (attacker.userID == woundData.attackerId)
                            distance = woundData.distance;
                        woundedData.Remove(victim.userID);
                    }

                    if (!attacker.IsNpc)
                        AddDistance(attacker, victim.IsNpc && configData.Options.NPCPVEKills ? Challenges.PVEKillDistance : Challenges.PVPKillDistance, (int)distance);
                }
            }
            else if (entity.GetComponent<BaseNpc>() != null)
            {
                if (attacker == null || attacker.IsNpc)
                    return;

                float distance = Vector3.Distance(attacker.transform.position, entity.transform.position);
                AddDistance(attacker, Challenges.PVEKillDistance, (int)distance);
                AddPoints(attacker, Challenges.AnimalKills, 1);
            }
            else
            {
                Hash<ulong, float> entityAttackers;
                if (damageData.TryGetValue(entity.net.ID.Value, out entityAttackers))
                {
                    ulong mostDamage = entityAttackers.OrderByDescending(x => x.Value)?.First().Key ?? 0U;
                    if (mostDamage != 0U)
                        AddPoints(mostDamage, entity is PatrolHelicopter ? Challenges.HelicopterKills : Challenges.APCKills, 1);
                    damageData.Remove(entity.net.ID.Value);
                }
            }
        }

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity == null)
                return;

            if (entity.ShortPrefabName == "survey_charge.deployed" && configData.Options.IgnoreSurveyCharges)
                return;

            if (entity.ShortPrefabName == "flare.deployed" && configData.Options.IgnoreFlares)
                return;

            if (entity.ShortPrefabName == "grenade.supplysignal.deployed" && configData.Options.IgnoreSupplySignals)
                return;

            if (entity.ShortPrefabName == "grenade.beancan.deployed" && configData.Options.IgnoreBeanCans)
                return;

            AddPoints(player, Challenges.ExplosivesThrown, 1);
        }

        private void OnStructureRepair(BaseCombatEntity block, BasePlayer player)
        {
            if (player == null)
                return;

            if (block.health < block.MaxHealth())
                AddPoints(player, Challenges.StructuresRepaired, 1);
        }
        #endregion

        #region Hooks
        [HookMethod("CompletedQuest")]
        public void CompletedQuest(BasePlayer player)
        {
            CheckEntry(player);
            AddPoints(player, Challenges.QuestsCompleted, 1);
        }
        #endregion

        #region Functions
        private void AddPoints(BasePlayer player, Challenges type, int amount)
        {
            if ((configData.Options.IgnoreAdmins && player.IsAdmin) || player.IsNpc || !player.userID.IsSteamId())
                return;

            CheckEntry(player);
            statCache[player.userID].Stats[type] += amount;
            CheckForUpdate(player.userID, type);
        }

        private void AddPoints(ulong playerId, Challenges type, int amount)
        {
            if (configData.Options.IgnoreAdmins)
            {
                if (ServerUsers.Get(playerId)?.group == ServerUsers.UserGroup.Moderator || ServerUsers.Get(playerId)?.group == ServerUsers.UserGroup.Owner)
                    return;
            }

            if (!playerId.IsSteamId())
                return;

            CheckEntry(playerId);
            statCache[playerId].Stats[type] += amount;
            CheckForUpdate(playerId, type);
        }

        private void AddDistance(BasePlayer player, Challenges type, int amount)
        {
            if ((configData.Options.IgnoreAdmins && player.IsAdmin) || player.IsNpc || !player.userID.IsSteamId()) 
                return;
            
            CheckEntry(player);
            if (statCache[player.userID].Stats[type] < amount)
                statCache[player.userID].Stats[type] = amount;
            CheckForUpdate(player.userID, type);
        }

        private void CheckForUpdate(ulong playerId, Challenges type)
        {
            if (titleCache[type].UserID == playerId)
            {
                titleCache[type].Count = statCache[playerId].Stats[type];
                return;
            }

            if (!configData.Options.UseUpdateTimer)
            {
                if (statCache[playerId].Stats[type] > titleCache[type].Count)
                {
                    SwitchLeader(playerId, titleCache[type].UserID, type);
                }
            }
        }

        private void SwitchLeader(ulong newId, ulong oldId, Challenges type)
        {
            string name = GetGroupName(type);

            if (configData.Options.UseOxideGroups)
            {
                if (oldId != 0UL && permission.GroupExists(name))
                    RemoveUserFromGroup(name, oldId.ToString());

                if (newId != 0UL && permission.GroupExists(name))
                    AddUserToGroup(name, newId.ToString());
            }

            titleCache[type] = new LeaderData
            {
                Count = statCache[newId].Stats[type],
                DisplayName = statCache[newId].DisplayName,
                UserID = newId
            };

            if (configData.Options.AnnounceNewLeaders)
            {
                string message = MSG("newLeader")
                    .Replace("{playername}", $"<color={configData.Colors.TextColor1}>{statCache[newId].DisplayName}</color><color={configData.Colors.TextColor2}>")
                    .Replace("{ctype}", $"</color><color={configData.Colors.TextColor1}>{MSG(type.ToString())}</color>");
                PrintToChat(message);
            }
        }

        private void CheckUpdateTimer()
        {
            if ((GrabCurrentTime() - chData.LastUpdate) > configData.Options.UpdateTimer)
            {
                Dictionary<Challenges, UpdateInfo> updates = new Dictionary<Challenges, UpdateInfo>();

                foreach (Challenges type in Enum.GetValues(typeof(Challenges)))
                {
                    bool hasChanged = false;
                    UpdateInfo info = new UpdateInfo
                    {
                        newId = titleCache[(Challenges)type].UserID,
                        oldId = titleCache[(Challenges)type].UserID,
                        count = titleCache[(Challenges)type].Count
                    };

                    foreach (KeyValuePair<ulong, StatData> player in statCache)
                    {
                        if (info.oldId == player.Key)
                            continue;

                        if (player.Value.Stats[(Challenges)type] > info.count)
                        {
                            hasChanged = true;
                            info.newId = player.Key;
                            info.count = player.Value.Stats[(Challenges)type];
                        }
                    }

                    if (hasChanged)
                        SwitchLeader(info.newId, info.oldId, (Challenges)type);
                }
            }
            else
            {
                double timeRemaining = ((configData.Options.UpdateTimer - (GrabCurrentTime() - chData.LastUpdate)) * 60) * 60;
                timer.Once((int)timeRemaining + 10, () => CheckUpdateTimer());
            }
        }

        class UpdateInfo
        {
            public ulong newId;
            public ulong oldId;
            public int count;
        }
        #endregion

        #region Chat Commands
        [ChatCommand("pc")]
        private void cmdPC(BasePlayer player, string command, string[] args)
        {
            if (!UIDisabled)
                CreateMenu(player);
            else SendReply(player, MSG("UIDisabled", player.UserIDString));
        }

        [ChatCommand("pc_wipe")]
        private void cmdPCWipe(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            RemoveAllUsergroups();
            titleCache = new Dictionary<Challenges, LeaderData>();
            statCache = new Dictionary<ulong, StatData>();
            CheckValidData();
            SendReply(player, MSG("dataWipe", player.UserIDString));
            SaveData();
        }

        [ConsoleCommand("pc_wipe")]
        private void ccmdPCWipe(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            RemoveAllUsergroups();
            titleCache = new Dictionary<Challenges, LeaderData>();
            statCache = new Dictionary<ulong, StatData>();
            CheckValidData();
            SendReply(arg, MSG("dataWipe"));
            SaveData();
        }
        #endregion

        #region Helper Methods
        private void CheckEntry(BasePlayer player)
        {
            if (!statCache.ContainsKey(player.userID))
            {
                statCache.Add(player.userID, new StatData
                {
                    DisplayName = player.displayName,
                    Stats = new Dictionary<Challenges, int>()
                });

                foreach (Challenges type in Enum.GetValues(typeof(Challenges)))
                    statCache[player.userID].Stats.Add((Challenges)type, 0);
            }
        }

        private void CheckEntry(ulong playerId)
        {
            if (!statCache.ContainsKey(playerId))
            {
                statCache.Add(playerId, new StatData
                {
                    DisplayName = covalence.Players.FindPlayerById(playerId.ToString())?.Name ?? "NoName",
                    Stats = new Dictionary<Challenges, int>()
                });
                foreach (Challenges type in Enum.GetValues(typeof(Challenges)))
                    statCache[playerId].Stats.Add((Challenges)type, 0);
            }
        }

        private string GetGroupName(Challenges type) => configData.ChallengeSettings[type].Title;

        private double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).Hours;
        #endregion

        #region Titles and Groups
        private void RegisterGroups()
        {
            if (!configData.Options.UseOxideGroups) return;
            foreach (Challenges type in Enum.GetValues(typeof(Challenges)))
                RegisterGroup((Challenges)type);
        }

        private void RegisterGroup(Challenges type)
        {
            string name = GetGroupName(type);
            if (!permission.GroupExists(name))
            {
                permission.CreateGroup(name, string.Empty, 0);
            }
        }

        private void RegisterTitles()
        {
            if (!configData.Options.UseBetterChat || !BetterChat || !BetterChat.IsLoaded)
                return;
            BetterChat?.Call("API_RegisterThirdPartyTitle", new object[] { this, new Func<IPlayer, string>(GetPlayerTitles) });
        }

        private string GetPlayerTitles(IPlayer player)
        {
            if (!configData.Options.UseBetterChat) return string.Empty;
            string playerTitle = string.Empty;
            int count = 0;
            IEnumerable<KeyValuePair<Challenges, LeaderData>> titles = titleCache.OrderByDescending(x => configData.ChallengeSettings[x.Key].Priority).Reverse();
            foreach (KeyValuePair<Challenges, LeaderData> title in titles)
            {
                if (!configData.ChallengeSettings[title.Key].Enabled || title.Value.UserID == 0U) continue;
                if (title.Value.UserID.ToString() == player.Id)
                {
                    playerTitle += $"{(count > 0 ? " " : "")}{configData.Options.TagFormat.Replace("{TAG}", GetGroupName(title.Key))}";
                    count++;
                    if (count >= configData.Options.MaximumTags)
                        break;
                }
            }
            return count == 0 ? string.Empty : $"[{configData.Colors.TitleColor}]{playerTitle}[/#]";
        }

        private void AddAllUsergroups()
        {
            if (configData.Options.UseOxideGroups)
            {
                foreach (KeyValuePair<Challenges, LeaderData> type in titleCache)
                {
                    string name = GetGroupName(type.Key);
                    if (titleCache[type.Key].UserID == 0 || !GroupExists(name)) continue;
                    if (!UserInGroup(name, titleCache[type.Key].UserID.ToString()))
                        AddUserToGroup(name, titleCache[type.Key].UserID.ToString());
                }
            }
        }

        private void RemoveAllUsergroups()
        {
            if (configData.Options.UseOxideGroups)
            {
                foreach (KeyValuePair<Challenges, LeaderData> type in titleCache)
                {
                    string name = GetGroupName(type.Key);
                    if (titleCache[type.Key].UserID == 0 || !GroupExists(name)) continue;
                    if (UserInGroup(name, titleCache[type.Key].UserID.ToString()))
                        RemoveUserFromGroup(name, titleCache[type.Key].UserID.ToString());
                }
            }
        }

        private bool GroupExists(string name) => permission.GroupExists(name);
        private bool UserInGroup(string name, string playerId) => permission.UserHasGroup(playerId, name);
        private void AddUserToGroup(string name, string playerId) => permission.AddUserGroup(playerId, name);
        private void RemoveUserFromGroup(string name, string playerId) => permission.RemoveUserGroup(playerId, name);
        #endregion

        #region Config
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Challenge Settings")]
            public Dictionary<Challenges, ChallengeInfo> ChallengeSettings { get; set; }
            public Option Options { get; set; }
            public TextColor Colors { get; set; }

            public class ChallengeInfo
            {
                [JsonProperty(PropertyName = "Title for name tag")]
                public string Title;
                [JsonProperty(PropertyName = "Enable this challenge")]
                public bool Enabled;
                [JsonProperty(PropertyName = "Position in the UI leaderboard")]
                public int UIPosition;
                [JsonProperty(PropertyName = "Title priority")]
                public int Priority;
            }
            public class Option
            {
                [JsonProperty(PropertyName = "Ignore kills against sleeping players (Players killed)")]
                public bool IgnoreSleepers;
                [JsonProperty(PropertyName = "Kills against NPC players are counted seperate to player kills")]
                public bool NPCKillSeperate;
                [JsonProperty(PropertyName = "NPC kill distance counts as PVE distance")]
                public bool NPCPVEKills;
                [JsonProperty(PropertyName = "Show challenge leader title tags (Requires BetterChat)")]
                public bool UseBetterChat;
                [JsonProperty(PropertyName = "Ignore all statistics recorded by admins")]
                public bool IgnoreAdmins;
                [JsonProperty(PropertyName = "Ignore kills for event players (Players killed)")]
                public bool IgnoreEventKills;
                [JsonProperty(PropertyName = "Ignore supply signals thrown (Explosives thrown)")]
                public bool IgnoreSupplySignals;
                [JsonProperty(PropertyName = "Ignore survey charges thrown (Explosives thrown)")]
                public bool IgnoreSurveyCharges;
                [JsonProperty(PropertyName = "Ignore beancan grenades thrown (Explosives thrown)")]
                public bool IgnoreBeanCans;
                [JsonProperty(PropertyName = "Ignore flares thrown (Explosives thrown)")]
                public bool IgnoreFlares;
                [JsonProperty(PropertyName = "Broadcast new challenge leaders to chat")]
                public bool AnnounceNewLeaders;
                [JsonProperty(PropertyName = "Update leaders on a timer (Recommended)")]
                public bool UseUpdateTimer;
                [JsonProperty(PropertyName = "Create and use Oxide groups for each challenge type")]
                public bool UseOxideGroups;
                [JsonProperty(PropertyName = "Update timer (hours)")]
                public int UpdateTimer;
                [JsonProperty(PropertyName = "Maximum tags to display (Requires BetterChat)")]
                public int MaximumTags;
                [JsonProperty(PropertyName = "Format of tags displayed (Requires BetterChat)")]
                public string TagFormat;
            }
            public class TextColor
            {
                [JsonProperty(PropertyName = "Primary message color (hex)")]
                public string TextColor1;
                [JsonProperty(PropertyName = "Secondary message color (hex)")]
                public string TextColor2;
                [JsonProperty(PropertyName = "Title color (hex) (Requires BetterChat)")]
                public string TitleColor;

                [JsonProperty(PropertyName = "UI Color - Background")]
                public UIColor Background;
                [JsonProperty(PropertyName = "UI Color - Panel")]
                public UIColor Panel;
                [JsonProperty(PropertyName = "UI Color - Button")]
                public UIColor Button;

                public class UIColor
                {
                    [JsonProperty(PropertyName = "Color (hex)")]
                    public string Color;
                    [JsonProperty(PropertyName = "Alpha (0.0 - 1.0)")]
                    public float Alpha;
                }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();
            if (configData == null)
            {
                LoadDefaultConfig();
                PrintWarning("Config was not readable! Using default values...");
            }

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ChallengeSettings = new Dictionary<Challenges, ConfigData.ChallengeInfo>
                {
                    {
                        Challenges.AnimalKills, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Hunter",
                            UIPosition = 0,
                            Priority = 5
                        }
                    },
                    {
                        Challenges.ArrowKills, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Archer",
                            UIPosition = 1,
                            Priority = 11
                        }
                    },
                    {
                        Challenges.StructuresBuilt, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Architect",
                            UIPosition = 2,
                            Priority = 12
                        }
                    },
                    {
                        Challenges.ClothesCrafted, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Tailor",
                            UIPosition = 3,
                            Priority = 19
                        }
                    },
                    {
                        Challenges.ExplosivesThrown, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Bomb-tech",
                            UIPosition = 4,
                            Priority = 10
                        }
                    },
                    {
                        Challenges.Headshots, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Assassin",
                            UIPosition = 5,
                            Priority = 1
                        }
                    },
                    {
                        Challenges.PlayersHealed, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Medic",
                            UIPosition = 6,
                            Priority = 18
                        }
                    },
                    {
                        Challenges.PlayersKilled, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Murderer",
                            UIPosition = 7,
                            Priority = 2
                        }
                    },
                    {
                        Challenges.MeleeKills, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Fighter",
                            UIPosition = 8,
                            Priority = 3
                        }
                    },
                    {
                        Challenges.PlantsGathered, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Harvester",
                            UIPosition = 9,
                            Priority = 17
                        }
                    },
                    {
                        Challenges.PVEKillDistance, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Deadshot",
                            UIPosition = 10,
                            Priority = 6
                        }
                    },
                    {
                        Challenges.PVPKillDistance, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Sniper",
                            UIPosition = 11,
                            Priority = 4
                        }
                    },
                    {
                        Challenges.StructuresRepaired, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Handyman",
                            UIPosition = 12,
                            Priority = 13
                        }
                    },
                    {
                        Challenges.RevolverKills, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Gunslinger",
                            UIPosition = 13,
                            Priority = 7
                        }
                    },
                    {
                        Challenges.RocketsFired, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Rocketeer",
                            UIPosition = 14,
                            Priority = 8
                        }
                    },
                    {
                        Challenges.RocksGathered, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Miner",
                            UIPosition = 15,
                            Priority = 16
                        }
                    },
                    {
                        Challenges.BladeKills, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "BladeKillsman",
                            UIPosition = 16,
                            Priority = 9
                        }
                    },
                    {
                        Challenges.WeaponsCrafted, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Gunsmith",
                            UIPosition = 17,
                            Priority = 14
                        }
                    },
                    {
                        Challenges.WoodGathered, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Lumberjack",
                            UIPosition = 18,
                            Priority = 15
                        }
                    },
                    {
                        Challenges.HelicopterKills, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "HeliHunter",
                            UIPosition = 19,
                            Priority = 20
                        }
                    },
                    {
                        Challenges.APCKills, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "TankHunter",
                            UIPosition = 20,
                            Priority = 21
                        }
                    },
                    {
                        Challenges.NPCKills, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "BotHunter",
                            UIPosition = 21,
                            Priority = 22
                        }
                    },
                    {
                        Challenges.QuestsCompleted, new ConfigData.ChallengeInfo
                        {
                            Enabled = true,
                            Title = "Adventurer",
                            UIPosition = 22,
                            Priority = 23
                        }
                    }
                },

                Options = new ConfigData.Option
                {
                    AnnounceNewLeaders = false,
                    IgnoreAdmins = true,
                    IgnoreSleepers = true,
                    IgnoreSupplySignals = false,
                    NPCKillSeperate = true,
                    NPCPVEKills = true,
                    IgnoreSurveyCharges = false,
                    IgnoreFlares = true,
                    IgnoreEventKills = true,
                    MaximumTags = 2,
                    TagFormat = "[{TAG}]",
                    UseBetterChat = true,
                    UseOxideGroups = false,
                    UseUpdateTimer = false,
                    UpdateTimer = 168
                },
                Colors = new ConfigData.TextColor
                {
                    TextColor1 = "#ce422b",
                    TextColor2 = "#939393",
                    TitleColor = "#ce422b",
                    Background = new ConfigData.TextColor.UIColor
                    {
                        Alpha = 0.98f,
                        Color = "#2b2b2b"
                    },
                    Panel = new ConfigData.TextColor.UIColor
                    {
                        Alpha = 1f,
                        Color = "#404141"
                    },
                    Button = new ConfigData.TextColor.UIColor
                    {
                        Alpha = 1f,
                        Color = "#393939"
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();
            if (configData.Version < new VersionNumber(2, 0, 30))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(2, 0, 41))
            {
                configData.Options.IgnoreFlares = true;
                configData.Options.NPCKillSeperate = true;
                configData.Options.NPCPVEKills = true;
                if (!configData.ChallengeSettings.ContainsKey(Challenges.APCKills))
                    configData.ChallengeSettings.Add(Challenges.APCKills, baseConfig.ChallengeSettings[Challenges.APCKills]);
                if (!configData.ChallengeSettings.ContainsKey(Challenges.HelicopterKills))
                    configData.ChallengeSettings.Add(Challenges.HelicopterKills, baseConfig.ChallengeSettings[Challenges.HelicopterKills]);
                if (!configData.ChallengeSettings.ContainsKey(Challenges.NPCKills))
                    configData.ChallengeSettings.Add(Challenges.NPCKills, baseConfig.ChallengeSettings[Challenges.NPCKills]);
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Data Management
        private void SaveData()
        {
            chData.Stats = statCache;
            chData.Titles = titleCache;
            data.WriteObject(chData);
        }

        private void LoadData()
        {
            try
            {
                chData = data.ReadObject<ChallengeData>();
                statCache = chData.Stats;
                titleCache = chData.Titles;
            }
            catch
            {
                chData = new ChallengeData();
            }
        }

        private void CheckValidData()
        {
            if (titleCache.Count < Enum.GetValues(typeof(Challenges)).Length)
            {
                foreach (var type in Enum.GetValues(typeof(Challenges)))
                {
                    if (!titleCache.ContainsKey((Challenges)type))
                        titleCache.Add((Challenges)type, new LeaderData());
                }
            }
            for (int i = statCache.Count - 1; i >= 0; i--)
            {
                var player = statCache.ElementAt(i);
                if (!player.Key.IsSteamId())
                {
                    statCache.Remove(player.Key);
                    continue;
                }

                foreach (var type in Enum.GetValues(typeof(Challenges)))
                {
                    if (!player.Value.Stats.ContainsKey((Challenges)type))
                        player.Value.Stats.Add((Challenges)type, 0);
                }
            }
        }

        private class ChallengeData
        {
            public Dictionary<ulong, StatData> Stats = new Dictionary<ulong, StatData>();
            public Dictionary<Challenges, LeaderData> Titles = new Dictionary<Challenges, LeaderData>();
            public double LastUpdate = 0;
        }

        private class StatData
        {
            public string DisplayName = string.Empty;
            public Dictionary<Challenges, int> Stats = new Dictionary<Challenges, int>();
        }

        private class LeaderData
        {
            public ulong UserID = 0U;
            public string DisplayName = null;
            public int Count = 0;
        }

        private class WoundedData
        {
            public float distance;
            public ulong attackerId;
        }

        enum Challenges
        {
            AnimalKills, ArrowKills, ClothesCrafted, Headshots, PlantsGathered, PlayersHealed, PlayersKilled, MeleeKills, RevolverKills, RocketsFired, RocksGathered, BladeKills, StructuresBuilt, StructuresRepaired, ExplosivesThrown, WeaponsCrafted, WoodGathered, QuestsCompleted, PVPKillDistance, PVEKillDistance, HelicopterKills, APCKills, NPCKills
        }

        #endregion

        #region Lists
        List<string> meleeShortnames = new List<string> { "bone.club", "hammer.salvaged", "hatchet", "icepick.salvaged", "knife.bone", "mace", "machete", "pickaxe", "rock", "stone.pickaxe", "stonehatchet", "torch" };
        List<string> bladeShortnames = new List<string> { "salvaged.sword", "salvaged.cleaver", "longsword", "axe.salvaged" };
        List<string> plantShortnames = new List<string> { "pumpkin", "cloth", "corn", "mushroom", "seed.hemp", "seed.corn", "seed.pumpkin" };
        #endregion

        #region Messaging
        private string MSG(string key, string id = null) => lang.GetMessage(key, this, id);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"newLeader", "{playername} has topped the leader board for most {ctype}" },
            {"AnimalKills", "animal kills" },
            {"ArrowKills", "kills with arrows" },
            {"ClothesCrafted", "clothes crafted" },
            {"Headshots", "headshots" },
            {"PlantsGathered", "plants gathered" },
            {"PlayersHealed", "players healed" },
            {"PlayersKilled", "players killed" },
            {"MeleeKills", "melee kills" },
            {"RevolverKills", "revolver kills" },
            {"RocketsFired", "rockets fired" },
            {"RocksGathered", "ore gathered" },
            {"BladeKills", "blade kills" },
            {"StructuresBuilt", "structures built" },
            {"StructuresRepaired", "structures repaired" },
            {"ExplosivesThrown", "explosives thrown" },
            {"WeaponsCrafted", "weapons crafted" },
            {"WoodGathered", "wood gathered" },
            {"PVEKillDistance", "longest PVE kill"},
            {"PVPKillDistance", "longest PVP kill" },
            {"QuestsCompleted", "quests completed" },
            {"UITitle", "Player Challenges   v{Version}" },
            {"UIDisabled", "The UI has been disabled as there is a error in the config. Please contact a admin" },
            {"dataWipe", "You have wiped all player stats and titles" }
        };
        #endregion
    }
}


// --- End of file: PlayerChallenges.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pound-bot-clans ---
// --- Original File Path: P/PoundBotClans/PoundBotClans.cs ---

// Requires: PoundBot
// Requires: Clans

using System.Collections.Generic;
using System;
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
  [Info("Pound Bot Clans", "MrPoundsign", "2.0.1")]
  [Description("Clans support for PoundBot")]

  class PoundBotClans : CovalencePlugin
  {
    [PluginReference]
    private Plugin PoundBot, Clans;

    #region Oxide Hooks
    protected override void LoadDefaultMessages()
    {
      lang.RegisterMessages(new Dictionary<string, string>
      {
        ["sending_clans"] = "Sending all clans to PoundBot",
        ["sending_clans_tag"] = " + [{0}]",
        ["sending_clan"] = "Sending clan {0} to PoundBot",
        ["sending_clan_delete"] = "Sending clan delete for {0} to PoundBot",
      }, this);
    }
    #endregion

    void OnServerInitialized()
    {
      SendClans();
    }

    private bool AcceptedHandler(int code, string response) => (code == 200);

    void SendClans()
    {
      Puts(lang.GetMessage("sending_clans", this));

      var clan_tags = (JArray)Clans.Call("GetAllClans");
      List<JObject> clans = new List<JObject>();
      foreach (string ctag in clan_tags)
      {
        Puts(string.Format(lang.GetMessage("sending_clans_tag", this), ctag));
        clans.Add((JObject)Clans.Call("GetClan", ctag));
      }

      Func<int, string, bool> callback = AcceptedHandler;

      PoundBot.Call("API_SendClans", new object[] { this, clans, callback });
    }

    #region Clans Hooks
    void OnClanCreate(string tag)
    {
      timer.Once(1f, () =>
      {
        SendClans();
        //var clan = (JObject)Clans.Call("GetClan", tag);

        //Puts(string.Format(lang.GetMessage("sending_clan", this), tag));

        //Func<int, string, bool> callback = AcceptedHandler;

        //PoundBot.Call("API_SendClan", new object[] { this, tag, clan, callback });
      });
    }

    void OnClanUpdate(string tag) => OnClanCreate(tag);

    void OnClanDestroy(string tag)
    {
      Func<int, string, bool> callback = AcceptedHandler;

      Puts(string.Format(lang.GetMessage("sending_clan_delete", this), tag));

      PoundBot.Call("API_DeleteClan", new object[] { this, tag, callback });
    }
    #endregion

    // Re-send all clans if PoundBot reconnects
    void OnPoundBotConnected() => SendClans();
  }
}

// --- End of file: PoundBotClans.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/perms-ui ---
// --- Original File Path: P/PermsUI/PermsUI.cs ---

﻿using UnityEngine;
using System.Collections.Generic;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("Perms UI", "Camoec", 1.3)]
    [Description("GUI for managing plugin permissions in-game")]

    public class PermsUI : RustPlugin
    {
        private const string UsePerm = "PermsUI.use";
        private void Init()
        {
            permission.RegisterPermission(UsePerm, this);
        }

        private void MainUI(BasePlayer player, string userID, bool user, int page)
        {
            string Layer = "UI";
            BasePlayer target = user ? BasePlayer.FindByID(ulong.Parse(userID)) : null;
            var container = new CuiElementContainer();
            List<string> perms = new List<string>();
            foreach (var perm in permission.GetPermissions())
                if (!perm.StartsWith("oxide"))
                    perms.Add(perm);

            int pageLen = 11;

            CuiHelper.DestroyUi(player, Layer);
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1"},
                Image =
                {
                    Color = "0 0 0 0.5"
                },
                CursorEnabled = true                
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = "" },
                Button =
                    {
                        Color = "0 0 0 0",
                        Close = Layer
                    }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                    OffsetMin = "-310 -250",
                    OffsetMax = "310 250"
                },
                Image =
                {
                    Color = "0.1 0.1 0.1 0.99"
                }
            }, Layer, Layer + ".Main");

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0 1", AnchorMax = "1 1",
                    OffsetMin = "0 -50",
                    OffsetMax = "0 0"
                },
                Image = 
                {
                    Color =  "0.09 0.09 0.09 1"
                }
            }, Layer + ".Main", Layer + ".Header");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "1 1",
                    OffsetMin = "30 0",
                    OffsetMax = "0 0"
                },
                Text =
                {
                    Text = string.Format(Lang("Info", player.UserIDString), page+1, (int)(perms.Count / 10)+1, (user ? $"{target.displayName} [{target.UserIDString}]" : userID)),
                    Align = TextAnchor.MiddleLeft,
                    Font = "RobotoCondensed-Bold.ttf",
                    FontSize = 14,
                    Color = "1 1 1 1"
                }
            }, Layer + ".Header");

            var _y = -60f;
            float _x = -10;

            float width = 30;
            float margin = 2;

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = $"{_x - width} -37.5",
                    OffsetMax = $"{_x} -12.5"
                },
                Text =
                {
                    Text = ">",
                    Align = TextAnchor.MiddleCenter,
                    FontSize = 12,
                    Color = "1 1 1 1"
                },
                Button =
                {
                    Color =  "0.6 0.01 0.16 1",
                    Command = $"PERMS page {player.UserIDString} {userID} {user} {(page < (perms.Count / pageLen) ? page+1 : page)}"
                }
            }, Layer + ".Header");



            _x = _x - margin - width;

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = $"{_x - width} -37.5",
                    OffsetMax = $"{_x} -12.5"
                },
                Text =
                {
                    Text = "<",
                    Align = TextAnchor.MiddleCenter,
                    FontSize = 12,
                    Color = "1 1 1 1"
                },
                Button =
                {
                    Color =  "0.6 0.01 0.16 1",
                    Command = $"perms page {player.UserIDString} {userID} {user} {(page > 0 ? page-1 : 0)}"
                }
            }, Layer + ".Header");
            
            for (int i = page * pageLen ; i < perms.Count; i++)
            {
                if (i > page * pageLen + pageLen - 1)
                    break;
                var perm = perms[i];
                container.Add(new CuiPanel
                {
                    RectTransform =
                    {
                        AnchorMin = "0.5 1", AnchorMax = "0.5 1",
                        OffsetMin = $"-300 {_y - 30}",
                        OffsetMax = $"300 {_y}"
                    },
                    Image =
                    {
                        Color =  "0.09 0.09 0.09 1"
                    }
                }, Layer + ".Main", Layer + $".Perm.{_y}");

                container.Add(new CuiLabel
                {
                    RectTransform =
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1",
                        OffsetMin = "10 0", OffsetMax = "0 0"
                    },
                    Text =
                    {
                        Text = $"{perm}",
                        Align = TextAnchor.MiddleLeft,
                        FontSize = 14,
                        Color = "1 1 1 1"
                    }
                }, Layer + $".Perm.{_y}");

                string cmd = $"{(user ? permission.UserHasPermission(userID, perm) ? "Revoke" : "Grant" : permission.GroupHasPermission(userID, perm) ? "Revoke" : "Grant")}";

                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "1 0.5", AnchorMax = "1 0.5",
                        OffsetMin = "-120 -15", OffsetMax = "-0 15"
                    },
                    Text =
                    {
                        Text = cmd,
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 14,
                        Color = "1 1 1 1"
                    },
                    Button =
                    {
                        Color =  cmd == "Revoke" ? "0.6 0.01 0.16 1" : "0.1 0.6 0.1 1",
                        Command = $"perms {(user ? "USER" : "GROUP")} {cmd} {perm} {userID} {player.userID} {page}"
                    }
                }, Layer + $".Perm.{_y}");

                _y = _y - 30 - 10;
            }


            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("perms")]
        private void GivePerm(ConsoleSystem.Arg arg)
        {
            if (!arg.IsRcon && (arg.Player() != null && !permission.UserHasPermission(arg.Player().UserIDString, UsePerm)))
                return;

            if (arg == null || arg.Args.Length == 0)
                return;
            var args = arg.Args;

            string id = args[0].ToLower();
            string cmd = args[1].ToLower();

            if(id == "page")
            {
                MainUI(BasePlayer.FindByID(ulong.Parse(cmd)), args[2], bool.Parse(args[3]), int.Parse(args[4]));
                return;
            }

            string perm = args[2];
            string userid = args[3];
            string caller = args[4];
            int page = int.Parse(args[5]);

            if (id == "user")
            {
                if (cmd == "grant")
                {
                    permission.GrantUserPermission(userid, perm, null);
                }
                else if (cmd == "revoke")
                {
                    permission.RevokeUserPermission(userid, perm);
                }
                MainUI(BasePlayer.FindByID(ulong.Parse(caller)), userid, true, page);
            }else if(id == "group")
            {
                if (cmd == "grant")
                {
                    permission.GrantGroupPermission(userid, perm, null);
                }
                else if (cmd == "revoke")
                {
                    permission.RevokeGroupPermission(userid, perm);
                }
                MainUI(BasePlayer.FindByID(ulong.Parse(caller)), userid, false, page);
            }
            
        }


        [ChatCommand("perms")]
        private void permsCommand (BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, UsePerm))
            {
                PrintToChat(player, Lang("NoPermission", player.UserIDString));
                return;
            }

            if (args.Length > 1)
            {
                string cmd = args[0].ToLower();
                string id = args[1].ToLower();
                
                if (cmd == "user")
                {
                    BasePlayer target = BasePlayer.Find(id);
                    if(target == null)
                    {
                        PrintToChat(player, Lang("UserNF", player.UserIDString));
                        return;
                    }
                    MainUI(player, target.UserIDString, true, 0);
                    return;
                }

                if (cmd == "group")
                {
                    if(!permission.GroupExists(id))
                    {
                        PrintToChat(player, Lang("GroupNF", player.UserIDString));
                        return;
                    }
                    MainUI(player, id, false, 0);
                    return;
                }
                return;
            }

            PrintToChat(player, Lang("Syntax", player.UserIDString));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You don't have permission to use this",
                ["Syntax"] = "Use /perms [user|group] [id|name]",
                ["GroupNF"] = "Group not found",
                ["UserNF"] = "Player not found",
                ["Info"] = "[{0}/{1}] Permissions for {2}"
            }, this);
        }

        private string Lang(string key, string userid) => lang.GetMessage(key, this, userid);

    }
}

// --- End of file: PermsUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/performance-ui ---
// --- Original File Path: P/PerformanceUI/PerformanceUI.cs ---

// Requires: ImageLibrary

using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Oxide.Core.Plugins;
using System;

namespace Oxide.Plugins
{
    /* TODO:
     * Finish UI alignment [x]
     * Make configuration [x]
     * Optimize code (if it's possible) [meh...]
     * Improve UI to make it look beautiful [x]
     * Make UI work without ImageLibrary [---]
     */

    [Info("Performance UI", "2CHEVSKII", "1.0.7")]
    [Description("Shows information about server performance in a user-friendly way")]
    class PerformanceUI : RustPlugin
    {

        #region -Configuration-


        protected override void LoadDefaultConfig() { }

        private void LoadCFG()
        {
            CheckConfig("Use permissions", ref usePermissions);
            CheckConfigFloat("UI X position", ref UI_X);
            CheckConfigFloat("UI Y position", ref UI_Y);
            SaveConfig();
        }

        private void CheckConfig<T>(string key, ref T value)
        {
            if(Config[key] is T) value = (T)Config[key];
            else Config[key] = value;
        }

        private void CheckConfigFloat(string key, ref float value)
        {
            if(Config[key] is double || Config[key] is int) value = Convert.ToSingle(Config[key]);
            else Config[key] = value;
        }


        #endregion

        #region -Language-


        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Wrong command usage"] = "<color=yellow>Wrong command usage! Try \"/performance help\"!</color>",
                ["User has no permission"] = "<color=red>You are not allowed to use this command!</color>",
                ["Help command response"] = "Usage:\n/performance - Get a single text message with current server performance and Your ping\n/performance gui - Display a UI with live updated performance information",
                ["Performance report"] = "Current server performance:\nTickrate: {0}\nFramerate: {1}\nFrametime: {2}\nYour ping: {3}"
            }, this, "en");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Wrong command usage"] = "<color=yellow>Неверная команда! Попробуйте \"/performance help\"!</color>",
                ["User has no permission"] = "<color=red>У Вас недостаточно прав для использования данной команды!</color>",
                ["Help command response"] = "Использование:\n/performance - Получить сообщение о текущей производительнсти сервера и Вашем пинге\n/performance gui - Отобразить UI с информацией в реальном времени",
                ["Performance report"] = "Текущая производительность:\nТикрейт: {0}\nКадров в секунду: {1}\nВремя кадра: {2}\nВаш пинг: {3}"
            }, this, "ru");
        }


        #endregion

        #region -Variables-


        [PluginReference] private Plugin ImageLibrary; //needed for proper image display

        private Dictionary<BasePlayer, bool> guiUsersOpened, guiUsersCollapsed;

        private int nominalTickrate = ConVar.Server.tickrate; //to determine how much current tickrate differs from original set
        private int nominalFPS = ConVar.FPS.limit;//same but for fps
        private int tickrate, ticks = 0; //actual tickrate

        private bool isTimerRunning;
        private bool usePermissions = true;

        private const string permUse = "performanceui.use";
        private const string permUseGUI = "performanceui.usegui";

        private float UI_X = 0f;
        private float UI_Y = 0.83f;


        #endregion

        #region -Oxide hooks-


        private void OnTick() //counts actual tickrate
        {
            if(!isTimerRunning) //check if timer needs to be restarted and calculates tickrate
            {
                int starttick = ticks = 0;
                timer.Once(1f, () => { tickrate = ticks - starttick; isTimerRunning = false; });
                isTimerRunning = true;
            }
            if(ticks >= 101) //100 is the maximum available tickrate for rust servers (where are my 144Hz?)
                ticks = 0;
            ticks++;
        }

        private void Init()
        {
            LoadCFG();
            permission.RegisterPermission(permUse, this); //registers a permission for commands usage
            permission.RegisterPermission(permUseGUI, this); //permission for gui usage (since it's much more heavy than the chat command)
            //permission.GrantGroupPermission("default", permUse, this); //grants chat command to all
            IconSize();
        }

        private void OnServerInitialized()
        {
            guiUsersOpened = new Dictionary<BasePlayer, bool>();
            guiUsersCollapsed = new Dictionary<BasePlayer, bool>();
            guiUsersOpened.Clear(); guiUsersCollapsed.Clear();
            foreach(var player in BasePlayer.activePlayerList) //add all existing players to dictionaries
            {
                guiUsersOpened.Add(player, false);
                guiUsersCollapsed.Add(player, false);
            }
            DownloadIcons();
            timer.Every(1f, () => RefreshUI()); //value determines frequency of data refresh
        }

        private void Unload() //destroy ui for all the players to prevent duplication and errors
        {
            guiUsersOpened.Clear();
            guiUsersCollapsed.Clear();
            RefreshUI();
        }

        private void OnPlayerInit(BasePlayer player) //add new player to the ui userlist
        {
            if(player != null)
            {
                guiUsersOpened.Add(player, false);
                guiUsersCollapsed.Add(player, false);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason) //remove player from userlist
        {
            if(player != null)
            {
                guiUsersOpened.Remove(player);
                guiUsersCollapsed.Remove(player);
            }
        }


        #endregion

        #region -Commands-


        [ChatCommand("performance")]
        private void CmdChatPerformance(BasePlayer player, string command, string[] args) //all the chat functions are here
        {
            switch(args.Length)
            {
                case 0:
                    if(permission.UserHasPermission(player.UserIDString, permUse) || !usePermissions)
                    {
                        string subMsg = lang.GetMessage("Performance report", this, player.UserIDString);
                        string message = string.Format(subMsg, GetTickrate(), GetFPS(), GetFrametime(), GetUserPing(player));
                        SendReply(player, message);
                    }
                    else
                    {
                        SendReply(player, lang.GetMessage("User has no permission", this, player.UserIDString));
                    }
                    //WRONGCOMMANDUSAGE
                    break;
                case 1:
                    switch(args[0].ToLower())
                    {
                        case "gui": //OPEN OR CLOSE UI
                            if(permission.UserHasPermission(player.UserIDString, permUseGUI) || !usePermissions) OpenCloseUI(player);
                            else SendReply(player, lang.GetMessage("User has no permission", this, player.UserIDString));
                            break;
                        case "help": //SENDS HELP MESSAGE
                            SendReply(player, lang.GetMessage("Help command response", this, player.UserIDString));
                            break;
                        default:
                            SendReply(player, lang.GetMessage("Wrong command usage", this, player.UserIDString));
                            break;
                    }
                    break;
                default:
                    SendReply(player, lang.GetMessage("Wrong command usage", this, player.UserIDString));
                    break;
            }
        }

        [ConsoleCommand("performance.size")] //changes size of the UI
        private void CmdConsoleSize(ConsoleSystem.Arg argument)
        {
            BasePlayer player = argument?.Player();
            if(player != null) ExpandCollapseUI(player);
        }


        #endregion

        #region -Helper methods-


        private void OpenCloseUI(BasePlayer player) //does what it says
        {
            bool isOpened;
            guiUsersOpened.TryGetValue(player, out isOpened);
            if(!isOpened)
            {
                guiUsersOpened[player] = true;
                RefreshUI();
            }
            else
            {
                guiUsersOpened[player] = false;
                RefreshUI();
            }
        }

        private void ExpandCollapseUI(BasePlayer player)//invoked when player press a button
        {
            bool isCollapsed;
            guiUsersCollapsed.TryGetValue(player, out isCollapsed);
            if(isCollapsed)
            {
                guiUsersCollapsed[player] = false;
                RefreshUI();
            }
            else
            {
                guiUsersCollapsed[player] = true;
                RefreshUI();
            }
        }

        private void RefreshUI() //re-builds ui with current values if atleast oneplayer has it open
        {
            if(guiUsersOpened.ContainsValue(true))
            {
                BuildUI();
                BuildSmallUI();
                foreach(BasePlayer player in BasePlayer.activePlayerList)
                {
                    CuiHelper.DestroyUi(player, mainCanvas);
                    bool isActiveUI;
                    guiUsersOpened.TryGetValue(player, out isActiveUI);
                    if(isActiveUI)
                    {
                        bool isCollapsedUI;
                        guiUsersCollapsed.TryGetValue(player, out isCollapsedUI);
                        if(isCollapsedUI) CuiHelper.AddUi(player, collapsedContainer);
                        else CuiHelper.AddUi(player, expandedContainer);
                    }
                }
            }
            else
            {
                foreach(var player in BasePlayer.activePlayerList)
                {
                    CuiHelper.DestroyUi(player, mainCanvas);
                }
            }
        }

        private int GetFPS() => Performance.report.frameRate;

        private float GetFrametime() => Performance.report.frameTime;

        private int GetTickrate() => tickrate;

        private int GetUserPing(BasePlayer player) => Player.Ping(player.Connection);


        #endregion

        #region -UI-


        private CuiElementContainer expandedContainer = new CuiElementContainer(); // ui containers
        private CuiElementContainer collapsedContainer = new CuiElementContainer();

        #region [UI elements]


        private const string mainCanvas = "mainCanvas";
        private const string ecButton = "ecButton";
        private const string tickrateBG = "tickrateBG";
        private const string tickrateValue = "tickrateValue";
        private const string tickrateIcon = "tickrateIcon";
        private const string tickrateURL = "https://i.imgur.com/mnnficY.png";
        private string tickColor, frameColor;
        private string bigUIAMin;
        private string bigUIAMax;
        private string smallUIAMin;
        private string smallUIAMax;
        private const string fpsBG = "fpsFTBG";
        private const string fpsFTValue = "fpsFTValue";
        private const string fpsFTIcon = "fpsIcon";
        private const string fpsURL = "https://i.imgur.com/KmdsVvW.png";


        #endregion

        #region [Helpers]


        private void IconSize()
        {
            bigUIAMin = $"{UI_X.ToString()} {UI_Y.ToString()}";
            bigUIAMax = $"{(UI_X + 0.1f).ToString()} {(UI_Y + 0.17f).ToString()}";
            smallUIAMin = $"{UI_X.ToString()} {UI_Y.ToString()}";
            smallUIAMax = $"{(UI_X + 0.11f).ToString()} {(UI_Y + 0.17f).ToString()}";
        }

        private void DownloadIcons() //store images used in ui
        {
            ImageLibrary.Call("AddImage", tickrateURL, tickrateIcon);
            ImageLibrary.Call("AddImage", fpsURL, fpsFTIcon);
        }

        private void ColorSwitcher(ref string tickColor, ref string frameColor) //switch color of the ui icons based on current performance
        {
            int localFPS = GetFPS(); //local value to request fps only one time at a cycle instead of 3 
            if(tickrate < nominalTickrate / 2)
            {
                tickColor = "0.99 0.31 0.02 1";//RED
            }
            else if(tickrate < nominalTickrate / 1.5 && tickrate > nominalTickrate / 2)
            {
                tickColor = "1 0.84 0 1";//YELLOW
            }
            else
            {
                tickColor = "1 1 1 1";//DEFAULT
            }
            if(localFPS < nominalFPS / 2)
            {
                frameColor = "0.99 0.31 0.02 1";//RED
            }
            else if(localFPS < nominalFPS / 1.5 && localFPS > nominalFPS / 2)
            {
                frameColor = "1 0.84 0 1";//YELLOW
            }
            else
            {
                frameColor = "1 1 1 1";//DEFAULT
            }
        }


        #endregion

        private void BuildUI() //Builds full-sized (non-collapsed) UI
        {
            ColorSwitcher(ref tickColor, ref frameColor);
            expandedContainer.Clear(); //Clears existing elements to prevent duplication
            expandedContainer.Add(new CuiPanel //Add main canvas to place all the elements
            {
                Image = { Color = "0.4 0.4 0.4 0" },
                RectTransform = { AnchorMin = bigUIAMin, AnchorMax = bigUIAMax },
                CursorEnabled = false,
            }, "Hud", mainCanvas);
            expandedContainer.Add(new CuiElement //Add backgound for tickrate value and icon
            {
                Parent = mainCanvas,
                Name = tickrateBG,
                Components =
                {
                    new CuiRawImageComponent{ Color = "0 0 0 1", Material = "assets/content/ui/uibackgroundblur-notice.mat", Sprite = "assets/standard assets/effects/imageeffects/textures/noise.png"},
                    new CuiRectTransformComponent{ AnchorMin = "0 0.26", AnchorMax = "1 0.48"}
                }
            });
            expandedContainer.Add(new CuiElement //add tickrate icon with color applied
            {
                Parent = tickrateBG,
                Name = tickrateIcon,
                Components =
                {
                    new CuiRawImageComponent{ Color = tickColor, Sprite = "assets/content/textures/generic/fulltransparent.tga", Png = (string)ImageLibrary.Call("GetImage", tickrateIcon) ?? ""},
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "0.215 1"}
                }
            });
            expandedContainer.Add(new CuiLabel //Add tickrate value
            {
                Text = { Text = string.Format("Tickrate: {0}", GetTickrate().ToString()), Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0.25 0.1", AnchorMax = "1 0.8" }
            }, tickrateBG, tickrateValue);
            expandedContainer.Add(new CuiElement //Add backgound for server fps and frametime
            {
                Parent = mainCanvas,
                Name = fpsBG,
                Components =
                {
                    new CuiRawImageComponent{ Color = "0 0 0 1", Material = "assets/content/ui/uibackgroundblur-notice.mat", Sprite = "assets/standard assets/effects/imageeffects/textures/noise.png"},
                    new CuiRectTransformComponent{ AnchorMin = "0 0.52", AnchorMax = "1 0.74"}
                }
            });
            expandedContainer.Add(new CuiElement //add fps icon with color applied
            {
                Parent = fpsBG,
                Name = fpsFTIcon,
                Components =
                {
                    new CuiRawImageComponent{ Color = tickColor, Sprite = "assets/content/textures/generic/fulltransparent.tga", Png = (string)ImageLibrary.Call("GetImage", fpsFTIcon) ?? ""},
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "0.215 1"}
                }
            });
            expandedContainer.Add(new CuiLabel //Add server fps and frametime values
            {
                Text = { Text = string.Format("FPS: {0}", GetFPS().ToString()), Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0.25 0.1", AnchorMax = "1 0.8" }
            }, fpsBG, fpsFTValue);
            expandedContainer.Add(new CuiButton //Add button to change size of the UI
            {
                RectTransform = { AnchorMin = "0 0.78", AnchorMax = "1 1" },
                Button = { Command = "performance.size", Color = "0.8 0.2 0.2 1" },
                Text = { Text = "MINIMIZE", Align = TextAnchor.MiddleCenter, FontSize = 20 },
            }, mainCanvas, ecButton);
        }

        private void BuildSmallUI() //Builds minimized UI
        {
            ColorSwitcher(ref tickColor, ref frameColor);
            collapsedContainer.Clear(); //Clears 
            collapsedContainer.Add(new CuiPanel //Canvas
            {
                Image = { Color = "0.4 0.4 0.4 0" },
                RectTransform = { AnchorMin = smallUIAMin, AnchorMax = smallUIAMax},
                CursorEnabled = false,
            }, "Hud", mainCanvas);
            collapsedContainer.Add(new CuiElement //tickrate panel
            {
                Parent = mainCanvas,
                Name = tickrateBG,
                Components =
                {
                    new CuiRawImageComponent{ Color = "0 0 0 1", Material = "assets/content/ui/uibackgroundblur-notice.mat", Sprite = "assets/standard assets/effects/imageeffects/textures/noise.png"},
                    new CuiRectTransformComponent{ AnchorMin = "0 0.26", AnchorMax = "0.2 0.48"}
                }
            });
            collapsedContainer.Add(new CuiElement //add tickrate icon with color applied
            {
                Parent = tickrateBG,
                Name = tickrateIcon,
                Components =
                {
                    new CuiRawImageComponent{ Color = tickColor, Sprite = "assets/content/textures/generic/fulltransparent.tga", Png = (string)ImageLibrary.Call("GetImage", tickrateIcon) ?? ""},
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "0.95 1"}
                }
            });
            collapsedContainer.Add(new CuiElement //framerate/frametime panel
            {
                Parent = mainCanvas,
                Name = fpsBG,
                Components =
                {
                    new CuiRawImageComponent{ Color = "0 0 0 1", Material = "assets/content/ui/uibackgroundblur-notice.mat", Sprite = "assets/standard assets/effects/imageeffects/textures/noise.png"},
                    new CuiRectTransformComponent{ AnchorMin = "0 0.52", AnchorMax = "0.2 0.74"}
                }
            });
            collapsedContainer.Add(new CuiElement //add fps icon with color applied
            {
                Parent = fpsBG,
                Name = fpsFTIcon,
                Components =
                {
                    new CuiRawImageComponent{ Color = tickColor, Sprite = "assets/content/textures/generic/fulltransparent.tga", Png = (string)ImageLibrary.Call("GetImage", fpsFTIcon) ?? ""},
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "0.95 1"}
                }
            });
            collapsedContainer.Add(new CuiButton //button
            {
                RectTransform = { AnchorMin = "0 0.78", AnchorMax = "0.2 1" },
                Button = { Command = "performance.size", Color = "0.14 0.89 0.31 1" },
                Text = { Text = "+", Align = TextAnchor.MiddleCenter, FontSize = 20 },
            }, mainCanvas, ecButton);
            
        }


        #endregion

        //UI is WIP

    }
}

// --- End of file: PerformanceUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/push-api ---
// --- Original File Path: P/PushAPI/PushAPI.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("PushAPI", "Wulf/lukespragg", "1.0.1", ResourceId = 705)]
    [Description("API for sending messages via various mobile notification services")]

    class PushAPI : CovalencePlugin
    {
        #region Initialization

        Dictionary<string, string> pushbulletHeaders;

        const string pushalotUrl = "https://pushalot.com/api/sendmessage";
        const string pushbulletUrl = "https://api.pushbullet.com/v2/pushes";
        const string pushoverUrl = "https://api.pushover.net/1/messages.json";

        static string pushalotToken;
        static string pushbulletToken;
        static string pushoverAppKey;
        static string pushoverUserKey;
        static string serviceName;

        protected override void LoadDefaultConfig()
        {
            // Settings
            Config["Pushalot Auth Token (32 characters)"] = pushalotToken = GetConfig("Pushalot Auth Token (32 characters)", "");
            Config["Pushbullet Access Token (34 characters)"] = pushbulletToken = GetConfig("Pushbullet Access Token (34 characters)", "");
            Config["Pushover App Key (30 characters)"] = pushoverAppKey = GetConfig("Pushover App Key (30 characters)", "");
            Config["Pushover User Key (30 characters)"] = pushoverUserKey = GetConfig("Pushover User Key (30 characters)", "");
            Config["Service Name (Ex. pushover)"] = serviceName = GetConfig("Service Name (Ex. pushover)", "");

            SaveConfig();
        }

        void Init()
        {
            LoadDefaultConfig();
            //LoadDefaultMessages();

            pushbulletHeaders = new Dictionary<string, string> { ["Access-Token"] = pushbulletToken };
        }

        #endregion

        #region Push Message

        /// <summary>
        /// Sends a message to the configured service
        /// </summary>
        /// <param name="title"></param>
        /// <param name="message"></param>
        /// <param name="priority"></param>
        /// <param name="callback"></param>
        void PushMessage(string title, string message, string priority = "high", Action<bool> callback = null)
        {
            // TODO: Null and empty handling

            switch (serviceName.ToLower())
            {
                case "pushalot":
                    Pushalot(title, message, priority, callback);
                    break;
                case "pushbullet":
                    Pushbullet(title, message, callback);
                    break;
                case "pushover":
                    Pushover(title, message, priority, "gamelan", callback);
                    break;
                default:
                    PrintError("Configured push service is not valid");
                    break;
            }
        }

        #endregion

        #region Pushalot Service

        /// <summary>
        /// Required base message class for pushing to Pushalot
        /// https://pushalot.com/api#basics
        /// </summary>
        class PushalotMessage
        {
            //public string AuthenticationToken { get; set; } // App authorization token
            public string Title { get; set; } // Title of the notification message
            public string Body { get; set; } // Notification message body to be pushed
            //public string LinkTitle { get; set; } // Title for enclosed link, only used if Link is set
            //public string Link { get; set; } // Enclosed URL link formatted in absolute URI form
            public bool IsImportant { get; set; } // Enable/disable visually marking message as important
            public bool IsQuiet { get; set; } // Enable/disable sending toast notifications to client(s)
            //public string Image { get; set; } // Image thumbnail URL link, recommended size is 72x72 pixels
            //public string Source { get; set; } // Notification source name that is displayed instad of app name
            //public int TimeToLive { get; set; } // Time in minutes until message gets sent to configured client(s)

            public string QueryString() => $"AuthorizationToken={pushalotToken}&Title={Title}&Body={Body}&IsImportant={IsImportant}&IsQuiet={IsQuiet}";
        }

        /// <summary>
        /// Sends a message to the Pushalot service
        /// </summary>
        /// <param name="title"></param>
        /// <param name="message"></param>
        /// <param name="priority"></param>
        /// <param name="callback"></param>
        void Pushalot(string title, string message, string priority = "high", Action<bool> callback = null)
        {
            var important = false;
            var quiet = false;

            switch (priority.ToLower())
            {
                case "high":
                    important = true;
                    break;
                case "quiet":
                    quiet = true;
                    break;
            }

            var payload = new PushalotMessage { Title = title, Body = message, IsImportant = important, IsQuiet = quiet };
            if (ErrorHandling(payload))
            {
                callback?.Invoke(false);
                return;
            }

            WebRequest(pushalotUrl, payload.QueryString(), callback);
        }

        bool ErrorHandling(PushalotMessage payload)
        {
            if (string.IsNullOrEmpty(pushbulletToken) || pushbulletToken.Length != 34)
            {
                LogWarning("Pushbullet access token not set! Please set it and try again");
                return false;
            }

            if (string.IsNullOrEmpty(payload.Title))
            {
                LogWarning("Title not given! Please enter one and try again");
                return false;
            }

            if (string.IsNullOrEmpty(payload.Body))
            {
                LogWarning("Body not given! Please enter one and try again");
                return false;
            }

            return true;
        }

        #endregion

        #region Pushbullet Service

        /// <summary>
        /// Required base note class for pushing to Pushbullet
        /// https://docs.pushbullet.com/#create-push
        /// </summary>
        class PushbulletNote
        {
            public string title { get; set; } // Title of the push, used for all types of pushes
            public string body { get; set; } // Body of the push, used for all types of pushes
            public string type { get; set; } // Type of the push, one of "note", "file", "link"
            //public string device_iden { get; set; } // Specific device identity to push to
            //public string email { get; set; } // Specific email address to push to
            //public string channel_tag { get; set; } // Channel tag of subscribers to push to
            //public string client_iden { get; set; } // Client identity used to push to multiple users

            public string QueryString() => $"&title={title}&body={body}&type={type}";
        }

        /// <summary>
        /// Optional file class for pushing files to Pushbullet
        /// https://docs.pushbullet.com/#push-a-file
        /// </summary>
        class PushbulletFile : PushbulletNote
        {
            public string file_name { get; set; } // File name
            public string file_type { get; set; } // File mime type, ex. "image/jpeg"
            public string file_url { get; set; } // File download URL

            public new string QueryString() => $"&title={title}&body={body}&type={type}&file_name={file_name}&file_type={file_type}&file_url={file_url}";
        }

        /// <summary>
        /// Sends a note to the Pushbullet service
        /// </summary>
        /// <param name="title"></param>
        /// <param name="message"></param>
        /// <param name="callback"></param>
        void Pushbullet(string title, string message, Action<bool> callback = null)
        {
            var payload = new PushbulletNote { title = title, body = message, type = "note" };
            if (!ErrorHandling(payload)) return;

            WebRequest(pushbulletUrl, payload.QueryString(), callback, pushbulletHeaders);
        }

        /// <summary>
        /// Sends a file to the Pushbullet service
        /// </summary>
        /// <param name="title"></param>
        /// <param name="message"></param>
        /// <param name="fileUrl"></param>
        /// <param name="fileName"></param>
        /// <param name="fileType"></param>
        /// <param name="callback"></param>
        void Pushbullet(string title, string message, string fileUrl, string fileName = "Unnamed", string fileType = "text/plain", Action<bool> callback = null)
        {
            // TODO: Try to detect file type from URL?
            // application/octet-stream
            // image/jpeg
            // image/png
            // text/plain

            var payload = new PushbulletFile { title = title, body = message, type = "file", file_url = fileUrl, file_name = fileName, file_type = fileType };
            if (!ErrorHandling(payload))
            {
                callback?.Invoke(false);
                return; // TODO: Need to check title and body too...
            }

            WebRequest(pushbulletUrl, payload.QueryString(), callback, pushbulletHeaders);
        }

        bool ErrorHandling(PushbulletNote payload, Action<bool> callback = null)
        {
            if (string.IsNullOrEmpty(pushbulletToken) || pushbulletToken.Length != 34)
            {
                LogWarning("Pushbullet access token not set! Please set it and try again");
                return false;
            }

            if (string.IsNullOrEmpty(payload.title))
            {
                LogWarning("Title not given! Please enter one and try again");
                return false;
            }

            if (string.IsNullOrEmpty(payload.body))
            {
                LogWarning("Body not given! Please enter one and try again");
                return false;
            }

            return true;
        }

        bool ErrorHandling(PushbulletFile payload, Action<bool> callback = null)
        {
            if (string.IsNullOrEmpty(payload.file_name))
            {
                LogWarning("File name not given! Please enter one and try again");
                return false;
            }

            if (string.IsNullOrEmpty(payload.file_url))
            {
                LogWarning("File URL not given! Please enter one and try again");
                return false;
            }

            return true;
        }

        #endregion

        #region Pushover Service

        /// <summary>
        /// Required base message class for pushing to Pushover
        /// https://pushover.net/api#messages
        /// </summary>
        class PushoverMessage
        {
            //public string token = pushoverAppKey; // The application's API token/key from https://pushover.net/apps
            //public string user = pushoverUserKey; // The user/group key (not e-mail address) for the account
            public string title { get; set; } // Title of the message, otherwise app's name is used
            public string message { get; set; } // Message body to be pushed, basic HTML is supported
            public string priority { get; set; } // -2 for no alert, -1 for quiet, 1 to bypass quiet hours, or 2 to require confirmation
            public string sound { get; set; } // Sound to override default sound choice, see https://pushover.net/api#soundspushoverUserKey
            //public string url { get; set; } // Supplementary URL to show with your message
            //public string url_title { get; set; } // Title for your supplementary URL, otherwise just the URL is shown
            //public long timestamp { get; set; } // Unix timestamp to use for date/time of message instead of API set time
            //public string device { get; set; } // One or more specific device names (comma separated) to send message to
            //public int html = 1; // Enable (1) or disable (0) HTML support

            public string QueryString() => $"token={pushoverAppKey}&user={pushoverUserKey}&title={title}&message={message}&priority={priority}&sound={sound}&html=1";
        }

        /// <summary>
        /// Sends a message to the Pushover service
        /// </summary>
        /// <param name="title"></param>
        /// <param name="message"></param>
        /// <param name="priority"></param>
        /// <param name="sound"></param>
        /// <param name="callback"></param>
        void Pushover(string title, string message, string priority = "high", string sound = "gamelan", Action<bool> callback = null)
        {
            switch (priority.ToLower())
            {
                case "high":
                    priority = "1";
                    break;
                case "low":
                    priority = "0";
                    break;
                case "quiet":
                    priority = "-1";
                    break;
            }

            var payload = new PushoverMessage { title = title, message = message, priority = priority, sound = sound };
            if (!ErrorHandling(payload))
            {
                callback?.Invoke(false);
                return;
            }

            WebRequest(pushoverUrl, payload.QueryString(), callback);
        }

        bool ErrorHandling(PushoverMessage payload, Action<bool> callback = null)
        {
            if (string.IsNullOrEmpty(pushoverAppKey) || pushoverAppKey.Length != 30)
            {
                LogWarning("Pushover application key not set! Please set it and try again");
                return false;
            }

            if (string.IsNullOrEmpty(pushoverUserKey) || pushoverUserKey.Length != 30)
            {
                LogWarning("Pushover user key not set! Please set it and try again");
                return false;
            }

            if (string.IsNullOrEmpty(payload.title))
            {
                LogWarning("Title not given! Please enter one and try again");
                return false;
            }

            if (string.IsNullOrEmpty(payload.message))
            {
                LogWarning("Message not given! Please enter one and try again");
                return false;
            }

            return true;
        }

        #endregion

        #region Web Request

        void WebRequest(string url, string body, Action<bool> callback, Dictionary<string, string> headers = null)
        {
            if (url == null || string.IsNullOrEmpty(body)) return;

            webrequest.EnqueuePost(url, body, (code, response) =>
            {
                if (response == null || code != 200) PrintWarning($"{serviceName.Titleize()} service responded with: {response} ({code})");
                callback?.Invoke(code == 200 || response != null);
            }, this, headers);
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        #endregion
    }
}

// --- End of file: PushAPI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/prop-control ---
// --- Original File Path: P/PropControl/PropControl.cs ---

﻿using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Prop Control", "Dana", "0.1.3")]
    [Description("Become an animal")]
    public class PropControl : RustPlugin
    {
        #region References

        [PluginReference] private Plugin Vanish, BetterVanish;

        private const string permallow = "propcontrol.allow";

        private List<Props> data = new List<Props>();
        private PluginConfig _pluginConfig;

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (_pluginConfig.PropControlConfig.InvulnerableProps && entity?.gameObject?.GetComponent<NpcAI>() != null)
            {
                info?.damageTypes.Clear();
                return true;
            }
            return null;
        }

        #endregion References

        #region Classes

        public class Props
        {
            public BasePlayer player { get; set; }
            public BaseEntity entity { get; set; }
        }

        private class NPCController : MonoBehaviour
        {
            public BasePlayer player;
            public NpcAI npcAi;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
            }
        }

        private class NpcAI : MonoBehaviour
        {
            internal Vector3 targetPos = Vector3.zero;
            internal BaseCombatEntity targetEnt { get; set; }
            internal BaseMountable mountable;
            public BasePlayer npc;
            public NPCController owner;
            public BaseEntity entity;
            public RidableHorse horse;
            public BaseNpc baseNpc;
            public Transform transformer;
            public ResourceDispenser dispenser;

            private void Awake()
            {
                entity = GetComponent<BaseEntity>();
                transformer = transform;

                var component = GetComponent<ResourceDispenser>();
                if (component != null)
                {
                    dispenser = component;
                }
                if (entity is RidableHorse)
                {
                    horse = entity as RidableHorse;
                    horse.maxSpeed = 200000f;
                    horse.walkSpeed = 2000f;
                    horse.trotSpeed = 4000f;
                    horse.runSpeed = horse.maxSpeed;
                }
                else if (entity is BasePlayer)
                {
                    npc = entity as BasePlayer;
                }
            }

            private void OnDestroy()
            {
                if (entity != null && !entity.IsDestroyed)
                {
                    entity.Kill();
                }

                if (targetEnt != null && !targetEnt.IsDestroyed)
                {
                    targetEnt.Kill();
                }

                Destroy(this);
            }

            private void Update()
            {
                if (owner == null || owner.player == null)
                {
                    return;
                }
                if (horse != null && !horse.IsDestroyed)
                {
                    horse.ServerPosition = owner.player.ServerPosition + owner.player.eyes.BodyForward() * 4f;
                    horse.ServerRotation = owner.player.eyes.bodyRotation;
                    return;
                }
                if (npc != null && !npc.IsDestroyed)
                {
                    if (baseNpc != null)
                    {
                        baseNpc.BlockEnemyTargeting(2000f);
                    }
                    npc.ServerPosition = owner.player.ServerPosition + owner.player.eyes.BodyForward() * 2f;
                    npc.ServerRotation = owner.player.ServerRotation;
                    npc.eyes.bodyRotation = owner.player.eyes.bodyRotation;
                    npc.eyes.rotation = owner.player.eyes.rotation;
                    return;
                }

                if (entity != null && !entity.IsDestroyed)
                {
                    entity.ServerPosition = owner.player.ServerPosition + owner.player.eyes.BodyForward() * 2.8f;
                    entity.ServerRotation = owner.player.eyes.bodyRotation;
                }
            }
        }

        #endregion Classes

        #region Messages/Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UnknownError"] = "Something went wrong",
                ["PlayerNotAProp"] = "You are not a prop",
                ["PlayerAlreadyAProp"] = "You are already a prop",
                ["PlayerBecameAProp"] = "You became a <color=#FFA500>{0}</color>",
                ["PlayerLeftAProp"] = "You are not a prop anymore",
                ["NoPermissions"] = "Missing permission",
                ["NoVanshPermission"] = "Missing vanish permission",
                ["NoVanishPlugin"] = "Vanish plugin required",
                ["InvalidArgs"] = "Invalid Arguments",
                ["PropsList"] = "<color=#FFA500>Available Props</color> \n\n<color=#FFA500>•</color> {0}",
            }, this);
        }

        private string Message(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion Messages/Localization

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(permallow, this);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }
        protected override void LoadConfig()
        {
            var newConfig = new DynamicConfigFile($"{Manager.ConfigPath}/{Name}.json");
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }

            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = newConfig.ReadObject<PluginConfig>();
            if (_pluginConfig.PropControlConfig == null)
            {
                _pluginConfig.PropControlConfig = new PropControlConfig
                {
                    PropPrefabMap = new Dictionary<string, string> {
                        { "basichorse", "assets/rust.ai/agents/horse/horse.prefab" },
                        { "boar", "assets/rust.ai/agents/boar/boar.prefab" },
                        { "bear", "assets/rust.ai/agents/bear/bear.prefab" },
                        { "wolf", "assets/rust.ai/agents/wolf/wolf.prefab" },
                        { "chicken", "assets/rust.ai/agents/chicken/chicken.prefab" },
                        { "horse", "assets/rust.ai/nextai/testridablehorse.prefab" },
                        { "stag", "assets/rust.ai/agents/stag/stag.prefab" },
                        { "scientist", "assets/prefabs/npc/scientist/scientist.prefab" },
                        { "heavy", "assets/rust.ai/agents/npcplayer/humannpc/heavyscientist/heavyscientist.prefab" },
                        { "peacekeeper", "assets/prefabs/npc/scientist/scientistpeacekeeper.prefab" },
                        { "zombie", "assets/rust.ai/agents/zombie/zombie.prefab" }
                    }
                };
            }
            newConfig.WriteObject(_pluginConfig);
            PrintWarning("Config Loaded");
        }

        private void Unload()
        {
            foreach (var prop in data)
            {
                if (prop.entity == null || prop.entity.IsDestroyed) continue;
                prop.entity.Kill();
            }

            data.Clear();
        }

        #endregion Hooks

        #region Commands

        [ChatCommand("leave")]
        private void LeaveCommand(BasePlayer player)
        {
            int index = data.FindIndex(data => data.player == player);
            if (index == -1)
            {
                PrintToChat(player, Message("PlayerNotAProp", player.UserIDString));
                return;
            }
            BaseEntity entity = data[index].entity;
            data.RemoveAt(index);
            Puts(data.Count.ToString());
            if (!entity.IsDestroyed) entity.Kill();
            PrintToChat(player, Message("PlayerLeftAProp", player.UserIDString));
        }

        [ChatCommand("become")]
        private void BecomeCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "PropControl.allow"))
            {
                PrintToChat(player, Message("NoPermissions", player.UserIDString));
                return;
            }
            if (!permission.UserHasPermission(player.UserIDString, "vanish.allow") && !permission.UserHasPermission(player.UserIDString, "bettervanish.allowed"))
            {
                PrintToChat(player, Message("NoVanshPermission", player.UserIDString));
                return;
            }
            if ((Vanish == null || !Vanish.IsLoaded || !_pluginConfig.PropControlConfig.UseVanish)
                && (BetterVanish == null || !BetterVanish.IsLoaded || !_pluginConfig.PropControlConfig.UseBetterVanish))
            {
                PrintToChat(player, Message("NoVanishPlugin", player.UserIDString));
                return;
            }
            if (args.Length < 1)
            {
                PrintToChat(player, Message("InvalidArgs", player.UserIDString));
                return;
            }
            int index = data.FindIndex(data => data.player == player);
            if (index != -1) // removed linq
            {
                if (data[index].entity.IsFullySpawned())
                {
                    PrintToChat(player, Message("PlayerAlreadyAProp", player.UserIDString));
                    return;
                }
                else
                {
                    data.RemoveAt(index);
                }
            }

            if (_pluginConfig.PropControlConfig.UseBetterVanish && BetterVanish != null && BetterVanish.IsLoaded)
            {
                if (!BetterVanish.Call<bool>("IsInvisible", player))
                {
                    BetterVanish.Call("Disappear", player);
                }
            }
            else if (_pluginConfig.PropControlConfig.UseVanish && Vanish != null && Vanish.IsLoaded)
            {
                if (!Vanish.Call<bool>("IsInvisible", player))
                {
                    Vanish.Call("Disappear", player);
                }
            }

            string prefab = DeterminePrefab(args[0]);

            if (prefab == "Invalid")
            {
                PrintToChat(player, Message("InvalidArgs", player.UserIDString));
                return;
            }

            var prop = GameManager.server.CreateEntity(prefab, player.transform.position, player.transform.rotation, true);
            if (prop == null)
            {
                PrintToChat(player, Message("UnknownError", player.UserIDString));
                return;
            }

            Rust.Ai.AiManagedAgent agentComponent;
            if (prop.TryGetComponent(out agentComponent))
            {
                UnityEngine.Object.Destroy(agentComponent);
            }

            PlayerInput playerInput;
            if (prop.TryGetComponent(out playerInput))
            {
                UnityEngine.Object.Destroy(playerInput);
            }

            NPCController controller = player.gameObject.AddComponent<NPCController>();
            controller.npcAi = prop.gameObject.AddComponent<NpcAI>();
            controller.npcAi.entity = prop;

            var dispenser = prop.GetComponent<ResourceDispenser>();
            if (dispenser != null)
            {
                controller.npcAi.dispenser = dispenser;
            }

            var transformer = prop.GetComponent<Transform>();
            if (transformer != null)
            {
                controller.npcAi.transformer = transformer;
            }

            controller.npcAi.owner = controller;

            data.Add(new Props() { player = player, entity = prop });
            prop.Spawn();

            PrintToChat(player, Message("PlayerBecameAProp", player.UserIDString, args[0]));
        }

        [ChatCommand("props")]
        private void PropsCommand(BasePlayer player)
        {
            PrintToChat(player, Message("PropsList", player.UserIDString, string.Join("\n<color=#FFA500>•</color> ", _pluginConfig.PropControlConfig.PropPrefabMap.Keys)));
        }

        #endregion Commands

        #region Helpers

        private static BaseEntity FindObject(Ray ray, float distance)
        {
            RaycastHit hit;
            return !Physics.Raycast(ray, out hit, distance) ? null : hit.GetEntity();
        }

        private string DeterminePrefab(string argument)
        {
            if (_pluginConfig.PropControlConfig.PropPrefabMap.ContainsKey(argument))
            {
                return _pluginConfig.PropControlConfig.PropPrefabMap[argument];
            }

            return "Invalid";
        }

        #endregion Helpers

        #region Classes

        private class PluginConfig
        {
            public PropControlConfig PropControlConfig { get; set; }
        }

        private class PropControlConfig
        {
            [JsonProperty(PropertyName = "Use - BetterVanish")]
            public bool UseBetterVanish { get; set; }

            [JsonProperty(PropertyName = "Use - Vanish")]
            public bool UseVanish { get; set; } = true;

            [JsonProperty(PropertyName = "PropPrefabMap")]
            public Dictionary<string, string> PropPrefabMap { get; set; }
            [JsonProperty(PropertyName = "Invulnerable Props - Enabled")]
            public bool InvulnerableProps { get; set; } = true;
        }

        #endregion Classes
    }
}


// --- End of file: PropControl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/playtime-supply-signal ---
// --- Original File Path: P/PlaytimeSupplySignal/PlaytimeSupplySignal.cs ---

using System.Collections.Generic;   //dic
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Core;
using Convert = System.Convert;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Playtime Supply Signal", "Krungh Crow", "1.1.3")]
    [Description("Give player a Supply Signal, based on time played on server and configurable rate.")]

    #region Changelogs and ToDo
    /*******************************************************************************
    * 
    * Thanks to BuzZ[PHOQUE] the original author of this plugin
    * 
    * 1.1.1 :   Started to maintain
    *       :   Added support for VehicleAirdrops plugin
    * 1.1.2 :   Added perm bonus (if a player/vip will recieve a bonus signal)
    * 1.1.3 :   Added random VehicleAirdrop signal from list Bonus
    *       :   Added random VehicleAirdrop signal from list Spawn
    *       :   Fixed messaging and signal handout
    * 
    ********************************************************************************/
    #endregion

    public class PlaytimeSupplySignal : RustPlugin
    {
        [PluginReference]
        private Plugin VehicleAirdrops;

        private Timer clock;
        bool debug = false;
        bool ConfigChanged;

        float clockrate = 120;                          // 120 seconds by default -> 2min.
        float bonusratemin = 60;                        // 3600 -> for each hour played by default
        bool spawnbonus = true;

        bool VAUse = false;                             // To replace the normal signal for a VehicleAirdrop signal
        private List<object> VASpawn = null;            // VehicleAirdrops signal to give on spawn
        private List<object> VABonus = null;            // VehicleAirdrops signal to give on bonus
        int VASpawnAmount = 1;                          // Amount of VehicleAirdrops signals to give on spawn
        int VABonusAmount = 1;                          // Amount of VehicleAirdrops signals to give on bonus

        string Prefix = "[PSS] ";                       // CHAT PLUGIN PREFIX
        string PrefixColor = "#555555";                 // CHAT PLUGIN PREFIX COLOR
        string ChatColor = "#999999";                   // CHAT MESSAGE COLOR
        ulong SteamIDIcon = 76561198859649789;          // STEAMID CREATED FOR THIS PLUGIN 76561198859649789

        const string Bonus_Perm = "playtimesupplysignal.bonus";


        class StoredData
    {
        public Dictionary<ulong, bool> playerIDhadfirst = new Dictionary<ulong, bool>();
        public Dictionary<ulong, float> playerIDbonusclock = new Dictionary<ulong, float>();
        public List<ulong> playerIDpending = new List<ulong>();

        public StoredData()
        {
        }
    }

    private StoredData storedData;

        #region CONFIG

    protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            
            Prefix = Convert.ToString(GetConfig("Chat Settings", "Prefix", "[PSS] :"));                       // CHAT PLUGIN PREFIX
            PrefixColor = Convert.ToString(GetConfig("Chat Settings", "PrefixColor", "#42d7f4"));                // CHAT PLUGIN PREFIX COLOR
            ChatColor = Convert.ToString(GetConfig("Chat Settings", "ChatColor", "#b7f5ff"));                    // CHAT  COLOR
            SteamIDIcon = Convert.ToUInt64(GetConfig("Chat Settings", "SteamIDIcon", 76561198859649789));   
            bonusratemin = Convert.ToSingle(GetConfig("Bonus Playtime", "Value in minutes", "60"));
            spawnbonus = Convert.ToBoolean(GetConfig("Bonus on Spawn", "Give a SupplySignal on first arrival", "true"));
            VAUse = Convert.ToBoolean(GetConfig("VehicleAirdrops", "Give a VehicleAirdrops signal instead of a normal one", "false"));
            VASpawnAmount = Convert.ToInt32(GetConfig("VehicleAirdrops Spawn settings", "VehicleAirdrops signal amount when spawned", "1"));
            VASpawn = (List<object>)GetConfig("VehicleAirdrops Spawn settings", "VehicleAirdrops to use", new List<object>() { "crate", "horse", "minicopter", "scrapheli", "rowboat", "rhib", "car" });
            VABonus = (List<object>)GetConfig("VehicleAirdrops Bonus settings", "VehicleAirdrops to use", new List<object>() { "crate", "horse", "minicopter", "scrapheli", "rowboat", "rhib","car" });
            VABonusAmount = Convert.ToInt32(GetConfig("VehicleAirdrops Bonus settings", "VehicleAirdrops signal amount on bonus", "1"));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

        #endregion

        #region INIT

    void Init()
    {
        storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
        LoadVariables();

        permission.RegisterPermission(Bonus_Perm, this);

        }


        void OnServerInitialized()
    {
            float bonusrate = (bonusratemin * 60);
        if (bonusrate <= (clockrate+1))
        {
            PrintError("Please set a longer rate for the bonus. Minimum rate is 3 min.");
            return;
        }
		clock = timer.Repeat(clockrate, 0, () =>
		{
            LetsClockOnActivePlaytime();
            //LetsClockOnSleeperPlaytime(); // for test
		});
    }

        #endregion

        #region UNLOAD

		void Unload()
		{
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
		}

        #endregion

        #region MESSAGES

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"FreeSlotMsg", "Please free one inventory slot to receive a bonus !"},
                {"RxMsg", "You received a SupplySignal bonus for your playtime !"},
                {"SpawnBonusMsg", "You received a SupplySignal bonus for joining this server !"},
                {"ItemMsg", "BONUS Playtime Supply Signal"},
                
            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"FreeSlotMsg", "Veuillez libérer une case d'inventaire pour recevoir un bonus !"},
                {"RxMsg", "Vous venez de recevoir un signal fumigène comme récompense de temps joué !"},
                {"SpawnBonusMsg", "Vous venez de recevoir un signal fumigène pour avoir choisi ce serveur !"},
                {"ItemMsg", "signal BONUS pour temps de jeu"},

            }, this, "fr");
        }

        #endregion

        void LetsClockOnActivePlaytime()
        {
            List<BasePlayer> playerlist = BasePlayer.activePlayerList.ToList();
            CountDaTime(playerlist);
        }

        void LetsClockOnSleeperPlaytime()
        {
            List<BasePlayer> playerlist = BasePlayer.sleepingPlayerList.ToList();
            CountDaTime(playerlist);
        }

        void CountDaTime(List<BasePlayer> playerlist)
        {
            foreach (BasePlayer player in playerlist)
            {
                float bonusrate = (bonusratemin * 60);
                if (debug){Puts($"rate in seconds, calculated from config : {bonusrate}");}
                if (storedData.playerIDhadfirst.ContainsKey(player.userID) == false)
                {
                    if (spawnbonus == true)
                    {
                        Player.Message(player, $"<color={ChatColor}> {lang.GetMessage("SpawnBonusMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                        if (VehicleAirdrops == true || VAUse == true)
                        {
                                Server.Command($"signal_give {player.userID} {VASpawn[new System.Random().Next(VASpawn.Count())]} {VASpawnAmount}");
                        }
                        else if (VehicleAirdrops == false && VAUse == false)
                        {
                               GiveSupplyDropToPlayer(player);
                        }
                        if (debug){Puts($"player {player.userID} did -NOT- received bonus yet -> GIVE a supplydrop");}
                    }
                    storedData.playerIDbonusclock.Add(player.userID, 0);
                    storedData.playerIDhadfirst.Add(player.userID, true);                        
                }
                else
                {
                    if (debug){Puts($"player -DID- receive bonus");}
                    float oldtime;
                    storedData.playerIDbonusclock.TryGetValue(player.userID, out oldtime);
                    storedData.playerIDbonusclock.Remove(player.userID);
                    float newtime = oldtime + clockrate;
                    storedData.playerIDbonusclock.Add(player.userID, newtime);
                    if (debug){Puts($"player {player.userID} newtime {newtime}");}
                    if (bonusrate <= 0)
                    {
                        if (debug){Puts($"error : bonusrate <= 0. has been set to 1 hour");}
                        bonusrate = 3600;
                    }
                    if (newtime >= bonusrate)
                    {
                        if (debug){Puts($"player {player.userID} reached bonusrate");}
                        storedData.playerIDbonusclock.Remove(player.userID);
                        storedData.playerIDbonusclock.Add(player.userID, 0);
                        if (VehicleAirdrops == false || VAUse == false )
                        {
                            if (permission.UserHasPermission(player.UserIDString, Bonus_Perm))
                            {
                                GiveSupplyDropToPlayer(player);
                            }
                        }
                        else if (VehicleAirdrops == true && VAUse == true)
                        {
                            if (permission.UserHasPermission(player.UserIDString, Bonus_Perm))
                            {
                                //Server.Command($"signal_give {player.userID} {VASpawn} {VASpawnAmount}");
                                Server.Command($"signal_give {player.userID} {VABonus[new System.Random().Next(VABonus.Count())]} {VABonusAmount}");

                                Player.Message(player, $"<color={ChatColor}> {lang.GetMessage("RxMsg", this, player.UserIDString)}</color>", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                            }
                        }
                    }
                }
            }
        }

        #region GIVE

        void GiveSupplyDropToPlayer(BasePlayer player)
        {
            foreach (var playerzactiv in BasePlayer.activePlayerList.ToList())
            {
                if (playerzactiv == player)
                {
                    Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1397052267).itemid, 1);
                    if (itemtogive == null)
                    {
                        if (debug){Puts($"Error on item creation at #GIVE");}
                        return;
                    }
                    itemtogive.name = $"{lang.GetMessage("ItemMsg", this, player.UserIDString)}";
                    int invcount = player.inventory.containerMain.itemList.Count;
                    int freeslot = 24 - invcount;
                    if (debug){Puts($"freeslot {freeslot}");}
                    if (freeslot < 1)
                    {
                        storedData.playerIDpending.Add(player.userID);
                        if (debug){Puts($"inventory full");}
                        Player.Message(player, $"<color={ChatColor}> {lang.GetMessage("FreeSlotMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);                
                        return;
                    }
                    if (freeslot >= 1)
                    {
                        Player.Message(player, $"<color={ChatColor}> {lang.GetMessage("RxMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);                
                        if (debug){Puts($"GIVING ITEM");}
                        player.GiveItem(itemtogive);
                        if (storedData.playerIDpending.Contains(player.userID) == true)
                        {
                            storedData.playerIDpending.Remove(player.userID);
                        }
                        return;
                    }
                }
            }
        }
        #endregion 
    }
}

// --- End of file: PlaytimeSupplySignal.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/personal-heli ---
// --- Original File Path: P/PersonalHeli/PersonalHeli.cs ---

﻿// #define DEBUG
using System.Collections.Generic;
using System;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Text;
using System.Linq;
using Facepunch;
using Rust;

namespace Oxide.Plugins {
    [Info("Personal Heli", "Egor Blagov", "1.1.11")]
    [Description("Calls heli to player and his team, with loot/damage and minig lock")]
    class PersonalHeli : RustPlugin {
        #region CONSTANTS
        const string permUse = "personalheli.use";
        const string permConsole = "personalheli.console";
        const float HelicopterEntitySpawnRadius = 10.0f;
        #endregion
        #region DEPENDENCIES
        [PluginReference]
        Plugin Friends, Clans;
        #endregion
        #region CONFIG
        class PluginConfig {
            public bool UseFriends = true;
            public bool UseTeams = true;
            public bool UseClans = true;
            public int CooldownSeconds = 1800;
            public string ChatCommand = "callheli";
            public bool ResetCooldownsOnWipe = true;
            public bool MemorizeTeamOnCall = false;
            public bool RetireOnAllTeamDead = false;
            public bool DenyCratesLooting = true;
            public bool DenyGibsMining = true;
            public bool RemoveFireFromCrates = true;
        }
        private PluginConfig config;
        #endregion
        #region STORED DATA
        class StoredData {
            public Dictionary<ulong, CallData> CallDatas = new Dictionary<ulong, CallData>();

            public class CallData {
                public DateTime LastCall = DateTime.MinValue;
                public bool CanCallNow(int cooldown) {
                    return DateTime.Now.Subtract(LastCall).TotalSeconds > cooldown;
                }

                public int SecondsToWait(int cooldown) {
                    return (int)Math.Round(cooldown - DateTime.Now.Subtract(LastCall).TotalSeconds);
                }

                public void OnCall() {
                    LastCall = DateTime.Now;
                }
            }

            public CallData GetForPlayer(BasePlayer player) {
                if (!CallDatas.ContainsKey(player.userID.Get())) {
                    CallDatas[player.userID.Get()] = new CallData();
                }

                return CallDatas[player.userID.Get()];
            }
        }
        private void SaveData() {
            if (storedData != null) {
                Interface.Oxide.DataFileSystem.WriteObject(Name, storedData, true);
            }
        }
        private void LoadData() {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            if (storedData == null) {
                storedData = new StoredData();
                SaveData();
            }
        }
        private StoredData storedData;
        #endregion
        #region L10N
        protected override void LoadDefaultMessages() {
            lang.RegisterMessages(new Dictionary<string, string> {
                ["NoPermission"] = "You have no permission to use this command",
                ["Cooldown"] = "Helicopter call is on cooldown, time remaining: {0}",
                ["LootDenied"] = "You are forbidden to loot this crate, it belongs to: {0}",
                ["DamageDenied"] = "You are forbidden to damage this helicopter, it was called by: {0}",
                ["MiningDenied"] = "You are forbidden to mine this debris, it belongs to: {0}",
                ["Friends"] = "their friends",
                ["Team"] = "their team",
                ["Clan"] = "their clan",
                ["CmdUsage"] = "Invalid format, usage: personalheli.call {{steamId}}",
                ["InvalidSteamId"] = "{0} is invalid Steam ID",
                ["PlayerNotFound"] = "Player with id {0} was not found",
                ["PlayerCalled"] = "Personal helicopter is called for {0}"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string> {
                ["NoPermission"] = "У Вас нет прав на использование этой команды",
                ["Cooldown"] = "Вызов вертолета в кулдауне, ждать осталось: {0}",
                ["HeliSuccess"] = "Вертолет был вызван",
                ["LootDenied"] = "Вам запрещено лутать этот ящик, его могут лутать: {0}",
                ["DamageDenied"] = "Вам запрещено наносить урон этому вертолету, его вызвал: {0}",
                ["MiningDenied"] = "Вам запрещено добывать эти обломки, их могут добывать: {0}",
                ["Friends"] = "его друзья",
                ["Team"] = "его команда",
                ["Clan"] = "его клан",
                ["CmdUsage"] = "Неправильный формат, использование: personalheli.call {{steamId}}",
                ["InvalidSteamId"] = "{0} не является Steam ID",
                ["PlayerNotFound"] = "Игрок с ID {0} не найден",
                ["PlayerCalled"] = "Вертолет был вызван для {0}"
            }, this, "ru");
        }
        private string _(string key, string userId, params object[] args) {
            return string.Format(lang.GetMessage(key, this, userId), args);
        }
        #endregion
        #region HOOKS
        private void Init() {
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permConsole, this);
            config = Config.ReadObject<PluginConfig>();
            Config.WriteObject(config);
            cmd.AddChatCommand(config.ChatCommand, this, CmdCallHeli);
            LoadData();
        }
        private void Unload() {
            foreach (var personal in UnityEngine.Object.FindObjectsOfType<PersonalComponent>()) {
                UnityEngine.Object.Destroy(personal);
            }
            SaveData();
        }
        protected override void LoadDefaultConfig() {
            Config.WriteObject(new PluginConfig(), true);
        }
        private void OnNewSave() {
            if (config.ResetCooldownsOnWipe) {
                storedData = new StoredData();
                SaveData();
            }
        }
        private void OnServerSave() {
            SaveData();
        }
        private void OnEntityKill(BaseEntity entity) {
            InvokePersonal<PersonalHeliComponent>(entity.gameObject, personalHeli => personalHeli.OnKill());
        }
        private object CanLootEntity(BasePlayer player, StorageContainer container) {
            return InvokePersonal<PersonalCrateComponent, object>(container?.gameObject, personalCrate => {
                var result = personalCrate.CanInterractWith(player);
                if (result == false) {
                    SendReply(player, _("LootDenied", player.UserIDString, GetPlayerOwnerDescription(player, personalCrate.Player)));
                    return false;
                }
                return null;
            });
        }
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info) {
            if (!config.RetireOnAllTeamDead) {
                return;
            }

            if (!(entity is BasePlayer)) {
                return;
            }
            NextTick(() => {
                foreach (var heli in PersonalHeliComponent.ActiveHelis) {
                    heli.OnPlayerDied(entity as BasePlayer);
                }
            });
        }
        private object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity entity) {
            return InvokePersonal<PersonalHeliComponent, object>(turret?._heliAI?.helicopterBase?.gameObject, personalHeli => {
                var result = personalHeli.CanInterractWith(entity);
                return result ? null : (object) false;
            });
        }
        private object OnPlayerAttack(BasePlayer attacker, HitInfo info) {
            if (info.HitEntity is ServerGib && info.WeaponPrefab is BaseMelee) {
                return InvokePersonal<PersonalGibComponent, object>(info?.HitEntity?.gameObject, personalGib => {
                    var result = personalGib.CanInterractWith(attacker);
                    if (result == false) {
                        SendReply(info.InitiatorPlayer, _("MiningDenied", info.InitiatorPlayer.UserIDString, GetPlayerOwnerDescription(info.InitiatorPlayer, personalGib.Player)));
                        return false;
                    }
                    return null;
                });
            }
            return InvokePersonal<PersonalHeliComponent, object>(info?.HitEntity?.gameObject, personalHeli => {
                var result = personalHeli.CanInterractWith(attacker);
                if (result == false) {
                    SendReply(info.InitiatorPlayer, _("DamageDenied", info.InitiatorPlayer.UserIDString, GetPlayerOwnerDescription(info.InitiatorPlayer, personalHeli.Player)));
                    return false;
                }
                return null;
            });
        }
        private object CanHelicopterStrafeTarget(PatrolHelicopterAI heliAi, BasePlayer target) {
            return InvokePersonal<PersonalHeliComponent, object>(heliAi?.helicopterBase?.gameObject, personalHeli => {
                return personalHeli.CanInterractWith(target) ? null : (object) false;
            });
        }
        private object CanHelicopterTarget(PatrolHelicopterAI heliAi, BasePlayer player) {
            return InvokePersonal<PersonalHeliComponent, object>(heliAi?.helicopterBase?.gameObject, personalHeli => {
                return personalHeli.CanInterractWith(player) ? null : (object) false;
            });
        }
        #endregion
        private bool CallHeliForPlayer(BasePlayer player) {
            var playerPos = player.transform.position;
            float mapWidth = (TerrainMeta.Size.x / 2) - 50f;
            var heliPos = new Vector3(
                playerPos.x < 0 ? -mapWidth : mapWidth,
                30,
                playerPos.z < 0 ? -mapWidth : mapWidth
            );

            PatrolHelicopter heli = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", new Vector3(), new Quaternion(), true) as PatrolHelicopter;
            if (!heli) return false;
            PatrolHelicopterAI heliAI = heli.GetComponent<PatrolHelicopterAI>();
            heli.Spawn();
            heli.transform.position = heliPos;
            var component = heli.gameObject.AddComponent<PersonalHeliComponent>();
            component.Init(this, player);
            foreach (var p in BasePlayer.activePlayerList) {
                SendReply(p, _("PlayerCalled", p.UserIDString, $"<color=#63ff64>{player.displayName}</color>"));
            }
            return true;
        }
        #region API
        private bool IsPersonal(PatrolHelicopter heli) => InvokePersonal<PersonalHeliComponent, object>(heli?.gameObject, (comp) => true) == null ? false : true;

        #endregion
        [ConsoleCommand("personalheli.call")]
        private void CmdCallHeliConsole(ConsoleSystem.Arg arg) {
            if (arg.Player() != null) {
                if (!permission.UserHasPermission(arg.Player().UserIDString, permConsole)) {
                    PrintToConsole(arg.Player(), _("NoPermission", arg.Player().UserIDString));
                    return;
                }
            }

            Action<string> printToConsole;
            if (arg.Player() == null) {
                printToConsole = (str) => Puts(str);
            } else {
                printToConsole = (str) => PrintToConsole(arg.Player(), str);
            }

            string UserId = arg.Player() == null ? "" : arg.Player().UserIDString;
            if (!arg.HasArgs()) {
                printToConsole(_("CmdUsage", UserId));
                return;
            }

            if (!arg.Args[0].IsSteamId()) {
                printToConsole(_("InvalidSteamId", UserId, arg.Args[0]));
                return;
            }

            var player = BasePlayer.FindByID(ulong.Parse(arg.Args[0]));
            if (player == null) {
                player = BasePlayer.FindSleeping(ulong.Parse(arg.Args[0]));
            }

            if (player == null) {
                printToConsole(_("PlayerNotFound", UserId, arg.Args[0]));
                return;
            }

            if (CallHeliForPlayer(player)) {
                printToConsole(_("PlayerCalled", UserId, player.displayName));
            }
        }

        private void CmdCallHeli(BasePlayer player, string cmd, string[] argv) {
            if (!permission.UserHasPermission(player.UserIDString, permUse)) {
                SendReply(player, _("NoPermission", player.UserIDString));
                return;
            }

            StoredData.CallData callData = storedData.GetForPlayer(player);
            if (!callData.CanCallNow(config.CooldownSeconds)) {
                SendReply(player, _("Cooldown", player.UserIDString, TimeSpan.FromSeconds(callData.SecondsToWait(config.CooldownSeconds))));
                return;
            }

            if (CallHeliForPlayer(player)) {
                callData.OnCall();
            }
        }
        private string GetPlayerOwnerDescription(BasePlayer player, BasePlayer playerOwner) {
            StringBuilder result = new StringBuilder($"<color=#63ff64>{playerOwner.displayName}</color>");
            if (config.UseFriends && Friends != null) {
                result.Append($", {_("Friends", player.UserIDString)}");
            }
            if (config.UseTeams) {
                result.Append($", {_("Team", player.UserIDString)}");
            }
            if (config.UseClans) {
                result.Append($", {_("Clan", player.UserIDString)}");
            }
            return result.ToString();
        }
        private T InvokePersonal<C, T>(GameObject obj, Func<C, T> action) where C : PersonalComponent {
            var comp = obj?.GetComponent<C>();
            if (comp == null) return default(T);
            return action(comp);
        }
        private void InvokePersonal<C>(GameObject obj, Action<C> action) where C : PersonalComponent => InvokePersonal<C, object>(obj, comp => { action(comp); return null; });
        abstract class PersonalComponent : FacepunchBehaviour {
            protected PersonalHeli Plugin;
            protected PluginConfig Config => Plugin.config;
            public List<BasePlayer> SavedTeam;
            public BasePlayer Player;
            public void Init(PersonalHeli plugin, BasePlayer player) {
                Player = player;
                Plugin = plugin;
                OnInitChild();
            }
            protected virtual void OnInitChild() { }

            public virtual bool CanInterractWith(BaseEntity target) {
                if (Config.MemorizeTeamOnCall && SavedTeam != null) {
                    return SavedTeam.Contains(target as BasePlayer);
                }

                if (!(target is BasePlayer) || target is NPCPlayer) {
                    return false;
                }

                if (target == Player) {
                    return true;
                }

                if (Plugin.config.UseFriends) {
                    if (AreFriends(target as BasePlayer)) {
                        return true;
                    }
                }

                if (Plugin.config.UseTeams) {
                    if (AreSameTeam(target as BasePlayer)) {
                        return true;
                    }
                }

                if (Plugin.config.UseClans) {
                    if (AreSameClan(target as BasePlayer)) {
                        return true;
                    }
                }

                return false;
            }

            protected bool AreSameClan(BasePlayer basePlayer) {
                if (Plugin.Clans == null) {
                    return false;
                }
                var playerClan = Plugin.Clans.Call<string>("GetClanOf", Player);
                var otherPlayerClan = Plugin.Clans.Call<string>("GetClanOf", basePlayer);
                if (playerClan == null || otherPlayerClan == null) {
                    return false;
                }

                return playerClan == otherPlayerClan;
            }

            protected bool AreSameTeam(BasePlayer otherPlayer) {
                if (Player.currentTeam == 0UL || otherPlayer.currentTeam == 0UL) {
                    return false;
                }

                return Player.currentTeam == otherPlayer.currentTeam;
            }

            protected bool AreFriends(BasePlayer otherPlayer) {
                if (Plugin.Friends == null) {
                    return false;
                }

                return Plugin.Friends.Call<bool>("AreFriends", Player.userID.Get(), otherPlayer.userID.Get());
            }

            private void OnDestroy() {
                OnDestroyChild();
            }
            protected virtual void OnDestroyChild() { }
        }
        class PersonalCrateComponent : PersonalComponent {
            private StorageContainer Crate;
            private void Awake() {
                Crate = GetComponent<StorageContainer>();
            }
            protected override void OnDestroyChild() {
                if (Crate != null && Crate.IsValid() && !Crate.IsDestroyed) {
                    Crate.Kill();
                }
            }
        }
        class PersonalGibComponent : PersonalComponent {
            private HelicopterDebris Gib;
            private void Awake() {
                Gib = GetComponent<HelicopterDebris>();
            }
            protected override void OnDestroyChild() {
                if (Gib != null && Gib.IsValid() && !Gib.IsDestroyed) {
                    Gib.Kill();
                }
            }
        }
        class PersonalHeliComponent : PersonalComponent {
            private const int MaxHeliDistanceToPlayer = 140;
            public static List<PersonalHeliComponent> ActiveHelis = new List<PersonalHeliComponent>();
            private PatrolHelicopter Heli;
            private PatrolHelicopterAI HeliAi => Heli.GetComponent<PatrolHelicopterAI>();
            private void Awake() {
                Heli = this.GetComponent<PatrolHelicopter>();
            }
            protected override void OnInitChild() {
                HeliAi.State_Move_Enter(Player.transform.position + new Vector3(UnityEngine.Random.Range(10f, 50f), 20f, UnityEngine.Random.Range(10f, 50f)));
                InvokeRepeating(new Action(UpdateTargets), 5.0f, 5.0f);
                if (Config.MemorizeTeamOnCall) {
                    SavedTeam = GetAllPlayersInTeam();
                }
                ActiveHelis.Add(this);
#if DEBUG
                InvokeRepeating(new Action(TraceState), 5.0f, 5.0f);
#endif
            }
#if DEBUG
            private void TraceState() {
                Plugin.Server.Broadcast($"helicopter: {Heli.transform.position}: {HeliAi._currentState.ToString()}");
                Plugin.Server.Broadcast(string.Join(", ", HeliAi._targetList.Select(tg => tg.ply.displayName)));
                Plugin.Server.Broadcast($"heli at destionation {Vector3.Distance(Heli.transform.position, HeliAi.destination)}");
            }
#endif
            private void UpdateTargets() {
                if (HeliAi._targetList.Count == 0) {
                    List<BasePlayer> team = Config.MemorizeTeamOnCall ? SavedTeam : GetAllPlayersInTeam();
                    foreach (var player in team) {
                        if (player != null && player.IsConnected) {
                            HeliAi._targetList.Add(new PatrolHelicopterAI.targetinfo(Player, Player));
                        }
                    }
                }

                if (HeliAi._targetList.Count == 1 && HeliAi._targetList[0].ply == Player &&
                    Vector3Ex.Distance2D(Heli.transform.position, Player.transform.position) > MaxHeliDistanceToPlayer) {
                    if (HeliAi._currentState != PatrolHelicopterAI.aiState.MOVE || Vector3Ex.Distance2D(HeliAi.destination, Player.transform.position) > MaxHeliDistanceToPlayer) {
                        HeliAi.ExitCurrentState();
                        var heliTarget = Player.transform.position.XZ() + Vector3.up * 250;
                        RaycastHit hit;
                        if (Physics.SphereCast(Player.transform.position.XZ() + Vector3.up * 600, 50, Vector3.down, out hit, 1500, Layers.Solid)) {
                            heliTarget = hit.point + Vector3.up * 20;
                        }
#if DEBUG
                        Plugin.Server.Broadcast($"Forcing helicopter {Heli.transform.position} to player {Player.displayName}, pos {heliTarget}");
#endif
                        HeliAi.State_Move_Enter(heliTarget);
                    }
                }
            }
            protected override void OnDestroyChild() {
                CancelInvoke(new Action(UpdateTargets));
#if DEBUG
                CancelInvoke(new Action(TraceState));
#endif
                if (Heli != null && Heli.IsValid() && !Heli.IsDestroyed) {
                    Heli.Kill();
                }

                ActiveHelis.Remove(this);
            }
            private List<BasePlayer> GetAllPlayersInTeam() {
                var fullTeam = new List<BasePlayer>();
                foreach (var player in BasePlayer.activePlayerList) {
                    if (player == Player) {
                        fullTeam.Add(player);
                    } else if ((Config.UseFriends && AreFriends(player)) ||
                            Plugin.config.UseClans && AreSameClan(player) ||
                            Plugin.config.UseTeams && AreSameTeam(player)) {
                        fullTeam.Add(player);
                    }
                }

                return fullTeam;
            }
            public void OnKill() {
                if (Config.DenyCratesLooting) {
                    var crates = Facepunch.Pool.GetList<LootContainer>();
                    Vis.Entities(Heli.transform.position, HelicopterEntitySpawnRadius, crates);
                    foreach (var crate in crates) {
                        var component = crate.gameObject.AddComponent<PersonalCrateComponent>();
                        component.Init(Plugin, Player);
                        if (Config.MemorizeTeamOnCall) {
                            component.SavedTeam = SavedTeam;
                        }
                        if (Config.RemoveFireFromCrates) {
                            if (crate is LockedByEntCrate) {
                                (crate as LockedByEntCrate).lockingEnt?.ToBaseEntity()?.Kill();
                            }
                        }
                    }
                    Facepunch.Pool.FreeList(ref crates);
                }
                if (Config.DenyGibsMining) {
                    var gibs = Facepunch.Pool.GetList<HelicopterDebris>();
                    Vis.Entities(Heli.transform.position, HelicopterEntitySpawnRadius, gibs);
                    foreach (var gib in gibs) {
                        var component = gib.gameObject.AddComponent<PersonalGibComponent>();
                        component.Init(Plugin, Player);
                        if (Config.MemorizeTeamOnCall) {
                            component.SavedTeam = SavedTeam;
                        }
                    }
                    Facepunch.Pool.FreeList(ref gibs);
                }
            }

            public void OnPlayerDied(BasePlayer player) {
                if (!Config.RetireOnAllTeamDead) {
                    return;
                }
                if (CanInterractWith(player)) {
                    bool allTeamDied = true;
                    List<BasePlayer> team = Config.MemorizeTeamOnCall ? SavedTeam : GetAllPlayersInTeam();
                    foreach (var member in team) {
                        if (!member.IsDead()) {
                            allTeamDied = false;
                            break;
                        }
                    }
                    if (allTeamDied) {
                        CancelInvoke(new Action(UpdateTargets));
                        HeliAi.Retire();
                    }
                }
            }
        }
    }
}


// --- End of file: PersonalHeli.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-database ---
// --- Original File Path: P/PlayerDatabase/PlayerDatabase.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.SQLite.Libraries;
using Oxide.Core.MySql.Libraries;
using Newtonsoft.Json.Linq;
using Oxide.Core.Database;
using Newtonsoft.Json;
using System.Linq;

/*
 *  CHANGELOG
 *  
 *  [2020-06-25 by FAKENINJA] v1.5.9 - Optimization: Removed unnessecary data serialization for SQLite and MySQL
 *  
 *  [2020-06-26 by FAKENINJA] v1.6.0 - Bugfixes: 
 *                                     - Resolved issue with serialization not working on stored list objects in databases.
 *                                     
 *                                     Addition:
 *                                     - Added option to rename MySQL/SQLite database table in config (MySQL/SQLite - Database Table Name)
 * 
 *  [2020-06-28 by FAKENINJA] v1.6.1 - Bugfixes: 
 *                                     - Resolved issue with serialization not working on stored dictionary objects in databases.
 *                                     
 */

namespace Oxide.Plugins
{
    [Info("Player Database", "Reneb / Maintained by FakeNinja", "1.6.2")]
    class PlayerDatabase : CovalencePlugin
    {
        List<string> changedPlayersData = new List<string>();

        DataType dataType = DataType.Files;

        enum DataType
        {
            Files,
            SQLite,
            MySql
        }

        ////////////////////////////////////////////////////////////
        // Configs
        ////////////////////////////////////////////////////////////

        static int dataTypeCfg = 1;

        static string sqlitename = "playerdatabase.db";

        static string sql_host = "localhost";
        static int sql_port = 3306;
        static string sql_db = "rust";
        static string sql_table = "PlayerDatabase";
        static string sql_user = "root";
        static string sql_pass = "toor";


        protected override void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<int>("Data Type : 0 (Files) or 1 (SQLite) or 2 (MySQL)", ref dataTypeCfg);
            CheckCfg<string>("SQLite - Database Name", ref sqlitename);
            CheckCfg<string>("MySQL - Host", ref sql_host);
            CheckCfg<int>("MySQL - Port", ref sql_port);
            CheckCfg<string>("MySQL - Database Name", ref sql_db);
            CheckCfg<string>("MySQL/SQLite - Database Table Name", ref sql_table);
            CheckCfg<string>("MySQL - Username", ref sql_user);
            CheckCfg<string>("MySQL - Password", ref sql_pass);
            dataType = (DataType)dataTypeCfg;
            SaveConfig();
            SetupDatabase();
        }

        ////////////////////////////////////////////////////////////
        // General Methods
        ////////////////////////////////////////////////////////////

        void FatalError(string msg)
        {
            Interface.Oxide.LogError(msg);
            if (dataType == DataType.MySql) Sql_conn.Con.Close();
            timer.Once(0.01f, () => Interface.Oxide.UnloadPlugin("PlayerDatabase"));
        }

        string GetMsg(string key, object steamid = null) => lang.GetMessage(key, this, steamid == null ? null : steamid.ToString());

        List<string> KnownPlayers() => dataType == DataType.SQLite ? sqliteData.Keys.ToList() : dataType == DataType.MySql ? sqlData.Keys.ToList() : storedData.knownPlayers.ToList();

        bool isKnownPlayer(string userid) => dataType == DataType.SQLite ? sqliteData.ContainsKey(userid) : dataType == DataType.MySql ? sqlData.ContainsKey(userid) : storedData.knownPlayers.Contains(userid);

        List<string> GetAllKnownPlayers() => KnownPlayers();

        object FindPlayer(string arg)
        {
            ulong steamid = 0L;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            if (steamid != 0L && arg.Length == 17)
            {
                if (!isKnownPlayer(arg)) return GetMsg("No players found matching this steamid.", null);
                else return arg;
            }
            Dictionary<string, string> foundPlayers = new Dictionary<string, string>();
            foreach (var userid in KnownPlayers())
            {
                var d = GetPlayerData(userid, "name");
                if (d != null)
                {
                    var name = (string)d;
                    string lowname = name.ToLower();
                    if (lowname.Contains(lowerarg))
                        if (!foundPlayers.ContainsKey(userid))
                            foundPlayers.Add(userid, name.ToString());

                }
            }
            if (foundPlayers.Count > 1)
            {
                string msg = string.Empty;
                foreach (KeyValuePair<string, string> pair in foundPlayers) { msg += string.Format("{0} {1}\n", pair.Key, pair.Value); }
                return msg;
            }
            foreach (string key in foundPlayers.Keys)
            {
                return key;
            }
            return GetMsg("No players found matching this name.", null);
        }

        ////////////////////////////////////////////////////////////
        // Oxide Hooks
        ////////////////////////////////////////////////////////////

        void OnServerSave()
        {
            SavePlayerDatabase();

            if (dataType == DataType.Files) SaveKnownPlayers();
        }

        void Unload()
        {
            OnServerSave();
        }

        void SetupDatabase()
        {
            LoadData();

            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "No players found matching this steamid.",  "No players found matching this steamid."},
                { "No players found matching this name.","No players found matching this name." }
            }, this);
        }

        void OnUserConnected(IPlayer player) { OnPlayerJoined(player.Id, player.Name, player.Address); }

        void OnPlayerJoined(string steamid, string name, string ip)
        {
            if (!isKnownPlayer(steamid)) { LoadPlayer(steamid); }
            SetPlayerData(steamid, "name", name);
            SetPlayerData(steamid, "ip", ip);
            SetPlayerData(steamid, "steamid", steamid);
        }
            ////////////////////////////////////////////////////////////
            // Save/Load
            ////////////////////////////////////////////////////////////

            void LoadData()
        {
            switch (dataType)
            {
                case DataType.SQLite:
                    LoadSQLite();
                    break;
                case DataType.MySql:
                    LoadMySQL();
                    break;
                default:
                    LoadFiles();
                    break;
            }
        }

        void LoadPlayers()
        {
            foreach (string userid in KnownPlayers())
            {
                try
                {
                    LoadPlayer(userid);
                }
                catch
                {
                    Interface.Oxide.LogWarning("Couldn't load " + userid);
                }
            }
        }

        void LoadPlayer(string userid)
        {
            try
            {
                if (dataType == DataType.SQLite)
                {
                    LoadPlayerSQLite(userid);
                }
                else if (dataType == DataType.MySql)
                {
                    LoadPlayerSQL(userid);
                }
                else
                {
                    LoadPlayerData(userid);
                }
            }
            catch (Exception e)
            {
                LogError(string.Format("Loading {0} got this error: {1}", userid, e.Message));
            }
        }

        void SavePlayerDatabase()
        {
            foreach (string userid in changedPlayersData)
            {
                try
                {
                    if (dataType == DataType.SQLite)
                    {
                        SavePlayerSQLite(userid);
                    }
                    else if (dataType == DataType.MySql)
                    {
                        SavePlayerSQL(userid);
                    }
                    else
                    {
                        SavePlayerData(userid);
                    }
                }
                catch (Exception e)
                {
                    Interface.Oxide.LogWarning(e.Message);
                }
            }
            changedPlayersData.Clear();
        }

        ////////////////////////////////////////////////////////////
        // Set / Get PlayerData
        ////////////////////////////////////////////////////////////

        void SetPlayerData(string userid, string key, object data, bool serializeData = false)
        {
            if (!isKnownPlayer(userid)) LoadPlayer(userid);


            if (data is List<string> || data is Dictionary<object, object> || serializeData == true)
            {
                data = JsonConvert.SerializeObject(data);
            }

            if (dataType == DataType.SQLite)
            {
                if (!isValidColumn(key))
                {
                    CreateNewColumn(key);
                }
                sqliteData[userid][key] = data.ToString();

            }
            else if (dataType == DataType.MySql)
            {
                if (!isValidColumn2(key))
                {
                    CreateNewColumn2(key);
                }
                sqlData[userid][key] = data.ToString();
            }
            else
            {
                var profile = playersData[userid];

                profile[key] = JsonConvert.SerializeObject(data);
                playersData[userid] = profile;
            }

            if (!changedPlayersData.Contains(userid))
                changedPlayersData.Add(userid);
        }

        object GetPlayerDataRaw(string userid, string key)
        {
            if (!isKnownPlayer(userid)) return null;

            if (dataType == DataType.SQLite)
            {
                if (!isValidColumn(key)) return null;
                if (sqliteData[userid] == null) return null;
                if (sqliteData[userid][key] == null) return null;
                return (string)sqliteData[userid][key];
            }
            else if (dataType == DataType.MySql)
            {
                if (!isValidColumn2(key)) return null;
                if (sqlData[userid] == null) return null;
                if (sqlData[userid][key] == null) return null;
                return (string)sqlData[userid][key];
            }
            else
            {
                var profile = playersData[userid];
                if (profile[key] == null) return null;
                return (string)profile[key];
            }
        }
        object GetPlayerData(string userid, string key)
        {
            if (!isKnownPlayer(userid)) return null;

            if (dataType == DataType.SQLite)
            {
                if (!isValidColumn(key)) return null;
                if (sqliteData[userid] == null) return null;
                if (sqliteData[userid][key] == null) return null;
                return sqliteData[userid][key];
            }
            else if (dataType == DataType.MySql)
            {
                if (!isValidColumn2(key)) return null;
                if (sqlData[userid] == null) return null;
                if (sqlData[userid][key] == null) return null;
                return sqlData[userid][key];
            }
            else
            {
                var profile = playersData[userid];
                if (profile[key] == null) return null;
                return JsonConvert.DeserializeObject((string)profile[key]);
            }
        }


        ////////////////////////////////////////////////////////////
        // Files
        ////////////////////////////////////////////////////////////

        public static DataFileSystem datafile = Interface.GetMod().DataFileSystem;

        string subDirectory = "playerdatabase/";

        Hash<string, DynamicConfigFile> playersData = new Hash<string, DynamicConfigFile>();

        StoredData storedData;

        class StoredData
        {
            public HashSet<string> knownPlayers = new HashSet<string>();

            public StoredData() { }
        }

        void LoadFiles()
        {
            try
            {
                storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("PlayerDatabase");
            }
            catch
            {
                storedData = new StoredData();
            }
            LoadPlayers();
        }

        void LoadPlayerData(string userid)
        {
            if (!storedData.knownPlayers.Contains(userid))
                storedData.knownPlayers.Add(userid);

            string path = subDirectory + userid;
            if (datafile.ExistsDatafile(path)) { }

            DynamicConfigFile profile = Interface.GetMod().DataFileSystem.GetDatafile(path);

            playersData[userid] = profile;
        }

        void SavePlayerData(string userid)
        {
            string path = subDirectory + userid;
            Interface.GetMod().DataFileSystem.SaveDatafile(path);
        }

        void SaveKnownPlayers()
        {
            Interface.GetMod().DataFileSystem.WriteObject("PlayerDatabase", storedData);
        }

        ////////////////////////////////////////////////////////////
        // SQLite
        ////////////////////////////////////////////////////////////

        Core.SQLite.Libraries.SQLite Sqlite = Interface.GetMod().GetLibrary<Core.SQLite.Libraries.SQLite>();
        Connection Sqlite_conn;

        List<string> sqliteColumns = new List<string>();

        Dictionary<string, Hash<string, string>> sqliteData = new Dictionary<string, Hash<string, string>>();

        bool isValidColumn(string column) => sqliteColumns.Contains(column);

        void CreateNewColumn(string column)
        {
            Sqlite.Insert(Core.Database.Sql.Builder.Append($"ALTER TABLE {sql_table} ADD COLUMN '{column}' TEXT"), Sqlite_conn);
            sqliteColumns.Add(column);
        }

        void LoadSQLite()
        {
            try
            {
                Sqlite_conn = Sqlite.OpenDb(sqlitename, this);
                if (Sqlite_conn == null)
                {
                    FatalError("Couldn't open the SQLite PlayerDatabase. ");
                    return;
                }
                Sqlite.Insert(Core.Database.Sql.Builder.Append($"CREATE TABLE IF NOT EXISTS {sql_table} ( id INTEGER NOT NULL PRIMARY KEY UNIQUE, userid TEXT );"), Sqlite_conn);
                Sqlite.Query(Core.Database.Sql.Builder.Append($"PRAGMA table_info({sql_table});"), Sqlite_conn, list =>
                {
                    if (list == null)
                    {
                        FatalError("Couldn't get columns. Database might be corrupted.");
                        return;
                    }
                    foreach (var entry in list)
                    {
                        sqliteColumns.Add((string)entry["name"]);
                    }

                });
                Sqlite.Query(Core.Database.Sql.Builder.Append($"SELECT userid from {sql_table}"), Sqlite_conn, list =>
                {
                    if (list == null) return;
                    foreach (var entry in list)
                    {
                        string steamid = (string)entry["userid"];
                        if (steamid != "0")
                        {
                            sqliteData.Add(steamid, new Hash<string, string>());
                        }
                    }
                    LoadPlayers();
                });
            }
            catch (Exception e)
            {
                FatalError(e.Message);
            }
        }

        void LoadPlayerSQLite(string userid)
        {
            if (!sqliteData.ContainsKey(userid)) { sqliteData.Add(userid, new Hash<string, string>()); }
            bool newplayer = true;
            Sqlite.Query(Core.Database.Sql.Builder.Append($"SELECT * from {sql_table} WHERE userid == {userid}"), Sqlite_conn, list =>
            {
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        foreach (var p in entry)
                        {
                            if (p.Value is string)
                            {
                                sqliteData[userid][p.Key] = (string)p.Value;
                            }
                        }
                        newplayer = false;
                    }
                }
                if (newplayer)
                {
                    sqliteData[userid]["userid"] = userid;
                    Sqlite.Insert(Core.Database.Sql.Builder.Append($"INSERT OR REPLACE INTO {sql_table} ( userid ) VALUES ( {userid} )"), Sqlite_conn);

                    changedPlayersData.Add(userid);
                }
            });
        }

        void SavePlayerSQLite(string userid)
        {
            var values = sqliteData[userid];
            var i = values.Count;
            string arg = string.Empty;
            var parms = new List<object>();
            foreach (var c in values)
            {
                arg += string.Format("{0}`{1}` = @{2}", arg == string.Empty ? string.Empty : ",", c.Key, parms.Count.ToString());
                parms.Add(c.Value);
            }
            Sqlite.Insert(Core.Database.Sql.Builder.Append($"UPDATE {sql_table} SET {arg} WHERE userid = {userid}", parms.ToArray()), Sqlite_conn);
        }


        ////////////////////////////////////////////////////////////
        // MySQL
        ////////////////////////////////////////////////////////////

        Core.MySql.Libraries.MySql Sql = Interface.GetMod().GetLibrary<Core.MySql.Libraries.MySql>();
        Connection Sql_conn;

        List<string> sqlColumns = new List<string>();

        Dictionary<string, Hash<string, string>> sqlData = new Dictionary<string, Hash<string, string>>();

        bool isValidColumn2(string column) => sqlColumns.Contains(column);

        void CreateNewColumn2(string column)
        {
            Sql.Insert(Core.Database.Sql.Builder.Append($"ALTER TABLE `{sql_table}` ADD `{column}` LONGTEXT"), Sql_conn);
            sqlColumns.Add(column);
        }

        void LoadMySQL()
        {
            try
            {
                Sql_conn = Sql.OpenDb(sql_host, sql_port, sql_db, sql_user, sql_pass, this);
                if (Sql_conn == null || Sql_conn.Con == null)
                {
                    FatalError("Couldn't open the SQLite PlayerDatabase: " + Sql_conn.Con.State.ToString());
                    return;
                }
                Sql.Insert(Core.Database.Sql.Builder.Append("SET NAMES utf8mb4"), Sql_conn);
                Sql.Insert(Core.Database.Sql.Builder.Append($"CREATE TABLE IF NOT EXISTS {sql_table} ( `id` int(11) NOT NULL, `userid` VARCHAR(17) NOT NULL );"), Sql_conn);
                Sql.Query(Core.Database.Sql.Builder.Append($"desc {sql_table};"), Sql_conn, list =>
                {
                    if (list == null)
                    {
                        FatalError("Couldn't get columns. Database might be corrupted.");
                        return;
                    }
                    foreach (var entry in list)
                    {
                        sqlColumns.Add((string)entry["Field"]);
                    }

                });
                Sql.Query(Core.Database.Sql.Builder.Append($"SELECT userid from {sql_table}"), Sql_conn, list =>
                {
                    if (list == null) return;
                    foreach (var entry in list)
                    {
                        string steamid = (string)entry["userid"];
                        if (steamid != "0")
                            sqlData.Add(steamid, new Hash<string, string>());
                    }
                    LoadPlayers();
                });
            }
            catch (Exception e)
            {
                FatalError(e.Message);
            }
        }

        void LoadPlayerSQL(string userid)
        {
            if (!sqlData.ContainsKey(userid)) sqlData.Add(userid, new Hash<string, string>());
            bool newplayer = true;
            Sql.Query(Core.Database.Sql.Builder.Append($"SELECT * from {sql_table} WHERE `userid` = '{userid}'"), Sql_conn, list =>
            {
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        foreach (var p in entry)
                        {
                            if (p.Value is string)
                            {
                                sqlData[userid][p.Key] = (string)p.Value;
                            }
                        }
                        newplayer = false;
                    }
                }
                if (newplayer)
                {
                    sqlData[userid]["userid"] = userid;
                    Sql.Insert(Core.Database.Sql.Builder.Append($"INSERT IGNORE INTO {sql_table} ( userid ) VALUES ( {userid} )"), Sql_conn);

                    changedPlayersData.Add(userid);
                }
            });
        }

        void SavePlayerSQL(string userid)
        {
            var values = sqlData[userid];

            string arg = string.Empty;
            var parms = new List<object>();
            foreach (var c in values)
            {
                arg += string.Format("{0}`{1}` = @{2}", arg == string.Empty ? string.Empty : ",", c.Key, parms.Count.ToString());
                parms.Add(c.Value);
            }

            Sql.Insert(Core.Database.Sql.Builder.Append($"UPDATE {sql_table} SET {arg} WHERE userid = {userid}", parms.ToArray()), Sql_conn);
        }
    }
}

// --- End of file: PlayerDatabase.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/private-admin-message ---
// --- Original File Path: P/PrivateAdminMessage/PrivateAdminMessage.cs ---

﻿using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Private Admin Message", "waayne", "0.2.0")]
    [Description("Allows admins to send private messages to players via console/chat")]
    internal class PrivateAdminMessage : CovalencePlugin
    {
        private const string PRIVATE_ADMIN_MESSAGE = "privateadminmessage.use";
        private const string PRIVATE_ADMIN_MESSAGE_RECEIVE = "privateadminmessage.receive";

        private void Init()
        {
            permission.RegisterPermission(PRIVATE_ADMIN_MESSAGE_RECEIVE, this);

            AddCovalenceCommand("privateadminmessage.pam", nameof(AdminToPlayerMessageCommand), PRIVATE_ADMIN_MESSAGE);
            AddCovalenceCommand("pam", nameof(AdminToPlayerMessageCommand), PRIVATE_ADMIN_MESSAGE);
            AddCovalenceCommand("am", nameof(PlayerToAdminMessageCommand));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SentYouToUser"] = "You to {0}: {1}",
                ["SentAdminToYou"] = "Admin to you: {0}\n(reply via /am <message>)",
                ["SentYouToAdmin"] = "You to Admin: {0}",
                ["SentUserToAdmin"] = "{0} to Admin: {1}",
                ["NoUserFoundOrOnline"] = "User not found or is currently not online",
                ["NoMessageProvided"] = "No message was provided",
                ["NoAdminOnline"] = "There is currently no admin online",
                ["Help"] = "Use /pam <name> <message> to write a message to an admin"
            }, this);
        }

        private void AdminToPlayerMessageCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length <= 0)
            {
                player.Reply(lang.GetMessage("Help", this, player.Id));
            }
            else if (args.Length == 1)
            {
                player.Reply(lang.GetMessage("NoMessageProvided", this, player.Id));
            }
            else if (args.Length > 1)
            {
                string receiverName = args[0];

                string message = args[1];
                for (var i = 2; i < args.Length; i++)
                    message += " " + args[i];

                IPlayer receiver = null;
                foreach (IPlayer connectedPlayer in covalence.Players.Connected)
                {
                    if (connectedPlayer.Name == receiverName)
                        receiver = connectedPlayer;
                }

                if (receiver == null)
                {
                    player.Reply(lang.GetMessage("NoUserFoundOrOnline", this, player.Id));
                    return;
                }

                if (!receiver.IsConnected)
                {
                    player.Reply(lang.GetMessage("NoUserFoundOrOnline", this, player.Id));
                    return;
                }

                receiver.Reply(string.Format(lang.GetMessage("SentAdminToYou", this, receiver.Id), message));
                player.Reply(string.Format(lang.GetMessage("SentYouToUser", this, player.Id), receiverName, message));
            }
        }

        private void PlayerToAdminMessageCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length <= 0)
            {
                player.Reply(lang.GetMessage("NoMessageProvided", this, player.Id));
                return;
            }
            
            string message = args[0];
            for (var i = 1; i < args.Length; i++)
                message += " " + args[i];

            var wasSent = false;

            foreach (IPlayer connectedPlayer in covalence.Players.Connected)
            {
                if (!connectedPlayer.HasPermission(PRIVATE_ADMIN_MESSAGE_RECEIVE))
                    continue;

                connectedPlayer.Reply(string.Format(lang.GetMessage("SentUserToAdmin", this, connectedPlayer.Id),
                    player.Name, message));

                wasSent = true;
            }

            player.Reply(wasSent
                ? string.Format(lang.GetMessage("SentYouToAdmin", this, player.Id), message)
                : string.Format(lang.GetMessage("NoAdminOnline", this, player.Id)));

            Log(string.Format(lang.GetMessage("SentUserToAdmin", this), player.Name, message));
        }
    }
}

// --- End of file: PrivateAdminMessage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/playtime-tracker ---
// --- Original File Path: P/PlaytimeTracker/PlaytimeTracker.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Playtime Tracker", "k1lly0u", "0.2.2")]
    [Description("Track player time spent on the server")]
    class PlaytimeTracker : CovalencePlugin
    {
        #region Fields        
        private StoredData storedData;
        private DynamicConfigFile data;

        private static Action<string, double> TimeReward;
        private static Action<string, string> ReferralReward;

        private static PluginTimers Timer;
        private static Plugin RewardPlugin;
        #endregion

        #region Oxide Hooks  
        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        void Init()
        {
            LoadData(); 
        }

        private void OnServerInitialized()
        {
            TimeReward = IssueReward;
            ReferralReward = IssueReward;

            Configuration.Reward.RegisterPermissions(this, permission);

            Timer = timer;

            ValididateRewardSystem();

            foreach (IPlayer user in players.Connected)
                OnUserConnected(user);

            TimedSaveData();
        }

        private void OnUserConnected(IPlayer user) => storedData.OnUserConnected(user);

        private void OnUserDisconnected(IPlayer user) => storedData.OnUserDisconnected(user);

        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin != null && plugin.Name.Equals(Configuration.Reward.Plugin, StringComparison.OrdinalIgnoreCase))
                RewardPlugin = plugin;
        }

        private void Unload()
        {
            SaveData();

            TimeReward = null;
            ReferralReward = null;

            Timer = null;
            RewardPlugin = null;
            Configuration = null;
        }
        #endregion

        #region Functions
        private void ValididateRewardSystem()
        {
            RewardPlugin = plugins.Find(Configuration.Reward.Plugin);

            if (RewardPlugin == null)
                PrintError("The selected reward system is not loaded. Unable to issue rewards");
        }

        private static double CurrentTime => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private static string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            int days = dateDifference.Days;
            int hours = dateDifference.Hours;
            hours += (days * 24);
            return string.Format("{0:00}h:{1:00}m:{2:00}s", hours, dateDifference.Minutes, dateDifference.Seconds);
        }
        #endregion

        #region Rewards
        internal void IssueReward(string id, double amount)
        {
            float multiplier = 1f;

            foreach (KeyValuePair<string, float> kvp in Configuration.Reward.CustomMultipliers)
            {
                if (permission.UserHasPermission(id, kvp.Key))
                {
                    if (kvp.Value > multiplier)
                        multiplier = kvp.Value;
                }
            }

            amount *= multiplier;

            switch (Configuration.Reward.Plugin)
            {
                case "ServerRewards":
                    RewardPlugin?.Call("AddPoints", ulong.Parse(id), (int)amount);
                    break;
                case "Economics":
                    RewardPlugin?.Call("Deposit", id, amount);
                    break;
                default:
                    break;
            }

            IPlayer user = players.FindPlayerById(id);
            if (user != null && user.IsConnected)
                Message(user, $"Reward.Given.{Configuration.Reward.Plugin}", (int)amount);
        }

        internal void IssueReward(string referrer, string referee)
        {
            IssueReward(referrer, Configuration.Reward.Referral.InviteReward);
            IssueReward(referee, Configuration.Reward.Referral.JoinReward);
        }
        #endregion

        #region Commands
        private double _nextTopUpdate;
        private List<StoredData.UserData> topList = new List<StoredData.UserData>();

        [Command("playtime")]
        private void cmdPlaytime(IPlayer user, string command, string[] args)
        {
            if (args.Length == 0)
            {
                double time = storedData.GetPlayTimeForPlayer(user.Id);
                double afkTime = storedData.GetAFKTimeForPlayer(user.Id);

                if (time == 0 && afkTime == 0)
                    Message(user, "Error.NoPlaytimeStored");
                else
                {
                    if (Configuration.General.TrackAFK)
                        Message(user, "Playtime.Both", FormatTime(time), FormatTime(afkTime));
                    else Message(user, "Playtime.Single", FormatTime(time));
                }

                Message(user, "Playtime.Help");
                return;
            }

            switch (args[0].ToLower())
            {
                case "top":
                    string str = lang.GetMessage("Top.Title", this, user.Id);

                    if (CurrentTime > _nextTopUpdate)
                    {
                        storedData.GetTopPlayTime(topList);
                        _nextTopUpdate = CurrentTime + 60f;
                    }

                    for (int i = 0; i < Math.Min(Configuration.General.TopCount, topList.Count); i++)
                        str += string.Format(lang.GetMessage("Top.Format", this), topList[i].displayName, FormatTime(topList[i].playtime));

                    user.Reply(str);
                    return;
                default:
                    if (user.IsAdmin)
                    {
                        IPlayer target = players.FindPlayer(args[0]);
                        if (target == null)
                        {
                            Message(user, "Error.NoPlayerFound", args[0]);
                            return;
                        }
                        double time = storedData.GetPlayTimeForPlayer(target.Id);
                        if (time == 0)
                        {
                            Message(user, "Error.NoTimeStored");
                            return;
                        }

                        user.Reply($"{target.Name} - {FormatTime(time)}");
                    }
                    else Message(user, "Error.InvalidSyntax");
                    break;
            }
        }

        [Command("refer")]
        private void cmdRefer(IPlayer user, string command, string[] args)
        {
            if (!Configuration.Reward.Referral.Enabled)
            {
                Message(user, "Referral.Disabled");
                return;
            }

            if (args.Length == 0)
            {
                Message(user, "Referral.Help");
                return;
            }

            if (storedData.HasBeenReferred(user.Id))
            {
                Message(user, "Referral.Submitted");
                return;
            }

            IPlayer referrer = players.FindPlayer(args[0]);
            if (referrer == null)
            {
                Message(user, "Error.NoPlayerFound", args[0]);
                return; 
            }

            if (referrer.Id.Equals(user.Id))
            {
                Message(user, "Referral.Self");
                return;
            }

            storedData.ReferPlayer(referrer.Id, user.Id);

            Message(user, "Referral.Accepted");

            if (referrer.IsConnected)
                Message(referrer, "Referral.Acknowledged", user.Name);
        }
        #endregion

        #region API
        private object GetPlayTime(string id)
        {
            double time = storedData.GetPlayTimeForPlayer(id);
            return time == 0 ? null : (object)time;
        }

        private object GetAFKTime(string id)
        {
            double time = storedData.GetAFKTimeForPlayer(id);
            return time == 0 ? null : (object)time;
        }

        private object GetReferrals(string id)
        {
            int amount = storedData.GetReferralsForPlayer(id);
            return amount == 0 ? null : (object)amount;
        }
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "General Options")]
            public GeneralOptions General { get; set; }

            [JsonProperty(PropertyName = "Reward Options")]
            public RewardOptions Reward { get; set; }

            public class GeneralOptions
            {
                [JsonProperty(PropertyName = "Data save interval (seconds)")]
                public int SaveInterval { get; set; }

                [JsonProperty(PropertyName = "Track player AFK time")]
                public bool TrackAFK { get; set; }

                [JsonProperty(PropertyName = "Number of entries to display in the top playtime list")]
                public int TopCount { get; set; }
            }
            public class RewardOptions
            {
                [JsonProperty(PropertyName = "Reward plugin (ServerRewards, Economics)")]
                public string Plugin { get; set; }

                [JsonProperty(PropertyName = "Playtime rewards")]
                public PlaytimeRewards Playtime { get; set; }

                [JsonProperty(PropertyName = "Referral rewards")]
                public ReferralRewards Referral { get; set; }

                [JsonProperty(PropertyName = "Custom reward multipliers (permission / multiplier)")]
                public Hash<string, float> CustomMultipliers { get; set; }


                public class PlaytimeRewards
                {
                    [JsonProperty(PropertyName = "Issue rewards for playtime")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Reward interval (seconds)")]
                    public int Interval { get; set; }

                    [JsonProperty(PropertyName = "Reward amount")]
                    public int Reward { get; set; }
                }

                public class ReferralRewards
                {
                    [JsonProperty(PropertyName = "Issue rewards for player referrals")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Referrer reward amount")]
                    public int InviteReward { get; set; }

                    [JsonProperty(PropertyName = "Referee reward amount")]
                    public int JoinReward { get; set; }
                }

                [JsonIgnore]
                private Permission permission;

                internal void RegisterPermissions(CovalencePlugin plugin, Permission permission)
                {
                    this.permission = permission;

                    foreach (string str in CustomMultipliers.Keys)
                        permission.RegisterPermission(str, plugin);
                }
            }

            public VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                General = new ConfigData.GeneralOptions
                {
                    SaveInterval = 900,
                    TrackAFK = true,
                    TopCount = 10
                },
                Reward = new ConfigData.RewardOptions
                {
                    Plugin = "Economics",
                    Playtime = new ConfigData.RewardOptions.PlaytimeRewards
                    {
                        Enabled = true,
                        Interval = 3600,
                        Reward = 5
                    },
                    Referral = new ConfigData.RewardOptions.ReferralRewards
                    {
                        Enabled = true,
                        InviteReward = 5,
                        JoinReward = 3
                    },
                    CustomMultipliers = new Hash<string, float>
                    {
                        ["playtimetracker.examplevip1"] = 1.5f,
                        ["playtimetracker.examplevip2"] = 2.0f,
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            if (Configuration.Version < new VersionNumber(0, 2, 0))
                Configuration = GetBaseConfig();

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management
        private void TimedSaveData()
        {
            timer.In(Configuration.General.SaveInterval, () =>
            {
                SaveData();
                TimedSaveData();
            });
        }

        private void SaveData() => data.WriteObject(storedData);

        private void LoadData()
        {
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("PlaytimeTracker/user_data") && Interface.Oxide.DataFileSystem.ExistsDatafile("PTTracker/playtime_data"))
                RestoreOldData();
            else
            {
                data = Interface.Oxide.DataFileSystem.GetFile("PlaytimeTracker/user_data");
                storedData = data.ReadObject<StoredData>();
                if (storedData == null)
                    storedData = new StoredData();
            }
        }

        [Command("ptt.restorenames")]
        private void FindMissingNames(IPlayer player, string message, string[] args)
        {
            if (!player.IsAdmin)
                return;

            int missing = 0;
            int restored = 0;
            foreach (KeyValuePair<string, StoredData.UserData> kvp in storedData._userData)
            {
                if (string.IsNullOrEmpty(kvp.Value.displayName))
                {
                    missing++;
                    IPlayer user = players.FindPlayerById(kvp.Key);
                    if (user != null)
                    {
                        if (!string.IsNullOrEmpty(user.Name))
                        {
                            restored++;
                            kvp.Value.displayName = user.Name;
                        }
                        else kvp.Value.displayName = "Unnamed";
                    }
                }
            }

            player.Reply($"Restored {restored}/{missing} names");
        }

        private class StoredData
        {
            [JsonProperty]
            internal Hash<string, UserData> _userData = new Hash<string, UserData>();

            [JsonProperty]
            internal HashSet<string> _referredUsers = new HashSet<string>();

            public bool HasBeenReferred(string id) => _referredUsers.Contains(id);

            public void ReferPlayer(string referrer, string referree)
            {
                _referredUsers.Add(referree);

                UserData userData;
                if (!_userData.TryGetValue(referrer, out userData))
                    userData = _userData[referrer] = new UserData();

                userData.referrals += 1;

                ReferralReward(referrer, referree);
            }

            public void OnUserConnected(IPlayer user)
            {
                UserData userData;
                if (!_userData.TryGetValue(user.Id, out userData))
                    userData = _userData[user.Id] = new UserData();

                userData.OnUserConnected(user);
            }

            public void OnUserDisconnected(IPlayer user)
            {
                UserData userData;
                if (_userData.TryGetValue(user.Id, out userData))
                    userData.OnUserDisconnected();
            }

            public double GetPlayTimeForPlayer(string id)
            {
                UserData userData;
                if (!_userData.TryGetValue(id, out userData))
                    return 0;

                return userData.PlayTime;
            }

            public double GetAFKTimeForPlayer(string id)
            {
                UserData userData;
                if (!_userData.TryGetValue(id, out userData))
                    return 0;

                return userData.AFKTime;
            }

            public int GetReferralsForPlayer(string id)
            {
                UserData userData;
                if (!_userData.TryGetValue(id, out userData))
                    return 0;

                return userData.referrals;
            }

            public void GetTopPlayTime(List<UserData> list)
            {
                list.Clear();
                list.AddRange(_userData.Values);

                list.Sort((UserData a, UserData b) =>
                {
                    return a.playtime.CompareTo(b.playtime) * -1;
                });
            }

            internal void InsertData(string id, string displayName, double playTime, double afkTime, double lastReward, int referrals)
            {
                UserData userData;
                if (!_userData.TryGetValue(id, out userData))
                    userData = _userData[id] = new UserData();

                userData.displayName = displayName;
                userData.playtime = playTime;
                userData.afkTime = afkTime;
                userData.lastRewardTime = playTime;
                userData.referrals = referrals;
            }

            internal void InsertReferral(string id)
            {
                _referredUsers.Add(id);
            }

            public class UserData
            {
                public double playtime;
                public double afkTime;
                public double lastRewardTime;
                public int referrals;

                public string displayName;

                [JsonIgnore]
                private IPlayer _user;

                [JsonIgnore]
                private Timer _timer;

                [JsonIgnore]
                private double _timeStarted;

                [JsonIgnore]
                private GenericPosition _lastPosition = new GenericPosition();

                private const float TIMER_INTERVAL = 30f;

                public double PlayTime
                {
                    get
                    {
                        if (_user == null || !_user.IsConnected)
                            return playtime;
                        return playtime + (_user.Position() != _lastPosition ? (CurrentTime - _timeStarted) : 0);
                    }
                }

                public double AFKTime
                {
                    get
                    {
                        if (_user == null || !_user.IsConnected)
                            return afkTime;
                        return afkTime + (_user.Position() == _lastPosition ? (CurrentTime - _timeStarted) : 0);
                    }
                }

                public void OnUserConnected(IPlayer user)
                {
                    displayName = user.Name;

                    _user = user;

                    _lastPosition = user.Position();

                    if (_timer != null)
                        OnUserDisconnected();

                    StartTimer();
                }

                private void StartTimer()
                {
                    _timeStarted = CurrentTime;
                    _timer = Timer.In(TIMER_INTERVAL, OnTimerTick);
                }

                public void OnUserDisconnected()
                {
                    _timer.Destroy();
                    _timer = null;
                }

                private void OnTimerTick()
                {
                    if (_user != null && _user.IsConnected)
                    {
                        if (Configuration.General.TrackAFK && _user != null)
                        {
                            if (EqualPosition(_user.Position(), _lastPosition))
                                afkTime += TIMER_INTERVAL;
                            else playtime += TIMER_INTERVAL;

                            _lastPosition = _user.Position();
                        }
                        else playtime += TIMER_INTERVAL;

                        if (RewardPlugin != null && Configuration.Reward.Playtime.Enabled)
                        {
                            double rewardMultiplier = (playtime - lastRewardTime) / Configuration.Reward.Playtime.Interval;
                            if (rewardMultiplier >= 1f)
                            {
                                TimeReward(_user.Id, (double)Configuration.Reward.Playtime.Reward * rewardMultiplier);
                                lastRewardTime = playtime;
                            }
                        }
                    }

                    StartTimer();
                }

                private bool EqualPosition(GenericPosition a, GenericPosition b)
                {
                    if (a == null || b == null)
                        return false;

                    return Math.Abs(a.X - b.X) <= (Math.Abs(a.X) + Math.Abs(b.X) + 1) * float.Epsilon &&
                           Math.Abs(a.Y - b.Y) <= (Math.Abs(a.Y) + Math.Abs(b.Y) + 1) * float.Epsilon &&
                           Math.Abs(a.Z - b.Z) <= (Math.Abs(a.Z) + Math.Abs(b.Z) + 1) * float.Epsilon;
                }
            }
        }

        #region Data Converter
        private void RestoreOldData()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("PlaytimeTracker/user_data");
            storedData = new StoredData();

            LoadOldData();

            foreach (KeyValuePair<string, PlayData.TimeInfo> kvp in playData.timeData)
            {
                IPlayer player = players.FindPlayerById(kvp.Key);
                storedData.InsertData(kvp.Key, player?.Name ?? "Unnamed", kvp.Value.playTime, kvp.Value.afkTime, kvp.Value.lastReward, kvp.Value.referrals);
            }

            foreach (string str in referData.referrals)
                storedData.InsertReferral(str);

            if (permData.permissions.Count > 0)
            {
                foreach (KeyValuePair<string, float> kvp in permData.permissions)
                    Configuration.Reward.CustomMultipliers[kvp.Key] = kvp.Value;

                Configuration.Reward.RegisterPermissions(this, permission);

                SaveConfig();
            }

            playData = null;
            referData = null;
            permData = null;

            SaveData();
        }

        private void LoadOldData()
        {
            TimeData = Interface.Oxide.DataFileSystem.GetFile("PTTracker/playtime_data");
            PermissionData = Interface.Oxide.DataFileSystem.GetFile("PTTracker/permission_data");
            ReferralData = Interface.Oxide.DataFileSystem.GetFile("PTTracker/referral_data");

            playData = TimeData.ReadObject<PlayData>();
            if (playData == null)
                playData = new PlayData();

            referData = ReferralData.ReadObject<RefData>();
            if (referData == null)
                referData = new RefData();

            permData = PermissionData.ReadObject<PermData>();
            if (permData == null)
                permData = new PermData();
        }

        private PlayData playData;
        private PermData permData;
        private RefData referData;

        private DynamicConfigFile TimeData;
        private DynamicConfigFile PermissionData;
        private DynamicConfigFile ReferralData;

        private class PlayData
        {
            public Dictionary<string, TimeInfo> timeData = new Dictionary<string, TimeInfo>();

            public class TimeInfo
            {
                public double playTime;
                public double afkTime;
                public double lastReward;
                public int referrals;
            }
        }

        private class PermData
        {
            public Dictionary<string, float> permissions = new Dictionary<string, float>();
        }

        private class RefData
        {
            public List<string> referrals = new List<string>();
        }
        #endregion
        #endregion

        #region Localization
        private void Message(IPlayer user, string key, params object[] args)
        {
            if (args == null || args.Length == 0)
                user.Reply(lang.GetMessage(key, this, user.Id));
            else user.Reply(string.Format(lang.GetMessage(key, this, user.Id), args));
        }

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Playtime.Both"] = "[#45b6fe]Playtime[/#] : [#ffd479]{0}[/#]\n[#45b6fe]AFK Time[/#] : [#ffd479]{1}[/#]",
            ["Playtime.Single"] = "[#45b6fe]Playtime[/#] : [#ffd479]{0}[/#]",
            ["Playtime.Help"] = "You can see the top scoring playtimes by typing [#a1ff46]/playtime top[/#]",
            ["Top.Title"] = "[#45b6fe]Top Playtimes:[/#]",
            ["Top.Format"] = "\n[#a1ff46]{0}[/#] - [#ffd479]{1}[/#]",

            ["Referral.Disabled"] = "The referral system is disabled",
            ["Referral.Help"] = "[#ffd479]/refer <name or ID>[/#] - Add a referral for the specified player",
            ["Referral.Submitted"] = "You have already submitted your referral",
            ["Referral.Self"] = "You can not refer yourself",
            ["Referral.Accepted"] = "Your referral has been accepted",
            ["Referral.Acknowledged"] = "[#a1ff46]{0}[/#] has acknowledged a referral from you",

            ["Reward.Given.ServerRewards"] = "You have received [#a1ff46]{0} RP[/#] for playing on our server!",
            ["Reward.Given.Economics"] = "You have received [#a1ff46]{0}[/#] coins for playing on our server!",

            ["Error.NoPlaytimeStored"] = "No playtime has been stored for you yet",
            ["Error.NoPlayerFound"] = "No player found with the name [#a1ff46]{0}[/#]",
            ["Error.NoTimeStored"] = "No time stored for the specified player",
            ["Error.InvalidSyntax"] = "Invalid syntax",
        };
        #endregion
    }
}


// --- End of file: PlaytimeTracker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/pound-bot-raid-alerts ---
// --- Original File Path: P/PoundBotRaidAlerts/PoundBotRaidAlerts.cs ---

// Requires: PoundBot

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
  [Info("Pound Bot Raid Alerts", "MrPoundsign", "2.0.4")]
  [Description("Raid Alerts for use with PoundBot")]

  class PoundBotRaidAlerts : CovalencePlugin
  {
    [PluginReference]
    private Plugin PoundBot;

    private bool ShowOwnDamage;
    private bool PermittedOnly;
    const string RaidAlertsPermission = "poundbotraidalerts.alert";
    const string RaidAlertsTestPermission = "poundbotraidalerts.test";

    #region Language
    protected override void LoadDefaultMessages()
    {
      lang.RegisterMessages(new Dictionary<string, string>
      {
        ["config.upgrading"] = "Upgrading config to v{0}",
        ["config.show_own_damage"] = "debug.show_own_damage is {0}",
        ["config.permitted_only"] = "permitted_only.enabled is {0}",
        ["command.raid_alerts_test"] = "rat",
      }, this);
    }
    #endregion

    private void Init()
    {
      permission.RegisterPermission(RaidAlertsPermission, this);
      permission.RegisterPermission(RaidAlertsTestPermission, this);

      AddLocalizedCommand("command.raid_alerts_test", "CommandRaidAlertsTest", RaidAlertsTestPermission);
    }

    void OnServerInitialized()
    {
      UpgradeConfig();
      ApplyConfig();
    }

    #region Configuration
    protected override void LoadDefaultConfig()
    {
      Config["config.version"] = 3;
      Config["debug.show_own_damage"] = false;
      Config["permitted_only.enabled"] = false;
    }

    private void ApplyConfig()
    {
      ShowOwnDamage = (bool)Config["debug.show_own_damage"];
      PermittedOnly = (bool)Config["permitted_only.enabled"];
    }

    void UpgradeConfig()
    {
      string cvKey = "config.version";
      bool dirty = false;

      if (Config[cvKey] == null)
      {
        Config[cvKey] = 1;
      }
      else
      {
        try
        {
          var foo = (string)Config[cvKey];
          Config[cvKey] = 2;
          dirty = true;
        }
        catch (InvalidCastException) { } // testing if it can be converted to a string or not. No need to change it because it's not a string.
      }

      int currentVersion = (int)Config[cvKey];

      if (currentVersion < 2)
      {
        if (Config["show_own_damage"] != null)
        {
          Config["debug.show_own_damage"] = (bool)Config["show_own_damage"];
        }
        else
        {
          Config["debug.show_own_damage"] = false;
        }
        Config.Remove("show_own_damage");
        Config["permitted_only.enabled"] = false;
        dirty = true;
      }

      if (currentVersion < 3)
      {
        Puts(string.Format(lang.GetMessage("config.upgrading", this), 3));
        Config.Remove("permitted_only.group");
        Config[cvKey] = 3;
        dirty = true;
      }

      if (dirty)
      {
        SaveConfig();
      }
    }
    #endregion

    void OnEntityDeath(BaseEntity victim, HitInfo info)
    {
      if (!(victim is DecayEntity) &&
        !(victim is StorageContainer) &&
        !(victim is BaseVehicle)
      ) return;

      SendEntityDeath(victim, info?.Initiator);
    }

    void SendEntityDeath(BaseEntity entity, BaseEntity initiator, bool test = false)
    {
      if (entity == null) return;
      if (initiator == null) return;
      if (initiator is Scientist) return;
      if (initiator is NPCMurderer) return;
      if (initiator is BasePlayer)
      {
        string[] w = entity.ShortPrefabName.Split('/');
        string n = w[w.Length - 1].Split('.')[0];

        int eid = entity.GetInstanceID();

        if (test) n = $"[TEST_{n}:{eid}]";

        if (!test && entity.OwnerID == 0)
        {
          if (test) Puts($"{n} Could not find owner. Not sending alert.");
          return;
        }
        BasePlayer player = (BasePlayer)initiator;

        if (!test && !ShowOwnDamage && entity.OwnerID == player.userID)
        {
          if (test) Puts($"{n} Show own damage is false. Not sending alert.");
          return;
        }

        BuildingPrivlidge priv = entity.GetBuildingPrivilege();
        string[] ownerIDs;

        if (priv != null)
        {
          if (test) Puts($"{n} Checking building privs");
          ownerIDs = priv.authorizedPlayers.Select(p => { return p.userid.ToString(); }).ToArray();
        }
        else
        {
          if (test)
          {
            Puts($"{n} setting owners IDs to testing user");
            ownerIDs = new string[] { player.userID.ToString() };
          }
          else
          {
            ownerIDs = new string[] { entity.OwnerID.ToString() };
          }
        }

        if (test) Puts($"{n} ownerIDs are {String.Join(",", ownerIDs)}");

        if (test) Puts($"{n} Registered Players Group is {(string)PoundBot.Call("API_RegisteredUsersGroup")}");

        // Filter Owners to those who are registered with PoundBot
        string[] registeredPlayerIDs = permission.GetUsersInGroup((string)PoundBot.Call("API_RegisteredUsersGroup"));

        for (int i = 0; i < registeredPlayerIDs.Length; i++)
        {
          registeredPlayerIDs[i] = registeredPlayerIDs[i].Substring(0, registeredPlayerIDs[i].IndexOf(' '));
        }

        if (test) Puts($"{n} rgisteredPlayersIDs are {String.Join(",", registeredPlayerIDs)}");

        ownerIDs = ownerIDs.Intersect(registeredPlayerIDs).ToArray();

        if (test) Puts($"{n} intersecting ownerIDs are {String.Join(",", ownerIDs)}");

        if (PermittedOnly)
        {
          if (test) Puts($"{n} PermittedOnly is true. Checking perms.");
          ownerIDs = ownerIDs.Where(ownerID => permission.UserHasPermission(ownerID, RaidAlertsPermission)).ToArray();
        }

        if (ownerIDs.Length == 0)
        {
          if (test) Puts($"{n} Owners length is 0. Not sending alert.");
          return;
        }

        if (test) Puts($"{n} Sending entity death to PoundBot");

        Func<int, string, bool> callback = EntityDeathHandler;

        PoundBot.Call(
          "API_SendEntityDeath", new object[] { this, n, GridPos(entity), ownerIDs, callback }
        );
      }
    }

    private bool EntityDeathHandler(int code, string response) => (code == 200);

    private string GridPos(BaseEntity entity)
    {
      var size = World.Size / 2;
      var gridCellSize = 150;
      var num2 = (int)(entity.transform.position.x + size) / gridCellSize;
      var index = Math.Abs((int)(entity.transform.position.z - size) / gridCellSize);
      return NumberToLetter(num2) + index.ToString();
    }

    public string NumberToLetter(int num)
    {
      int num1 = (int)Math.Floor((double)(num / 26));
      int num2 = num % 26;
      string empty = string.Empty;
      if (num1 > 0)
      {
        for (int index = 0; index < num1; ++index)
          empty += Convert.ToChar(65 + index).ToString();
      }
      return empty + Convert.ToChar(65 + num2).ToString();
    }

    #region Helpers
    private void AddLocalizedCommand(string key, string command, string perm = null)
    {
      foreach (var language in lang.GetLanguages(this))
      {
        var messages = lang.GetMessages(language, this);
        foreach (var message in messages.Where(m => m.Key.Equals(key)))
          if (!string.IsNullOrEmpty(message.Value)) AddCovalenceCommand(message.Value, command, perm);
      }
    }
    #endregion

    #region Commands
    //[Command("rat"), Permission(RaidAlertsTestPermission)]
    private void CommandRaidAlertsTest(IPlayer iplayer, string command, string[] args)
    {
      BasePlayer p = iplayer.Object as BasePlayer;
      // RaidAlertsTestPermission

      RaycastHit raycastHit;
      BaseEntity targetEntity;

      bool flag = Physics.Raycast(p.eyes.HeadRay(), out raycastHit, 500f, Rust.Layers.Solid);
      targetEntity = flag ? raycastHit.GetEntity() : null;

      Puts($"targetEntity is {targetEntity}");

      if (targetEntity != null) SendEntityDeath(targetEntity, p, true);

    }

    [Command("pb.ra.show_own_damage")]
    private void ConsoleCommandShowOwnDamage(IPlayer player, string command, string[] args)
    {
      if (args.Length == 1)
      {
        Config["debug.show_own_damage"] = (args[0] == "1" || args[0] == "true");
        SaveConfig();
        ApplyConfig();
      }
      Puts(string.Format(lang.GetMessage("config.show_own_damage", this), ShowOwnDamage));
    }

    [Command("pb.ra.permitted_only")]
    private void ConsoleCommandPermittedOnly(IPlayer player, string command, string[] args)
    {
      if (args.Length == 1)
      {
        Config["permitted_only.enabled"] = (args[0] == "1" || args[0] == "true");
        SaveConfig();
        ApplyConfig();
      }

      Puts(string.Format(lang.GetMessage("config.permitted_only", this), PermittedOnly));
    }
    #endregion
  }
}

// --- End of file: PoundBotRaidAlerts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-demos ---
// --- Original File Path: P/PlayerDemos/PlayerDemos.cs ---

using System;
using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Player Demos", "OfficerJAKE", "1.1.5")]
    [Description("Allow players to record demo files to the server, and more")]
    public class PlayerDemos : RustPlugin
    {

        #region Global Vars

        public const string PERM_ALLOW = "playerdemos.allow";
        public const string PERM_ADMIN = "playerdemos.admin";
        public const string CHAT_COMMAND_START = "pd.start";
        public const string CHAT_COMMAND_STOP = "pd.stop";
        public const string CHAT_COMMAND_ADMIN_START = "pda.start";
        public const string CHAT_COMMAND_ADMIN_STOP = "pda.stop";
        public const string CHAT_COMMAND_ADMIN_STOP_ALL = "pda.stopall";

        #endregion Global Vars

        #region Configuration

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Global settings")]
            public GlobalSettings globalSettings = new GlobalSettings();

            public class GlobalSettings
            {
				
                [JsonProperty(PropertyName = "Log To Console")]
                public bool LogToConsole = false;
				
                [JsonProperty(PropertyName = "Alert Player")]
                public bool AlertPlayer = false;
				
                [JsonProperty(PropertyName = "Max record time")]
                public float MaxDemoRecordTime = 1800F;
				
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }
        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CHAT_PREFIX"] = "<color=#359bf2>PLAYER DEMOS: </color>",
                ["NO_PERMS"] = "You do not have permission to use this command",
                ["DEMO_STARTED"] = "You have started a demo recording",
                ["DEMO_STOPPED"] = "Your demo recording has stopped",
                ["DEMO_STARTED_LOG"] = "{0} has started a demo recording",
                ["DEMO_STOPPED_LOG"] = "{0} has stopped a demo recording",
                ["ARG_ERROR"] = "<color=#ff0000>ERROR</color> You cannot supply arguments with this command",
                ["ADMIN_ARG_ERROR"] = "<color=#ff0000>ERROR</color> Usage: /admindemo STEAMID",
                ["INCORRECT_ID"] = "{0} does not appear to be a valid steamid",
                ["NO_PLAYER_ONLINE"] = "Could not find online player: {0}",
                ["PLAYER_FOUND"] = "Player was found with name: {0}",
                ["ADMIN_DEMO_STARTED"] = "{0} Started a demo for {1}",
                ["ADMIN_DEMO_STOPPED"] = "{0} Stopped a demo for {1}",
                ["PLAYER_ALERT_STARTED"] = "An admin started recording you",
                ["PLAYER_ALERT_STOPPED"] = "An admin stopped recording you",
                ["PLAYER_NOT_RECORDING"] = "Cannot stop recording, {0} is not recording",
				["YOU_ARE_NOT_RECORDING"] = "You are not recording, we cannot stop",
                ["ALL_DEMOS_STOPPED"] = "All demo recordings have been stopped",
                ["ALL_DEMOS_STOPPED_LOG"] = "All demo recordings have been stopped by {0}",
                //		[""] = "",
            }, this);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion Localization

        #region Chat Commands

        [ChatCommand(CHAT_COMMAND_START)]
        private void ChatCommandDemoStart(BasePlayer player, string command, string[] args)
        {
			
            if (!permission.UserHasPermission(player.UserIDString, PERM_ALLOW))
            {
                player.ChatMessage(Lang("CHAT_PREFIX") + Lang("NO_PERMS"));
                return;
            }
			
            if (args.Length > 0)
            {
                player.ChatMessage(Lang("CHAT_PREFIX") + Lang("ARG_ERROR"));
                return;
            }

            StartRecordingDemo(player);

        }

        [ChatCommand(CHAT_COMMAND_STOP)]
        private void ChatCommandDemoStop(BasePlayer player, string command, string[] args)
        {
			
            if (!permission.UserHasPermission(player.UserIDString, PERM_ALLOW))
            {
                player.ChatMessage(Lang("CHAT_PREFIX") + Lang("NO_PERMS"));
                return;
            }
			
            if (args.Length > 0)
            {
                player.ChatMessage(Lang("CHAT_PREFIX") + Lang("ARG_ERROR"));
                return;
            }
			
			if(!player.Connection.IsRecording)
			{
				player.ChatMessage(Lang("CHAT_PREFIX") + Lang("YOU_ARE_NOT_RECORDING"));
                return;
			}
			
            StopRecordingDemo(player);

        }

        [ChatCommand(CHAT_COMMAND_ADMIN_START)]
        private void AdminStartDemo(BasePlayer player, string command, string[] args)
        {

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, PERM_ADMIN))
            {
				
                if (args.Length != 1)
                {
                    player.ChatMessage(Lang("CHAT_PREFIX") + Lang("ADMIN_ARG_ERROR"));
                    return;
                }

                string SentID = args[0];

                if (!SentID.StartsWith("7656119") || SentID.Length != 17)
                {
                    player.ChatMessage(Lang("CHAT_PREFIX") + Lang("INCORRECT_ID", null, SentID));
                    return;
                }

                ulong IdToRecord = Convert.ToUInt64(args[0]);
                BasePlayer WhoToRecord = BasePlayer.FindByID(IdToRecord);

                if (WhoToRecord == null)
                {
                    player.ChatMessage(Lang("CHAT_PREFIX") + Lang("NO_PLAYER_ONLINE", null, IdToRecord));
                    return;
                }

                StartAdminDemo(player, WhoToRecord);

            }
            else
            {
                player.ChatMessage(Lang("CHAT_PREFIX") + Lang("NO_PERMS"));
                return;
            }

        }

        [ChatCommand(CHAT_COMMAND_ADMIN_STOP)]
        private void AdminStopDemo(BasePlayer player, string command, string[] args)
        {
			
            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, PERM_ADMIN))
            {
				
                if (args.Length != 1)
                {
                    player.ChatMessage(Lang("CHAT_PREFIX") + Lang("ADMIN_ARG_ERROR"));
                    return;
                }

                string SentID = args[0];
                if (!SentID.StartsWith("7656119") || SentID.Length != 17)
                {
                    player.ChatMessage(Lang("CHAT_PREFIX") + Lang("INCORRECT_ID", null, SentID));
                    return;
                }

                ulong IdToRecord = Convert.ToUInt64(args[0]);
                BasePlayer WhoToRecord = BasePlayer.FindByID(IdToRecord);

                if (WhoToRecord == null)
                {
                    player.ChatMessage(Lang("CHAT_PREFIX") + Lang("NO_PLAYER_ONLINE", null, IdToRecord));
                    return;
                }

                if (!WhoToRecord.Connection.IsRecording)
                {
                    player.ChatMessage(Lang("PLAYER_NOT_RECORDING", null, WhoToRecord.UserIDString));
                    return;
                }

                StopAdminDemo(player, WhoToRecord);

            }
            else
            {
                player.ChatMessage(Lang("CHAT_PREFIX") + Lang("NO_PERMS"));
                return;
            }

        }

        [ChatCommand(CHAT_COMMAND_ADMIN_STOP_ALL)]
        private void AdminStopAllDemos(BasePlayer player, string command, string[] args)
        {
			
            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, PERM_ADMIN))
            {
                AdminStopAllDemos(player);
            }
            else
            {
                player.ChatMessage(Lang("CHAT_PREFIX") + Lang("NO_PERMS"));
                return;
            }
			
        }

        #endregion Chat Commands

        #region Hooks

        private void Unload()
        {
			
            foreach (var player in BasePlayer.activePlayerList)
            {
				
                if (player.Connection.IsRecording)
                {
                    player.Connection.StopRecording();
                }
				
            }
			
        }

        void Init()
        {
            permission.RegisterPermission(PERM_ALLOW, this);
            permission.RegisterPermission(PERM_ADMIN, this);
        }
		
        private void StartRecordingDemo(BasePlayer player)
        {
			
            if (configData.globalSettings.LogToConsole)
            {
                PrintWarning(Lang("DEMO_STARTED_LOG", null, player));
            }

            player.ChatMessage(Lang("CHAT_PREFIX") + Lang("DEMO_STARTED"));

            player.StartDemoRecording();
            timer.Once(configData.globalSettings.MaxDemoRecordTime, () => StopRecordingDemo(player));
			
        }

        private void StopRecordingDemo(BasePlayer player)
        {
			
            if (configData.globalSettings.LogToConsole)
            {
                PrintWarning(Lang("DEMO_STOPPED_LOG", null, player));
            }

            player.ChatMessage(Lang("CHAT_PREFIX") + Lang("DEMO_STOPPED"));
            player.StopDemoRecording();
			
        }

        private void StartAdminDemo(BasePlayer player, BasePlayer WhoToRecord)
        {
			
            if (configData.globalSettings.LogToConsole)
            {
                PrintWarning(Lang("ADMIN_DEMO_STARTED", null, player.displayName, WhoToRecord.displayName));
            }

            player.ChatMessage(Lang("CHAT_PREFIX") + Lang("ADMIN_DEMO_STARTED", null, player.displayName, WhoToRecord.UserIDString));

            if (configData.globalSettings.AlertPlayer)
            {
                WhoToRecord.ChatMessage(Lang("CHAT_PREFIX") + Lang("PLAYER_ALERT_STARTED"));
            }

            WhoToRecord.StartDemoRecording();
            timer.Once(configData.globalSettings.MaxDemoRecordTime, () => StopAdminDemo(player, WhoToRecord));

        }

        private void StopAdminDemo(BasePlayer player, BasePlayer WhoToRecord)
        {
			
            if (configData.globalSettings.LogToConsole)
            {
                PrintWarning(Lang("ADMIN_DEMO_STOPPED", null, player.displayName, WhoToRecord.displayName));
            }

            player.ChatMessage(Lang("CHAT_PREFIX") + Lang("ADMIN_DEMO_STOPPED", null, player.displayName, WhoToRecord.UserIDString));

            if (configData.globalSettings.AlertPlayer)
            {
                WhoToRecord.ChatMessage(Lang("CHAT_PREFIX") + Lang("PLAYER_ALERT_STOPPED"));
            }

            WhoToRecord.StopDemoRecording();

        }
		
		private void AdminStopAllDemos(BasePlayer player)
        {
			
            foreach (var Rplayer in BasePlayer.activePlayerList)
            {
				
                if (Rplayer.Connection.IsRecording)
                {
                    Rplayer.Connection.StopRecording();
                    Rplayer.ChatMessage(Lang("CHAT_PREFIX") + Lang("ALL_DEMOS_STOPPED"));

                    if (configData.globalSettings.LogToConsole)
                    {
                        PrintWarning(Lang("ALL_DEMOS_STOPPED_LOG", null, player));
                    }

                }
				
            }
			
        }
		
        #endregion Hooks

    }

}


// --- End of file: PlayerDemos.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ping ---
// --- Original File Path: P/Ping/Ping.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Ping", "Wulf/lukespragg", "1.8.0", ResourceId = 1921)]
    [Description("Ping chekcing on command and automatic kicking of players with high pings")]

    class Ping : CovalencePlugin
    {
        #region Initialization

        const string permBypass = "ping.bypass";
        const string permCheck = "ping.check";

        bool highPingKick;
        bool kickNotices;
        bool repeatChecking;
        bool warnBeforeKick;

        int highPingLimit;
        int kickGracePeriod;

        protected override void LoadDefaultConfig()
        {
            // Options
            Config["High Ping Kick (true/false)"] = highPingKick = GetConfig("High Ping Kick (true/false)", true);
            Config["Kick Notice Messages (true/false)"] = kickNotices = GetConfig("Kick Notice Messages (true/false)", true);
            Config["Repeat Checking (true/false)"] = repeatChecking = GetConfig("Repeat Checking (true/false)", true);
            Config["Warn Before Kicking (true/false)"] = warnBeforeKick = GetConfig("Warn Before Kicking (true/false)", true);

            // Settings
            Config["High Ping Limit (Milliseconds)"] = highPingLimit = GetConfig("High Ping Limit (Milliseconds)", 200);
            Config["Kick Grace Period (Seconds)"] = kickGracePeriod = GetConfig("Kick Grace Period (Seconds)", 30);

            SaveConfig();
        }

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["KickWarning"] = "You will be kicked in {0} seconds if your ping is not lowered",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PingTooHigh"] = "Ping is too high: {0}ms",
                ["PlayerKicked"] = "{0} kicked for high ping ({1}ms)",
                ["PlayerNotFound"] = "Player '{0}' was not found",
                ["PlayerPing"] = "{0} has a ping of {1}ms",
                ["YourPing"] = "You have a ping of {0}ms"
            }, this);

            // French
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["KickWarning"] = "Vous sera lancé dans {0} secondes si votre ping n’est pas abaissé",
                ["NotAllowed"] = "Vous n’êtes pas autorisé à utiliser la commande « {0} »",
                ["PingTooHigh"] = "Ping est trop élevée : {0} ms",
                ["PlayerKicked"] = "{0} expulsé pour ping élevé ({1} ms)",
                ["PlayerNotFound"] = "Player « {0} » n’a pas été trouvée",
                ["YourPing"] = "Vous avez un ping de {0} ms"
            }, this, "fr");

            // German
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["KickWarning"] = "Sie werden in {0} Sekunden gekickt wenn Ihr Ping nicht gesenkt wird",
                ["NotAllowed"] = "Sie sind nicht berechtigt, verwenden Sie den Befehl '{0}'",
                ["PingTooHigh"] = "Ping ist zu hoch: {0} ms",
                ["PlayerKicked"] = "{0} gekickt für hohen Ping ({1} ms)",
                ["PlayerNotFound"] = "Player '{0}' wurde nicht gefunden",
                ["YourPing"] = "Sie haben einen Ping von {0} ms"
            }, this, "de");

            // Russian
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["KickWarning"] = "Вам будет ногами в {0} секунд если пинг не опустил",
                ["NotAllowed"] = "Нельзя использовать команду «{0}»",
                ["PingTooHigh"] = "Пинг слишком высока: {0} ms",
                ["PlayerKicked"] = "{0} ногами высокий пинг ({1} ms)",
                ["PlayerNotFound"] = "Игрок «{0}» не найден",
                ["YourPing"] = "У вас пинг {0} ms"
            }, this, "ru");

            // Spanish
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["KickWarning"] = "Usted va ser pateado en {0} segundos si el ping no baja",
                ["NotAllowed"] = "No se permite utilizar el comando '{0}'",
                ["PingTooHigh"] = "Ping es demasiado alto: {0} ms",
                ["PlayerKicked"] = "{0} expulsado por ping alto ({1} ms)",
                ["PlayerNotFound"] = "Jugador '{0}' no se encontró",
                ["YourPing"] = "Tienes un ping de {0} ms"
            }, this, "es");
        }

        void Init()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();
            permission.RegisterPermission(permBypass, this);
            permission.RegisterPermission(permCheck, this);
        }

        #endregion

        #region Game Hooks

        void OnServerInitialized()
        {
            foreach (var player in players.Connected) timer.Once(5f, () => PingCheck(player));
        }

        void OnServerSave()
        {
            if (!repeatChecking) return;
            foreach (var player in players.Connected) timer.Once(5f, () => PingCheck(player));
        }

        void OnUserConnected(IPlayer player) => timer.Once(10f, () => PingCheck(player));

        #endregion

        #region Ping Checking

        void PingCheck(IPlayer player, bool warned = false)
        {
            if (!player.IsConnected || player.HasPermission(permBypass)) return;

            var ping = player.Ping;
            if (ping < highPingLimit || !highPingKick) return;

            if (warnBeforeKick && !warned)
            {
                player.Message(Lang("KickWarning", player.Id, kickGracePeriod));
                timer.Once(kickGracePeriod, () => PingCheck(player, true));
            }
            else
                PingKick(player, ping.ToString());
        }

        void PingKick(IPlayer player, string ping)
        {
            player.Kick(Lang("PingTooHigh", player.Id, ping));

            if (!kickNotices) return;
            Puts(Lang("PlayerKicked", null, player.Name, ping));
            server.Broadcast(Lang("PlayerKicked", null, player.Name, ping));
        }

        #endregion

        #region Commands

        [Command("ping", "pong")]
        void PingCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                player.Reply(Lang("YourPing", player.Id, player.Ping));
                return;
            }

            if (player.HasPermission(permCheck))
            {
                var target = players.FindPlayer(args[0]);
                if (target == null || !target.IsConnected)
                {
                    player.Reply(Lang("PlayerNotFound", player.Id, args[0]));
                    return;
                }

                player.Reply(Lang("PlayerPing", player.Id, target.Name, target.Ping));
            }
            else
                player.Reply(Lang("NotAllowed", player.Id, command));
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}

// --- End of file: Ping.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-effects ---
// --- Original File Path: P/PlayerEffects/PlayerEffects.cs ---

﻿/*
 ########### README ####################################################
                                                                             
  !!! DON'T EDIT THIS FILE !!!
                                                                     
 ########### CHANGES ###################################################

 1.0.0
    - Plugin release

 #######################################################################
*/

using System.Collections.Generic;
using UnityEngine;
using Oxide.Game.Rust.Libraries;
using VLB;

namespace Oxide.Plugins
{
    [Info("Player Effects", "paulsimik", "1.0.0")]
    [Description("Adds Effect to the Player")]
    class PlayerEffects : RustPlugin
    {
        private bool DEBUG = false;

        #region [Fields]

        private const string permUse = "playereffects.use";
        private const string MISSING_EFFECT = "assets/bundled/prefabs/fx/missing.prefab";
        private const string BARRICADE_EFFECT = "assets/bundled/prefabs/fx/door/barricade_spawn.prefab";
        private const string FIRE2_EFFECT = "assets/bundled/prefabs/fx/fire/fire_v2.prefab";

        #endregion

        #region [Oxide Hooks]

        private void Init() => permission.RegisterPermission(permUse, this);

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                DestroyPlayerComponent(player);
        }

        private void OnPlayerDisconnected(BasePlayer player) => DestroyPlayerComponent(player);

        #endregion

        #region [Hooks]   

        private PlayerEffect GetPlayer(BasePlayer player)
        {
            if (player == null)
                return null;

            var playerEffect = player.GetComponent<PlayerEffect>();
            if (playerEffect == null)
                return null;

            return playerEffect;
        }

        private void DestroyPlayerComponent(BasePlayer player)
        {
            PlayerEffect playerEffect = GetPlayer(player);
            if (playerEffect == null)
                return;

            UnityEngine.Object.Destroy(playerEffect);
        }

        private void AddEffect(PlayerEffect playerEffect, string typeEffect)
        {
            switch (typeEffect)
            {
                case "0":
                case "disable":
                case "disabled":
                    {
                        playerEffect.DestroyTimer();
                        SendReply(playerEffect.player, GetLang("Disable", playerEffect.player.UserIDString));                 
                        return;
                    }
                case "1":
                case "particles":
                    {
                        playerEffect.effect = MISSING_EFFECT;
                        playerEffect.effectPosition = Vector3.zero;
                        playerEffect.time = 1f;
                        playerEffect.DestroyTimer();
                        playerEffect.RunTimer();
                        SendReply(playerEffect.player, GetLang("Effect1", playerEffect.player.UserIDString));
                        return;
                    }
                case "2":
                case "smoke":
                    {
                        playerEffect.effect = BARRICADE_EFFECT;
                        playerEffect.effectPosition = Vector3.zero;
                        playerEffect.time = 0.2f;
                        playerEffect.DestroyTimer();
                        playerEffect.RunTimer();
                        SendReply(playerEffect.player, GetLang("Effect2", playerEffect.player.UserIDString));
                        return;
                    }
                case "3":
                case "fire":
                    {
                        playerEffect.effect = FIRE2_EFFECT;
                        playerEffect.effectPosition = new Vector3(0, 0, -1);
                        playerEffect.time = 8f;
                        playerEffect.DestroyTimer();
                        playerEffect.RunTimer();
                        SendReply(playerEffect.player, GetLang("Effect3", playerEffect.player.UserIDString));
                        return;
                    }
                case "help":
                    {
                        SendReply(playerEffect.player, GetLang("Help", playerEffect.player.UserIDString));
                        return;
                    }
                default:
                    SendReply(playerEffect.player, GetLang("Invalid", playerEffect.player.UserIDString));
                    return;
            }
        }

        #endregion

        #region [Chat Commands]

        [ChatCommand("pe")]
        private void cmdPlayerEffect(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player))
            {
                SendReply(player, GetLang("NoPerm", player.UserIDString));
                return;
            }

            PlayerEffect playerEffect = player.gameObject.GetOrAddComponent<PlayerEffect>();
            if (playerEffect == null)
                return;

            var type = args.Length > 0 ? args[0] : null;
            AddEffect(playerEffect, type);
        }

        #endregion

        #region [Classes]

        public class PlayerEffect : MonoBehaviour
        {
            public BasePlayer player;
            public string effect;
            public Vector3 effectPosition;
            public float time;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                effect = string.Empty;
                effectPosition = Vector3.zero;
                time = 1f;
            }

            public void RunTimer() => InvokeRepeating("RunEffect", 0.2f, time);

            public void DestroyTimer() => CancelInvoke("RunEffect");

            private void RunEffect()
            {
                if (string.IsNullOrEmpty(effect) || player == null)
                    return;

                Effect.server.Run(effect, player, 0, effectPosition, new Vector3(1, 0, 0), null, true);
            }

            private void OnDestroy()
            {
                DestroyTimer();
                Destroy(this); 
            }
        }

        #endregion

        #region [Localization]

        private string GetLang(string key, string playerID) => lang.GetMessage(key, this, playerID);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "NoPerm", "You don't have permissions" },
                { "Invalid", "Invalid syntax!\nType /pe help" },
                { "Disable", "Effect has been disabled" },
                { "Effect1", "Effect <color=#a8a6a6>'particles'</color> has been activated" },
                { "Effect2", "Effect <color=#a8a6a6>'smoke'</color> has been activated" },
                { "Effect3", "Effect <color=#a8a6a6>'fire'</color> has been activated" },
                { "Help", "<size=16><color=#3498db>Player Effects</color></size>" +
                "\n<color=#a8a6a6>/pe 0 or disable</color> - disable effect" +
                "\n<color=#a8a6a6>/pe 1 or particles</color> - particles effect" +
                "\n<color=#a8a6a6>/pe 2 or smoke</color> - smoke effect" +
                "\n<color=#a8a6a6>/pe 3 or fire</color> - fire effect" }

            }, this);
        }

        #endregion

        #region [Helpers]

        private bool HasPermission(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, permUse);
        }

        private void SendMessage(BasePlayer player, string msg) => Player.Message(player, msg);

        private void PrintDebug(object message)
        {
            if (!DEBUG)
                return;

            Debug.Log($"{this.Name} Debug: {message}");
        }

        #endregion
    }
}

// --- End of file: PlayerEffects.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/purifier-config ---
// --- Original File Path: P/PurifierConfig/PurifierConfig.cs ---

using System;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Purifier Config", "Shady", "1.0.4", ResourceId = 1911)]
    [Description("Tweak settings for water purifiers.")]
    class PurifierConfig : RustPlugin
    {
        bool init = false;
        #region Config
        int WPM;
        int WaterRatio;

        protected override void LoadDefaultConfig()
        {
            Config["WaterToProcessPerMinute"] = WPM = GetConfig("WaterToProcessPerMinute", 120);
            Config["FreshWaterRatio"] = WaterRatio = GetConfig("FreshWaterRatio", 4);
            SaveConfig();
        }
        #endregion
        #region Hooks
        void OnServerInitialized()
        {
            var purifiers = BaseEntity.serverEntities?.Where(p => p != null && (p is WaterPurifier))?.Select(p => p as WaterPurifier)?.ToList() ?? null;
            if (purifiers != null && purifiers.Count > 0)
            {
                for (int i = 0; i < purifiers.Count; i++) ConfigurePurifier(purifiers[i]);
                Puts("Configured " + purifiers.Count.ToString("N0") + " water purifiers successfully!");
            }
            init = true;
        }

        void Init() => LoadDefaultConfig();

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null || !init || !(entity is WaterPurifier)) return;
            var purifier = entity?.GetComponent<WaterPurifier>() ?? null;
            if (purifier != null) ConfigurePurifier(purifier);
        }
        #endregion
        #region ConfigurePurifiers
        void ConfigurePurifier(WaterPurifier purifier)
        {
            if (purifier == null) return;
            purifier.waterToProcessPerMinute = WPM;
            purifier.freshWaterRatio = WaterRatio;
        }
        #endregion
        #region Util
        T GetConfig<T>(string name, T defaultValue) { return (Config[name] == null) ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T)); }
        #endregion
    }
}

// --- End of file: PurifierConfig.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/planterbox-defender ---
// --- Original File Path: P/PlanterboxDefender/PlanterboxDefender.cs ---

﻿//#define Debug
using HarmonyLib;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;
using System;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Planterbox Defender", "kaucsenta", "3.0.0")]
    [Description("Only owner, owner team or if clans plugin present, clan can harvest grownable entities")]

    public class PlanterboxDefender : RustPlugin
    {
        [PluginReference]
        private Plugin Clans, Friends;
        private static PlanterboxDefender _instance;

        [AutoPatch]
        [HarmonyPatch(typeof(GrowableEntity), "TakeClones", new Type[]
        {
            typeof(BasePlayer)
        })]
        public class Patch_TakeClones
        {
            public static bool Prefix(GrowableEntity __instance, BasePlayer player)
            {
                if (_instance.CanLootGrowableEntity(__instance, player) == null)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }
        [AutoPatch]
        [HarmonyPatch(typeof(GrowableEntity), "PickFruit", new Type[]
        {
            typeof(BasePlayer),
            typeof(bool)
        })]
        public class Patch_PickFruit
        {
            public static bool Prefix(GrowableEntity __instance, BasePlayer player, bool eat)
            {
                if(_instance.CanLootGrowableEntity(__instance, player) == null)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }
        private void OnServerInitialized()
        {
            _instance = this;
            permission.RegisterPermission("planterboxdefender.admin", this);
        }
        private void OnEntityBuilt(Planner plan, GameObject seed)
        {
            var player = plan.GetOwnerPlayer();
            var isSeed = seed.GetComponent<GrowableEntity>();
            if (player == null || isSeed == null)
            {
                return;
            }

            var held = player.GetActiveItem();

            NextTick(() =>
            {
                if (isSeed.GetParentEntity() == null || !(isSeed.GetParentEntity() is PlanterBox))
                { 
                    return; 
                }
                else
                {   
                    if(!(isSeed.GetParentEntity() is PlanterBox))
                    {
                        return;
                    }
                    else
                    {

                        if (held == null)
                        {
                            return;
                        }
                        
                        PlanterBox temp = (PlanterBox)isSeed.GetParentEntity();
                        ulong plantowner = temp.OwnerID;
                        if (plantowner == player.userID)
                        {
#if Debug
            PrintToChat("You can harvest0");
#endif
                            return;
                        }

                        if (SameTeam(plantowner, player.userID))
                        {
#if Debug
            PrintToChat("You can harvest1");
#endif
                            return;
                        }

                        if (SameClan(plantowner, player.userID))
                        {
#if Debug
            PrintToChat("You can harvest2");
#endif
                            return;
                        }
                        if (HasFriend(plantowner, player.userID))
                        {
#if Debug
                    PrintToChat("You can harvest3");
#endif
                            return;
                        }
                        BuildingPrivlidge PrivlidgeToHarvest = temp.GetBuildingPrivilege();
                        if (PrivlidgeToHarvest?.IsAuthed(player) == true)
                        {
#if Debug
                    PrintToChat("You can harvest4");
#endif
                            return ;
                        }
                        player.ChatMessage(lang.GetMessage("Noharvest", this, player.UserIDString));
#if Debug
                PrintToChat(player.userID.ToString());
# endif
                        var refund = ItemManager.CreateByName(held.info.shortname, 1);

                        if (refund != null)
                        {
                            player.inventory.GiveItem(refund);
                        }
                        return; /* This is the case, when the player can't harvest the crops*/
                    }               
                }
            });

        }
                
        object CanLootGrowableEntity(GrowableEntity plant, BasePlayer player)
        {
            if (player == null)
            {
                Puts("Player error");
                return true; /* This is the case, when the player can't harvest the crops*/
            }
            if (plant == null)
            {
                Puts("Plant error");
#if Debug
                PrintToChat(player.userID.ToString());
#endif
                return true; /* This is the case, when the player can't harvest the crops*/
            }
            if (player != null && permission.UserHasPermission(player.UserIDString, "planterboxdefender.admin"))
                return null;
            if (plant.GetPlanter() != null)
            {
                ulong plantowner = plant.GetPlanter().OwnerID;

                if (plantowner == player.userID)
                {
#if Debug
            PrintToChat("You can harvest0");
#endif
                    return null;
                }

                if (SameTeam(plantowner, player.userID))
                {
#if Debug
            PrintToChat("You can harvest1");
#endif
                    return null;
                }

                if (SameClan(plantowner, player.userID))
                {
#if Debug
            PrintToChat("You can harvest2");
#endif
                    return null;
                }
                if(HasFriend(plantowner, player.userID))
                {
#if Debug
                    PrintToChat("You can harvest3");
#endif
                    return null;
                }
                BuildingPrivlidge PrivlidgeToHarvest =  plant.GetPlanter().GetBuildingPrivilege();
                if (PrivlidgeToHarvest?.IsAuthed(player) == true)
                {
#if Debug
                    PrintToChat("You can harvest4");
#endif
                    return null;
                }
                player.ChatMessage(lang.GetMessage("Noharvest", this, player.UserIDString));
#if Debug
                PrintToChat(player.userID.ToString());
#endif
                return true; /* This is the case, when the player can't harvest the crops*/
            }
#if Debug
            PrintToChat("missing planter");
#endif

            return null;
        }

        

        private bool SameTeam(ulong playerID, ulong friendID)
        {
            if (!RelationshipManager.TeamsEnabled()) return false;
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerID);
            if (playerTeam == null) return false;
            var friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendID);
            if (friendTeam == null) return false;
            return playerTeam == friendTeam;
        }

        private bool HasFriend(ulong playerID, ulong friendID)
        {
            if (Friends == null) return false;
            return (bool)Friends.Call("HasFriend", playerID, friendID);
        }

        private bool SameClan(ulong playerID, ulong friendID)
        {
            if (Clans == null) return false;
            //Clans
            var isMember = Clans.Call("IsClanMember", playerID.ToString(), friendID.ToString());
            if (isMember != null) return (bool)isMember;
            //Rust:IO Clans
            var playerClan = Clans.Call("GetClanOf", playerID);
            if (playerClan == null) return false;
            var friendClan = Clans.Call("GetClanOf", friendID);
            if (friendClan == null) return false;
            return (string)playerClan == (string)friendClan;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Noharvest"] = "You can't harvest this."
            }, this);
        }

    }
}


// --- End of file: PlanterboxDefender.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/password ---
// --- Original File Path: P/Password/Password.cs ---

//#define DEBUG

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Password", "Wulf", "3.0.2")]
    [Description("Provides name and chat command password protection for the server")]
    class Password : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        class Configuration
        {
            [JsonProperty("Server password")]
            public string ServerPassword = "umod";

            [JsonProperty("Maxium password attempts")]
            public int MaxAttempts = 3;

            [JsonProperty("Grace period (seconds)")]
            public int GracePeriod = 60;

            [JsonProperty("Always check for password on join")]
            public bool AlwaysCheck = true;

            [JsonProperty("Ask for password in chat")]
            public bool PromptInChat = true;

            [JsonProperty("Check for password in names")]
            public bool CheckNames = true;

            [JsonProperty("Freeze unauthorized players")]
            public bool FreezeUnauthorized = true;

            [JsonProperty("Mute unauthorized players")]
            public bool MuteUnauthorized = true;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandPassword"] = "password",
                ["MaximumAttempts"] = "You've exhausted the maximum password attempts ({0})",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["NotFastEnough"] = "You did not enter a password fast enough ({0} seconds)",
                ["PasswordAccepted"] = "Server password accepted, welcome!",
                ["PasswordChanged"] = "Server password has been changed to: {0}",
                ["PasswordCurrently"] = "Server password is currently set to: {0}",
                ["PasswordInvalid"] = "Invalid server password or not provided",
                ["PasswordPrompt"] = "Please enter the server password with /{0} PASSWORD"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private readonly Dictionary<string, Timer> freezeTimers = new Dictionary<string, Timer>();
        private readonly Dictionary<string, int> attempts = new Dictionary<string, int>();
        private readonly HashSet<string> authorized = new HashSet<string>();

        private const string permBypass = "password.bypass";

        private void Init()
        {
            permission.RegisterPermission(permBypass, this);

            AddCovalenceCommand("server.password", nameof(CommandServerPassword));
            AddLocalizedCommand(nameof(CommandPassword));

            if (!config.PromptInChat)
            {
                Unsubscribe(nameof(OnUserConnected));
            }
            if (!config.MuteUnauthorized)
            {
                Unsubscribe(nameof(OnBetterChat));
                Unsubscribe(nameof(OnUserChat));
            }
        }

        private void OnServerInitialized()
        {
            foreach (IPlayer player in players.Connected)
            {
                authorized.Add(player.Id);
            }
        }

        #endregion Initialization

        #region Login Checking

        private object CanUserLogin(string playerName, string playerId)
        {
#if DEBUG
            LogWarning($"{playerName} authorized? {authorized.Contains(playerId)}");
#endif

            if (permission.UserHasPermission(playerId, permBypass) || config.CheckNames && playerName.Contains(config.ServerPassword)
                || !config.AlwaysCheck && authorized.Contains(playerId))
            {
                if (!authorized.Contains(playerId))
                {
                    authorized.Add(playerId);
                }
                Interface.Oxide.CallHook("OnPasswordAccepted", playerName, playerId);
                return true;
            }

            if (!config.PromptInChat)
            {
                return GetLang("PasswordInvalid", playerId);
            }

            return null;
        }

        #endregion Login Checking

        #region Auth Handling

        private void OnUserConnected(IPlayer player)
        {
            if (!player.HasPermission(permBypass) && !authorized.Contains(player.Id))
            {
                Message(player, "PasswordPrompt", GetLang("CommandPassword", player.Id));

                timer.Once(config.GracePeriod, () =>
                {
                    if (!authorized.Contains(player.Id))
                    {
                        player.Kick(GetLang("NotFastEnough", player.Id, config.GracePeriod));
                    }
                });

                if (config.FreezeUnauthorized)
                {
                    GenericPosition originalPosition = player.Position();
                    freezeTimers[player.Id] = timer.Every(0.01f, () =>
                    {
                        if (!player.IsConnected || authorized.Contains(player.Id))
                        {
                            freezeTimers[player.Id].Destroy();
                        }
                        else
                        {
                            player.Teleport(originalPosition);
                        }
                    });
                }
            }
        }

        private void OnUserDisconnected(IPlayer player)
        {
            if (!config.AlwaysCheck && authorized.Contains(player.Id))
            {
                authorized.Remove(player.Id);
            }
        }

        #endregion Auth Handling

        #region Chat Handling

        private object OnUserChat(IPlayer player)
        {
            if (!authorized.Contains(player.Id))
            {
                Message(player, "PasswordPrompt", GetLang("CommandPassword", player.Id));
                return true;
            }

            return null;
        }

        private object OnBetterChat(Dictionary<string, object> data)
        {
            if (!authorized.Contains((data["Player"] as IPlayer).Id))
            {
                return true;
            }

            return null;
        }

        #endregion Chat Handling

        #region Commands

        private void CommandPassword(IPlayer player, string command, string[] args)
        {
            if (args.Length < 1)
            {
                Message(player, "PasswordPrompt", command);
                return;
            }

            if (args[0] != config.ServerPassword)
            {
                if (attempts.ContainsKey(player.Id) && attempts[player.Id] + 1 >= config.MaxAttempts)
                {
                    player.Kick(GetLang("MaximumAttempts", player.Id, config.MaxAttempts));
                    return;
                }

                Message(player, "PasswordInvalid");
                if (attempts.ContainsKey(player.Id))
                {
                    attempts[player.Id] += 1;
                }
                else
                {
                    attempts.Add(player.Id, 1);
                }
                return;
            }

            authorized.Add(player.Id);
            Message(player, "PasswordAccepted");
            Interface.Oxide.CallHook("OnPasswordAccepted", player.Name, player.Id);
        }

        private void CommandServerPassword(IPlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 1)
            {
                Message(player, "PasswordCurrently", config.ServerPassword);
                return;
            }

            config.ServerPassword = args[0].Sanitize(); // TODO: Combine all args to allow spaces?
            Message(player, "PasswordChanged", config.ServerPassword);
            SaveConfig();
        }

        #endregion Commands

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: Password.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/proximity-alert ---
// --- Original File Path: P/ProximityAlert/ProximityAlert.cs ---

﻿using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Proximity Alert", "PaiN", "0.3.7")]
    [Description("Displays a UI warning message when players get within a set radius of the player")]
    class ProximityAlert : RustPlugin
    {
        #region Fields
        [PluginReference]
        private Plugin Clans, EventManager, Friends, HumanNPC;

        static ProximityAlert ins;
        private const string proxUI = "ProximityAlertUI";
        private const string permUse = "proximityalert.use";
        #endregion

        #region Functions
        private void OnServerInitialized()
        {
            ins = this;
            LoadVariables();
            RegisterPermissions();
            CheckDependencies();

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void Unload()
        {
            var objects = UnityEngine.Object.FindObjectsOfType<ProximityPlayer>();
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);

            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, proxUI);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permUse)) return;
            if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(2, () => OnPlayerConnected(player));
                return;
            }
            var proxPlayer = player.GetComponent<ProximityPlayer>();
            if (proxPlayer != null)
                UnityEngine.Object.DestroyImmediate(proxPlayer);

            NextTick(() => player.gameObject.AddComponent<ProximityPlayer>());
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, proxUI);
            var proxPlayer = player.GetComponent<ProximityPlayer>();
            if (proxPlayer != null)
                UnityEngine.Object.Destroy(proxPlayer);
        }

        private void OnEntityDeath(BasePlayer victim, HitInfo info) => HandleVictim(victim, info);

        private void OnPlayerTeleported(BasePlayer player, Vector3 oldPos, Vector3 newPos)
        {
            var proxPlayer = player.GetComponent<ProximityPlayer>();
            if (proxPlayer != null && proxPlayer.isEnabled)
            {
                proxPlayer.inProximity.Clear();
                CuiHelper.DestroyUi(player, proxUI);
            }
        }

        private void RegisterPermissions()
        {
            permission.RegisterPermission("proximityalert.use", this);
            if (configData.UseCustomPermissions)
            {
                foreach (var perm in configData.CustomPermissions)
                {
                    permission.RegisterPermission(perm.Key, this);
                }
            }
        }

        private void CheckDependencies()
        {
            if (!Friends) PrintWarning("Friends could not be found! Unable to use friends feature");
            if (!Clans) PrintWarning("Clans could not be found! Unable to use clans feature");
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            var playerProx = player?.GetComponent<ProximityPlayer>();
            if (playerProx != null && playerProx.isEnabled && playerProx.justDied)
                playerProx.justDied = false;
        }

        private void HandleVictim(BasePlayer victim, HitInfo info)
        {
            if (!DoChecks(victim)) return;

            if (victim.userID.IsSteamId())
            {
                var vicProx = victim?.GetComponent<ProximityPlayer>();

                if (vicProx != null && vicProx.isEnabled)
                {
                    vicProx.justDied = true;
                    vicProx.inProximity.Clear();
                    CuiHelper.DestroyUi(victim, proxUI);
                }
            }

            foreach (var obj in UnityEngine.Object.FindObjectsOfType<ProximityPlayer>())
            {
                if (!obj.isEnabled) continue;
                if (obj.inProximity.Contains(victim.userID))
                {
                    obj.inProximity.Remove(victim.userID);
                    if (obj.inProximity.Count == 0)
                    {
                        ProxCollisionLeave(obj.player);
                        timer.In(5, () => CuiHelper.DestroyUi(obj.player, proxUI));
                    }
                }
            }
        }

        private bool DoChecks(BasePlayer enemy)
        {
            if (!configData.DetectSleepers && enemy.IsSleeping()) return false;
            if (!configData.DetectScientists && IsScientist(enemy)) return false;
            if (!configData.DetectTunnelNPCs && IsTunnelNPC(enemy)) return false;
            if (!configData.DetectBanditNPCs && IsBanditNPC(enemy)) return false;
            if (!configData.DetectHumanNPCs && HumanNPC)
            {
                if (enemy.userID >= 41234564 && enemy.userID <= 11474836478)
                    return false;
            }

            return true;
        }

        private void ProxCollisionEnter(BasePlayer player)
        {
            var UI = CreateUI(lang.GetMessage("warning", this, player.UserIDString));
            CuiHelper.DestroyUi(player, proxUI);
            CuiHelper.AddUi(player, UI);
        }

        private void ProxCollisionLeave(BasePlayer player)
        {
            var UI = CreateUI(lang.GetMessage("clear", this, player.UserIDString));
            CuiHelper.DestroyUi(player, proxUI);
            CuiHelper.AddUi(player, UI);
        }

        private float GetPlayerRadius(BasePlayer player)
        {
            foreach (var perm in configData.CustomPermissions)
            {
                if (permission.UserHasPermission(player.UserIDString, perm.Key))
                    return perm.Value;
            }
            if (permission.UserHasPermission(player.UserIDString, permUse))
                return configData.TriggerRadius;
            return 0f;
        }

        private bool IsClanmate(ulong playerId, ulong friendId)
        {
            if (!Clans) return false;
            object playerTag = Clans?.Call("GetClanOf", playerId);
            object friendTag = Clans?.Call("GetClanOf", friendId);
            if (playerTag is string && friendTag is string)
                if (playerTag == friendTag) return true;
            return false;
        }

        private bool IsFriend(ulong playerID, ulong friendID)
        {
            if (!Friends) return false;
            bool isFriend = (bool)Friends?.Call("IsFriend", playerID, friendID);
            return isFriend;
        }

        private bool IsTeam(BasePlayer player, BasePlayer target) => (player.currentTeam != 0UL && target.currentTeam != 0UL && player.currentTeam == target.currentTeam) ? true : false;

        private bool IsScientist(BaseNetworkable networkable) => networkable is ScientistNPC;

        private bool IsTunnelNPC(BaseNetworkable networkable) => networkable is TunnelDweller;

        private bool IsBanditNPC(BaseNetworkable networkable) => networkable.ShortPrefabName.Contains("bandit");

        private bool IsPlaying(BasePlayer player) => (EventManager?.Call("IsEventPlayer", player) != null) ? true : false;

        private void JoinedEvent(BasePlayer player)
        {
            var proxPlayer = player.GetComponent<ProximityPlayer>();
            if (proxPlayer != null)
            {
                CuiHelper.DestroyUi(player, proxUI);
                proxPlayer.isEnabled = false;
            }
        }

        private void LeftEvent(BasePlayer player)
        {
            var proxPlayer = player.GetComponent<ProximityPlayer>();
            if (proxPlayer != null)
            {
                CuiHelper.DestroyUi(player, proxUI);
                proxPlayer.isEnabled = true;
            }
        }
        #endregion

        #region UI
        public CuiElementContainer CreateUI(string text)
        {
            var container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = "0 0 0 0"},
                            RectTransform = {AnchorMin = $"{ins.configData.GUI_X_Pos} {ins.configData.GUI_Y_Pos}", AnchorMax = $"{ins.configData.GUI_X_Pos + ins.configData.GUI_X_Dim} {ins.configData.GUI_Y_Pos + ins.configData.GUI_Y_Dim}"},
                            CursorEnabled = false
                        },
                        new CuiElement().Parent = "Hud",
                        proxUI
                    }
                };
            container.Add(new CuiLabel
            {
                Text = { FontSize = ins.configData.FontSize, Align = TextAnchor.MiddleCenter, Text = text },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }

            },
            proxUI,
            CuiHelper.GetGuid());
            return container;
        }
        #endregion

        #region Chat Command
        [ChatCommand("prox")]
        private void cmdProx(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permUse)) return;

            var proxPlayer = player.GetComponent<ProximityPlayer>();
            if (proxPlayer != null)
            {
                CuiHelper.DestroyUi(player, proxUI);
                if (proxPlayer.isEnabled)
                {
                    proxPlayer.isEnabled = false;
                    SendReply(player, lang.GetMessage("deactive", this, player.UserIDString));
                }
                else
                {
                    proxPlayer.isEnabled = true;
                    SendReply(player, lang.GetMessage("active", this, player.UserIDString));
                }
            }
        }
        #endregion

        #region Player Class
        private class ProximityPlayer : MonoBehaviour
        {
            public BasePlayer player;
            private Timer destroyTimer;
            public List<ulong> inProximity = new List<ulong>();
            public bool isEnabled;
            public bool justDied;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();

                var child = gameObject.CreateChild();
                var collider = child.AddComponent<SphereCollider>();
                collider.gameObject.layer = (int)Layer.Reserved1;
                collider.radius = ins.GetPlayerRadius(player);
                collider.isTrigger = true;

                isEnabled = true;
                justDied = false;
            }

            private void OnTriggerEnter(Collider col)
            {
                var enemy = col.GetComponentInParent<BasePlayer>();
                if (enemy != null && enemy != player)
                {
                    if (enemy.GetComponent<ProximityPlayer>()?.justDied == true) return;
                    if (inProximity.Contains(enemy.userID)) return;

                    if (ins.IsTeam(player, enemy)) return;
                    if (ins.IsFriend(player.userID, enemy.userID)) return;
                    if (ins.IsClanmate(player.userID, enemy.userID)) return;
                    if (ins.IsPlaying(enemy)) return;

                    if(!ins.DoChecks(enemy)) return;

                    if (inProximity.Count == 0 && isEnabled)
                    {
                        if (destroyTimer != null)
                            destroyTimer.Destroy();
                        ins.ProxCollisionEnter(player);
                    }
                    inProximity.Add(enemy.userID);
                }
            }

            private void OnTriggerExit(Collider col)
            {
                var enemy = col.GetComponentInParent<BasePlayer>();
                if (enemy != null && enemy != player && inProximity.Contains(enemy.userID))
                {
                    inProximity.Remove(enemy.userID);
                    if (inProximity.Count == 0 && isEnabled)
                    {
                        ins.ProxCollisionLeave(player);
                        destroyTimer = ins.timer.In(5, () => CuiHelper.DestroyUi(player, proxUI));
                    }
                }
            }
        }
        #endregion

        #region Config
        private ConfigData configData;

        private class ConfigData
        {
            public bool DetectSleepers { get; set; }
            public bool DetectHumanNPCs { get; set; }
            public bool DetectTunnelNPCs { get; set; }
            public bool DetectScientists { get; set; }
            public bool DetectBanditNPCs { get; set; }

            public float GUI_X_Pos { get; set; }
            public float GUI_X_Dim { get; set; }
            public float GUI_Y_Pos { get; set; }
            public float GUI_Y_Dim { get; set; }
            public int FontSize { get; set; }
            public float TriggerRadius { get; set; }
            public Dictionary<string, float> CustomPermissions { get; set; }
            public bool UseCustomPermissions { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                CustomPermissions = new Dictionary<string, float>
                {
                    { "proximityalert.vip1", 50f },
                    { "proximityalert.vip2", 75f },
                },
                DetectHumanNPCs = false,
                DetectTunnelNPCs = false,
                DetectSleepers = false,
                DetectScientists = false,
                DetectBanditNPCs = false,
                FontSize = 18,
                GUI_X_Pos = 0.2f,
                GUI_X_Dim = 0.6f,
                GUI_Y_Pos = 0.1f,
                GUI_Y_Dim = 0.16f,
                TriggerRadius = 25f,
                UseCustomPermissions = true
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"warning", "<color=#cc0000>Caution!</color> There are players nearby!" },
                {"clear", "<color=#ffdb19>Clear!</color>" },
                {"active", "You have activated ProximityAlert" },
                {"deactive", "You have deactivated ProximityAlert" }
            }, this);
        }
        #endregion
    }
}


// --- End of file: ProximityAlert.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/player-informations ---
// --- Original File Path: P/PlayerInformations/PlayerInformations.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("PlayerInformations", "austinv900", "1.2.14")]
    [Description("Logs players informations.")]
    public class PlayerInformations : CovalencePlugin
    {
        [PluginReference]
        Plugin PlayerDatabase;

        #region Fields

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        #endregion

        #region Methods

        string GetMsg(string key, object steamid = null) => lang.GetMessage(key, this, steamid.ToString());

        bool IsConnected(string steamid) => players.Connected.Where(x => x.Id == steamid).Count() > 0;

        string NormalizeIP(string ip)
        {
            if (!ip.Contains(":")) return ip;
            return ip.Substring(0, ip.LastIndexOf(":"));
        }

        void SendHelpText(IPlayer player) { player.Reply(HelpText(player.Id)); }

        string HelpText(string steamid)
        {
            string msg = string.Empty;
            if (hasPermission(steamid, IPpermission, IPauthlevel)) { msg += "\r\n<color=\"#ffd479\">/lastips steamid/name</color> - get the last ips used by a user\r\n<color=\"#ffd479\">/ipowners XX.XX.XX.XX </color>- know what players used this ip"; }
            if (hasPermission(steamid, LSpermission, LSauthlevel)) { msg += "\r\n<color=\"#ffd479\">/lastseen steamid/name</color> - know when was this player last seen online"; }
            if (hasPermission(steamid, LPpermission, LPauthlevel)) { msg += "\r\n<color=\"#ffd479\">/lastposition steamid/name</color> - know where is the last position of a player"; }
            if (hasPermission(steamid, FCpermission, FCauthlevel)) { msg += "\r\n<color=\"#ffd479\">/firstconnection steamid/name</color> - know when was this player first seen online"; }
            if (hasPermission(steamid, TPpermission, TPauthlevel)) { msg += "\r\n<color=\"#ffd479\">/played steamid/name</color> - know how much time a player has played on this server"; }
            if (hasPermission(steamid, NAMESpermission, NAMESauthlevel)) { msg += "\r\n<color=\"#ffd479\">/lastnames steamid/name</color> - know the last names used by a user"; }
            if (msg != string.Empty)
            {
                msg = "<size=18>Players Information</size>" + msg;
            }
            return msg;
        }

        bool hasPermission(string steamid, string permissionName, int authLevel)
        {
            if (steamid == "server_console") return true;

            var player = players.FindPlayer(steamid);
            if (player != null && player.IsConnected)
            {
                if (player.IsAdmin) return true;
#if RUST
                var baseplayer = (BasePlayer)(player?.Object);
                if(baseplayer != null)
                {
                    if (baseplayer.net.connection.authLevel >= authLevel) return true;
                }
#endif
            }

            return permission.UserHasPermission(steamid, permissionName);
        }

        void OnPlayerJoined(string steamid, string name, string ip)
        {
            if (IPuse)
                RecordIP(steamid, ip);
            if (NAMESuse)
                RecordName(steamid, name);
            if (FCuse)
                RecordFirstConnection(steamid);
            if (TPuse)
                StartRecordTime(steamid);
        }

        void OnPlayerLeave(IPlayer player)
        {
            var steamid = player.Id;

            if (LSuse)
                RecordLastSeen(steamid);
            if (TPuse)
                EndRecordTime(steamid);
            if (LPuse)
                RecordPosition(steamid, player.IsConnected ? player.Position().X : 0f, player.IsConnected ? player.Position().Y : 0f, player.IsConnected ? player.Position().Z : 0f);
        }

        static double LogTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }

        string TimeMinToString(string time) { return TimeMinToString(double.Parse(time)); }

        string TimeMinToString(double time)
        {
            TimeSpan timespan = TimeSpan.FromSeconds(time);
            DateTime date = new DateTime(1970, 1, 1, 0, 0, 0) + timespan;
            return string.Format("{0}:{1} {2}/{3}/{4}", date.Hour.ToString(), date.Minute.ToString(), date.Month.ToString(), date.Day.ToString(), date.Year.ToString());
        }

        string SecondsToString(string time) { return SecondsToString(decimal.Parse(time)); }
        string SecondsToString(decimal time)
        {
            decimal days = Math.Floor(time / 86400);
            time -= days * 86400;
            decimal hours = Math.Floor(time / 3600);
            time -= hours * 3600;
            decimal minutes = Math.Floor(time / 60);
            time -= minutes * 60;
            return string.Format("{0}d {1}h {2}m {3}s", days.ToString(), hours.ToString(), minutes.ToString(), Math.Floor(time).ToString());
        }

        private object FindPlayer(string arg)
        {
            string success = PlayerDatabase.Call("FindPlayer", arg) as string;
            if (success.Length == 17)
            {
                return ulong.Parse(success);
            }
            else
                return success;
        }

        #endregion

        #region Configs

        private static bool IPuse = true;
        private static string IPpermission = "playerinformations.ips";
        private static int IPauthlevel = 1;
        private static int IPmaxLogs = 5;

        private static bool NAMESuse = true;
        private static string NAMESpermission = "playerinformations.names";
        private static int NAMESauthlevel = 1;
        private static int NAMESmaxLogs = 5;

        private static bool FCuse = true;
        private static string FCpermission = "playerinformations.firstconnection";
        private static int FCauthlevel = 1;

        private static bool LSuse = true;
        private static string LSpermission = "playerinformations.lastseen";
        private static int LSauthlevel = 1;

        private static bool LPuse = true;
        private static string LPpermission = "playerinformations.lastposition";
        private static int LPauthlevel = 1;

        private static bool TPuse = true;
        private static string TPpermission = "playerinformations.timeplayed";
        private static int TPauthlevel = 0;

        void Init()
        {
            permission.RegisterPermission(FCpermission, this);
            permission.RegisterPermission(IPpermission, this);
            permission.RegisterPermission(LPpermission, this);
            permission.RegisterPermission(LSpermission, this);
            permission.RegisterPermission(NAMESpermission, this);
            permission.RegisterPermission(TPpermission, this);

            CheckCfg<bool>("IP Logs - activated", ref IPuse);
            CheckCfg<string>("IP Logs - Permission - oxide permission", ref IPpermission);
            CheckCfg<int>("IP Logs - Permission - authlevel - Rust ONLY", ref IPauthlevel);
            CheckCfg<int>("IP Logs - Max Logs per player", ref IPmaxLogs);

            CheckCfg<bool>("Names Logs - activated", ref NAMESuse);
            CheckCfg<string>("Names Logs - Permission - oxide permission", ref NAMESpermission);
            CheckCfg<int>("Names Logs - Permission - authlevel - Rust ONLY", ref NAMESauthlevel);
            CheckCfg<int>("Names Logs - Max Logs per player", ref NAMESmaxLogs);

            CheckCfg<bool>("First Connection - activated", ref FCuse);
            CheckCfg<string>("First Connection - Permission - oxide permission", ref FCpermission);
            CheckCfg<int>("First Connection - Permission - authlevel - Rust ONLY", ref FCauthlevel);

            CheckCfg<bool>("Last Seen - activated", ref LSuse);
            CheckCfg<string>("Last Seen - Permission - oxide permission", ref LSpermission);
            CheckCfg<int>("Last Seen - Permission - authlevel - Rust ONLY", ref LSauthlevel);

            CheckCfg<bool>("Last Position - activated", ref LPuse);
            CheckCfg<string>("Last Position - Permission - oxide permission", ref LPpermission);
            CheckCfg<int>("Last Position - Permission - authlevel - Rust ONLY", ref LPauthlevel);

            CheckCfg<bool>("Time Played - activated", ref TPuse);
            CheckCfg<string>("Time Played - Permission - oxide permission", ref TPpermission);
            CheckCfg<int>("Time Played - Permission - authlevel - Rust ONLY", ref TPauthlevel);

            SaveConfig();
        }

        protected override void LoadDefaultConfig() { }

        void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"You don't have permission to use this command.", "You don't have permission to use this command."},
                {"IPs aren't recorded.","IPs aren't recorded."},
                {"/lastips STEAMID/NAME", "/lastips STEAMID/NAME"},
                {"Couldn't find a player that matches this name.", "Couldn't find a player that matches this name."},
                {"No logs for this player.", "No logs for this player."},
                {"/ipowners XX.XX.XX.XX", "/ipowners XX.XX.XX.XX"},
                {"Couldn't get the list of players", "Couldn't get the list of players"},
                {"This command has been deactivated.", "This command has been deactivated."},
                {"/lastseen STEAMID/NAME", "/lastseen STEAMID/NAME"},
                { "This player is connected!",  "This player is connected!"},
                {"/firstconnection STEAMID/NAME", "/firstconnection STEAMID/NAME"},
                { "/lastnames STEAMID/NAME",  "/lastnames STEAMID/NAME"},
                {"/played STEAMID/NAME", "/played STEAMID/NAME"},
                {"/lastposition STEAMID/NAME","/lastposition STEAMID/NAME"},
                {"{0} - {1} last known position is: {2} {3} {4}","{0} - {1} last known position is: {2} {3} {4}"},
                {"{0} - {1} was last seen: {2}","{0} - {1} was last seen: {2}" },
                {"{0} - {1} played: {2}","{0} - {1} played: {2}" }
            }, this);
        }
        #endregion

        #region OxideHooks

        void OnServerInitialized()
        {
            if (PlayerDatabase == null)
            {
				PrintWarning("PlayerDatabase is not loaded, Please make sure you have the plugin PlayerDatabase");
                timer.Once(0.01f, () => Interface.Oxide.UnloadPlugin("PlayerInformations"));
                return;
            }
            if (TPuse)
            {
                StartRecordTimeAll();
            }
        }

        void Unload()
        {
            if (TPuse)
            {
                EndRecordTimeAll();
            }
        }

        void OnUserConnected(IPlayer player) { OnPlayerJoined(player.Id, player.Name, NormalizeIP(player.Address)); }

        void OnUserDisconnected(IPlayer player) { OnPlayerLeave(player); }

        #endregion

        #region Played

        Dictionary<string, double> recordPlayTime = new Dictionary<string, double>();

        [Command("played")]
        void cmdChatPlayed(IPlayer player, string command, string[] args)
        {
            string answer = CMD_chatPlayed(player.Id, args);
            player.Reply(answer);
        }

        string CMD_chatPlayed(string steamid, string[] args)
        {
            if (!hasPermission(steamid, TPpermission, TPauthlevel)) { return GetMsg("You don't have permission to use this command.", steamid); }
            if (!IPuse) { return GetMsg("This command has been deactivated.", steamid); }
            if (args.Length == 0)
            {
                return GetMsg("/played STEAMID/NAME", steamid);
            }
            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                return findplayer is string ? (string)findplayer : GetMsg("Couldn't find a player that matches this name.", steamid);
            }

            var name = (string)PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "name") ?? "Unknown";
            var totaltime = TimePlayed(findplayer.ToString());

            return string.Format(GetMsg("{0} - {1} played: {2}",steamid), name, findplayer.ToString(), SecondsToString(totaltime.ToString()));
        }

        void StartRecordTimeAll()
        {
            foreach (IPlayer player in players.Connected)
            {
                StartRecordTime(player.Id);
            }
        }
        void EndRecordTimeAll()
        {
            foreach (IPlayer player in players.Connected)
            {
                EndRecordTime(player.Id);
            }
        }

        double LastRecordTime(string steamid)
        {
            var success = PlayerDatabase.Call("GetPlayerData", steamid, "Time Played");
            
            double lastRecordTime = 0.0;
            
            if(success != null && success is string && double.TryParse((string)success, out lastRecordTime))
            {
                return lastRecordTime;
            }

            return 0.0;
        }
		
        double SessionRecordTime(string steamid)
        {
            if (recordPlayTime.ContainsKey(steamid))
            {
                return LogTime() - recordPlayTime[steamid];
            }
            else return 0.0;
        }

        double TimePlayed(string steamid)
        {
            return SessionRecordTime(steamid) + LastRecordTime(steamid);
        }

        void StartRecordTime(string steamid)
        {
            if (recordPlayTime.ContainsKey(steamid))
                recordPlayTime.Remove(steamid);
            recordPlayTime.Add(steamid, LogTime());
        }

        void EndRecordTime(string steamid)
        {
            if (!recordPlayTime.ContainsKey(steamid)) return;

            var totaltime = TimePlayed(steamid);

            PlayerDatabase.Call("SetPlayerData", steamid, "Time Played", totaltime.ToString());
        }

        #endregion

        #region Position

        [Command("lastposition")]
        void cmdChatLastPosition(IPlayer player, string command, string[] args)
        {
            string answer = CMD_chatLastPosition(player.Id, args);
            player.Reply(answer);
        }

        GenericPosition FindPosition(string steamid)
        {
            GenericPosition position = FindCurrentPosition(steamid);
            if(position == default(GenericPosition))
            {
                position = FindLastPosition(steamid);
            }
            return position;
        }

        GenericPosition FindCurrentPosition(string steamid)
        {
            var player = players.FindPlayer(steamid);
            if (player == null) return default(GenericPosition);
            return player.Position();
        }

        GenericPosition FindLastPosition(string steamid)
        {
            GenericPosition LastPos = default(GenericPosition);
            var success = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Last Position");
            
            if (success is string)
            {
                try
                {
                    LastPos = JsonConvert.DeserializeObject<GenericPosition>((string)success);
                }
                catch (System.Exception)
                {
                    LastPos = default(GenericPosition);
                }
            }

            return LastPos;
        }

        void RecordPosition(string steamid, float x, float y, float z)
        {
            var LastPos = new GenericPosition(x, y, z);
            PlayerDatabase.Call("SetPlayerData", steamid, "Last Position", LastPos);
        }

        string CMD_chatLastPosition(string steamid, string[] args)
        {
            if (!hasPermission(steamid, LSpermission, LSauthlevel)) { return GetMsg("You don't have permission to use this command.", steamid); }
            if (!IPuse) { return GetMsg("This command has been deactivated.", steamid); }
            if (args.Length == 0) { return GetMsg("/lastposition STEAMID/NAME", steamid); }

            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                return findplayer is string ? (string)findplayer : GetMsg("Couldn't find a player that matches this name.", steamid);
            }

            var name = (string)PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "name") ?? "Unknown";

            var lastKnownPosition = FindPosition(findplayer.ToString());
            if(lastKnownPosition == default(GenericPosition))
            {
                return GetMsg("No logs for this player.", steamid);
            }

            return string.Format(GetMsg("{0} - {1} last known position is: {2} {3} {4}",steamid), findplayer.ToString(), name, lastKnownPosition.X.ToString(), lastKnownPosition.Y.ToString(), lastKnownPosition.Z.ToString());
        }

        #endregion

        #region Lastseen

        [Command("lastseen")]
        void cmdChatLastseen(IPlayer player, string command, string[] args)
        {
            string answer = CMD_chatLastseen(player.Id, args);
            player.Reply(answer);
        }

        void RecordLastSeen(string steamid)
        {
            PlayerDatabase.Call("SetPlayerData", steamid, "Last Seen", LogTime().ToString());
        }

        float LastSeen(string steamid)
        {
            if (IsConnected(steamid))
            {
                return -1f;
            }
            var success = PlayerDatabase.Call("GetPlayerData", steamid, "Last Seen");
            
            float lastSeen = 0f;
            
            if (success != null && success is string && float.TryParse((string)success, out lastSeen))
            {
                return lastSeen;
            }
            
			return 0f;
        }

        string CMD_chatLastseen(string steamid, string[] args)
        {
            if (!hasPermission(steamid, LSpermission, LSauthlevel)) { return GetMsg("You don't have permission to use this command.", steamid); }
            if (!IPuse) { return GetMsg("This command has been deactivated.", steamid); }

            if (args.Length == 0)
            {
                return GetMsg("/lastseen STEAMID/NAME", steamid);
            }

            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                return findplayer is string ? (string)findplayer : GetMsg("Couldn't find a player that matches this name.", steamid);
            }

            float lastSeen = LastSeen(findplayer.ToString());
            if(lastSeen == -1f)
            {
                return GetMsg("This player is connected!", steamid);
            }
            if(lastSeen == 0f)
            {
                return GetMsg("No logs for this player.", steamid);
            }
            var name = (string)PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "name") ?? "Unknown";
            return string.Format(GetMsg("{0} - {1} was last seen: {2}",steamid), name, findplayer.ToString(), TimeMinToString(lastSeen.ToString()));
        }

        #endregion

        #region IPS

        [Command("lastips")]
        void cmdChatLastIps(IPlayer player, string command, string[] args)
        {
            string answer = CMD_lastIps(player.Id, args);
            player.Reply(answer);
        }

        [Command("ipowners")]
        void cmdChatIpOwners(IPlayer player, string command, string[] args)
        {
            string answer = CMD_chatIps(player.Id, args);
            player.Reply(answer);
        }

        void RecordIP(string steamid, string playerip)
        {
            if (string.IsNullOrEmpty(playerip) || string.IsNullOrEmpty(steamid))
            {
                return;
            }

            var IPlist = new List<string>();

            var success = PlayerDatabase.Call("GetPlayerData", steamid, "IPs");

            if (success is List<string>)
                IPlist = (List<string>)success;

            if (IPlist.Contains(playerip)) return;

            if (IPlist.Count >= IPmaxLogs)
            {
                for (int i = 0; i < (IPlist.Count - IPmaxLogs + 1); i++)
                {
                    IPlist.RemoveAt(0);
                }
            }
            IPlist.Add(playerip);
            PlayerDatabase.Call("SetPlayerData", steamid, "IPs", IPlist);
        }

        string CMD_lastIps(string steamid, string[] args)
        {
            if (!hasPermission(steamid, IPpermission, IPauthlevel)) { return GetMsg("You don't have permission to use this command.", steamid); }
            if (!IPuse) { return GetMsg("IPs aren't recorded.", steamid); }
            if (args.Length == 0)
            {
                return GetMsg("/lastips STEAMID/NAME", steamid);
            }
            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                return findplayer is string ? (string)findplayer : GetMsg("Couldn't find a player that matches this name.", steamid);
            }
            var IPlist = new List<string>();
            var success = PlayerDatabase.Call("GetPlayerDataRaw", findplayer.ToString(), "IPs");
            if (success is string)
            {
                IPlist = JsonConvert.DeserializeObject<List<string>>((string)success);
            }

            if (IPlist.Count == 0)
            {
                return GetMsg("No logs for this player.", steamid);
            }
            var name = (string)PlayerDatabase?.Call("GetPlayerData", findplayer.ToString(), "name");
            string replystring = string.Format("IP List for {0} - {1}", name, findplayer.ToString());
            foreach (var ip in IPlist)
            {
                replystring += string.Format("\r\n{0}", ip);
            }
            return replystring;
        }

        string CMD_chatIps(string steamid, string[] args)
        {
            if (!hasPermission(steamid, IPpermission, IPauthlevel)) { return GetMsg("You don't have permission to use this command.", steamid); }
            if (!IPuse) { return GetMsg("IPs aren't recorded.", steamid); }
            if (args.Length == 0)
            {
                return GetMsg("/ipowners XX.XX.XX.XX", steamid);
            }
            List<string> knownPlayers = new List<string>();
            var success = PlayerDatabase.Call("GetAllKnownPlayers");
            if (success is List<string>)
                knownPlayers = (List<string>)success;
            if (knownPlayers.Count == 0)
            {
                return GetMsg("Couldn't get the list of players", steamid);
            }

            var foundPlayers = new List<string>();
            foreach (string playerID in knownPlayers)
            {
                var playerIPs = new List<string>();
                var successs = PlayerDatabase.Call("GetPlayerDataRaw", playerID, "IPs");
                if (successs is string)
                {
                    playerIPs = JsonConvert.DeserializeObject<List<string>>((string)successs);
                }
                if (playerIPs.Count == 0) { continue; }
                if (playerIPs.Contains(args[0]))
                {
                    foundPlayers.Add(playerID);
                }
            }
            string replystring = string.Format("Found {0} players with this matching ip", foundPlayers.Count.ToString());

            foreach (string userid in foundPlayers)
            {
                var name = (string)PlayerDatabase.Call("GetPlayerData", userid, "name") ?? "Unknown";
                replystring += string.Format("\r\n{0} - {1}", userid, name);
            }
            return replystring;
        }

        #endregion

        #region FirstConnection

        [Command("firstconnection")]
        void cmdChatFirstconnection(IPlayer player, string command, string[] args)
        {
            string answer = CMD_chatFirstconnection(player.Id, args);
            player.Reply(answer);
        }

        float FirstConnection(string steamid)
        {
            var success = PlayerDatabase.Call("GetPlayerData", steamid, "First Connection");
            float firstConnection = 0f;
            
            if (success != null && success is string && float.TryParse((string)success, out firstConnection))
            {
                return firstConnection;
            }

            return 0f;
        }

        void RecordFirstConnection(string steamid)
        {
            var firstConnection = FirstConnection(steamid);
            if (firstConnection == 0f)
            {
                var FirstConnectionTable = LogTime().ToString();
                PlayerDatabase.Call("SetPlayerData", steamid, "First Connection", FirstConnectionTable);
            }
        }

        string CMD_chatFirstconnection(string steamid, string[] args)
        {
            if (!hasPermission(steamid, FCpermission, FCauthlevel)) { return GetMsg("You don't have permission to use this command.", steamid); }
            if (!IPuse) { return GetMsg("This command has been deactivated.", steamid); }
            if (args.Length == 0)
            {
                return GetMsg("/firstconnection STEAMID/NAME", steamid);
            }
            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                return findplayer is string ? (string)findplayer : GetMsg("Couldn't find a player that matches this name.", steamid);
            }
            var firstConnection = FirstConnection(findplayer.ToString());
            if(firstConnection == 0f)
            {
                return GetMsg("No logs for this player.", steamid);
            }

            var name = (string)PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "name") ?? "Unknown";
            return string.Format("{0} - {1} first connected: {2}", name, findplayer.ToString(), TimeMinToString(firstConnection.ToString()));
        }

        #endregion

        #region Names

        [Command("lastnames")]
        void cmdChatLastname(IPlayer player, string command, string[] args)
        {
            string answer = CMD_chatLastname(player.Id, args);
            player.Reply(answer);
        }

        List<string> LastNames(string steamid)
        {
            List<string> returnList = null;
            var success = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Names");
            if (success is string)
            {
                try
                {
                    returnList = JsonConvert.DeserializeObject<List<string>>((string)success);
                    return returnList;
                }
                catch (System.Exception)
                {
                }
            }

            returnList = new List<string>();
            return returnList;
        }

        void RecordName(string steamid, string playername)
        {
            var NameList = LastNames(steamid);

            if (NameList.Contains(playername)) return;

            if (NameList.Count >= NAMESmaxLogs)
            {
                for (int i = 0; i < (NameList.Count - NAMESmaxLogs + 1); i++)
                {
                    NameList.RemoveAt(0);
                }
            }

            NameList.Add(playername);

            PlayerDatabase.Call("SetPlayerData", steamid, "Names", NameList);
        }

        string CMD_chatLastname(string steamid, string[] args)
        {
            if (!hasPermission(steamid, NAMESpermission, NAMESauthlevel)) { return GetMsg("You don't have permission to use this command.", steamid); }
            if (!IPuse) { return GetMsg("This command has been deactivated.", steamid); }
            if (args.Length == 0)
            {
                return GetMsg("/lastnames STEAMID/NAME", steamid);
            }
            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                return findplayer is string ? (string)findplayer : GetMsg("Couldn't find a player that matches this name.", steamid);
            }
            var NameList = LastNames(findplayer.ToString());
            if (NameList.Count == 0)
            {
                return GetMsg("No logs for this player.", steamid);
            }
            var name = (string)PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "name") ?? "Unknown";
            string replyanswer = string.Format("Name List for {0} - {1}", name, findplayer.ToString());
            foreach (var n in NameList)
            {
                replyanswer += string.Format("\r\n{0}", n);
            }
            return replyanswer;
        }

        #endregion
    }
}

// --- End of file: PlayerInformations.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/plant-drop ---
// --- Original File Path: P/PlantDrop/PlantDrop.cs ---

﻿using System;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("Plant Drop", "Iv Misticos", "1.2.3")]
    [Description("Allows planting growables anywhere by dropping the seed")]
    class PlantDrop : RustPlugin
    {
        #region Variables

        private const string PrefabCorn = "assets/prefabs/plants/corn/corn.entity.prefab";
        private const string PrefabHemp = "assets/prefabs/plants/hemp/hemp.entity.prefab";
        private const string PrefabPotato = "assets/prefabs/plants/potato/potato.entity.prefab";
        private const string PrefabPumpkin = "assets/prefabs/plants/pumpkin/pumpkin.entity.prefab";

        private readonly Random _random = new Random();

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Randomize Position")]
            public bool RandomizePosition = false;

            [JsonProperty(PropertyName = "Randomize Position On N")]
            public float RandomizePositionOn = 2f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Hooks

        private void OnItemDropped(Item item, BaseNetworkable entity)
        {
            if (item?.info == null || entity == null)
                return;

            var shortname = item.info.shortname;
            var pos = entity.transform.position;

            // ReSharper disable once SwitchStatementMissingSomeCases
            switch (shortname)
            {
                case "seed.corn":
                    CreatePlant(entity, PrefabCorn, pos, item.amount);
                    break;

                case "seed.hemp":
                    CreatePlant(entity, PrefabHemp, pos, item.amount);
                    break;

                case "seed.potato":
                    CreatePlant(entity, PrefabPotato, pos, item.amount);
                    break;

                case "seed.pumpkin":
                    CreatePlant(entity, PrefabPumpkin, pos, item.amount);
                    break;
            }
        }

        #endregion

        #region Helpers

        private void CreatePlant(BaseNetworkable seed, string prefab, Vector3 pos, int amount)
        {
            RaycastHit hit;
            Physics.Raycast(pos, Vector3.down, out hit);
            if (hit.GetEntity() != null)
                return;

            pos.y = TerrainMeta.HeightMap.GetHeight(seed.transform.position);
            seed.Kill();

            for (var i = 0; i < amount; i++)
            {
                if (_config.RandomizePosition)
                {
                    pos.x += UnityEngine.Random.Range(-_config.RandomizePositionOn, _config.RandomizePositionOn);
                    pos.z += UnityEngine.Random.Range(-_config.RandomizePositionOn, _config.RandomizePositionOn);
                    pos.y = TerrainMeta.HeightMap.GetHeight(pos);
                }

                var growable = GameManager.server.CreateEntity(prefab, pos, Quaternion.identity) as GrowableEntity;
                if (growable == null) continue;

                growable.Spawn();
            }
        }

        #endregion
    }
}


// --- End of file: PlantDrop.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/paynow-store ---
// --- Original File Path: P/PayNow/PayNow.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System.Text;

namespace Oxide.Plugins
{
    [Info("PayNow", "PayNow Services Inc", "0.0.10")]
    [Description("Official plugin for the PayNow.gg store integration.")]
    internal class PayNow : CovalencePlugin
    {
        const string COMMAND_QUEUE_URL = "https://api.paynow.gg/v1/delivery/command-queue/";
        const string GS_LINK_URL = "https://api.paynow.gg/v1/delivery/gameserver/link";

        PluginConfig _config;

        readonly Dictionary<string, string> _headers = new Dictionary<string, string>();
        readonly CommandHistory _executedCommands = new CommandHistory(25);
        readonly StringBuilder _cachedStringBuilder = new StringBuilder();
        readonly List<string> _successfulCommandsList = new List<string>(1000);
        Timer _pendingCommandsTimer;

        #region Oxide

        [HookMethod("Loaded")]
        void Loaded()
        {
            if (string.IsNullOrEmpty(_config.ApiToken))
                PrintWarning("No API token set! Use the 'paynow.token <token>' command to set it.");

            UpdateHeaders();
        }

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized() => ValidateToken();

        [Command("paynow.token")]
        void CommandToken(IPlayer player, string command, string[] args)
        {
            if (!player.IsServer && !player.IsAdmin)
                return;

            if (args.Length != 1)
            {
                player.Reply("Usage: paynow.token <token>");
                return;
            }

            StopPendingCommandsLoop();
            _config.ApiToken = args[0];
            SaveConfig();
            UpdateHeaders();

            player.Reply("Successfully saved the PayNow API token! Attempting to validate it...");
            ValidateToken();
        }

        void ValidateToken() => LinkGameServer(StartPendingCommandsLoop);

        void StartPendingCommandsLoop()
        {
            if (_pendingCommandsTimer != null) return;
            Puts("Started checking for pending commands");
            GetPendingCommands();
            timer.Every(_config.ApiCheckIntervalSeconds, GetPendingCommands);
        }

        void StopPendingCommandsLoop() => timer.Destroy(ref _pendingCommandsTimer);

        #endregion

        #region WebRequests

        void LinkGameServer(Action continuationCallback)
        {
            // Don't make the API call if we don't have a token
            if (string.IsNullOrEmpty(_config.ApiToken))
                return;

            var data = new LinkGameServerRequest
            {
                Ip = server.Address + ":" + server.Port,
                Hostname = server.Name,
                Platform = game,
                Version = Version.ToString()
            };

            try
            {
                // Make the API call
                webrequest.Enqueue(GS_LINK_URL, JsonConvert.SerializeObject(data), (code, responseString) => HandleLinkGameServerResponse(code, responseString, continuationCallback), this, RequestMethod.POST, _headers);
            }
            catch (Exception ex)
            {
                PrintException("Failure initiate game server link request to PayNow, trying again in 5 seconds...", ex);
                timer.In(5, () => LinkGameServer(continuationCallback));
                return;
            }
        }

        void HandleLinkGameServerResponse(int code, string responseString, Action continuationCallback)
        {
            // Check we are authorised to be here...
            if (code == 401 || code == 403)
            {
                PrintError("Failure linking game server to PayNow, invalid token supplied. Please update your token and try again");
                return;
            }

            // Check if we got a valid response code....
            if (code >= 500)
            {
                PrintWarning("Failure linking game server to PayNow, trying again in 5 seconds...");
                timer.In(5, () => LinkGameServer(continuationCallback));
                return;
            }

            LinkGameServerResponse response;
            try
            {
                response = JsonConvert.DeserializeObject<LinkGameServerResponse>(responseString);
            }
            catch (Exception ex)
            {
                PrintException("Failure whilst deserializing link game server response, trying again in 5 seconds...", ex);
                timer.In(5, () => LinkGameServer(continuationCallback));
                return;
            }

            if (response == null)
            {
                PrintError("PayNow API returned a null link game server response, trying again in 5 seconds...");
                timer.In(5, () => LinkGameServer(continuationCallback));
                return;
            }

            if (response.UpdateAvailable)
            {
                Puts("Update available! latest version: {0}, current version: {1}", response.LatestVersion, Version.ToString());
            }

            if (response.PreviouslyLinked != null)
            {
                PrintWarning("This token has been previously used on \"{0}\" ({1}), ensure you have removed this token from the previous server.", response.PreviouslyLinked.HostName, response.PreviouslyLinked.IP);
            }

            if (response.GameServer == null)
            {
                PrintError("PayNow API did not return a GameServer object, this may be a transient issue, please try again or contact support.");
                return;
            }

            Puts("Connected to PayNow using the token for \"{0}\" ({1}) successfully!", response.GameServer.Name, response.GameServer.Id);
            continuationCallback?.Invoke();
        }

        void GetPendingCommands()
        {
            // Don't make the API call if we don't have a token
            if (string.IsNullOrEmpty(_config.ApiToken))
                return;

            try
            {
                // Make the API call
                webrequest.Enqueue(COMMAND_QUEUE_URL, BuildOnlinePlayersJson(), HandlePendingCommands, this, RequestMethod.POST, _headers);
            }
            catch (Exception ex)
            {
                PrintException("Failed retrieve get pending commands", ex);
            }
        }

        void HandlePendingCommands(int code, string response)
        {
            try
            {
                // Check if we got a valid response
                if (code != 200 || response == null)
                    throw new Exception($"Server sent an invalid response: ({code}) ({response})");

                // Deserialize the response
                QueuedCommand[] data = JsonConvert.DeserializeObject<QueuedCommand[]>(response);
                if (data == null)
                    throw new Exception($"Response deserialized to null: ({response})");

                // Process the data
                ProcessPendingCommands(data);
            }
            catch (Exception ex)
            {
                PrintException("Failed handle pending commands", ex);
            }
        }

        void AcknowledgeCommands(List<string> commandsIds)
        {
            // Check if we have any order ids to acknowledge
            if (commandsIds.Count == 0) return;

            try
            {
                // Make the API call to acknowledge the commands
                webrequest.Enqueue(COMMAND_QUEUE_URL, BuildAcknowledgeJson(commandsIds), HandleAcknowledgeCommands, this, RequestMethod.DELETE, _headers);
            }
            catch (Exception ex)
            {
                PrintException("Failed to acknowledge commands", ex);
            }
        }

        void HandleAcknowledgeCommands(int code, string response)
        {
            // Check if we got a valid response
            if (code >= 200 && code < 300) return;

            // Log an error if we didn't get a 204 response
            PrintError(
                $"Command acknowledgement resulted in an unexpected response code: ({code.ToString()}) ({response})");
        }

        #endregion

        #region Command Processing

        void ProcessPendingCommands(QueuedCommand[] queuedCommands)
        {
            // Check if we got any data
            if (queuedCommands.Length == 0)
                return;

            _successfulCommandsList.Clear();
            for (int i = 0; i < queuedCommands.Length; i++)
            {
                QueuedCommand command = queuedCommands[i];

                // Make sure we don't execute the same command twice
                if (_executedCommands.Contains(command.AttemptId))
                    continue;

                try
                {
                    if (command.OnlineOnly && players.Connected.All(x => x.Id != command.SteamId))
                        continue;

                    // Try executing the command
                    if (ExecuteCommand(command.Command))
                    {
                        // Add the order id to the list of acknowledged orders
                        _successfulCommandsList.Add(command.AttemptId);
                        _executedCommands.Add(command.AttemptId);
                    }
                    else
                    {
                        // Log an error if the command failed
                        PrintWarning($"Failed to run command {command.Command} ({command.AttemptId})!");
                    }
                }
                catch (Exception ex)
                {
                    // Log an error if an exception occurs
                    PrintException("Failed to execute command", ex);
                }
            }

            // Log the amount of commands we executed
            if (_config.LogCommandExecutions)
                Puts(
                    $"Received {queuedCommands.Length.ToString()} and executed {_successfulCommandsList.Count.ToString()} commands!");

            // Acknowledge the commands
            AcknowledgeCommands(_successfulCommandsList);
        }

        bool ExecuteCommand(string command)
        {
            // Run the command
            server.Command(command);

            // TODO: Fetch Command Response, currently not possible when using oxide covalence libraries

            return true;
        }

        #endregion

        #region Api DTOs

        [Serializable]
        public class QueuedCommand
        {
            [JsonProperty("attempt_id")] public string AttemptId;

            [JsonProperty("steam_id")] public string SteamId;

            [JsonProperty("command")] public string Command;

            [JsonProperty("online_only")] public bool OnlineOnly;

            [JsonProperty("queued_at")] public string QueuedAt;
        }

        [Serializable]
        public class LinkGameServerRequest
        {
            [JsonProperty("ip")] public string Ip;

            [JsonProperty("hostname")] public string Hostname;

            [JsonProperty("platform")] public string Platform;

            [JsonProperty("version")] public string Version;
        }

        [Serializable]
        public class LinkGameServerResponse
        {
            [JsonProperty("update_available")] public bool UpdateAvailable { get; set; }

            [JsonProperty("latest_version")] public string LatestVersion { get; set; }

            [JsonProperty("previously_linked")] public PreviouslyLinkedData PreviouslyLinked { get; set; }

            [JsonProperty("gameserver")] public GameServerData GameServer { get; set; }

            public class PreviouslyLinkedData
            {
                [JsonProperty("ip")] public string IP { get; set; }
                [JsonProperty("host_name")] public string HostName { get; set; }
                [JsonProperty("last_linked_at")] public DateTime LastLinkedAt { get; set; }
            }

            public class GameServerData
            {
                [JsonProperty("id")] public long Id { get; set; }
                [JsonProperty("store_id")] public long StoreId { get; set; }
                [JsonProperty("name")] public string Name { get; set; }
                [JsonProperty("created_at")] public DateTime? CreatedAt { get; set; }
                [JsonProperty("updated_at")] public DateTime? UpdatedAt { get; set; }
            }
        }

        #endregion

        #region Configuration

        [Serializable]
        class PluginConfig
        {
            [JsonProperty("API token")] public string ApiToken = string.Empty;

            [JsonProperty("Time between API checks in seconds")]
            public float ApiCheckIntervalSeconds = 10;

            [JsonProperty("Log command executions")]
            public bool LogCommandExecutions = true;

            // Backwards compatibility
            [JsonProperty("ApiToken")]
            public string OldApiToken
            {
                set { ApiToken = value; }
            }

            [JsonProperty("ApiCheckIntervalSeconds")]
            public float OldApiCheckIntervalSeconds
            {
                set { ApiCheckIntervalSeconds = value; }
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = new PluginConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            _config = Config.ReadObject<PluginConfig>();

            SaveConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Helpers

        void UpdateHeaders()
        {
            _headers["Content-Type"] = "application/json";
            _headers["Authorization"] = "Gameserver " + _config.ApiToken;
        }

        string BuildAcknowledgeJson(List<string> orderIds)
        {
            _cachedStringBuilder.Clear();

            // Json format [{"attempt_id": "123"}]
            _cachedStringBuilder.Append("[");
            for (int i = 0; i < orderIds.Count; i++)
            {
                _cachedStringBuilder.Append("{\"attempt_id\": \"");
                _cachedStringBuilder.Append(orderIds[i]);
                _cachedStringBuilder.Append("\"}");

                if (i < orderIds.Count - 1)
                {
                    _cachedStringBuilder.Append(",");
                }
            }

            _cachedStringBuilder.Append("]");

            return _cachedStringBuilder.ToString();
        }

        string BuildOnlinePlayersJson()
        {
            _cachedStringBuilder.Clear();

            // Json format {"steam_ids": ["123"]}
            _cachedStringBuilder.Append("{\"steam_ids\":[");
            var addedPlayers = false;
            foreach (var player in players.Connected)
            {
                addedPlayers = true;
                _cachedStringBuilder.Append("\"");
                _cachedStringBuilder.Append(player.Id);
                _cachedStringBuilder.Append("\"");
                _cachedStringBuilder.Append(",");
            }

            if (addedPlayers) _cachedStringBuilder.Remove(_cachedStringBuilder.Length - 1, 1);

            _cachedStringBuilder.Append("]}");

            return _cachedStringBuilder.ToString();
        }

        class CommandHistory
        {
            readonly Queue<string> _queue;
            readonly int _capacity;

            public CommandHistory(int capacity)
            {
                _capacity = capacity;
                _queue = new Queue<string>(capacity);
            }

            public void Add(string command)
            {
                if (_queue.Count >= _capacity)
                    _queue.Dequeue();

                _queue.Enqueue(command);
            }

            public bool Contains(string command) => _queue.Contains(command);
        }

        void PrintException(string message, Exception ex) => Interface.Oxide.LogException($"[{Title}] {message}", ex);

        #endregion
    }
}

// --- End of file: PayNow.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/prevent-looting ---
// --- Original File Path: P/PreventLooting/PreventLooting.cs ---

using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Game.Rust;
using UnityEngine;
using System.Reflection;
using Oxide.Core.Libraries.Covalence;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("PreventLooting", "CaseMan", "1.15.0", ResourceId = 2469)]
    [Description("Prevent looting by other players")]

    class PreventLooting : RustPlugin
    {	
		#region Variables
	    [PluginReference] Plugin Friends;
		[PluginReference] Plugin ZoneManager;
		[PluginReference] Plugin DynamicPVP;		
		
		bool UsePermission;
		bool UseFriendsAPI;
		bool UseTeams;
		bool AdminCanLoot;
		bool CanAuthCB;
		bool CanLootPl;
		bool CanLootCorpse;
		bool CanLootEnt;
		bool CanRWMount;
		bool CanRWSwap;
		bool CanRWTake;
		bool CanRWUnload;
		bool CanRWLoad;
		bool CanLootBackpack;
		bool CanLootBackpackPlugin;
		bool CanPickup;
		bool CanOvenToggle;
		bool IncludeZoneMode;
		bool UseZoneManager;
		bool UseDynamicPVP;
		bool UseExcludeEntities;
		bool UseCupboard;
		List<object> UseCupboardInclude;
		bool UseOnlyInCupboardRange;		
		List<object> UseOnlyInCupboardRangeInclude;
		bool WipeDetected = false;
		List<object> ZoneID;
		List<object> ExcludeEntities;
		string PLPerm = "preventlooting.use";
		string PlayerPerm = "preventlooting.player";
		string CorpsePerm = "preventlooting.corpse";
		string BackpackPerm = "preventlooting.backpack";
		string StoragePerm = "preventlooting.storage";
		string AdmPerm = "preventlooting.admin";
	
		class StoredData
        {
            public Dictionary<ulong, EntityData> Data = new Dictionary<ulong, EntityData>();
            public StoredData()
            {
            }
        }

        class EntityData
        {
			public List<ulong> Share = new List<ulong>();
			public Dictionary<string, List<ulong>> Quarry = new Dictionary<string, List<ulong>>();
			public EntityData(){}
        }
		
		StoredData storedData;
		
		#endregion
		#region Initialization
		void Init()
        {
            LoadDefaultConfig();
			permission.RegisterPermission(PLPerm, this);
			permission.RegisterPermission(AdmPerm, this);
			permission.RegisterPermission(PlayerPerm, this);
			permission.RegisterPermission(CorpsePerm, this);
			permission.RegisterPermission(BackpackPerm, this);
			permission.RegisterPermission(StoragePerm, this);
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("PreventLooting");
			
        }
		void OnServerInitialized()
		{
			if(WipeDetected)		
			{
				PrintWarning("Wipe detected! Clearing all share data!");
				storedData.Data.Clear();
				Interface.Oxide.DataFileSystem.WriteObject("PreventLooting", storedData);
			}	
		}	
		void OnServerSave() => Interface.Oxide.DataFileSystem.WriteObject("PreventLooting", storedData);
		void Unload() => Interface.Oxide.DataFileSystem.WriteObject("PreventLooting", storedData);
		void OnNewSave(string filename) => WipeDetected = true;
		#endregion
		#region Configuration
        protected override void LoadDefaultConfig()
        {
			Config["UsePermission"] = UsePermission = GetConfig("UsePermission", false);
			Config["UseFriendsAPI"] = UseFriendsAPI = GetConfig("UseFriendsAPI", true);
			Config["UseTeams"] = UseTeams = GetConfig("UseTeams", true);
			Config["AdminCanLoot"] = AdminCanLoot = GetConfig("AdminCanLoot", true);
			Config["CanAuthorizeCupboard"] = CanAuthCB = GetConfig("CanAuthorizeCupboard", true);
			Config["CanLootPlayer"] = CanLootPl = GetConfig("CanLootPlayer", false);
			Config["CanLootCorpse"] = CanLootCorpse = GetConfig("CanLootCorpse", false);
			Config["CanLootEntity"] = CanLootEnt = GetConfig("CanLootEntity", false);			
			Config["CanRackedWeaponMount"] = CanRWMount = GetConfig("CanRackedWeaponMount", false);
			Config["CanRackedWeaponSwap"] = CanRWSwap = GetConfig("CanRackedWeaponSwap", false);
			Config["CanRackedWeaponTake"] = CanRWTake = GetConfig("CanRackedWeaponTake", false);
			Config["CanRackedWeaponUnload"] = CanRWUnload = GetConfig("CanRackedWeaponUnload", false);
			Config["CanRackedWeaponLoad"] = CanRWLoad = GetConfig("CanRackedWeaponLoad", false);			
			Config["CanLootBackpack"] = CanLootBackpack = GetConfig("CanLootBackpack", false);
			Config["CanLootBackpackPlugin"] = CanLootBackpackPlugin = GetConfig("CanLootBackpackPlugin", false);
			Config["CanPickup"] = CanPickup = GetConfig("CanPickup", false);
			Config["CanOvenToggle"] = CanOvenToggle = GetConfig("CanOvenToggle", false);
			Config["UseZoneManager"] = UseZoneManager = GetConfig("UseZoneManager", false);
			Config["ZoneManagerIncludeMode"] = IncludeZoneMode = GetConfig("ZoneManagerIncludeMode", false);
			Config["ZoneID"] = ZoneID = GetConfig("ZoneID", new List<object>{"12345678"});
			Config["UseDynamicPVP"] = UseDynamicPVP = GetConfig("UseDynamicPVP", false);
			Config["UseExcludeEntities"] = UseExcludeEntities = GetConfig("UseExcludeEntities", true);
			Config["ExcludeEntities"] = ExcludeEntities = GetConfig("ExcludeEntities", new List<object>{"mailbox.deployed"});
			Config["UseCupboard"] = UseCupboard = GetConfig("UseCupboard", false);
			Config["UseCupboardInclude"] = UseCupboardInclude = GetConfig("UseCupboardInclude", new List<object>{"storage"});
			Config["UseOnlyInCupboardRange"] = UseOnlyInCupboardRange = GetConfig("UseOnlyInCupboardRange", false);
			Config["UseOnlyInCupboardRangeInclude"] = UseOnlyInCupboardRangeInclude = GetConfig("UseOnlyInCupboardRangeInclude", new List<object>{"storage"});

			SaveConfig();
        }		
		#endregion		
		#region Localization
		
        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
				["OnTryLootPlayer"] = "You can not loot players!",
				["OnTryLootCorpse"] = "You can not loot corpses of players!",
				["OnTryLootEntity"] = "You can not use this entity because it is not yours!",
				["OnTryLootWeaponRack"] = "You can not use this weapon rack because it is not yours!",
				["OnTryLootBackpack"] = "You can not open this backpack because it is not yours!",
				["OnTryPickup"] = "You can not pickup this because it is not yours!",
				["NoAccess"] = "This entity is not yours!",
				["PlayerNotFound"] = "Player {0} not found!",
				["ShareAll"] = "All players were given permission to use this entity!",
				["SharePlayer"] = "The player {0} was given permission to use this entity!",
				["NoShare"] = "No permissions have been found for this entity!",
				["ListShare"] = "List of permissions for this entity:",
				["EntityNotFound"] = "You are not standing in front of the entity or away from it!",
				["HasShareAllList"] = "All players are allowed to use this entity!",
				["ShareClear"] = "All permissions for this entity have been deleted!",
				["HasShareAll"] = "All players already have permission to use this entity!",
				["HasSharePlayer"] = "Player {0} already has permission to use this entity!",
				["HasUnShareAll"] = "Permission to use this entity has not been issued to all players!",
				["HasUnSharePlayer"] = "Player {0} has not been granted permission to use this entity!",
				["WasUnShareAll"] = "All players have been removed permission for this entity!",
				["WasUnSharePlayer"] = "The permission to use this entity has been removed from player {0}!",
				["MultiplePlayerFind"]="Multiple players found:",
				["OwnEntity"]="This object is yours!",
				["NoPermission"]="You do not have enough rights to execute this command!",
				["EntPrevent"] = "This entity is protected!",
				["EntNoPrevent"] = "This entity is not protected!",	
				["OnTryOnOff"] = "You can not turn on or off this entity because it is not yours!",
				["OnTryAuthCB"] = "You can not authorize in cupboard because it is not yours!",
            }, this);
			lang.RegisterMessages(new Dictionary<string, string>
            {
                ["OnTryLootPlayer"] = "Вы не можете обворовывать игроков!",
                ["OnTryLootCorpse"] = "Вы не можете обворовывать трупы игроков!",
                ["OnTryLootEntity"] = "Вы не можете использовать этот объект, потому что он вам не принадлежит!",
				["OnTryLootWeaponRack"] = "Вы не можете использовать эту оружейную стойку, потому что она вам не принадлежит!",
				["OnTryLootBackpack"] = "Вы не можете открыть чужой рюкзак!",
				["OnTryPickup"] = "Вы не можете взять чужое!",
				["NoAccess"]="Этот объект не принадлежит вам!",
				["PlayerNotFound"]="Игрок с именем {0} не найден!",
				["ShareAll"]="Всем игрокам было выдано разрешение на использование этого объекта!",
				["SharePlayer"]="Игроку {0} было выдано разрешение на использование этого объекта!",
				["NoShare"]="Не найдено разрешений для этого объекта!",
				["ListShare"]="Список разрешений для этого объекта:",
				["EntityNotFound"]="Вы стоите не перед хранилищем или далеко от него!",
				["HasShareAllList"]="Всем игрокам разрешено использовать этот объект!",
				["ShareClear"]="Все разрешения для этого объекта были удалены!",
				["HasShareAll"]="Все игроки уже имеют разрешение на использование этого объекта!",
				["HasSharePlayer"]="Игрок {0} уже имеет разрешение на использование этого объекта!",
				["HasUnShareAll"]="Разрешение на использование этого объекта не было выдано для всех игроков!",
				["HasUnSharePlayer"]="Игроку {0} не было выдано разрешение на использование этого объекта!",	
				["WasUnShareAll"]="Всем игрокам было удалено разрешение на использование этого объекта!",
				["WasUnSharePlayer"]="Игроку {0} было удалено разрешение на использование этого объекта!",
				["MultiplePlayerFind"]="Найдено несколько игроков:",
				["OwnEntity"]="Этот объект принадлежит вам!",
				["NoPermission"]="У вас недостаточно прав для выполнения этой команды!",
				["EntPrevent"]="Этот предмет защищен от воровства!",
				["EntNoPrevent"]="Этот предмет не защищен от воровства!",
				["OnTryOnOff"] = "Вы не можете включить или выключить этот объект, потому что он вам не принадлежит!",
				["OnTryAuthCB"] = "Вы не можете авторизоваться в чужом шкафу, потому что он вам не принадлежит!",
            }, this, "ru");

        }
        #endregion
		#region Hooks
		private object CanLootEntity(BasePlayer player, LootableCorpse corpse)
		{
			if(corpse == null || player == null) return null;
			if(CanLootCorpse) return null;
			if(CheckHelper(player, corpse as BaseEntity)) return null;
			if(IsFriend(corpse.playerSteamID, player.userID)) return null;
			if(UsePermission && !permission.UserHasPermission(corpse.playerSteamID.ToString(), CorpsePerm)) return null;
			if(corpse.playerSteamID < 76561197960265728L || player.userID == corpse.playerSteamID) return null;
			if(UseCupboard || UseOnlyInCupboardRange)
					if(CheckAuthCupboard(corpse, player)) return null;
			SendReply(player, lang.GetMessage("OnTryLootCorpse", this, player.UserIDString));	
			return true;
		}		
		private void OnItemDropped(Item item, BaseEntity entity)
        {
            if (item.info.itemid == -907422733 || item.info.itemid == 2068884361)
            {
                entity.OwnerID = item.GetOwnerPlayer()?.userID ?? 0;
            }
        }
		private object OnItemPickup(Item item, BasePlayer player)
        {            
			if(item == null || player == null) return null;
			BaseEntity entity = item?.GetWorldEntity();
			if(CheckHelper(player, entity)) return null;
			if(entity.OwnerID != 0 && entity.OwnerID != player.userID && !IsFriend(entity.OwnerID, player.userID)) 
			{	
				if(item.info.itemid == -907422733 || item.info.itemid == 2068884361)
				{
					if(UseCupboard || UseOnlyInCupboardRange)
						if(CheckAuthCupboard(entity, player)) return null;
					SendReply(player, lang.GetMessage("OnTryPickup", this, player.UserIDString));
					return false;
				}
				return null;
			}	
			return null;
        }
        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            Item item = entity?.GetItem();	
			if(item == null || player == null) return;
			if(CheckHelper(player, entity)) return;
            if (item.info.itemid == -907422733 || item.info.itemid == 2068884361)
            {
				if(CanLootBackpack) return;
				if(IsFriend(entity.OwnerID, player.userID)) return;
				if(UsePermission && !permission.UserHasPermission(entity.OwnerID.ToString(), BackpackPerm)) return;
				if(entity.OwnerID < 76561197960265728L || player.userID == entity.OwnerID) return;
				if(UseCupboard || UseOnlyInCupboardRange)
					if(CheckAuthCupboard(entity, player)) return;
				NextFrame(() =>
					{
                        player.inventory.loot.Clear();
                        player.inventory.loot.SendImmediate();
                    });
				SendReply(player, lang.GetMessage("OnTryLootBackpack", this, player.UserIDString));	
			}
        }		
		private object CanLootEntity(BasePlayer player, DroppedItemContainer container)
		{
			if(container == null || player == null) return null;
			if(CanLootBackpack && CanLootBackpackPlugin) return null;
			if(CheckHelper(player, container as BaseEntity)) return null;
			if(((container as BaseEntity).name.Contains("item_drop_backpack") && !CanLootBackpack) || ((container as BaseEntity).name.Contains("droppedbackpack") && !CanLootBackpackPlugin))
			{
				if(IsFriend(container.playerSteamID, player.userID)) return null;
				if(UsePermission && !permission.UserHasPermission(container.playerSteamID.ToString(), BackpackPerm)) return null;
				if(container.playerSteamID < 76561197960265728L || player.userID == container.playerSteamID) return null;
				if(UseCupboard || UseOnlyInCupboardRange)
					if(CheckAuthCupboard(container, player)) return null;
				SendReply(player, lang.GetMessage("OnTryLootBackpack", this, player.UserIDString));	
				return true;
			}
			return null;
		}
		private object CanLootPlayer(BasePlayer target, BasePlayer player)
		{
			if(target == null || player == null) return null;
			if(CanLootPl) return null;
			if(CheckHelper(player, target as BaseEntity)) return null;
			if(IsFriend(target.userID, player.userID)) return null;
			if(UsePermission && !permission.UserHasPermission(target.userID.ToString(), PlayerPerm)) return null;
			if(player.userID == target.userID) return null;
			if(UseCupboard || UseOnlyInCupboardRange)
					if(CheckAuthCupboard(target, player)) return null;
			SendReply(player, lang.GetMessage("OnTryLootPlayer", this, player.UserIDString));
			return false;
		}	
		private bool CheckHelper(BasePlayer player, BaseEntity entity)
		{
			if(entity == null || player == null) return true;
			if(player.IsAdmin && AdminCanLoot) return true;
			if(permission.UserHasPermission(player.userID.ToString(), AdmPerm)) return true;
			if(UseZoneManager && ZoneManager != null)
			{	
				if(CheckDynamicPVP(player)) return true;
				if((string[])ZoneManager.Call("GetPlayerZoneIDs", player) != null)
				{					
					if(!IncludeZoneMode)
					{					
						foreach(var zoneID in ZoneID)
						{
							if((bool)ZoneManager.Call("isPlayerInZone", zoneID, player)) return true;
						}
					}
					else
					{
						foreach(var zoneID in ZoneID)
						{
							if((bool)ZoneManager.Call("isPlayerInZone", zoneID, player)) return false;			
						}		
						return true;
					}
				}				
			}
			if(entity is SupplyDrop) return true;
			return false;
		}	
		private bool CheckDynamicPVP(BasePlayer player)
        {
			if(UseDynamicPVP && DynamicPVP != null)
			{	
				var Zones = (string[])ZoneManager.Call("GetPlayerZoneIDs", player);
				foreach (var zoneID in Zones)
				{
					if((bool)DynamicPVP.Call("IsDynamicPVPZone", zoneID)) return true;
				}
			}
            return false;
        }		
		private object CanLootEntity(BasePlayer player, StorageContainer container)
		{
			if(container == null || player == null) return null;
			if(CanLootEnt) return null;
			BaseEntity entity = container as BaseEntity;
			if(CheckHelper(player, entity)) return null;
			BaseEntity childentity = entity;
			entity = CheckParent(entity);
			if(entity.OwnerID == player.userID) return null;
			if(UsePermission && !permission.UserHasPermission(entity.OwnerID.ToString(), StoragePerm)) return null;	
			if(UseExcludeEntities)
			{
				if(ExcludeEntities.Contains(entity.ShortPrefabName)) return null;
			}			
			if(IsVendingOpen(player, entity) || IsDropBoxOpen(player, entity)) return null;
			if(IsFriend(entity.OwnerID, player.userID)) return null;
			if(storedData.Data.ContainsKey(entity.net.ID.Value))
			{
				if(childentity == entity)
				{				
					if(storedData.Data[entity.net.ID.Value].Share.Contains(player.userID) || storedData.Data[entity.net.ID.Value].Share.Contains(0)) return null;
				}
				else
				{
					if(storedData.Data[entity.net.ID.Value].Quarry.ContainsKey(childentity.ShortPrefabName))
						if(storedData.Data[entity.net.ID.Value].Quarry[childentity.ShortPrefabName].Contains(player.userID) || storedData.Data[entity.net.ID.Value].Quarry[childentity.ShortPrefabName].Contains(0)) return null;
				}	
			}
			if(entity.OwnerID != player.userID && entity.OwnerID != 0)
			{			
				if(UseCupboard || UseOnlyInCupboardRange)
					if(CheckAuthCupboard(entity, player)) return null;
				SendReply(player, lang.GetMessage("OnTryLootEntity", this, player.UserIDString));
				return false;	
			}
			return null;
		}		
		private bool CheckRackedWeapon(BasePlayer player, BaseEntity entity)
		{			
			if(CheckHelper(player, entity)) return true;
			if(entity.OwnerID == player.userID) return true;
			if(UsePermission && !permission.UserHasPermission(entity.OwnerID.ToString(), StoragePerm)) return true;	
			if(UseExcludeEntities)
			{
				if(ExcludeEntities.Contains(entity.ShortPrefabName)) return true;
			}			
			if(IsFriend(entity.OwnerID, player.userID)) return true;
			if(storedData.Data.ContainsKey(entity.net.ID.Value))
			{			
				if(storedData.Data[entity.net.ID.Value].Share.Contains(player.userID) || storedData.Data[entity.net.ID.Value].Share.Contains(0)) return true;
			}
			if(entity.OwnerID != player.userID && entity.OwnerID != 0)
			{			
				if(UseCupboard || UseOnlyInCupboardRange)
					if(CheckAuthCupboard(entity, player)) return true;
				SendReply(player, lang.GetMessage("OnTryLootWeaponRack", this, player.UserIDString));
				return false;	
			}
			return true;
		}	
		private object OnRackedWeaponMount(Item weapon, BasePlayer player, WeaponRack rack)
		{
			if(rack == null || player == null || weapon == null) return null;
			if(CanRWMount) return null;
			BaseEntity entity = rack as BaseEntity;
			if(CheckRackedWeapon(player, entity)) return null;
			return false;
		}
		private object OnRackedWeaponSwap(Item weaponMounting, WeaponRackSlot weaponTaking, BasePlayer player, WeaponRack rack)
		{
			if(rack == null || player == null || weaponMounting == null) return null;
			if(CanRWSwap) return null;
			BaseEntity entity = rack as BaseEntity;
			if(CheckRackedWeapon(player, entity)) return null;
			return false;
		}
		private object OnRackedWeaponTake(Item weapon, BasePlayer player, WeaponRack rack)
		{
			if(rack == null || player == null || weapon == null) return null;
			if(CanRWTake) return null;
			BaseEntity entity = rack as BaseEntity;
			if(CheckRackedWeapon(player, entity)) return null;
			return false;
		}
		private object OnRackedWeaponUnload(Item weapon, BasePlayer player, WeaponRack rack)
		{
			if(rack == null || player == null || weapon == null) return null;
			if(CanRWUnload) return null;
			BaseEntity entity = rack as BaseEntity;
			if(CheckRackedWeapon(player, entity)) return null;
			return false;
		}
		private object OnRackedWeaponLoad(Item weapon, ItemDefinition ammoItem, BasePlayer player, WeaponRack rack)
		{
			if(rack == null || player == null || weapon == null) return null;
			if(CanRWLoad) return null;
			BaseEntity entity = rack as BaseEntity;
			if(CheckRackedWeapon(player, entity)) return null;
			return false;
		}
		private object OnOvenToggle(BaseOven oven, BasePlayer player)
		{
			if(oven == null || player == null) return null;
			if(CanOvenToggle) return null;
			BaseEntity entity = oven as BaseEntity;
			if(CheckHelper(player, entity)) return null;
			if(entity.OwnerID == player.userID) return null;
			if(entity.OwnerID != 0 && entity.OwnerID != player.userID && !IsFriend(entity.OwnerID, player.userID)) 
			{	
				if(UseCupboard || UseOnlyInCupboardRange)
					if(CheckAuthCupboard(entity, player)) return null;
				SendReply(player, lang.GetMessage("OnTryOnOff", this, player.UserIDString));
				return false;
			}	
			return null;
		}
		private object CanPickupEntity(BasePlayer player, BaseCombatEntity ent)
		{
			if(ent == null || player == null) return null;
			if(CanPickup) return null;
			BaseEntity entity = ent as BaseEntity;
			if(CheckHelper(player, entity)) return null;
			if(entity.OwnerID != 0 && entity.OwnerID != player.userID && !IsFriend(entity.OwnerID, player.userID)) 
			{	
				if(UseCupboard || UseOnlyInCupboardRange)
					if(CheckAuthCupboard(entity, player)) return null;
				SendReply(player, lang.GetMessage("OnTryPickup", this, player.UserIDString));
				return false;
			}	
			return null;
		}
		private object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
		{
			if(CanAuthCB) return null;
			BaseEntity entity = privilege as BaseEntity;
			if(CheckHelper(player, entity)) return null;
			if(entity.OwnerID != 0 && entity.OwnerID != player.userID && !IsFriend(entity.OwnerID, player.userID)) 
			{	
				SendReply(player, lang.GetMessage("OnTryAuthCB", this, player.UserIDString));
				return false;
			}
			return null;
		}
		private BaseEntity CheckParent(BaseEntity entity)
		{
			if(entity.HasParent())
			{
				BaseEntity parententity = entity.GetParentEntity();
				if(parententity is MiningQuarry)	
				{
					entity.OwnerID=parententity.OwnerID;
					entity=parententity;
				}	
			}
			return entity;	
		}
		object CanAdministerVending(BasePlayer player, VendingMachine machine)
		{
			if(machine == null || player == null) return null;
			if(CanLootEnt) return null;
			BaseEntity entity = machine as BaseEntity;
			if(CheckHelper(player, entity)) return null;
			if(UsePermission && !permission.UserHasPermission(entity.OwnerID.ToString(), StoragePerm)) return null;	
			if(entity.OwnerID == player.userID) return null;
			if(UseExcludeEntities)
			{
				if(ExcludeEntities.Contains(entity.ShortPrefabName)) return null;
			}		
			if(IsFriend(entity.OwnerID, player.userID)) return null;
			if(entity.OwnerID != player.userID && entity.OwnerID != 0)
			{			
				if(UseCupboard || UseOnlyInCupboardRange)
					if(CheckAuthCupboard(entity, player)) return null;
				SendReply(player, lang.GetMessage("OnTryLootEntity", this, player.UserIDString));
				return false;	
			}
			return null;
		}
		bool IsVendingOpen(BasePlayer player, BaseEntity entity)
		{
			if(entity is VendingMachine) 
			{	
				VendingMachine shopFront = entity as VendingMachine;
				if(shopFront.PlayerInfront(player)) return true;
				return false;	
			}
			return false;
		}
		bool IsDropBoxOpen(BasePlayer player, BaseEntity entity)
		{
			if(entity is DropBox) 
			{	
				DropBox dropboxFront = entity as DropBox;
				if(dropboxFront.PlayerInfront(player)) return true;
				return false;		
			}
			return false;
		}		
		bool IsFriend(ulong friendid, ulong playerid)
		{
			if(UseFriendsAPI && Friends != null)	
			{
				var fr = Friends.CallHook("AreFriends", friendid, playerid);
                if (fr != null && (bool)fr) return true;
			}
			if(UseTeams)
			{
				BasePlayer player = BasePlayer.FindByID(playerid);
				if(player == null) return false;
				if (player.currentTeam != (long)0)
				{
					RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
					if(playerTeam == null) return false;
					if(playerTeam.members.Contains(friendid)) return true;	
				}		
			}
			return false;
		}		
		bool FindEntityFromRay(BasePlayer player, out object success)
        {
			success = null;
			RaycastHit hit;
			if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 2.2f))
				return false;
			success = hit.GetEntity();
			return true; 
        }
		bool CheckAuthCupboard(object ent, BasePlayer player)
		{		
			BaseEntity entity = ent as BaseEntity;
			ulong ownerid = 0;
			string type = "";
			if(ent is BaseCombatEntity)
				if((ent as BaseCombatEntity).pickup.enabled) type = "pickup";
			if(ent is StorageContainer || ent is MiningQuarry || ent is WeaponRack)
			{
				ownerid = entity.OwnerID;
				type = "storage";
			}				
			else if(ent is BasePlayer)
			{
				ownerid = (ent as BasePlayer).userID;
				type = "player";
			}				
			else if(ent is LootableCorpse)
			{
				ownerid = (ent as LootableCorpse).playerSteamID;
				type = "corpse";
			}			
			else if(ent is DroppedItemContainer)
			{
				ownerid = (ent as DroppedItemContainer).playerSteamID;
				if(entity.name.Contains("item_drop_backpack")) type = "backpack";
				else if (entity.name.Contains("droppedbackpack")) type = "backpackplugin";
			}				
			BuildingPrivlidge bprev = player.GetBuildingPrivilege(new OBB(entity.transform.position, entity.transform.rotation, entity.bounds));
			if(UseOnlyInCupboardRangeInclude.Contains(type) && bprev == null)	
			{				
				if(UseOnlyInCupboardRange) return true;
				if(!UseOnlyInCupboardRange) return false;
			}
			if(UseCupboard && UseCupboardInclude.Contains(type) && bprev != null)	
			{
				if(ownerid != 0)
				{
					if(bprev.IsAuthed(player) && bprev.authorizedPlayers.Any<ProtoBuf.PlayerNameID>((ProtoBuf.PlayerNameID x) => x.userid == ownerid)) return true;
				}
				else
				{
					if(bprev.IsAuthed(player)) return true;
				}				
			}								
			return false;
		}
		private IPlayer CheckPlayer(BasePlayer player, string[] args)
		{
			var playerlist = covalence.Players.FindPlayers(args[0]).ToList();
			if(playerlist.Count > 1)
			{
				
				var message="<color=#FF0000>"+lang.GetMessage("MultiplePlayerFind", this, player.UserIDString)+"</color>\n";
				int i=0;
				foreach(var pl in playerlist)
				{
					i++;
					message+= string.Format("{0}. <color=#FFA500>{1}</color> ({2})\n\r", i, pl.Name, pl.Id);
				}
				SendReply(player, message);
                return null;
            }
			var player0 = covalence.Players.FindPlayer(args[0]);
			if(player0==null) 
			{
				SendReply(player, string.Format(lang.GetMessage("PlayerNotFound", this, player.UserIDString), "<color=#FFA500>"+args[0]+"</color>")); 
				return null;
			}
			return player0;
		}	
		#endregion
		#region Commands	
		[ChatCommand("share")]
        void Share(BasePlayer player, string command, string[] args)
        {	
		    if (UsePermission && !permission.UserHasPermission(player.UserIDString, PLPerm)) 
			{
				SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
				return;
			}
			IPlayer player0 = null;
			ulong ID;							
			if (args == null || args.Length <= 0) ID=0;
			else
			{	
				player0 = CheckPlayer(player, args);
				if(player0 == null) return;
				ID=Convert.ToUInt64(player0.Id);
			}
			object success;
			if (FindEntityFromRay(player, out success))
			{
				if (success is StorageContainer)
				{	
					BaseEntity entity = success as BaseEntity;
					BaseEntity childentity = entity;
					entity = CheckParent(entity);
					if(entity.OwnerID == ID)
					{
						SendReply(player, lang.GetMessage("OwnEntity", this, player.UserIDString));
						return;
					}				
					if(entity.OwnerID != player.userID && (!player.IsAdmin || (player.IsAdmin && !AdminCanLoot)))
					{
						SendReply(player, lang.GetMessage("NoAccess", this, player.UserIDString));
						return;
					}
					if(!storedData.Data.ContainsKey(entity.net.ID.Value)) 
					{
						var data = new EntityData();
						storedData.Data.Add(entity.net.ID.Value, data);
						if(childentity != entity) 
						{
							data.Quarry = new Dictionary<string, List<ulong>>();
							data.Quarry.Add(childentity.ShortPrefabName, new List<ulong>{ID});
						}
						else
						{
							data.Share = new List<ulong>();							
							data.Share.Add(ID);
						}
						if(ID==0) SendReply(player, lang.GetMessage("ShareAll", this, player.UserIDString));
						else SendReply(player, string.Format(lang.GetMessage("SharePlayer", this, player.UserIDString), "<color=#FFA500>"+player0.Name+"</color>"));
					}	
					else 
					{
						if(childentity == entity)
						{
							if(storedData.Data[entity.net.ID.Value].Share.Contains(ID))
							{
								if(ID==0) SendReply(player, lang.GetMessage("HasShareAll", this, player.UserIDString));
								else SendReply(player, string.Format(lang.GetMessage("HasSharePlayer", this, player.UserIDString), "<color=#FFA500>"+player0.Name+"</color>"));
							}						
							else
							{
								storedData.Data[entity.net.ID.Value].Share.Add(ID);
								if(ID==0) SendReply(player, lang.GetMessage("ShareAll", this, player.UserIDString));
								else SendReply(player, string.Format(lang.GetMessage("SharePlayer", this, player.UserIDString), "<color=#FFA500>"+player0.Name+"</color>"));
							}
						}
						else
						{
							if(!storedData.Data[entity.net.ID.Value].Quarry.ContainsKey(childentity.ShortPrefabName)) storedData.Data[entity.net.ID.Value].Quarry.Add(childentity.ShortPrefabName, new List<ulong>{});
							if(storedData.Data[entity.net.ID.Value].Quarry[childentity.ShortPrefabName].Contains(ID))
							{
								if(ID==0) SendReply(player, lang.GetMessage("HasShareAll", this, player.UserIDString));
								else SendReply(player, string.Format(lang.GetMessage("HasSharePlayer", this, player.UserIDString), "<color=#FFA500>"+player0.Name+"</color>"));
							}						
							else
							{
								if(storedData.Data[entity.net.ID.Value].Quarry.ContainsKey(childentity.ShortPrefabName)) storedData.Data[entity.net.ID.Value].Quarry[childentity.ShortPrefabName].Add(ID);
								else storedData.Data[entity.net.ID.Value].Quarry.Add(childentity.ShortPrefabName, new List<ulong>{ID});
								if(ID==0) SendReply(player, lang.GetMessage("ShareAll", this, player.UserIDString));
								else SendReply(player, string.Format(lang.GetMessage("SharePlayer", this, player.UserIDString), "<color=#FFA500>"+player0.Name+"</color>"));
							}
						}	
					}
				}
				else
				{
					SendReply(player, lang.GetMessage("EntityNotFound", this, player.UserIDString));
				}	
		    }
			else
			{
				SendReply(player, lang.GetMessage("EntityNotFound", this, player.UserIDString));
			}	
        }		
        [ChatCommand("unshare")]
        void Unshare(BasePlayer player, string command, string[] args)
        {
		    if (UsePermission && !permission.UserHasPermission(player.UserIDString, PLPerm)) 
			{
				SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
				return;
			}
			IPlayer player0 = null;
			ulong ID;							
			if (args == null || args.Length <= 0) ID=0;
			else
			{	
				player0 = CheckPlayer(player, args);
				if(player0 == null) return;
				ID=Convert.ToUInt64(player0.Id);
			}
			object success;
			if (FindEntityFromRay(player, out success))			
			{
				if (success is StorageContainer)
				{
					BaseEntity entity = success as BaseEntity;
					BaseEntity childentity = entity;
					entity = CheckParent(entity);
					if(entity.OwnerID != player.userID && (!player.IsAdmin || (player.IsAdmin &&!AdminCanLoot)))
					{
						SendReply(player, lang.GetMessage("NoAccess", this, player.UserIDString));
						return;
					}
					if(!storedData.Data.ContainsKey(entity.net.ID.Value)) 
					{
						SendReply(player, lang.GetMessage("NoShare", this, player.UserIDString));
					}	
					else 
					{
						if(childentity == entity)
						{
							if(!storedData.Data[entity.net.ID.Value].Share.Contains(ID))
							{
								if(ID==0) SendReply(player, lang.GetMessage("HasUnShareAll", this, player.UserIDString));	
								else SendReply(player, string.Format(lang.GetMessage("HasUnSharePlayer", this, player.UserIDString), "<color=#FFA500>"+player0.Name+"</color>"));	
							}
							else
							{
								storedData.Data[entity.net.ID.Value].Share.Remove(ID);
								if(storedData.Data[entity.net.ID.Value].Share.Count==0) storedData.Data.Remove(entity.net.ID.Value);
								if(ID==0) SendReply(player, lang.GetMessage("WasUnShareAll", this, player.UserIDString));
								else SendReply(player, string.Format(lang.GetMessage("WasUnSharePlayer", this, player.UserIDString), "<color=#FFA500>"+player0.Name+"</color>"));
							}
						}
						else
						{
							if(!storedData.Data[entity.net.ID.Value].Quarry.ContainsKey(childentity.ShortPrefabName)) 
							{
								SendReply(player, lang.GetMessage("NoShare", this, player.UserIDString));
								return;
							}
							if(!storedData.Data[entity.net.ID.Value].Quarry[childentity.ShortPrefabName].Contains(ID))
							{
								if(ID==0) SendReply(player, lang.GetMessage("HasUnShareAll", this, player.UserIDString));	
								else SendReply(player, string.Format(lang.GetMessage("HasUnSharePlayer", this, player.UserIDString), "<color=#FFA500>"+player0.Name+"</color>"));	
							}
							else
							{
								storedData.Data[entity.net.ID.Value].Quarry[childentity.ShortPrefabName].Remove(ID);
								if(storedData.Data[entity.net.ID.Value].Quarry[childentity.ShortPrefabName].Count==0) storedData.Data[entity.net.ID.Value].Quarry.Remove(childentity.ShortPrefabName);
								if(ID==0) SendReply(player, lang.GetMessage("WasUnShareAll", this, player.UserIDString));
								else SendReply(player, string.Format(lang.GetMessage("WasUnSharePlayer", this, player.UserIDString), "<color=#FFA500>"+player0.Name+"</color>"));
							}
						}
						Sharelist(player);
					}
				}
				else
				{
					SendReply(player, lang.GetMessage("EntityNotFound", this, player.UserIDString));
				}	
			}	
			else
			{
				SendReply(player, lang.GetMessage("EntityNotFound", this, player.UserIDString));
			}			
		}		
		[ChatCommand("sharelist")]
        void Sharelist(BasePlayer player)
        {
		    if (UsePermission && !permission.UserHasPermission(player.UserIDString, PLPerm)) 
			{
				SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
				return;
			}			
			object success;
			if (FindEntityFromRay(player, out success))			
			{			
				if (success is StorageContainer)
				{
					BaseEntity entity = success as BaseEntity;
					BaseEntity childentity = entity;
					entity = CheckParent(entity);
					if(entity.OwnerID != player.userID && (!player.IsAdmin || (player.IsAdmin &&!AdminCanLoot)))
					{
						SendReply(player, lang.GetMessage("NoAccess", this, player.UserIDString));
						return;
					}
					if(!storedData.Data.ContainsKey(entity.net.ID.Value)) 
					{
						SendReply(player, lang.GetMessage("NoShare", this, player.UserIDString));
					}
					else
					{
						if(childentity == entity)
						{
							if(storedData.Data[entity.net.ID.Value].Share.Contains(0))
							{
								SendReply(player, lang.GetMessage("HasShareAllList", this, player.UserIDString));
								return;
							}	
							var message="<color=#FFFF00>"+lang.GetMessage("ListShare", this, player.UserIDString)+"</color>\n";
							int i=0;
							foreach(var share in storedData.Data[entity.net.ID.Value].Share)
							{
								i++;
								message+= string.Format("{0}. <color=#00FF00>{1}</color> ({2})\n\r", i, covalence.Players.FindPlayer(share.ToString()).Name, covalence.Players.FindPlayer(share.ToString()).Id);
							}	
							SendReply(player, message);
						}
						else
						{
							if(!storedData.Data[entity.net.ID.Value].Quarry.ContainsKey(childentity.ShortPrefabName)) 
							{
								SendReply(player, lang.GetMessage("NoShare", this, player.UserIDString));
								return;
							}
							if(storedData.Data[entity.net.ID.Value].Quarry[childentity.ShortPrefabName].Contains(0))
							{
								SendReply(player, lang.GetMessage("HasShareAllList", this, player.UserIDString));
								return;
							}	
							var message="<color=#FFFF00>"+lang.GetMessage("ListShare", this, player.UserIDString)+"</color>\n";
							int i=0;
							foreach(var share in storedData.Data[entity.net.ID.Value].Quarry[childentity.ShortPrefabName])
							{
								i++;
								message+= string.Format("{0}. <color=#00FF00>{1}</color> ({2})\n\r", i, covalence.Players.FindPlayer(share.ToString()).Name, covalence.Players.FindPlayer(share.ToString()).Id);
							}	
							SendReply(player, message);
						}	
					}
				}
				else
				{
					SendReply(player, lang.GetMessage("EntityNotFound", this, player.UserIDString));
				}
			}
			else
			{
				SendReply(player, lang.GetMessage("EntityNotFound", this, player.UserIDString));
			}
		}		
		[ChatCommand("shareclear")]
        void Shareclear(BasePlayer player)
        {
		    if (UsePermission && !permission.UserHasPermission(player.UserIDString, PLPerm)) 
			{
				SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
				return;
			}			
			object success;
			if (FindEntityFromRay(player, out success))			
			{
				if (success is StorageContainer)
				{
					BaseEntity entity = success as BaseEntity;
					BaseEntity childentity = entity;
					entity = CheckParent(entity);
					if(entity.OwnerID != player.userID && (!player.IsAdmin || (player.IsAdmin &&!AdminCanLoot)))
					{
						SendReply(player, lang.GetMessage("NoAccess", this, player.UserIDString));
						return;
					}
					if(!storedData.Data.ContainsKey(entity.net.ID.Value)) 
					{
						SendReply(player, lang.GetMessage("NoShare", this, player.UserIDString));
					}
					else
					{
						if(childentity == entity)
						{
							storedData.Data[entity.net.ID.Value].Share.Clear();
							if(storedData.Data[entity.net.ID.Value].Share.Count==0) storedData.Data.Remove(entity.net.ID.Value);
							SendReply(player, lang.GetMessage("ShareClear", this, player.UserIDString));
						}
						else
						{
							if(!storedData.Data[entity.net.ID.Value].Quarry.ContainsKey(childentity.ShortPrefabName))
							{
								SendReply(player, lang.GetMessage("NoShare", this, player.UserIDString));
								return;
							}
							storedData.Data[entity.net.ID.Value].Quarry[childentity.ShortPrefabName].Clear();
							if(storedData.Data[entity.net.ID.Value].Quarry[childentity.ShortPrefabName].Count==0) storedData.Data[entity.net.ID.Value].Quarry.Remove(childentity.ShortPrefabName);
							SendReply(player, lang.GetMessage("ShareClear", this, player.UserIDString));
						}
					}
				}
				else
				{
					SendReply(player, lang.GetMessage("EntityNotFound", this, player.UserIDString));
				}				
			}
			else
			{
				SendReply(player, lang.GetMessage("EntityNotFound", this, player.UserIDString));
			}
		}
		[ChatCommand("checkit")]
        void CheckBP(BasePlayer player)
        {
		    if (UsePermission && !permission.UserHasPermission(player.UserIDString, PLPerm)) 
			{
				SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
				return;
			}			
			object success;
			if (FindEntityFromRay(player, out success))			
			{			
				if (success is StorageContainer)
				{
					BaseEntity entity = success as BaseEntity;
					entity = CheckParent(entity);
					if(entity.OwnerID != player.userID && (!player.IsAdmin || (player.IsAdmin &&!AdminCanLoot)))
					{
						SendReply(player, lang.GetMessage("NoAccess", this, player.UserIDString));
						return;
					}
					if(UseOnlyInCupboardRange)
					{
						BuildingPrivlidge bprev = player.GetBuildingPrivilege(new OBB(entity.transform.position, entity.transform.rotation, entity.bounds));
						if(bprev == null) SendReply(player, "<color=#FF0000>"+lang.GetMessage("EntNoPrevent", this, player.UserIDString)+"</color>\n");
						else SendReply(player, "<color=#CCFF00>"+lang.GetMessage("EntPrevent", this, player.UserIDString)+"</color>\n");		
					}	
					else SendReply(player, "<color=#CCFF00>"+lang.GetMessage("EntPrevent", this, player.UserIDString)+"</color>\n");	
				}
			}
			else
			{
				SendReply(player, lang.GetMessage("EntityNotFound", this, player.UserIDString));
			}
		}
		#endregion
		#region Helpers
		T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T) Convert.ChangeType(Config[name], typeof(T)); 
		#endregion
    }
}


// --- End of file: PreventLooting.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/recycle-modifier ---
// --- Original File Path: R/RecycleModifier/RecycleModifier.cs ---

﻿using Newtonsoft.Json;
using System;
using System.Collections.Generic;
namespace Oxide.Plugins
{
    [Info("Recycle Modifier", "birthdates", "1.0.3")]
    [Description("Ability to change the output of the recycler")]
    public class RecycleModifier : RustPlugin
    {
        private ConfigFile config;

        public class ConfigFile
        {
            [JsonProperty(PropertyName = "Blacklisted items (wont get the modifier)")]
            public List<string> bAP;

            [JsonProperty(PropertyName = "Modifier")]
            public float mod;



            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                    mod = 2f,
                    bAP = new List<string>()
                    {
                        "rock",
                        "locker"
                    }

                };
            }

        }


        void OnRecycleItem(Recycler recycler, Item item)
        {

            if (config.bAP.Contains(item.info.shortname))
            {
                return;
            }

            recycler.inventory.Remove(item);
            foreach (var i in item.info.Blueprint.ingredients)
            {
                var z = ItemManager.CreateByPartialName(i.itemDef.shortname, Convert.ToInt32(Convert.ToInt32(i.amount / 2) * config.mod - (int)i.amount / 2));
                if(z == null) continue;
                recycler.MoveItemToOutput(z);

            }


        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            config = Config.ReadObject<ConfigFile>();
            if (config == null)
            {
                LoadDefaultConfig();
            }
        }


        protected override void LoadDefaultConfig()
        {
            config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoPermission", "You don't have any permission."},
            }, this);
        }



        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private void Init()
        {
            LoadConfig();
        }



    }
}

// --- End of file: RecycleModifier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/raid-tracker ---
// --- Original File Path: R/RaidTracker/RaidTracker.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Raid Tracker", "Mabel", "2.1.3")]
    [Description("Track raids by explosives, weapons, and ammo with detailed on-screen visuals")]
    class RaidTracker : CovalencePlugin
    {
        private readonly bool _dev = false; // force certain config options
        private bool _debug = false; // respect config, detailed output
        private readonly float _debugDrawDuration = 15f;
        private static RaidTracker _instance;
        private PluginConfig _config;
        private bool _isConfigValid = true;
        private readonly StringBuilder _sb = new StringBuilder();
        private readonly Game.Rust.Libraries.Player _rustPlayer = Interface.Oxide.GetLibrary<Game.Rust.Libraries.Player>("Player");

        private readonly DiscordWebhookManager _discordWebhookManager = new DiscordWebhookManager();
        private readonly int _collisionLayerMask = LayerMask.GetMask("Construction", "Deployed");
        private readonly Dictionary<Vector3, ulong> _MLRSRocketOwners = new Dictionary<Vector3, ulong>();
        private readonly Dictionary<ulong, bool> _verboseMode = new Dictionary<ulong, bool>();
        private readonly Dictionary<ulong, string[]> _lastViewCommand = new Dictionary<ulong, string[]>();
        private Dictionary<string, DecayEntityIgnoreOptions> _decayEntityIgnoreList = new Dictionary<string, DecayEntityIgnoreOptions>();
        private readonly Dictionary<string, string> _prefabToItem = new Dictionary<string, string>();
        private readonly Dictionary<string, string> _buildingBlockPrettyNames = new Dictionary<string, string>();
        private readonly Dictionary<ulong, float> _notificationCooldown = new Dictionary<ulong, float>();

        private bool _wipeData;
        private List<RaidEvent> _raidEventLog = new List<RaidEvent>();
        private string _raidEventLogFilename;
        private int _raidEventLogCount;

        private readonly string[] _ignoredTimedExplosives = new string[] {
            "firecrackers.deployed",
            "flare.deployed",
            "maincannonshell",
            "rocket_heli",
            "rocket_heli_napalm"
        };

        private readonly string[] _uniqueHexColors = new string[] {
            "#01FFFE", "#FFA6FE", "#FFDB66", "#006401", "#010067",
            "#95003A", "#007DB5", "#FF00F6", "#FFEEE8", "#774D00",
            "#90FB92", "#0076FF", "#D5FF00", "#FF937E", "#6A826C",
            "#FF029D", "#FE8900", "#7A4782", "#7E2DD2", "#85A900",
            "#FF0056", "#A42400", "#00AE7E", "#683D3B", "#BDC6FF",
            "#263400", "#BDD393", "#00B917", "#9E008E", "#001544",
            "#C28C9F", "#FF74A3", "#01D0FF", "#004754", "#E56FFE",
            "#788231", "#0E4CA1", "#91D0CB", "#BE9970", "#968AE8",
            "#BB8800", "#43002C", "#DEFF74", "#00FFC6", "#FFE502",
            "#620E00", "#008F9C", "#98FF52", "#7544B1", "#B500FF",
            "#00FF78", "#FF6E41", "#005F39", "#6B6882", "#5FAD4E",
            "#A75740", "#A5FFD2", "#FFB167", "#009BFF", "#E85EBE",
            "#00FF00", "#0000FF", "#FF0000", "#000000"
        };
        private readonly List<Color> _uniqueColors = new List<Color>();
        private readonly Dictionary<ulong, Color> _teamColors = new Dictionary<ulong, Color>();
        private int _currentTeamColorIdx = 0;

        [PluginReference]
        private readonly Plugin AbandonedBases, Clans, RaidableBases;

        private const string PERM_WIPE = "raidtracker.wipe";
        private const string PERM_PX = "raidtracker.px";

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PERM_WIPE, this);
            permission.RegisterPermission(PERM_PX, this);

            Unsubscribe(nameof(OnPlayerDisconnected));
            Unsubscribe(nameof(OnMlrsFired));
            Unsubscribe(nameof(OnMlrsFiringEnded));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(OnServerSave));
        }

        private void OnServerInitialized()
        {
            _debug = _debug || _config.debug;
            if (_dev)
            {
                _debug = true;
                Puts("[DEV] Dev mode enabled!");
            }

            PrintDebug("Debug mode enabled!");

            _raidEventLogFilename = $"{Name}\\RaidEventLog";
            _raidEventLog = Interface.Oxide.DataFileSystem.ReadObject<List<RaidEvent>>(_raidEventLogFilename);
            _raidEventLogCount = _raidEventLog.Count;

            foreach (string hexColor in _uniqueHexColors)
            {
                Color color;
                if (ColorUtility.TryParseHtmlString(hexColor, out color))
                    _uniqueColors.Add(color);
            }

            foreach (var item in ItemManager.itemList.OrderBy(x => x.shortname))
            {
                ItemModEntity itemModEnt = item.GetComponent<ItemModEntity>();
                if (itemModEnt != null)
                {
                    var gameObjRef = itemModEnt.entityPrefab;
                    if (string.IsNullOrEmpty(gameObjRef.guid)) continue;

                    AddPrefabToItem(gameObjRef.resourcePath, item.shortname, nameof(ItemModEntity));
                }

                ItemModDeployable itemModDeploy = item.GetComponent<ItemModDeployable>();
                if (itemModDeploy != null)
                {
                    var gameObjRef = itemModDeploy.entityPrefab;
                    if (string.IsNullOrEmpty(gameObjRef.guid)) continue;

                    AddPrefabToItem(gameObjRef.resourcePath, item.shortname, nameof(ItemModDeployable));
                }

                ItemModProjectile itemModProj = item.GetComponent<ItemModProjectile>();
                if (itemModProj != null)
                {
                    var gameObjRef = itemModProj.projectileObject;
                    if (string.IsNullOrEmpty(gameObjRef.guid)) continue;

                    AddPrefabToItem(gameObjRef.resourcePath, item.shortname, nameof(ItemModProjectile));
                }
            }

            if (_wipeData && _config.deleteDataOnWipe)
            {
                Puts($"Wipe detected! Removing {_raidEventLog.Count} raid events.");
                _wipeData = false;
                _raidEventLog = new List<RaidEvent>();
                SaveRaidEventLog();
            }

            if (_raidEventLog.Count > 0)
            {
                int removed = 0;
                DateTime currentDateTime = DateTime.Now;
                for (int i = _raidEventLog.Count - 1; i >= 0; i--)
                {
                    RaidEvent raidEvent = _raidEventLog[i];
                    if (currentDateTime.Subtract(raidEvent.timestamp).TotalDays >= _config.daysBeforeDelete)
                    {
                        _raidEventLog.RemoveAt(i);
                        removed++;
                    }
                }

                if (removed > 0)
                {
                    Puts($"Removed {removed} raid events older than {_config.daysBeforeDelete} days");
                    SaveRaidEventLog();
                }
            }

            var saveList = false;
            var decayEntityListFilename = $"{Name}\\DecayEntityIgnoreList";
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(decayEntityListFilename))
            {
                Puts($"Generating DecayEntityIgnoreList, any items enabled in this list will be ignored by the plugin");
                Puts($"Saving DecayEntityIgnoreList to /oxide/data/{Utility.CleanPath(decayEntityListFilename)}.json");
            }

            _decayEntityIgnoreList = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, DecayEntityIgnoreOptions>>(decayEntityListFilename);

            Dictionary<BuildingGrade.Enum, string> buildingGradeNames = new Dictionary<BuildingGrade.Enum, string> {
                { BuildingGrade.Enum.Twigs, "Twig" },
                { BuildingGrade.Enum.TopTier, "HQM" }
            };

            foreach (var prefab in GameManifest.Current.entities)
            {
                var gameObj = GameManager.server.FindPrefab(prefab);
                if (gameObj == null) continue;

                var thrownWep = gameObj.GetComponent<ThrownWeapon>();
                if (thrownWep != null)
                {
                    var itemShortname = GetItemFromPrefabShortname(thrownWep.ShortPrefabName); // get item shortname from held entity
                    AddPrefabToItem(thrownWep.prefabToThrow.resourcePath, itemShortname, nameof(ThrownWeapon)); // assign deployed entity to same item shortname

                    PrintDebug($"  {thrownWep.ShortPrefabName}[{thrownWep.GetType()}] -> {GetPrefabShortname(thrownWep.prefabToThrow.resourcePath)} -> {itemShortname}");
                }

                var ent = gameObj.GetComponent<DecayEntity>();
                if (ent != null)
                {
                    var itemShortname = GetItemFromPrefabShortname(ent.ShortPrefabName);
                    if (!_decayEntityIgnoreList.ContainsKey(ent.PrefabName))
                    {
                        var item = ItemManager.FindItemDefinition(itemShortname);
                        var itemName = item != null ? $"{item?.displayName?.english ?? "Unknown"} ({itemShortname})" : "";
                        _decayEntityIgnoreList[ent.PrefabName] = new DecayEntityIgnoreOptions
                        {
                            name = itemName,
                            ignore = false,
                            ignoreDiscord = false
                        };
                        LogToSingleFile("decay_entity_log", $"added {ent.PrefabName} {(!string.IsNullOrEmpty(itemName) ? $"[ITEM: {itemName}]" : "")}");
                        saveList = true;
                    }

                    if (ent is BuildingBlock)
                    {
                        PrintDebug($"BuildingBlock - {ent.ShortPrefabName}");

                        Type gradeType = typeof(BuildingGrade.Enum);
                        foreach (var grade in Enum.GetNames(gradeType))
                        {
                            var e = (BuildingGrade.Enum)Enum.Parse(gradeType, grade);
                            if (e == BuildingGrade.Enum.None || e == BuildingGrade.Enum.Count) continue;

                            var buildingBlockItemShortname = $"{ent.ShortPrefabName}.{grade.ToLower()}";
                            var gradeName = buildingGradeNames.ContainsKey(e) ? buildingGradeNames[e] : grade;
                            var prettyName = $"{gradeName} {ent.prefabAttribute.Find<Construction>(StringPool.Get(ent.PrefabName))?.info.name?.english ?? "Unknown"}";
                            _buildingBlockPrettyNames[buildingBlockItemShortname] = prettyName;

                            PrintDebug($"   BuildingGrade[{grade}] - {prettyName}[{buildingBlockItemShortname}]");
                        }
                    }
                }
            }

            if (saveList)
            {
                var sorted = _decayEntityIgnoreList
                    .OrderBy(x => string.IsNullOrWhiteSpace(x.Value.name))
                    .ThenBy(x => x.Value.name)
                    .ToDictionary(x => x.Key, x => x.Value);

                Interface.Oxide.DataFileSystem.WriteObject(decayEntityListFilename, sorted);
            }

            var saveCfg = false;
            foreach (var trackerList in _config.trackers)
            {
                foreach (var weaponCfg in trackerList.Value)
                {
                    if (!string.IsNullOrEmpty(weaponCfg.Value.name)) continue;

                    var shortname = GetItemFromPrefabShortname(weaponCfg.Key);
                    weaponCfg.Value.name = GetPrettyItemName(shortname);
                    saveCfg = true;
                }
            }

            // Don't overwrite the config if invalid since the user will lose their config!
            if (_isConfigValid && saveCfg)
                SaveConfig();

            Subscribe(nameof(OnPlayerDisconnected));
            Subscribe(nameof(OnMlrsFired));
            Subscribe(nameof(OnMlrsFiringEnded));
            Subscribe(nameof(OnEntitySpawned));
            Subscribe(nameof(OnEntityDeath));
            Subscribe(nameof(OnServerSave));
        }

        private void Unload()
        {
            var trackers = UnityEngine.Object.FindObjectsOfType<ExplosiveTracker>();
            if (trackers != null && trackers.Length > 0)
            {
                Puts($"Destroying {trackers.Length} explosive trackers");
                foreach (var t in trackers)
                {
                    t.logEvent = false;
                    UnityEngine.Object.Destroy(t);
                }
            }

            _instance = null;
            SaveRaidEventLog();
        }

        private void OnPlayerDisconnected(BasePlayer pl, string reason)
        {
            _verboseMode.Remove(pl.userID);
            _lastViewCommand.Remove(pl.userID);
            _notificationCooldown.Remove(pl.userID);
        }

        private void OnMlrsFired(MLRS mlrs, BasePlayer driver)
        {
            _MLRSRocketOwners[mlrs.transform.position] = driver.userID;
        }

        private void OnMlrsFiringEnded(MLRS mlrs)
        {
            _MLRSRocketOwners.Remove(mlrs.transform.position);
        }

        private void OnEntitySpawned(TimedExplosive ent)
        {
            if (ent == null || _ignoredTimedExplosives.Contains(ent.ShortPrefabName)) return;

            var trackerCategory = "entity_collision";
            if (!AddOrFindWeaponConfig(trackerCategory, ent.ShortPrefabName).enabled) return;

            if (ent is MLRSRocket && _MLRSRocketOwners.Count > 0) // fix MLRS rocket creatorEntity being null when there is no driver in the MLRS truck
            {
                var mlrsOwnerID = _MLRSRocketOwners.First(x => Vector3.Distance(x.Key, ent.transform.position) < 25f).Value;
                var mlrsOwner = BasePlayer.FindByID(mlrsOwnerID);
                if (mlrsOwner != null)
                {
                    ent.creatorEntity = mlrsOwner;
                    ent.OwnerID = mlrsOwner.userID;
                }
            }

            var tracker = ent.gameObject.AddComponent<ExplosiveTracker>();
            if (tracker != null)
            {
                tracker.Init(trackerCategory);
            }

            if (_debug)
            {
                var pl = ent.creatorEntity as BasePlayer;
                PrintDebug($"Added explosive tracker to {ent.ShortPrefabName} spawned by {pl?.displayName ?? "Unknown"}[{pl?.userID ?? 0}]");
            }
        }

        private void OnEntityDeath(DecayEntity entity, HitInfo info)
        {
            if (entity == null || info == null)
                return;

            var initiator = info.Initiator;
            if (initiator is FireBall) // Log fireballs spawned from inc ammo, fire arrows, etc
            {
                var fireballTrackerCategory = "entity_death_fire";
                var fireballWeaponCfg = AddOrFindWeaponConfig(fireballTrackerCategory, initiator.ShortPrefabName);
                if (!fireballWeaponCfg.enabled || IsDecayEntityIgnored(entity))
                    return;

                var creator = initiator.creatorEntity as BasePlayer;
                RaidEvent raidEventFireball = new RaidEvent
                {
                    attackerName = creator?.displayName ?? fireballWeaponCfg.name,
                    attackerSteamID = creator?.userID ?? 0,
                    attackerTeamID = creator?.Team?.teamID ?? 0,
                    victimSteamID = entity.OwnerID,
                    weapon = $"{initiator.ShortPrefabName}[{fireballTrackerCategory}]",
                    hitEntity = $"EVENT.BURNT {GetDecayEntityShortname(entity)}",
                    startPos = entity.transform.position + new Vector3(0, .2f, 0),
                    endPos = entity.transform.position,
                    timestamp = DateTime.Now
                };
                _raidEventLog.Add(raidEventFireball);
                raidEventFireball.Notify(entity);

                PrintDebug($"OnEntityDeath ({initiator.ShortPrefabName}) - WeaponPrefab: {info?.WeaponPrefab?.ShortPrefabName ?? "NULL"}, ProjectilePrefab: {info?.ProjectilePrefab?.name ?? "NULL"}");
                PrintDebug($"{initiator.ShortPrefabName} ({initiator.creatorEntity}) BURNT {GetDecayEntityShortname(entity)}[{entity?.net?.ID.Value ?? 0}]");
                return;
            }

            var attacker = info.InitiatorPlayer;
            if (attacker == null || IsDecayEntityOrAttackerIgnored(entity, attacker))
                return;

            if (info?.WeaponPrefab == null && info?.damageTypes?.GetMajorityDamageType() == Rust.DamageType.Heat) // Log fires spawned from flame throwers or other weapons
            {
                var fireTrackerCategory = "entity_death_fire";
                var fireWeapon = "fire_damage";
                var fireWeaponCfg = AddOrFindWeaponConfig(fireTrackerCategory, fireWeapon);
                if (!fireWeaponCfg.enabled)
                    return;

                RaidEvent raidEventFire = new RaidEvent
                {
                    attackerName = attacker?.displayName ?? "Unknown",
                    attackerSteamID = attacker?.userID ?? 0,
                    attackerTeamID = attacker?.Team?.teamID ?? 0,
                    victimSteamID = entity.OwnerID,
                    weapon = $"{fireWeapon}[{fireTrackerCategory}]",
                    hitEntity = $"EVENT.BURNT {GetDecayEntityShortname(entity)}",
                    startPos = entity.transform.position + new Vector3(0, .2f, 0),
                    endPos = entity.transform.position,
                    timestamp = DateTime.Now
                };
                _raidEventLog.Add(raidEventFire);
                raidEventFire.Notify(entity);

                PrintDebug($"OnEntityDeath ({fireWeapon}) - WeaponPrefab: {info?.WeaponPrefab?.ShortPrefabName ?? "NULL"}, ProjectilePrefab: {info?.ProjectilePrefab?.name ?? "NULL"}");
                PrintDebug($"{fireWeapon} BURNT {GetDecayEntityShortname(entity)}[{entity?.net?.ID.Value ?? 0}]");
                return;
            }

            var weaponPrefabShortname = info?.WeaponPrefab?.ShortPrefabName;
            var projectilePrefabShortname = info?.ProjectilePrefab?.name;
            var projectileItemShortname = projectilePrefabShortname != null ? GetItemFromPrefabShortname(projectilePrefabShortname) : null;

            var heldEntity = attacker.GetHeldEntity();
            if (heldEntity is AttackEntity)
            {
                if (info.WeaponPrefab == null)
                {
                    weaponPrefabShortname = heldEntity.ShortPrefabName;

                    PrintDebug($"OnEntityDeath - WeaponPrefab is NULL! Using HeldEntity: {heldEntity.ShortPrefabName ?? "NULL"}");
                }

                var projectile = heldEntity?.GetComponent<BaseProjectile>();
                var heldProjectileItemShortname = projectile?.primaryMagazine?.ammoType?.shortname ?? null;
                if ((info.WeaponPrefab == null && info.ProjectilePrefab == null)
                    || (projectileItemShortname != null && heldProjectileItemShortname != null && projectileItemShortname != heldProjectileItemShortname)) // certain projectiles from HitInfo do not match the projectile in the players gun Ex: ammo.pistol.hv, rifle.ammmo.hv, ammo.shotgun
                {
                    if (_debug)
                    {
                        if (projectileItemShortname != heldProjectileItemShortname)
                            PrintDebug($"OnEntityDeath - ProjectileItemShortname ({projectileItemShortname ?? "NULL"}) != HeldProjectileItemShortname ({heldProjectileItemShortname ?? "NULL"})! Using HeldProjectileItemShortname: {heldProjectileItemShortname ?? "NULL"}");
                        else
                            PrintDebug($"OnEntityDeath - WeaponPrefab + ProjectilePrefab are NULL! Using HeldEntityProjectile: {projectileItemShortname ?? "NULL"}");
                    }

                    projectileItemShortname = heldProjectileItemShortname;
                }
            }

            var weaponTrackerCategory = "entity_death_weapon";
            var weaponItemShortname = weaponPrefabShortname != null ? GetItemFromPrefabShortname(weaponPrefabShortname) : null;
            var weaponEnabled = weaponItemShortname != null ? AddOrFindWeaponConfig(weaponTrackerCategory, weaponItemShortname).enabled : false;

            var projectileTrackerCategory = "entity_death_ammo";
            var projectileEnabled = projectileItemShortname != null && weaponItemShortname != projectileItemShortname ? AddOrFindWeaponConfig(projectileTrackerCategory, projectileItemShortname).enabled : false;

            PrintDebug($"OnEntityDeath - WeaponPrefab: {info?.WeaponPrefab?.ShortPrefabName ?? "NULL"} ({weaponItemShortname ?? "NULL"}), ProjectilePrefab: {info?.ProjectilePrefab?.name ?? "NULL"} ({projectileItemShortname ?? "NULL"})");

            if (!weaponEnabled && !projectileEnabled) return;

            string weapon;
            if (weaponEnabled && projectileItemShortname != null && weaponItemShortname != projectileItemShortname)
                weapon = $"{weaponItemShortname}[{weaponTrackerCategory}];{projectileItemShortname}[{projectileTrackerCategory}]";
            else if (projectileEnabled && weaponItemShortname != null && weaponItemShortname != projectileItemShortname)
                weapon = $"{projectileItemShortname}[{projectileTrackerCategory}];{weaponItemShortname}[{weaponTrackerCategory}]";
            else if (projectileEnabled)
                weapon = $"{projectileItemShortname}[{projectileTrackerCategory}]";
            else
                weapon = $"{weaponItemShortname}[{weaponTrackerCategory}]";

            var startPos = attacker.transform.position;
            startPos.y += attacker.GetHeight() - .5f;
            var endPos = info.HitPositionWorld != Vector3.zero && info.HitPositionWorld != entity.transform.position ? info.HitPositionWorld : entity.WorldSpaceBounds().ToBounds().center;

            RaidEvent raidEvent = new RaidEvent
            {
                attackerName = attacker?.displayName ?? "Unknown",
                attackerSteamID = attacker?.userID ?? 0,
                attackerTeamID = attacker?.Team?.teamID ?? 0,
                victimSteamID = entity.OwnerID,
                weapon = weapon,
                hitEntity = $"EVENT.DESTROYED {GetDecayEntityShortname(entity)}",
                startPos = startPos,
                endPos = endPos,
                timestamp = DateTime.Now
            };
            _raidEventLog.Add(raidEvent);
            raidEvent.Notify(entity);

            PrintDebug($"{weapon} DESTROYED {GetDecayEntityShortname(entity)}[{entity?.net?.ID.Value ?? 0}]");
        }

        private void OnServerSave()
        {
            SaveRaidEventLog();
        }

        private void OnNewSave(string filename)
        {
            _wipeData = true;
        }

        #endregion

        #region Commands

        [Command("x")]
        private void ViewExplosionsCommand(IPlayer player, string command, string[] args)
        {
            BasePlayer pl = player.Object as BasePlayer;
            if (pl == null || !pl.IsAdmin) return;

            if (args.Length > 0 && (args[0].ToLower() == "v" || args[0].ToLower() == "extra"))
            {
                _verboseMode[pl.userID] = _verboseMode.ContainsKey(pl.userID) ? !_verboseMode[pl.userID] : true;
                SendChatMsg(pl, lang.GetMessage(_verboseMode[pl.userID] ? "ViewEventsCommand.ExtraModeEnabled" : "ViewEventsCommand.ExtraModeDisabled", this, pl.UserIDString));
                return;
            }

            float radius = _config.searchRadius > 0f ? _config.searchRadius : 50f;
            string filterType = args.Length > 0 ? args[0].ToLower() : "";
            string filter = "";
            bool verbose = _verboseMode.ContainsKey(pl.userID) && _verboseMode[pl.userID];

            Vector3 pos = pl.transform.position;
            pos.y += pl.GetHeight() - .5f;

            float tempRadius;
            IEnumerable<IGrouping<RaidFilter, RaidEvent>> groupedRaidsNearMe;
            switch (filterType)
            {
                case "l":
                case "last":
                    string[] lastArgs;
                    if (_lastViewCommand.TryGetValue(pl.userID, out lastArgs))
                        ViewExplosionsCommand(player, command, lastArgs);
                    return;
                case "help":
                    _sb.Clear();
                    _sb.AppendLine(lang.GetMessage("ViewEventsCommand.HelpHeader", this, pl.UserIDString));
                    _sb.AppendLine(lang.GetMessage("ViewEventsCommand.HelpDefault", this, pl.UserIDString));
                    _sb.AppendLine(lang.GetMessage("ViewEventsCommand.HelpExtraMode", this, pl.UserIDString));
                    _sb.AppendLine(lang.GetMessage("ViewEventsCommand.HelpWipe", this, pl.UserIDString));
                    _sb.AppendLine(lang.GetMessage("ViewEventsCommand.HelpLast", this, pl.UserIDString));
                    _sb.AppendLine(lang.GetMessage("ViewEventsCommand.HelpFilter", this, pl.UserIDString));
                    _sb.Append("<indent=6>");
                    _sb.AppendLine(lang.GetMessage("ViewEventsCommand.HelpFilterTime", this, pl.UserIDString));
                    _sb.AppendLine(lang.GetMessage("ViewEventsCommand.HelpFilterWeapon", this, pl.UserIDString));
                    _sb.AppendLine(lang.GetMessage("ViewEventsCommand.HelpFilterEntity", this, pl.UserIDString));
                    _sb.AppendLine(lang.GetMessage("ViewEventsCommand.HelpFilterTeam", this, pl.UserIDString));
                    _sb.AppendLine(lang.GetMessage("ViewEventsCommand.HelpFilterPlayer", this, pl.UserIDString));
                    _sb.Append("<indent=0>");
                    _sb.AppendLine(lang.GetMessage("ViewEventsCommand.HelpPrintRaidEvent", this, pl.UserIDString));
                    SendChatMsg(pl, _sb.ToString(), "");

                    return;
                case "wipe":
                    if (!permission.UserHasPermission(pl.UserIDString, PERM_WIPE))
                    {
                        SendChatMsg(pl, lang.GetMessage("ViewEventsCommand.WipePermission", this, pl.UserIDString));
                        return;
                    }

                    if (args.Length > 1 && float.TryParse(args[1], out tempRadius))
                        radius = tempRadius;

                    var raidEventsToWipe = FindRaidEventsInSphere(pos, radius).ToList();
                    if (raidEventsToWipe.Count == 0)
                    {
                        SendChatMsg(pl, string.Format(lang.GetMessage("ViewEventsCommand.NotFoundRadius", this, pl.UserIDString), radius));
                        return;
                    }

                    foreach (var raidEvent in raidEventsToWipe)
                    {
                        int idx = raidEvent.GetIndex();
                        if (idx > -1)
                            _raidEventLog.RemoveAt(idx);
                    }

                    var playerPos = pl.transform.position;
                    var gridPos = MapHelper.PositionToString(playerPos);
                    var filename = $"{Name}\\WipedRaidEvents\\{string.Format("{0:yyyy-MM-dd}", DateTime.Now)}\\{pl.userID}\\{gridPos}_{string.Format("{0:h-mm-tt}", DateTime.Now)}";
                    LogToFile("wiped_raid_events", $"{pl.displayName}[{pl.userID}] wiped {raidEventsToWipe.Count} raid events in {gridPos} ({FormatPosition(playerPos)})", this);
                    Interface.Oxide.DataFileSystem.WriteObject(filename, raidEventsToWipe);
                    SaveRaidEventLog();

                    SendChatMsg(pl, string.Format(lang.GetMessage("ViewEventsCommand.WipedRaidEventsRadius", this, pl.UserIDString), raidEventsToWipe.Count, radius, gridPos));
                    return;
                case "time":
                    filter = args.Length > 1 ? args[1].ToLower() : "";

                    if (args.Length > 2 && float.TryParse(args[2], out tempRadius))
                        radius = tempRadius;

                    double hours;
                    if (!double.TryParse(filter, out hours))
                        hours = 24;

                    groupedRaidsNearMe = FindRaidEventsInSphere(pos, radius)
                        .Where(x => DateTime.Now.Subtract(x.timestamp).TotalHours <= hours)
                        .GroupBy(x => new RaidFilter { filter = $"{x.attackerName}[{x.attackerSteamID}]", filterType = filterType });
                    break;
                case "weapon":
                    filter = args.Length > 1 ? args[1].ToLower() : "";

                    if (args.Length > 2 && float.TryParse(args[2], out tempRadius))
                        radius = tempRadius;

                    groupedRaidsNearMe = FindRaidEventsInSphere(pos, radius)
                        .Where(x => x.weapon.Contains(filter) || FindWeaponConfig(x.GetTrackerCategory(), x.GetPrimaryWeaponShortname()).name.ToLower().Contains(filter))
                        .GroupBy(x => new RaidFilter { filter = FindWeaponConfig(x.GetTrackerCategory(), x.GetPrimaryWeaponShortname()).name, filterType = filterType });
                    break;
                case "entity":
                    filter = args.Length > 1 ? args[1].ToLower() : "";

                    if (args.Length > 2 && float.TryParse(args[2], out tempRadius))
                        radius = tempRadius;

                    groupedRaidsNearMe = FindRaidEventsInSphere(pos, radius)
                        .Where(x => x.hitEntity.Contains(filter))
                        .GroupBy(x => new RaidFilter { filter = x.GetHitEntityShortname(), filterType = filterType });
                    break;
                case "team":
                    filter = args.Length > 1 ? args[1].ToLower() : "";

                    if (args.Length > 2 && float.TryParse(args[2], out tempRadius))
                        radius = tempRadius;

                    IEnumerable<RaidEvent> tempRaidEvents = FindRaidEventsInSphere(pos, radius);
                    if (!string.IsNullOrEmpty(filter))
                        tempRaidEvents = tempRaidEvents.Where(x => x.attackerTeamID.ToString() == filter);

                    groupedRaidsNearMe = tempRaidEvents.GroupBy(x => {
                        var team = RelationshipManager.ServerInstance.FindTeam(x.attackerTeamID);
                        return new RaidFilter { filter = team != null ? $"{team.GetLeader()?.displayName ?? "UNKNOWN LEADER"}'s Team (ID: {x.attackerTeamID})" : x.attackerTeamID.ToString(), filterType = filterType };
                    });
                    break;
                case "player":
                    filter = args.Length > 1 ? args[1].ToLower() : "";

                    if (args.Length > 2 && float.TryParse(args[2], out tempRadius))
                        radius = tempRadius;

                    groupedRaidsNearMe = FindRaidEventsInSphere(pos, radius)
                        .Where(x => x.attackerSteamID.ToString() == filter || x.attackerName.ToLower().Contains(filter))
                        .GroupBy(x => new RaidFilter { filter = $"{x.attackerName}[{x.attackerSteamID}]", filterType = filterType });
                    break;
                default:
                    if (args.Length > 0 && float.TryParse(args[0], out tempRadius))
                        radius = tempRadius;

                    groupedRaidsNearMe = FindRaidEventsInSphere(pos, radius)
                        .GroupBy(x => new RaidFilter { filter = $"{x.attackerName}[{x.attackerSteamID}]", filterType = "default" });
                    break;
            }

            DrawRaidEvents(pl, groupedRaidsNearMe, filterType, filter, radius);
            _lastViewCommand[pl.userID] = args;
        }

        [Command("px")]
        private void PlayerViewExplosionsCommand(IPlayer player, string command, string[] args)
        {
            BasePlayer pl = player.Object as BasePlayer;
            if (pl == null) return;

            bool isAdmin = player.IsAdmin;
            if (!isAdmin && !permission.UserHasPermission(pl.UserIDString, PERM_PX))
            {
                SendChatMsg(pl, string.Format(lang.GetMessage("ViewEventsCommand.NoPermission", this, pl.UserIDString), $"/{command}"));
                return;
            }

            try
            {
                if (!isAdmin)
                {
                    pl.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    pl.SendNetworkUpdateImmediate();
                }

                float radius = _config.searchRadius > 0f ? _config.searchRadius : 50f;
                float tempRadius;
                if (args.Length > 0 && float.TryParse(args[0], out tempRadius))
                    radius = Mathf.Clamp(tempRadius, 0f, 100f);

                Vector3 pos = pl.transform.position;
                pos.y += pl.GetHeight() - .5f;

                var groupedRaidsNearMe = FindRaidEventsInSphere(pos, radius)
                    .Where(x => x.victimSteamID == pl.userID || (pl.Team != null && pl.Team.members.Contains(x.victimSteamID)) || FindWeaponConfig(x.GetTrackerCategory(), x.GetPrimaryWeaponShortname()).alwaysLog)
                    .Where(x => DateTime.Now.Subtract(x.timestamp).TotalMinutes > _config.playerViewExplosionsCommand.ignoreRaidEventsLessThanMinutes)
                    .GroupBy(x => new RaidFilter { filter = $"{x.attackerSteamID.GetHashCode()}", filterType = "victim" });

                DrawRaidEvents(pl, groupedRaidsNearMe, "victim", pl.UserIDString, radius, _config.playerViewExplosionsCommand.drawAttackerName);
            }
            catch (Exception ex)
            {
                LogToSingleFile("px_error_log", $"error drawing player explosions for {pl.userID}[{pl?.displayName ?? "Unknown"}]\n\nException: {ex.Message}");
            }

            if (!isAdmin)
            {
                pl.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                pl.SendNetworkUpdateImmediate();
            }
        }

        [Command("re")]
        private void RaidEventDetailsCommand(IPlayer player, string command, string[] args)
        {
            BasePlayer pl = player.Object as BasePlayer;
            if (pl == null || !pl.IsAdmin) return;

            int index = -1;
            int i;
            if (args.Length > 0 && int.TryParse(args[0], out i))
                index = i;

            if (index < _raidEventLog.Count && _raidEventLog[index] != null)
            {
                RaidEvent raidEvent = _raidEventLog[index];
                SendChatMsg(pl, $"\n\nRaid Event {index}:\n{JsonConvert.SerializeObject(raidEvent, Formatting.Indented)}");
            }
            else
                SendChatMsg(pl, $"Raid event {index} not found!");
        }

        [Command("rt.debug")]
        private void DebugCommand(IPlayer player, string command, string[] args)
        {
            if (!player.IsServer) return;

            _debug = !_debug;
            Puts($"debug: {_debug}");
        }

        [Command("rt.weapon_colors")]
        private void WeaponColorsCommand(IPlayer player, string command, string[] args)
        {
            BasePlayer pl = player.Object as BasePlayer;
            if (pl == null || !pl.IsAdmin) return;

            _sb.Clear();
            var category = args.Length > 0 && _config.trackers.ContainsKey(args[0].ToLower()) ? args[0].ToLower() : _config.trackers.Keys.First();
            foreach (var weaponCfg in _config.trackers[category])
            {
                var val = weaponCfg.Value;
                _sb.AppendLine($"<color={val.hexColor}>• {val.name} ({category})</color> - Enabled: {val.enabled}");
            }

            SendChatMsg(pl, $"\n\n{_sb}");
        }

        #endregion

        #region Helpers

        private void DrawRaidEvents(BasePlayer pl, IEnumerable<IGrouping<RaidFilter, RaidEvent>> groupedRaidsNearMe, string filterType, string filter, float radius, bool drawAttackerName = true)
        {
            bool verbose = _verboseMode.ContainsKey(pl.userID) && _verboseMode[pl.userID];
            int raidCount = groupedRaidsNearMe.Sum(x => x.Count());
            _sb.Clear();
            _sb.AppendLine(string.Format(lang.GetMessage("ViewEventsCommand.Header", this, pl.UserIDString), raidCount, radius));

            if (!string.IsNullOrEmpty(filterType))
                _sb.AppendLine(string.Format(lang.GetMessage("ViewEventsCommand.Filter", this, pl.UserIDString), filterType, filter));

            var groupCloseNames = new Dictionary<ulong, List<Vector3>>();
            foreach (var grouping in groupedRaidsNearMe)
            {
                var groupingColor = GetRandomColor();
                var groupingColorHex = GetHexColor(groupingColor);
                foreach (RaidEvent raidEvent in grouping)
                {
                    if (raidEvent.attackerTeamID > 0 && !_teamColors.ContainsKey(raidEvent.attackerTeamID))
                    {
                        _teamColors[raidEvent.attackerTeamID] = _uniqueColors[_currentTeamColorIdx];
                        _currentTeamColorIdx = _currentTeamColorIdx < _uniqueColors.Count() ? _currentTeamColorIdx : -1;
                        _currentTeamColorIdx++;
                    }

                    var teamColor = raidEvent.attackerTeamID > 0 ? _teamColors[raidEvent.attackerTeamID] : GetRandomColor();
                    var teamColorHex = GetHexColor(teamColor);
                    var weaponCfg = FindWeaponConfig(raidEvent.GetTrackerCategory(), raidEvent.GetPrimaryWeaponShortname());
                    var weaponColor = weaponCfg.GetWeaponColor();

                    if (filterType == "weapon")
                    {
                        groupingColor = weaponColor;
                        groupingColorHex = GetHexColor(groupingColor);
                    }
                    else if (filterType == "team")
                    {
                        groupingColor = teamColor;
                        groupingColorHex = GetHexColor(groupingColor);
                    }

                    string startText, endText;
                    var startPos = raidEvent.startPos;
                    var endPos = raidEvent.endPos;

                    if (weaponCfg.shortArrow)
                        startPos = raidEvent.endPos + new Vector3(0, .2f, 0);

                    string attackerTeam = raidEvent.attackerTeamID > 0 ? string.Format(lang.GetMessage("ViewEventsCommand.Team", this, pl.UserIDString), teamColorHex, raidEvent.attackerTeamID) : "";
                    if (verbose)
                    {
                        startText = string.Format(lang.GetMessage("ViewEventsCommand.StartTextExtra", this, pl.UserIDString), drawAttackerName ? raidEvent.attackerName : "X", raidEvent.attackerSteamID, attackerTeam);
                        endText = string.Format(lang.GetMessage("ViewEventsCommand.EndTextExtra", this, pl.UserIDString), groupingColorHex, raidEvent.GetIndex(), raidEvent.GetWeaponName(), raidEvent.hitEntity.Replace(raidEvent.GetEventType(), raidEvent.GetPrettyEventType()));
                    }
                    else
                    {
                        startText = string.Format(lang.GetMessage("ViewEventsCommand.StartText", this, pl.UserIDString), drawAttackerName ? raidEvent.attackerName : "X", attackerTeam);
                        endText = string.Format(lang.GetMessage("ViewEventsCommand.EndText", this, pl.UserIDString), groupingColorHex, raidEvent.GetWeaponName());
                    }

                    if (raidEvent.hitEntity.Contains("EVENT.ATTACHED"))
                        Box(pl, endPos, .05f, groupingColor, _config.drawDuration);
                    else if (raidEvent.hitEntity.Contains("EVENT.HIT"))
                        Sphere(pl, endPos, .05f, groupingColor, _config.drawDuration);

                    if (!groupCloseNames.ContainsKey(raidEvent.attackerSteamID))
                        groupCloseNames[raidEvent.attackerSteamID] = new List<Vector3>();

                    if (!groupCloseNames[raidEvent.attackerSteamID].Any(x => Vector3.Distance(x, startPos) < .1f))
                    {
                        groupCloseNames[raidEvent.attackerSteamID].Add(startPos);
                        Text(pl, startPos, startText, groupingColor, _config.drawDuration);
                    }

                    Arrow(pl, startPos, endPos, .05f, groupingColor, _config.drawDuration);
                    Text(pl, endPos + new Vector3(0, .05f, 0), endText, weaponColor, _config.drawDuration);
                }
                _sb.AppendLine(string.Format(lang.GetMessage("ViewEventsCommand.GroupingCount", this, pl.UserIDString), groupingColorHex, grouping.Count(), grouping.Key.filterType, grouping.Key.filter));

                var weaponCounts = grouping
                    .GroupBy(x => new { weapon = x.GetPrimaryWeaponShortname(), trackerCategory = x.GetTrackerCategory() })
                    .Select(x => new { data = x.Key, count = x.Count() });

                _sb.Append("<indent=6>");
                foreach (var x in weaponCounts)
                {
                    var weaponCfg = FindWeaponConfig(x.data.trackerCategory, x.data.weapon);
                    _sb.Append(string.Format(lang.GetMessage("ViewEventsCommand.WeaponCount", this, pl.UserIDString), weaponCfg.hexColor, x.count, weaponCfg.name, x.data.trackerCategory));
                }
                _sb.Append("<indent=0>");
                _sb.AppendLine($"\n");
            }

            if (raidCount < 1)
                _sb.AppendLine(lang.GetMessage("ViewEventsCommand.NotFound", this, pl.UserIDString));

            SendChatMsg(pl, _sb.ToString().TrimEnd(), "");
        }

        private void LogToSingleFile(string filename, string text) =>
            LogToFile(filename, string.Format("[{0:yyyy-MM-dd HH:mm:ss}] {1}", DateTime.Now, text), this, false);

        private void PrintDebug(string msg)
        {
            if (_debug) Puts($"[DEBUG] {msg}");
        }

        private void SendChatMsg(BasePlayer pl, string msg, string prefix = null)
        {
            var p = prefix != null ? prefix : lang.GetMessage("ChatPrefix", this, pl.UserIDString);
            _rustPlayer.Message(pl, msg, p, _config.chatIconID, Array.Empty<object>());

            if (_config.printToClientConsole)
                pl.ConsoleMessage($"{(!string.IsNullOrEmpty(p) ? $"{p} " : "")}{msg}");
        }

        public void Arrow(BasePlayer player, Vector3 from, Vector3 to, float headSize, Color color, float duration) =>
            player.SendConsoleCommand("ddraw.arrow", duration, color, from, to, headSize);

        public void Sphere(BasePlayer player, Vector3 pos, float radius, Color color, float duration) =>
            player.SendConsoleCommand("ddraw.sphere", duration, color, pos, radius);

        public void Box(BasePlayer player, Vector3 pos, float size, Color color, float duration) =>
            player.SendConsoleCommand("ddraw.box", duration, color, pos, size);

        public void Text(BasePlayer player, Vector3 pos, string text, Color color, float duration) =>
            player.SendConsoleCommand("ddraw.text", duration, color, pos, text);

        private void AddPrefabToItem(string prefab, string itemShortname, string prefabSource)
        {
            var prefabShortname = GetPrefabShortname(prefab);
            if (_prefabToItem.ContainsKey(prefabShortname)) return;

            _prefabToItem[prefabShortname] = itemShortname;
            PrintDebug($"prefabToItem - {prefabSource}: {prefabShortname} -> {itemShortname}");
        }

        private string GetItemFromPrefabShortname(string prefabShortname) =>
            _prefabToItem.ContainsKey(prefabShortname) ? _prefabToItem[prefabShortname] : prefabShortname;

        private string GetPrefabShortname(string prefab) =>
            prefab.Substring(prefab.LastIndexOf('/') + 1).Replace(".prefab", "");

        private string GetPrettyItemName(string itemShortname)
        {
            string buildingBlockName;
            if (_buildingBlockPrettyNames.TryGetValue(itemShortname, out buildingBlockName))
                return buildingBlockName;

            return ItemManager.FindItemDefinition(itemShortname)?.displayName?.english ?? itemShortname;
        }

        private IEnumerable<RaidEvent> FindRaidEventsInSphere(Vector3 pos, float r) =>
            _raidEventLog.Where(x => Vector3.Distance(pos, x.startPos) < r || Vector3.Distance(pos, x.endPos) < r);

        private Color GetRandomColor() => UnityEngine.Random.ColorHSV(0f, 1f, .4f, .8f, .5f, 1f);

        private string GetHexColor(Color color) => $"#{ColorUtility.ToHtmlStringRGB(color)}";

        private PluginConfig.WeaponConfig AddOrFindWeaponConfig(string category, string shortname)
        {
            if (!_config.trackers.ContainsKey(category))
                _config.trackers[category] = new SortedDictionary<string, PluginConfig.WeaponConfig>();

            if (!_config.trackers[category].ContainsKey(shortname))
            {
                var weaponCfg = new PluginConfig.WeaponConfig
                {
                    enabled = _config.enableNewTrackers,
                    name = GetPrettyItemName(GetItemFromPrefabShortname(shortname)),
                    hexColor = GetHexColor(GetRandomColor())
                };
                _config.trackers[category][shortname] = weaponCfg;

                LogToSingleFile("weapon_config_log", $"added {weaponCfg.name} ({category} / {shortname}), enabled: {weaponCfg.enabled}");
                SaveConfig();
            }

            return FindWeaponConfig(category, shortname);
        }

        private PluginConfig.WeaponConfig FindWeaponConfig(string category, string shortname)
        {
            PluginConfig.WeaponConfig weaponCfg;
            if (_config.trackers.ContainsKey(category) && _config.trackers[category].TryGetValue(shortname, out weaponCfg))
            {
                if (_dev)
                {
                    return new PluginConfig.WeaponConfig
                    {
                        enabled = true,
                        name = weaponCfg.name,
                        hexColor = weaponCfg.hexColor,
                        alwaysLog = weaponCfg.alwaysLog,
                        shortArrow = weaponCfg.shortArrow,
                        discordIcon = weaponCfg.discordIcon,
                        notifyConsole = true,
                        notifyAdmin = true,
                        notifyDiscord = true,
                        logToFile = true
                    };
                }

                PluginConfig.WeaponConfig globalWeaponCfg = null;
                if (_config.trackers.ContainsKey("_global") && _config.trackers["_global"].ContainsKey("*"))
                    globalWeaponCfg = _config.trackers["_global"]["*"];

                if ((globalWeaponCfg == null || !globalWeaponCfg.enabled) && _config.trackers[category].ContainsKey("*"))
                    globalWeaponCfg = _config.trackers[category]["*"];

                if (!weaponCfg.enabled && globalWeaponCfg.enabled)
                {
                    return new PluginConfig.WeaponConfig
                    {
                        enabled = globalWeaponCfg.enabled,
                        name = weaponCfg.name,
                        hexColor = weaponCfg.hexColor,
                        alwaysLog = weaponCfg.alwaysLog,
                        shortArrow = weaponCfg.shortArrow,
                        discordIcon = weaponCfg.discordIcon,
                        notifyConsole = globalWeaponCfg.notifyConsole,
                        notifyAdmin = globalWeaponCfg.notifyAdmin,
                        notifyDiscord = globalWeaponCfg.notifyDiscord,
                        logToFile = globalWeaponCfg.logToFile
                    };
                }
                return weaponCfg;
            }
            throw new Exception($"THIS SHOULD NEVER HAPPEN! Unable to find weapon config [{category} / {shortname}]");
        }

        private string GetDecayEntityShortname(DecayEntity entity)
        {
            var buildingBlock = entity as BuildingBlock;
            return $"{entity.ShortPrefabName}{(buildingBlock != null ? $".{buildingBlock.grade.ToString().ToLower()}" : "")}";
        }

        private bool IsDecayEntityIgnored(DecayEntity entity)
        {
            if (entity is LootContainer || entity.OwnerID == 0)
                return true;

            if (!_dev && _decayEntityIgnoreList.ContainsKey(entity.PrefabName) && _decayEntityIgnoreList[entity.PrefabName].ignore)
                return true;

            var buildingBlock = entity as BuildingBlock;
            bool ignoreGrade;
            if (!_dev && buildingBlock != null && _config.ignoreBuildingGrades.TryGetValue(buildingBlock.grade, out ignoreGrade) && ignoreGrade)
                return true;

            if (Convert.ToBoolean(RaidableBases?.Call("EventTerritory", entity.transform.position)))
                return true;

            if (Convert.ToBoolean(AbandonedBases?.Call("EventTerritory", entity.transform.position)))
                return true;

            return false;
        }

        private bool IsDecayEntityOrAttackerIgnored(DecayEntity entity, BasePlayer attacker)
        {
            if (IsDecayEntityIgnored(entity))
                return true;

            if (attacker != null && attacker.IsAdmin)
                return false;

            if (!_dev && _config.ignoreSameOwner && attacker != null && attacker.userID == entity.OwnerID)
                return true;

            if (!_dev && _config.ignoreTeamMember && attacker != null && attacker.Team != null && attacker.Team.members.Contains(entity.OwnerID))
                return true;

            if (!_dev && _config.ignoreClanMemberOrAlly && attacker != null && Convert.ToBoolean(Clans?.Call("IsMemberOrAlly", attacker.UserIDString, entity.OwnerID.ToString())))
                return true;

            return false;
        }

        private string FormatPosition(Vector3 pos)
        {
            return string.Format("{0:F1},{1:F1},{2:F1}", new object[] {
                pos.x,
                pos.y,
                pos.z
            });
        }

        private string StringReplaceKeys(string str, Dictionary<string, string> kv)
        {
            foreach (var x in kv)
                str = str.Replace($"{{{x.Key}}}", x.Value);
            return str;
        }

        private void SaveRaidEventLog()
        {
            if (_raidEventLog.Count == _raidEventLogCount) return;

            Interface.Oxide.DataFileSystem.WriteObject(_raidEventLogFilename, _raidEventLog);
            _raidEventLogCount = _raidEventLog.Count;
        }

        #endregion

        #region Config

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ChatPrefix"] = $"<color=#00a7fe>[{Title}]</color>",
                ["RaidEvent.Message"] = "{attackerName}[{attackerSteamID}] is raiding {victimName}[{victimSteamID}] ~ {weaponName} -> {hitEntity} @ {gridPos} (teleportpos {teleportPos})",
                ["RaidEvent.PrettyMessage"] = "<color=#f5646c>{attackerName}[{attackerSteamID}]</color> is raiding <color=#52bf6f>{victimName}[{victimSteamID}]</color> ~ <color={weaponColor}>{weaponName}</color> {raidEventType} <color=#00a7fe>{entityItemName}</color> ({entityShortname}) @ <color=#00a7fe>{gridPos}</color>",
                ["ViewEventsCommand.HelpHeader"] = $"<size=16><color=#00a7fe>{Title}</color> Help</size>\n",
                ["ViewEventsCommand.HelpDefault"] = "<size=12><color=#00a7fe>/x <radius></color> - Show all raid events within X radius (default 50m)</size>",
                ["ViewEventsCommand.HelpExtraMode"] = "<size=12><color=#00a7fe>/x extra</color> - Toggle extra info mode</size>",
                ["ViewEventsCommand.HelpWipe"] = "<size=12><color=#00a7fe>/x wipe <radius></color> - Wipe all raid events within <radius></size>",
                ["ViewEventsCommand.HelpLast"] = "<size=12><color=#00a7fe>/x last</color> - Re-run last command</size>",
                ["ViewEventsCommand.HelpFilter"] = "<size=12><color=#00a7fe>/x <filterType> <filter> <radius></color></size>",
                ["ViewEventsCommand.HelpFilterTime"] = "<size=12><color=#00a7fe>/x time <hrs> <radius></color> - Show all raid events near by over the past <hrs> within <radius></size>",
                ["ViewEventsCommand.HelpFilterWeapon"] = "<size=12><color=#00a7fe>/x weapon <partial name or item name> <radius></color> - Show all raid events within <radius> filtered by weapon</size>",
                ["ViewEventsCommand.HelpFilterEntity"] = "<size=12><color=#00a7fe>/x entity <partial entity shortname> <radius></color> - Show all raid events within <radius> filtered by entity</size>",
                ["ViewEventsCommand.HelpFilterTeam"] = "<size=12><color=#00a7fe>/x team <team id> <radius></color> - Show all raid events within <radius> filtered by team</size>",
                ["ViewEventsCommand.HelpFilterPlayer"] = "<size=12><color=#00a7fe>/x player <steam id or partial name> <radius></color> - Show all raid events within <radius> filtered by player</size>",
                ["ViewEventsCommand.HelpPrintRaidEvent"] = "<size=12><color=#00a7fe>/re <event id></color> - Print info about a raid event by event id</size>",
                ["ViewEventsCommand.ExtraModeEnabled"] = "<color=#52bf6f>Extra info mode enabled</color>",
                ["ViewEventsCommand.ExtraModeDisabled"] = "<color=#f5646c>Extra info mode disabled</color>",
                ["ViewEventsCommand.WipePermission"] = "You do not have permission to wipe raid events!",
                ["ViewEventsCommand.NotFoundRadius"] = "No raid events found within <color=#00a7fe>{0}m</color>!",
                ["ViewEventsCommand.WipedRaidEventsRadius"] = "Wiped <color=#00a7fe>{0}</color> raid events within <color=#00a7fe>{1}m</color> at <color=#00a7fe>{2}</color>",
                ["ViewEventsCommand.Header"] = $"<size=16><color=#00a7fe>{Title}</color> ~ {{0}} raid event(s) within {{1}}m</size>\n",
                ["ViewEventsCommand.Filter"] = "<color=#00a7fe>filter:</color> [{0}, {1}]\n",
                ["ViewEventsCommand.Team"] = "<color={0}> T:{1}</color>",
                ["ViewEventsCommand.StartTextExtra"] = "<size=12>{0}[{1}]{2}</size>",
                ["ViewEventsCommand.EndTextExtra"] = "<size=12><color={0}>X</color> (RE:{1}) {2} <color={0}>~</color> {3}</size>",
                ["ViewEventsCommand.StartText"] = "<size=12>{0}{1}</size>",
                ["ViewEventsCommand.EndText"] = "<size=12><color={0}>X</color> {1}</size>",
                ["ViewEventsCommand.GroupingCount"] = "<color={0}>{1} raid event(s) [{2}, {3}]</color>",
                ["ViewEventsCommand.WeaponCount"] = "<color={0}>• {1}x {2} <size=10>({3})</size> </color>",
                ["ViewEventsCommand.NotFound"] = "no raid events found!",
                ["ViewEventsCommand.NoPermission"] = "You do not have permission to use <color=#00a7fe>{0}</color>!"
            }, this);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig();
        }

        protected override void LoadDefaultConfig()
        {
            Log($"Loading default configuration");
            _config = GetDefaultConfig();
        }

        protected override void LoadConfig()
        {
            _instance = this;
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<PluginConfig>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                var defaultConfig = GetDefaultConfig();

                bool updated = false;

                foreach (var category in defaultConfig.trackers.Keys)
                {
                    if (!_config.trackers.ContainsKey(category))
                    {
                        _config.trackers[category] = defaultConfig.trackers[category];
                        updated = true;
                    }
                    else
                    {
                        foreach (var weapon in defaultConfig.trackers[category])
                        {
                            if (!_config.trackers[category].ContainsKey(weapon.Key))
                            {
                                _config.trackers[category][weapon.Key] = weapon.Value;
                                updated = true;
                            }
                        }
                    }
                }
                var backupConfigFilename = $"{Name}\\ConfigBackup\\{Name}_{DateTime.Now:yyyy-M-dd_HH-mm-ss}";

                if (updated)
                {
                    LogWarning("Configuration appears to be outdated; updating and saving a backup.");
                    Interface.Oxide.DataFileSystem.WriteObject(backupConfigFilename, _config);
                    SaveConfig();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    Interface.Oxide.DataFileSystem.WriteObject(backupConfigFilename, _config);
                    SaveConfig();
                }
                else
                    Log("Configuration is up to date");

                var webhookURL = _config.discord.webhookURL;
                Puts($"Discord webhook {(!string.IsNullOrEmpty(webhookURL) && !webhookURL.Contains("Intro-to-Webhooks") ? "enabled" : "disabled")}!");
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                _isConfigValid = false;
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        private class PluginConfig : SerializableConfiguration
        {
            public bool debug = false;
            public ulong chatIconID = 76561199278762587;
            public bool deleteDataOnWipe = true;
            public float daysBeforeDelete = 7f;
            public float searchRadius = 50f;
            public float drawDuration = 30f;

            [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<BuildingGrade.Enum, bool> ignoreBuildingGrades = new Dictionary<BuildingGrade.Enum, bool> {
                { BuildingGrade.Enum.Twigs, true },
                { BuildingGrade.Enum.Wood, false },
                { BuildingGrade.Enum.Stone, false },
                { BuildingGrade.Enum.Metal, false },
                { BuildingGrade.Enum.TopTier, false }
            };

            public bool ignoreSameOwner = true;
            public bool ignoreTeamMember = true;
            public bool ignoreClanMemberOrAlly = true;
            public bool enableNewTrackers = true;
            public bool printToClientConsole = true;
            public PlayerViewExplosionsCommand playerViewExplosionsCommand = new PlayerViewExplosionsCommand
            {
                drawAttackerName = false,
                ignoreRaidEventsLessThanMinutes = 30f
            };
            public NotificationCooldown notificationCooldown = new NotificationCooldown
            {
                enabled = false,
                cooldown = 300f
            };

            public DiscordConfig discord = new DiscordConfig
            {
                webhookURL = "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks",
                simpleMessage = new DiscordSimpleMessage
                {
                    enabled = false,
                    message = "{attackerName}[{attackerSteamID}] is raiding {victimName}[{victimSteamID}] ~ {weaponName} -> {raidEventType} {entityItemName} ({entityShortname}) @ {gridPos} (teleportpos {teleportPos})"
                },
                embed = new DiscordEmbed
                {
                    title = "{attackerName} is raiding {victimName} @ {gridPos}",
                    thumbnail = new DiscordEmbedThumbnail
                    {
                        newUrl = "https://cdn.rusthelp.com/images/public/128/{weaponItemShortname}.png"
                    },
                    fields = new List<DiscordEmbedField> {
                        {
                            new DiscordEmbedField {
                                name = "Weapon",
                                value = "{weaponName} ({raidTrackerCategory} / {weaponShortname})",
                                inline = false
                            }
                        },
                        {
                            new DiscordEmbedField {
                                name = "Entity",
                                value = "{raidEventType} {entityItemName} ({entityShortname})",
                                inline = false
                            }
                        },
                        {
                            new DiscordEmbedField {
                                name = "Attacker",
                                value = "{attackerName} \n[Steam Profile](https://steamcommunity.com/profiles/{attackerSteamID}) ({attackerSteamID})\n[SteamID.uk](https://steamid.uk/profile/{attackerSteamID})\n\n**Attacker Team**\n{attackerTeamName}",
                                inline = true
                            }
                        },
                        {
                            new DiscordEmbedField {
                                name = "Victim",
                                value = "{victimName} \n[Steam Profile](https://steamcommunity.com/profiles/{victimSteamID}) ({victimSteamID})\n[SteamID.uk](https://steamid.uk/profile/{victimSteamID})\n\n**Victim Team**\n{victimTeamName}",
                                inline = true
                            }
                        },
                        {
                            new DiscordEmbedField {
                                name = "Location",
                                value = "{gridPos} - teleportpos {teleportPos}",
                                inline = false
                            }
                        }
                    },
                    footer = new DiscordEmbedFooter
                    {
                        text = $"{_instance.Title} {{{0}}} by {_instance.Author}",
                        icon_url = "https://i.imgur.com/DluJ5X5.png"
                    }
                }
            };

            [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SortedDictionary<string, SortedDictionary<string, WeaponConfig>> trackers = new SortedDictionary<string, SortedDictionary<string, WeaponConfig>> {
                {
                    "_global",
                    new SortedDictionary<string, WeaponConfig> {
                        { "*", new WeaponConfig { enabled = false, name = "Enable all trackers in every category" } }
                    }
                },
                {
                    "entity_collision",
                    new SortedDictionary<string, WeaponConfig> {
                        { "*", new WeaponConfig { enabled = false, name = "Enable all 'entity_collision' trackers" } },
                        { "40mm_grenade_he", new WeaponConfig { enabled = true, hexColor = "#FF5764" } },
                        { "40mm_grenade_smoke", new WeaponConfig { enabled = false, hexColor = "#4B4B4B" } },
                        { "explosive.satchel.deployed", new WeaponConfig { enabled = true, hexColor = "#BA9500" } },
                        { "explosive.timed.deployed", new WeaponConfig { enabled = true, name = "C4", hexColor = "#FF5764" } },
                        { "grenade.beancan.deployed", new WeaponConfig { enabled = false, hexColor = "#BA9500" } },
                        { "grenade.f1.deployed", new WeaponConfig { enabled = false, hexColor = "#538C4F" } },
                        { "grenade.flashbang.deployed", new WeaponConfig { enabled = false, hexColor = "#4B4B4B" } },
                        { "grenade.molotov.deployed", new WeaponConfig { enabled = true, hexColor = "#FF8C24" } },
                        { "grenade.smoke.deployed", new WeaponConfig { enabled = false, hexColor = "#4B4B4B" } },
                        { "grenade.supplysignal.deployed", new WeaponConfig { enabled = true, hexColor = "#B867FF", alwaysLog = true, shortArrow = true } },
                        { "rocket_basic", new WeaponConfig { enabled = true, hexColor = "#B867FF" } },
                        { "rocket_fire", new WeaponConfig { enabled = true, hexColor = "#FF8C24" } },
                        { "rocket_hv", new WeaponConfig { enabled = true, hexColor = "#528EFF" } },
                        { "rocket_mlrs", new WeaponConfig { enabled = true, hexColor = "#FF5764", alwaysLog = true } },
                        { "survey_charge.deployed", new WeaponConfig { enabled = false, hexColor = "#212121" } },
                        { "boulder_explosive", new WeaponConfig { enabled = false, hexColor = "#212121" } },
                        { "boulder_incendiary", new WeaponConfig { enabled = false, hexColor = "#212121" } },
                        { "boulder_small", new WeaponConfig { enabled = false, name = "Scattershot", hexColor = "#212121" } },
                        { "boulder_mid", new WeaponConfig { enabled = false, name = "Scattershot", hexColor = "#212121" } }
                    }
                },
                {
                    "entity_death_ammo",
                    new SortedDictionary<string, WeaponConfig> {
                        { "*", new WeaponConfig { enabled = false, name = "Enable all 'entity_death_ammo' trackers" } },
                        { "ammo.grenadelauncher.buckshot", new WeaponConfig { enabled = true, hexColor = "#FF5764" } },
                        { "ammo.handmade.shell", new WeaponConfig { enabled = true, hexColor = "#FFC880" } },
                        { "ammo.nailgun.nails", new WeaponConfig { enabled = true, hexColor = "#528EFF" } },
                        { "ammo.pistol", new WeaponConfig { enabled = true, name = "Pistol Ammo", hexColor = "#FFC880" } },
                        { "ammo.pistol.fire", new WeaponConfig { enabled = true, name = "Inc Pistol Ammo", hexColor = "#FF8C24" } },
                        { "ammo.pistol.hv", new WeaponConfig { enabled = true, name = "HV Pistol Ammo", hexColor = "#528EFF" } },
                        { "ammo.rifle", new WeaponConfig { enabled = true, name = "Rifle Ammo", hexColor = "#FFC880" } },
                        { "ammo.rifle.explosive", new WeaponConfig { enabled = true, name = "Exp Rifle Ammo", hexColor = "#FF5764" } },
                        { "ammo.rifle.hv", new WeaponConfig { enabled = true, name = "HV Rifle Ammo", hexColor = "#528EFF" } },
                        { "ammo.rifle.incendiary", new WeaponConfig { enabled = true, name = "Inc Rifle Ammo", hexColor = "#FF8C24" } },
                        { "ammo.shotgun", new WeaponConfig { enabled = true, hexColor = "#FF5764" } },
                        { "ammo.shotgun.fire", new WeaponConfig { enabled = true, name = "12 Gauge Inc Shell", hexColor = "#FF8C24" } },
                        { "ammo.shotgun.slug", new WeaponConfig { enabled = true, hexColor = "#3DBF39" } },
                        { "ammo.snowballgun", new WeaponConfig { enabled = true, name = "Snowball", hexColor = "#3E8E91" } },
                        { "arrow.bone", new WeaponConfig { enabled = true, hexColor = "#212121" } },
                        { "arrow.fire", new WeaponConfig { enabled = true, hexColor = "#FF8C24" } },
                        { "arrow.hv", new WeaponConfig { enabled = true, hexColor = "#528EFF" } },
                        { "arrow.wooden", new WeaponConfig { enabled = true, hexColor = "#FFC880" } },
                        { "speargun.spear", new WeaponConfig { enabled = false, hexColor = "#7E7E7E" } },
                        { "ballista.bolt.pitchfork", new WeaponConfig { enabled = false, hexColor = "#7E7E7E" } },
                        { "ballista.bolt.piercer", new WeaponConfig { enabled = false, hexColor = "#7E7E7E" } },
                        { "ballista.bolt.hammerhead", new WeaponConfig { enabled = false, hexColor = "#7E7E7E" } },
                        { "catapult.ammo.boulder", new WeaponConfig { enabled = true, hexColor = "#FF8C24" } },
                        { "catapult.ammo.explosive", new WeaponConfig { enabled = true, hexColor = "#FF8C24" } },
                        { "catapult.ammo.incendiary", new WeaponConfig { enabled = true, hexColor = "#FF8C24" } }
                    }
                },
                {
                    "entity_death_fire",
                    new SortedDictionary<string, WeaponConfig> {
                        { "*", new WeaponConfig { enabled = false, name = "Enable all 'entity_death_fire' trackers" } },
                        { "fire_damage", new WeaponConfig { enabled = true, name = "Fire", hexColor = "#FF8C24", discordIcon = "https://i.imgur.com/dBqgQv9.png" } },
                        { "fireball", new WeaponConfig { enabled = true, name = "Fireball", hexColor = "#FF8C24", discordIcon = "https://i.imgur.com/dBqgQv9.png" } },
                        { "fireball_small", new WeaponConfig { enabled = true, name = "Small Fireball", hexColor = "#FF8C24", discordIcon = "https://i.imgur.com/dBqgQv9.png" } },
                        { "fireball_small_arrow", new WeaponConfig { enabled = true, name = "Arrow Fireball", hexColor = "#FF8C24", discordIcon = "https://i.imgur.com/dBqgQv9.png" } },
                        { "fireball_small_shotgun", new WeaponConfig { enabled = true, name = "Shotgun Fireball", hexColor = "#FF8C24", discordIcon = "https://i.imgur.com/dBqgQv9.png" } },
                        { "flameturret_fireball", new WeaponConfig { enabled = true, name = "Flame Turret Fireball", hexColor = "#FF8C24", discordIcon = "https://i.imgur.com/dBqgQv9.png" } },
                        { "fireball_ballista", new WeaponConfig { enabled = true, name = "Ballista Fireball", hexColor = "#FF8C24", discordIcon = "https://i.imgur.com/dBqgQv9.png" } },
                        { "fireball_catapult", new WeaponConfig { enabled = true, name = "Catapult Fireball", hexColor = "#FF8C24", discordIcon = "https://i.imgur.com/dBqgQv9.png" } },
                        { "fireball_small_molotov", new WeaponConfig { enabled = true, name = "Molotov Fireball", hexColor = "#FF8C24", discordIcon = "https://i.imgur.com/dBqgQv9.png" } }
                    }
                },
                {
                    "entity_death_weapon",
                    new SortedDictionary<string, WeaponConfig> {
                        { "*", new WeaponConfig { enabled = false, name = "Enable all 'entity_death_weapon' trackers" } },
                        { "ammo.grenadelauncher.he", new WeaponConfig { enabled = false, hexColor = "#FF5764", shortArrow = true } },
                        { "ammo.rocket.basic", new WeaponConfig { enabled = false, hexColor = "#B867FF", shortArrow = true } },
                        { "ammo.rocket.fire", new WeaponConfig { enabled = false, hexColor = "#FF8C24", shortArrow = true } },
                        { "ammo.rocket.hv", new WeaponConfig { enabled = false, hexColor = "#528EFF", shortArrow = true } },
                        { "ammo.rocket.mlrs", new WeaponConfig { enabled = false, hexColor = "#FF5764", shortArrow = true } },
                        { "axe.salvaged", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "ballista.mounted", new WeaponConfig { enabled = false, name = "Mounted Ballista", hexColor = "#4DBEFF" } },
                        { "ballista.static", new WeaponConfig { enabled = false, name = "Ballista", hexColor = "#4DBEFF" } },
                        { "batteringram.entity", new WeaponConfig { enabled = false, name = "Battering Ram", hexColor = "#4DBEFF", discordIcon = "https://cdn.rusthelp.com/images/public/128/batteringram.png" } },
                        { "bone.club", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "bow.compound", new WeaponConfig { enabled = false, hexColor = "#B867FF" } },
                        { "bow.hunting", new WeaponConfig { enabled = false, hexColor = "#B867FF" } },
                        { "candycaneclub", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "catapult", new WeaponConfig { enabled = true, name = "Catapult", hexColor = "#4DBEFF" } },
                        { "chainsaw", new WeaponConfig { enabled = true, hexColor = "#FF5764" } },
                        { "concretehatchet", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "concretepickaxe", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "crossbow", new WeaponConfig { enabled = false, hexColor = "#B867FF" } },
                        { "explosive.satchel", new WeaponConfig { enabled = false, hexColor = "#BA9500", shortArrow = true } },
                        { "explosive.timed", new WeaponConfig { enabled = false, name = "C4", hexColor = "#FF5764", shortArrow = true } },
                        { "flamethrower", new WeaponConfig { enabled = true, hexColor = "#FF8C24" } },
                        { "flashlight.held", new WeaponConfig { enabled = true, hexColor = "#212121" } },
                        { "grenade.beancan", new WeaponConfig { enabled = true, hexColor = "#BA9500", shortArrow = true } },
                        { "grenade.f1", new WeaponConfig { enabled = true, hexColor = "#538C4F", shortArrow = true } },
                        { "grenade.flashbang", new WeaponConfig { enabled = true, hexColor = "#4B4B4B", shortArrow = true } },
                        { "grenade.molotov", new WeaponConfig { enabled = true, hexColor = "#FF8C24", shortArrow = true } },
                        { "hammer.salvaged", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "hatchet", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "hmlmg", new WeaponConfig { enabled = false, hexColor = "#FF5764" } },
                        { "icepick.salvaged", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "jackhammer", new WeaponConfig { enabled = true, hexColor = "#FF5764" } },
                        { "knife.bone", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "knife.butcher", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "knife.combat", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "lmg.m249", new WeaponConfig { enabled = false, hexColor = "#FF5764" } },
                        { "longsword", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "lumberjack.hatchet", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "lumberjack.pickaxe", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "mace", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "mace.baseballbat", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "machete", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "military flamethrower", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "minigun", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "multiplegrenadelauncher", new WeaponConfig { enabled = false, hexColor = "#FF5764" } },
                        { "paddle", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "pickaxe", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "pistol.eoka", new WeaponConfig { enabled = true, hexColor = "#3E8E91" } },
                        { "pistol.m92", new WeaponConfig { enabled = false, hexColor = "#3E8E91" } },
                        { "pistol.nailgun", new WeaponConfig { enabled = true, hexColor = "#3E8E91" } },
                        { "pistol.prototype17", new WeaponConfig { enabled = true, hexColor = "#3E8E91" } },
                        { "pistol.python", new WeaponConfig { enabled = false, hexColor = "#3E8E91" } },
                        { "pistol.revolver", new WeaponConfig { enabled = false, hexColor = "#3E8E91" } },
                        { "pistol.semiauto", new WeaponConfig { enabled = false, hexColor = "#3E8E91" } },
                        { "pitchfork", new WeaponConfig { enabled =