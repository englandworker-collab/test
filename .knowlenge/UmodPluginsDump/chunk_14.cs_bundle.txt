 true, hexColor = "#4DBEFF" } },
                        { "revolver.hc", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "rifle.ak", new WeaponConfig { enabled = false, hexColor = "#FF5764" } },
                        { "rifle.ak.diver", new WeaponConfig { enabled = false, hexColor = "#FF5764" } },
                        { "rifle.ak.med", new WeaponConfig { enabled = false, hexColor = "#FF5764" } },
                        { "rifle.ak.ice", new WeaponConfig { enabled = false, hexColor = "#FF5764" } },
                        { "rifle.bolt", new WeaponConfig { enabled = false, hexColor = "#FF5764" } },
                        { "rifle.l96", new WeaponConfig { enabled = false, hexColor = "#FF5764" } },
                        { "rifle.lr300", new WeaponConfig { enabled = false, hexColor = "#FF5764" } },
                        { "rifle.m39", new WeaponConfig { enabled = false, hexColor = "#FF5764" } },
                        { "rifle.semiauto", new WeaponConfig { enabled = false, hexColor = "#FF5764" } },
                        { "rifle.sks", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "rock", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "salvaged.cleaver", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "salvaged.sword", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "shotgun.double", new WeaponConfig { enabled = false, hexColor = "#3DBF39" } },
                        { "shotgun.pump", new WeaponConfig { enabled = false, hexColor = "#3DBF39" } },
                        { "shotgun.spas12", new WeaponConfig { enabled = false, hexColor = "#3DBF39" } },
                        { "shotgun.waterpipe", new WeaponConfig { enabled = false, hexColor = "#3DBF39" } },
                        { "sickle", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "smg.2", new WeaponConfig { enabled = false, hexColor = "#365EEF" } },
                        { "smg.mp5", new WeaponConfig { enabled = false, hexColor = "#365EEF" } },
                        { "smg.thompson", new WeaponConfig { enabled = false, hexColor = "#365EEF" } },
                        { "t1_smg", new WeaponConfig { enabled = false, hexColor = "#365EEF" } },
                        { "snowballgun", new WeaponConfig { enabled = false, hexColor = "#3E8E91" } },
                        { "spear.stone", new WeaponConfig { enabled = true, hexColor = "#CB60DB" } },
                        { "spear.wooden", new WeaponConfig { enabled = true, hexColor = "#CB60DB" } },
                        { "speargun", new WeaponConfig { enabled = true, hexColor = "#CB60DB" } },
                        { "stone.pickaxe", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "stonehatchet", new WeaponConfig { enabled = true, hexColor = "#4DBEFF" } },
                        { "surveycharge", new WeaponConfig { enabled = false, hexColor = "#212121", shortArrow = true } },
                        { "torch", new WeaponConfig { enabled = true, hexColor = "#FF8C24" } },
                        { "torch.torch.skull", new WeaponConfig { enabled = true, hexColor = "#FF8C24" } },
                        { "catapult.ammo.boulder", new WeaponConfig { enabled = true, hexColor = "#FF8C24" } },
                        { "catapult.ammo.explosive", new WeaponConfig { enabled = true, hexColor = "#FF8C24" } },
                        { "catapult.ammo.incendiary", new WeaponConfig { enabled = true, hexColor = "#FF8C24" } }
                    }
                }
            };

            [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SortedDictionary<string, string> eventTypes = new SortedDictionary<string, string>{
                { "EVENT.ATTACHED", "attached to"},
                { "EVENT.BURNT", "burnt" },
                { "EVENT.DESTROYED", "destroyed" },
                { "EVENT.HIT", "hit" },
                { "EVENT.NO_HIT", "no hit" }
            };

            public class WeaponConfig
            {
                public bool enabled;
                public string name;

                [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
                public string hexColor;

                [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
                public bool alwaysLog;

                [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
                public bool shortArrow;

                [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
                public string discordIcon;

                public bool notifyConsole;
                public bool notifyAdmin;
                public bool notifyDiscord;
                public bool logToFile;

                public Color GetWeaponColor()
                {
                    Color weaponColor;
                    if (ColorUtility.TryParseHtmlString(this.hexColor, out weaponColor))
                        return weaponColor;
                    return _instance.GetRandomColor();
                }
            }

            public class DiscordConfig
            {
                public string webhookURL;
                public DiscordSimpleMessage simpleMessage;
                public DiscordEmbed embed = new DiscordEmbed();
            }

            public class DiscordSimpleMessage
            {
                public bool enabled;
                public string message;
            }

            public class DiscordEmbed
            {
                public string title;
                public DiscordEmbedThumbnail thumbnail = new DiscordEmbedThumbnail();

                [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<DiscordEmbedField> fields = new List<DiscordEmbedField>();

                public DiscordEmbedFooter footer = new DiscordEmbedFooter();
            }

            public class DiscordEmbedThumbnail
            {
                public string newUrl;
            }

            public class DiscordEmbedField
            {
                public string name;
                public string value;
                public bool inline;
            }

            public class DiscordEmbedFooter
            {
                public string text;
                public string icon_url;
            }

            public class PlayerViewExplosionsCommand
            {
                public bool drawAttackerName;
                public float ignoreRaidEventsLessThanMinutes;
            }

            public class NotificationCooldown
            {
                public bool enabled;
                public float cooldown;
            }
        }

        public class DecayEntityIgnoreOptions
        {
            public string name;
            public bool ignore;
            public bool ignoreDiscord;
        }

        #endregion

        #region Config Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        #endregion

        #region Classes

        private class DiscordWebhookManager
        {
            private float _timeout = 200f;
            private float _busy = Time.realtimeSinceStartup;
            private bool _rateLimited = false;
            private Queue<RaidEvent> _queue = new Queue<RaidEvent>();
            private readonly Dictionary<string, string> _headers = new Dictionary<string, string>
            {
                ["Content-Type"] = "application/json"
            };

            public void Enqueue(RaidEvent raidEvent) => _queue.Enqueue(raidEvent);

            private void SendNextRequest()
            {
                if (_queue.Count == 0)
                    return;

                SendWebhook(_queue.Dequeue());
            }

            public void SendWebhook(RaidEvent raidEvent)
            {
                var url = _instance._config.discord.webhookURL;
                if (string.IsNullOrEmpty(url) || url.Contains("Intro-to-Webhooks"))
                    return;

                var timeSinceStartup = Time.realtimeSinceStartup;
                if (_busy > timeSinceStartup || _rateLimited)
                {
                    _instance.PrintDebug($"(RaidEvent: {raidEvent.GetIndex()}) Discord SendWebhook QUEUE busy: {_busy > timeSinceStartup}, rateLimited: {_rateLimited}");

                    Enqueue(raidEvent);
                    return;
                }

                _busy = timeSinceStartup + _timeout;

                string gridPos = MapHelper.PositionToString(raidEvent.endPos);
                string entityShortname = raidEvent.GetHitEntityShortname();
                string entityItemShortname = _instance.GetItemFromPrefabShortname(entityShortname);
                string weaponShortname = raidEvent.GetPrimaryWeaponShortname();
                string weaponItemShortname = _instance.GetItemFromPrefabShortname(weaponShortname);
                var weaponCfg = _instance.FindWeaponConfig(raidEvent.GetTrackerCategory(), weaponShortname);

                var attackerTeam = RelationshipManager.ServerInstance.FindTeam(raidEvent.attackerTeamID);
                string attackerTeamName = attackerTeam != null ? $"{attackerTeam.GetLeader()?.displayName ?? "Unknown Leader"}'s Team (ID: {raidEvent.attackerTeamID})" : "No Team";

                BasePlayer victim = RelationshipManager.FindByID(raidEvent.victimSteamID);
                string victimName = victim?.displayName ?? "Unknown";
                ulong victimTeamID = victim?.Team != null ? victim.Team.teamID : 0;
                string victimTeamName = victim?.Team != null ? $"{victim.Team.GetLeader()?.displayName ?? "Unknown Leader"}'s Team (ID: {victimTeamID})" : "No Team";

                if (victim == null)
                {
                    IPlayer victim2 = _instance.covalence.Players.FindPlayerById(raidEvent.victimSteamID.ToString());
                    victimName = victim2?.Name ?? "Unknown";
                }

                Dictionary<string, string> keyValues = new Dictionary<string, string> {
                    { "attackerName", raidEvent.attackerName },
                    { "attackerSteamID", raidEvent.attackerSteamID.ToString() },
                    { "attackerTeamName", attackerTeamName },
                    { "victimName", victimName },
                    { "victimSteamID", raidEvent.victimSteamID.ToString() },
                    { "victimTeamName", victimTeamName },
                    { "weaponName", raidEvent.GetWeaponName() },
                    { "weaponShortname", weaponShortname },
                    { "weaponItemShortname", weaponItemShortname },
                    { "entityItemName", _instance.GetPrettyItemName(entityItemShortname) },
                    { "entityShortname", entityShortname },
                    { "entityItemShortname", entityItemShortname },
                    { "raidEventIndex", raidEvent.GetIndex().ToString() },
                    { "raidTrackerCategory", raidEvent.GetTrackerCategory() },
                    { "raidEventType", raidEvent.GetPrettyEventType() },
                    { "gridPos", gridPos },
                    { "teleportPos", _instance.FormatPosition(raidEvent.endPos) }
                };

                object payload;
                if (_instance._config.discord.simpleMessage.enabled)
                {
                    payload = new
                    {
                        content = _instance.StringReplaceKeys(_instance._config.discord.simpleMessage.message, keyValues)
                    };
                }
                else
                {
                    var fields = _instance._config.discord.embed.fields
                        .Select(x => new {
                            name = _instance.StringReplaceKeys(x.name, keyValues),
                            value = _instance.StringReplaceKeys(x.value, keyValues),
                            inline = x.inline
                        })
                        .ToArray();

                    int decimalColor;
                    if (!int.TryParse(weaponCfg.hexColor.Replace("#", ""), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out decimalColor))
                        decimalColor = 5548284;

                    payload = new
                    {
                        embeds = new[] {
                            new {
                                title = _instance.StringReplaceKeys(_instance._config.discord.embed.title, keyValues),
                                thumbnail = new {
                                    url = !string.IsNullOrEmpty(weaponCfg.discordIcon) ? weaponCfg.discordIcon : _instance.StringReplaceKeys(_instance._config.discord.embed.thumbnail.newUrl, keyValues)
                                },
                                fields = fields,
                                footer = new {
                                    text = string.Format(_instance._config.discord.embed.footer.text ?? "", _instance.Version),
                                    icon_url = _instance._config.discord.embed.footer.icon_url ?? ""
                                },
                                color = decimalColor,
                                timestamp = raidEvent.timestamp
                            }
                        }
                    };
                }

                _instance.webrequest.Enqueue(url, JsonConvert.SerializeObject(payload), (code, response) => {
                    var reIdx = raidEvent.GetIndex();
                    _instance.PrintDebug($"(RaidEvent: {reIdx}) Discord SendWebhook [{code}] {response}");

                    if (code == 429 && response.Length > 0)
                    {
                        JObject jsonRes = JObject.Parse(response);
                        float retryAfter = Math.Max(1f, jsonRes["retry_after"].Value<int>() / 1000f);

                        _instance.PrintDebug($"(RaidEvent: {reIdx}) Discord SendWebhook rate limited [retry_after: {retryAfter}s]");

                        _rateLimited = true;
                        _instance.timer.In(retryAfter, () => {
                            _rateLimited = false;
                            _busy = Time.realtimeSinceStartup;
                            SendWebhook(raidEvent);
                        });
                    }
                    else if (code != 200 && code != 204)
                    {
                        _busy = Time.realtimeSinceStartup;
                        _instance.Puts($"(RaidEvent: {reIdx}) Discord SendWebhook failed! Response: [{code}]\n{response}");
                    }
                    else
                    {
                        _instance.timer.In(2f, () => { //discord webhooks are limited to 30 req/min, delay requests to reduce rate limit chance
                            _busy = Time.realtimeSinceStartup;
                            SendNextRequest();
                        });
                    }
                }, _instance, Core.Libraries.RequestMethod.POST, _headers, _timeout);
            }
        }

        public class Vector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                serializer.Serialize(writer, value.ToString());
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                string s = (string)reader.Value;
                string[] temp = s.Substring(1, s.Length - 2).Split(',');
                return new Vector3(float.Parse(temp[0]), float.Parse(temp[1]), float.Parse(temp[2]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }

        private class RaidEvent
        {
            public string attackerName;
            public ulong attackerSteamID;
            public ulong attackerTeamID;
            public ulong victimSteamID;
            public string weapon; // "primaryWeapon[tracker_category]" OR "primaryWeapon[tracker_category];secondaryWeapon[tracker_category]"
            public string hitEntity; // "event_type entity_name"
            [JsonConverter(typeof(Vector3Converter))]
            public Vector3 startPos;
            [JsonConverter(typeof(Vector3Converter))]
            public Vector3 endPos;
            public DateTime timestamp;

            public int GetIndex()
            {
                return _instance._raidEventLog.IndexOf(this);
            }

            public string GetPrimaryWeapon()
            {
                if (weapon.Contains(";"))
                    return weapon.Substring(0, weapon.LastIndexOf(';'));
                return weapon;
            }

            public string GetPrimaryWeaponShortname()
            {
                return GetWeaponShortname(GetPrimaryWeapon());
            }

            public string GetSecondaryWeapon()
            {
                if (weapon.Contains(";"))
                    return weapon.Substring(weapon.LastIndexOf(';') + 1);
                return null;
            }

            public string GetSecondaryWeaponShortname()
            {
                return GetWeaponShortname(GetSecondaryWeapon());
            }

            private string GetWeaponShortname(string w)
            {
                return w.Substring(0, w.LastIndexOf('['));
            }

            public string GetTrackerCategory()
            {
                if (weapon.Contains(";"))
                    return GetTrackerCategory(GetPrimaryWeapon());
                return GetTrackerCategory(weapon);
            }

            private string GetTrackerCategory(string w)
            {
                var frm = w.IndexOf('[') + 1;
                return w.Substring(frm, w.LastIndexOf(']') - frm);
            }

            public string GetWeaponName()
            {
                if (weapon.Contains(";"))
                    return $"{_instance.FindWeaponConfig(GetTrackerCategory(), GetPrimaryWeaponShortname()).name} [{_instance.FindWeaponConfig(GetTrackerCategory(GetSecondaryWeapon()), GetSecondaryWeaponShortname()).name}]";
                return _instance.FindWeaponConfig(GetTrackerCategory(), GetPrimaryWeaponShortname()).name;
            }

            public string GetEventType()
            {
                return hitEntity.Substring(0, hitEntity.LastIndexOf(' '));
            }

            public string GetPrettyEventType()
            {
                var evt = GetEventType();
                return _instance._config.eventTypes.ContainsKey(evt) ? _instance._config.eventTypes[evt] : evt;
            }

            public string GetHitEntityShortname()
            {
                return hitEntity.Substring(hitEntity.LastIndexOf(' ') + 1);
            }

            public string GetMessage()
            {
                IPlayer victim = _instance.covalence.Players.FindPlayerById(victimSteamID.ToString());
                return _instance.StringReplaceKeys(
                    _instance.lang.GetMessage("RaidEvent.Message", _instance),
                    new Dictionary<string, string> {
                        { "raidEventIndex", GetIndex().ToString() },
                        { "attackerName", attackerName },
                        { "attackerSteamID", attackerSteamID.ToString() },
                        { "victimName", victim?.Name ?? "Unknown" },
                        { "victimSteamID", victimSteamID.ToString() },
                        { "weaponName", GetWeaponName() },
                        { "hitEntity", hitEntity.Replace(GetEventType(), GetPrettyEventType()) },
                        { "gridPos", MapHelper.PositionToString(endPos) },
                        { "teleportPos", _instance.FormatPosition(endPos) }
                    });
            }

            public string GetPrettyMessage(BasePlayer pl)
            {
                var weaponCfg = _instance.FindWeaponConfig(GetTrackerCategory(), GetPrimaryWeaponShortname());
                IPlayer victim = _instance.covalence.Players.FindPlayerById(victimSteamID.ToString());
                string entityShortname = GetHitEntityShortname();
                string entityItemShortname = _instance.GetItemFromPrefabShortname(entityShortname);
                string entityItemName = _instance.GetPrettyItemName(entityItemShortname);
                return _instance.StringReplaceKeys(
                    _instance.lang.GetMessage("RaidEvent.PrettyMessage", _instance, pl?.UserIDString),
                    new Dictionary<string, string> {
                        { "raidEventIndex", GetIndex().ToString() },
                        { "attackerName", attackerName },
                        { "attackerSteamID", attackerSteamID.ToString() },
                        { "victimName", victim?.Name ?? "Unknown" },
                        { "victimSteamID", victimSteamID.ToString() },
                        { "weaponName", GetWeaponName() },
                        { "weaponColor", weaponCfg.hexColor },
                        { "raidEventType", GetPrettyEventType() },
                        { "entityItemName", entityItemName },
                        { "entityShortname", entityShortname },
                        { "gridPos", MapHelper.PositionToString(endPos) },
                        { "teleportPos", _instance.FormatPosition(endPos) }
                    });
            }

            public void Notify(BaseEntity entity, string damagedEntityPrefab = null)
            {
                var weaponCfg = _instance.FindWeaponConfig(GetTrackerCategory(), GetPrimaryWeaponShortname());
                if (weaponCfg.logToFile || _instance._dev)
                    _instance.LogToFile("raid_events", GetMessage(), _instance);

                if (_instance._config.notificationCooldown.enabled && !_instance._dev)
                {
                    float cooldown;
                    if (_instance._notificationCooldown.TryGetValue(attackerSteamID, out cooldown) && cooldown > Time.realtimeSinceStartup)
                        return;

                    _instance._notificationCooldown[attackerSteamID] = Time.realtimeSinceStartup + _instance._config.notificationCooldown.cooldown;
                }

                if (weaponCfg.notifyConsole)
                    _instance.Puts(GetMessage());

                if (weaponCfg.notifyAdmin || _instance._dev)
                    NotifyAdmin();

                if (weaponCfg.notifyDiscord || _instance._dev)
                {
                    if (string.IsNullOrEmpty(damagedEntityPrefab) && entity != null)
                        damagedEntityPrefab = entity.PrefabName;

                    DecayEntityIgnoreOptions decayEntOptions;
                    if (!_instance._dev && _instance._decayEntityIgnoreList.TryGetValue(damagedEntityPrefab, out decayEntOptions) && decayEntOptions.ignoreDiscord)
                        return;

                    _instance._discordWebhookManager.SendWebhook(this);
                }

                if (_instance._debug && entity != null)
                    DebugNotify(entity);
            }

            private void NotifyAdmin()
            {
                foreach (var adminPlayer in BasePlayer.activePlayerList)
                {
                    if (adminPlayer == null || !adminPlayer.IsAdmin || !adminPlayer.IsAlive()) continue;
                    _instance.SendChatMsg(adminPlayer, GetPrettyMessage(adminPlayer));
                }
            }

            private void DebugNotify(BaseEntity entity)
            {
                string msg = GetMessage();
                foreach (var adminPlayer in BasePlayer.activePlayerList)
                {
                    if (adminPlayer == null || !adminPlayer.IsAdmin || !adminPlayer.IsAlive()) continue;

                    _instance.Arrow(adminPlayer, endPos, endPos + entity.transform.forward, 0.05f, Color.magenta, _instance._debugDrawDuration);
                    _instance.Sphere(adminPlayer, endPos, (entity as TimedExplosive)?.explosionRadius ?? 2f, Color.cyan, _instance._debugDrawDuration);

                    _instance.Sphere(adminPlayer, endPos, 0.05f, Color.red, _instance._debugDrawDuration);
                    _instance.Text(adminPlayer, endPos, $"<size=14>[DEBUG] RAID DETECTED\n{msg}</size>", Color.magenta, _instance._debugDrawDuration);
                }

                _instance.PrintDebug($"RAID: {msg}");
            }
        }

        private class RaidFilter
        {
            public string filter;
            public string filterType;

            public override bool Equals(object other)
            {
                if (ReferenceEquals(null, other)) return false;
                if (ReferenceEquals(this, other)) return true;
                if (this.GetType() != other.GetType()) return false;
                return Equals((RaidFilter)other);
            }

            public override int GetHashCode()
            {
                return filter.GetHashCode() + filterType.GetHashCode();
            }

            public bool Equals(RaidFilter other)
            {
                return other.filter == filter && other.filterType == filterType;
            }

            public static bool operator ==(RaidFilter lhs, RaidFilter rhs)
            {
                return lhs.Equals(rhs);
            }

            public static bool operator !=(RaidFilter lhs, RaidFilter rhs)
            {
                return !lhs.Equals(rhs);
            }
        }

        public class ExplosiveTracker : MonoBehaviour
        {
            private float startTime;
            private double millisecondsTaken;

            private string hitEntityPrefab;
            private BaseEntity explosiveEntity;
            private DecayEntity parentEntity;
            private BasePlayer attacker;
            private Vector3 position;
            private RaidEvent raidEvent;

            public string trackerCategory;
            public bool logEvent = true;

            public void Init(string category)
            {
                explosiveEntity = GetComponent<BaseEntity>();
                attacker = explosiveEntity?.creatorEntity as BasePlayer;

                if (explosiveEntity == null || attacker == null || attacker.IsNpc)
                {
                    logEvent = false;
                    Destroy(this);
                    return;
                }

                trackerCategory = category;
                position = explosiveEntity.transform.position;
                if (_instance._debug)
                    startTime = Time.realtimeSinceStartup;

                var startPos = attacker.transform.position;
                startPos.y += attacker.GetHeight() - .5f;

                raidEvent = new RaidEvent
                {
                    attackerName = attacker?.displayName ?? "Unknown",
                    attackerSteamID = attacker?.userID ?? 0,
                    attackerTeamID = attacker?.Team?.teamID ?? 0,
                    victimSteamID = 0,
                    weapon = $"{explosiveEntity.ShortPrefabName}[{trackerCategory}]",
                    startPos = startPos,
                    endPos = Vector3.zero,
                    timestamp = DateTime.Now
                };
            }

            private void FixedUpdate()
            {
                if (explosiveEntity == null)
                {
                    logEvent = false;
                    Destroy(this);
                    return;
                }

                var tick = DateTime.Now;
                var dudTimedExp = explosiveEntity as DudTimedExplosive;
                if (dudTimedExp != null)
                {
                    // ignore logging if explosive is dud
                    logEvent = dudTimedExp.HasFlag(BaseEntity.Flags.On);
                    if (!logEvent) return;
                }

                var newPos = explosiveEntity.transform.position;
                if (parentEntity != null)
                {
                    if (string.IsNullOrEmpty(raidEvent.hitEntity))
                    {
                        if (_instance.IsDecayEntityOrAttackerIgnored(parentEntity, attacker))
                        {
                            logEvent = false;
                            Destroy(this);
                            return;
                        }

                        var entityShortname = _instance.GetDecayEntityShortname(parentEntity);
                        hitEntityPrefab = parentEntity.PrefabName;
                        raidEvent.hitEntity = $"EVENT.ATTACHED {entityShortname}";
                        raidEvent.victimSteamID = parentEntity.OwnerID;

                        _instance.PrintDebug($"{explosiveEntity.ShortPrefabName} ATTACHED TO PARENT {entityShortname}[{parentEntity?.net?.ID.Value ?? 0}]");
                    }
                }
                else
                    parentEntity = explosiveEntity.GetParentEntity() as DecayEntity;

                if (newPos != position && Vector3.Distance(newPos, Vector3.zero) > 5f)
                    position = newPos;

                if (_instance._debug)
                    millisecondsTaken += (DateTime.Now - tick).TotalMilliseconds;
            }

            private void OnDestroy()
            {
                if (!logEvent) return;

                var tick = DateTime.Now;

                // not parented to an entity, check for collisions
                if (string.IsNullOrEmpty(raidEvent.hitEntity))
                {
                    Ray ray = new Ray(position, explosiveEntity.transform.forward);
                    float radius = (explosiveEntity as TimedExplosive)?.explosionRadius ?? 2f;
                    float maxDistance = 1f;
                    List<RaycastHit> hits = Facepunch.Pool.Get<List<RaycastHit>>();
                    GamePhysics.TraceAllUnordered(ray, radius, hits, maxDistance, _instance._collisionLayerMask, QueryTriggerInteraction.Ignore);

                    if (hits.Count > 0)
                    {
                        var sortedHits = hits.Where(x => {
                            var decayEnt = x.GetEntity() as DecayEntity;
                            return decayEnt != null && decayEnt.IsVisible(position, float.PositiveInfinity);
                        })
                            .OrderBy(x => (x.transform.position - position).sqrMagnitude)
                            .ToList();

                        if (_instance._debug)
                        {
                            foreach (var hit in hits)
                            {
                                foreach (var adminPlayer in BasePlayer.activePlayerList)
                                {
                                    if (adminPlayer == null || !adminPlayer.IsAdmin || !adminPlayer.IsAlive()) continue;

                                    var traceHitEnt = hit.GetEntity() as DecayEntity;
                                    var color = Color.red;
                                    if (sortedHits.IndexOf(hit) == 0)
                                        color = Color.green;
                                    else if (sortedHits.Contains(hit))
                                        color = Color.yellow;

                                    _instance.Arrow(adminPlayer, position, hit.transform.position, 0.05f, color, _instance._debugDrawDuration);
                                    _instance.Box(adminPlayer, hit.transform.position, 0.1f, color, _instance._debugDrawDuration);
                                    _instance.Text(adminPlayer, hit.transform.position, $"<size=10>{(sortedHits.Contains(hit) ? $"{sortedHits.IndexOf(hit)}" : "")} {traceHitEnt?.ShortPrefabName ?? "Unknown"}</size>", color, _instance._debugDrawDuration);
                                }
                            }
                        }

                        if (sortedHits.Count > 0)
                        {
                            DecayEntity hitEntity = sortedHits[0].GetEntity() as DecayEntity;
                            if (hitEntity != null)
                            {
                                if (_instance.IsDecayEntityOrAttackerIgnored(hitEntity, attacker))
                                    return;

                                var entityShortname = _instance.GetDecayEntityShortname(hitEntity);
                                hitEntityPrefab = hitEntity.PrefabName;
                                raidEvent.hitEntity = $"EVENT.HIT {entityShortname}";
                                raidEvent.victimSteamID = hitEntity.OwnerID;

                                _instance.PrintDebug($"{explosiveEntity.ShortPrefabName} COLLIDED WITH {entityShortname}[{hitEntity?.net?.ID.Value ?? 0}]");
                            }
                        }
                    }

                    Facepunch.Pool.FreeUnmanaged(ref hits);
                }

                // parent entity, collision or always logged weapon detected. log raid event.
                if (!string.IsNullOrEmpty(raidEvent.hitEntity) || _instance.FindWeaponConfig(trackerCategory, raidEvent.GetPrimaryWeaponShortname()).alwaysLog)
                {
                    raidEvent.hitEntity = raidEvent.hitEntity ?? $"EVENT.NO_HIT unknown_entity";
                    raidEvent.endPos = position;

                    if (explosiveEntity is MLRSRocket)
                    {
                        var pos = (raidEvent.startPos + raidEvent.endPos) / 2;
                        pos.y += 700f;
                        raidEvent.startPos = pos;
                    }

                    _instance._raidEventLog.Add(raidEvent);
                    raidEvent.Notify(explosiveEntity, hitEntityPrefab);
                }

                if (_instance._debug)
                {
                    millisecondsTaken += (DateTime.Now - tick).TotalMilliseconds;
                    _instance.PrintDebug($"{raidEvent.weapon} explosive tracker took {millisecondsTaken}ms and was alive for {Time.realtimeSinceStartup - startTime}s");
                }
            }
        }

        #endregion
    }
}

// --- End of file: RaidTracker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rad-house ---
// --- Original File Path: R/RadHouse/RadHouse.cs ---

﻿using System.Collections.Generic;
using UnityEngine;
using Rust;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using System.Reflection;
using System;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("RadHouse", "pidorassavy", "1.0.5")]
    [Description("Small plugin create RadHouse event on server")]

    class RadHouse : RustPlugin
    {
        // Other needed functions and vars
        #region SomeParameters and plugin's load
        [PluginReference] Plugin RandomSpawns;
        [PluginReference] Plugin RustMap;
		[PluginReference] Plugin LustyMap;

        private List<ZoneList> RadiationZones = new List<ZoneList>();
        private static readonly int playerLayer = LayerMask.GetMask("Player (Server)");
        private static readonly Collider[] colBuffer = (Collider[])typeof(Vis).GetField("colBuffer", (BindingFlags.Static | BindingFlags.NonPublic))?.GetValue(null);
        private ZoneList RadHouseZone;


        public List<uint> BaseEntityList = new List<uint>();
        public List<ulong> PlayerAuth = new List<ulong>();
        private List<string> BlockedItems = new List<string>();
        private Dictionary<string, object> ItemList_Common = new Dictionary<string, object>()
        {
            ["charcoal"] = 10000,
            ["metal.fragments"] = 2500,
            ["sulfur"] = 1000,
            ["wood"] = 10000

        };
        private Dictionary<string, object> ItemList_Rare = new Dictionary<string, object>()
        {
            ["rifle.ak"] = 1,
            ["rifle.bolt"] = 1,
            ["rifle.lr300"] = 1,
            ["smg.thompson"] = 1
        };
        private Dictionary<string, object> ItemList_Top = new Dictionary<string, object>()
        {
            ["ammo.rocket.basic"] = 2,
            ["explosive.satchel"] = 4,
            ["explosive.timed"] = 1,
            ["lmg.m249"] = 1,
            ["rocket.launcher"] = 1
        };

        public bool CanLoot = false;
  
        public bool NowLooted = false;
        public Timer mytimer;
        public Timer mytimer2;
        public Timer mytimer3;
        public Timer mytimer4;
        public int timercallbackdelay = 0;

        #region CFG var's
        public bool GuiOn = true;
        public string AnchorMinCfg = "0.3445 0.16075";
        public string AnchorMaxCfg = "0.6405 0.20075";
        public string ColorCfg = "1 1 1 0.1";
        public string TextGUI = "Радиационный дом:";
        public bool RadiationTrue = false;
        public string ChatPrefix = "<color=#ffe100>Радиационный дом:</color>";

        public int TimerSpawnHouse = 3600;
        public int TimerDestroyHouse = 60;
        public int TimerLoot = 120;

        public int RadiationRadius = 10;
        public int RadiationIntensity = 25;
        #endregion




        protected override void LoadDefaultConfig()
        {
            LoadConfigValues();
        }


        private void LoadConfigValues()
        {
            
            GetConfig("[GUI]", "Включить GUI", ref GuiOn);
            GetConfig("[GUI]", "Anchor Min", ref AnchorMinCfg);
            GetConfig("[GUI]", "Anchor Max", ref AnchorMaxCfg);
            GetConfig("[GUI]", "Цвет фона", ref ColorCfg);
            GetConfig("[GUI]", "Текст в GUI окне", ref TextGUI);
            GetConfig("[Основное]", "Префикс чата", ref ChatPrefix);
            GetConfig("[Основное]", "Время спавна дома", ref TimerSpawnHouse);
            GetConfig("[Основное]", "Задержка перед лутанием ящика", ref TimerLoot);
            GetConfig("[Основное]", "Задержка перед удалением дома", ref TimerDestroyHouse);
            GetConfig("[Радиация]", "Радиус радиации", ref RadiationRadius);
            GetConfig("[Радиация]", "Отключить стандартную радиацию", ref RadiationTrue);
            GetConfig("[Радиация]", "Интенсивность радиации", ref RadiationIntensity);
            GetConfig("[Лут]", "Список обычного лута (shortname)", ref ItemList_Common);
            GetConfig("[Лут]", "Список редкого лута (shortname)", ref ItemList_Rare);
            GetConfig("[Лут]", "Список топового лута (shortname)", ref ItemList_Top);
            SaveConfig();
        }

        private void GetConfig<T>(string menu, string Key, ref T var)
        {
            if (Config[menu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
            }

            Config[menu, Key] = var;
        }

        void OnServerInitialized()
        {
            LoadDefaultConfig();
            timer.Once(1, () => { CreateRadHouse(); });
            mytimer4 = timer.Repeat(TimerSpawnHouse, 0, () =>
            {
                try
                {
                    if (BaseEntityList != null)
                    {
                        DestroyRadHouse();
                    }
                    CreateRadHouse();
                }
                catch(Exception ex) { Puts(ex.ToString()); }
            });
        }

        void Loaded()
        {
            if (RadiationTrue)
            {
                OnServerRadiation();
                PrintWarning("Радиация на стандартный объектах отключена");
            }
        }
        void Unload()
        {
            if(BaseEntityList != null) DestroyRadHouse();
            if(mytimer != null) timer.Destroy(ref mytimer);
            if (mytimer2 != null) timer.Destroy(ref mytimer2);
            if (mytimer3 != null) timer.Destroy(ref mytimer3);
            if (mytimer4 != null) timer.Destroy(ref mytimer4);
        }

        #endregion

            // Function Create entity
            #region CreateAndDestroyRadHouse
        public object success;

        [ChatCommand("rh")]
        void CreateRadHouseCommand(BasePlayer player, string cmd, string[] Args)
        {
            if (player == null) return;

            if (!player.IsAdmin)
            {
                SendReply(player, $"{ChatPrefix} Команда доступна только администраторам");
                return;
            }
            if (Args == null || Args.Length == 0)
            {
                SendReply(player, $"{ChatPrefix} Используйте /rh start или /rh cancel");
                return;
            }

            switch (Args[0])
            {
                case "start":
                    CreateRadHouse();
                    SendReply(player, $"{ChatPrefix} Вы в ручную запустили ивент");
                    return;
                case "cancel":
                    DestroyRadHouse();
                    SendReply(player, $"{ChatPrefix} Ивент остановлен");
                    return;
            }

        }
        private void OnServerRadiation()
        {
            var allobjects = UnityEngine.Object.FindObjectsOfType<TriggerRadiation>();
            for (int i = 0; i < allobjects.Length; i++)
            {
                UnityEngine.Object.Destroy(allobjects[i]);
                
            }
        }
        void CreateRadHouse()
        {
            if(!plugins.Exists("RandomSpawns"))
            { return; }
            Vector3 pos;
            pos.x = 0;
            pos.y = 0;
            pos.z = 0;
            success = RandomSpawns.Call("GetSpawnPoint");

            pos = (Vector3)success;
            if(pos.y > 30f)
            {
                CreateRadHouse();
                return;
            }
            

            pos.x = pos.x + 0f;
            pos.y = pos.y + 1f;
            pos.z = pos.z + 0f;
            			
			
            BaseEntity Foundation = GameManager.server.CreateEntity("assets/prefabs/building core/foundation/foundation.prefab", pos, new Quaternion(), true);
            BuildingBlock bbF = Foundation.GetComponent<BuildingBlock>();			
			
			var bId = BindDecay(bbF);						
			
            pos.x = pos.x - 1.5f;

            BaseEntity Wall = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);
            Wall.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
            BuildingBlock bbW = Wall.GetComponent<BuildingBlock>();
			
			bId = BindDecay(bbW, bId);

            pos = (Vector3)success;

            pos.x = pos.x + 0f;
            pos.y = pos.y + 1f;
            pos.z = pos.z + 3f;

            BaseEntity Foundation2 = GameManager.server.CreateEntity("assets/prefabs/building core/foundation/foundation.prefab", pos, new Quaternion(), true);
            BuildingBlock bbF2 = Foundation2.GetComponent<BuildingBlock>();

			bId = BindDecay(bbF2, bId);
			
            pos.x = pos.x - 1.5f;

            BaseEntity Wall2 = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);
            Wall2.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
            BuildingBlock bbW2 = Wall2.GetComponent<BuildingBlock>();

			bId = BindDecay(bbW2, bId);
			
            pos = (Vector3)success;

            pos.x = pos.x + 3f;
            pos.y = pos.y + 1f;
            pos.z = pos.z + 0f;

            BaseEntity Foundation3 = GameManager.server.CreateEntity("assets/prefabs/building core/foundation/foundation.prefab", pos, new Quaternion(), true);
            BuildingBlock bbF3 = Foundation3.GetComponent<BuildingBlock>();

			bId = BindDecay(bbF3, bId);
			
            pos.x = pos.x + 1.5f;

            BaseEntity Wall3 = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);
            BuildingBlock bbW3 = Wall3.GetComponent<BuildingBlock>();

			bId = BindDecay(bbW3, bId);
			
            pos = (Vector3)success;

            pos.x = pos.x + 3f;
            pos.y = pos.y + 1f;
            pos.z = pos.z + 3f;

            BaseEntity Foundation4 = GameManager.server.CreateEntity("assets/prefabs/building core/foundation/foundation.prefab", pos, new Quaternion(), true);
            BuildingBlock bbF4 = Foundation4.GetComponent<BuildingBlock>();

			bId = BindDecay(bbF4, bId);
			
            pos.x = pos.x + 1.5f;

            BaseEntity Wall4 = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);
            BuildingBlock bbW4 = Wall4.GetComponent<BuildingBlock>();

			bId = BindDecay(bbW4, bId);
			
            pos = (Vector3)success;

            pos.z = pos.z - 1.5f;
            pos.y = pos.y + 1f;

            BaseEntity DoorWay = GameManager.server.CreateEntity("assets/prefabs/building core/wall.doorway/wall.doorway.prefab", pos, new Quaternion(), true);
            DoorWay.transform.localEulerAngles = new Vector3(0f, 90f, 0f);
            BuildingBlock bbDW = DoorWay.GetComponent<BuildingBlock>();

			bId = BindDecay(bbDW, bId);
			
            pos = (Vector3)success;

            pos.x = pos.x + 3f;
            pos.y = pos.y + 1f;
            pos.z = pos.z + 4.5f;

            BaseEntity DoorWay2 = GameManager.server.CreateEntity("assets/prefabs/building core/wall.doorway/wall.doorway.prefab", pos, new Quaternion(), true);
            DoorWay2.transform.localEulerAngles = new Vector3(0f, 270f, 0f);
            BuildingBlock bbDW2 = DoorWay2.GetComponent<BuildingBlock>();

			bId = BindDecay(bbDW2, bId);
			
            pos = (Vector3)success;

            pos.z = pos.z - 1.5f;
            pos.y = pos.y + 1f;
            pos.x = pos.x + 3f;

            BaseEntity WindowWall = GameManager.server.CreateEntity("assets/prefabs/building core/wall.window/wall.window.prefab", pos, new Quaternion(), true);
            WindowWall.transform.localEulerAngles = new Vector3(0f, 90f, 0f);
            BuildingBlock bbWW = WindowWall.GetComponent<BuildingBlock>();

			bId = BindDecay(bbWW, bId);
			
            pos = (Vector3)success;

            pos.x = pos.x + 0f;
            pos.y = pos.y + 1f;
            pos.z = pos.z + 4.5f;

            BaseEntity WindowWall2 = GameManager.server.CreateEntity("assets/prefabs/building core/wall.window/wall.window.prefab", pos, new Quaternion(), true);
            WindowWall2.transform.localEulerAngles = new Vector3(0f, 270f, 0f);
            BuildingBlock bbWW2 = WindowWall2.GetComponent<BuildingBlock>();

			bId = BindDecay(bbWW2, bId);
			
            pos = (Vector3)success;

            pos.x = pos.x + 0f;
            pos.y = pos.y + 4f;
            pos.z = pos.z + 0f;

            BaseEntity Roof = GameManager.server.CreateEntity("assets/prefabs/building core/roof/roof.prefab", pos, new Quaternion(), true);
            Roof.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
            BuildingBlock bbR = Roof.GetComponent<BuildingBlock>();

			bId = BindDecay(bbR, bId);
			
            pos = (Vector3)success;

            pos.x = pos.x + 3f;
            pos.y = pos.y + 4f;
            pos.z = pos.z + 0f;

            BaseEntity Roof2 = GameManager.server.CreateEntity("assets/prefabs/building core/roof/roof.prefab", pos, new Quaternion(), true);
            Roof2.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
            BuildingBlock bbR2 = Roof2.GetComponent<BuildingBlock>();

			bId = BindDecay(bbR2, bId);
			
            pos = (Vector3)success;

            pos.x = pos.x + 0f;
            pos.y = pos.y + 4f;
            pos.z = pos.z + 3f;

            BaseEntity Roof3 = GameManager.server.CreateEntity("assets/prefabs/building core/roof/roof.prefab", pos, new Quaternion(), true);
            Roof3.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
            BuildingBlock bbR3 = Roof3.GetComponent<BuildingBlock>();

			bId = BindDecay(bbR3, bId);
			
            pos = (Vector3)success;

            pos.x = pos.x + 3f;
            pos.y = pos.y + 4f;
            pos.z = pos.z + 3f;

            BaseEntity Roof4 = GameManager.server.CreateEntity("assets/prefabs/building core/roof/roof.prefab", pos, new Quaternion(), true);
            Roof4.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
            BuildingBlock bbR4 = Roof4.GetComponent<BuildingBlock>();

			bId = BindDecay(bbR4, bId);
			
            pos = (Vector3)success;

            pos.x = pos.x + 4.0f;
            pos.y = pos.y + 1f;
            pos.z = pos.z + 1.5f;

            BaseEntity CupBoard = GameManager.server.CreateEntity("assets/prefabs/deployable/tool cupboard/cupboard.tool.deployed.prefab", pos, new Quaternion(), true);
            CupBoard.transform.localEulerAngles = new Vector3(0f, 270f, 0f);

			bId = BindDecay(CupBoard, bId);
			
            pos = (Vector3)success;

            pos.x = pos.x - 1.0f;
            pos.y = pos.y + 1f;
            pos.z = pos.z + 1.5f;

            BaseEntity Box = GameManager.server.CreateEntity("assets/prefabs/deployable/large wood storage/box.wooden.large.prefab", pos, new Quaternion(), true);
            Box.skinID = 942917320;
            Box.transform.localEulerAngles = new Vector3(0f, 90f, 0f);			
			
			bId = BindDecay(Box, bId);
			
            pos = (Vector3)success;

            pos.x = pos.x + 3;
            pos.y = pos.y - 0.5f;
            pos.z = pos.z + 7.5f;

            BaseEntity FSteps = GameManager.server.CreateEntity("assets/prefabs/building core/foundation.steps/foundation.steps.prefab", pos, new Quaternion(), true);
            FSteps.transform.localEulerAngles = new Vector3(0f, 90f, 0f);
            BuildingBlock bbFS = FSteps.GetComponent<BuildingBlock>();

			bId = BindDecay(bbFS, bId);
			
            pos = (Vector3)success;

            pos.x = pos.x - 0f;
            pos.y = pos.y - 0.5f;
            pos.z = pos.z - 4.5f;

            BaseEntity FSteps2 = GameManager.server.CreateEntity("assets/prefabs/building core/foundation.steps/foundation.steps.prefab", pos, new Quaternion(), true);
            FSteps2.transform.localEulerAngles = new Vector3(0f, 270f, 0f);
            BuildingBlock bbFS2 = FSteps2.GetComponent<BuildingBlock>();

			bId = BindDecay(bbFS2, bId);
			
            Foundation.Spawn();
            Wall.Spawn();
            Foundation2.Spawn();
            Wall2.Spawn();
            Foundation3.Spawn();
            Wall3.Spawn();
            Foundation4.Spawn();
            Wall4.Spawn();
            DoorWay.Spawn();
            DoorWay2.Spawn();
            WindowWall.Spawn();
            WindowWall2.Spawn();
            Roof.Spawn();
            Roof2.Spawn();
            Roof3.Spawn();
            Roof4.Spawn();
            CupBoard.Spawn();
            Box.Spawn();
            FSteps.Spawn();
            FSteps2.Spawn();									
			
            StorageContainer Container = Box.GetComponent<StorageContainer>();									
            ItemContainer inven = Container?.inventory;						
			
            if (Container != null)
            {				
				
				if (ItemList_Common != null)
				{	
					var Common = ItemList_Common.Select(key => key.Key).ToList();				                               
					for (var i = 0; i < ItemList_Common.Count; i++)
					{
						int j = UnityEngine.Random.Range(1, 10);
						var item = ItemManager.CreateByName(Common[i], Convert.ToInt32(ItemList_Common[Common[i]]));
						if (j > 3)
						{
							item.MoveToContainer(Container.inventory, -1, false);
						}
					}
				}
				
				if (ItemList_Rare != null)
				{	
					var Rare = ItemList_Rare.Select(key => key.Key).ToList();				
					for (var i = 0; i < ItemList_Rare.Count; i++)
					{
						int j = UnityEngine.Random.Range(1, 10);
						var item = ItemManager.CreateByName(Rare[i], Convert.ToInt32(ItemList_Rare[Rare[i]]));
						if (j > 5)
						{
							item.MoveToContainer(Container.inventory, -1, false);
						}
					}
				}
				
				if (ItemList_Top != null)
				{	
					var Top = ItemList_Top.Select(key => key.Key).ToList();				
					for (var i = 0; i < ItemList_Top.Count; i++)
					{
						int j = UnityEngine.Random.Range(1, 10);
						var item = ItemManager.CreateByName(Top[i], Convert.ToInt32(ItemList_Top[Top[i]]));
						if (j > 7)
						{
							item.MoveToContainer(Container.inventory, -1, false);
						}
					}
				}
            }
			
            bbF.SetGrade((BuildingGrade.Enum)1);
            bbF.UpdateSkin();
            bbF.SetHealthToMax();
            bbF.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbW.SetGrade((BuildingGrade.Enum)1);
            bbW.UpdateSkin();
            bbW.SetHealthToMax();
            bbW.grounded = true;
            bbW.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbF2.SetGrade((BuildingGrade.Enum)1);
            bbF2.UpdateSkin();
            bbF2.SetHealthToMax();
            bbF2.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbW2.SetGrade((BuildingGrade.Enum)1);
            bbW2.UpdateSkin();
            bbW2.SetHealthToMax();
            bbW2.grounded = true;
            bbW2.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbF3.SetGrade((BuildingGrade.Enum)1);
            bbF3.UpdateSkin();
            bbF3.SetHealthToMax();
            bbF3.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbW3.SetGrade((BuildingGrade.Enum)1);
            bbW3.UpdateSkin();
            bbW3.SetHealthToMax();
            bbW3.grounded = true;
            bbW3.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbF4.SetGrade((BuildingGrade.Enum)1);
            bbF4.UpdateSkin();
            bbF4.SetHealthToMax();
            bbF4.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbW4.SetGrade((BuildingGrade.Enum)1);
            bbW4.UpdateSkin();
            bbW4.SetHealthToMax();
            bbW4.grounded = true;
            bbW4.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbDW.SetGrade((BuildingGrade.Enum)1);
            bbDW.UpdateSkin();
            bbDW.SetHealthToMax();
            bbDW.grounded = true;
            bbDW.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbDW2.SetGrade((BuildingGrade.Enum)1);
            bbDW2.UpdateSkin();
            bbDW2.SetHealthToMax();
            bbDW2.grounded = true;
            bbDW2.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbWW.SetGrade((BuildingGrade.Enum)1);
            bbWW.UpdateSkin();
            bbWW.SetHealthToMax();
            bbWW.grounded = true;
            bbWW.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbWW2.SetGrade((BuildingGrade.Enum)1);
            bbWW2.UpdateSkin();
            bbWW2.SetHealthToMax();
            bbWW2.grounded = true;
            bbWW2.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbR.SetGrade((BuildingGrade.Enum)1);
            bbR.UpdateSkin();
            bbR.SetHealthToMax();
            bbR.grounded = true;
            bbR.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbR2.SetGrade((BuildingGrade.Enum)1);
            bbR2.UpdateSkin();
            bbR2.SetHealthToMax();
            bbR2.grounded = true;
            bbR2.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbR3.SetGrade((BuildingGrade.Enum)1);
            bbR3.UpdateSkin();
            bbR3.SetHealthToMax();
            bbR3.grounded = true;
            bbR3.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbR4.SetGrade((BuildingGrade.Enum)1);
            bbR4.UpdateSkin();
            bbR4.SetHealthToMax();
            bbR4.grounded = true;
            bbR4.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbFS.SetGrade((BuildingGrade.Enum)1);
            bbFS.UpdateSkin();
            bbFS.SetHealthToMax();
            bbFS.grounded = true;
            bbFS.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            bbFS2.SetGrade((BuildingGrade.Enum)1);
            bbFS2.UpdateSkin();
            bbFS2.SetHealthToMax();
            bbFS2.grounded = true;
            bbFS2.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);			
			
            BaseEntityList.Add(Foundation.net.ID);
            BaseEntityList.Add(Foundation2.net.ID);
            BaseEntityList.Add(Foundation3.net.ID);
            BaseEntityList.Add(Foundation4.net.ID);
            BaseEntityList.Add(Wall.net.ID);
            BaseEntityList.Add(Wall2.net.ID);
            BaseEntityList.Add(Wall3.net.ID);
            BaseEntityList.Add(Wall4.net.ID);
            BaseEntityList.Add(Roof.net.ID);
            BaseEntityList.Add(Roof2.net.ID);
            BaseEntityList.Add(Roof3.net.ID);
            BaseEntityList.Add(Roof4.net.ID);
            BaseEntityList.Add(DoorWay.net.ID);
            BaseEntityList.Add(DoorWay2.net.ID);
            BaseEntityList.Add(WindowWall.net.ID);
            BaseEntityList.Add(WindowWall2.net.ID);
            BaseEntityList.Add(CupBoard.net.ID);
            BaseEntityList.Add(Box.net.ID);
            BaseEntityList.Add(FSteps.net.ID);
            BaseEntityList.Add(FSteps2.net.ID);
            InitializeZone(Box.transform.position, RadiationIntensity, RadiationRadius, 666);
            Server.Broadcast($"{ChatPrefix} Радиактивный домик появился, координаты: {pos.ToString()}");
            foreach (var player in BasePlayer.activePlayerList)
            {
                CreateGui(player);
            }
            if (plugins.Exists("RustMap"))
            {
				LustyMap?.Call("AddMarker", Box.transform , Box.transform , "RadHouseMap", "rad", 0);
                RustMap?.Call("AddTemporaryMarker", "rad", false, 0.03f, 0.99f, Box.transform, "RadHouseMap");
            }
            CanLoot = false;
            NowLooted = false;
            timercallbackdelay = 0;
        }

        void DestroyRadHouse()
        {
            if(BaseEntityList != null)
            {
                foreach(uint id in BaseEntityList)
                {
                    BaseNetworkable.serverEntities.Find(id).Kill();
                }
                DestroyZone(RadHouseZone);
                if (plugins.Exists("RustMap"))
                {
					LustyMap?.Call("RemoveMarker", "RadHouseMap");
					RustMap?.Call("RemoveTemporaryMarkerByName", "RadHouseMap");
                }
                BaseEntityList.Clear();
                PlayerAuth.Clear();
            }
            foreach(var player in BasePlayer.activePlayerList)
            {
                DestroyGui(player);
            }
        }
		private uint BindDecay(BaseEntity entity, uint buildingid = 0)
		{
			DecayEntity decayEntity = entity.GetComponentInParent<DecayEntity>();      
			if(decayEntity != null)
			{
				if(buildingid == 0)  				
					buildingid = BuildingManager.server.NewBuildingID();					
						
			   decayEntity.AttachToBuilding(buildingid);
			}
			return buildingid;
		}
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (BaseEntityList != null)
                {
                    foreach (uint id in BaseEntityList)
                    {
                        BaseNetworkable entityID = BaseNetworkable.serverEntities.Find(id);
                        if (entityID.net.ID == entity.net.ID)
                        {
                            return false;
                        }
                    }
                }
            }
            catch (Exception ex) { return null; }
            return null;
        }

        #endregion

        // Function loot box and auth in cupboard
        #region LootBox
        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (BaseEntityList != null)
            {
                foreach (uint id in BaseEntityList)
                {
                    BaseNetworkable entityID = BaseNetworkable.serverEntities.Find(id);
                    if (entityID.net.ID == entity.net.ID)
                    {
                        if (!CanLoot)
                        {
                            StopLooting(player, "OnTryLootEntity");
                        }
                        else if (!PlayerAuth.Contains(player.userID))
                        {
                            StopLooting(player, "OnTryLootEntity");
                        }
                    }
                }
            }
        }

        void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (BaseEntityList != null)
            {
                foreach (uint id in BaseEntityList)
                {
                    BaseNetworkable entityID = BaseNetworkable.serverEntities.Find(id);
                    if (entityID.net.ID == entity.net.ID)
                    {
                        if (CanLoot)
                        {
                            if (PlayerAuth.Contains(player.userID))
                            {
                                if (!NowLooted)
                                {
                                    NowLooted = true;
                                    Server.Broadcast($"{ChatPrefix} Игрок {player.displayName} залутал ящик в радиактивном доме. \nДом самоуничтожится через {TimerDestroyHouse} секунд");
                                    mytimer3 = timer.Once(TimerDestroyHouse, () =>
                                    {
                                        DestroyRadHouse();
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }

        private void StopLooting(BasePlayer player, string message)
        {
            NextTick(() => player.EndLooting());
            if (PlayerAuth.Contains(player.userID))
            {
                SendReply(player, $"{ChatPrefix } Вы сможете залутать ящик, через: {mytimer.Delay - timercallbackdelay} секунд");
            }
            else { SendReply(player, $"{ChatPrefix} Вы должны быть авторизованы в шкафу для лута ящика"); }
        }

        object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            var Cupboard = privilege as BuildingPrivlidge;
            var entity = privilege as BaseEntity;
            if (BaseEntityList != null)
            {
                foreach (uint id in BaseEntityList)
                {
                    BaseNetworkable entityID = BaseNetworkable.serverEntities.Find(id);
                    if (entityID.net.ID == entity.net.ID)
                    {
                        if(PlayerAuth.Contains(player.userID))
                        {
                            SendReply(player, $"{ChatPrefix} Вы уже авторизованы в шкафу");
                            return false;
                        }
                        foreach (var authPlayer in BasePlayer.activePlayerList)
                        {
                            if (PlayerAuth.Contains(authPlayer.userID))
                            {
                                SendReply(authPlayer, $"{ChatPrefix} Вас выписал из шкафа игрок {player.displayName}");
                            }
                        }
                        CanLoot = false;
                        PlayerAuth.Clear();
                        timer.Destroy(ref mytimer);
                        timer.Destroy(ref mytimer2);
                        timercallbackdelay = 0;
                        mytimer = timer.Once(TimerLoot, () =>
                        {
                            CanLoot = true;
                            foreach (var authPlayer in BasePlayer.activePlayerList)
                            {
                                if (PlayerAuth.Contains(authPlayer.userID))
                                {
                                    SendReply(authPlayer, $"{ChatPrefix} Ящик разблокирован.");
                                }
                            }
                        });
                        mytimer2 = timer.Repeat(1f, 0, () =>
                        {
                            if (timercallbackdelay >= TimerLoot)
                            {
                                timercallbackdelay = 0;
                                timer.Destroy(ref mytimer2);
                            }
                            else
                            {
                                timercallbackdelay = timercallbackdelay + 1;
                            }
                        });

                        PlayerAuth.Add(player.userID);
                        SendReply(player, $"{ChatPrefix} Через {TimerLoot} секунд вы сможете залутать ящик радиационного дома");
                        return false;
                    }
                }
            }
            return null;
        }
        #endregion

        // GUI Create and Destroy
        #region GUI
        void CreateGui(BasePlayer player)
        {
            if (GuiOn)
            {
                Vector3 pos = (Vector3)success;
                CuiElementContainer Container = new CuiElementContainer();
                CuiElement RadUI = new CuiElement
                {
                    Name = "RadUI",
                    
                    Components = {
                        new CuiImageComponent {
                            Color = ColorCfg
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.644 0.023",
                            AnchorMax = "0.833 0.063",
                        }
                    }
                };

                CuiElement RadText = new CuiElement
                {
                    Name = "RadText",
                    Parent = "HouseUI",
                    Components = {
                        new CuiTextComponent {
                            Text = $"{TextGUI} {pos.ToString()}",
                            Color = "0.76 0.76 0.76 1.00",
                            FontSize = 12,
                            Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf"
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.1 0",
                            AnchorMax = "1 1"
                        }
                    }
                };
                CuiElement HouseUI = new CuiElement
                {
                    Name = "HouseUI",
                    Parent = "RadUI",
                    Components = {
                        new CuiRawImageComponent {
                            Url = "https://i.imgur.com/y9Uaikm.png",
                            Color = "1 1 1 1",

                        },
                        new CuiRectTransformComponent {
                        AnchorMin = "0 0",
                         AnchorMax = "1 1"
                        }
                }
                };
                CuiElement HouseIcon = new CuiElement
                {
                    Name = "HouseIcon",
                    Parent = "RadUI",
                    Components = {
                        new CuiRawImageComponent {
                            Url = "https://i.imgur.com/dXYWqc7.png",
                            Color = "0.56 0.19 0.11 1.00"
                        },
                        new CuiRectTransformComponent {
                        AnchorMin = "0.0 0.0001",
                        AnchorMax = "0.125 0.9999"
                        }
                }
                };
                
                Container.Add(RadUI);
                Container.Add(HouseUI);
                Container.Add(RadText);
               Container.Add(HouseIcon);
               
                CuiHelper.AddUi(player, Container);
            }
        }

        void DestroyGui(BasePlayer player)
        {
            if (GuiOn)
            {
                CuiHelper.DestroyUi(player, "RadUI");
                CuiHelper.DestroyUi(player, "HouseUI");
            }
        }
        #endregion

        #region Radiation Control
        private void InitializeZone(Vector3 Location, float intensity, float radius, int ZoneID)
        {
            if (!ConVar.Server.radiation)
                ConVar.Server.radiation = true;

            var newZone = new GameObject().AddComponent<RadZones>();
            newZone.Activate(Location, radius, intensity, ZoneID);

            ZoneList listEntry = new ZoneList { zone = newZone };
            RadHouseZone = listEntry;
            RadiationZones.Add(listEntry);
        }
        private void DestroyZone(ZoneList zone)
        {
            if (RadiationZones.Contains(zone))
            {
                var index = RadiationZones.FindIndex(a => a.zone == zone.zone);
                UnityEngine.Object.Destroy(RadiationZones[index].zone);
                RadiationZones.Remove(zone);
            }
        }
        public class ZoneList
        {
            public RadZones zone;
        }

        public class RadZones : MonoBehaviour
        {
            private int ID;
            private Vector3 Position;
            private float ZoneRadius;
            private float RadiationAmount;

            private List<BasePlayer> InZone;

            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "NukeZone";

                var rigidbody = gameObject.AddComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
            }

            public void Activate(Vector3 pos, float radius, float amount, int ZoneID)
            {
                ID = ZoneID;
                Position = pos;
                ZoneRadius = radius;
                RadiationAmount = amount;

                gameObject.name = $"RadHouse{ID}";
                transform.position = Position;
                transform.rotation = new Quaternion();
                UpdateCollider();
                gameObject.SetActive(true);
                enabled = true;

                var Rads = gameObject.GetComponent<TriggerRadiation>();
                Rads = Rads ?? gameObject.AddComponent<TriggerRadiation>();
                Rads.RadiationAmountOverride = RadiationAmount;
                Rads.radiationSize = ZoneRadius;
                Rads.interestLayers = playerLayer;
                Rads.enabled = true;

                if (IsInvoking("UpdateTrigger")) CancelInvoke("UpdateTrigger");
                InvokeRepeating("UpdateTrigger", 5f, 5f);
            }

            private void OnDestroy()
            {
                CancelInvoke("UpdateTrigger");
                Destroy(gameObject);
            }

            private void UpdateCollider()
            {
                var sphereCollider = gameObject.GetComponent<SphereCollider>();
                {
                    if (sphereCollider == null)
                    {
                        sphereCollider = gameObject.AddComponent<SphereCollider>();
                        sphereCollider.isTrigger = true;
                    }
                    sphereCollider.radius = ZoneRadius;
                }
            }
            private void UpdateTrigger()
            {
                InZone = new List<BasePlayer>();
                int entities = Physics.OverlapSphereNonAlloc(Position, ZoneRadius, colBuffer, playerLayer);
                for (var i = 0; i < entities; i++)
                {
                    var player = colBuffer[i].GetComponentInParent<BasePlayer>();
                    if (player != null)
                        InZone.Add(player);
                }
            }
        }
        #endregion

    }
}

// --- End of file: RadHouse.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/repair-cost ---
// --- Original File Path: R/RepairCost/RepairCost.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("Repair Cost", "Rustoholics", "0.1.1")]
    [Description("Alter the repair cost of items")]

    public class RepairCost : CovalencePlugin
    {
        #region Dependencies
        
        [PluginReference] 
        private Plugin Economics;
        
        #endregion

        #region Variables
        
        private Dictionary<string,RepairBench> _repairBenches = new Dictionary<string,RepairBench>();
        private Dictionary<string,string> _repairGui = new Dictionary<string,string>();
        private Dictionary<string,ulong> _repairGuiItem = new Dictionary<string,ulong>();
        private Dictionary<string, Timer> _repairTimers = new Dictionary<string, Timer>();
        
        #endregion

        #region Config
        private Configuration _config;
        protected override void SaveConfig() => Config.WriteObject(_config);
        protected override void LoadDefaultConfig() => _config = new Configuration();

        private class Configuration
        {
            
            public Dictionary<string, Dictionary<string, object>> RepairCosts = new Dictionary<string, Dictionary<string, object>>
            {
                {"global", new Dictionary<string, object>
                    {
                        {"enabled", false},
                        {"multiplier", 5.0f},
                        {"items", new Dictionary<string, float>()},
                        {"economics", 0.0d}
                    }
                },
                {"smg.mp5", new Dictionary<string, object>
                    {
                        {"enabled", true},
                        {"multiplier", 6.0f},
                        {
                            "items", new Dictionary<string, float>
                            {
                                {"smgbody", 1.0f}
                            }
                        },
                        {"economics", 100.0d}
                    }
                },
                {"rifle.lr300", new Dictionary<string, object>
                    {
                        {"enabled", true},
                        {"multiplier", 10.0f},
                        {"items", new Dictionary<string, float>()},
                        {"economics", 100.0d}
                    }
                },
                {"pistol.m92", new Dictionary<string, object>
                    {
                        {"enabled", true},
                        {"multiplier", 5.0f},
                        {"items", new Dictionary<string, float>()},
                        {"economics", 100.0d}
                    }
                },
                {"rifle.l96", new Dictionary<string, object>
                    {
                        {"enabled", true},
                        {"multiplier", 10.0f},
                        {"items", new Dictionary<string, float>()},
                        {"economics", 100.0d}
                    }
                },
                {"lmg.m249", new Dictionary<string, object>
                    {
                        {"enabled", true},
                        {"multiplier", 10.0f},
                        {"items", new Dictionary<string, float>()},
                        {"economics", 100.0d}
                    }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();

                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }
        #endregion
        
        #region Language
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotEnoughMaterials"] = "You do not have enough materials to repair this item",
                ["EconomicsRequired"] = " and {0} coins",
                ["NotEnoughCoins"] = "You do not have enough coins to make this repair"
            }, this);
        }
        
        #endregion
        
        #region Hooks
        void CanLootEntity(BasePlayer player, RepairBench container)
        {
            _repairBenches[player.UserIDString] = container;
        }
        
        void OnLootEntityEnd(BasePlayer player, RepairBench container)
        {
            if (_repairTimers.ContainsKey(player.UserIDString))
            {
                _repairTimers[player.UserIDString].Destroy();
                _repairTimers.Remove(player.UserIDString);
            }

            CloseGui(player);
            if (_repairBenches.ContainsKey(player.UserIDString))
            {
                _repairBenches.Remove(player.UserIDString);
            }
        }
        void OnLootEntity(BasePlayer player, RepairBench container)
        {
            CheckAndPresentGui(player, container);
        }
        
        object OnItemRepair(BasePlayer player, Item itemToRepair)
        {
            if (!IsCustomRepairItem(itemToRepair))
            {
                return null;
            }
            
            RepairBench repairBenchEntity = _repairBenches[player.UserIDString];

            var list = RepairList(player, itemToRepair);
            
            var economicsRequired = EconomicsRequired(itemToRepair);

            if (!PlayerHasEnough(player, list, economicsRequired))
            {
                player.ChatMessage(Lang("NotEnoughMaterials", player.UserIDString));
                return true;
            }
            
            if (Economics != null && economicsRequired > 0)
            {
                if (!Economics.Call<bool>("Withdraw", player.UserIDString, economicsRequired))
                {
                    player.ChatMessage(Lang("NotEnoughCoins", player.UserIDString));
                    return true;             
                }
            }
            
            foreach (ItemAmount itemAmount in list)
            {
                player.inventory.Take((List<Item>) null, itemAmount.itemid, (int)itemAmount.amount);
            }
            

            Facepunch.Pool.FreeList<ItemAmount>(ref list);
            itemToRepair.DoRepair(0.2f);
            
            if (Global.developer > 0)
                Debug.Log((object) ("Item repaired! condition : " + (object) itemToRepair.condition + "/" + (object) itemToRepair.maxCondition));
            Effect.server.Run("assets/bundled/prefabs/fx/repairbench/itemrepair.prefab", repairBenchEntity, 0U, Vector3.zero, Vector3.zero);
            return true;
        }
        
        // Remove any open GUIs on unloading the plugin, to avoid stuck GUIs
        void Unload()
        {
            foreach (var userIdString in _repairGui.Keys.ToArray())
            {
                var player = BasePlayer.FindByID(Convert.ToUInt64(userIdString));
                if (player != null && player.IsConnected)
                {
                    CloseGui(player);
                }
            }
        }
        
        void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            NextTick(() =>
            {
                if (item == null || container == null)
                {
                    return;
                }

                BasePlayer player;

                if (container.entityOwner != null && container.entityOwner is RepairBench)
                {
                    if (item.GetOwnerPlayer() == null) return;
                    
                    // Check if bench is empty
                    if (container.itemList.Count == 0)
                    {
                        player = item.GetOwnerPlayer();
                        CloseGui(player);
                    }

                    return;
                }

                if (item.GetRootContainer() == null) return;
                
                if (!(item.GetRootContainer().entityOwner is RepairBench)) return;
                
                if (container.GetOwnerPlayer() == null) return;
                
                player = container.GetOwnerPlayer();
                CheckAndPresentGui(player, (RepairBench)item.GetRootContainer().entityOwner);
            });
        }
        
        #endregion
        
        #region GUI

        void CheckAndPresentGui(BasePlayer player, RepairBench container)
        {
            var item = container.inventory.GetSlot(0);
            if (item != null && UseCustomRepairGui(item, player))
            {
                // Check if Repair GUI is already open
                if (!_repairGui.ContainsKey(player.UserIDString))
                {
                    WriteGui(player, item); // It's not open so write it
                }else if(_repairGuiItem[player.UserIDString] != item.uid)
                {
                    CloseGui(player); // It's open but for a different item, so close that GUI and open a new one
                    WriteGui(player, item);
                }
            }
            else
            {
                CloseGui(player);
            }
        }

        bool UseCustomRepairGui(Item item, BasePlayer player)
        {
            if (!IsCustomRepairItem(item))
            {
                return false;
            }
            ItemDefinition targetItem = (UnityEngine.Object) item.info.isRedirectOf != (UnityEngine.Object) null ? item.info.isRedirectOf : item.info;
            if ((player.blueprints.HasUnlocked(targetItem) ? 1 : (!((UnityEngine.Object) targetItem.Blueprint != (UnityEngine.Object) null) ? 0 : (!targetItem.Blueprint.isResearchable ? 1 : 0))) == 0)
                return false;
            
            if (!item.info.condition.repairable || item.condition.Equals(item.maxCondition))
            {
                return false;
            }

            return true;
        }
        
        void WriteGui(BasePlayer player, Item itemToRepair)
        {
            var list = RepairList(player, itemToRepair);
            var economicsRequired = EconomicsRequired(itemToRepair);
            if (list == null)
            {
                return;
            }
            var panel = new CuiPanel();
            if (itemToRepair.info.HasSkins)
            {
                panel.RectTransform.AnchorMin = "0.5 0";
                panel.RectTransform.AnchorMax = "0.5 0";
                panel.RectTransform.OffsetMin = "326 343";
                panel.RectTransform.OffsetMax = "564 413";
            }
            else
            {
                panel.RectTransform.AnchorMin = "0.5 0";
                panel.RectTransform.AnchorMax = "0.5 0";
                panel.RectTransform.OffsetMin = "326 179";
                panel.RectTransform.OffsetMax = "564 249";
            }

            panel.Image.Color = "0.25 0.24 0.22 1.0";

            var text = new CuiLabel();
            text.Text.Color = "1.0 1.0 1.0 1.0";
            if (!PlayerHasEnough(player, list, economicsRequired))
            {
                text.Text.Color = "0.73 0.4 0.29 1.0";
            }
            text.Text.Align = TextAnchor.MiddleCenter;
            text.Text.FontSize = 12;
            text.Text.Font = "RobotoCondensed-Regular.ttf";
            text.Text.Text = "Repair cost: ";

            var n = 0;
            foreach (var i in list)
            {
                if (n > 0)
                {
                    text.Text.Text += ", ";
                }

                text.Text.Text += Convert.ToString(i.amount) + " " + i.itemDef.displayName.english;
                n++;
            }

            if (economicsRequired > 0)
            {
                text.Text.Text += Lang("EconomicsRequired", player.UserIDString, economicsRequired);
            }

            var container = new CuiElementContainer();
            var menu = container.Add(panel, "Overlay");
            
            if (_repairGui.ContainsKey(player.UserIDString))
            {
                return; // Final check to make sure this player doesn't have a GUI already
            }
            container.Add(text, menu, "RepairText");
            _repairGui[player.UserIDString] = menu;
            _repairGuiItem[player.UserIDString] = itemToRepair.uid;
            
            CuiHelper.AddUi(player, container);
        }

        void CloseGui(BasePlayer player)
        {
            if (!_repairGui.ContainsKey(player.UserIDString))
            {
                return;
            }
            CuiHelper.DestroyUi(player, _repairGui[player.UserIDString]);
            _repairGui.Remove(player.UserIDString);
            _repairGuiItem.Remove(player.UserIDString);
        }
        
        #endregion
        
        #region Repair Items List and Amount Modifiers
        private List<ItemAmount> RepairList(BasePlayer player, Item itemToRepair)
        {
            ItemDefinition info = itemToRepair.info;
            ItemBlueprint component = info.GetComponent<ItemBlueprint>();
            
            List<ItemAmount> list = Facepunch.Pool.GetList<ItemAmount>();
            RepairBench.GetRepairCostList(component, list);

            return ApplyItemListMultiplier(list, itemToRepair);
        }

        private List<ItemAmount> ApplyItemListMultiplier(List<ItemAmount> list, Item itemToRepair)
        {
            List<ItemAmount> newlist = new List<ItemAmount>();
            var repairCostFraction = RepairBench.RepairCostFraction(itemToRepair);
            float multiplier = 1;

            if (_config.RepairCosts.ContainsKey(itemToRepair.info.shortname) && _config.RepairCosts[itemToRepair.info.shortname].ContainsKey("multiplier"))
            {
                multiplier = Convert.ToSingle(_config.RepairCosts[itemToRepair.info.shortname]["multiplier"]);
            }
            else if(_config.RepairCosts.ContainsKey("global") && _config.RepairCosts["global"].ContainsKey("enabled") && (bool)_config.RepairCosts["global"]["enabled"] && _config.RepairCosts["global"].ContainsKey("multiplier"))
            {
                multiplier = Convert.ToSingle(_config.RepairCosts["global"]["multiplier"]);
            }

            foreach (ItemAmount itemAmount in list)
            {
                if (itemAmount.itemDef.category != ItemCategory.Component)
                {
                    itemAmount.amount = Mathf.CeilToInt(itemAmount.amount * repairCostFraction * multiplier);
                    newlist.Add(itemAmount);
                }
            }

            // Add any extra items
            if (_config.RepairCosts[itemToRepair.info.shortname].ContainsKey("items"))
            {
                var items = (IEnumerable)_config.RepairCosts[itemToRepair.info.shortname]["items"];
                var json = JsonConvert.SerializeObject(items);
                var dictionary = JsonConvert.DeserializeObject<Dictionary<string, float>>(json);
                foreach (var customItem in dictionary)
                {
                    var itemDefinition = ItemManager.FindItemDefinition(customItem.Key);
                    if (itemDefinition == null) // Could not find an item definition matching this key, skip it
                    {
                        continue;
                    }

                    var isNew = true;
                    foreach (var newItem in newlist)
                    {
                        // The item is already in the list, so override it
                        if (newItem.itemid == itemDefinition.itemid)
                        {
                            newItem.amount =  Mathf.CeilToInt(Convert.ToSingle(customItem.Value));
                            isNew = false;
                            break;
                        }
                    }

                    if (isNew)
                    {
                        newlist.Add(new ItemAmount(itemDefinition, customItem.Value));
                    }
                }
            }
            
            Facepunch.Pool.FreeList<ItemAmount>(ref list);
            
            return newlist;
        }
        
        #endregion

        #region Checking Functions
        bool IsCustomRepairItem(Item item)
        {
            if (_config.RepairCosts.ContainsKey(item.info.shortname) && _config.RepairCosts[item.info.shortname].ContainsKey("enabled"))
            {
                return (bool)_config.RepairCosts[item.info.shortname]["enabled"];
            }
            if (_config.RepairCosts.ContainsKey("global") && _config.RepairCosts["global"].ContainsKey("enabled"))
            {
                return (bool)_config.RepairCosts["global"]["enabled"];
            }

            return false;
        }

        bool PlayerHasEnough(BasePlayer player, List<ItemAmount> list, double economics=0d)
        {
            foreach (ItemAmount itemAmount in list)
            {
            
                int amount = player.inventory.GetAmount(itemAmount.itemDef.itemid);
                if (itemAmount.amount > amount)
                {
                    return false;
                }
            }

            if (Economics != null && economics > 0)
            {
                if (Economics.Call<double>("Balance", player.UserIDString) < economics)
                {
                    return false;
                }
            }

            return true;
        }

        double EconomicsRequired(Item item)
        {
            if (Economics == null)
            {
                return 0d;
            }
            if (_config.RepairCosts.ContainsKey(item.info.shortname) &&
                _config.RepairCosts[item.info.shortname].ContainsKey("enabled") && 
                _config.RepairCosts[item.info.shortname].ContainsKey("economics") &&
                Convert.ToDouble(_config.RepairCosts[item.info.shortname]["economics"]) > 0)
            {
                return Convert.ToDouble(_config.RepairCosts[item.info.shortname]["economics"]);
            }
            if (_config.RepairCosts.ContainsKey("global") &&
                      _config.RepairCosts["global"].ContainsKey("economics") &&
                      Convert.ToDouble(_config.RepairCosts["global"]["economics"]) > 0)
            {
                return Convert.ToDouble(_config.RepairCosts["global"]["economics"]);
            }
            return 0d;
        }
        
        #endregion
        
    }
}

// --- End of file: RepairCost.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/remove-animals-ai ---
// --- Original File Path: R/RemoveAnimalsAI/RemoveAnimalsAI.cs ---

using HarmonyLib;
using Oxide.Core.Plugins;
using Rust.Ai.Gen2;
using static Rust.Ai.Gen2.FSMComponent;

namespace Oxide.Plugins
{
    [Info("Remove Animals AI", "Whipers88 @CobaltStudios", "1.1.1")]
    [Description("Removing AI only for animals (not for bots)")]
    public class RemoveAnimalsAI : RustPlugin
    {
        private void Init()
        {
            FSMComponent.workQueue.Clear();
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                if (entity is BaseNPC2)
                {
                    entity.Kill();
                }
                if(entity is BaseAnimalNPC baseAnimalNPC)
                {
                    if(baseAnimalNPC.HasBrain && baseAnimalNPC.TryGetComponent<BaseAIBrain>(out BaseAIBrain baseAIBrain))
                    {
                        UnityEngine.Object.Destroy(baseAIBrain);
                    }
                }
            }
        }

        [HarmonyPatch(typeof(BaseNpc), nameof(BaseNpc.TickAi)), AutoPatch]
        public static class TickAiPatch
        {
            [HarmonyPrefix]
            private static bool Prefix()
            {
                return false;
            }
        }
        [HarmonyPatch(typeof(LimitedTurnNavAgent), nameof(LimitedTurnNavAgent.TickSteering)), AutoPatch]
        public static class TickSteeringPatch
        {
            [HarmonyPrefix]
            private static bool Prefix()
            {
                return false;
            }
        }

        [HarmonyPatch(typeof(TickFSMWorkQueue), "RunJob"), AutoPatch]
        public static class RunJobPatch
        {
            [HarmonyPrefix]
            private static bool Prefix(FSMComponent component)
            {
                if (component == null)
                    return false;

                if (!component.enabled)
                    return false;

                if (component._baseEntity?.Health() != 0)
                {
                    return false;
                }
                component.Tick();
                FSMComponent.workQueue.Remove(component);
                return false;
            }
        }

        [HarmonyPatch(typeof(AIThinkManager), nameof(AIThinkManager.ProcessQueue)), AutoPatch]
        public static class ProcessQueuePatch
        {
            [HarmonyPrefix]
            private static bool Prefix(AIThinkManager.QueueType queueType)
            {
                if (queueType == AIThinkManager.QueueType.Animal)
                {
                    return false;
                }
                return true;
            }
        }

        [HarmonyPatch(typeof(AnimalBrain), nameof(AnimalBrain.InitializeAI)), AutoPatch]
        public static class InitializeAIPatch
        {
            [HarmonyPrefix]
            private static bool Prefix(BaseAIBrain __instance)
            {
                return false;
            }
        }

    }
}

// --- End of file: RemoveAnimalsAI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/reset-code-locks ---
// --- Original File Path: R/ResetCodeLocks/ResetCodeLocks.cs ---

﻿using System.Linq;
using System.Reflection;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("ResetCodeLocks", "Absolut", "1.0.2", ResourceId = 2348)]

    class ResetCodeLocks : RustPlugin
    {
        private FieldInfo CurrentCode;
        private FieldInfo CurrentGuestCode;
        private FieldInfo CodeLockWhiteList;
        private FieldInfo hasCode;
        private FieldInfo hasGuestCode;

        string TitleColor = "<color=orange>";
        string MsgColor = "<color=#A9A9A9>";

        void Loaded()
        {
            CurrentCode = typeof(CodeLock).GetField("code", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            CurrentGuestCode = typeof(CodeLock).GetField("guestCode", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            CodeLockWhiteList = typeof(CodeLock).GetField("whitelistPlayers", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            hasCode = typeof(CodeLock).GetField("hasCode", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            hasGuestCode = typeof(CodeLock).GetField("hasGuestCode", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            lang.RegisterMessages(messages, this);
            permission.RegisterPermission(this.Name + ".allow", this);
        }

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "ResetCodeLocks: " },
            {"Instructions", "Commands For ResetCodeLocks:\n/code main '4 digit code' ---> Resets the code on all your CodeLocks to the code given\n/code guest '4 digit code' ---> Resets the guest code on all your CodeLocks to the code given\n--------------------\nExamples: /code guest 1234\n/code main 1234"},
            {"CodeLength", "The code must be 4 digits long. Example: 1234" },
            {"NoCodeLocksFound", "No code locks found!" },
            {"NumberCodeLocksReset", "You reset the code on {0} CodeLocks" },
            {"NoPerm", "You do not have permission to use this command" },
        };

        [ChatCommand("code")]
        private void chatcod(BasePlayer player, string cmd, string[] args)
        {
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, this.Name + ".allow"))
            {
                GetSendMSG(player, "NoPerm");
                return;
            }
            if (args == null || args.Length < 2)
            {
                GetSendMSG(player, "Instructions");
                return;
            }
            int code;
            if (!int.TryParse(args[1], out code))
            {
                GetSendMSG(player, "Instructions");
                return;
            }
            if (args[1].Length != 4)
            {
                GetSendMSG(player, "CodeLength");
                return;
            }
            switch (args[0].ToLower())
            {
                case "main":
                    PlayerSetLocks(player, code.ToString());
                    break;
                case "guest":
                    PlayerSetLocks(player, code.ToString(), true);
                    break;
                default:
                    GetSendMSG(player, "Instructions");
                    return;
            }
        }
        private void GetSendMSG(BasePlayer player, string message, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            string msg = string.Format(lang.GetMessage(message, this, player.UserIDString), arg1, arg2, arg3);
            SendReply(player, TitleColor + lang.GetMessage("title", this, player.UserIDString) + "</color>" + MsgColor + msg + "</color>");
        }

        private void PlayerSetLocks(BasePlayer player, string code, bool guest = false)
        {
            bool HasLocks = false;
            int num = 0;
            foreach (var entry in UnityEngine.Object.FindObjectsOfType<BaseEntity>().Where(k => k.GetSlot(BaseEntity.Slot.Lock) != null && (k.OwnerID == player.userID || (player.IsAdmin && k.OwnerID == 0))))
            {
                BaseEntity lockSlot = entry.GetSlot(BaseEntity.Slot.Lock);
                CodeLock codelock = lockSlot?.GetComponent<CodeLock>();
                if (codelock != null)
                {
                    HasLocks = true;
                    if (guest)
                    {
                        CurrentGuestCode.SetValue(codelock, code);
                        hasGuestCode.SetValue(codelock, true);
                        hasCode.SetValue(codelock, true);
                    }
                    else
                    {
                        CurrentCode.SetValue(codelock, code);
                        hasGuestCode.SetValue(codelock, true);
                        hasCode.SetValue(codelock, true);
                        List<ulong> whitelisted = CodeLockWhiteList.GetValue(codelock) as List<ulong>;
                        if (!whitelisted.Contains(player.userID))
                            whitelisted.Add(player.userID);
                        CodeLockWhiteList.SetValue(codelock, whitelisted);
                        codelock.SetFlag(BaseEntity.Flags.Locked, true);
                    }
                    num++;
                }
            }
            if (!HasLocks)
                GetSendMSG(player, "NoCodeLocksFound");
            else
                GetSendMSG(player, "NumberCodeLocksReset", num.ToString());
        }
    }
}

// --- End of file: ResetCodeLocks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/real-time-chat ---
// --- Original File Path: R/RealTimeChat/RealTimeChat.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{        
    [Info("Real Time Chat", "The Friendly Chap", "1.0.2")]
    [Description("Returns the server real time in chat.")]
    public class RealTimeChat : RustPlugin
    {
        #region Language
        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TimeMessage"] = "The server's local time is: ",
            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TimeMessage"] = "Местное время сервера: ",
            }, this, "ru");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TimeMessage"] = "L'heure locale du serveur est: ",
            }, this, "fr");
        }
        #endregion Language
        #region Commands
        [ChatCommand("time")]
        void RealTimeCommand(BasePlayer player)
        {
            PrintToChat(player, lang.GetMessage("TimeMessage", this, player.UserIDString) + DateTime.Now.ToString("hh:mm") + " " + DateTime.Now.ToString("tt"));
        }
        #endregion Commands
        #region Hooks
        void Init()
        {
            LoadDefaultMessages();
        }
        #endregion Hooks
    }
}

// --- End of file: RealTimeChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rust-map-api ---
// --- Original File Path: R/RustMapApi/RustMapApi.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using Facepunch.Utility;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;
using UnityEngine.Networking;
using Color = UnityEngine.Color;

namespace Oxide.Plugins
{
    [Info("Rust Map Api", "MJSU", "1.3.2")]
    [Description("An API to generate the rust server map image")]
    internal class RustMapApi : RustPlugin
    {
        #region Class Fields

        [PluginReference] private Plugin ImgurApi;
        
        private PluginConfig _pluginConfig; //Plugin Config
        private StoredData _storedData;
        
        private TerrainTexturing _terrainTexture;
        private Terrain _terrain;
        private TerrainHeightMap _heightMap;
        private TerrainSplatMap _splatMap;
        
        private readonly Hash<string, RenderInfo> _renders = new Hash<string, RenderInfo>();
        private readonly Hash<string, Hash<string, Hash<string, Hash<string, object>>>> _imageCache = new Hash<string, Hash<string, Hash<string, Hash<string, object>>>>();
        private List<Hash<string, object>> _iconOverlay;
        
        private enum EncodingMode {Jpg = 1, Png = 2}
        private enum MapColorsVersion {Version1, Current}

        private bool _isReady;

        private Coroutine _storeImageRoutine;
        private readonly Queue<StorageInfo> _storageQueue = new Queue<StorageInfo>();
        
        private const string DefaultMapName = "Default";
        private const string IconMapName = "Icons";
        
        private readonly Hash<MapColorsVersion, MapColors> _mapColorVersions = new Hash<MapColorsVersion, MapColors>
        {
            //Map colors before the 10/2020 update
            [MapColorsVersion.Version1] = new MapColors
            {
                StartColor = new Vector3(0.324313372f, 0.397058845f, 0.195609868f),
                WaterColor = new Vector4(0.269668937f, 0.4205476f, 0.5660378f, 1f),
                GravelColor = new Vector4(0.139705867f, 0.132621378f, 0.114024632f, 0.372f),
                DirtColor = new Vector4(0.322227329f, 0.375f, 0.228860289f, 1f),
                SandColor = new Vector4(1f, 0.8250507f, 0.448529422f, 1f),
                GrassColor = new Vector4(0.4509804f, 0.5529412f, 0.270588249f, 1f),
                ForestColor = new Vector4(0.5529412f, 0.440000027f, 0.270588249f, 1f),
                RockColor = new Vector4(0.42344287f, 0.4852941f, 0.314013839f, 1f),
                SnowColor = new Vector4(0.8088235f, 0.8088235f, 0.8088235f, 1f),
                PebbleColor = new Vector4(0.121568628f, 0.419607848f, 0.627451f, 1f),
                OffShoreColor = new Vector4(0.166295841f, 0.259337664f, 0.3490566f, 1f),
                SunDirection = Vector3.Normalize(new Vector3(0.95f, 2.87f, 2.37f)),
                Half = new Vector3(0.5f, 0.5f, 0.5f),
                SunPower = 0.5f,
                Brightness = 1f,
                Contrast = 0.87f,
                OceanWaterLevel = 0
            },

            //Current map colors
            [MapColorsVersion.Current] = new MapColors
            {
                StartColor = new Vector3(0.286274523f, 0.270588249f, 0.247058839f),
                WaterColor = new Vector4(0.16941601f, 0.317557573f, 0.362000018f, 1f),
                GravelColor = new Vector4(0.25f, 0.243421048f, 0.220394745f, 1f),
                DirtColor = new Vector4(0.6f, 0.479594618f, 0.33f, 1f),
                SandColor = new Vector4(0.7f, 0.65968585f, 0.5277487f, 1f),
                GrassColor = new Vector4(0.354863644f, 0.37f, 0.2035f, 1f),
                ForestColor = new Vector4(0.248437509f, 0.3f, 0.0703125f, 1f),
                RockColor = new Vector4(0.4f, 0.393798441f, 0.375193775f, 1f),
                SnowColor = new Vector4(0.862745166f, 0.9294118f, 0.941176534f, 1f),
                PebbleColor = new Vector4(0.137254909f, 0.2784314f, 0.2761563f, 1f),
                OffShoreColor = new Vector4(0.04090196f, 0.220600322f, 0.274509817f, 1f),
                SunDirection = Vector3.Normalize(new Vector3(0.95f, 2.87f, 2.37f)),
                Half = new Vector3(0.5f, 0.5f, 0.5f),
                SunPower = 0.65f,
                Brightness = 1.05f,
                Contrast = 0.94f,
                OceanWaterLevel = 0.0f
            }
        };
        
        private readonly Hash<string, IconConfig> _defaultIcons = new Hash<string, IconConfig>
            {
                ["Harbor"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/ND4c70v.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Giant Excavator Pit"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/hmUKFwS.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Junkyard"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/V8D4ZGc.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Launch Site"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/gjdynsc.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Water Treatment Plant"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/5L2Gdag.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Military Tunnel"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/6RwXvC2.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Airfield"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/KhQXhIs.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Power Plant"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/ZxqiBc6.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Train Yard"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/wVifXqr.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Outpost"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/hb7JZ9i.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Bandit Camp"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/cIR4YOt.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Sewer Branch"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/PbKZQdZ.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["HQM Quarry"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/bGFogbM.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Satellite Dish"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/XwSpCJY.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["The Dome"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/mPRgBF2.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Sulfur Quarry"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/bGFogbM.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Stone Quarry"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/bGFogbM.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Power Sub Station"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/LQUknms.png",
                    Width = 60,
                    Height = 60,
                    Show = false
                },
                ["Water Well"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/TASWRD0.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Abandoned Cabins"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/xigwDcW.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Wild Swamp"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/2tcTYKA.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Abandoned Supermarket"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/ZyP2W9F.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Mining Outpost"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/C0acqvj.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Oxum's Gas Station"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/oW1bDdF.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Cave"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/ByKJj9C.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Lighthouse"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/r5vbzhm.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Large Oil Rig"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/AAhZO7k.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Oil Rig"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/AAhZO7k.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Fishing Village"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/7UCs5BO.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Large Fishing Village"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/7UCs5BO.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Ranch"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/VQjSjzA.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
                ["Large Barn"] = new IconConfig
                {
                    ImageUrl = "https://i.imgur.com/VQjSjzA.png",
                    Width = 60,
                    Height = 60,
                    Show = true
                },
            };
        #endregion

        #region Setup & Loading

        private void Init()
        {
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.StartingSplits = config.StartingSplits ?? new List<string>
            {
                "2x2"
            };

            config.IconSettings = config.IconSettings ?? _defaultIcons;
            
            config.CustomIcons = config.CustomIcons ?? new List<CustomIcons>
            {
                new CustomIcons
                {
                    Height = 200,
                    Width = 200,
                    ImageUrl = "https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png",
                    Show = false,
                    XPos = 0,
                    ZPos = 0
                }
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _terrainTexture = TerrainTexturing.Instance;
            if (_terrainTexture == null)
            {
                return;
            }
                
            _terrain = _terrainTexture.GetComponent<Terrain>();
            _heightMap = _terrainTexture.GetComponent<TerrainHeightMap>();
            if (_heightMap == null)
            {
                return;
            }
            
            _splatMap = _terrainTexture.GetComponent<TerrainSplatMap>();
            if (_splatMap == null)
            {
                return;
            }

            InvokeHandler.Instance.StartCoroutine(CreateStartupImages());
        }
        
        private IEnumerator CreateStartupImages()
        {
            yield return ValidateImages();
            yield return ValidateConfig();
            yield return LoadIcons();
            yield return CreateStartingRenders();
            yield return CreateStartupSplits();
            
            _isReady = true;
            Interface.Call("OnRustMapApiReady");
            SaveData();
        }

        private void OnNewSave(string filename)
        {
            _storedData = new StoredData();
        }

        private void Unload()
        {
            SaveData();
        }
        #endregion

        #region Handle Startup

        private IEnumerator ValidateImages()
        {
            Puts("Validating existing images");
            foreach (KeyValuePair<string,Hash<string,Hash<string,uint>>> maps in _storedData.MapIds.ToList())
            {
                foreach (KeyValuePair<string, Hash<string, uint>> split in maps.Value.ToList())
                {
                    bool remove = false;
                    foreach (KeyValuePair<string, uint> section in split.Value)
                    {
                        byte[] data = FileStorage.server.Get(section.Value, FileStorage.Type.jpg, CommunityEntity.ServerInstance.net.ID);
                        if (data == null)
                        {
                            remove = true;
                        }
                        
                        yield return null;
                    }

                    if (remove)
                    {
                        Puts($"{maps.Key} {split.Key} not found removing");
                        _storedData.MapIds[maps.Key].Remove(split.Key);
                    }
                }
            }

            foreach (KeyValuePair<int,uint> icons in _storedData.IconIds.ToList())
            {
                byte[] data = FileStorage.server.Get(icons.Value, FileStorage.Type.jpg, CommunityEntity.ServerInstance.net.ID);
                if (data == null)
                {
                    _storedData.IconIds.Remove(icons.Key);
                }
                
                yield return null;
            }
        }

        private IEnumerator ValidateConfig()
        {
            Puts("Validating config has latest monuments");
            bool changed = false;
            if (TerrainMeta.Path != null && TerrainMeta.Path.Monuments != null)
            {
                foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
                {
                    yield return null;
                    string name = GetMonumentName(monument);

                    IconConfig config = _pluginConfig.IconSettings[name];
                    if (config == null)
                    {
                        config = new IconConfig
                        {
                            Height = 90,
                            Width = 90,
                            Show = false,
                            ImageUrl = string.Empty
                        };
                        _pluginConfig.IconSettings[name] = config;
                        changed = true;
                    }

                    if (string.IsNullOrEmpty(config.ImageUrl))
                    {
                        var defaultValue = _defaultIcons[name];
                        if (defaultValue != null)
                        {
                            config.ImageUrl = defaultValue.ImageUrl;
                            config.Show = true;
                            changed = true;
                        }
                    }
                }
            }

            if (changed)
            {
                Config.WriteObject(_pluginConfig);
            }
        }

        private IEnumerator LoadIcons()
        {
            foreach (IconConfig icon in _pluginConfig.IconSettings.Values)
            {
                if (!icon.Show || string.IsNullOrEmpty(icon.ImageUrl))
                {
                    continue;
                }
                
                yield return LoadIcon(icon);
                yield return null;
            }

            foreach (CustomIcons icon in _pluginConfig.CustomIcons)
            {
                if (!icon.Show || string.IsNullOrEmpty(icon.ImageUrl))
                {
                    continue;
                }
                
                yield return LoadIcon(icon);
                yield return null;
            }
            
            Puts("Loaded image icons");
        }

        private IEnumerator CreateStartingRenders()
        {
            Stopwatch sw = Stopwatch.StartNew();
            
            ImageConfig config = new ImageConfig(GetDefaultColors());
            Array2D<Color> render = Render(config, GetDefaultResolution());
            sw.Stop();
            if (render.IsEmpty())
            {
                PrintError("Failed to generate map render");
                yield break;
            }

            _renders[DefaultMapName] = new RenderInfo(render, config);
            Puts($"Map Render Took: {GetDuration(sw.ElapsedMilliseconds)}");
            
            yield return new WaitForSeconds(.1f);
            
            sw.Restart();
            _iconOverlay = BuildIconMonuments(render.Height);
            List<OverlayConfig> overlayConfig = _iconOverlay.Select(o => new OverlayConfig(o)).ToList();
            render = RenderOverlay(render, overlayConfig);
            sw.Stop();
            
            if (render.IsEmpty())
            {
                PrintError("Failed to generate icon render");
                yield break;
            }

            _renders[IconMapName] = new RenderInfo(render, config, overlayConfig);
            
            Puts($"Icon Render Took: {GetDuration(sw.ElapsedMilliseconds)}");
        }

        private IEnumerator CreateStartupSplits()
        {
            yield return new WaitForSeconds(.1f);

            if (!HasSplit(DefaultMapName, 1, 1))
            { 
                SaveSingleImage(DefaultMapName);
                yield return new WaitForSeconds(.1f);
            }

            if (!HasSplit(IconMapName, 1, 1))
            { 
                SaveSingleImage(IconMapName);
                yield return new WaitForSeconds(.1f);
            }

            foreach (string splitText in _pluginConfig.StartingSplits)
            {
                if (!splitText.ToLower().Contains("x"))
                {
                    PrintError($"split {splitText} does not contain an x");
                    continue;
                }

                string[] splits = splitText.Split('x', 'X');
                if (splits.Length < 2)
                {
                    PrintError($"split {splitText} is not valid. Format should be 2x2 for 2 rows x 2 columns");
                    continue;
                }

                int row;
                if (!int.TryParse(splits[0], out row))
                {
                    PrintError($"Row of {splits[0]} is not a valid number");
                    continue;
                }
                
                int col;
                if (!int.TryParse(splits[1], out col))
                {
                    PrintError($"Column of {splits[1]} is not a valid number");
                    continue;
                }
                
                if (!HasSplit(DefaultMapName, row, col))
                {
                    SaveSplitImage(DefaultMapName, row, col);
                    yield return new WaitForSeconds(.1f);
                }

                if (!HasSplit(IconMapName, row, col))
                {
                    SaveSplitImage(IconMapName, row, col);
                    yield return new WaitForSeconds(.1f);
                }
            }
                
            yield return new WaitForSeconds(1f);
        }
        #endregion

        #region Console Command
        [ConsoleCommand("rma_regenerate")]
        private void RegenerateConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
            {
                return;
            }

            InvokeHandler.Instance.StartCoroutine(HandleRegenerate(arg));
        }

        private IEnumerator HandleRegenerate(ConsoleSystem.Arg arg)
        {
            Puts("Removing maps from file storage");   
            foreach (Hash<string, Hash<string, uint>> maps in _storedData.MapIds.Values)
            {
                foreach (Hash<string,uint> split in maps.Values)
                {
                    foreach (uint section in split.Values)
                    {
                        FileStorage.server.Remove(section, FileStorage.Type.jpg, CommunityEntity.ServerInstance.net.ID);
                        yield return null;
                    }
                }
            }

            Puts("Removing Icons from file storage");   
            foreach (uint icon in _storedData.IconIds.Values)
            {
                FileStorage.server.Remove(icon, FileStorage.Type.jpg, CommunityEntity.ServerInstance.net.ID);
                yield return null;
            }
            
            Puts("Wiping stored data");   
            _storedData = new StoredData();

            Puts("Regenerating images");
            yield return CreateStartupImages();
        }
        
        [ConsoleCommand("rma_upload")]
        private void UploadConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
            {
                return;
            }

            if (ImgurApi == null)
            {
                PrintWarning("Cannot upload missing plugin dependency ImgurApi: https://umod.org/plugins/imgur-api");
                return;
            }

            if (arg.Args == null || arg.Args.Length < 1)
            {
                arg.ReplyWith("Invalid Syntax. rma_upload <mapName> <resolution:optional> <numRows:optional> <numCols:optional>\nEx: rma_upload default 2000 1 1 - to upload an image with a resolution of 2000x2000 and split into a 1x1 square to imgur");
                return;
            }

            string mapName = _renders.Keys.FirstOrDefault(k =>
                k.Equals(arg.GetString(0), StringComparison.InvariantCultureIgnoreCase));
            if (string.IsNullOrEmpty(mapName))
            {
                arg.ReplyWith($"Map name does not exist. Valid map names are {string.Join(", ", _renders.Keys.ToArray())}");
                return;
            }

            int defaultResolution = GetDefaultResolution();
            int resolution = arg.GetInt(1, defaultResolution);
            int numRows = arg.GetInt(2, 1);
            int numCols = arg.GetInt(3, 1);
            
            if (numRows < 1)
            {
                arg.ReplyWith($"Invalid number of rows: {arg.Args[1]}");
                return;
            }

            if (numRows > 64)
            {
                arg.ReplyWith($"Num rows cannot be > 64: {arg.Args[1]}");
                return;
            }

            if (numCols < 1)
            {
                arg.ReplyWith($"Invalid number of columns: {arg.Args[2]}");
                return;
            }
            
            if (numCols > 64)
            {
                arg.ReplyWith($"Num cols cannot be > 64: {arg.Args[2]}");
                return;
            }

            if (resolution < 1)
            {
                arg.ReplyWith($"Invalid resolution: {arg.Args[3]}");
                return;
            }

            NextTick(() =>
            {
                Array2D<Color> render = new Array2D<Color>();
                if (resolution != defaultResolution)
                {
                    Stopwatch sw = Stopwatch.StartNew();
                    RenderInfo info = _renders[mapName];

                    render = Render(info.RenderConfig, resolution);
                    if (info.OverlayConfig != null)
                    {
                        List<Hash<string, object>> monuments = BuildIconMonuments(resolution);
                        render = RenderOverlay(render, monuments.Select(m => new OverlayConfig(m)).ToList());
                    }
                    sw.Stop();
                    Puts($"Upload render took: {GetDuration(sw.ElapsedMilliseconds)}");
                }

                if (numRows == 1 && numCols == 1)
                {
                    Hash<string, object> map = resolution != defaultResolution ? CreateSingle(render, _pluginConfig.DefaultImageEncoding)[GetIndex(0, 0)] : GetFullMap(mapName);
                    string title = GetImageTitle(mapName, numRows, numCols);
                    UploadSingle(map, title, HandleSingleResponse);
                    Puts("Uploading to imgur");
                }
                else
                {
                    Hash<string, Hash<string, object>> map = resolution != defaultResolution ? CreateSplice(render, numRows, numCols, _pluginConfig.DefaultImageEncoding) : GetSplit(mapName, numRows, numCols);
                    string albumTitle = GetImageTitle(mapName, numRows, numCols);
                    UploadAlbum(map, albumTitle, mapName, HandleAlbumResponse);
                    Puts("Uploading to imgur album");
                }
            });
        }

        private string GetImageTitle(string mapName, int row, int col)
        {
           return $"Map: {mapName} Save:{Protocol.save} Size:{World.Size} Seed:{World.Seed} {row}x{col}";
        }

        private string GetSectionTitle(string mapName, string section)
        {
            return $"{mapName} {World.Size} {World.Seed} {section}";
        }
        
        private void HandleSingleResponse(Hash<string, object> response)
        {
            bool success = (bool)response["Success"];
            if (!success)
            {
                PrintError($"An error occured uploading the image \n\n{JsonConvert.SerializeObject(response)}");
                return;
            }

            Hash<string, object> data = response["Data"] as Hash<string, object>;
            
            Puts($"{data?["Link"]}");
            Interface.Call("OnRustFullMapUploaded", response);
        }

        private void HandleAlbumResponse(Hash<string, Hash<string, object>> response)
        {
            bool success = (bool)response["Album"]["Success"];
            if (!success)
            {
                PrintError($"An error occured uploading the image \n\n{JsonConvert.SerializeObject(response)}");
                return;
            }

            Hash<string, object> data = response["Album"]["Data"] as Hash<string, object>;
            
            Puts($"{data?["Link"]}");
            Interface.Call("OnRustSplitMapUploaded", response);
        }
        #endregion

        #region API

        private bool IsReady()
        {
            return _isReady;
        }
        
        private int GetDefaultResolution()
        {
            return (int)(World.Size / 2);
        }
        
        private int GetDefaultImageFormat()
        {
            return (int) _pluginConfig.DefaultImageEncoding;
        }
        
        private Hash<string, object> CreateRender(string mapName, Hash<string, object> config)
        {
            if (!_isReady)
            {
                return null;
            }

            int resolution = config.ContainsKey("ImageResolution") ? (int) config["ImageResolution"] : GetDefaultResolution();
            MapColorsVersion version = _pluginConfig.MapColorsVersion;
            if (config.ContainsKey("Version"))
            {
                string versionString = (string) config["Version"];
                Enum.TryParse(versionString, true, out version);
            }
            
            ImageConfig imageConfig = new ImageConfig(config, _mapColorVersions[version]);
            Array2D<Color> render = Render(imageConfig, resolution);
            _renders[mapName] = new RenderInfo(render, imageConfig);
            
            return RenderToHash(render);
        }

        private object CreatePluginRender(Plugin plugin, string mapName, int resolution)
        {
            if (!_isReady)
            {
                return null;
            }
            
            Stopwatch sw = Stopwatch.StartNew();

            mapName = _renders.Keys.FirstOrDefault(k => k.Equals(mapName, StringComparison.InvariantCultureIgnoreCase));
            
            if (string.IsNullOrEmpty(mapName))
            {
                return $"Map name does not exist. Valid map names are {string.Join(", ", _renders.Keys.ToArray())}";
            }
            
            RenderInfo info = _renders[mapName];

            Puts($"Starting render for plugin {plugin.Name}");
            Array2D<Color> render = Render(info.RenderConfig, resolution);
            if (info.OverlayConfig != null)
            {
                List<Hash<string, object>> monuments = BuildIconMonuments(resolution);
                render = RenderOverlay(render, monuments.Select(m => new OverlayConfig(m)).ToList());
            }
            sw.Stop();
            Puts($"Render for plugin {plugin.Name} took: {GetDuration(sw.ElapsedMilliseconds)}");
            return render;
        }
        
        private object CreatePluginImage(Plugin plugin, string mapName, int resolution, int encoding)
        {
            object response = CreatePluginRender(plugin, mapName, resolution);
            if (!(response is Array2D<Color>))
            {
                return response;
            }

            EncodingMode mode = (EncodingMode) encoding;
            
            return CreateSingle((Array2D<Color>)response, mode)[GetIndex(0, 0)];
        }

        private void UploadPluginImageSingle(Plugin plugin, string mapName, int resolution, int encoding, Action<Hash<string,object>> callback, string title = null)
        {
            object response = CreatePluginImage(plugin, mapName, resolution, encoding);
            if (!(response is Hash<string, object>))
            {
                PrintError($"UploadPluginImageSingle has error {response}");
                return;
            }

            Hash<string, object> map = (Hash<string, object>) response;
            UploadSingle(map, title, callback);
        }

        private Hash<string, object> CreateRenderOverlay(string renderSource, string newMapName, List<Hash<string, object>> overlay)
        {
            if (!_isReady)
            {
                return null;
            }

            RenderInfo renderInfo = _renders[renderSource];
            if (renderInfo == null)
            {
                return null;
            }

            List<OverlayConfig> overlayConfig = overlay.Select(o => new OverlayConfig(o)).ToList();

            Array2D<Color> overlayRender = RenderOverlay(renderInfo.Colors, overlayConfig);

            _renders[newMapName] = new RenderInfo(overlayRender, renderInfo.RenderConfig, overlayConfig);
            return RenderToHash(overlayRender);
        }
        
        private Hash<string, object> GetRender(string mapName)
        {
            if (!_renders.ContainsKey(mapName))
            {
                return null;
            }

            return RenderToHash(_renders[mapName].Colors);
        }
        
        private Hash<string, Hash<string, object>> CreateSingle(string mapName, int encodingMode)
        {
            if (!_renders.ContainsKey(mapName))
            {
                return null;
            }
            
            Array2D<Color> render = _renders[mapName].Colors;
            EncodingMode mode = (EncodingMode) encodingMode;

            return CreateSingle(render, mode);
        }

        private Hash<string, Hash<string, object>> CreateSingle(Array2D<Color> render, EncodingMode mode)
        {
            return new Hash<string, Hash<string, object>>
            {
                [GetIndex(0,0)] = CreateMapData(render, mode)
            };
        }
        
        private Hash<string, Hash<string,object>> CreateSplice(string mapName, int numRows, int numCols, int encodingMode)
        {
            if (!_renders.ContainsKey(mapName))
            {
                return null;
            }
            
            Array2D<Color> render = _renders[mapName].Colors;
            EncodingMode mode = (EncodingMode) encodingMode;

            return CreateSplice(render, numRows, numCols, mode);
        }

        private Hash<string, Hash<string, object>> CreateSplice(Array2D<Color> render, int numRows, int numCols, EncodingMode mode)
        {
            Hash<string, Hash<string,object>> splice = new Hash<string, Hash<string, object>>();
            int rowSize = render.Height / numRows;
            int colSize = render.Width / numCols;
            for (int x = 0; x < numRows; x++)
            {
                for (int y = 0; y < numCols; y++)
                {
                    Array2D<Color> splicedColors = render.Splice(y * colSize, x * rowSize, colSize, rowSize);
                    splice[GetIndex(x,y)] = CreateMapData(splicedColors, mode);
                }
            }
            
            return splice;
        }
        
        private Hash<string, Hash<string, object>> SaveSingleImage(string mapName)
        {
            if (!_renders.ContainsKey(mapName))
            {
                return null;
            }

            Stopwatch sw = Stopwatch.StartNew();
            Hash<string, Hash<string, object>> single = CreateSingle(mapName, (int) _pluginConfig.DefaultImageEncoding);
            sw.Stop();
            
            Puts($"{mapName} Encoding Took: {GetDuration(sw.ElapsedMilliseconds)}");
            
            SaveCache(mapName, GetIndex(1, 1), single);
            SaveSplit(mapName, GetIndex(1, 1), single);
            return single;
        }

        private Hash<string, Hash<string, object>> SaveSplitImage(string mapName, int numRows, int numCols)
        {
            Stopwatch sw = Stopwatch.StartNew();
            Hash<string, Hash<string, object>> split = CreateSplice(mapName, numRows, numCols, (int) _pluginConfig.DefaultImageEncoding);
            sw.Stop();
            
            string index = GetIndex(numRows, numCols);
            Puts($"{mapName} {index} Split Took: {GetDuration(sw.ElapsedMilliseconds)}");

            SaveCache(mapName, index, split);
            SaveSplit(mapName, index, split);
            return split;
        }
        
        private List<string> GetRenderNames()
        {
            return _renders.Keys.ToList();
        }
        
        private List<string> GetSavedSplits(string mapName)
        {
            return _storedData.GetSavedSplits(mapName);
        }
        
        private Hash<string, object> GetFullMap(string mapName)
        {
            return GetSection(mapName, 1, 1, 0, 0);
        }

        private List<Hash<string, object>> GetIconOverlay()
        {
            return _iconOverlay;
        }

        private bool HasSplit(string mapName, int numRows, int numCols)
        {
            Hash<string, uint> split = _storedData.MapIds[mapName]?[GetIndex(numRows, numCols)];
            if (split != null)
            {
                return split.Count == numRows * numCols;
            }

            return false;
        }

        private Hash<string, object> GetSection(string mapName, int numRows, int numCols, int row, int col)
        {
            if (numRows <= 0)
            {
                throw new ArgumentOutOfRangeException(nameof(numRows), "numRows cannot be less <= 0!");
            }
            
            if (numCols <= 0)
            {
                throw new ArgumentOutOfRangeException(nameof(numCols), "numCols cannot be less <= 0!");
            }
            
            if (row < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(row), "Row cannot be less < 0!");
            }
            
            if (col < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(col), "Col cannot be less < 0!");
            }

            if (row >= numRows)
            {
                throw new ArgumentOutOfRangeException(nameof(numRows), "row cannot be >= numRows");
            }
            
            if (col >= numCols)
            {
                throw new ArgumentOutOfRangeException(nameof(numRows), "col cannot be >= numCols");
            }
            
            string splitIndex = GetIndex(numRows, numCols);
            string sectionIndex = GetIndex(row, col);
            Hash<string, object> cacheSection = GetCacheSection(mapName, splitIndex, sectionIndex);
            if (cacheSection != null)
            {
                return cacheSection;
            }
            
            if (HasSplit(mapName, numRows, numCols))
            {
                Hash<string, object> section = LoadSection(mapName, splitIndex, sectionIndex);
                if (section != null)
                {
                    return section;
                }
            }

            if (numRows == 1 && numCols == 1)
            {
                return SaveSingleImage(mapName)[sectionIndex];
            }

            return SaveSplitImage(mapName, numRows, numCols)[sectionIndex];
        }

        private Hash<string, Hash<string, object>> GetSplit(string mapName, int numRows, int numCols)
        {
            if (numRows <= 0)
            {
                throw new ArgumentOutOfRangeException(nameof(numRows), "numRows cannot be less <= 0!");
            }
            
            if (numCols <= 0)
            {
                throw new ArgumentOutOfRangeException(nameof(numCols), "numCols cannot be less <= 0!");
            }
            
            string splitIndex = GetIndex(numRows, numCols);
            Hash<string, Hash<string, object>> cacheSplit = GetCacheSplit(mapName, splitIndex);
            if (cacheSplit != null)
            {
                return cacheSplit;
            }
            
            if (HasSplit(mapName, numRows, numCols))
            {
                Hash<string, Hash<string, object>> split = new Hash<string, Hash<string, object>>();
                foreach (KeyValuePair<string,uint> pair in _storedData.MapIds[mapName][splitIndex])
                {
                    split[pair.Key] = LoadSection(mapName, splitIndex, pair.Key);
                }

                return split;
            }

            if (numRows == 1 && numCols == 1)
            {
                return SaveSingleImage(mapName);
            }

            return SaveSplitImage(mapName, numRows, numCols);
        }
        #endregion

        #region Icon Handling

        private List<Hash<string, object>> BuildIconMonuments(int size)
        {
            float posScale = (float)size / World.Size;
            List<Hash<string, object>> overlays = new  List<Hash<string, object>>();
            if (TerrainMeta.Path != null && TerrainMeta.Path.Monuments != null)
            {
                foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
                {
                    string name = GetMonumentName(monument);

                    IconConfig config = _pluginConfig.IconSettings[name];
                    if (config == null)
                    {
                        _pluginConfig.IconSettings[name] = new IconConfig
                        {
                            Height = 90,
                            Width = 90,
                            Show = false,
                            ImageUrl = string.Empty
                        };
                        Config.WriteObject(_pluginConfig);
                        continue;
                    }

                    if (string.IsNullOrEmpty(config.ImageUrl))
                    {
                        var defaultValue = _defaultIcons[name];
                        if (defaultValue != null)
                        {
                            config.ImageUrl = defaultValue.ImageUrl;
                            config.Show = true;
                            Config.WriteObject(_pluginConfig);
                        }
                    }

                    if (!config.Show)
                    {
                        continue;
                    }
                    
                    float x = monument.transform.position.z;
                    float z = monument.transform.position.x;

                    AddImageToOverlay(x, z, posScale, overlays, config, name);
                }
            }

            foreach (CustomIcons customIcon in _pluginConfig.CustomIcons)
            {
                if (!customIcon.Show)
                {
                    continue;
                }
                
                AddImageToOverlay(customIcon.XPos, customIcon.ZPos, posScale, overlays, customIcon, $"Custom Image: {customIcon.ImageUrl}");
            }
            return overlays;
        }

        private static void AddImageToOverlay(float x,float z, float posScale , List<Hash<string, object>> overlays, IconConfig config, string name)
        {
            float half = World.Size / 2.0f;

            x = (x + half) * posScale;
            z = (z + half) * posScale;
            
            overlays.Add(new Hash<string, object>
            {
                [nameof(OverlayConfig.Height)] = (int) (config.Height / posScale),
                [nameof(OverlayConfig.Width)] = (int) (config.Width / posScale),
                [nameof(OverlayConfig.Image)] = config.Image,
                [nameof(OverlayConfig.XPos)] = (int) x,
                [nameof(OverlayConfig.YPos)] = (int) z,
                [nameof(OverlayConfig.DebugName)] = name
            });
        }
        
        private string GetMonumentName(MonumentInfo monument)
        {
            string name = monument.displayPhrase.english.Replace("\n", "");
            if (string.IsNullOrEmpty(name))
            {
                if (monument.Type == MonumentType.Cave)
                {
                    name = "Cave";
                }
                else if(monument.name.Contains("power_sub"))
                {
                    name = "Power Sub Station";
                }
                else
                {
                    name = monument.name;
                }
            }

            return name;
        }

        #endregion
        
        #region Storage Handling
        private Hash<string, object> LoadSection(string mapName, string split, string section)
        {
            Hash<string, object> cache = GetCacheSection(mapName, split, section);
            if (cache != null)
            {
                return cache;
            }

            uint? imageId = _storedData.MapIds[mapName]?[split]?[section];
            if (imageId == null)
            {
                return null;
            }

            byte[] data = LoadImage(imageId.Value, FileStorage.Type.jpg);

            Hash<string, object> imageData = ImageDataFromBytes(data);
            SaveCache(mapName, split, section, imageData);

            return imageData;
        }
        
        private void SaveSplit(string mapName, string split, Hash<string, Hash<string, object>> splitData)
        {
            _storageQueue.Enqueue(new StorageInfo
            {
                MapName = mapName,
                Split = split,
                SplitData = splitData
            });
            
            if (_storeImageRoutine == null)
            {
                _storeImageRoutine = InvokeHandler.Instance.StartCoroutine(HandleSave());
            }
        }

        private IEnumerator HandleSave()
        {
            while (_storageQueue.Count > 0)
            {
                StorageInfo next = _storageQueue.Dequeue();
                foreach (KeyValuePair<string,Hash<string,object>> data in next.SplitData)
                {
                    StoreSection(next.MapName, next.Split, data.Key, data.Value);
                    yield return null;
                }
            }

            if (_isReady)
            {
                SaveData();
            }

            _storeImageRoutine = null;
        }
        
        private void StoreSection(string mapName, string split, string section, Hash<string, object> imageData)
        {
            Hash<string, Hash<string, uint>> map = _storedData.MapIds[mapName];
            if (map == null)
            {
                map = new Hash<string, Hash<string, uint>>();
                _storedData.MapIds[mapName] = map;
            }
            
            byte[] storageBytes = BytesFromImageData(imageData);
            Hash<string, uint> splitData = map[split];
            if (splitData == null)
            {
                splitData = new Hash<string, uint>();
                map[split] = splitData;
            }

            splitData[section] = StoreImage(storageBytes, FileStorage.Type.jpg);
        }

        private Hash<string, Hash<string, object>> GetCacheSplit(string mapName, string split)
        {
            return _imageCache[mapName]?[split];
        }
        
        private Hash<string, object> GetCacheSection(string mapName, string split, string section)
        {
            return GetCacheSplit(mapName,split)?[section];
        }

        private void SaveCache(string mapName, string split, Hash<string, Hash<string, object>> data)
        {
            Hash<string, Hash<string, Hash<string, object>>> map = _imageCache[mapName];
            if (map == null)
            {
                map = new Hash<string, Hash<string, Hash<string, object>>>();
                _imageCache[mapName] = map;
            }

            map[split] = data;
        }
        
        private void SaveCache(string mapName, string split, string section,  Hash<string, object> data)
        {
            Hash<string, Hash<string, Hash<string, object>>> map = _imageCache[mapName];
            if (map == null)
            {
                map = new Hash<string, Hash<string, Hash<string, object>>>();
                _imageCache[mapName] = map;
            }

            Hash<string, Hash<string, object>> cache = map[split];
            if (cache == null)
            {
                cache = new Hash<string, Hash<string, object>>();
                map[split] = cache;
            }

            cache[section] = data;
        }

        private uint StoreImage(byte[] bytes, FileStorage.Type type)
        {
            return FileStorage.server.Store(Compression.Compress(bytes), type, CommunityEntity.ServerInstance.net.ID);
        }

        private byte[] LoadImage(uint id, FileStorage.Type type)
        {
            return Compression.Uncompress(FileStorage.server.Get(id, type, CommunityEntity.ServerInstance.net.ID));
        }

        private Hash<string, object> ImageDataFromBytes(byte[] bytes)
        {
            return new Hash<string, object>
            {
                ["width"] = BitConverter.ToInt32(bytes, 0),
                ["height"] = BitConverter.ToInt32(bytes, 4),
                ["image"] = bytes.Skip(8).ToArray()
            };
        }
        
        private byte[] BytesFromImageData(Hash<string, object> data)
        {
            byte[] width = BitConverter.GetBytes((int) data["width"]);
            byte[] height = BitConverter.GetBytes((int) data["height"]);
            byte[] image = (byte[]) data["image"];
            
            byte[] bytes = new byte[width.Length + height.Length + image.Length];
            Array.Copy(width, 0, bytes, 0, width.Length);
            Array.Copy(height, 0, bytes, width.Length, height.Length);
            Array.Copy(image, 0, bytes, width.Length + height.Length, image.Length);
            return bytes;
        }
        #endregion

        #region Helper Methods
        private Hash<string, object> RenderToHash(Array2D<Color> colors)
        {
            return new Hash<string, object>
            {
                ["colors"] = colors.Items,
                ["width"] = colors.Width,
                ["height"] = colors.Height
            };
        }

        private Hash<string, object> CreateMapData(Array2D<Color> colors, EncodingMode mode)
        {
            return  new Hash<string, object>
            {
                ["image"] = EncodeTo(colors.Items, colors.Width, colors.Height, mode),
                ["width"] = colors.Width,
                ["height"] = colors.Height
            };
        }
        
        private string GetIndex(int row, int col)
        {
            return $"{row}x{col}";
        }

        private MapColors GetDefaultColors()
        {
            return _mapColorVersions[_pluginConfig.MapColorsVersion];
        }

        private string GetDuration(double milliseconds)
        {
            return $"{TimeSpan.FromMilliseconds(milliseconds).TotalSeconds:0.00} Seconds";
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);
        }
        #endregion

        #region Imgur Helpers
        private void UploadSingle(Hash<string, object> map, string title, Action<Hash<string, object>> callback)
        {
            ImgurApi.Call("UploadImage", map["image"], new Action<Hash<string, object>>(callback), title);
        }
        
        private void UploadAlbum(Hash<string, Hash<string, object>> map, string title, string mapName, Action<Hash<string, Hash<string, object>>> callback)
        {
            List<Hash<string, object>> images = new List<Hash<string, object>>();
            foreach (KeyValuePair<string, Hash<string, object>> section in map)
            {
                images.Add(new Hash<string, object>
                {
                    ["Image"] = section.Value["image"],
                    ["Title"] = GetSectionTitle(mapName, section.Key)
                });
            }

            ImgurApi.Call("UploadAlbum", images, new Action<Hash<string, Hash<string, object>>>(callback), title);
        }
        #endregion

        #region Map Renderer

        private Array2D<Color> Render(ImageConfig config, int mapSize)
        {
            int waterOffset = config.WaterOffset;
            int halfWaterOffset = waterOffset / 2;

            if (_heightMap == null || _splatMap == null || _terrain == null)
            {
                return new Array2D<Color>();
            }
            
            if (mapSize <= 0)
            {
                return new Array2D<Color>();
            }
            
            int imageWidth = mapSize + waterOffset;
            int imageHeight = mapSize + waterOffset;
            int widthWithWater = mapSize + halfWaterOffset;

            float scale = 1f / mapSize;

            Array2D<Color> output = new Array2D<Color>(imageWidth, imageHeight);

            Parallel.For(-halfWaterOffset, imageHeight - halfWaterOffset, row =>
            {
                float offsetRow = row * scale;
                for (int col = -halfWaterOffset; col < widthWithWater; col++)
                {
                    float offsetCol = col * scale;
                    float terrainHeight = GetHeight(offsetRow, offsetCol);
                    float sun = Math.Max(Vector3.Dot(GetNormal(offsetRow, offsetCol), config.SunDirection), 0.0f);
                    Vector3 pixel = Vector3.Lerp(config.StartColor, config.GravelColor, GetSplat(row, col, 128) * config.GravelColor.w);
                    pixel = Vector3.Lerp(pixel, config.PebbleColor, GetSplat(offsetRow, offsetCol, 64) * config.PebbleColor.w);
                    pixel = Vector3.Lerp(pixel, config.RockColor, GetSplat(offsetRow, offsetCol, 8) * config.RockColor.w);
                    pixel = Vector3.Lerp(pixel, config.DirtColor, GetSplat(offsetRow, offsetCol, 1) * config.DirtColor.w);
                    pixel = Vector3.Lerp(pixel, config.GrassColor, GetSplat(offsetRow, offsetCol, 16) * config.GrassColor.w);
                    pixel = Vector3.Lerp(pixel, config.ForestColor, GetSplat(offsetRow, offsetCol, 32) * config.ForestColor.w);
                    pixel = Vector3.Lerp(pixel, config.SandColor, GetSplat(offsetRow, offsetCol, 4) * config.SandColor.w);
                    pixel = Vector3.Lerp(pixel, config.SnowColor, GetSplat(offsetRow, offsetCol, 2) * config.SnowColor.w);
                    float waterDepth = -terrainHeight;
                    if (waterDepth > config.OceanWaterLevel)
                    {
                        pixel = Vector3.Lerp(pixel, config.WaterColor, Mathf.Clamp(0.5f + waterDepth / 5.0f, 0.0f, 1f));
                        pixel = Vector3.Lerp(pixel, config.OffShoreColor, Mathf.Clamp(waterDepth / 50f, 0.0f, 1f));
                        sun = config.SunPower;
                    }

                    pixel += (sun - config.SunPower) * config.SunPower * pixel;
                    pixel = (pixel - config.Half) * config.Contrast + config.Half;
                    pixel *= config.Brightness;
                    
                    output[row + halfWaterOffset, col + halfWaterOffset] = new Color(pixel.x, pixel.y, pixel.z);
                }
            });
            
            return output;
        }

        private Array2D<Color> RenderOverlay(Array2D<Color> previous, List<OverlayConfig> overlays)
        {
            Array2D<Color> colors = previous.Clone();
            foreach (OverlayConfig overlay in overlays)          
            {
                if (overlay.Image == null || overlay.Image.Length == 0)
                {
                    Puts($"{overlay.DebugName} contains an invalid image");
                    continue;
                }
                
                using (Bitmap image = ResizeImage(overlay.Image, overlay.Width, overlay.Height))
                {
                    int startRow = overlay.YPos - overlay.Height / 2;
                    int startCol = overlay.XPos - overlay.Width / 2;

                    if (startRow < -overlay.Width)
                    {
                        startRow = 5;
                    }

                    if (startRow > colors.Width - overlay.Width)
                    {
                        startRow = colors.Width - overlay.Width - 5;
                    }

                    if (startCol < -overlay.Height)
                    {
                        startCol = 5;
                    }

                    if (startCol > colors.Height - overlay.Height)
                    {
                        startCol = colors.Height - overlay.Height - 5;
                    }
                    
                    for (int row = 0; row < image.Height; row++)
                    {
                        for (int col = 1; col <= image.Width; col++)
                        {
                            System.Drawing.Color pixel = image.GetPixel(row, overlay.Width - col);
                            int overlayRow = row + startRow;
                            int overlayCol = col + startCol;
                            if (pixel.A != 0)
                            {
                                if (overlayRow >= colors.Height || overlayCol >= colors.Width || overlayRow < 0 || overlayCol < 0)
                                {
                                    continue;
                                }
                                
                                colors[overlayRow, overlayCol] = new Color32(pixel.R, pixel.G, pixel.B, pixel.A);
                            }
                        }
                    }
                }
            }

            return colors;
        }

        float GetHeight(float x, float y)
        {
            return _heightMap.GetHeight(x, y);
        }

        Vector3 GetNormal(float x, float y)
        {
            return _heightMap.GetNormal(x, y);
        }

        float GetSplat(float x, float y, int mask)
        {
            return _splatMap.GetSplat(x, y, mask);
        }
        
        private byte[] EncodeTo(Color[] color, int width, int height, EncodingMode mode)
        {
            Texture2D tex = null;
            try
            {
                tex = new Texture2D(width, height);
                tex.SetPixels(color);
                tex.Apply();
                return mode == EncodingMode.Jpg ? tex.EncodeToJPG(85) : tex.EncodeToPNG();
            }
            finally
            {
                if (tex != null)
                    UnityEngine.Object.Destroy(tex);
            }
        }
        
        private Bitmap ResizeImage(byte[] bytes, int targetWidth, int targetHeight)
        {
            using (MemoryStream original = new MemoryStream())
            {
                original.Write(bytes, 0, bytes.Length);
                using (Bitmap img = new Bitmap(Image.FromStream(original)))
                {
                    return new Bitmap(img, new Size(targetWidth, targetHeight));
                }
            }
        }
        #endregion

        #region Icon Handling

        private IEnumerator LoadIcon(IconConfig config)
        {
            int code = config.ImageUrl.GetHashCode();
            uint iconId = _storedData.IconIds[code];
            if (iconId != 0)
            {
                config.Image = LoadImage(iconId, FileStorage.Type.png);
            }
            else
            {
                yield return DownloadIcon(config, code);
            }
        }

        private IEnumerator DownloadIcon(IconConfig config, int code)
        {
            using (UnityWebRequest www = UnityWebRequest.Get(config.ImageUrl))
            {
                yield return www.SendWebRequest();

                if (www.isNetworkError || www.isHttpError)
                {
                    PrintError($"Failed to download icon: {www.error}");
                    www.Dispose();
                    yield break;
                }
                
                Texture2D texture = new Texture2D(2, 2);
                texture.LoadImage(www.downloadHandler.data);
                if (texture != null)
                {
                    byte[] bytes = texture.EncodeToPNG();
                    GameObject.Destroy(texture);
                    config.Image = bytes;
                    _storedData.IconIds[code] = StoreImage(bytes, FileStorage.Type.png);
                }
            }
        }

        #endregion
        
        #region Classes
        private class PluginConfig
        {
            [DefaultValue(MapColorsVersion.Current)]
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Map Colors Version")]
            public MapColorsVersion MapColorsVersion { get; set; }
            
            [DefaultValue(EncodingMode.Jpg)]
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Default Image Encoding (Jpg, Png)")]
            public EncodingMode DefaultImageEncoding { get; set; }
            
            [JsonProperty(PropertyName = "Starting Splits (Rows x Columns)")]
            public List<string> StartingSplits { get; set; }
            
            [JsonProperty(PropertyName = "IconSettings")]
            public Hash<string, IconConfig> IconSettings { get; set; }
            
            [JsonProperty(PropertyName = "Custom Icons")]
            public List<CustomIcons> CustomIcons { get; set; }
        }

        private class IconConfig
        {
            public int Width { get; set; }
            public int Height { get; set; }
            public string ImageUrl { get; set; }
            public bool Show { get; set; }
            
            [JsonIgnore]
            public byte[] Image { get; set; }
        }

        private class CustomIcons : IconConfig
        {
            public float XPos { get; set; }
            public float ZPos { get; set; }
        }

        private class StoredData
        {
            public Hash<string, Hash<string, Hash<string, uint>>> MapIds = new Hash<string, Hash<string, Hash<string, uint>>>();
            public Hash<int, uint> IconIds = new Hash<int, uint>();
            
            public List<string> GetSavedSplits(string mapName)
            {
                Hash<string, Hash<string, uint>> splits = MapIds[mapName];
                return splits == null ? new List<string>() : splits.Keys.ToList();
            }
        }

        private class StorageInfo
        {
            public string MapName { get; set; }
            public string Split { get; set; }
            public Hash<string, Hash<string, object>> SplitData { get; set; }
        }

        private class RenderInfo
        {
            public Array2D<Color> Colors { get; set; }
            public ImageConfig RenderConfig { get; set; }
            public List<OverlayConfig> OverlayConfig { get; set; }

            public RenderInfo()
            {
                
            }
            
            public RenderInfo(Array2D<Color> colors, ImageConfig renderConfig)
            {
                Colors = colors;
                RenderConfig = renderConfig;
            }

            public RenderInfo(Array2D<Color> colors, ImageConfig renderConfig, List<OverlayConfig> overlayConfig)
            {
                Colors = colors;
                RenderConfig = renderConfig;
                OverlayConfig = overlayConfig;
            }
        }
        
        private class MapColors
        {
            public Vector3 StartColor { get; set; }
            public Vector4 WaterColor { get; set; }
            public Vector4 GravelColor  { get; set; }
            public Vector4 DirtColor  { get; set; }
            public Vector4 SandColor  { get; set; }
            public Vector4 GrassColor  { get; set; }
            public Vector4 ForestColor  { get; set; }
            public Vector4 RockColor  { get; set; }
            public Vector4 SnowColor  { get; set; }
            public Vector4 PebbleColor  { get; set; }
            public Vector4 OffShoreColor { get; set; }
            public Vector3 SunDirection  { get; set; }
            public Vector3 Half  { get; set; }
            public int WaterOffset { get; set; }
            public float SunPower { get; set; }
            public float Brightness { get; set; }
            public float Contrast { get; set; }
            public float OceanWaterLevel { get; set; }
        }

        private class ImageConfig : MapColors
        {
            public ImageConfig(MapColors defaultColors) : this(new Hash<string, object>(), defaultColors)
            {
                
            }
            
            public ImageConfig(Hash<string, object> config, MapColors defaultColors)
            {
                StartColor = config.ContainsKey(nameof(StartColor)) ? (Vector3) config[nameof(StartColor)] : defaultColors.StartColor;
                WaterColor = config.ContainsKey(nameof(WaterColor)) ? (Vector4) config[nameof(WaterColor)] : defaultColors.WaterColor;
                GravelColor = config.ContainsKey(nameof(GravelColor)) ? (Vector4) config[nameof(GravelColor)] : defaultColors.GravelColor;
                DirtColor = config.ContainsKey(nameof(DirtColor)) ? (Vector4) config[nameof(DirtColor)] : defaultColors.DirtColor;
                SandColor = config.ContainsKey(nameof(SandColor)) ? (Vector4) config[nameof(SandColor)] : defaultColors.SandColor;
                GrassColor = config.ContainsKey(nameof(GrassColor)) ? (Vector4) config[nameof(GrassColor)] : defaultColors.GrassColor;
                ForestColor = config.ContainsKey(nameof(ForestColor)) ? (Vector4) config[nameof(ForestColor)] : defaultColors.ForestColor;
                RockColor = config.ContainsKey(nameof(RockColor)) ? (Vector4) config[nameof(RockColor)] : defaultColors.RockColor;
                SnowColor = config.ContainsKey(nameof(SnowColor)) ? (Vector4) config[nameof(SnowColor)] : defaultColors.SnowColor;
                PebbleColor = config.ContainsKey(nameof(PebbleColor)) ? (Vector4) config[nameof(PebbleColor)] : defaultColors.PebbleColor;
                OffShoreColor = config.ContainsKey(nameof(OffShoreColor)) ? (Vector4) config[nameof(OffShoreColor)] : defaultColors.OffShoreColor;
                SunDirection = config.ContainsKey(nameof(SunDirection)) ? (Vector3) config[nameof(SunDirection)] : defaultColors.SunDirection;
                SunPower = config.ContainsKey(nameof(SunPower)) ? (float) config[nameof(SunPower)] : defaultColors.SunPower;
                Brightness = config.ContainsKey(nameof(Brightness)) ? (float) config[nameof(Brightness)] : defaultColors.Brightness;
                Contrast = config.ContainsKey(nameof(Contrast)) ? (float) config[nameof(Contrast)] : defaultColors.Contrast;
                OceanWaterLevel = config.ContainsKey(nameof(OceanWaterLevel)) ? (float) config[nameof(OceanWaterLevel)] : defaultColors.OceanWaterLevel;
                Half = config.ContainsKey(nameof(Half)) ? (Vector3) config[nameof(Half)] : defaultColors.Half;
                WaterOffset = config.ContainsKey(nameof(WaterOffset)) ? (int) config[nameof(WaterOffset)] : 0;
            }
        }

        private class OverlayConfig
        {
            public int XPos { get; set; }
            public int YPos { get; set; }
            public int Width { get; set; }
            public int Height { get; set; }
            public byte[] Image { get; set; }
            public string DebugName { get; set; }
            
            public OverlayConfig()
            {
                
            }

            public OverlayConfig(Hash<string, object> data)
            {
                XPos = data.ContainsKey(nameof(XPos)) ? (int)data[nameof(XPos)] : 0;
                YPos = data.ContainsKey(nameof(YPos)) ? (int)data[nameof(YPos)] : 0;
                Width = data.ContainsKey(nameof(Width)) ? (int)data[nameof(Width)] : 0;
                Height = data.ContainsKey(nameof(Height)) ? (int)data[nameof(Height)] : 0;
                Image = data.ContainsKey(nameof(Image)) ? (byte[])data[nameof(Image)] : null;
                DebugName = data.ContainsKey(nameof(DebugName)) ? (string)data[nameof(DebugName)] : null;
            }
        }
        
        private struct Array2D<T>
        {
            public readonly T[] Items;

            public readonly int Width;

            public readonly int Height;

            public Array2D(T[] items, int width, int height)
            {
                Items = items;
                Width = width;
                Height = height;
            }
            
            public Array2D(int width, int height)
            {
                Items = new T[width * height];
                Width = width;
                Height = height;
            }
            
            public T this[int row, int col]
            {
                get
                {
                    if (row < 0 || row > Width - 1)
                    {
                        throw new IndexOutOfRangeException( $"Get row out of range at {row} Min: 0 Max: {Width - 1}");
                    }

                    if (col < 0 || col > Height - 1)
                    {
                        throw new IndexOutOfRangeException($"Get col out of range at {col} Min: 0 Max: {Height - 1}");
                    }
                    
                    return Items[col * Width + row];
                }
                set
                {
                    if (row < 0 || row > Width - 1)
                    {
                        throw new IndexOutOfRangeException( $"Set row out of range at {row} Min: 0 Max: {Width - 1}");
                    }

                    if (col < 0 || col > Height - 1)
                    {
                        throw new IndexOutOfRangeException($"Set col out of range at {col} Min: 0 Max: {Height - 1}");
                    }
                    
                    Items[col * Width + row] = value;
                }
            }

            public bool IsEmpty()
            {
                return Items == null || Width == 0 && Height == 0;
            }

            public Array2D<T> Splice(int startX, int startY, int width, int height)
            {
                if (startX < 0 || startX >= Width)
                {
                    throw new IndexOutOfRangeException($"startX is < 0 or greater than {Width}: {startX}");
                }

                if (startY < 0 || startY >= Height)
                {
                    throw new IndexOutOfRangeException($"startY is < 0 or greater than {Height}: {startY}");
                }

                if (width == 0 || startX + width > Width)
                {
                    throw new IndexOutOfRangeException($"width is < 0 or greater than {Width}: {width}");
                }

                if (height == 0 || startY + height > Height)
                {
                    throw new IndexOutOfRangeException($"height is < 0 or greater than {Height}: {height}");
                }
                
                Array2D<T> splice = new Array2D<T>(width, height);
                Array2D<T> copyThis = this;
                Parallel.For(0, width, x =>
                {
                    for (int y = 0; y < height; y++)
                    {
                        splice[x, y] = copyThis[startX + x, startY + y];
                    }
                });

                return splice;
            }

            public Array2D<T> Clone()
            {
                return new Array2D<T>((T[])Items.Clone(), Width, Height);
            }

        }
        #endregion
    }
}


// --- End of file: RustMapApi.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/random-positions ---
// --- Original File Path: R/RandomPositions/RandomPositions.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Random Positions", "Orange", "1.0.3")]
    [Description("Randomized positions for plugins or for players respawn points")]
    public class RandomPositions : RustPlugin
    {
        #region Vars

        private HashSet<Vector3> positions = new HashSet<Vector3>();
        private const int scanHeight = 100;
        private static int getBlockMask => LayerMask.GetMask("Construction", "Prevent Building", "Water");
        private static bool MaskIsBlocked(int mask) => getBlockMask == (getBlockMask | (1 << mask));
        private const string commandName = "randompositions";

        #endregion
        
        #region Oxide Hooks

        private void Init()
        {
            cmd.AddConsoleCommand(commandName, this, nameof(cmdControlConsole));

            if (config.useForPlayerSpawns == false)
            {
                Unsubscribe(nameof(OnPlayerRespawn));
            }
        }

        private void OnServerInitialized()
        {
            GeneratePositions();
        }

        private object OnPlayerRespawn(BasePlayer player)
        {
            var position = GetValidSpawnPoint();
            if (position == new Vector3())
            {
                return null;
            }
            
            return new BasePlayer.SpawnPoint
            {
                pos = position
            };
        }

        private object GetRandomPosition()
        {
            var position = GetValidSpawnPoint();
            if (position == new Vector3())
            {
                return null;
            }
            
            return position;
        }

        #endregion

        #region Commands

        private void cmdControlConsole(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin == false)
            {
                return;
            }

            var player = arg.Player();
            var action = arg.Args?.Length > 0 ? arg.Args[0].ToLower() : "null";

            switch (action)
            {
                case "check":
                    var startPosition = player.transform.position - new Vector3(0, 0.2f, 0);
                    GetClosestValidPosition(startPosition, player);
                    break;
                
                case "showall":
                    foreach (var position in positions)
                    {
                        player.SendConsoleCommand("ddraw.box", 10, Color.green, position, 2f);
                    }
                    break;
            }
        }

        #endregion

        #region Core

        private void GeneratePositions()
        {
            positions.Clear();
            var generationSuccess = 0;
            var islandSize = ConVar.Server.worldsize / 2;
            for (var i = 0; i < config.maxGenerationAttempts; i++)
            {
                if (generationSuccess >= config.positionsToGenerate)
                {
                    break;
                }
                
                var x = Core.Random.Range(-islandSize, islandSize);
                var z = Core.Random.Range(-islandSize, islandSize);
                var original = new Vector3(x, scanHeight, z);
                var position = GetClosestValidPosition(original);
                if (position != new Vector3())
                {
                    positions.Add(position);
                    generationSuccess++;
                }
            }
        }

        private Vector3 GetClosestValidPosition(Vector3 original, BasePlayer player = null)
        {
            var target = original - new Vector3(0, 200, 0);
            RaycastHit hitInfo;
            if (Physics.Linecast(original, target, out hitInfo) == false)
            {
                // if (player != null)
                // {
                //     player.ChatMessage("No hit");
                // }
                
                return new Vector3();
            }

            var position = hitInfo.point;
            var collider = hitInfo.collider;
            var colliderName = collider?.name;
            var colliderLayer = collider?.gameObject.layer ?? 4;
            
            if (collider == null)
            {
                // if (player != null)
                // {
                //     player.ChatMessage("collider == null");
                // }
                
                return new Vector3();
            }
           
            if (MaskIsBlocked(colliderLayer) || colliderLayer != 23)
            {
                // if (player != null)
                // {
                //     player.ChatMessage($"hitLayer == getBlockMask ({colliderLayer})");
                // }
                
                return new Vector3();
            }

            if (IsValidPosition(position) == false)
            {
                // if (player != null)
                // {
                //     player.ChatMessage("IsValidPosition(position) == false");
                // }
                
                return new Vector3();
            }

            // if (player != null)
            // {
            //     player.ChatMessage("" +
            //         $"Position is valid! ({position})\n" +
            //         $"Layer: {colliderLayer}\n" +
            //         $"Collider: {colliderName}");
            // }
            
            return position;
        }

        private Vector3 GetValidSpawnPoint()
        {
            for (var i = 0; i < 25; i++)
            {
                var number = Core.Random.Range(0, positions.Count);
                var position = positions.ElementAt(number);
                if (IsValidPosition(position) == true)
                {
                    return position;
                }
                else
                {
                    positions.Remove(position);
                }
            }

            return new Vector3();
        }

        private static bool IsValidPosition(Vector3 position)
        {
            var entities = new List<BuildingBlock>();
            Vis.Entities(position, config.radiusCheck, entities);
            return entities.Count == 0;
        }

        #endregion
        
        #region Configuration | 2.0.0

        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Use for player spawns")]
            public bool useForPlayerSpawns = false;
            
            [JsonProperty(PropertyName = "Buildings radius check")]
            public int radiusCheck = 25;
            
            [JsonProperty(PropertyName = "Positions to generate")]
            public int positionsToGenerate = 1500;
            
            [JsonProperty(PropertyName = "Maximal generation attempts")]
            public int maxGenerationAttempts = 3000;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");

                timer.Every(10f,
                    () =>
                    {
                        PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                    });
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: RandomPositions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/running-man ---
// --- Original File Path: R/RunningMan/RunningMan.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("Running Man", "sami37", "1.7.6")]
    [Description("Get rewarded for killing runner or just survive as runner")]
    class RunningMan : RustPlugin
    {
        #region Declaration
        [PluginReference] private Plugin Clans, Economics, Friends, KarmaSystem, ServerRewards;

        private Timer _compassRefresh, _countdownRefresh;
        private Timer _eventpause;
        private Timer _eventstart;
        private bool _eventStarted;
        private Timer _ingameTimer;
        private readonly Random _rnd = new Random();
        private BasePlayer _runningman;
        private string panelString = "RunningPanel", panelCountString = "RunningCountPanel";

        private Dictionary<string, Dictionary<string, RewardData>> _savedReward =
            new Dictionary<string, Dictionary<string, RewardData>>(StringComparer.OrdinalIgnoreCase);

        private Timer _stillRunnerTimer;
        private double _LastStartedEvent;
        private double _time2;
        private double _NextEvent;
        #endregion

        #region Class

        private class RewardData
        {
            public Dictionary<string, ValueAmount> RewardItems;
        }

        private class ValueAmount
        {
            public int MaxValue;
            public int MinValue;
        }

        #endregion

        #region Configuration
        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Default")]
            public Default Info = new Default();

            [JsonProperty(PropertyName = "TimeRange")]
            public TimeRangeInfo TimeRange = new TimeRangeInfo();

            [JsonProperty(PropertyName = "Reward")]
            public Reward RewardInfo = new Reward();

            [JsonProperty(PropertyName = "CompassUI Info")]
            public CompassUi CompassUiInfo = new CompassUi();

            [JsonProperty(PropertyName = "Countdown Info")]
            public CountdownUi CountdownUiInfo = new CountdownUi();

            public class Default
            {
                [JsonProperty(PropertyName = "ChatName")]
                public string ChatName = "EVENT";

                [JsonProperty(PropertyName = "authLevel")]
                public int AuthLevel = 1;

                [JsonProperty(PropertyName = "AutoStart")]
                public bool AutoStart = true;

                [JsonProperty(PropertyName = "Display Distance")]
                public bool DisplayDistance = true;

                [JsonProperty(PropertyName = "Count")]
                public int Count = 2;

                [JsonProperty(PropertyName = "StarteventTime")]
                public int StarteventTime = 30;

                [JsonProperty(PropertyName = "PauseeventTime")]
                public int PauseeventTime = 30;

                [JsonProperty(PropertyName = "DisconnectPendingTimer")]
                public int DisconnectPendingTimer = 30;

                [JsonProperty(PropertyName = "Excluded auth level")]
                public int Excludedauthlevel = 1;

                [JsonProperty(PropertyName = "Block friends kill reward")]
                public bool Blockfriendskillreward = true;

                [JsonProperty(PropertyName = "Block clans kill reward")]
                public bool Blockclanskillreward = true;
            }

            public class TimeRangeInfo
            {
                [JsonProperty(PropertyName = "Start War Time")]
                public int StartWarTime = 18;

                [JsonProperty(PropertyName = "End War Time")]
                public int EndWarTime = 8;

                [JsonProperty(PropertyName = "Enable Time Range")]
                public bool TimeRange;

            }

            public class Reward
            {
                [JsonProperty(PropertyName = "Random")]
                public bool Random = true;

                [JsonProperty(PropertyName = "RewardFixing")]
                public string RewardFixing = "wood";

                [JsonProperty(PropertyName = "RewardFixingAmount")]
                public int RewardFixingAmount = 10000;

                [JsonProperty(PropertyName = "KarmaSystem")]
                public KarmaSystem KarmaInfo = new KarmaSystem();

                public class KarmaSystem
                {
                    [JsonProperty(PropertyName = "PointToRemove")]
                    public int PointToRemove;

                    [JsonProperty(PropertyName = "PointToAdd")]
                    public int PointToAdd = 1;
                }
            }

            public class CompassUi
            {
                [JsonProperty(PropertyName = "AnchorMin")]
                public string AnchorMin = "0.03 0.067";

                [JsonProperty(PropertyName = "AnchorMax")]
                public string AnchorMax = "0.05 0.09";

                [JsonProperty(PropertyName = "Direction")]
                public Direction RunnerDirection = new Direction();

                public class Direction
                {
                    [JsonProperty(PropertyName = "North East")]
                    public string NorthEast = "N-E";

                    [JsonProperty(PropertyName = "South East")]
                    public string SouthEast = "S-E";

                    [JsonProperty(PropertyName = "North West")]
                    public string NorthWest = "N-W";

                    [JsonProperty(PropertyName = "South West")]
                    public string SouthWest = "S-W";

                    [JsonProperty(PropertyName = "No runner")]
                    public string None = "/";
                }

                [JsonProperty(PropertyName = "Disable while event is off")]
                public bool Disabled;
            }

            public class CountdownUi
            {
                [JsonProperty(PropertyName = "AnchorMin")]
                public string AnchorMin = "0.93 0.93";

                [JsonProperty(PropertyName = "AnchorMax")]
                public string AnchorMax = "1 1";

                [JsonProperty(PropertyName = "Disable UI while no runner")]
                public bool DisableNoRunner;

                [JsonProperty(PropertyName = "Disable UI while runner on")]
                public bool DisableRunnerOn;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                Config.WriteObject(_config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonError");
                PrintError("The configuration file contains an error and has been replaced with a default config.\n" +
                           "The error configuration file was saved in the .jsonError extension");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        #endregion

        #region Umod Hook
        private void OnServerInitialized()
        {
            LoadConfig();

            _eventStarted = false;
            if (_config.Info.AutoStart && !_config.TimeRange.TimeRange)
            {
                _eventpause = timer.Once(60 * _config.Info.PauseeventTime, () => Startevent());
                _LastStartedEvent = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
            }
            else if (_config.Info.AutoStart && _config.TimeRange.TimeRange)
            {
                _ingameTimer = timer.Once(20, CheckTime);
                _NextEvent = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day,
                                 _config.TimeRange.StartWarTime, 0, 0).Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
                CheckTime();
            }

            _compassRefresh = timer.Every(5, RefreshUi);
            _countdownRefresh = timer.Every(1, RefreshCountdownUi);
            LoadSavedData();
        }

        private void Init()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {
                    "StartEventRunner",
                    "<color=#C4FF00>{0}</color>: Running man {1}\nKill him and get the reward!\nCommand: /run - to know the distance to the target."
                },
                {"NotEnoughPlayers", "<color=#C4FF00>{0}</color>: There aren't enough players to start the event."},
                {"RunnerSaved", "<color=#C4FF00>{0}</color>: {1} ran away from the chase and received a reward!"},
                {"StillRunner", "<color=#C4FF00>{0}</color>: {1} your are still the runner."},
                {"RunnerBackOnline", "<color=#C4FF00>{0}</color>: {1} is back online.\nKill him and get the reward!"},
                {"RunnerKilled", "<color=#C4FF00>{0}</color>: Player - {1} kill {2} and received a reward!"},
                {
                    "RunnerDistance",
                    "<color=#C4FF00>{0}</color>: Player - {1},\n is at a distance of {2}\nKill him and get the reward!"
                },
                {"UntilEndOfEvent", "<color=#C4FF00>{0}</color>: Until the end of event left: {1} minutes"},
                {"NotRunningEvent", "<color=#C4FF00>{0}</color>: At the moment the event is not running"},
                {
                    "UntilStartOfEvent",
                    "<color=#C4FF00>{0}</color>: Before the start of the event remained: {1} minutes"
                },
                {"RunCommandHelp", "Use \"/run\" to find out information about the running man"},
                {
                    "AdminCommandHelp",
                    "Use \"/eventon\" for start event Running Man\nUse \"/eventoff\" for start event Running Man"
                },
                {
                    "AdminAddCommandHelp",
                    "Use \"/running add <Package Name> <ItemName or money or karma> <MinAmount> <MaxAmount>\" to add item."
                },
                {
                    "AdminRemoveCommandHelp",
                    "Use \"/running remove <PackageName> <ItemName or karma or money>\" to remove item."
                },
                {"NobodyOnline", "<color=#C4FF00>{0}</color>: You can't run event while there is nobody online"},
                {"NoPerm", "<color=#C4FF00>{0}</color>: You have no rights to do this!"},
                {"RunnerLeaved", "<color=#C4FF00>{0}</color>: {1} got scared and ran away!"},
                {"EventStopped", "<color=#C4FF00>{0}</color>: Event has stopped!"},
                {"PackageDontExist", "<color=#C4FF00>{0}</color>: This package don't exist."},
                {"MissingItemFromPackage", "<color=#C4FF00>{0}</color>: Item not found in package."},
                {"ItemRemoved", "<color=#C4FF00>{0}</color>: Successfully removed item {1}."},
                {"ItemAdded", "<color=#C4FF00>{0}</color>: Successfully added item {1} to package {2}."},
                {"PackageAdded", "<color=#C4FF00>{0}</color>: Successfully added package {1} and inserted item to it."},
                {"ItemExist", "<color=#C4FF00>{0}</color>: Item already exist in package."},
                {"Rewarded", "<color=#C4FF00>{0}</color>: You won a reward : {1}."}
            }, this);
            permission.RegisterPermission("runningman.admin", this);
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        private void Unload()
        {
            _eventpause?.Destroy();
            _eventstart?.Destroy();
            _ingameTimer?.Destroy();
            _compassRefresh?.Destroy();
            _countdownRefresh?.Destroy();
            _runningman = null;
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUi(player);
                DestroyCountdownUi(player);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (_runningman != null)
                if (player == _runningman)
                    _stillRunnerTimer = timer.Once(60 * _config.Info.DisconnectPendingTimer,
                        DestroyLeaveEvent);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (_runningman != null)
                if (_runningman == player)
                {
                    SendReply(player,
                        string.Format(lang.GetMessage("StillRunner", this, player.UserIDString),
                            _config.Info.ChatName, _runningman.displayName));
                    BroadcastChat(string.Format(lang.GetMessage("RunnerBackOnline", this),
                        _config.Info.ChatName, _runningman.displayName));
                    _stillRunnerTimer?.Destroy();
                }
                else
                {
                    SendHelpText(player);
                }
        }

        private void OnPlayerDeath(BasePlayer victim, HitInfo hitinfo)
        {
            var attacker = hitinfo?.Initiator?.ToPlayer();
            if (attacker == null || victim == null || _runningman == null)
                return;
            if (attacker == victim)
                return;
            if (victim != _runningman)
                return;
            if (Friends != null && (bool)Friends?.CallHook("AreFriends", attacker.userID, victim.userID) && _config.Info.Blockfriendskillreward)
                return;

            var attackerclan = Clans?.CallHook("GetClanOf", attacker.userID);
            var victimclan = Clans?.CallHook("GetClanOf", victim.userID);

            if (victimclan != null && attackerclan != null && victimclan == attackerclan && _config.Info.Blockclanskillreward)
                return;

            Runlog(string.Format(lang.GetMessage("RunnerKilled", this), _config.Info.ChatName, attacker.displayName, _runningman.displayName));

            BroadcastChat(string.Format(lang.GetMessage("RunnerKilled", this), _config.Info.ChatName, attacker.displayName, _runningman.displayName));
            var inv = attacker.inventory;
            if (_config.RewardInfo.Random)
            {
                if (_savedReward?["killer"] == null)
                {
                    PrintWarning("Reward list is empty, please add items, using FixingReward option...");
                    inv?.GiveItem(ItemManager.CreateByName(_config.RewardInfo.RewardFixing, _config.RewardInfo.RewardFixingAmount), inv.containerMain);
                    return;
                }

                var rand = _savedReward["killer"].ElementAt(_rnd.Next(0, _savedReward["killer"].Count));
                foreach (var data in rand.Value.RewardItems)
                {
                    var randomReward = _rnd.Next(data.Value.MinValue, data.Value.MaxValue);
                    switch (data.Key.ToLower())
                    {
                        case "karma":
                            if (KarmaSystem != null && KarmaSystem.IsLoaded)
                            {
                                var player = covalence.Players.FindPlayerById(attacker.UserIDString);
                                KarmaSystem.Call("AddKarma", player, (double)randomReward);
                                SendReply(attacker,
                                    string.Format(lang.GetMessage("Rewarded", this, attacker.UserIDString),
                                        _config.Info.ChatName, data.Key + " x " + randomReward));
                            }
                            else
                            {
                                inv?.GiveItem(
                                    ItemManager.CreateByName(_config.RewardInfo.RewardFixing,
                                        _config.RewardInfo.RewardFixingAmount), inv.containerMain);
                                SendReply(attacker, string.Format(
                                    lang.GetMessage("Rewarded", this, attacker.UserIDString),
                                    _config.Info.ChatName, _config.RewardInfo.RewardFixing + " x " + _config.RewardInfo.RewardFixingAmount));
                            }

                            break;
                        case "money":
                            if (Economics != null && Economics.IsLoaded)
                            {
                                Economics.CallHook("Deposit", attacker.userID,
                                    randomReward);
                                SendReply(attacker,
                                    string.Format(lang.GetMessage("Rewarded", this, attacker.UserIDString),
                                        _config.Info.ChatName, "money x " + randomReward));
                            }
                            else
                            {
                                inv?.GiveItem(
                                    ItemManager.CreateByName(_config.RewardInfo.RewardFixing,
                                        _config.RewardInfo.RewardFixingAmount), inv.containerMain);
                                SendReply(attacker, string.Format(
                                    lang.GetMessage("Rewarded", this, attacker.UserIDString),
                                    _config.Info.ChatName, _config.RewardInfo.RewardFixing + " x " + _config.RewardInfo.RewardFixingAmount));
                            }

                            break;
                        case "serverreward":
                            if (ServerRewards != null && ServerRewards.IsLoaded)
                            {
                                ServerRewards.CallHook("AddPoints", attacker.userID, randomReward);
                                SendReply(attacker,
                                    string.Format(lang.GetMessage("Rewarded", this, attacker.UserIDString),
                                        _config.Info.ChatName,
                                        "ServerRewards points x " + randomReward));
                            }
                            else
                            {
                                inv?.GiveItem(
                                    ItemManager.CreateByName(_config.RewardInfo.RewardFixing,
                                        _config.RewardInfo.RewardFixingAmount), inv.containerMain);
                                SendReply(attacker, string.Format(
                                    lang.GetMessage("Rewarded", this, attacker.UserIDString),
                                    _config.Info.ChatName, _config.RewardInfo.RewardFixing + " x " + _config.RewardInfo.RewardFixingAmount));
                            }

                            break;
                        default:
                            var item = ItemManager.CreateByName(data.Key,
                                randomReward);
                            if (item != null)
                            {
                                inv?.GiveItem(item, inv.containerMain);
                                SendReply(attacker,
                                    string.Format(lang.GetMessage("Rewarded", this, attacker.UserIDString),
                                        _config.Info.ChatName,
                                        item.info.displayName.english + " x " + item.amount));
                            }
                            else
                            {
                                PrintError($"Failed to create item...{rand.Key}");
                            }

                            break;
                    }
                }
            }
            else
            {
                switch ((_config.RewardInfo.RewardFixing).ToLower())
                {
                    case "karma":
                        if (KarmaSystem != null && KarmaSystem.IsLoaded)
                        {
                            var player = covalence.Players.FindPlayerById(attacker.UserIDString);
                            KarmaSystem.Call("AddKarma", player, _config.RewardInfo.RewardFixingAmount);
                            SendReply(attacker,
                                string.Format(lang.GetMessage("Rewarded", this, attacker.UserIDString),
                                    _config.Info.ChatName,
                                    "Karma point x " + _config.RewardInfo.RewardFixingAmount));
                        }
                        else
                        {
                            inv?.GiveItem(
                                ItemManager.CreateByName(_config.RewardInfo.RewardFixing,
                                    _config.RewardInfo.RewardFixingAmount), inv.containerMain);
                            SendReply(attacker, string.Format(lang.GetMessage("Rewarded", this, attacker.UserIDString),
                                _config.Info.ChatName,
                                _config.RewardInfo.RewardFixing + " x " +
                                _config.RewardInfo.RewardFixingAmount));
                        }

                        break;
                    case "money":
                        if (Economics != null && Economics.IsLoaded)
                        {
                            Economics.CallHook("Deposit", attacker.userID,
                                _config.RewardInfo.RewardFixingAmount);
                            SendReply(attacker,
                                string.Format(lang.GetMessage("Rewarded", this, attacker.UserIDString),
                                    _config.Info.ChatName,
                                    "money x " + _config.RewardInfo.RewardFixingAmount));
                        }

                        break;
                    case "serverreward":
                        if (ServerRewards != null && ServerRewards.IsLoaded)
                        {
                            ServerRewards.CallHook("AddPoints", attacker.userID,
                                _config.RewardInfo.RewardFixingAmount);

                            SendReply(attacker,
                                string.Format(lang.GetMessage("Rewarded", this, attacker.UserIDString),
                                    _config.Info.ChatName,
                                    "ServerRewards points x " + _config.RewardInfo.RewardFixingAmount));
                        }

                        break;
                    default:
                        var item = ItemManager.CreateByName(_config.RewardInfo.RewardFixing,
                            _config.RewardInfo.RewardFixingAmount);
                        if (item != null)
                        {
                            inv?.GiveItem(item, inv.containerMain);
                            SendReply(attacker,
                                string.Format(lang.GetMessage("Rewarded", this, attacker.UserIDString),
                                    _config.Info.ChatName,
                                    item.info.displayName.english + " x " + item.amount));
                        }
                        else
                        {
                            PrintError($"Failed to create item...{_config.RewardInfo.RewardFixing}");
                        }

                        break;
                }
            }

            _eventstart?.Destroy();
            _eventstart = null;
            _runningman = null;
            Runlog("timer eventstart stopped");
            _eventpause?.Destroy();

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUi(player);
                DestroyCountdownUi(player);
            }

            _eventpause = timer.Once(60 * _config.Info.PauseeventTime, () => Startevent());
            _LastStartedEvent = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
        }

        #endregion

        #region General function
        private bool HasAccess(BasePlayer player, string permissionName)
        {
            if (player.net.connection.authLevel > 1) return true;
            return permission.UserHasPermission(player.userID.ToString(), permissionName);
        }

        private void CheckTime()
        {
            if (DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds >= _config.TimeRange.StartWarTime &&
                DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds < 24 ||
                DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds >= 0 &&
                DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds < _config.TimeRange.EndWarTime)
            {
                if (!_eventStarted)
                {
                    _eventpause = timer.Once(60 * _config.Info.PauseeventTime, () => Startevent());
                    _eventStarted = true;
                }
            }
            else
            {
                if (_eventStarted)
                {
                    _eventStarted = false;
                    DestroyEvent();
                }

                _eventpause = timer.Once(20, CheckTime);
            }
        }

        private void LoadSavedData()
        {
            _savedReward = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Dictionary<string, RewardData>>>(Name);
            if (_savedReward.Count == 0)
            {
                _savedReward["runner"] = new Dictionary<string, RewardData>
                {
                    {
                        "Karma", new RewardData
                        {
                            RewardItems = new Dictionary<string, ValueAmount>
                            {
                                {
                                    "Karma", new ValueAmount
                                    {
                                        MinValue = 0,
                                        MaxValue = 1
                                    }
                                }
                            }
                        }
                    },
                    {
                        "ServerReward", new RewardData
                        {
                            RewardItems = new Dictionary<string, ValueAmount>
                            {
                                {
                                    "serverreward", new ValueAmount
                                    {
                                        MinValue = 0,
                                        MaxValue = 1
                                    }
                                }
                            }
                        }
                    },
                    {
                        "build", new RewardData
                        {
                            RewardItems = new Dictionary<string, ValueAmount>
                            {
                                {
                                    "wood", new ValueAmount
                                    {
                                        MinValue = 1000,
                                        MaxValue = 10000
                                    }
                                },
                                {
                                    "stones", new ValueAmount
                                    {
                                        MinValue = 1000,
                                        MaxValue = 10000
                                    }
                                }
                            }
                        }
                    }
                };
                _savedReward["killer"] = new Dictionary<string, RewardData>
                {
                    {
                        "Karma", new RewardData
                        {
                            RewardItems = new Dictionary<string, ValueAmount>
                            {
                                {
                                    "Karma", new ValueAmount
                                    {
                                        MinValue = 0,
                                        MaxValue = 1
                                    }
                                }
                            }
                        }
                    },
                    {
                        "ServerReward", new RewardData
                        {
                            RewardItems = new Dictionary<string, ValueAmount>
                            {
                                {
                                    "serverreward", new ValueAmount
                                    {
                                        MinValue = 0,
                                        MaxValue = 1
                                    }
                                }
                            }
                        }
                    },
                    {
                        "build", new RewardData
                        {
                            RewardItems = new Dictionary<string, ValueAmount>
                            {
                                {
                                    "wood", new ValueAmount
                                    {
                                        MinValue = 1000,
                                        MaxValue = 10000
                                    }
                                },
                                {
                                    "stones", new ValueAmount
                                    {
                                        MinValue = 1000,
                                        MaxValue = 10000
                                    }
                                }
                            }
                        }
                    }
                };
                PrintWarning("Failed to load data file, generating a new one...");
            }

            SaveLoadedData();
        }

        private void SaveLoadedData()
        {
            try
            {
                Interface.Oxide.DataFileSystem.WriteObject(Name, _savedReward);
            }
            catch (Exception)
            {
                PrintWarning("Failed to save data file.");
            }
        }

        private void Startevent(string playerId = null)
        {
            if (_eventpause != null)
            {
                _eventpause.Destroy();
                _runningman = null;
            }

            if (_eventstart != null)
            {
                _eventstart.Destroy();
                _runningman = null;
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUi(player);
            }

            if (BasePlayer.activePlayerList != null)
            {

                if (playerId != null)
                {
                    var player = BasePlayer.Find(playerId);

                    if (player != null)
                    {
                        _runningman = player;

                        Runlog("Running man: " + _runningman.displayName);
                        BroadcastChat(string.Format(lang.GetMessage("StartEventRunner", this), _config.Info.ChatName, _runningman.displayName));

                        _eventstart = timer.Once(60 * _config.Info.StarteventTime, Runningstop);
                        _LastStartedEvent = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
                        return;
                    }
                    else
                    {
                        BroadcastChat(string.Format(lang.GetMessage("NotEnoughPlayers", this), _config.Info.ChatName));
                        _eventpause?.Destroy();
                        _eventpause = timer.Once(60 * _config.Info.PauseeventTime, () => Startevent());
                        _LastStartedEvent = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
                        return;
                    }
                }

                var auth = _config.Info.Excludedauthlevel;
                var t = auth == 0 ? BasePlayer.activePlayerList : BasePlayer.activePlayerList.Where(x => x.net.connection.authLevel < auth);
                var enumerable = t.ToList();

                if (enumerable.Count >= _config.Info.Count && enumerable.Count > 0)
                {
                    var basePlayers = t as BasePlayer[] ?? enumerable.ToArray();
                    var randI = _rnd.Next(0, basePlayers.Length);
                    _runningman = basePlayers[randI];

                    Runlog("Running man: " + _runningman.displayName);
                    BroadcastChat(string.Format(lang.GetMessage("StartEventRunner", this), _config.Info.ChatName, _runningman.displayName));

                    _eventstart = timer.Once(60 * _config.Info.StarteventTime, Runningstop);
                    _LastStartedEvent = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
                }
                else
                {
                    BroadcastChat(string.Format(lang.GetMessage("NotEnoughPlayers", this), _config.Info.ChatName));
                    _eventpause?.Destroy();
                    _eventpause = timer.Once(60 * _config.Info.PauseeventTime, () => Startevent());
                    _LastStartedEvent = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
                }
            }
        }

        private void Runningstop()
        {
            Runlog("Running man - " + _runningman.displayName + " ran away from the chase and received as a reward!");

            BroadcastChat(string.Format(lang.GetMessage("RunnerSaved", this), _config.Info.ChatName, _runningman.displayName));

            var inv = _runningman.inventory;
            if (_config.RewardInfo.Random)
            {
                if (_savedReward?["runner"] == null)
                {
                    PrintWarning("Reward list is empty, please add items");
                    inv?.GiveItem(ItemManager.CreateByName(_config.RewardInfo.RewardFixing, _config.RewardInfo.RewardFixingAmount), inv.containerMain);
                    return;
                }

                Runlog("random");
                var rand = _savedReward["runner"].ElementAt(_rnd.Next(0, _savedReward["runner"].Count));
                foreach (var data in rand.Value.RewardItems)
                {
                    var randomReward = _rnd.Next(data.Value.MinValue, data.Value.MaxValue);
                    switch (data.Key.ToLower())
                    {
                        case "karma":
                            if (KarmaSystem != null && KarmaSystem.IsLoaded)
                            {
                                var player = covalence.Players.FindPlayerById(_runningman.UserIDString);
                                KarmaSystem.Call("AddKarma", player, (double)randomReward);
                                SendReply(_runningman,
                                    string.Format(lang.GetMessage("Rewarded", this, _runningman.UserIDString),
                                        _config.Info.ChatName, data.Key + " x " + randomReward));
                            }
                            else
                            {
                                inv?.GiveItem(
                                    ItemManager.CreateByName(_config.RewardInfo.RewardFixing,
                                        _config.RewardInfo.RewardFixingAmount), inv.containerMain);
                                SendReply(_runningman, string.Format(
                                    lang.GetMessage("Rewarded", this, _runningman.UserIDString),
                                    _config.Info.ChatName, $"{_config.RewardInfo.RewardFixing} x {_config.RewardInfo.RewardFixingAmount}"));
                            }

                            break;
                        case "money":
                            if (Economics != null && Economics.IsLoaded)
                            {
                                Economics?.CallHook("Deposit", _runningman.userID,
                                    randomReward);
                                SendReply(_runningman,
                                    string.Format(lang.GetMessage("Rewarded", this, _runningman.UserIDString),
                                        _config.Info.ChatName, "money x " + randomReward));
                            }
                            else
                            {
                                inv?.GiveItem(
                                    ItemManager.CreateByName(_config.RewardInfo.RewardFixing,
                                        _config.RewardInfo.RewardFixingAmount), inv.containerMain);
                                SendReply(_runningman, string.Format(
                                    lang.GetMessage("Rewarded", this, _runningman.UserIDString),
                                    _config.Info.ChatName, _config.RewardInfo.RewardFixing +
                                                                            " x " +
                                                                            _config.RewardInfo.RewardFixingAmount));
                            }

                            break;
                        case "serverreward":
                            if (ServerRewards != null && ServerRewards.IsLoaded)
                            {
                                ServerRewards?.CallHook("AddPoints", _runningman.userID, randomReward);
                                SendReply(_runningman,
                                    string.Format(lang.GetMessage("Rewarded", this, _runningman.UserIDString),
                                        _config.Info.ChatName,
                                        "ServerRewards points x " + randomReward));
                            }
                            else
                            {
                                inv?.GiveItem(
                                    ItemManager.CreateByName(_config.RewardInfo.RewardFixing,
                                        _config.RewardInfo.RewardFixingAmount), inv.containerMain);
                                SendReply(_runningman, string.Format(
                                    lang.GetMessage("Rewarded", this, _runningman.UserIDString),
                                    _config.Info.ChatName, _config.RewardInfo.RewardFixing +
                                                                            " x " +
                                                                            _config.RewardInfo.RewardFixingAmount));
                            }

                            break;
                        default:
                            var item = ItemManager.CreateByName(data.Key,
                                randomReward);
                            if (item != null)
                            {
                                inv?.GiveItem(item, inv.containerMain);
                                SendReply(_runningman,
                                    string.Format(lang.GetMessage("Rewarded", this, _runningman.UserIDString),
                                        _config.Info.ChatName,
                                        item.info.displayName.english + " x " + item.amount));
                            }
                            else
                            {
                                PrintError($"Failed to create item...{rand.Key}");
                            }

                            break;
                    }
                }
            }
            else
            {
                inv?.GiveItem(ItemManager.CreateByName(_config.RewardInfo.RewardFixing,
                    _config.RewardInfo.RewardFixingAmount), inv.containerMain);
            }

            _eventstart.Destroy();
            _eventstart = null;
            _runningman = null;
            Runlog("timer eventstart stopped");
            _eventpause?.Destroy();

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUi(player);
                DestroyCountdownUi(player);
            }

            _eventpause = timer.Once(60 * _config.Info.PauseeventTime, () => Startevent());
            _LastStartedEvent = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
        }

        private void BroadcastChat(string msg = null)
        {
            foreach (var player in BasePlayer.activePlayerList) SendReply(player, msg ?? " ", "");
        }

        private void Runlog(string text)
        {
            Puts("[EVENT] +--------------- RUNNING MAN -----------------");
            Puts("[EVENT] | " + text);
            Puts("[EVENT] +---------------------------------------------");
        }

        private void SendHelpText(BasePlayer player)
        {
            player.ChatMessage(lang.GetMessage("RunCommandHelp", this, player.UserIDString));
            var authlevel = player.net.connection.authLevel;
            if (authlevel >= _config.Info.AuthLevel)
            {
                player.ChatMessage(lang.GetMessage("AdminCommandHelp", this, player.UserIDString));
                player.ChatMessage(lang.GetMessage("AdminAddCommandHelp", this, player.UserIDString));
                player.ChatMessage(lang.GetMessage("AdminRemoveCommandHelp", this, player.UserIDString));
            }
        }

        private void DestroyEvent()
        {
            if (_eventpause != null)
            {
                _eventpause.Destroy();
                _eventpause = null;
                _runningman = null;
                Runlog("timer eventpause stopped");
            }

            if (_eventstart != null)
            {
                _eventstart.Destroy();
                _eventstart = null;
                _runningman = null;
                Runlog("timer eventstart stopped");
            }

            _ingameTimer?.Destroy();
            _compassRefresh?.Destroy();
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUi(player);
                DestroyCountdownUi(player);
            }
        }

        private void DestroyLeaveEvent()
        {
            if (_runningman != null)
            {
                Runlog("Player " + _runningman.displayName + " got scared and ran away!");
                BroadcastChat(string.Format(lang.GetMessage("RunnerLeaved", this),
                    _config.Info.ChatName, _runningman.displayName));
            }

            if (_eventpause != null)
            {
                _eventpause.Destroy();
                _eventpause = null;
                _runningman = null;
                Runlog("timer eventpause stopped");
            }

            if (_eventstart != null)
            {
                _eventstart.Destroy();
                _eventstart = null;
                _runningman = null;
                Runlog("timer eventstart stopped");
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUi(player);
            }

            Runlog("Running Man has stopped");
            _eventpause = timer.Once(60 * _config.Info.PauseeventTime, () => Startevent());
            _LastStartedEvent = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
        }

        #endregion

        #region Commands function
        [ChatCommand("run")]
        private void CmdRun(BasePlayer player, string cmd, string[] args)
        {
            if (!player)
                return;
            if (_runningman != null)
            {
                var xr = _runningman.transform.position.x;
                var zr = _runningman.transform.position.z;
                var xk = player.transform.position.x;
                var zk = player.transform.position.z;
                var dist = Math.Floor(Math.Sqrt(Math.Pow(xr - xk, 2) + Math.Pow(zr - zk, 2)));
                if (_config.Info.DisplayDistance)
                    SendReply(player,
                        string.Format(lang.GetMessage("RunnerDistance", this, player.UserIDString),
                            _config.Info.ChatName, _runningman.displayName, dist));
                else
                    SendReply(player,
                        string.Format(lang.GetMessage("RunnerDistance", this, player.UserIDString),
                            _config.Info.ChatName, _runningman.displayName, "unknown"));
                _time2 = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
                var time3 = _time2 - _LastStartedEvent;
                time3 = _eventstart.Delay - time3;
                time3 = Math.Floor(time3 / 60);
                SendReply(player,
                    string.Format(lang.GetMessage("UntilEndOfEvent", this, player.UserIDString),
                        _config.Info.ChatName, time3));
            }
            else
            {
                _time2 = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;

                var time3 = _time2 - _LastStartedEvent;
                if (_eventpause != null)
                {
                    time3 = _eventpause.Delay - time3;
                    time3 = Math.Floor(time3 / 60);
                    SendReply(player,
                        string.Format(lang.GetMessage("NotRunningEvent", this, player.UserIDString),
                            _config.Info.ChatName));
                    SendReply(player,
                        string.Format(lang.GetMessage("UntilStartOfEvent", this, player.UserIDString),
                            _config.Info.ChatName, time3));
                }
                else
                {
                    SendReply(player,
                        string.Format(lang.GetMessage("NotRunningEvent", this, player.UserIDString),
                            _config.Info.ChatName));
                }
            }
        }

        [ChatCommand("eventon")]
        private void CmdEvent(BasePlayer player, string cmd, string[] args)
        {
            if (!HasAccess(player, "runningman.admin"))
            {
                SendReply(player,
                    string.Format(lang.GetMessage("NoPerm", this, player.UserIDString), _config.Info.ChatName));
                return;
            }

            if (_config.TimeRange.TimeRange)
            {
                _ingameTimer = timer.Once(20, CheckTime);
                if (DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds >= _config.TimeRange.StartWarTime &&
                    DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds < 24 ||
                    DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds >= 0 &&
                    DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds < _config.TimeRange.EndWarTime)
                {
                    _time2 = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;

                    var time3 = _time2 - _LastStartedEvent;
                    _NextEvent = _eventpause.Delay - time3;
                }
                else
                {
                    _NextEvent = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day,
                                         _config.TimeRange.StartWarTime, 0, 0).Subtract(new DateTime(1970, 1, 1))
                                     .TotalSeconds - DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
                }
            }
            else
            {
                if(args.Length == 1)
                    Startevent(args[0]);
                else
                    Startevent();
                _LastStartedEvent = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
            }
        }

        [ConsoleCommand("eventon")]
        private void CcmdEvent(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            if (arg.Player().net.connection.authLevel >= _config.Info.AuthLevel)
            {
                if (_eventpause != null)
                {
                    _eventpause.Destroy();
                    _runningman = null;
                    Runlog("timer eventpause stopped");
                }

                if (_eventstart != null)
                {
                    _eventstart.Destroy();
                    _runningman = null;
                    Runlog("timer eventstart stopped");
                }

                var onlineplayers = BasePlayer.activePlayerList;
                var randI = _rnd.Next(0, onlineplayers.Count);
                _runningman = onlineplayers[randI];
                Runlog("Running man: " + _runningman.displayName);
                BroadcastChat(string.Format(lang.GetMessage("StartEventRunner", this),
                    _config.Info.ChatName, _runningman.displayName));
                _eventstart = timer.Once(60 * _config.Info.StarteventTime, Runningstop);
                _LastStartedEvent = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
            }
            else
            {
                arg.ReplyWith(string.Format(lang.GetMessage("NoPerm", this, arg.Player().UserIDString),
                    _config.Info.ChatName));
            }
        }

        [ConsoleCommand("eventoff")]
        private void CmdEventOf(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            if (arg.Player().net.connection.authLevel >= _config.Info.AuthLevel)
                DestroyEvent();
            else
                arg.ReplyWith(string.Format(lang.GetMessage("NoPerm", this, arg.Player().UserIDString),
                    _config.Info.ChatName));
        }

        [ChatCommand("eventoff")]
        private void CmdEventOff(BasePlayer player, string cmd, string[] args)
        {
            if (!HasAccess(player, "runningman.admin"))
            {
                SendReply(player,
                    string.Format(lang.GetMessage("NoPerm", this, player.UserIDString), _config.Info.ChatName));
                return;
            }

			DestroyEvent();
			
			Runlog("Running Man has stopped");
            SendReply(player,
                string.Format(lang.GetMessage("EventStopped", this, player.UserIDString),
                    _config.Info.ChatName));
        }

        [ChatCommand("running")]
        private void CmdChat(BasePlayer player, string cmd, string[] args)
        {
            if (!HasAccess(player, "runningman.admin"))
            {
                SendReply(player,
                    string.Format(lang.GetMessage("NoPerm", this, player.UserIDString), _config.Info.ChatName));
                return;
            }

            if (args == null)
            {
                SendHelpText(player);
                return;
            }

            string action;
            string package;
            string item;
            string type;

            if (args.Length >= 0 && args.Length <= 4)
            {
                SendHelpText(player);
                return;
            }

            if (args.Length < 5)
            {
                type = args[0].ToLower();
                action = args[1].ToLower();
                package = args[2].ToLower();
                item = args[3].ToLower();
                if (action == "remove")
                {
                    if (type == "k" || type == "killer")
                        type = "killer";
                    else
                        type = "runner";
                    switch (args.Length)
                    {
                        case 2:
                            if (_savedReward[type].ContainsKey(package))
                                _savedReward[type].Remove(package);
                            else
                                SendReply(player,
                                    string.Format(lang.GetMessage("PackageDontExist", this, player.UserIDString),
                                        _config.Info.ChatName));
                            break;
                        case 3:
                            if (_savedReward.ContainsKey(package))
                                if (_savedReward[type][package].RewardItems.ContainsKey(item))
                                {
                                    _savedReward[type][package].RewardItems.Remove(item);
                                    SendReply(player,
                                        string.Format(lang.GetMessage("ItemRemoved", this, player.UserIDString),
                                            _config.Info.ChatName, item));
                                }
                                else
                                {
                                    SendReply(player,
                                        string.Format(
                                            lang.GetMessage("MissingItemFromPackage", this, player.UserIDString),
                                            _config.Info.ChatName));
                                }
                            else
                                SendReply(player,
                                    string.Format(lang.GetMessage("PackageDontExist", this, player.UserIDString),
                                        _config.Info.ChatName));

                            break;
                    }
                }
                else
                {
                    SendHelpText(player);
                }
            }

            if (args.Length == 6)
            {
                type = args[0].ToLower();
                action = args[1].ToLower();
                package = args[2].ToLower();
                item = args[3].ToLower();
                var minamount = int.Parse(args[4]);
                var maxamount = int.Parse(args[5]);

                if (action == "add")
                {
                    if (type == "k" || type == "killer")
                        type = "killer";
                    else
                        type = "runner";
                    if (_savedReward[type].ContainsKey(package))
                    {
                        if (_savedReward[type][package].RewardItems.ContainsKey(item))
                        {
                            SendReply(player,
                                string.Format(lang.GetMessage("ItemExist", this, player.UserIDString),
                                    _config.Info.ChatName));
                            return;
                        }

                        _savedReward[type][package].RewardItems.Add(item, new ValueAmount
                        {
                            MinValue = minamount,
                            MaxValue = maxamount
                        });
                        SendReply(player,
                            string.Format(lang.GetMessage("ItemAdded", this, player.UserIDString),
                                _config.Info.ChatName, item, package));
                        SaveLoadedData();
                    }
                    else
                    {
                        _savedReward[type].Add(package, new RewardData
                        {
                            RewardItems = new Dictionary<string, ValueAmount>
                            {
                                {
                                    item, new ValueAmount
                                    {
                                        MinValue = minamount,
                                        MaxValue = maxamount
                                    }
                                }
                            }
                        });
                        SendReply(player,
                            string.Format(lang.GetMessage("PackageAdded", this, player.UserIDString),
                                _config.Info.ChatName, package));
                        SaveLoadedData();
                    }
                }
                else
                {
                    SendHelpText(player);
                }
            }
        }

        #endregion

        #region Compass/countdown UI

        private void DestroyUi(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, panelString);
        }

        private void RefreshUi()
        {
            foreach (var player in BasePlayer.activePlayerList)
                if (player != _runningman)
                {

                    if (_runningman == null && !_config.CompassUiInfo.Disabled)
                    {
                        DestroyUi(player);
                        CreateUi(player);
                    }
                    if (_runningman != null)
                    {
                        DestroyUi(player);
                        CreateUi(player);
                    }
                }
        }

        private void CreateUi(BasePlayer player)
        {
            var panel = new CuiElementContainer
            {
                {
                    new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = _config.CompassUiInfo.AnchorMin,
                            AnchorMax = _config.CompassUiInfo.AnchorMax
                        }
                    },
                    new CuiElement().Parent, panelString
                },
                {
                    new CuiLabel
                    {
                        RectTransform =
                        {
                            AnchorMax = "1 1",
                            AnchorMin = "0 0"
                        },
                        Text =
                        {
                            Text = GetDirection(player),
                            Align = TextAnchor.MiddleCenter,
                            Color = "0 0 0 1"
                        }
                    },
                    panelString
                }
            };

            CuiHelper.AddUi(player, panel);
        }

        private string GetDirection(BasePlayer player)
        {
            if (_runningman == null)
                return _config.CompassUiInfo.RunnerDirection.None;

            var vect = _runningman.transform.position;
            var pos = player.transform.position;

            if (pos.x < vect.x && pos.z < vect.z)
                return _config.CompassUiInfo.RunnerDirection.NorthEast;
            if (pos.x > vect.x && pos.z < vect.z)
                return _config.CompassUiInfo.RunnerDirection.NorthWest;
            if (pos.x < vect.x && pos.z > vect.z)
                return _config.CompassUiInfo.RunnerDirection.SouthEast;
            if (pos.x > vect.x && pos.z > vect.z)
                return _config.CompassUiInfo.RunnerDirection.SouthWest;


            return _config.CompassUiInfo.RunnerDirection.None;
        }

        private void CreateCountdownUi(BasePlayer player)
        {
            double time3;
            string texts = "";
            if (_runningman == null)
            {
                if (_config.TimeRange.TimeRange)
                {
                    if (DateTime.Now.Hour < _config.TimeRange.StartWarTime)
                    {
                        if (_eventpause != null)
                        {
                            time3 = _NextEvent - DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
                            var t = TimeSpan.FromSeconds(time3);
                            string answer = t.Hours != 0 ? $"{t.Hours:D2}H:{t.Minutes:D2}m:{t.Seconds:D2}s" : $"{t.Minutes:D2}m:{t.Seconds:D2}s";
                            texts = $"Next event in\n{answer}";
                        }
                    }
                }
                else
                {
                    _time2 = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;

                    time3 = _time2 - _LastStartedEvent;

                    if (_eventpause != null)
                    {
                        time3 = _eventpause.Delay - time3;

                        var t = TimeSpan.FromSeconds(time3);

                        string answer = t.Hours != 0 ? $"{t.Hours:D2}H:{t.Minutes:D2}m:{t.Seconds:D2}s" : $"{t.Minutes:D2}m:{t.Seconds:D2}s";
                        texts = $"Next event in\n{answer}";
                    }
                }
            }
            else
            {
                if ((int)_LastStartedEvent == 0)
                    return;

                _time2 = DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
                time3 = _time2 - _LastStartedEvent;
                if (_eventstart != null) time3 = _eventstart.Delay - time3;

                var t = TimeSpan.FromSeconds(time3);

                string answer = t.Hours != 0 ? $"{t.Hours:D2}H:{t.Minutes:D2}m:{t.Seconds:D2}s" : $"{t.Minutes:D2}m:{t.Seconds:D2}s";
                texts = $"Time left\n{answer}";
            }

            var panel = new CuiElementContainer
            {
                {
                    new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = _config.CountdownUiInfo.AnchorMin,
                            AnchorMax = _config.CountdownUiInfo.AnchorMax
                        }
                    },
                    new CuiElement().Parent, panelCountString
                }
            };


            panel.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMax = "1 1",
                    AnchorMin = "0 0"
                },
                Text =
                {
                    Text = texts,
                    Align = TextAnchor.MiddleCenter,
                    Color = "0 0 0 1"
                }
            }, panelCountString);

            if (_runningman == null && !_config.CountdownUiInfo.DisableNoRunner)
            {
                CuiHelper.AddUi(player, panel);
                return;
            }

            if (_runningman != null && !_config.CountdownUiInfo.DisableRunnerOn)
            {
                CuiHelper.AddUi(player, panel);
            }
        }

        private void DestroyCountdownUi(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, panelCountString);
        }

        private void RefreshCountdownUi()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyCountdownUi(player);
                CreateCountdownUi(player);
            }
        }

        #endregion
    }
}

// --- End of file: RunningMan.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/reserved ---
// --- Original File Path: R/Reserved/Reserved.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Reserved", "Wulf/lukespragg", "2.0.3")]
    [Description("Allows players with permission to always be able to connect")]
    public class Reserved : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Always allow admin to connect (true/false)")]
            public bool AlwaysAllowAdmin { get; set; } = false;

            [JsonProperty(PropertyName = "Always use reserved slot if player has permission (true/false)")]
            public bool AlwaysUseSlot { get; set; } = false;

            [JsonProperty(PropertyName = "Dynamic slots based on players with permission (true/false)")]
            public bool DynamicSlots { get; set; } = false;

            [JsonProperty(PropertyName = "Kick other players for players with permission (true/false)")]
            public bool KickForReserved { get; set; } = true;

            [JsonProperty(PropertyName = "Number of slots to reserve (if dynamic slots not enabled)")]
            public int ReservedSlots { get; set; } = 5;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            PrintWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Localization

        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["KickedForReserved"] = "Kicked for player with reserved slot",
                ["ReservedSlotsOnly"] = "Only reserved slots available",
                ["SlotsNowAvailable"] = "{0} slot(s) now available"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string permSlot = "reserved.slot";

        private int slotsAvailable;

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permSlot, this);

            slotsAvailable = Math.Min(config.ReservedSlots, server.MaxPlayers);
            int slotCount = players.All.Count(player => player.HasPermission(permSlot));

            if (config.DynamicSlots)
            {
                int slotsUsed = players.Connected.Count(player => player.HasPermission(permSlot));
                slotsAvailable = Math.Min(slotCount - slotsUsed, server.MaxPlayers);
            }
            else
            {
                Unsubscribe(nameof(OnServerSave));
                Unsubscribe(nameof(OnUserPermissionRevoked));
                Unsubscribe(nameof(OnUserPermissionRevoked));
            }

            Log(Lang("SlotsNowAvailable", null, slotsAvailable.ToString()));

            if (slotsAvailable >= server.MaxPlayers)
            {
                LogWarning($"Slots available ({slotsAvailable}) is greater than or equal to max players ({server.MaxPlayers})");
            }
        }

        private void OnUserPermissionGranted(string id, string perm)
        {
            if (perm == permSlot && config.DynamicSlots && permission.UserHasPermission(id, permSlot))
            {
                slotsAvailable++;
                Log(Lang("SlotsNowAvailable", null, slotsAvailable.ToString()));
            }
        }

        private void OnUserPermissionRevoked(string id, string perm)
        {
            if (perm == permSlot && config.DynamicSlots && permission.UserHasPermission(id, permSlot))
            {
                slotsAvailable--;
                Log(Lang("SlotsNowAvailable", null, slotsAvailable.ToString()));
            }
        }

        private void OnServerSave() => SaveConfig();

        #endregion Initialization

        #region Reserved Check

        private object CanUserLogin(string name, string id, string ip)
        {
            if (config.AlwaysAllowAdmin)
            {
                IPlayer player = players.FindPlayerById(id);

                if (player != null && player.IsAdmin)
                {
                    Log($"{name} ({id}) is admin, bypassing reserved slot(s)");
                    return null;
                }
            }

            int currentPlayers = players.Connected.Count();
            int maxPlayers = server.MaxPlayers;

            if (slotsAvailable > 0)
            {
                if (maxPlayers - currentPlayers <= slotsAvailable)
                {
                    if (!permission.UserHasPermission(id, permSlot))
                    {
                        return Lang("ReservedSlotsOnly", id);
                    }

                    if (config.KickForReserved && currentPlayers == maxPlayers)
                    {
                        IPlayer[] targets = players.Connected.ToArray();
                        IPlayer target = targets.FirstOrDefault(p => !p.HasPermission(permSlot) && p.Id != id);

                        if (target != null)
                        {
                            target.Kick(Lang("KickedForReserved", target.Id));
                        }
                    }
                }

                if (config.AlwaysUseSlot)
                {
                    slotsAvailable--;
                    Log(Lang("SlotsNowAvailable", null, slotsAvailable.ToString()));
                }
            }

            return null;
        }

        private void OnUserDisconnected(IPlayer player, string reason)
        {
            if (config.AlwaysUseSlot && permission.UserHasPermission(player.Id, permSlot))
            {
                slotsAvailable--;
                Log(Lang("SlotsNowAvailable", null, slotsAvailable.ToString()));
            }
        }

        #endregion Reserved Check

        #region Helper Methods

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        #endregion Helper Methods
    }
}


// --- End of file: Reserved.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/resource-vip-spawns ---
// --- Original File Path: R/ResourceVIPSpawns/ResourceVIPSpawns.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using UnityEngine;
using System;

namespace Oxide.Plugins
{
    [Info("Resource VIP Spawns", "Daano123", "1.0.0")]
    [Description("Resource VIP Spawns is a plugin that allows players with the correct permissions to set a spawn point for resources that respawn every X seconds")]
    class ResourceVIPSpawns : CovalencePlugin
    {
        #region Variables
        Dictionary<string, Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer>> SpawnPointsSet = new Dictionary<string, Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer>>();

        const string Admin_Perm = "resourcevipspawns.admin";
        const string Spawnable_Perm = "resourcevipspawns.spawnable";

        readonly string SulfurAssetLocation = "assets/bundled/prefabs/autospawn/resource/ores/sulfur-ore.prefab";
        readonly string MetalAssetLocation = "assets/bundled/prefabs/autospawn/resource/ores/metal-ore.prefab";
        readonly string StoneAssetLocation = "assets/bundled/prefabs/autospawn/resource/ores/stone-ore.prefab";
        #endregion

        #region Configuaration
        protected override void LoadDefaultConfig()
        {
            LogWarning("Creating a new configuration file");
            Config["CooldownSulfurSpawn"] = 300;
            Config["CooldownMetalSpawn"] = 300;
            Config["CooldownStoneSpawn"] = 300;
            Config["AllowedOutsideBuildingPrivilege"] = false;
            Config["EnableSpawnablesWhenOffline"] = false;
            Config["DebugMode"] = false;
        }
        #endregion

        #region LanguageAPI
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You do not have access to that command!",
                ["InvalidInput"] = "Please enter valid command syntax!",
                ["OutdoorsBlocked"] = "You cannot set resource spawnpoints outside of building privelige areas",
                ["SpawnPointAlreadySet"] = "You already have a spawnpoint set for this resource!",
                ["RemoveAll"] = "Your resource spawn data has been wiped succesfully!",
                ["RemoveIndividual"] = "Your resource spawn data has been wiped succesfully for this ore type!",
                ["Info"] = "<br>Set up to 3 spawn points for resources with this plugin. <br>Commands: <br>/rs add/remove sulfur/metal/stone <br>Example: <br>/rs add sulfur - sets spawn point for sulfur" +
                " <br>/rs remove sulfur - removes spawn point for sulfur <br>/rs remove all - wipes all spawn points",
                ["AdminInfo"] = "<br>Currect respawn timers: <br>Sulfur - {0}<br>Metal - {1}<br>Stone - {2}",
                ["OutOfReach"] = "Please look closer to the ground!",
                ["Spawned"] = "The following ore spawnpoint has been set: ",
                ["Prefix"] = "<color=#ff6100>[Resource VIP] </color>"
            }, this);
        }
        #endregion

        #region Hooks
        private void Init()
        {
            permission.RegisterPermission(Admin_Perm, this);
            permission.RegisterPermission(Spawnable_Perm, this);
        }
        #endregion

        #region Commands
        [Command("rs")]
        private void Spawn(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                //SpawnHandler.Instance.EnforceLimits
                return;
            }

            string prefix = lang.GetMessage("Prefix", this, player.Id);

            if (args.Length < 1)
            {
                player.Reply(prefix + lang.GetMessage("Info", this, player.Id));
                return;
            }

            switch (args[0].ToLower())
            {
                case "add":
                    {
                        #region addSpawns
                        switch (args[1].ToLower())
                        {
                            case "sulfur":
                                {
                                    if (player.HasPermission(Spawnable_Perm))
                                        SpawnEntity(player, SulfurAssetLocation);
                                    else
                                        player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                                    break;
                                }
                            case "metal":
                                {
                                    if (player.HasPermission(Spawnable_Perm))
                                        SpawnEntity(player, MetalAssetLocation);
                                    else
                                        player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                                    break;
                                }
                            case "stone":
                                {
                                    if (player.HasPermission(Spawnable_Perm))
                                        SpawnEntity(player, StoneAssetLocation);
                                    else
                                        player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                                    break;
                                }
                            default:
                                player.Reply(prefix + lang.GetMessage("InvalidInput", this, player.Id));
                                break;
                        }
                        break;
                        #endregion
                    }
                case "remove":
                    {
                        #region removeSpawns
                        switch (args[1].ToLower())
                        {
                            case "all":
                                {
                                    if (player.HasPermission(Spawnable_Perm))
                                    {
                                        Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer> DestroyableTimers;

                                        SpawnPointsSet.TryGetValue(player.Id, out DestroyableTimers);
                                        if(DestroyableTimers.Item4 != null)
                                            DestroyableTimers.Item4.Destroy();
                                        if(DestroyableTimers.Item5 != null)
                                            DestroyableTimers.Item5.Destroy();
                                        if(DestroyableTimers.Item6 != null)
                                            DestroyableTimers.Item6.Destroy();
                                        SpawnPointsSet.Remove(player.Id);
                                        player.Reply(prefix + lang.GetMessage("RemoveAll", this, player.Id));
                                    }
                                    else 
                                        player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                                    break;
                                }
                            case "sulfur":
                                {
                                    if (player.HasPermission(Spawnable_Perm))
                                    {
                                        Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer> DestroyableTimers;

                                        SpawnPointsSet.TryGetValue(player.Id, out DestroyableTimers);
                                        DestroyableTimers.Item4.Destroy();
                                        SpawnPointsSet.Remove(player.Id);
                                        Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer> Data = new Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer>(new Vector3(0,0,0), DestroyableTimers.Item2,
                                            DestroyableTimers.Item3, null, DestroyableTimers.Item5, DestroyableTimers.Item6);
                                        SpawnPointsSet.Add(player.Id, Data);
                                        player.Reply(prefix + lang.GetMessage("RemoveIndividual", this, player.Id));
                                    }
                                    else
                                        player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                                    break;
                                }
                            case "metal":
                                {
                                    if (player.HasPermission(Spawnable_Perm))
                                    {
                                        Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer> DestroyableTimers;

                                        SpawnPointsSet.TryGetValue(player.Id, out DestroyableTimers);
                                        DestroyableTimers.Item5.Destroy();
                                        SpawnPointsSet.Remove(player.Id);
                                        Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer> Data = new Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer>(DestroyableTimers.Item1, new Vector3(0, 0, 0),
                                            DestroyableTimers.Item3, DestroyableTimers.Item4, null, DestroyableTimers.Item6);
                                        SpawnPointsSet.Add(player.Id, Data);
                                        player.Reply(prefix + lang.GetMessage("RemoveIndividual", this, player.Id));
                                    }
                                    else
                                        player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                                    break;
                                }
                            case "stone":
                                {
                                    if (player.HasPermission(Spawnable_Perm))
                                    {
                                        Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer> DestroyableTimers;

                                        SpawnPointsSet.TryGetValue(player.Id, out DestroyableTimers);
                                        DestroyableTimers.Item6.Destroy();
                                        SpawnPointsSet.Remove(player.Id);
                                        Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer> Data = new Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer>(DestroyableTimers.Item1, DestroyableTimers.Item2,
                                            new Vector3(0, 0, 0), DestroyableTimers.Item4, DestroyableTimers.Item5, null);
                                        SpawnPointsSet.Add(player.Id, Data);
                                        player.Reply(prefix + lang.GetMessage("RemoveIndividual", this, player.Id));
                                    }
                                    else
                                        player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                                    break;
                                }
                            default:
                                    player.Reply(prefix + lang.GetMessage("InvalidInput", this, player.Id));
                                    break;
                        }
                        break;
                        #endregion
                    }
                case "admin":
                    {
                        if (player.HasPermission(Admin_Perm))
                            player.Reply(prefix + string.Format(lang.GetMessage("AdminInfo", this, player.Id), float.Parse(Config["CooldownSulfurSpawn"].ToString()), float.Parse(Config["CooldownMetalSpawn"].ToString()), float.Parse(Config["CooldownStoneSpawn"].ToString())));
                        else
                            player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                        break;
                    }
                default:
                    player.Reply(prefix + lang.GetMessage("Info", this, player.Id));
                    break;
            }

        }
        #endregion

        #region Functions
        void SpawnEntity(IPlayer player, string entity_name)
        {
            BasePlayer PlayerObject = player.Object as BasePlayer;
            string prefix = lang.GetMessage("Prefix", this, player.Id);

            #region Raycast
            Vector3 ViewAdjust = new Vector3(0f, 1.5f, 0f);
            Vector3 position = PlayerObject.transform.position + ViewAdjust;
            Vector3 rotation = Quaternion.Euler(PlayerObject.serverInput.current.aimAngles) * Vector3.forward;
            int range = 10;

            RaycastHit hit;
            if (!Physics.Raycast(position, rotation, out hit, range))
            {
                player.Reply(prefix + lang.GetMessage("OutOfReach", this, player.Id));
                return;
            }
            #endregion

            #region Building Check
            if (!(bool)Config["AllowedOutsideBuildingPrivilege"] & !PlayerObject.IsBuildingAuthed())
            {
                player.Reply(prefix + lang.GetMessage("OutdoorsBlocked", this, player.Id));
                return;
            }
            #endregion

            #region Single Spawn Check
            switch (entity_name)
            {
                case "assets/bundled/prefabs/autospawn/resource/ores/sulfur-ore.prefab":
                    {
                        if (SpawnPointsSet.ContainsKey(player.Id))
                        {
                            Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer> vectors3;
                            SpawnPointsSet.TryGetValue(player.Id, out vectors3);
                            if (vectors3.Item1.x != 0 & vectors3.Item1.y != 0 & vectors3.Item1.z != 0)
                            { 
                                player.Reply(prefix + lang.GetMessage("SpawnPointAlreadySet", this, player.Id));
                                return;
                            }
                            Vector3 i1 = hit.point;
                            Vector3 i2 = vectors3.Item2;
                            Vector3 i3 = vectors3.Item3;
                            Timer t2 = vectors3.Item5;
                            Timer t3 = vectors3.Item6;
                            SpawnPointsSet.Remove(player.Id);
                            object timerObj = Config["CooldownSulfurSpawn"];
                            float timerTime = float.Parse(timerObj.ToString());
                            Timer t1 = TimerHandler(player, timerTime, entity_name, hit.point);
                            SpawnPointsSet.Add(player.Id, new Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer>(i1, i2, i3, t1, t2, t3));
                        }
                        else
                        {
                            object timerObj = Config["CooldownSulfurSpawn"];
                            float timerTime = float.Parse(timerObj.ToString());
                            Timer timer = TimerHandler(player, timerTime, entity_name, hit.point);
                            SpawnPointsSet.Add(player.Id, new Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer>(hit.point, new Vector3(0, 0, 0), new Vector3(0, 0, 0), timer, null, null));
                        }
                        break;
                    }
                case "assets/bundled/prefabs/autospawn/resource/ores/metal-ore.prefab":
                    {
                        if (SpawnPointsSet.ContainsKey(player.Id))
                        {
                            Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer> vectors3;
                            SpawnPointsSet.TryGetValue(player.Id, out vectors3);
                            if (vectors3.Item2.x != 0 & vectors3.Item2.y != 0 & vectors3.Item2.z != 0)
                            {
                                player.Reply(prefix + lang.GetMessage("SpawnPointAlreadySet", this, player.Id));
                                return;
                            }
                            Vector3 i1 = vectors3.Item1;
                            Vector3 i2 = hit.point;
                            Vector3 i3 = vectors3.Item3;
                            Timer t1 = vectors3.Item4;
                            Timer t3 = vectors3.Item6;

                            SpawnPointsSet.Remove(player.Id);
                            object timerObj = Config["CooldownMetalSpawn"];
                            float timerTime = float.Parse(timerObj.ToString());
                            Timer t2 = TimerHandler(player, timerTime, entity_name, hit.point);
                            SpawnPointsSet.Add(player.Id, new Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer>(i1, i2, i3, t1, t2, t3));
                        }
                        else
                        {
                            object timerObj = Config["CooldownMetalSpawn"];
                            float timerTime = float.Parse(timerObj.ToString());
                            Timer timer = TimerHandler(player, timerTime, entity_name, hit.point);
                            SpawnPointsSet.Add(player.Id, new Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer>(new Vector3(0, 0, 0), hit.point, new Vector3(0, 0, 0), null, timer, null));
                        }
                        break;
                    }
                case "assets/bundled/prefabs/autospawn/resource/ores/stone-ore.prefab":
                    {
                        if (SpawnPointsSet.ContainsKey(player.Id))
                        {
                            Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer> vectors3;
                            SpawnPointsSet.TryGetValue(player.Id, out vectors3);
                            if (vectors3.Item3.x != 0 & vectors3.Item3.y != 0 & vectors3.Item3.z != 0)
                            {
                                player.Reply(prefix + lang.GetMessage("SpawnPointAlreadySet", this, player.Id));
                                return;
                            }
                            Vector3 i1 = vectors3.Item1;
                            Vector3 i2 = vectors3.Item2;
                            Vector3 i3 = hit.point;
                            Timer t1 = vectors3.Item4;
                            Timer t2 = vectors3.Item6;
                            SpawnPointsSet.Remove(player.Id);
                            object timerObj = Config["CooldownStoneSpawn"];
                            float timerTime = float.Parse(timerObj.ToString());
                            Timer t3 = TimerHandler(player, timerTime, entity_name, hit.point);
                            SpawnPointsSet.Add(player.Id, new Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer>(i1, i2, i3, t1, t2, t3));
                        }
                        else
                        {
                            object timerObj = Config["CooldownStoneSpawn"];
                            float timerTime = float.Parse(timerObj.ToString());
                            Timer timer = TimerHandler(player, timerTime, entity_name, hit.point);
                            SpawnPointsSet.Add(player.Id, new Tuple<Vector3, Vector3, Vector3, Timer, Timer, Timer>(new Vector3(0, 0, 0), new Vector3(0, 0, 0), hit.point, null, null, timer));
                        }
                        break;
                    }
                default:
                    break;
            }
            #endregion
        }

        #region Timer Handler
        private Timer TimerHandler(IPlayer player, float timerTime, string entity_name, Vector3 hit)
        {
            string prefix = lang.GetMessage("Prefix", this, player.Id);
            Timer Cooldown = timer.Every(timerTime, () =>
            {
                if((bool)Config["EnableSpawnablesWhenOffline"] | player.IsConnected)
                {
                    BaseEntity Entity = GameManager.server.CreateEntity(entity_name, hit);
                    if (Entity)
                    {
                        Entity.Spawn();
                        //Debug Mode Logging
                        if(player.HasPermission(Admin_Perm) & (bool)Config["DebugMode"])
                            player.Reply(prefix + "Resource spawned " + Entity.ShortPrefabName);
                    }
                }
            });
            player.Reply(prefix + lang.GetMessage("Spawned", this, player.Id) + GameManager.server.CreateEntity(entity_name).ShortPrefabName);
            return Cooldown;
        }
        #endregion

        #endregion
    }
}

// --- End of file: ResourceVIPSpawns.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/random-wrapped-gift ---
// --- Original File Path: R/RandomWrappedGift/RandomWrappedGift.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("Random Wrapped Gift", "Ryz0r", "1.1.1")]
    [Description("Enables players with permission to receive a randomly wrapped gift in a configured interval.")]
    public class RandomWrappedGift : RustPlugin
    {
        private const string GifteePerm = "randomwrappedgift.giftee";
        private const string GifterPerm = "randomwrappedgift.gifter";
        public string EffectToUse = "assets/prefabs/misc/easter/painted eggs/effects/gold_open.prefab";
        private Random random = new Random();
        
        #region Config/Lang
        private Configuration _config;
        protected override void SaveConfig() => Config.WriteObject(_config);
        protected override void LoadDefaultConfig() => _config = new Configuration();

        private class Configuration
        {
            [JsonProperty(PropertyName = "Gift Items (Item Shortname)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> GiftItems = new Dictionary<string, int>
            {
                {"rifle.ak", 1},
                {"stones", 1500}
            };

            [JsonProperty(PropertyName = "Wrapped Gift Interval (Seconds)")]
            public float WrappedGiftInterval = 300f;

            [JsonProperty(PropertyName = "Play Effect When Opened?")]
            public bool EffectWhenOpened = true;
            
            [JsonProperty(PropertyName = "Give gift to sleepers with permissions?")]
            public bool GiftToSleepers = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPerm"] = "You do not have permissions to use this command.",
                ["Given"] = "You have given players gifts. Yay!",
                ["Gifted"] = "You have received a randomly wrapped gift. Enjoy!"
            }, this); 
        }
        #endregion
        
        private void CreateGift(BasePlayer bp)
        {
            var theItem = _config.GiftItems.ElementAt(random.Next(0, _config.GiftItems.Count));
            var createdItem = ItemManager.CreateByName(theItem.Key);
            
            var soonWrapped = ItemManager.CreateByItemID(204970153, 1);
            
            soonWrapped.contents.AddItem(createdItem.info, theItem.Value);
            bp.GiveItem(soonWrapped);
            bp.ChatMessage(lang.GetMessage("Gifted", this, bp.UserIDString));

            if (_config.EffectWhenOpened)
            {
                EffectNetwork.Send(new Effect(EffectToUse, bp.GetNetworkPosition(), Vector3.zero), bp.net.connection);
            }
        }
        
        
        private void Init()
        {
            AddCovalenceCommand("give", nameof(GiveGiftCommand));
            permission.RegisterPermission(GifteePerm, this);
            permission.RegisterPermission(GifterPerm, this);
        }

        private void OnServerInitialized()
        {
            GiveGifts();
            timer.Every(_config.WrappedGiftInterval, GiveGifts);
        }

        private void GiveGifts()
        {
            if (_config.GiftToSleepers)
            {
                foreach (var p in BasePlayer.allPlayerList)
                {
                    if (permission.UserHasPermission(p.UserIDString, GifteePerm))
                    {
                        CreateGift(p);
                    }
                }
            }
            else
            {
                foreach (var p in BasePlayer.activePlayerList)
                {
                    if (permission.UserHasPermission(p.UserIDString, GifteePerm))
                    {
                        CreateGift(p);
                    }
                }
            }
        }

        private void GiveGiftCommand(IPlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.Id, GifterPerm))
            {
                player.Reply(lang.GetMessage("NoPerm", this, player.Id));
                return;
            }
            
            player.Reply(lang.GetMessage("Given", this, player.Id));
            GiveGifts();
        }
    }
}

// --- End of file: RandomWrappedGift.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/restrict-placement ---
// --- Original File Path: R/RestrictPlacement/RestrictPlacement.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using System.Collections.Generic;

namespace Oxide.Plugins {
	[Info("Restrict Placement", "ItzNathaniel", "1.0.5")]
	[Description("Restrict Users from placing certain items.")]
	public class RestrictPlacement : RustPlugin {
		#region // Fields/Variables \\
		private Configuration _config;
		private const string permissionBypass = "restrictplacement.bypass";
		#endregion

		#region // Config \\
		protected override void LoadConfig() {
			base.LoadConfig();
			_config = Config.ReadObject<Configuration>();
			SaveConfig();
		}

		protected override void SaveConfig() => Config.WriteObject(_config);

		protected override void LoadDefaultConfig() {
			_config = new Configuration {
				blacklist = new HashSet<string> {
					"fullName.deployed.prefab"
				}
			};

			SaveConfig();
		}

		private class Configuration {
			[JsonProperty("Blacklist")]
			public HashSet<string> blacklist;
		}
		#endregion

		#region // Language \\
		protected override void LoadDefaultMessages() {
			lang.RegisterMessages(new Dictionary<string, string> {
				["Restricted"] = "<color=#d63031>Restrict Placement</color><color=#ffeaa7>: You're not allowed to place this item.</color>"
			}, this);
		}
		#endregion

		#region // Hooks \\
		private void Init() {
			permission.RegisterPermission(permissionBypass, this);
		}

		private object CanBuild(Planner planner, Construction prefab, Construction.Target target) {
			return CheckBuild(planner, prefab, target);
		}

		private object CheckBuild(Planner planner, Construction prefab, Construction.Target target) {
			var player = planner.GetOwnerPlayer();
			if (player == null) return null;
			
			if (_config.blacklist.Contains(prefab.fullName) && !permission.UserHasPermission(player.UserIDString, permissionBypass)) {
				var msg = string.Format(lang.GetMessage("Restricted", this, player.UserIDString));
				player.ChatMessage(msg);
				return true;
			}
			return null;
		}
		#endregion
	}
}


// --- End of file: RestrictPlacement.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rust-translation-api ---
// --- Original File Path: R/RustTranslationAPI/RustTranslationAPI.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins;

[Info("Rust Translation API", "MJSU", "2.0.1")]
[Description("Provides translations for Rust entities & items")]
public class RustTranslationAPI : RustPlugin
{
    #region Class Fields

    private static readonly string LOGLine = new('=', 30);

    private readonly Dictionary<string, Dictionary<string, string>> _languages = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, string> _constructionTokens = new();
    private readonly Dictionary<string, string> _deployableTokens = new();
    private readonly Dictionary<string, string> _displayNameTokens = new();
    private readonly Dictionary<string, string> _holdableTokens = new();
    private readonly Dictionary<string, string> _monumentTokens = new();
    private readonly Dictionary<uint, string> _prefabTokens = new();
    private bool _isInitialized;

    public enum LogLevel : byte
    {
        Off = 0,
        Error = 1,
        Warning = 2,
        Info = 3,
        Debug = 4
    }

    #endregion Class Fields

    #region Initialization

    private void OnServerInitialized()
    {
        Log($"{LOGLine}\nOnServerInitialized: start", LogLevel.Debug);
        ProcessTranslations();
        ProcessItems();
        ProcessMonuments();
        ProcessAttributes();
        _isInitialized = true;
        NextTick(() => Interface.CallHook("OnTranslationsInitialized"));
        Log("OnServerInitialized: finish", LogLevel.Debug);
    }

    private void Unload()
    {
        Log($"Plugin unloaded\n{LOGLine}\n", LogLevel.Debug);
    }

    #endregion Initialization

    #region Configuration

    private PluginConfig _pluginConfig;

    public class PluginConfig
    {
        [JsonConverter(typeof(StringEnumConverter))]
        [DefaultValue(LogLevel.Off)]
        [JsonProperty(PropertyName = "Log Level (Debug, Info, Warning, Error, Off)")]
        public LogLevel LoggingLevel { get; set; }
    }

    protected override void LoadDefaultConfig() => PrintWarning("Loading Default Config");

    protected override void LoadConfig()
    {
        base.LoadConfig();
        Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
        _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
        Config.WriteObject(_pluginConfig);
    }

    public static PluginConfig AdditionalConfig(PluginConfig config) => config;

    #endregion Configuration

    #region Core Methods

    public void ProcessTranslations()
    {
        AssetBundleBackend assets = (AssetBundleBackend)FileSystem.Backend;
        Dictionary<string, AssetBundle> files = assets.files;

        foreach ((string path, AssetBundle bundle) in files!)
        {
            if (!path.EndsWith(".json") || !path.StartsWith("assets/localization/"))
            {
                continue;
            }

            if (bundle.LoadAsset(path) is TextAsset textAsset)
            {
                int lastIndex = path.LastIndexOf('/');
                int secondLastIndex = path.LastIndexOf('/', lastIndex - 1) + 1;
                string language = path[secondLastIndex..lastIndex];

                if (!_languages.TryGetValue(language, out Dictionary<string, string> tokens))
                {
                    _languages[language] = tokens = new Dictionary<string, string>();
                    Log($"Added language: {language}", LogLevel.Debug);
                }

                foreach ((string token, string translation) in JsonConvert.DeserializeObject<Dictionary<string, string>>(textAsset.text))
                {
                    tokens[token] = translation;
                }

                Log($"Loaded {tokens.Count} tokens for language: {language}", LogLevel.Debug);
            }
        }

        Log($"Loaded {_languages.Count} languages.\n{string.Join(", ", _languages.Keys)}", LogLevel.Debug);
    }

    public void ProcessItems()
    {
        foreach (ItemDefinition def in ItemManager.GetItemDefinitions())
        {
            _displayNameTokens[def.displayName.english] = def.displayName.token;
            BaseEntity deployableEntity = def.GetComponent<ItemModDeployable>()?.entityPrefab.GetEntity();
            if (deployableEntity)
            {
                _deployableTokens[deployableEntity.ShortPrefabName] = def.displayName.token;
                _prefabTokens[deployableEntity.prefabID] = def.displayName.token;
            }
            
            HeldEntity heldEntity = def.GetComponent<ItemModEntity>()?.entityPrefab?.Get()?.GetComponent<HeldEntity>();
            if (heldEntity&& heldEntity is not Planner && heldEntity is not Deployer)
            {
                _holdableTokens[heldEntity.ShortPrefabName] = def.displayName.token;
                _prefabTokens[heldEntity.prefabID] = def.displayName.token;
                if (heldEntity is ThrownWeapon thrownWeapon)
                {
                    BaseEntity thrownEntity = thrownWeapon.prefabToThrow.GetEntity();
                    _holdableTokens[thrownEntity.ShortPrefabName] = def.displayName.token;
                    _prefabTokens[thrownEntity.prefabID] = def.displayName.token;
                }
            }
            
            PoweredLightsDeployer poweredLights = def.GetComponent<ItemModEntity>()?.entityPrefab?.Get()?.GetComponent<PoweredLightsDeployer>();
            if (poweredLights)
            {
                _holdableTokens[poweredLights.ShortPrefabName] = def.displayName.token;
                _prefabTokens[poweredLights.prefabID] = def.displayName.token;

                BaseEntity lights = poweredLights.poweredLightsPrefab.GetEntity();
                if (lights)
                {
                    _prefabTokens[lights.prefabID] = def.displayName.token;
                }
            }
        }
    }

    public void ProcessMonuments()
    {
        foreach (MonumentInfo monumentInfo in TerrainMeta.Path.Monuments)
        {
            if (monumentInfo.displayPhrase.IsValid())
            {
                string shortPrefabName = Path.GetFileNameWithoutExtension(monumentInfo.name);
                _monumentTokens[shortPrefabName] = monumentInfo.displayPhrase.token;
            }
        }
    }

    public void ProcessAttributes()
    {
        foreach (PrefabAttribute.AttributeCollection attributes in PrefabAttribute.server.prefabs.Values)
        {
            Construction construction = attributes.Find<Construction>().FirstOrDefault();
            if (construction && !construction!.deployable && construction.info.name.IsValid())
            {
                string shortPrefabName = Path.GetFileNameWithoutExtension(construction.fullName);
                _constructionTokens[shortPrefabName] = construction.info.name.token;
                _prefabTokens[construction.prefabID] = construction.info.name.token;
            }
            
            PrefabInformation prefabInfo =  attributes.Find<PrefabInformation>().FirstOrDefault();
            if (prefabInfo)
            {
                _prefabTokens[prefabInfo!.prefabID] = prefabInfo.title.token;
            }
        }
    }

    #endregion Core Methods

    #region API Methods

    private bool IsInitialized() => _isInitialized;
    private bool IsSupportedLanguage(string language) => _languages.ContainsKey(language);
    
    private string GetTranslation(string language, string token)
    {
        if (!string.IsNullOrEmpty(language) && !string.IsNullOrEmpty(token) && _languages.TryGetValue(language, out Dictionary<string, string> tokens) && tokens.TryGetValue(token, out string translation))
        {
            return translation;
        }

        return null;
    }

    private string GetLanguage(BasePlayer player) => player?.net.connection.info.GetString("global.language", "en") ?? "en";

    private string GetTranslation(string language, Translate.Phrase token) => GetTranslation(language, token?.token);
    private string GetTranslation(BasePlayer player, Translate.Phrase token) => GetTranslation(GetLanguage(player), token?.token);
    private string GetTranslation(string language, Item item) => GetTranslation(language, item?.info);
    private string GetTranslation(BasePlayer player, Item item) => GetTranslation(GetLanguage(player), item);
    private string GetTranslation(string language, ItemDefinition def) => GetTranslation(language, def?.displayName);
    private string GetTranslation(BasePlayer player, ItemDefinition def) => GetTranslation(GetLanguage(player), def);
    
    private string GetTranslation(string language, BaseEntity entity) => GetPrefabTranslation(language, entity.prefabID);
    private string GetTranslation(BasePlayer player, BaseEntity entity) => GetPrefabTranslation(player, entity.prefabID);
    private string GetTranslation(string language, MonumentInfo monument) => GetTranslation(language, monument?.displayPhrase);
    private string GetTranslation(BasePlayer player, MonumentInfo monument) => GetTranslation(GetLanguage(player), monument);
    
    private string GetTranslation(string language, Construction construction) => GetTranslation(language, construction?.info.name.token);
    private string GetTranslation(BasePlayer player, Construction monument) => GetTranslation(GetLanguage(player), monument);
    private string GetPrefabTranslation(string language, uint prefabId) => _prefabTokens.TryGetValue(prefabId, out string token) ? GetTranslation(language, token) : null;
    private string GetPrefabTranslation(BasePlayer player, uint prefabId) => _prefabTokens.TryGetValue(prefabId, out string token) ? GetTranslation(GetLanguage(player), token) : null;
    
    private string GetItemDescriptionByID(string language, int itemID) => GetItemDescriptionByDefinition(language, ItemManager.FindItemDefinition(itemID));
    private string GetItemDescriptionByID(BasePlayer player, int itemID) => GetItemDescriptionByID(GetLanguage(player), itemID);
    private string GetItemDescriptionByDefinition(string language, ItemDefinition def) => GetTranslation(language, def?.displayDescription);
    private string GetItemDescriptionByDefinition(BasePlayer player, ItemDefinition def) => GetItemDescriptionByDefinition(GetLanguage(player), def);
    
    private string GetItemTranslationByID(string language, int itemID) => GetTranslation(language, ItemManager.FindItemDefinition(itemID));
    private string GetItemTranslationByDisplayName(string language, string displayName) => _displayNameTokens.TryGetValue(displayName, out string token) ? GetTranslation(language, token) : null;
    private string GetItemTranslationByDefinition(string language, ItemDefinition def) => GetTranslation(language, def);
    private string GetItemTranslationByShortName(string language, string itemShortName) => GetTranslation(language, ItemManager.FindItemDefinition(itemShortName));
    
    private string GetDeployableTranslation(string language, string deployable) => _deployableTokens.TryGetValue(deployable, out string token) ? GetTranslation(language, token) : null;
    private string GetHoldableTranslation(string language, string holdable) => _holdableTokens.TryGetValue(holdable, out string token) ? GetTranslation(language, token) : null;
    private string GetMonumentTranslation(string language, string monumentName) => _monumentTokens.TryGetValue(monumentName, out string token) ? GetTranslation(language, token) : null;
    private string GetMonumentTranslation(string language, MonumentInfo monumentInfo) => GetTranslation(language, monumentInfo);
    private string GetConstructionTranslation(string language, string constructionName) => _constructionTokens.TryGetValue(constructionName, out string token) ? GetTranslation(language, token) : null;
    private string GetConstructionTranslation(string language, Construction construction) => GetTranslation(language, construction);

    #endregion API Methods

    #region Helpers

    public void Log(string message, LogLevel level = LogLevel.Info, string filename = "log", [CallerMemberName] string methodName = null)
    {
        switch (level)
        {
            case LogLevel.Error:
                PrintError(message);
                message = $"{DateTime.Now:HH:mm:ss} {methodName} {message}";
                break;
            case LogLevel.Warning:
                PrintWarning(message);
                message = $"{DateTime.Now:HH:mm:ss} {methodName} {message}";
                break;
            case LogLevel.Debug:
                message = $"{DateTime.Now:HH:mm:ss} {methodName} {message}";
                break;
            case LogLevel.Off:
            case LogLevel.Info:
                break;
            default:
                message = $"{DateTime.Now:HH:mm:ss} {message}";
                break;
        }

        if (_pluginConfig.LoggingLevel >= level)
        {
            LogToFile(filename, message, this);
        }
    }

    #endregion Helpers
}

// --- End of file: RustTranslationAPI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/raid-limit ---
// --- Original File Path: R/RaidLimit/RaidLimit.cs ---

// Requires: ImageLibrary

using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Oxide.Plugins;
using Rust;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Raid Limit", "noname", "2.2.3")]
    [Description("Limits the number of raids per day on buildings")]
    class RaidLimit : CovalencePlugin
    {
        [PluginReference]
        Plugin ImageLibrary, PlaytimeTracker;

        private static RaidLimit Instance;

        private int MaskInt = LayerMask.GetMask("Construction", "Prevent Building", "Deployed");
        private const string raidlimit_admin_Perm = "raidlimit.admin";
        private const string raidlimit_bypass_Perm = "raidlimit.bypass";

        private List<ulong> PlayerSpamMessageBlockFlags;

        #region Hooks

        private new void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");

            Config.WriteObject(GetDefaultConfig(), true);
        }

        private void Init()
        {
            Instance = this;

            RegisterPermissions();
            LoadConfig();
            LoadPlayersData();
            ChargeDataCheck();
        }

        private void OnServerSave()
        {
            SavePlayersData();
        }

        private void Unload()
        {
            PlayersDestroyRaidLimitUI();
            SavePlayersData();

            Instance = null;
        }

        private void Loaded()
        {
            RegisterUICommand();
        }

        private void OnServerInitialized()
        {
            PlayerSpamMessageBlockFlags = new List<ulong>();
            playersDateTimeData = new PlayersDateTimeData();
            PlayersAddToData();
            PlayersUpdateNameData();

            LoadImage();
            PlayersUpdateRaidLimitUI(true);

            StartTimer();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsNpc) return;

            PlayerAddToData(player);
            PlayerUpdateNameData(player);

            timer.Once(4f, () =>
            {
                PlayerAddToData(player);
                PlayerUpdateNameData(player);
                PlayerUpdateRaidLimitUI(player, true);
            });
        }

        private void OnUserGroupAdded(string id, string groupName)
        {
            if (!permission.GroupHasPermission(groupName, raidlimit_bypass_Perm))
                return;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.UserIDString == id)
                    PlayerUpdateRaidLimitUI(player, false);
            }
        }

        private void OnUserGroupRemoved(string id, string groupName)
        {
            if (!permission.GroupHasPermission(groupName, raidlimit_bypass_Perm))
                return;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.UserIDString == id)
                    PlayerUpdateRaidLimitUI(player, false);
            }
        }

        private void OnUserPermissionGranted(string id, string permName)
        {
            if (permName != raidlimit_bypass_Perm)
                return;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.UserIDString == id)
                    PlayerUpdateRaidLimitUI(player, false);
            }
        }

        private void OnUserPermissionRevoked(string id, string permName)
        {
            if (permName != raidlimit_bypass_Perm)
                return;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.UserIDString == id)
                    PlayerUpdateRaidLimitUI(player, false);
            }
        }

        private void OnGroupPermissionGranted(string name, string perm)
        {
            if (perm != raidlimit_bypass_Perm)
                return;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (permission.UserHasGroup(player.UserIDString, name))
                    PlayerUpdateRaidLimitUI(player, false);
            }
        }

        private void OnGroupPermissionRevoked(string name, string perm)
        {
            if (perm != raidlimit_bypass_Perm)
                return;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (permission.UserHasGroup(player.UserIDString, name))
                    PlayerUpdateRaidLimitUI(player, false);
            }
        }

        private void OnGroupDeleted(string name)
        {
            PlayersUpdateRaidLimitUI(false);
        }

        #endregion

        #region PluginIO

        #region ConfigManage

        private PluginConfig config;

        private void LoadConfig()
        {
            config = Config.ReadObject<PluginConfig>();

            if (config == null)
                config = GetDefaultConfig();
            else
                CheckMissingVariable();
        }

        private class PluginConfig
        {
            [JsonProperty("1.RaidLimitOperationType")]
            public RaidLimitOperationType RaidLimitOperationType;
            [JsonProperty("2.RaidLimitSettings")]
            public RaidLimitSettings RaidLimitSettings;
            [JsonProperty("3.UISettings")]
            public UISettings UISettings;
            [JsonProperty("4.TeamSyncSettings")]
            public TeamSyncSettings TeamSyncSettings;
        }

        private class RaidLimitOperationType
        {
            [JsonProperty("1.1.OperationType")]
            public int OperationType;
            [JsonProperty("1.2.ObjectOwnerIdentification")]
            public ObjectOwnerIdentification ObjectOwnerIdentification;
            [JsonProperty("1.3.ToolCupboardIdentification")]
            public ToolCupboardIdentification ToolCupboardIdentification;
        }

        private class ObjectOwnerIdentification
        {
            [JsonProperty("1.2.1.ObjectSearchDepth")]
            public int ObjectSearchDepth;
            [JsonProperty("1.2.2.ObjectSearchRange")]
            public int ObjectSearchRange;
        }

        private class ToolCupboardIdentification
        {
            [JsonProperty("1.3.1.ObjectSearchDepth")]
            public int ObjectSearchDepth;
            [JsonProperty("1.3.2.ObjectSearchRange")]
            public int ObjectSearchRange;
            [JsonProperty("1.3.3.CheckToolCupboardInstanceID")]
            public bool CheckToolCupboardInstanceID;
            [JsonProperty("1.3.4.CheckAuthorizedPeoples")]
            public bool CheckAuthorizedPeoples;
        }

        private class RaidLimitSettings
        {
            [JsonProperty("2.1.OneTimeMaximumRaidableHomeCount")]
            public int? OneTimeMaximumRaidableHomeCount;
            [JsonProperty("2.2.NoobCantRaidSecond")]
            public int? NoobCantRaidSecond;
            [JsonProperty("2.3.InitializeCounterOnMidnightTime")]
            public bool? InitializeCounterOnMidnightTime;
            [JsonProperty("2.4.MidnightTimeDetectionTimerInterval")]
            public int? MidnightTimeDetectionTimerInterval;
            [JsonProperty("2.5.CounterChargeDelay")]
            public int? CounterChargeDelay;
            [JsonProperty("2.6.CounterChargeDelayType")]
            public int? CounterChargeDelayType;
            [JsonProperty("2.7.CounterChargeType")]
            public int? CounterChargeType;
        }

        private class UISettings
        {
            [JsonProperty("3.1.UIEnable")]
            public bool UIEnable;
            [JsonProperty("3.2.UIUpdateInterval")]
            public int UIUpdateInterval;
            [JsonProperty("3.3.UIPosition")]
            public UIPosition UIPosition;
        }

        private class UIPosition
        {
            [JsonProperty("3.3.1.AnchorMin")]
            public string AnchorMin;
            [JsonProperty("3.3.2.AnchorMax")]
            public string AnchorMax;
        }

        private class TeamSyncSettings
        {
            [JsonProperty("4.1.TeamCounterSync")]
            public bool TeamCounterSync;
            [JsonProperty("4.2.PreventTempDisband")]
            public bool PreventTempDisband;
            [JsonProperty("4.3.OldTeamSaveInterval")]
            public int OldTeamSaveInterval;
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                RaidLimitOperationType = new RaidLimitOperationType()
                {
                    OperationType = 0,

                    ObjectOwnerIdentification = new ObjectOwnerIdentification()
                    {
                        ObjectSearchDepth = -1,
                        ObjectSearchRange = 5
                    },

                    ToolCupboardIdentification = new ToolCupboardIdentification()
                    {
                        ObjectSearchDepth = -1,
                        ObjectSearchRange = 5,
                        CheckToolCupboardInstanceID = true,
                        CheckAuthorizedPeoples = true
                    }
                },

                RaidLimitSettings = new RaidLimitSettings()
                {
                    OneTimeMaximumRaidableHomeCount = 2,
                    NoobCantRaidSecond = 10800,//3h
                    InitializeCounterOnMidnightTime = true,
                    CounterChargeDelay = 43200,//12h  -1 == disable
                    CounterChargeDelayType = 0,//0 == realtime, 1 == playtime
                    CounterChargeType = 0//0 == Charge when used up, 1 == Charge if there is not enough
                },

                UISettings = new UISettings()
                {
                    UIEnable = true,
                    UIUpdateInterval = 3,

                    UIPosition = new UIPosition()
                    {
                        AnchorMin = "0.28 0.025",
                        AnchorMax = "0.3392 0.06"
                    }
                },

                TeamSyncSettings = new TeamSyncSettings()
                {
                    TeamCounterSync = true,
                    PreventTempDisband = true,
                    OldTeamSaveInterval = 600
                }
            };
        }

        private void CheckMissingVariable()
        {
            bool Missed = false;

            if (config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount == null)
            {
                config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount = 2;
                Missed = true;
            }

            if (config.RaidLimitSettings.NoobCantRaidSecond == null)
            {
                config.RaidLimitSettings.NoobCantRaidSecond = 10800;
                Missed = true;
            }

            if (config.RaidLimitSettings.InitializeCounterOnMidnightTime == null)
            {
                config.RaidLimitSettings.InitializeCounterOnMidnightTime = true;
                Missed = true;
            }

            if (config.RaidLimitSettings.MidnightTimeDetectionTimerInterval == null)
            {
                config.RaidLimitSettings.MidnightTimeDetectionTimerInterval = 10;
                Missed = true;
            }

            if (config.RaidLimitSettings.CounterChargeDelay == null)
            {
                config.RaidLimitSettings.CounterChargeDelay = 43200;
                Missed = true;
            }

            if (config.RaidLimitSettings.CounterChargeDelayType == null)
            {
                config.RaidLimitSettings.CounterChargeDelayType = 0;
                Missed = true;
            }

            if (config.RaidLimitSettings.CounterChargeType == null)
            {
                config.RaidLimitSettings.CounterChargeType = 0;
                Missed = true;
            }

            if (Missed)
                Config.WriteObject(config, true);
        }

        #endregion

        #region DataManage

        DynamicConfigFile playersdataFile;
        PlayersData playersData;

        DynamicConfigFile playersuidataFile;
        PlayersUIData playersUIData;

        DynamicConfigFile playersteamdataFile;
        PlayersTeamData playersTeamData;

        private void LoadPlayersData()
        {
            playersdataFile = Interface.Oxide.DataFileSystem.GetDatafile("RaidLimitPlayerData");
            playersData = playersdataFile.ReadObject<PlayersData>();

            if (playersData == null)
                playersData = new PlayersData();

            playersuidataFile = Interface.Oxide.DataFileSystem.GetDatafile("RaidLimitPlayerUIData");
            playersUIData = playersuidataFile.ReadObject<PlayersUIData>();

            if (playersUIData == null)
                playersUIData = new PlayersUIData();

            playersteamdataFile = Interface.Oxide.DataFileSystem.GetDatafile("RaidLimitPlayerTeamData");
            playersTeamData = playersuidataFile.ReadObject<PlayersTeamData>();

            if (playersTeamData == null)
                playersTeamData = new PlayersTeamData();
        }

        private void ChargeDataCheck()
        {
            foreach (var item in playersData.Players)
            {
                PlayerInfo playerinfo = item.Value;

                if (config.RaidLimitSettings.CounterChargeDelay != -1)
                {
                    switch (config.RaidLimitSettings.CounterChargeType)
                    {
                        case 0:
                            if (playerinfo.RaidLeftCount == 0 && playerinfo.Charging == false)
                                playerinfo.AddChargeSchedule();
                            break;

                        case 1:
                            if (playerinfo.RaidLeftCount < config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount && playerinfo.Charging == false)
                                playerinfo.AddChargeSchedule();
                            break;

                        default:
                            goto case 0;
                    }
                }
            }
        }

        private void SavePlayersData()
        {
            Puts("Saving RaidLimit PlayersDataFile...");
            playersdataFile.WriteObject<PlayersData>(playersData);
            playersuidataFile.WriteObject<PlayersUIData>(playersUIData);
            playersteamdataFile.WriteObject<PlayersTeamData>(playersTeamData);
        }

        private class PlayersTeamData
        {
            public Dictionary<ulong, PlayerTeam> TeamsData1;
            public Dictionary<ulong, PlayerTeam> TeamsData2;
            public int OldDataIndicator;

            public PlayersTeamData()
            {
                TeamsData1 = new Dictionary<ulong, PlayerTeam>();
                TeamsData2 = new Dictionary<ulong, PlayerTeam>();

                OldDataIndicator = 2;
            }

            public void UpdateData()
            {
                Dictionary<ulong, PlayerTeam> OldTeamsData;
                if (OldDataIndicator == 1)
                    OldTeamsData = TeamsData2;
                else
                    OldTeamsData = TeamsData1;

                OldTeamsData.Clear();
                foreach (var item in RelationshipManager.ServerInstance.teams)
                {
                    OldTeamsData.Add(item.Key, new PlayerTeam(item.Value.members));
                }

                if (OldDataIndicator == 1)
                    OldDataIndicator = 2;
                else
                    OldDataIndicator = 1;
            }
        }

        private class PlayerTeam
        {
            public List<ulong> Members { get; set; }

            public PlayerTeam()
            {
                Members = new List<ulong>();
            }

            public PlayerTeam(List<ulong> members)
            {
                Members = new List<ulong>(members);
            }
        }

        private class PlayersUIData
        {
            public Dictionary<string, bool> PlayersUIToggle;

            public PlayersUIData()
            {
                PlayersUIToggle = new Dictionary<string, bool>();
            }

            public void AddPlayer(BasePlayer player)
            {
                if (!PlayersUIToggle.ContainsKey(player.UserIDString) && player != null)
                {
                    PlayersUIToggle.Add(player.UserIDString, true);
                }
            }
        }

        private class PlayersData
        {
            public DateTime excutteddate;
            public Dictionary<string, PlayerInfo> Players;

            public PlayersData()
            {
                excutteddate = DateTime.MinValue;
                Players = new Dictionary<string, PlayerInfo>();
            }

            public void AddPlayer(string playerId)
            {
                if (!Players.ContainsKey(playerId) && playerId != null)
                {
                    Players.Add(playerId, new PlayerInfo(playerId));
                }
            }

            public void AddPlayer(BasePlayer player)
            {
                if (!Players.ContainsKey(player.UserIDString) && player != null)
                {
                    Players.Add(player.UserIDString, new PlayerInfo(player.IPlayer));
                }
            }

            public void PlayerAddTime(string PlayerID, TimeSpan time)
            {
                if (Players.ContainsKey(PlayerID))
                {
                    Players[PlayerID].Playtime = Players[PlayerID].Playtime.Add(time);
                }
            }
        }

        private class PlayerInfo
        {
            public string Id;
            public string Name;
            public int RaidLeftCount;
            public List<RaidCountItem> RaidCountItems;

            public bool Charging;
            public TimeSpan NextChargePlaytime;
            public DateTime NextChargeRealtime;

            public TimeSpan Playtime;
            public bool NoobCanRaidPlaytimeTracker;
            public bool NoobCanRaid;

            public PlayerInfo()
            {
                //for json deserialize
            }

            public PlayerInfo(string playerId)
            {
                Id = playerId;
                Name = null;
                RaidLeftCount = 0;
                RaidCountItems = new List<RaidCountItem>();

                Charging = false;
                NextChargePlaytime = new TimeSpan(0, 0, 0);
                NextChargeRealtime = DateTime.MinValue;

                Playtime = new TimeSpan(0, 0, 0);
                NoobCanRaidPlaytimeTracker = false;
                NoobCanRaid = false;
            }

            public PlayerInfo(IPlayer player)
            {
                Id = player.Id;
                Name = player.Name;
                RaidLeftCount = 0;
                RaidCountItems = new List<RaidCountItem>();

                Charging = false;
                NextChargePlaytime = new TimeSpan(0, 0, 0);
                NextChargeRealtime = DateTime.MinValue;

                Playtime = new TimeSpan(0, 0, 0);
                NoobCanRaidPlaytimeTracker = false;
                NoobCanRaid = false;
            }

            public bool AddRaidTarget(RaidCountItem raidCountItem)
            {
                if (RaidLeftCount <= 0)
                    return false;

                RaidLeftCount--;
                RaidCountItems.Add(raidCountItem);
                return true;
            }

            public void AddChargeSchedule()
            {
                TimeSpan CounterChargeDelay = TimeSpan.FromSeconds(Instance.config.RaidLimitSettings.CounterChargeDelay.Value);

                NextChargePlaytime = Instance.GetPlayerPlaytime(Id) + CounterChargeDelay;
                NextChargeRealtime = DateTime.Now + CounterChargeDelay;

                Charging = true;
            }

            public void StopCharging()
            {
                Charging = false;
            }

            public void ChargeRaidCount(bool chargeAll)
            {
                if (Instance.config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount <= RaidLeftCount)
                    return;

                if (chargeAll)
                    RaidLeftCount = Instance.config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount.Value;
                else
                    RaidLeftCount++;

                if (Instance.config.RaidLimitSettings.InitializeCounterOnMidnightTime == false)
                {
                    if (chargeAll)
                        RaidCountItems.Clear();
                    else
                        RaidCountItems.RemoveAt(RaidCountItems.Count - 1);
                }
            }

            public int AddRaidCount(int amount)
            {
                int CountSave = RaidLeftCount;

                RaidLeftCount += amount;

                if (RaidLeftCount < 0)
                    RaidLeftCount = 0;
                else if (Instance.config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount < RaidLeftCount)
                    RaidLeftCount = Instance.config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount.Value;


                for (int i = 0; i < amount; i++)
                {
                    if (RaidCountItems.Count <= 0)
                        break;
                    RaidCountItems.RemoveAt(RaidCountItems.Count - 1);
                }

                return RaidLeftCount - CountSave;
            }

            public void ResetRaidDataNCount()
            {
                RaidLeftCount = Instance.config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount.Value;
                RaidCountItems.Clear();
            }
        }

        private class RaidCountItem
        {
            public List<ulong> RaidTargets;
            public List<int> TCInstanceIDs;

            public RaidCountItem()
            {
                //for json deserialize
            }

            public RaidCountItem(List<ulong> raidTargets, List<int> tcInstanceIDs)
            {
                RaidTargets = raidTargets;
                TCInstanceIDs = tcInstanceIDs;
            }

            public void AddRaidTargetsRange(List<ulong> raidTargets)
            {
                foreach (var item in raidTargets)
                {
                    if (RaidTargets.Contains(item) == false)
                        RaidTargets.Add(item);
                }
            }

            public void AddTCInstanceIDsRange(List<int> tcInstanceIDs)
            {
                foreach (var item in tcInstanceIDs)
                {
                    if (TCInstanceIDs.Contains(item) == false)
                        TCInstanceIDs.Add(item);
                }
            }
        }

        #endregion

        #region PermissionManage

        private void RegisterPermissions()
        {
            permission.RegisterPermission(raidlimit_admin_Perm, this);
            permission.RegisterPermission(raidlimit_bypass_Perm, this);
        }

        #endregion

        #region LangManage

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "You do not have permission to use the '{0}' command.",
                ["Date Changed"] = "The day has changed. The raid limit has been initialized.",
                ["You Can Raid"] = "You have enough play time to raid.",
                ["Add RaidList"] = "The owner of this building has been added to the raid list. you can raid {0} more time.",
                ["Add RaidList TC"] = "The building has been added to the raid list. you can raid {0} more time.",
                ["Team Member Raiding"] = "Team member \"{0}\" is raiding. Raid limit counter reduced. The owner of the house where the team is raiding has been added to the raid list.",
                ["Left Raid Count"] = "You can raid {0} more time.",
                ["Raid Blocked"] = "You can't raid any more today.",
                ["Raid Blocked NoRefill"] = "You can't raid any more.",
                ["Raid Blocked RNextTime"] = "You can't raid right now. After {0} seconds in realtime, Raid count will be recharged.",
                ["Raid Blocked PNextTime"] = "You can't raid right now. After {0} seconds in playtime, Raid count will be recharged.",
                ["Raid Blocked Time"] = "You have to play the game for more than {0}seconds before you can raid it. Your play time is {1}seconds.",
                ["Raid Reset Specific Slayer"] = "Your raid limit has been refilled.",
                ["Raid List Reset"] = "The raid limit has been initialized.",
                ["bypass GUI Msg"] = "<color=#FFE400>bypass</color>",
                ["SteamID Not Found"] = "Could not find this SteamID: {0}.",
                ["Player Not Found"] = "Could not find this player: {0}.",
                ["Multiple Players Found"] = "Found multiple players!\n\n{0}",
                ["NotEnoughArgument"] = "to run this command you need {0} arguments.",
                ["Invalid Parameter"] = "'{0}' is an invalid parameter.",
                ["Count IncreasedC"] = "{0}'s raidlimit has increased by '{1}'.",
                ["Count DecreasedC"] = "{0}'s raidlimit has decreased by '{1}'.",
                ["Count IncreasedP"] = "raidlimit has increased by '{0}'.",
                ["Count DecreasedP"] = "raidlimit has decreased by '{0}'."
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "'{0}' 명령어를 사용하실 권한이 없습니다.",
                ["Date Changed"] = "날이 바뀌었습니다. 레이드 제한이 초기화 되었습니다.",
                ["You Can Raid"] = "플레이타임이 충분하므로 이제 레이드가 가능합니다.",
                ["Add RaidList"] = "이 건축물의 주인이 레이드 가능 목록에 추가되었습니다. 앞으로 {0}번 더 레이드 할 수 있습니다.",
                ["Add RaidList TC"] = "이 건묵물이 레이드 가능 목록에 추가되었습니다. 앞으로 {0}번 더 레이드 할 수 있습니다.",
                ["Team Member Raiding"] = "팀원 \"{0}\" 님이 레이드 중입니다. 레이드 제한이 감소하였습니다. 레이드 당하고 있는 건축물의 주인이 레이드 가능 목록에 추가되었습니다.",
                ["Left Raid Count"] = "{0}번 더 레이드 하실 수 있습니다.",
                ["Raid Blocked"] = "오늘은 더이상 레이드를 할 수 없습니다.",
                ["Raid Blocked NoRefill"] = "더이상 레이드를 할 수 없습니다.",
                ["Raid Blocked RNextTime"] = "더이상 레이드를 할 수 없습니다. 리얼타임을 기준으로 {0}초후에 레이드 제한 횟수가 다시 충전됩니다.",
                ["Raid Blocked PNextTime"] = "더이상 레이드를 할 수 없습니다. 플레이타임을 기준으로 {0}초후에 레이드 제한 횟수가 다시 충전됩니다.",
                ["Raid Blocked Time"] = "레이드를 하기위해선 플레이타임이 {0}초 이상이여야합니다. 현재 누적 플레이타임은 {1}초입니다.",
                ["Raid Reset Specific Slayer"] = "레이드 제한횟수가 재충전 되었습니다.",
                ["Raid List Reset"] = "레이드 제한횟수가 재충전 되었습니다.",
                ["bypass GUI Msg"] = "<color=#FFE400>무한</color>",
                ["SteamID Not Found"] = "{0} 와 일치하는 스팀 아이디를 가진 플레이어가 없습니다.",
                ["Player Not Found"] = "{0} 와 일치하는 이름을 가진 플레이어가 없습니다.",
                ["Multiple Players Found"] = "여러명의 플레이어를 검색했습니다!\n\n{0}",
                ["NotEnoughArgument"] = "이명령어를 실행하기 위해서는 {0} 개의 값이 필요합니다.",
                ["Invalid Parameter"] = "'{0}'는 유효하지 않은 파라미터 입니다.",
                ["Count IncreasedC"] = "{0}님의 레이드제한이 '{1}'만큼 증가하였습니다.",
                ["Count DecreasedC"] = "{0}님의 레이드제한이 '{1}'만큼 감소하였습니다.",
                ["Count IncreasedP"] = "레이드제한이 '{0}'만큼 증가하였습니다.",
                ["Count DecreasedP"] = "레이드제한이 '{0}'만큼 감소하였습니다."
            }, this, "ko");
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        #endregion

        #endregion

        #region TimerManager

        private void StartTimer()
        {
            if (config.TeamSyncSettings.PreventTempDisband == true)
                timer.Every(config.TeamSyncSettings.OldTeamSaveInterval, PreventTempDisband_Timer_Tick);

            if (config.RaidLimitSettings.InitializeCounterOnMidnightTime == true)
                timer.Every(config.RaidLimitSettings.MidnightTimeDetectionTimerInterval.Value, CheckDayChanged_Timer_Tick);

            timer.Every(config.UISettings.UIUpdateInterval, UIUpdate_Timer_Tick);
        }

        private void PreventTempDisband_Timer_Tick()
        {
            playersTeamData.UpdateData();
        }

        private void CheckDayChanged_Timer_Tick()
        {
            if (playersData.excutteddate.DayOfYear < DateTime.Now.DayOfYear || playersData.excutteddate.Year < DateTime.Now.Year)
            {
                Puts(Lang("Date Changed", null));
                foreach (IPlayer current in players.Connected)
                    current.Message(Lang("Date Changed", current.Id));

                foreach (var item in playersData.Players)
                {
                    item.Value.ResetRaidDataNCount();
                    item.Value.StopCharging();
                }
                SavePlayersData();
                PlayersUpdateRaidLimitUI(false);

                playersData.excutteddate = DateTime.Now;
            }
        }

        private void UIUpdate_Timer_Tick()//done
        {
            foreach (BasePlayer basePlayer in BasePlayer.activePlayerList)
            {
                PlayerInfo playerInfo = playersData.Players[basePlayer.UserIDString];
                TimeSpan playtime = GetPlayerPlaytime(basePlayer);

                if (GetCanRaid(playerInfo) == false)
                {
                    if (playtime.TotalSeconds > config.RaidLimitSettings.NoobCantRaidSecond)
                    {
                        if (PlaytimeTracker != null)
                            playerInfo.NoobCanRaidPlaytimeTracker = true;
                        else
                            playerInfo.NoobCanRaid = true;

                        playerInfo.ChargeRaidCount(true);

                        if (!permission.UserHasPermission(basePlayer.UserIDString, raidlimit_bypass_Perm))
                            basePlayer.ChatMessage(Lang("You Can Raid", basePlayer.UserIDString));
                        UpdatePlayerCountUI(basePlayer, false);
                    }
                }

                if (GetCanRaid(playerInfo) == false)
                {
                    UpdatePlayerNoobTimeUI(basePlayer, playtime, false);
                }
                else
                {
                    if (playerInfo.Charging && config.RaidLimitSettings.CounterChargeDelay != -1)
                    {
                        switch (config.RaidLimitSettings.CounterChargeDelayType)
                        {
                            case 0://realtume
                                switch (config.RaidLimitSettings.CounterChargeType)
                                {
                                    case 0://Charge when used up
                                        if (playerInfo.RaidLeftCount != 0)
                                            break;

                                        if (DateTime.Now >= playerInfo.NextChargeRealtime)
                                        {
                                            playerInfo.ChargeRaidCount(true);
                                            basePlayer.ChatMessage(Lang("Raid Reset Specific Slayer", basePlayer.UserIDString));

                                            playerInfo.StopCharging();

                                            PlayerUpdateRaidLimitUI(basePlayer, false);
                                        }
                                        break;

                                    case 1://Charge if there is not enough
                                        if (DateTime.Now >= playerInfo.NextChargeRealtime)
                                        {
                                            playerInfo.ChargeRaidCount(false);
                                            basePlayer.ChatMessage(Lang("Raid Reset Specific Slayer", basePlayer.UserIDString));

                                            if (config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount <= playerInfo.RaidLeftCount)
                                                playerInfo.StopCharging();
                                            else
                                                playerInfo.AddChargeSchedule();

                                            PlayerUpdateRaidLimitUI(basePlayer, false);
                                        }
                                        break;

                                    default:
                                        goto case 0;
                                }
                                break;

                            case 1://playtime
                                switch (config.RaidLimitSettings.CounterChargeType)
                                {
                                    case 0://Charge when used up
                                        if (playerInfo.RaidLeftCount != 0)
                                            break;

                                        if (playtime >= playerInfo.NextChargePlaytime)
                                        {
                                            playerInfo.ChargeRaidCount(true);
                                            basePlayer.ChatMessage(Lang("Raid Reset Specific Slayer", basePlayer.UserIDString));

                                            playerInfo.StopCharging();

                                            PlayerUpdateRaidLimitUI(basePlayer, false);
                                        }
                                        break;

                                    case 1://Charge if there is not enough
                                        if (playtime >= playerInfo.NextChargePlaytime)
                                        {
                                            playerInfo.ChargeRaidCount(false);
                                            basePlayer.ChatMessage(Lang("Raid Reset Specific Slayer", basePlayer.UserIDString));

                                            if (config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount <= playerInfo.RaidLeftCount)
                                                playerInfo.StopCharging();
                                            else
                                                playerInfo.AddChargeSchedule();

                                            PlayerUpdateRaidLimitUI(basePlayer, false);
                                        }
                                        break;

                                    default:
                                        goto case 0;
                                }
                                break;

                            default:
                                goto case 0;
                        }

                        if (playerInfo.RaidLeftCount == 0)
                        {
                            switch (config.RaidLimitSettings.CounterChargeDelayType)
                            {
                                case 0:
                                    UpdatePlayerTimeUI(basePlayer, playerInfo.NextChargeRealtime - DateTime.Now, false);
                                    break;

                                case 1:
                                    UpdatePlayerTimeUI(basePlayer, playerInfo.NextChargePlaytime - playtime, false);
                                    break;

                                default:
                                    goto case 0;
                            }
                        }
                    }
                }
            }

            if (PlaytimeTracker == null)
            {
                TimeSpan timerticktimeSpan = DateTime.Now - playersDateTimeData.SaveTickTime;

                foreach (BasePlayer basePlayer in BasePlayer.activePlayerList)
                {
                    if (playersDateTimeData.BasePlayerList.Contains(basePlayer))
                    {
                        PlayerInfo playerInfo = playersData.Players[basePlayer.UserIDString];

                        if (playerInfo.Playtime.TotalSeconds < config.RaidLimitSettings.NoobCantRaidSecond)
                            playersData.PlayerAddTime(basePlayer.UserIDString, timerticktimeSpan);
                        else
                        {
                            if (playerInfo.NoobCanRaid == false)
                            {
                                playerInfo.NoobCanRaid = true;
                            }
                        }
                    }
                }

                playersDateTimeData.SaveTickTime = DateTime.Now;
                playersDateTimeData.BasePlayerList = BasePlayer.activePlayerList;
            }
            else
            {
                playersDateTimeData.SaveTickTime = DateTime.Now;
            }
        }

        #endregion

        #region InterCommand

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || entity.gameObject == null || info == null)
                return;

            if (((1 << entity.gameObject.layer) & MaskInt) != 0)
            {
                BasePlayer player = info.Initiator as BasePlayer;// ?? entity.lastAttacker;

                if (player == null ||
                    player.IsNpc ||
                    !entity.OwnerID.IsSteamId()||
                    player.UserIDString == entity.OwnerID.ToString() ||
                    info.damageTypes.Get(DamageType.Explosion) == 0 ||
                    permission.UserHasPermission(player.UserIDString, raidlimit_bypass_Perm))
                    return;

                PlayerInfo playerinfo = playersData.Players[player.UserIDString];

                if (GetCanRaid(playerinfo) == false)
                {
                    TimeSpan playtime = GetPlayerPlaytime(player);
                    TryChatMessage(player, Lang("Raid Blocked Time", player.UserIDString, config.RaidLimitSettings.NoobCantRaidSecond, playtime.TotalSeconds));
                    info.damageTypes.Scale(DamageType.Explosion, 0);
                    return;
                }

                /////////////////////////////////////////////////////////////////////

                if (config.RaidLimitOperationType.OperationType != 1)
                {
                    if (CheckRaidCountItemContainsNAdd(playerinfo.RaidCountItems, new RaidCountItem(new List<ulong>() { entity.OwnerID }, new List<int>())) == true)
                        return;

                    if (permission.UserHasPermission(entity.OwnerID.ToString(), "antinoobraid.noob"))
                    {
                        info.damageTypes.Scale(DamageType.Explosion, 0);
                        return;
                    }
                }

                string addraidlistmsg = (config.RaidLimitOperationType.OperationType == 1 &&
                    config.RaidLimitOperationType.ToolCupboardIdentification.CheckToolCupboardInstanceID == true &&
                    config.RaidLimitOperationType.ToolCupboardIdentification.CheckAuthorizedPeoples == false) ? "Add RaidList TC" : "Add RaidList";

                if (0 < playerinfo.RaidLeftCount)
                {
                    RaidCountItem RaidCountItem = FindLinkedStructuresRaidCountItem(entity);
                    if (RaidCountItem == null)
                    {
                        info.damageTypes.Scale(DamageType.Explosion, 0);
                        return;
                    }

                    if (RaidCountItem.RaidTargets.Count == 0 && RaidCountItem.TCInstanceIDs.Count == 0)
                        return;

                    if (config.RaidLimitOperationType.OperationType == 1)
                    {
                        if (RaidCountItem.RaidTargets.Contains(player.userID))
                            return;
                    }

                    if (CheckRaidCountItemContainsNAdd(playerinfo.RaidCountItems, RaidCountItem) == true)
                        return;

                    playerinfo.AddRaidTarget(RaidCountItem);
                    if (config.RaidLimitSettings.CounterChargeDelay != -1)
                    {
                        switch (config.RaidLimitSettings.CounterChargeType)
                        {
                            case 0:
                                if (playerinfo.RaidLeftCount == 0)
                                    playerinfo.AddChargeSchedule();
                                break;

                            case 1:
                                if (playerinfo.RaidLeftCount < config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount)
                                    playerinfo.AddChargeSchedule();
                                break;

                            default:
                                goto case 0;
                        }
                    }

                    if (playerinfo.Charging && playerinfo.RaidLeftCount == 0)
                    {
                        switch (config.RaidLimitSettings.CounterChargeDelayType)
                        {
                            case 0:
                                UpdatePlayerTimeUI(player, playerinfo.NextChargeRealtime - DateTime.Now, false);
                                break;

                            case 1:
                                TimeSpan playerplaytime = GetPlayerPlaytime(player);
                                UpdatePlayerTimeUI(player, playerinfo.NextChargePlaytime - playerplaytime, false);
                                break;

                            default:
                                goto case 0;
                        }
                    }
                    else
                        UpdatePlayerCountUI(player, false);

                    player.ChatMessage(Lang(addraidlistmsg, player.UserIDString, playerinfo.RaidLeftCount));

                    if (config.TeamSyncSettings.TeamCounterSync == true && player.currentTeam != 0)
                    {
                        List<ulong> Team;

                        if (config.TeamSyncSettings.PreventTempDisband == true)
                        {
                            Team = new List<ulong>(RelationshipManager.ServerInstance.FindTeam(player.currentTeam).members);

                            Dictionary<ulong, PlayerTeam> oldTeamData;
                            if (playersTeamData.OldDataIndicator == 1)
                                oldTeamData = playersTeamData.TeamsData1;
                            else
                                oldTeamData = playersTeamData.TeamsData2;

                            if (oldTeamData.ContainsKey(player.currentTeam))
                            {
                                Team.AddRange(oldTeamData[player.currentTeam].Members);
                                Team = Team.Distinct().ToList();
                            }
                        }
                        else
                            Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam).members;

                        foreach (var member in Team)
                        {
                            if (member != player.userID)
                            {
                                if (playersData.Players.ContainsKey(member.ToString()) == false)
                                    playersData.AddPlayer(member.ToString());
                                PlayerInfo playerInfo = playersData.Players[member.ToString()];

                                if (0 < playerInfo.RaidLeftCount && CheckRaidCountItemContainsNAdd(playerInfo.RaidCountItems, RaidCountItem) == false)
                                {
                                    BasePlayer memberBplayer = TryGetPlayer(member);

                                    playerInfo.AddRaidTarget(RaidCountItem);
                                    if (config.RaidLimitSettings.CounterChargeDelay != -1)
                                    {
                                        switch (config.RaidLimitSettings.CounterChargeType)
                                        {
                                            case 0:
                                                if (playerInfo.RaidLeftCount == 0)
                                                    playerInfo.AddChargeSchedule();
                                                break;

                                            case 1:
                                                if (playerInfo.RaidLeftCount < config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount)
                                                    playerInfo.AddChargeSchedule();
                                                break;

                                            default:
                                                goto case 0;
                                        }
                                    }

                                    if (playerInfo.Charging && playerInfo.RaidLeftCount == 0)
                                    {
                                        switch (config.RaidLimitSettings.CounterChargeDelayType)
                                        {
                                            case 0:
                                                UpdatePlayerTimeUI(memberBplayer, playerInfo.NextChargeRealtime - DateTime.Now, false);
                                                break;

                                            case 1:
                                                if (memberBplayer == null)
                                                    break;

                                                TimeSpan playerplaytime = GetPlayerPlaytime(memberBplayer);
                                                UpdatePlayerTimeUI(memberBplayer, playerInfo.NextChargePlaytime - playerplaytime, false);
                                                break;

                                            default:
                                                goto case 0;
                                        }
                                    }
                                    else
                                        UpdatePlayerCountUI(player, false);

                                    UpdatePlayerCountUI(memberBplayer, false);
                                    memberBplayer?.ChatMessage(Lang("Team Member Raiding", member.ToString(), player.displayName));
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (playerinfo.Charging)
                    {
                        int leftseconds;
                        switch (config.RaidLimitSettings.CounterChargeDelayType)
                        {
                            case 0:
                                leftseconds = (int)(playerinfo.NextChargeRealtime - DateTime.Now).TotalSeconds;
                                TryChatMessage(player, Lang("Raid Blocked RNextTime", player.UserIDString, leftseconds));
                                break;

                            case 1:
                                TimeSpan playerplaytime = GetPlayerPlaytime(player);
                                leftseconds = (int)(playerinfo.NextChargePlaytime - playerplaytime).TotalSeconds;
                                TryChatMessage(player, Lang("Raid Blocked PNextTime", player.UserIDString, leftseconds));
                                break;

                            default:
                                goto case 0;
                        }
                    }
                    else
                    {
                        if (config.RaidLimitSettings.InitializeCounterOnMidnightTime == true)
                            TryChatMessage(player, Lang("Raid Blocked", player.UserIDString));
                        else
                            TryChatMessage(player, Lang("Raid Blocked NoRefill", player.UserIDString));
                    }

                    info.damageTypes.Scale(DamageType.Explosion, 0);
                }
            }
            return;
        }

        private void PlayerAddToData(BasePlayer player)
        {
            playersData.AddPlayer(player);
            playersUIData.AddPlayer(player);
        }

        private void PlayersAddToData()
        {
            foreach (var BasePlayer in BasePlayer.activePlayerList)
            {
                PlayerAddToData(BasePlayer);
            }
        }

        private void PlayerUpdateNameData(BasePlayer player)
        {
            if (playersData.Players.ContainsKey(player.UserIDString))
                playersData.Players[player.UserIDString].Name = player.displayName;
        }

        private void PlayersUpdateNameData()
        {
            foreach (var BasePlayer in BasePlayer.activePlayerList)
            {
                PlayerUpdateNameData(BasePlayer);
            }
        }

        private bool CheckRaidCountItemContainsNAdd(List<RaidCountItem> player, RaidCountItem target)
        {
            bool returnValue = false;

            foreach (var playeritem in player)
            {
                foreach (var searcheditem in target.RaidTargets)
                {
                    if (playeritem.RaidTargets.Contains(searcheditem))
                    {
                        playeritem.AddRaidTargetsRange(target.RaidTargets);
                        returnValue = true;
                        break;
                    }
                }

                foreach (var searcheditem in target.TCInstanceIDs)
                {
                    if (playeritem.TCInstanceIDs.Contains(searcheditem))
                    {
                        playeritem.AddTCInstanceIDsRange(target.TCInstanceIDs);
                        returnValue = true;
                        break;
                    }
                }
            }

            return returnValue;
        }

        private RaidCountItem FindLinkedStructuresRaidCountItem(BaseEntity entity)
        {
            int ObjectSearchRange;
            int ObjectSearchDepth;

            switch (config.RaidLimitOperationType.OperationType)
            {
                case 0:
                    ObjectSearchRange = config.RaidLimitOperationType.ObjectOwnerIdentification.ObjectSearchRange;
                    ObjectSearchDepth = config.RaidLimitOperationType.ObjectOwnerIdentification.ObjectSearchDepth;
                    break;

                case 1:
                    ObjectSearchRange = config.RaidLimitOperationType.ToolCupboardIdentification.ObjectSearchRange;
                    ObjectSearchDepth = config.RaidLimitOperationType.ToolCupboardIdentification.ObjectSearchDepth;
                    break;

                default:
                    goto case 0;
            }

            List<BaseEntity> SearchedEntity = new List<BaseEntity>();
            List<BaseEntity> RemoveEntity = new List<BaseEntity>();
            List<BaseEntity> ExpendEntity = new List<BaseEntity>();

            List<BaseEntity> EntityList = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(entity.transform.position, ObjectSearchRange, EntityList, MaskInt);

            int Depth = 0;

            while (!(EntityList.Count == 0))
            {
                if (ObjectSearchDepth != -1)
                {
                    if (Depth >= ObjectSearchDepth)
                    {
                        break;
                    }
                    Depth++;
                }

                foreach (var item in EntityList)
                {
                    if (SearchedEntity.Contains(item) == false)
                    {
                        SearchedEntity.Add(item);
                        ExpendEntity.Add(item);
                        RemoveEntity.Add(item);
                    }
                    else
                    {
                        RemoveEntity.Add(item);
                    }
                }

                foreach (var item in ExpendEntity)
                {
                    Vis.Entities<BaseEntity>(item.transform.position, ObjectSearchRange, EntityList, MaskInt);
                }

                ExpendEntity.Clear();
                EntityList = EntityList.Distinct().ToList();

                foreach (var item in RemoveEntity)
                {
                    if (EntityList.Contains(item))
                        EntityList.Remove(item);
                }
                RemoveEntity.Clear();
            }

            RaidCountItem raidCountItem;

            switch (config.RaidLimitOperationType.OperationType)
            {
                case 0:
                    List<ulong> Owners = new List<ulong>();
                    Owners.Add(entity.OwnerID);

                    foreach (var item in SearchedEntity)
                    {
                        if (Owners.Contains(item.OwnerID) == false)
                            Owners.Add(item.OwnerID);
                    }

                    raidCountItem = new RaidCountItem(Owners, new List<int>());
                    break;

                case 1:
                    List<ulong> AuthUsers = new List<ulong>();
                    List<int> CupboardInstanceIDs = new List<int>();
                    int noobusercount = 0;

                    foreach (var item in SearchedEntity)
                    {
                        BuildingPrivlidge cupboard = item.GetComponentInParent<BuildingPrivlidge>();
                        if (cupboard != null)
                        {
                            if (config.RaidLimitOperationType.ToolCupboardIdentification.CheckToolCupboardInstanceID)
                                CupboardInstanceIDs.Add(cupboard.GetInstanceID());

                            if (config.RaidLimitOperationType.ToolCupboardIdentification.CheckAuthorizedPeoples)
                            {
                                foreach (ProtoBuf.PlayerNameID playernameid in cupboard.authorizedPlayers)
                                {
                                    if (AuthUsers.Contains(playernameid.userid) == false)
                                    {
                                        AuthUsers.Add(playernameid.userid);

                                        if (permission.UserHasPermission(playernameid.userid.ToString(), "antinoobraid.noob"))
                                            noobusercount++;
                                    }
                                }
                            }
                        }
                    }

                    if (0 < noobusercount && noobusercount == AuthUsers.Count)
                        raidCountItem = null;//cant raid
                    else
                        raidCountItem = new RaidCountItem(AuthUsers, CupboardInstanceIDs);
                    break;

                default:
                    goto case 0;
            }

            return raidCountItem;
        }

        PlayersDateTimeData playersDateTimeData;

        private class PlayersDateTimeData
        {
            public ListHashSet<BasePlayer> BasePlayerList = BasePlayer.activePlayerList;
            public DateTime SaveTickTime = DateTime.Now;

            public PlayersDateTimeData()
            {
            }
        }

        #endregion

        #region Command/API

        [Command("rl.reset")]
        private void ResetLimitCount(IPlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                if (!player.HasPermission(raidlimit_admin_Perm))
                {
                    player.Reply(Lang("No Permission", player.Id, command));
                    return;
                }
            }

            foreach (var item in playersData.Players)
            {
                item.Value.ResetRaidDataNCount();
                item.Value.StopCharging();
            }
            SavePlayersData();

            Puts(Lang("Raid List Reset", null));
            foreach (IPlayer current in players.Connected)
                current.Reply(Lang("Raid List Reset", current.Id));
            PlayersUpdateRaidLimitUI(false);
        }

        [Command("rl.addvalue")]
        private void IncreaseLimitCount(IPlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                if (!player.HasPermission(raidlimit_admin_Perm))
                {
                    player.Reply(Lang("No Permission", player.Id, command));
                    return;
                }
            }

            int parsedint;

            if (1 < args.Length && int.TryParse(args[1], out parsedint))
            {
                IPlayer TPlayer = GetPlayer(args[0], player);

                if (!playersData.Players.ContainsKey(TPlayer.Id))
                    playersData.Players.Add(TPlayer.Id, new PlayerInfo(TPlayer));

                int result = playersData.Players[TPlayer.Id].AddRaidCount(parsedint);
                PlayerUpdateRaidLimitUI(TPlayer.Object as BasePlayer, false);

                if (result < 0)
                {
                    player.Reply(Lang("Count DecreasedC", player.Id, TPlayer.Name, ((int)Mathf.Abs(result)).ToString()));
                    TPlayer.Reply(Lang("Count DecreasedP", TPlayer.Id, ((int)Mathf.Abs(result)).ToString()));
                }
                else
                {
                    player.Reply(Lang("Count IncreasedC", player.Id, TPlayer.Name, result.ToString()));
                    TPlayer.Reply(Lang("Count IncreasedP", TPlayer.Id, result.ToString()));
                }
            }
            else
                player.Reply(Lang("NotEnoughArgument", player.Id, 2.ToString()));
        }

        [Command("rlcheck")]
        private void CheckLimitCount(IPlayer player, string command, string[] args)
        {
            if (playersData.Players.ContainsKey(player.Id) == false)
                return;

            PlayerInfo playerinfo = playersData.Players[player.Id];

            if (GetCanRaid(playerinfo))
            {
                player.Reply(Lang("Left Raid Count", player.Id, (playerinfo.RaidLeftCount)));
            }
            else
            {
                TimeSpan playtime = GetPlayerPlaytime(player);
                player.Reply(Lang("Raid Blocked Time", player.Id, config.RaidLimitSettings.NoobCantRaidSecond, playtime.TotalSeconds));
            }
        }

        private void UIToggle(IPlayer player, string command, string[] args)
        {
            bool playerUIToggle = playersUIData.PlayersUIToggle[player.Id];
            if (playerUIToggle == true)
            {
                HideUI(player.Object as BasePlayer);
            }
            else
            {
                ShowUI(player.Object as BasePlayer);
            }
        }

        private void RegisterUICommand()
        {
            if (config.UISettings.UIEnable)
                AddCovalenceCommand("RaidUI", "UIToggle");
        }

        //API

        private void ShowUI(BasePlayer player)
        {
            playersUIData.PlayersUIToggle[player.UserIDString] = true;
            PlayerUpdateRaidLimitUI(player, true);
        }

        private void HideUI(BasePlayer player)
        {
            playersUIData.PlayersUIToggle[player.UserIDString] = false;
            PlayerDestroyRaidLimitUI(player);
        }

        //

        #endregion

        #region GUI

        public string RaidLimit_boomb = "RaidLimit_boomb";
        public string BaseRaidLimitUI = "BaseRaidLimitUI";
        public string LabelPanel = "LabelPanel";

        public void LoadImage()
        {
            if (ImageLibrary.Call<bool>("HasImage", RaidLimit_boomb))
                return;

            ImageLibrary.Call<bool>("AddImage", "https://i.imgur.com/t3QdFmG.png", RaidLimit_boomb);
        }

        private void UpdateRaidLimitUI(BasePlayer player, bool Imageupdate, int FontSize, string Msg)
        {
            if (player == null)
                return;

            if (permission.UserHasPermission(player.UserIDString, raidlimit_bypass_Perm))
                Msg = Lang("bypass GUI Msg", player.UserIDString);

            if (playersUIData.PlayersUIToggle[player.UserIDString] == false)
                return;

            if (playersData.Players.ContainsKey(player.UserIDString) == false)
                playersData.AddPlayer(player);

            CuiElementContainer RaidLimitGUI = new CuiElementContainer();

            if (Imageupdate == true)
            {
                string panel = RaidLimitGUI.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image =
                    {
                        Color = "1 1 1 0.2"
                    },

                    RectTransform =
                    {
                        AnchorMin = config.UISettings.UIPosition.AnchorMin,
                        AnchorMax = config.UISettings.UIPosition.AnchorMax
                    },
                }, "Under", BaseRaidLimitUI);

                RaidLimitGUI.Add(new CuiElement
                {
                    Name = "BombImage",
                    Parent = BaseRaidLimitUI,
                    Components =
                    {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageLibrary.Call<string>("GetImage", RaidLimit_boomb) },
                        new CuiRectTransformComponent { AnchorMin = "0 0.02", AnchorMax = "0.32 0.93" }
                    }
                });
            }

            string labelpanel = RaidLimitGUI.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image =
                {
                    Color = "0 0 0 0"
                },

                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                },
            }, BaseRaidLimitUI, LabelPanel);

            RaidLimitGUI.Add(new CuiLabel
            {
                Text =
                {
                    Text = Msg,
                    FontSize = FontSize,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.3 0",
                    AnchorMax = "1.0 1"
                }
            }, labelpanel);

            if (Imageupdate)
            {
                CuiHelper.DestroyUi(player, BaseRaidLimitUI);
            }
            else
            {
                CuiHelper.DestroyUi(player, LabelPanel);
            }
            CuiHelper.AddUi(player, RaidLimitGUI);
        }

        private void UpdatePlayerCountUI(BasePlayer player, bool imageupdate)
        {
            if (player == null)
                return;

            if (config.UISettings.UIEnable == false)
                return;

            PlayerInfo playerInfo = playersData.Players[player.UserIDString];
            string LeftCount = playerInfo.RaidLeftCount + "/" + config.RaidLimitSettings.OneTimeMaximumRaidableHomeCount;
            UpdateRaidLimitUI(player, imageupdate, 14, LeftCount);
        }

        private void UpdatePlayerNoobTimeUI(BasePlayer player, TimeSpan playtime, bool imageupdate)
        {
            UpdatePlayerTimeUI(player, TimeSpan.FromSeconds(config.RaidLimitSettings.NoobCantRaidSecond.Value).Subtract(playtime), imageupdate);
        }

        private void UpdatePlayerTimeUI(BasePlayer player, TimeSpan displaytime, bool imageupdate)
        {
            if (config.UISettings.UIEnable == false)
                return;

            string timestring = GetimeToString(displaytime);

            UpdateRaidLimitUI(player, imageupdate, 12, timestring);
        }

        private void PlayerUpdateRaidLimitUI(BasePlayer player, bool imageupdate)
        {
            if (config.UISettings.UIEnable == false)
                return;

            PlayerInfo playerInfo = playersData.Players[player.UserIDString];
            TimeSpan playtime = GetPlayerPlaytime(player);

            if (GetCanRaid(playerInfo))
            {
                if (playerInfo.Charging)
                {
                    switch (config.RaidLimitSettings.CounterChargeDelayType)
                    {
                        case 0:
                            UpdatePlayerTimeUI(player, playerInfo.NextChargeRealtime - DateTime.Now, imageupdate);
                            break;

                        case 1:
                            UpdatePlayerTimeUI(player, playerInfo.NextChargePlaytime - playtime, imageupdate);
                            break;

                        default:
                            goto case 0;
                    }
                }
                else
                    UpdatePlayerCountUI(player, imageupdate);
            }
            else
            {
                if (playerInfo.Charging)
                {
                    switch (config.RaidLimitSettings.CounterChargeDelayType)
                    {
                        case 0:
                            UpdatePlayerTimeUI(player, playerInfo.NextChargeRealtime - DateTime.Now, imageupdate);
                            break;

                        case 1:
                            UpdatePlayerTimeUI(player, playerInfo.NextChargePlaytime - playtime, imageupdate);
                            break;

                        default:
                            goto case 0;
                    }
                }
                else
                    UpdatePlayerNoobTimeUI(player, playtime, imageupdate);
            }
        }

        private void PlayerDestroyRaidLimitUI(BasePlayer player)
        {
            if (config.UISettings.UIEnable == false)
                return;

            CuiHelper.DestroyUi(player, BaseRaidLimitUI);
        }

        private void PlayersUpdateRaidLimitUI(bool imageupdate)
        {
            if (config.UISettings.UIEnable == false)
                return;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                PlayerInfo playerInfo = playersData.Players[player.UserIDString];

                if (GetCanRaid(playerInfo))
                {
                    UpdatePlayerCountUI(player, imageupdate);
                }
                else
                {
                    TimeSpan playtime = GetPlayerPlaytime(player);

                    if (playerInfo.Charging)
                    {
                        switch (config.RaidLimitSettings.CounterChargeDelayType)
                        {
                            case 0:
                                UpdatePlayerTimeUI(player, playerInfo.NextChargeRealtime - DateTime.Now, imageupdate);
                                break;

                            case 1:
                                UpdatePlayerTimeUI(player, playerInfo.NextChargePlaytime - playtime, imageupdate);
                                break;

                            default:
                                goto case 0;
                        }
                    }
                    else
                        UpdatePlayerNoobTimeUI(player, playtime, imageupdate);
                }
            }
        }

        private void PlayersDestroyRaidLimitUI()
        {
            if (config.UISettings.UIEnable == false)
                return;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, BaseRaidLimitUI);
            }
        }

        #endregion

        #region Helper

        private IPlayer GetPlayer(string nameOrID, IPlayer player)
        {
            List<BasePlayer> BasePlayerList = BasePlayer.activePlayerList.ToList();
            List<IPlayer> PlayersList = new List<IPlayer>();

            foreach (var item in BasePlayerList)
            {
                PlayersList.Add(item.IPlayer);
            }

            if (nameOrID.IsSteamId())
            {
                IPlayer result = PlayersList.Find((p) => p.Id == nameOrID);

                if (result == null)
                    player.Reply(Lang("SteamID Not Found", player?.Id, nameOrID));

                return result;
            }

            List<IPlayer> foundPlayers = new List<IPlayer>();

            foreach (IPlayer current in PlayersList)
            {
                if (current.Name.ToLower() == nameOrID.ToLower())
                    return current;

                if (current.Name.ToLower().Contains(nameOrID.ToLower()))
                    foundPlayers.Add(current);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    player.Reply(Lang("Player Not Found", player?.Id, nameOrID));
                    break;
                case 1:
                    return foundPlayers[0];
                default:
                    string[] names = (from current in foundPlayers select $"- {current.Name}").ToArray();
                    player.Reply(Lang("Multiple Players Found", player?.Id, string.Join("\n", names)));
                    break;
            }
            return null;
        }

        private void TryChatMessage(BasePlayer player, string msg)
        {
            if (PlayerSpamMessageBlockFlags.Contains(player.userID))
                return;

            player.ChatMessage(msg);
            PlayerSpamMessageBlockFlags.Add(player.userID);
            timer.Once(1f, () =>
            {
                PlayerSpamMessageBlockFlags.Remove(player.userID);
            });
        }

        private bool GetCanRaid(PlayerInfo playerInfo)
        {
            if (PlaytimeTracker != null)
            {
                return playerInfo.NoobCanRaidPlaytimeTracker;
            }
            else
            {
                return playerInfo.NoobCanRaid;
            }
        }

        private string GetimeToString(TimeSpan lefttime)
        {
            var days = lefttime.Days;
            var hours = lefttime.Hours;
            hours += (days * 24);
            var mins = lefttime.Minutes;
            var secs = lefttime.Seconds;
            return string.Format("<color=red>{0:00}:{1:00}:{2:00}</color>", hours, mins, secs);
        }

        private TimeSpan GetPlayerPlaytime(IPlayer player) => GetPlayerPlaytime(player.Id);

        private TimeSpan GetPlayerPlaytime(BasePlayer player) => GetPlayerPlaytime(player.UserIDString);

        private TimeSpan GetPlayerPlaytime(string playerId)
        {
            if (PlaytimeTracker != null)
            {
                double? obj = PlaytimeTracker.Call<double>("GetPlayTime", playerId);

                if (obj != null)
                {
                    return TimeSpan.FromSeconds(obj.Value);
                }
                else
                {
                    return playersData.Players[playerId].Playtime;
                }
            }
            return playersData.Players[playerId].Playtime;
        }

        private BasePlayer TryGetPlayer(ulong playerId)
        {
            return BasePlayer.FindByID(playerId);
        }

        #endregion
    }
}

// --- End of file: RaidLimit.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/remover-tool ---
// --- Original File Path: R/RemoverTool/RemoverTool.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using VLB;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Remover Tool", "Reneb/Fuji/Arainrr/Tryhard", "4.3.43", ResourceId = 651)]
    [Description("Building and entity removal tool")]
    public class RemoverTool : RustPlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin Friends, ServerRewards, Clans, Economics, ImageLibrary, BuildingOwners, RustTranslationAPI, NoEscape;

        private const string ECONOMICS_KEY = "economics";
        private const string SERVER_REWARDS_KEY = "serverrewards";

        private const string PERMISSION_ALL = "removertool.all";
        private const string PERMISSION_ADMIN = "removertool.admin";
        private const string PERMISSION_NORMAL = "removertool.normal";
        private const string PERMISSION_TARGET = "removertool.target";
        private const string PERMISSION_EXTERNAL = "removertool.external";
        private const string PERMISSION_OVERRIDE = "removertool.override";
        private const string PERMISSION_STRUCTURE = "removertool.structure";

        private const string PREFAB_ITEM_DROP = "assets/prefabs/misc/item drop/item_drop.prefab";

        private const int LAYER_ALL = 1 << 0 | 1 << 8 | 1 << 21;
        private const int LAYER_TARGET = ~(1 << 2 | 1 << 3 | 1 << 4 | 1 << 10 | 1 << 18 | 1 << 28 | 1 << 29);

        private static RemoverTool _instance;
        private static BUTTON _removeButton;
        private static RemoveMode _removeMode;

        private readonly object _false = false;
        private bool _configChanged;
        private bool _removeOverride;
        private Coroutine _removeAllCoroutine;
        private Coroutine _removeStructureCoroutine;
        private Coroutine _removeExternalCoroutine;
        private Coroutine _removePlayerEntityCoroutine;

        private StringBuilder _debugStringBuilder;
        private Hash<ulong, float> _entitySpawnedTimes;
        private readonly Hash<ulong, float> _cooldownTimes = new Hash<ulong, float>();

        private enum RemoveMode
        {
            None,
            NoHeld,
            MeleeHit,
            SpecificTool
        }

        private enum RemoveType
        {
            None,
            All,
            Admin,
            Normal,
            External,
            Structure
        }

        private enum PlayerEntityRemoveType
        {
            All,
            Cupboard,
            Building
        }

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            _instance = this;
            permission.RegisterPermission(PERMISSION_ALL, this);
            permission.RegisterPermission(PERMISSION_ADMIN, this);
            permission.RegisterPermission(PERMISSION_NORMAL, this);
            permission.RegisterPermission(PERMISSION_TARGET, this);
            permission.RegisterPermission(PERMISSION_OVERRIDE, this);
            permission.RegisterPermission(PERMISSION_EXTERNAL, this);
            permission.RegisterPermission(PERMISSION_STRUCTURE, this);

            Unsubscribe(nameof(OnHammerHit));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
            Unsubscribe(nameof(OnPlayerAttack));
            Unsubscribe(nameof(OnActiveItemChanged));
            Unsubscribe(nameof(OnRaidBlock));
            Unsubscribe(nameof(OnCombatBlock));

            foreach (var perm in _configData.permission.Keys)
            {
                if (!permission.PermissionExists(perm, this))
                {
                    permission.RegisterPermission(perm, this);
                }
            }
            cmd.AddChatCommand(_configData.chat.command, this, nameof(CmdRemove));
        }

        private void OnServerInitialized()
        {
            Initialize();
            UpdateConfig();
            LoadConfig();
            _removeMode = RemoveMode.None;
            if (_configData.removerMode.noHeldMode)
            {
                _removeMode = RemoveMode.NoHeld;
            }
            if (_configData.removerMode.meleeHitMode)
            {
                _removeMode = RemoveMode.MeleeHit;
            }
            if (_configData.removerMode.specificToolMode)
            {
                _removeMode = RemoveMode.SpecificTool;
            }
            if (_removeMode == RemoveMode.MeleeHit)
            {
                BaseMelee baseMelee;
                ItemDefinition itemDefinition;
                if (string.IsNullOrEmpty(_configData.removerMode.meleeHitItemShortname) ||
                        (itemDefinition = ItemManager.FindItemDefinition(_configData.removerMode.meleeHitItemShortname)) == null ||
                        (baseMelee = itemDefinition.GetComponent<ItemModEntity>()?.entityPrefab.Get()?.GetComponent<BaseMelee>()) == null)
                {
                    PrintError($"{_configData.removerMode.meleeHitItemShortname} is not an item shortname for a melee tool");
                    _removeMode = RemoveMode.None;
                }
                else
                {
                    Subscribe(baseMelee is Hammer ? nameof(OnHammerHit) : nameof(OnPlayerAttack));
                }
            }

            if (_configData.noEscape.useRaidBlocker)
            {
                Subscribe(nameof(OnRaidBlock));
            }
            if (_configData.noEscape.useCombatBlocker)
            {
                Subscribe(nameof(OnCombatBlock));
            }

            if (_configData.global.entityTimeLimit)
            {
                _entitySpawnedTimes = new Hash<ulong, float>();
                Subscribe(nameof(OnEntitySpawned));
                Subscribe(nameof(OnEntityKill));
            }
            if (_configData.global.logToFile)
            {
                _debugStringBuilder = new StringBuilder();
            }

            if (_removeMode == RemoveMode.MeleeHit && _configData.removerMode.meleeHitEnableInHand ||
                    _removeMode == RemoveMode.SpecificTool && _configData.removerMode.specificToolEnableInHand)
            {
                Subscribe(nameof(OnActiveItemChanged));
            }

            if (!Enum.TryParse(_configData.global.removeButton, true, out _removeButton) || !Enum.IsDefined(typeof(BUTTON), _removeButton))
            {
                PrintError($"{_configData.global.removeButton} is an invalid button. The remove button has been changed to 'FIRE_PRIMARY'.");
                _removeButton = BUTTON.FIRE_PRIMARY;
                _configData.global.removeButton = _removeButton.ToString();
                SaveConfig();
            }
            if (ImageLibrary != null)
            {
                foreach (var image in _configData.imageUrls)
                {
                    AddImageToLibrary(image.Value, image.Key);
                }
                if (_configData.ui.showCrosshair)
                {
                    AddImageToLibrary(_configData.ui.crosshairImageUrl, UINAME_CROSSHAIR);
                }
            }
        }

        private void Unload()
        {
            // if (_configChanged)
            // {
            //     SaveConfig();
            // }
            SaveDebug();
            if (_removeAllCoroutine != null)
            {
                ServerMgr.Instance.StopCoroutine(_removeAllCoroutine);
            }
            if (_removeStructureCoroutine != null)
            {
                ServerMgr.Instance.StopCoroutine(_removeStructureCoroutine);
            }
            if (_removeExternalCoroutine != null)
            {
                ServerMgr.Instance.StopCoroutine(_removeExternalCoroutine);
            }
            if (_removePlayerEntityCoroutine != null)
            {
                ServerMgr.Instance.StopCoroutine(_removePlayerEntityCoroutine);
            }
            foreach (var player in BasePlayer.activePlayerList)
            {
                player.GetComponent<ToolRemover>()?.DisableTool();
            }
            _configData = null;
            _instance = null;
        }

        private void OnServerSave()
        {
            if (_configChanged)
            {
                _configChanged = false;
                timer.Once(Random.Range(0f, 60f), SaveConfig);
            }
            if (_configData.global.logToFile)
            {
                timer.Once(Random.Range(0f, 60f), SaveDebug);
            }
            if (_configData.global.entityTimeLimit && _entitySpawnedTimes != null)
            {
                var currentTime = Time.realtimeSinceStartup;
                foreach (var entry in _entitySpawnedTimes.ToArray())
                {
                    if (currentTime - entry.Value > _configData.global.limitTime)
                    {
                        _entitySpawnedTimes.Remove(entry.Key);
                    }
                }
            }
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            if (entity == null || entity.net == null)
            {
                return;
            }
            // if (!CanEntityBeSaved(entity)) return;
            _entitySpawnedTimes[entity.net.ID.Value] = Time.realtimeSinceStartup;
        }

        private void OnEntityKill(BaseEntity entity)
        {
            if (entity == null || entity.net == null)
            {
                return;
            }
            _entitySpawnedTimes.Remove(entity.net.ID.Value);
        }

        private object OnPlayerAttack(BasePlayer player, HitInfo info)
        {
            return OnHammerHit(player, info);
        }

        private object OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (player == null || info.HitEntity == null)
            {
                return null;
            }
            var toolRemover = player.GetComponent<ToolRemover>();
            if (toolRemover == null)
            {
                return null;
            }
            if (!IsMeleeTool(player))
            {
                return null;
            }
            toolRemover.HitEntity = info.HitEntity;
            return _false;
        }

        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (newItem == null)
            {
                return;
            }
            if (player == null || !player.userID.IsSteamId())
            {
                return;
            }
            if (IsToolRemover(player))
            {
                return;
            }
            if (_removeMode == RemoveMode.MeleeHit && IsMeleeTool(newItem))
            {
                ToggleRemove(player, RemoveType.Normal);
                return;
            }
            if (_removeMode == RemoveMode.SpecificTool && IsSpecificTool(newItem))
            {
                ToggleRemove(player, RemoveType.Normal);
            }
        }

        #endregion Oxide Hooks

        #region Initializing

        private readonly HashSet<Construction> _constructions = new HashSet<Construction>();
        private readonly Dictionary<string, int> _itemShortNameToItemId = new Dictionary<string, int>();
        private readonly Dictionary<string, string> _prefabNameToStructure = new Dictionary<string, string>();
        private readonly Dictionary<string, string> _shortPrefabNameToDeployable = new Dictionary<string, string>();

        private void Initialize()
        {
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                if (!_itemShortNameToItemId.ContainsKey(itemDefinition.shortname))
                {
                    _itemShortNameToItemId.Add(itemDefinition.shortname, itemDefinition.itemid);
                }
                var deployablePrefab = itemDefinition.GetComponent<ItemModDeployable>()?.entityPrefab?.resourcePath;
                if (string.IsNullOrEmpty(deployablePrefab))
                {
                    continue;
                }
                var shortPrefabName = Utility.GetFileNameWithoutExtension(deployablePrefab);
                if (!string.IsNullOrEmpty(shortPrefabName) && !_shortPrefabNameToDeployable.ContainsKey(shortPrefabName))
                {
                    _shortPrefabNameToDeployable.Add(shortPrefabName, itemDefinition.shortname);
                }
            }
            foreach (var entry in PrefabAttribute.server.prefabs)
            {
                var construction = entry.Value.Find<Construction>().FirstOrDefault();
                if (construction != null && construction.deployable == null && !string.IsNullOrEmpty(construction.info.name.english))
                {
                    _constructions.Add(construction);
                    if (!_prefabNameToStructure.ContainsKey(construction.fullName))
                    {
                        _prefabNameToStructure.Add(construction.fullName, construction.info.name.english);
                    }
                }
            }
        }

        #endregion Initializing

        #region Methods

        private static string GetRemoveTypeName(RemoveType removeType)
        {
            return _configData.removeType[removeType].displayName;
        }

        private static void DropItemContainer(ItemContainer itemContainer, Vector3 position, Quaternion rotation)
        {
            itemContainer?.Drop(PREFAB_ITEM_DROP, position, rotation, 0);
        }

        private static bool IsExternalWall(StabilityEntity stabilityEntity)
        {
            return stabilityEntity.ShortPrefabName.Contains("external");
        }

        private static bool CanEntityBeDisplayed(BaseEntity entity, BasePlayer player)
        {
            var stash = entity as StashContainer;
            return stash == null || !stash.IsHidden() || stash.PlayerInRange(player);
        }

        private static bool CanEntityBeSaved(BaseEntity entity)
        {
            if (entity is BuildingBlock)
            {
                return true;
            }
            EntitySettings entitySettings;
            if (_configData.remove.entity.TryGetValue(entity.ShortPrefabName, out entitySettings) && entitySettings.enabled)
            {
                return true;
            }
            return false;
        }

        private static bool HasEntityEnabled(BaseEntity entity)
        {
            var buildingBlock = entity as BuildingBlock;
            if (buildingBlock != null)
            {
                bool valid;
                if (_configData.remove.validConstruction.TryGetValue(buildingBlock.grade, out valid) && valid)
                {
                    return true;
                }
            }
            EntitySettings entitySettings;
            if (_configData.remove.entity.TryGetValue(entity.ShortPrefabName, out entitySettings) && entitySettings.enabled)
            {
                return true;
            }
            return false;
        }

        private static bool IsRemovableEntity(BaseEntity entity)
        {
            if (_instance._shortPrefabNameToDeployable.ContainsKey(entity.ShortPrefabName)
                    || _instance._prefabNameToStructure.ContainsKey(entity.PrefabName)
                    || _configData.remove.entity.ContainsKey(entity.ShortPrefabName))
            {
                var baseCombatEntity = entity as BaseCombatEntity;
                if (baseCombatEntity != null)
                {
                    if (baseCombatEntity.IsDead())
                    {
                        return false;
                    }
                    if (baseCombatEntity.pickup.itemTarget != null)
                    {
                        return true;
                    }
                }
                return true;
            }
            return false;
        }

        private static string GetEntityImage(string name)
        {
            if (_instance.ImageLibrary == null)
            {
                return null;
            }
            if (_configData.imageUrls.ContainsKey(name))
            {
                return GetImageFromLibrary(name);
            }
            if (_instance._itemShortNameToItemId.ContainsKey(name))
            {
                return GetImageFromLibrary(name);
            }
            return null;
        }

        private static string GetItemImage(string shortname)
        {
            if (_instance.ImageLibrary == null)
            {
                return null;
            }
            switch (shortname.ToLower())
            {
                case ECONOMICS_KEY:
                    return GetImageFromLibrary(ECONOMICS_KEY);

                case SERVER_REWARDS_KEY:
                    return GetImageFromLibrary(SERVER_REWARDS_KEY);
            }
            return GetEntityImage(shortname);
        }

        private static void TryFindEntityName(BasePlayer player, BaseEntity entity, out string displayName, out string imageName)
        {
            var target = entity as BasePlayer;
            if (target != null)
            {
                imageName = target.userID.IsSteamId() ? target.UserIDString : target.ShortPrefabName;
                displayName = $"{target.displayName} ({target.ShortPrefabName})";
                return;
            }
            EntitySettings entitySettings;
            if (_configData.remove.entity.TryGetValue(entity.ShortPrefabName, out entitySettings))
            {
                imageName = entity.ShortPrefabName;
                displayName = _instance.GetDeployableDisplayName(player, entity.ShortPrefabName, entitySettings.displayName);
                return;
            }

            string structureName;
            if (_instance._prefabNameToStructure.TryGetValue(entity.PrefabName, out structureName))
            {
                BuildingBlocksSettings buildingBlockSettings;
                if (_configData.remove.buildingBlock.TryGetValue(structureName, out buildingBlockSettings))
                {
                    imageName = structureName;
                    displayName = _instance.GetConstructionDisplayName(player, entity.PrefabName, buildingBlockSettings.displayName);
                    return;
                }
            }

            imageName = entity.ShortPrefabName;
            displayName = entity.ShortPrefabName;
        }

        private static string GetDisplayNameByCurrencyName(string language, string currencyName, long skinId)
        {
            var itemDefinition = ItemManager.FindItemDefinition(currencyName);
            if (itemDefinition != null)
            {
                var translationKey = $"{itemDefinition.shortname}_{skinId}";
                var translationValue = GetCurrencyDisplayName(translationKey, itemDefinition.displayName.english, true);
                if (skinId <= 0 || string.IsNullOrEmpty(translationValue))
                {
                    var displayName = _instance.GetItemDisplayName(language, itemDefinition.shortname);
                    if (!string.IsNullOrEmpty(displayName))
                    {
                        return displayName;
                    }
                    return itemDefinition.displayName.english;
                }
                return GetCurrencyDisplayName(translationKey, itemDefinition.displayName.english);
            }
            return GetCurrencyDisplayName(currencyName, currencyName);
        }

        private static string GetCurrencyDisplayName(string currencyName, string defaultName = null, bool readOnly = false)
        {
            string displayName;
            if (_configData.remove.displayNames.TryGetValue(currencyName, out displayName))
            {
                return displayName;
            }
            if (!readOnly)
            {
                _configData.remove.displayNames.Add(currencyName, defaultName);
                _instance._configChanged = true;
            }
            return defaultName;
        }

        private static PermissionSettings GetPermissionSettings(BasePlayer player)
        {
            var priority = 0;
            PermissionSettings permissionSettings = null;
            foreach (var entry in _configData.permission)
            {
                if (entry.Value.priority >= priority && _instance.permission.UserHasPermission(player.UserIDString, entry.Key))
                {
                    priority = entry.Value.priority;
                    permissionSettings = entry.Value;
                }
            }
            return permissionSettings ?? new PermissionSettings();
        }

        private static Vector2 GetAnchor(string anchor)
        {
            var array = anchor.Split(' ');
            return new Vector2(float.Parse(array[0]), float.Parse(array[1]));
        }

        private static bool AddImageToLibrary(string url, string shortname, ulong skin = 0)
        {
            return (bool)_instance.ImageLibrary.Call("AddImage", url, shortname.ToLower(), skin);
        }

        private static string GetImageFromLibrary(string shortname, ulong skin = 0, bool returnUrl = false)
        {
            return string.IsNullOrEmpty(shortname) ? null : (string)_instance.ImageLibrary.Call("GetImage", shortname.ToLower(), skin, returnUrl);
        }

        #endregion Methods

        #region NoEscape

        private void OnRaidBlock(BasePlayer player)
        {
            if (_configData.noEscape.useRaidBlocker)
            {
                // Print(player, Lang("RaidBlocked", player.UserIDString));
                player.GetComponent<ToolRemover>()?.DisableTool(false);
            }
        }

        private void OnCombatBlock(BasePlayer player)
        {
            if (_configData.noEscape.useCombatBlocker)
            {
                // Print(player, Lang("CombatBlocked", player.UserIDString));
                player.GetComponent<ToolRemover>()?.DisableTool(false);
            }
        }

        private bool IsPlayerBlocked(BasePlayer player, out string reason)
        {
            if (NoEscape != null)
            {
                if (_configData.noEscape.useRaidBlocker && IsRaidBlocked(player.UserIDString))
                {
                    reason = Lang("RaidBlocked", player.UserIDString);
                    return true;
                }
                if (_configData.noEscape.useCombatBlocker && IsCombatBlocked(player.UserIDString))
                {
                    reason = Lang("CombatBlocked", player.UserIDString);
                    return true;
                }
            }

            reason = null;
            return false;
        }

        private bool IsRaidBlocked(string playerID)
        {
            return (bool)NoEscape.Call("IsRaidBlocked", playerID);
        }

        private bool IsCombatBlocked(string playerID)
        {
            return (bool)NoEscape.Call("IsCombatBlocked", playerID);
        }

        #endregion NoEscape

        #region UI

        private static class UI
        {
            public static CuiElementContainer CreateElementContainer(string parent, string panelName, string backgroundColor, string anchorMin, string anchorMax, string offsetMin = "", string offsetMax = "", bool cursor = false)
            {
                return new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            Image = { Color = backgroundColor },
                            RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax, OffsetMin = offsetMin, OffsetMax = offsetMax },
                            CursorEnabled = cursor
                        },
                        parent, panelName
                    }
                };
            }

            public static void CreatePanel(ref CuiElementContainer container, string panelName, string backgroundColor, string anchorMin, string anchorMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = backgroundColor },
                    RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax },
                    CursorEnabled = cursor
                }, panelName);
            }

            public static void CreateLabel(ref CuiElementContainer container, string panelName, string textColor, string text, int fontSize, string anchorMin, string anchorMax, TextAnchor align = TextAnchor.MiddleCenter, float fadeIn = 0f)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = textColor, FontSize = fontSize, Align = align, Text = text, FadeIn = fadeIn },
                    RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax }
                }, panelName);
            }

            public static void CreateImage(ref CuiElementContainer container, string panelName, string image, string anchorMin, string anchorMax, string color = "1 1 1 1")
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panelName,
                    Components =
                    {
                        new CuiRawImageComponent { Color = color, Png = image },
                        new CuiRectTransformComponent { AnchorMin = anchorMin, AnchorMax = anchorMax }
                    }
                });
            }

            public static void CreateImage(ref CuiElementContainer container, string panelName, int itemId, ulong skinId, string anchorMin, string anchorMax)
            {
                container.Add(new CuiPanel
                {
                    Image = { ItemId = itemId, SkinId = skinId },
                    RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax },
                    CursorEnabled = false
                }, panelName);
            }
        }

        [Flags]
        private enum UiEntry
        {
            None = 0,
            Entity = 1,
            Price = 1 << 1,
            Refund = 1 << 2,
            Auth = 1 << 3
        }

        private const string UINAME_MAIN = "RemoverToolUI_Main";
        private const string UINAME_TIMELEFT = "RemoverToolUI_TimeLeft";
        private const string UINAME_ENTITY = "RemoverToolUI_Entity";
        private const string UINAME_PRICE = "RemoverToolUI_Price";
        private const string UINAME_REFUND = "RemoverToolUI_Refund";
        private const string UINAME_AUTH = "RemoverToolUI_Auth";
        private const string UINAME_CROSSHAIR = "RemoverToolUI_Crosshair";

        private static void CreateCrosshairUI(BasePlayer player)
        {
            if (_instance.ImageLibrary == null)
            {
                return;
            }
            var image = GetImageFromLibrary(UINAME_CROSSHAIR);
            if (string.IsNullOrEmpty(image))
            {
                return;
            }
            var container = UI.CreateElementContainer("Hud", UINAME_CROSSHAIR, "0 0 0 0", _configData.ui.crosshairAnchorMin, _configData.ui.crosshairAnchorMax, _configData.ui.crosshairOffsetMin, _configData.ui.crosshairOffsetMax);
            UI.CreateImage(ref container, UINAME_CROSSHAIR, image, "0 0", "1 1", _configData.ui.crosshairColor);
            CuiHelper.DestroyUi(player, UINAME_CROSSHAIR);
            CuiHelper.AddUi(player, container);
        }

        private static void CreateMainUI(BasePlayer player, RemoveType removeType)
        {
            var container = UI.CreateElementContainer("Hud", UINAME_MAIN, _configData.ui.removerToolBackgroundColor, _configData.ui.removerToolAnchorMin, _configData.ui.removerToolAnchorMax, _configData.ui.removerToolOffsetMin, _configData.ui.removerToolOffsetMax);
            UI.CreatePanel(ref container, UINAME_MAIN, _configData.ui.removeBackgroundColor, _configData.ui.removeAnchorMin, _configData.ui.removeAnchorMax);
            UI.CreateLabel(ref container, UINAME_MAIN, _configData.ui.removeTextColor, _instance.Lang("RemoverToolType", player.UserIDString, GetRemoveTypeName(removeType)), _configData.ui.removeTextSize, _configData.ui.removeTextAnchorMin, _configData.ui.removeTextAnchorMax, TextAnchor.MiddleLeft);
            CuiHelper.DestroyUi(player, UINAME_MAIN);
            CuiHelper.AddUi(player, container);
        }

        private static void UpdateTimeLeftUI(BasePlayer player, RemoveType removeType, int timeLeft, int currentRemoved, int maxRemovable)
        {
            var container = UI.CreateElementContainer(UINAME_MAIN, UINAME_TIMELEFT, _configData.ui.timeLeftBackgroundColor, _configData.ui.timeLeftAnchorMin, _configData.ui.timeLeftAnchorMax);
            UI.CreateLabel(ref container, UINAME_TIMELEFT, _configData.ui.timeLeftTextColor, _instance.Lang("TimeLeft", player.UserIDString, timeLeft, removeType == RemoveType.Normal || removeType == RemoveType.Admin ? maxRemovable == 0 ? $"{currentRemoved} / {_instance.Lang("Unlimit", player.UserIDString)}" : $"{currentRemoved} / {maxRemovable}" : currentRemoved.ToString()), _configData.ui.timeLeftTextSize, _configData.ui.timeLeftTextAnchorMin, _configData.ui.timeLeftTextAnchorMax, TextAnchor.MiddleLeft);
            CuiHelper.DestroyUi(player, UINAME_TIMELEFT);
            CuiHelper.AddUi(player, container);
        }

        private static void UpdateEntityUI(BasePlayer player, BaseEntity targetEntity, RemovableEntityInfo? info)
        {
            var container = UI.CreateElementContainer(UINAME_MAIN, UINAME_ENTITY, _configData.ui.entityBackgroundColor, _configData.ui.entityAnchorMin, _configData.ui.entityAnchorMax);

            string displayName, imageName;
            TryFindEntityName(player, targetEntity, out displayName, out imageName);
            if (info.HasValue && !string.IsNullOrEmpty(info.Value.DisplayName.Value))
            {
                displayName = info.Value.DisplayName.Value;
            }
            UI.CreateLabel(ref container, UINAME_ENTITY, _configData.ui.entityTextColor, displayName, _configData.ui.entityTextSize, _configData.ui.entityTextAnchorMin, _configData.ui.entityTextAnchorMax, TextAnchor.MiddleLeft);
            if (_configData.ui.entityImageEnabled)
            {
                var imageAnchorMin = _configData.ui.entityImageAnchorMin;
                var imageAnchorMax = _configData.ui.entityImageAnchorMax;
                if (info.HasValue && !string.IsNullOrEmpty(info.Value.ImageId.Value))
                {
                    var image = info.Value.ImageId.Value;
                    if (!string.IsNullOrEmpty(image))
                    {
                        UI.CreateImage(ref container, UINAME_ENTITY, image, imageAnchorMin, imageAnchorMax);
                    }
                }
                else if (!string.IsNullOrEmpty(imageName))
                {
                    string shortname;
                    int itemId;
                    if (_instance._shortPrefabNameToDeployable.TryGetValue(imageName, out shortname) && _instance._itemShortNameToItemId.TryGetValue(shortname, out itemId))
                    {
                        UI.CreateImage(ref container, UINAME_ENTITY, itemId, targetEntity.skinID, imageAnchorMin, imageAnchorMax);
                    }
                    else
                    {
                        var image = GetEntityImage(imageName);
                        if (!string.IsNullOrEmpty(image))
                        {
                            UI.CreateImage(ref container, UINAME_ENTITY, image, imageAnchorMin, imageAnchorMax);
                        }
                    }
                }
            }
            CuiHelper.DestroyUi(player, UINAME_ENTITY);
            CuiHelper.AddUi(player, container);
        }

        private static void UpdatePriceUI(BasePlayer player, BaseEntity targetEntity, RemovableEntityInfo? info, bool usePrice)
        {
            Dictionary<string, CurrencyInfo> price = null;
            if (usePrice)
            {
                price = _instance.GetPrice(targetEntity, info);
            }
            var container = UI.CreateElementContainer(UINAME_MAIN, UINAME_PRICE, _configData.ui.priceBackgroundColor, _configData.ui.priceAnchorMin, _configData.ui.priceAnchorMax);
            UI.CreateLabel(ref container, UINAME_PRICE, _configData.ui.priceTextColor, _instance.Lang("Price", player.UserIDString), _configData.ui.priceTextSize, _configData.ui.priceTextAnchorMin, _configData.ui.priceTextAnchorMax, TextAnchor.MiddleLeft);
            if (price == null || price.Count == 0)
            {
                UI.CreateLabel(ref container, UINAME_PRICE, _configData.ui.price2TextColor, _instance.Lang("Free", player.UserIDString), _configData.ui.price2TextSize, _configData.ui.price2TextAnchorMin, _configData.ui.price2TextAnchorMax, TextAnchor.MiddleLeft);
            }
            else
            {
                var anchorMin = _configData.ui.Price2TextAnchorMin;
                var anchorMax = _configData.ui.Price2TextAnchorMax;
                var x = (anchorMax.y - anchorMin.y) / price.Count;
                var textSize = _configData.ui.price2TextSize - price.Count;
                var language = _instance.lang.GetLanguage(player.UserIDString);

                var i = 0;
                foreach (var entry in price)
                {
                    var externalItemInfo = info?.Price[entry.Key];
                    var displayText = !externalItemInfo.HasValue || string.IsNullOrEmpty(externalItemInfo.Value.DisplayName.Value)
                            ? $"{GetDisplayNameByCurrencyName(language, entry.Key, entry.Value.SkinId)}  <color=#00B5FF>x{entry.Value.Amount}</color>"
                            : $"{externalItemInfo.Value.DisplayName.Value} x{externalItemInfo.Value.Amount.Value}";

                    UI.CreateLabel(ref container, UINAME_PRICE, _configData.ui.price2TextColor, displayText, textSize, $"{anchorMin.x} {anchorMin.y + i * x}", $"{anchorMax.x} {anchorMin.y + (i + 1) * x}", TextAnchor.MiddleLeft);
                    if (_configData.ui.imageEnabled)
                    {
                        var imageAnchorMin = $"{anchorMax.x - _configData.ui.rightDistance - x * _configData.ui.imageScale} {anchorMin.y + i * x}";
                        var imageAnchorMax = $"{anchorMax.x - _configData.ui.rightDistance} {anchorMin.y + (i + 1) * x}";
                        if (externalItemInfo.HasValue && !string.IsNullOrEmpty(externalItemInfo.Value.ImageId.Value))
                        {
                            var image = externalItemInfo.Value.ImageId.Value;
                            if (!string.IsNullOrEmpty(image))
                            {
                                UI.CreateImage(ref container, UINAME_PRICE, image, imageAnchorMin, imageAnchorMax);
                            }
                        }
                        else
                        {
                            int itemId;
                            if (_instance._itemShortNameToItemId.TryGetValue(entry.Key, out itemId))
                            {
                                UI.CreateImage(ref container, UINAME_PRICE, itemId, entry.Value.SkinId >= 0 ? (ulong)entry.Value.SkinId : 0, imageAnchorMin, imageAnchorMax);
                            }
                            else
                            {
                                var image = GetItemImage(entry.Key);
                                if (!string.IsNullOrEmpty(image))
                                {
                                    UI.CreateImage(ref container, UINAME_PRICE, image, imageAnchorMin, imageAnchorMax);
                                }
                            }
                        }
                    }
                    i++;
                }
            }
            CuiHelper.DestroyUi(player, UINAME_PRICE);
            CuiHelper.AddUi(player, container);
        }

        private static void UpdateRefundUI(BasePlayer player, BaseEntity targetEntity, RemovableEntityInfo? info, bool useRefund)
        {
            Dictionary<string, CurrencyInfo> refund = null;
            if (useRefund)
            {
                refund = _instance.GetRefund(targetEntity, info);
            }
            var container = UI.CreateElementContainer(UINAME_MAIN, UINAME_REFUND, _configData.ui.refundBackgroundColor, _configData.ui.refundAnchorMin, _configData.ui.refundAnchorMax);
            UI.CreateLabel(ref container, UINAME_REFUND, _configData.ui.refundTextColor, _instance.Lang("Refund", player.UserIDString), _configData.ui.refundTextSize, _configData.ui.refundTextAnchorMin, _configData.ui.refundTextAnchorMax, TextAnchor.MiddleLeft);

            if (refund == null || refund.Count == 0)
            {
                UI.CreateLabel(ref container, UINAME_REFUND, _configData.ui.refund2TextColor, _instance.Lang("Nothing", player.UserIDString), _configData.ui.refund2TextSize, _configData.ui.refund2TextAnchorMin, _configData.ui.refund2TextAnchorMax, TextAnchor.MiddleLeft);
            }
            else
            {
                var anchorMin = _configData.ui.Refund2TextAnchorMin;
                var anchorMax = _configData.ui.Refund2TextAnchorMax;
                var x = (anchorMax.y - anchorMin.y) / refund.Count;
                var textSize = _configData.ui.refund2TextSize - refund.Count;
                var language = _instance.lang.GetLanguage(player.UserIDString);

                var i = 0;
                foreach (var entry in refund)
                {
                    var externalItemInfo = info?.Refund[entry.Key];
                    var displayText = !externalItemInfo.HasValue || string.IsNullOrEmpty(externalItemInfo.Value.DisplayName.Value)
                            ? $"{GetDisplayNameByCurrencyName(language, entry.Key, entry.Value.SkinId)}  <color=#00B5FF>x{entry.Value.Amount}</color>"
                            : $"{externalItemInfo.Value.DisplayName.Value} x{externalItemInfo.Value.Amount.Value}";

                    UI.CreateLabel(ref container, UINAME_REFUND, _configData.ui.refund2TextColor, displayText, textSize, $"{anchorMin.x} {anchorMin.y + i * x}", $"{anchorMax.x} {anchorMin.y + (i + 1) * x}", TextAnchor.MiddleLeft);
                    if (_configData.ui.imageEnabled)
                    {
                        var imageAnchorMin = $"{anchorMax.x - _configData.ui.rightDistance - x * _configData.ui.imageScale} {anchorMin.y + i * x}";
                        var imageAnchorMax = $"{anchorMax.x - _configData.ui.rightDistance} {anchorMin.y + (i + 1) * x}";
                        if (externalItemInfo.HasValue && !string.IsNullOrEmpty(externalItemInfo.Value.ImageId.Value))
                        {
                            var image = externalItemInfo.Value.ImageId.Value;
                            if (!string.IsNullOrEmpty(image))
                            {
                                UI.CreateImage(ref container, UINAME_REFUND, image, imageAnchorMin, imageAnchorMax);
                            }
                        }
                        else
                        {
                            int itemId;
                            if (_instance._itemShortNameToItemId.TryGetValue(entry.Key, out itemId))
                            {
                                UI.CreateImage(ref container, UINAME_REFUND, itemId, entry.Value.SkinId >= 0 ? (ulong)entry.Value.SkinId : 0, imageAnchorMin, imageAnchorMax);
                            }
                            else
                            {
                                var image = GetItemImage(entry.Key);
                                if (!string.IsNullOrEmpty(image))
                                {
                                    UI.CreateImage(ref container, UINAME_REFUND, image, imageAnchorMin, imageAnchorMax);
                                }
                            }
                        }
                    }
                    i++;
                }
            }
            CuiHelper.DestroyUi(player, UINAME_REFUND);
            CuiHelper.AddUi(player, container);
        }

        private static void UpdateAuthorizationUI(BasePlayer player, RemoveType removeType, BaseEntity targetEntity, RemovableEntityInfo? info, bool shouldPay)
        {
            string reason;
            var color = _instance.CanRemoveEntity(player, removeType, targetEntity, info, shouldPay, out reason) ? _configData.ui.allowedBackgroundColor : _configData.ui.refusedBackgroundColor;
            var container = UI.CreateElementContainer(UINAME_MAIN, UINAME_AUTH, color, _configData.ui.authorizationsAnchorMin, _configData.ui.authorizationsAnchorMax);
            UI.CreateLabel(ref container, UINAME_AUTH, _configData.ui.authorizationsTextColor, reason, _configData.ui.authorizationsTextSize, _configData.ui.authorizationsTextAnchorMin, _configData.ui.authorizationsTextAnchorMax, TextAnchor.MiddleLeft);
            CuiHelper.DestroyUi(player, UINAME_AUTH);
            CuiHelper.AddUi(player, container);
        }

        private static void DestroyAllUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UINAME_CROSSHAIR);
            CuiHelper.DestroyUi(player, UINAME_MAIN);
        }

        private static void DestroyUiEntry(BasePlayer player, UiEntry uiEntry)
        {
            switch (uiEntry)
            {
                case UiEntry.Entity:
                    CuiHelper.DestroyUi(player, UINAME_ENTITY);
                    return;

                case UiEntry.Price:
                    CuiHelper.DestroyUi(player, UINAME_PRICE);
                    return;

                case UiEntry.Refund:
                    CuiHelper.DestroyUi(player, UINAME_REFUND);
                    return;

                case UiEntry.Auth:
                    CuiHelper.DestroyUi(player, UINAME_AUTH);
                    return;
            }
        }

        #endregion UI

        #region ToolRemover Component

        #region Tool Helpers

        private static bool IsSpecificTool(BasePlayer player)
        {
            var heldItem = player.GetActiveItem();
            return IsSpecificTool(heldItem);
        }

        private static bool IsSpecificTool(Item heldItem)
        {
            if (heldItem != null && heldItem.info.shortname == _configData.removerMode.specificToolShortName)
            {
                if (_configData.removerMode.specificToolSkin < 0)
                {
                    return true;
                }
                return heldItem.skin == (ulong)_configData.removerMode.specificToolSkin;
            }
            return false;
        }

        private static bool IsMeleeTool(BasePlayer player)
        {
            var heldItem = player.GetActiveItem();
            return IsMeleeTool(heldItem);
        }

        private static bool IsMeleeTool(Item heldItem)
        {
            if (heldItem != null && heldItem.info.shortname == _configData.removerMode.meleeHitItemShortname)
            {
                if (_configData.removerMode.meleeHitModeSkin < 0)
                {
                    return true;
                }
                return heldItem.skin == (ulong)_configData.removerMode.meleeHitModeSkin;
            }
            return false;
        }

        #endregion Tool Helpers

        private class ToolRemover : FacepunchBehaviour
        {
            private const float MinInterval = 0.2f;

            public int CurrentRemoved { get; set; }
            public BaseEntity HitEntity { get; set; }
            public bool CanOverride { get; private set; }
            public BasePlayer Player { get; private set; }
            public RemoveType RemoveType { get; private set; }

            private bool _resetTime;
            private bool _shouldPay;
            private bool _shouldRefund;
            private int _removeTime;
            private int _maxRemovable;
            private float _distance;
            private float _removeInterval;

            private int _timeLeft;
            private float _lastRemove;
            private ItemId _currentItemId;
            private bool _disableInHand;

            private Item _lastHeldItem;
            private BaseEntity _targetEntity;
            private UiEntry _activeUiEntries;

            private void Awake()
            {
                Player = GetComponent<BasePlayer>();
                _currentItemId = Player.svActiveItemID;
                _disableInHand = _removeMode == RemoveMode.MeleeHit && _configData.removerMode.meleeHitDisableInHand
                        || _removeMode == RemoveMode.SpecificTool && _configData.removerMode.specificToolDisableInHand;
                if (_disableInHand)
                {
                    _lastHeldItem = Player.GetActiveItem();
                }
                if (_removeMode == RemoveMode.NoHeld)
                {
                    UnEquip();
                }
            }

            public void Init(RemoveType removeType, int removeTime, int maxRemovable, float distance, float removeInterval, bool shouldPay, bool shouldRefund, bool resetTime, bool canOverride)
            {
                RemoveType = removeType;
                CanOverride = canOverride;

                _distance = distance;
                _resetTime = resetTime;
                _removeTime = _timeLeft = removeTime;
                _removeInterval = Mathf.Max(MinInterval, removeInterval);
                if (RemoveType == RemoveType.Normal)
                {
                    _maxRemovable = maxRemovable;
                    _shouldPay = shouldPay && _configData.remove.priceEnabled;
                    _shouldRefund = shouldRefund && _configData.remove.refundEnabled;
                    _instance.PrintDebug($"{Player.displayName}({Player.userID}) have Enabled the remover tool.");
                    Interface.CallHook("OnRemoverToolActivated", Player);
                }
                else
                {
                    _maxRemovable = CurrentRemoved = 0;
                    _shouldPay = _shouldRefund = false;
                }

                DestroyAllUI(Player);
                if (_configData.ui.showCrosshair)
                {
                    CreateCrosshairUI(Player);
                }

                if (_configData.ui.enabled)
                {
                    CreateMainUI(Player, RemoveType);
                }

                CancelInvoke(RemoveUpdate);
                InvokeRepeating(RemoveUpdate, 0f, 1f);
            }

            private void RemoveUpdate()
            {
                if (_configData.ui.enabled)
                {
                    _targetEntity = GetTargetEntity();
                    UpdateTimeLeftUI(Player, RemoveType, _timeLeft, CurrentRemoved, _maxRemovable);

                    var info = RemoveType == RemoveType.Normal ? GetRemovableEntityInfo(_targetEntity, Player) : null;
                    var canShow = (info.HasValue || _targetEntity != null) && CanEntityBeDisplayed(_targetEntity, Player);
                    if (HandleUiEntry(UiEntry.Entity, canShow))
                    {
                        UpdateEntityUI(Player, _targetEntity, info);
                    }
                    if (RemoveType == RemoveType.Normal)
                    {
                        if (_configData.ui.authorizationEnabled)
                        {
                            if (HandleUiEntry(UiEntry.Auth, canShow))
                            {
                                UpdateAuthorizationUI(Player, RemoveType, _targetEntity, info, _shouldPay);
                            }
                        }
                        if (_configData.ui.priceEnabled || _configData.ui.refundEnabled)
                        {
                            canShow = canShow && (info.HasValue || HasEntityEnabled(_targetEntity));
                            if (_configData.ui.priceEnabled)
                            {
                                if (HandleUiEntry(UiEntry.Price, canShow))
                                {
                                    UpdatePriceUI(Player, _targetEntity, info, _shouldPay);
                                }
                            }
                            if (_configData.ui.refundEnabled)
                            {
                                if (HandleUiEntry(UiEntry.Refund, canShow))
                                {
                                    UpdateRefundUI(Player, _targetEntity, info, _shouldRefund);
                                }
                            }
                        }
                    }
                }

                if (_timeLeft-- <= 0)
                {
                    DisableTool();
                }
            }

            private BaseEntity GetTargetEntity()
            {
                BaseEntity target = null;
                List<RaycastHit> hitInfos = Pool.GetList<RaycastHit>();
                GamePhysics.TraceAll(Player.eyes.HeadRay(), 0f, hitInfos, _distance, LAYER_TARGET);
                foreach (var hitInfo in hitInfos)
                {
                    var hitEntity = hitInfo.GetEntity();
                    if (hitEntity != null)
                    {
                        if (target == null)
                        {
                            target = hitEntity;
                        }
                        else if (hitEntity.GetParentEntity() == target)
                        {
                            target = hitEntity;
                            break;
                        }
                    }
                }
                Pool.FreeUnmanaged(ref hitInfos);
                return target;
                // RaycastHit hitInfo;
                // if (Physics.Raycast(Player.eyes.HeadRay(), out hitInfo, _distance, LAYER_TARGET))
                // {
                //     return hitInfo.GetEntity();
                // }
                // return null;
            }

            private void Update()
            {
                if (Player == null || !Player.IsConnected || !Player.CanInteract())
                {
                    DisableTool();
                    return;
                }
                if (Player.svActiveItemID != _currentItemId)
                {
                    if (_disableInHand)
                    {
                        var heldItem = Player.GetActiveItem();
                        if (_removeMode == RemoveMode.MeleeHit && IsMeleeTool(_lastHeldItem) && !IsMeleeTool(heldItem) ||
                                _removeMode == RemoveMode.SpecificTool && IsSpecificTool(_lastHeldItem) && !IsSpecificTool(heldItem))
                        {
                            DisableTool();
                            return;
                        }
                        _lastHeldItem = heldItem;
                    }
                    if (_removeMode == RemoveMode.NoHeld)
                    {
                        if (Player.svActiveItemID.IsValid)
                        {
                            if (_configData.removerMode.noHeldDisableInHand)
                            {
                                DisableTool();
                                return;
                            }
                            UnEquip();
                        }
                    }
                    _currentItemId = Player.svActiveItemID;
                }
                if (Time.realtimeSinceStartup - _lastRemove >= _removeInterval)
                {
                    if (_removeMode == RemoveMode.MeleeHit)
                    {
                        if (HitEntity == null)
                        {
                            return;
                        }
                        _targetEntity = HitEntity;
                        HitEntity = null;
                    }
                    else
                    {
                        if (!Player.serverInput.IsDown(_removeButton))
                        {
                            return;
                        }
                        if (_removeMode == RemoveMode.SpecificTool && !IsSpecificTool(Player))
                        {
                            //rt.Print(player,rt.Lang("UsageOfRemove",player.UserIDString));
                            return;
                        }
                        _targetEntity = GetTargetEntity();
                    }
                    if (_instance.TryRemove(Player, _targetEntity, RemoveType, _shouldPay, _shouldRefund))
                    {
                        if (_resetTime)
                        {
                            _timeLeft = _removeTime;
                        }
                        if (RemoveType == RemoveType.Normal || RemoveType == RemoveType.Admin)
                        {
                            CurrentRemoved++;
                        }
                        if (_configData.global.startCooldownOnRemoved && RemoveType == RemoveType.Normal)
                        {
                            _instance._cooldownTimes[Player.userID] = Time.realtimeSinceStartup;
                        }
                    }
                    _lastRemove = Time.realtimeSinceStartup;
                }
                if (RemoveType == RemoveType.Normal && _maxRemovable > 0 && CurrentRemoved >= _maxRemovable)
                {
                    _instance.Print(Player, _instance.Lang("EntityLimit", Player.UserIDString, _maxRemovable));
                    DisableTool(false);
                }
                ;
            }

            private void UnEquip()
            {
                // Player.lastReceivedTick.activeItem = 0;
                var activeItem = Player.GetActiveItem();
                if (activeItem?.GetHeldEntity() is HeldEntity)
                {
                    var slot = activeItem.position;
                    activeItem.SetParent(null);
                    Player.Invoke(() =>
                    {
                        if (activeItem == null || !activeItem.IsValid())
                        {
                            return;
                        }
                        if (Player.inventory.containerBelt.GetSlot(slot) == null)
                        {
                            activeItem.position = slot;
                            activeItem.SetParent(Player.inventory.containerBelt);
                        }
                        else
                        {
                            Player.GiveItem(activeItem);
                        }
                    }, 0.2f);
                }
            }

            private bool HandleUiEntry(UiEntry uiEntry, bool canShow)
            {
                if (canShow)
                {
                    _activeUiEntries |= uiEntry;
                    return true;
                }

                if (_activeUiEntries.HasFlag(uiEntry))
                {
                    _activeUiEntries &= ~uiEntry;
                    DestroyUiEntry(Player, uiEntry);
                }
                return false;
            }

            public void DisableTool(bool showMessage = true)
            {
                if (showMessage)
                {
                    if (_instance != null && Player != null && Player.IsConnected)
                    {
                        if (_configData != null && _configData.chat.showMessageWhenEnabledOrDisabled)
                        {
                            _instance.Print(Player, _instance.Lang("ToolDisabled", Player.UserIDString));
                        }
                    }
                }

                if (RemoveType == RemoveType.Normal)
                {
                    if (_instance != null && Player != null)
                    {
                        _instance.PrintDebug($"{Player.displayName}({Player.userID}) have Disabled the remover tool.");
                    }
                    Interface.CallHook("OnRemoverToolDeactivated", Player);
                }
                DestroyAllUI(Player);
                Destroy(this);
            }

            private void OnDestroy()
            {
                if (_instance != null && RemoveType == RemoveType.Normal)
                {
                    if (_configData != null && !_configData.global.startCooldownOnRemoved)
                    {
                        _instance._cooldownTimes[Player.userID] = Time.realtimeSinceStartup;
                    }
                }
            }
        }

        #endregion ToolRemover Component

        #region TryRemove

        private bool TryRemove(BasePlayer player, BaseEntity targetEntity, RemoveType removeType, bool shouldPay, bool shouldRefund)
        {
            if (targetEntity == null)
            {
                Print(player, Lang("NotFoundOrFar", player.UserIDString));
                return false;
            }
            if (targetEntity.IsDestroyed)
            {
                Print(player, Lang("InvalidEntity", player.UserIDString));
                return false;
            }
            if (removeType != RemoveType.Normal)
            {
                var result = Interface.CallHook("CanAdminRemove", player, targetEntity, removeType.ToString());
                if (result != null)
                {
                    Print(player, result is string ? (string)result : Lang("BeBlocked", player.UserIDString));
                    return false;
                }
                switch (removeType)
                {
                    case RemoveType.Admin:
                        {
                            var target = targetEntity as BasePlayer;
                            if (target != null)
                            {
                                if (target.userID.IsSteamId() && target.IsConnected)
                                {
                                    target.Kick("From RemoverTool Plugin");
                                    return true;
                                }
                            }
                            DoRemove(targetEntity, _configData.removeType[RemoveType.Admin].gibs ? BaseNetworkable.DestroyMode.Gib : BaseNetworkable.DestroyMode.None);
                            return true;
                        }
                    case RemoveType.All:
                        {
                            if (_removeAllCoroutine != null)
                            {
                                Print(player, Lang("AlreadyRemoveAll", player.UserIDString));
                                return false;
                            }
                            _removeAllCoroutine = ServerMgr.Instance.StartCoroutine(RemoveAll(targetEntity, player));
                            Print(player, Lang("StartRemoveAll", player.UserIDString));
                            return true;
                        }
                    case RemoveType.External:
                        {
                            var stabilityEntity = targetEntity as StabilityEntity;
                            if (stabilityEntity == null || !IsExternalWall(stabilityEntity))
                            {
                                Print(player, Lang("NotExternalWall", player.UserIDString));
                                return false;
                            }
                            if (_removeExternalCoroutine != null)
                            {
                                Print(player, Lang("AlreadyRemoveExternal", player.UserIDString));
                                return false;
                            }
                            _removeExternalCoroutine = ServerMgr.Instance.StartCoroutine(RemoveExternal(stabilityEntity, player));
                            Print(player, Lang("StartRemoveExternal", player.UserIDString));
                            return true;
                        }
                    case RemoveType.Structure:
                        {
                            var decayEntity = targetEntity as DecayEntity;
                            if (decayEntity == null)
                            {
                                Print(player, Lang("NotStructure", player.UserIDString));
                                return false;
                            }
                            if (_removeStructureCoroutine != null)
                            {
                                Print(player, Lang("AlreadyRemoveStructure", player.UserIDString));
                                return false;
                            }
                            _removeStructureCoroutine = ServerMgr.Instance.StartCoroutine(RemoveStructure(decayEntity, player));
                            Print(player, Lang("StartRemoveStructure", player.UserIDString));
                            return true;
                        }
                }
            }

            var info = GetRemovableEntityInfo(targetEntity, player);

            string reason;
            if (!CanRemoveEntity(player, removeType, targetEntity, info, shouldPay, out reason))
            {
                Print(player, reason);
                return false;
            }

            DropContainerEntity(targetEntity);

            if (shouldPay)
            {
                var flag = TryPay(player, targetEntity, info);
                if (!flag)
                {
                    Print(player, Lang("CantPay", player.UserIDString));
                    return false;
                }
            }

            if (shouldRefund)
            {
                GiveRefund(player, targetEntity, info);
            }

            DoNormalRemove(player, targetEntity, _configData.removeType[RemoveType.Normal].gibs);
            return true;
        }

        private bool CanRemoveEntity(BasePlayer player, RemoveType removeType, BaseEntity targetEntity, RemovableEntityInfo? info, bool shouldPay, out string reason)
        {
            if (removeType != RemoveType.Normal)
            {
                reason = null;
                return true;
            }
            if (targetEntity == null || !CanEntityBeDisplayed(targetEntity, player))
            {
                reason = Lang("NotFoundOrFar", player.UserIDString);
                return false;
            }
            if (targetEntity.IsDestroyed)
            {
                reason = Lang("InvalidEntity", player.UserIDString);
                return false;
            }
            if (!info.HasValue)
            {
                if (!IsRemovableEntity(targetEntity))
                {
                    reason = Lang("InvalidEntity", player.UserIDString);
                    return false;
                }
                if (!HasEntityEnabled(targetEntity))
                {
                    reason = Lang("EntityDisabled", player.UserIDString);
                    return false;
                }
            }
            var result = Interface.CallHook("canRemove", player, targetEntity);
            if (result != null)
            {
                reason = result is string ? (string)result : Lang("BeBlocked", player.UserIDString);
                return false;
            }
            if (!_configData.damagedEntity.enabled && IsDamagedEntity(targetEntity))
            {
                reason = Lang("DamagedEntity", player.UserIDString);
                return false;
            }
            if (IsPlayerBlocked(player, out reason))
            {
                return false;
            }
            if (_configData.global.entityTimeLimit && IsEntityTimeLimit(targetEntity))
            {
                reason = Lang("EntityTimeLimit", player.UserIDString, _configData.global.limitTime);
                return false;
            }
            if (!_configData.container.removeNotEmptyStorage)
            {
                var storageContainer = targetEntity as StorageContainer;
                if (storageContainer != null && storageContainer.inventory?.itemList?.Count > 0)
                {
                    reason = Lang("StorageNotEmpty", player.UserIDString);
                    return false;
                }
            }
            if (!_configData.container.removeNotEmptyIoEntity)
            {
                var containerIOEntity = targetEntity as ContainerIOEntity;
                if (containerIOEntity != null && containerIOEntity.inventory?.itemList?.Count > 0)
                {
                    reason = Lang("StorageNotEmpty", player.UserIDString);
                    return false;
                }
            }
            if (shouldPay && !CanPay(player, targetEntity, info))
            {
                reason = Lang("NotEnoughCost", player.UserIDString);
                return false;
            }
            if (!HasAccess(player, targetEntity))
            {
                reason = Lang("NotRemoveAccess", player.UserIDString);
                return false;
            }
            reason = Lang("CanRemove", player.UserIDString);
            return true;
        }

        private bool HasAccess(BasePlayer player, BaseEntity targetEntity)
        {
            if (_configData.global.useBuildingOwners && BuildingOwners != null)
            {
                var buildingBlock = targetEntity as BuildingBlock;
                if (buildingBlock != null)
                {
                    var result = BuildingOwners?.Call("FindBlockData", buildingBlock) as string;
                    if (result != null)
                    {
                        var ownerID = ulong.Parse(result);
                        if (AreFriends(ownerID, player.userID))
                        {
                            return true;
                        }
                    }
                }
            }
            //var 1 = configData.globalS.excludeTwigs && (targetEntity as BuildingBlock)?.grade == BuildingGrade.Enum.Twigs;
            if (_configData.global.useEntityOwners)
            {
                if (AreFriends(targetEntity.OwnerID, player.userID))
                {
                    if (!_configData.global.useToolCupboards)
                    {
                        return true;
                    }
                    if (HasTotalAccess(player, targetEntity))
                    {
                        return true;
                    }
                }

                return false;
            }
            if (_configData.global.useToolCupboards)
            {
                if (HasTotalAccess(player, targetEntity))
                {
                    return true;
                }
            }
            return false;
        }

        private static bool HasTotalAccess(BasePlayer player, BaseEntity targetEntity)
        {
            if (player.IsBuildingBlocked(targetEntity.WorldSpaceBounds()))
            {
                return false;
            }
            if (_configData.global.useBuildingLocks && !CanOpenAllLocks(player, targetEntity))
            {
                //reason = Lang("Can'tOpenAllLocks", player.UserIDString);
                return false;
            }
            return true;
        }

        private static bool CanOpenAllLocks(BasePlayer player, BaseEntity targetEntity)
        {
            var decayEntities = Pool.GetList<DecayEntity>();
            var building = targetEntity.GetBuildingPrivilege()?.GetBuilding() ?? (targetEntity as DecayEntity)?.GetBuilding();
            if (building != null)
            {
                decayEntities.AddRange(building.decayEntities);
            }
            /*else//An entity placed outside
            {
                Vis.Entities(targetEntity.transform.position, 9f, decayEntities, Layers.Mask.Construction | Layers.Mask.Deployed);
            }*/
            foreach (var decayEntity in decayEntities)
            {
                if ((decayEntity is Door || decayEntity is BoxStorage) && decayEntity.OwnerID.IsSteamId())
                {
                    var lockEntity = decayEntity.GetSlot(BaseEntity.Slot.Lock) as BaseLock;
                    if (lockEntity != null && !OnTryToOpen(player, lockEntity))
                    {
                        Pool.FreeList(ref decayEntities);
                        return false;
                    }
                }
            }
            Pool.FreeUnmanaged(ref decayEntities);
            return true;
        }

        private static bool OnTryToOpen(BasePlayer player, BaseLock baseLock)
        {
            var codeLock = baseLock as CodeLock;
            if (codeLock != null)
            {
                var obj = Interface.CallHook("CanUseLockedEntity", player, codeLock);
                if (obj is bool)
                {
                    return (bool)obj;
                }
                if (!codeLock.IsLocked())
                {
                    return true;
                }
                // Make no sound during the check
                if (codeLock.whitelistPlayers.Contains(player.userID) || codeLock.guestPlayers.Contains(player.userID))
                {
                    return true;
                }
                return false;
            }
            var keyLock = baseLock as KeyLock;
            if (keyLock != null)
            {
                return keyLock.OnTryToOpen(player);
            }

            return false;
        }

        private static bool IsDamagedEntity(BaseEntity entity)
        {
            var baseCombatEntity = entity as BaseCombatEntity;
            if (baseCombatEntity == null || !baseCombatEntity.repair.enabled)
            {
                return false;
            }
            if (_configData.damagedEntity.excludeBuildingBlocks && (baseCombatEntity is BuildingBlock || baseCombatEntity is SimpleBuildingBlock))
            {
                return false;
            }
            if (_configData.damagedEntity.excludeQuarries && !(baseCombatEntity is BuildingBlock))
            {
                // Quarries
                if (baseCombatEntity.repair.itemTarget == null || baseCombatEntity.repair.itemTarget.Blueprint == null)
                {
                    return false;
                }
            }

            if (baseCombatEntity.healthFraction * 100f >= _configData.damagedEntity.percentage)
            {
                return false;
            }
            return true;
        }

        private static bool IsEntityTimeLimit(BaseEntity entity)
        {
            if (entity.net == null)
            {
                return true;
            }
            float spawnedTime;
            if (_instance._entitySpawnedTimes.TryGetValue(entity.net.ID.Value, out spawnedTime))
            {
                return Time.realtimeSinceStartup - spawnedTime > _configData.global.limitTime;
            }
            return true;
        }

        private static void DropContainerEntity(BaseEntity targetEntity)
        {
            var itemContainerEntity = targetEntity as IItemContainerEntity;
            if (itemContainerEntity != null && itemContainerEntity.inventory?.itemList?.Count > 0)
            {
                bool dropContainer = false, dropItems = false;
                var storageContainer = targetEntity as StorageContainer;
                if (storageContainer != null)
                {
                    dropContainer = _configData.container.dropContainerStorage;
                    dropItems = _configData.container.dropItemsStorage;
                }
                else
                {
                    var containerIoEntity = targetEntity as ContainerIOEntity;
                    if (containerIoEntity != null)
                    {
                        dropContainer = _configData.container.dropContainerIoEntity;
                        dropItems = _configData.container.dropItemsIoEntity;
                    }
                }
                if (dropContainer || dropItems)
                {
                    if (Interface.CallHook("OnDropContainerEntity", targetEntity) == null)
                    {
                        if (dropContainer)
                        {
                            DropItemContainer(itemContainerEntity.inventory, itemContainerEntity.GetDropPosition(), itemContainerEntity.Transform.rotation);
                        }
                        else if (dropItems)
                        {
                            itemContainerEntity.DropItems();
                        }
                    }
                }
            }
        }

        #region AreFriends

        private bool AreFriends(ulong playerID, ulong friendID)
        {
            if (!playerID.IsSteamId())
            {
                return false;
            }
            if (playerID == friendID)
            {
                return true;
            }
            if (_configData.global.useTeams && SameTeam(playerID, friendID))
            {
                return true;
            }
            if (_configData.global.useFriends && HasFriend(playerID, friendID))
            {
                return true;
            }
            if (_configData.global.useClans && SameClan(playerID, friendID))
            {
                return true;
            }
            return false;
        }

        private static bool SameTeam(ulong playerID, ulong friendID)
        {
            if (!RelationshipManager.TeamsEnabled())
            {
                return false;
            }
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerID);
            if (playerTeam == null)
            {
                return false;
            }
            var friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendID);
            if (friendTeam == null)
            {
                return false;
            }
            return playerTeam == friendTeam;
        }

        private bool HasFriend(ulong playerID, ulong friendID)
        {
            if (Friends == null)
            {
                return false;
            }
            return (bool)Friends.Call("HasFriend", playerID, friendID);
        }

        private bool SameClan(ulong playerID, ulong friendID)
        {
            if (Clans == null)
            {
                return false;
            }
            //Clans
            var isMember = Clans.Call("IsClanMember", playerID.ToString(), friendID.ToString());
            if (isMember != null)
            {
                return (bool)isMember;
            }
            //Rust:IO Clans
            var playerClan = Clans.Call("GetClanOf", playerID);
            if (playerClan == null)
            {
                return false;
            }
            var friendClan = Clans.Call("GetClanOf", friendID);
            if (friendClan == null)
            {
                return false;
            }
            return (string)playerClan == (string)friendClan;
        }

        #endregion AreFriends

        #endregion TryRemove

        #region Pay

        private Dictionary<string, CurrencyInfo> GetPrice(BaseEntity targetEntity, RemovableEntityInfo? info)
        {
            if (info.HasValue)
            {
                return info.Value.Price.ValueName2Currency;
            }
            var buildingBlock = targetEntity as BuildingBlock;
            if (buildingBlock != null)
            {
                var entityName = _prefabNameToStructure[buildingBlock.PrefabName];
                BuildingBlocksSettings buildingBlockSettings;
                if (_configData.remove.buildingBlock.TryGetValue(entityName, out buildingBlockSettings))
                {
                    BuildingGradeSettings buildingGradeSettings;
                    if (buildingBlockSettings.buildingGrade.TryGetValue(buildingBlock.grade, out buildingGradeSettings))
                    {
                        if (buildingGradeSettings.priceDict != null)
                        {
                            return buildingGradeSettings.priceDict;
                        }
                        if (buildingGradeSettings.pricePercentage > 0f)
                        {
                            var currentGrade = buildingBlock.currentGrade;
                            if (currentGrade != null)
                            {
                                var price = new Dictionary<string, CurrencyInfo>();
                                var costToBuild = buildingBlock.blockDefinition.GetGrade(buildingBlock.grade, buildingBlock.skinID).CostToBuild();
                                foreach (var itemAmount in costToBuild)
                                {
                                    var amount = Mathf.RoundToInt(itemAmount.amount * buildingGradeSettings.pricePercentage / 100);
                                    if (amount <= 0)
                                    {
                                        continue;
                                    }
                                    price.Add(itemAmount.itemDef.shortname, new CurrencyInfo(amount));
                                }

                                return price;
                            }
                        }
                        else if (buildingGradeSettings.pricePercentage < 0f)
                        {
                            var currentGrade = buildingBlock.currentGrade;
                            if (currentGrade != null)
                            {
                                return buildingBlock.blockDefinition.GetGrade(buildingBlock.grade, buildingBlock.skinID).CostToBuild().ToDictionary(x => x.itemDef.shortname, y => new CurrencyInfo(Mathf.RoundToInt(y.amount)));
                            }
                        }
                    }
                }
            }
            else
            {
                EntitySettings entitySettings;
                if (_configData.remove.entity.TryGetValue(targetEntity.ShortPrefabName, out entitySettings))
                {
                    return entitySettings.priceDict;
                }
            }
            return null;
        }

        private bool TryPay(BasePlayer player, BaseEntity targetEntity, RemovableEntityInfo? info)
        {
            var price = GetPrice(targetEntity, info);
            if (price == null || price.Count == 0)
            {
                return true;
            }
            var collect = Pool.GetList<Item>();
            try
            {
                foreach (var entry in price)
                {
                    if (entry.Value.Amount <= 0)
                    {
                        continue;
                    }
                    int itemId;
                    if (_itemShortNameToItemId.TryGetValue(entry.Key, out itemId))
                    {
                        var take = TakeInventory(player, itemId, entry.Value, collect);
                        player.Command("note.inv", itemId, -take);
                    }
                    else if (!CheckOrPay(targetEntity, player, entry.Key, entry.Value, false))
                    {
                        return false;
                    }
                }
            }
            catch (Exception e)
            {
                PrintError($"{player} couldn't pay to remove entity. Error: {e}");
                return false;
            }
            finally
            {
                foreach (var item in collect)
                {
                    item.Remove();
                }
                Pool.FreeUnmanaged(ref collect);
            }
            return true;
        }

        private bool CanPay(BasePlayer player, BaseEntity targetEntity, RemovableEntityInfo? info)
        {
            var price = GetPrice(targetEntity, info);
            if (price == null || price.Count == 0)
            {
                return true;
            }
            foreach (var entry in price)
            {
                if (entry.Value.Amount <= 0)
                {
                    continue;
                }
                int itemId;
                if (_itemShortNameToItemId.TryGetValue(entry.Key, out itemId))
                {
                    var amount = GetInventoryAmount(player, itemId, entry.Value);
                    if (amount < entry.Value.Amount)
                    {
                        return false;
                    }
                }
                else if (!CheckOrPay(targetEntity, player, entry.Key, entry.Value, true))
                {
                    return false;
                }
            }
            return true;
        }

        private bool CheckOrPay(BaseEntity targetEntity, BasePlayer player, string itemName, CurrencyInfo currencyInfo, bool check)
        {
            if (currencyInfo.Amount <= 0)
            {
                return true;
            }
            switch (itemName.ToLower())
            {
                case ECONOMICS_KEY:
                    if (Economics == null)
                    {
                        return false;
                    }
                    if (check)
                    {
                        var balance = Economics.Call("Balance", player.userID);
                        if (balance == null)
                        {
                            return false;
                        }
                        if ((double)balance < currencyInfo.Amount)
                        {
                            return false;
                        }
                    }
                    else
                    {
                        var withdraw = Economics.Call("Withdraw", player.userID, (double)currencyInfo.Amount);
                        if (withdraw == null || !(bool)withdraw)
                        {
                            return false;
                        }
                    }
                    return true;

                case SERVER_REWARDS_KEY:
                    if (ServerRewards == null)
                    {
                        return false;
                    }
                    if (check)
                    {
                        var points = ServerRewards.Call("CheckPoints", player.userID);
                        if (points == null)
                        {
                            return false;
                        }

                        if ((int)points < currencyInfo.Amount)
                        {
                            return false;
                        }
                    }
                    else
                    {
                        var takePoints = ServerRewards.Call("TakePoints", player.userID, currencyInfo.Amount);
                        if (takePoints == null || !(bool)takePoints)
                        {
                            return false;
                        }
                    }
                    return true;

                default:
                    {
                        var result = Interface.CallHook("OnRemovableEntityCheckOrPay", targetEntity, player, itemName, currencyInfo.Amount, currencyInfo.SkinId, check);
                        if (result is bool)
                        {
                            return (bool)result;
                        }
                    }

                    return true;
            }
        }

        private static int GetInventoryAmount(BasePlayer player, int itemId, CurrencyInfo currencyInfo)
        {
            var count = 0;
            if (itemId == 0)
            {
                return count;
            }
            var list = Pool.Get<List<Item>>();
            player.inventory.GetAllItems(list);
            foreach (var item in list)
            {
                if (item.info.itemid == itemId && !item.IsBusy() && (currencyInfo.SkinId < 0 || item.skin == (ulong)currencyInfo.SkinId))
                {
                    count += item.amount;
                }
            }
            Pool.FreeUnmanaged(ref list);
            return count;
        }

        private static int TakeInventory(BasePlayer player, int itemId, CurrencyInfo currencyInfo, List<Item> collect)
        {
            var take = 0;
            if (itemId == 0)
            {
                return take;
            }
            var amount = currencyInfo.Amount;
            var list = Pool.Get<List<Item>>();
            player.inventory.GetAllItems(list);
            foreach (var item in list)
            {
                if (item.info.itemid == itemId && !item.IsBusy() && (currencyInfo.SkinId < 0 || item.skin == (ulong)currencyInfo.SkinId))
                {
                    var need = amount - take;
                    if (need > 0)
                    {
                        if (item.amount > need)
                        {
                            item.MarkDirty();
                            item.amount -= need;
                            take += need;
                            var newItem = ItemManager.CreateByItemID(itemId, 1, item.skin);
                            newItem.amount = need;
                            newItem.CollectedForCrafting(player);
                            collect?.Add(newItem);
                            break;
                        }
                        if (item.amount <= need)
                        {
                            take += item.amount;
                            item.RemoveFromContainer();
                            collect?.Add(item);
                        }
                        if (take == amount)
                        {
                            break;
                        }
                    }
                }
            }
            Pool.FreeUnmanaged(ref list);
            return take;
        }

        #endregion Pay

        #region Refund

        private void GiveRefund(BasePlayer player, BaseEntity targetEntity, RemovableEntityInfo? info)
        {
            var refund = GetRefund(targetEntity, info);
            if (refund == null || refund.Count == 0)
            {
                return;
            }
            foreach (var entry in refund)
            {
                var itemName = entry.Key;
                var currencyInfo = entry.Value;
                if (currencyInfo.Amount <= 0)
                {
                    continue;
                }
                int itemId;
                string shortname;
                _shortPrefabNameToDeployable.TryGetValue(targetEntity.ShortPrefabName, out shortname);
                if (_itemShortNameToItemId.TryGetValue(itemName, out itemId))
                {
                    var isOriginalItem = itemName == shortname;
                    var isSpecifiedSkinId = currencyInfo.SkinId >= 0;
                    var item = ItemManager.CreateByItemID(itemId, currencyInfo.Amount, isSpecifiedSkinId ? (ulong)currencyInfo.SkinId : isOriginalItem ? targetEntity.skinID : 0);
                    if (!isSpecifiedSkinId && isOriginalItem && item.hasCondition && targetEntity is BaseCombatEntity)
                    {
                        item.condition = item.maxCondition * (targetEntity.Health() / targetEntity.MaxHealth());
                    }
                    player.GiveItem(item);
                }
                else
                {
                    var flag = false;
                    switch (itemName.ToLower())
                    {
                        case ECONOMICS_KEY:
                            {
                                if (Economics == null)
                                {
                                    continue;
                                }
                                var result = Economics.Call("Deposit", player.userID, (double)currencyInfo.Amount);
                                if (result != null)
                                {
                                    flag = true;
                                }
                                break;
                            }

                        case SERVER_REWARDS_KEY:
                            {
                                if (ServerRewards == null)
                                {
                                    continue;
                                }
                                var result = ServerRewards.Call("AddPoints", player.userID, currencyInfo.Amount);
                                if (result != null)
                                {
                                    flag = true;
                                }
                                break;
                            }

                        default:
                            {
                                var result = Interface.CallHook("OnRemovableEntityGiveRefund", targetEntity, player, itemName, currencyInfo.Amount, currencyInfo.SkinId);
                                if (result == null)
                                {
                                    flag = true;
                                }
                                break;
                            }
                    }

                    if (!flag)
                    {
                        PrintError($"{player} didn't receive refund maybe {itemName} doesn't seem to be a valid item name");
                    }
                }
            }
        }

        private Dictionary<string, CurrencyInfo> GetRefund(BaseEntity targetEntity, RemovableEntityInfo? info)
        {
            if (info.HasValue)
            {
                return info.Value.Refund.ValueName2Currency;
            }
            var buildingBlock = targetEntity.GetComponent<BuildingBlock>();
            if (buildingBlock != null)
            {
                var entityName = _prefabNameToStructure[buildingBlock.PrefabName];
                BuildingBlocksSettings buildingBlockSettings;
                if (_configData.remove.buildingBlock.TryGetValue(entityName, out buildingBlockSettings))
                {
                    BuildingGradeSettings buildingGradeSettings;
                    if (buildingBlockSettings.buildingGrade.TryGetValue(buildingBlock.grade, out buildingGradeSettings))
                    {
                        if (buildingGradeSettings.refundDict != null)
                        {
                            return buildingGradeSettings.refundDict;
                        }
                        if (buildingGradeSettings.refundPercentage > 0f)
                        {
                            var currentGrade = buildingBlock.currentGrade;
                            if (currentGrade != null)
                            {
                                var refund = new Dictionary<string, CurrencyInfo>();
                                var costToBuild = buildingBlock.blockDefinition.GetGrade(buildingBlock.grade, buildingBlock.skinID).CostToBuild();
                                foreach (var itemAmount in costToBuild)
                                {
                                    var amount = Mathf.RoundToInt(itemAmount.amount * buildingGradeSettings.refundPercentage / 100);
                                    if (amount <= 0)
                                    {
                                        continue;
                                    }
                                    refund.Add(itemAmount.itemDef.shortname, new CurrencyInfo(amount));
                                }
                                return refund;
                            }
                        }
                        else if (buildingGradeSettings.refundPercentage < 0f)
                        {
                            var currentGrade = buildingBlock.currentGrade;
                            if (currentGrade != null)
                            {
                                return buildingBlock.blockDefinition.GetGrade(buildingBlock.grade, buildingBlock.skinID).CostToBuild().ToDictionary(x => x.itemDef.shortname, y => new CurrencyInfo(Mathf.RoundToInt(y.amount)));
                            }
                        }
                    }
                }
            }
            else
            {
                EntitySettings entitySettings;
                if (_configData.remove.entity.TryGetValue(targetEntity.ShortPrefabName, out entitySettings))
                {
                    if (_configData.remove.refundSlot)
                    {
                        var slots = GetSlots(targetEntity);
                        if (slots.Any())
                        {
                            var refund = new Dictionary<string, CurrencyInfo>(entitySettings.refundDict);
                            foreach (var slotName in slots)
                            {
                                if (!refund.ContainsKey(slotName))
                                {
                                    refund.Add(slotName, new CurrencyInfo(0));
                                }
                                refund[slotName] = new CurrencyInfo(refund[slotName].Amount + 1, refund[slotName].SkinId);
                            }
                            return refund;
                        }
                    }
                    return entitySettings.refundDict;
                }
            }
            return null;
        }

        private IEnumerable<string> GetSlots(BaseEntity targetEntity)
        {
            foreach (BaseEntity.Slot slot in Enum.GetValues(typeof(BaseEntity.Slot)))
            {
                if (targetEntity.HasSlot(slot))
                {
                    var entity = targetEntity.GetSlot(slot);
                    if (entity != null)
                    {
                        string slotName;
                        if (_shortPrefabNameToDeployable.TryGetValue(entity.ShortPrefabName, out slotName))
                        {
                            yield return slotName;
                        }
                    }
                }
            }
        }

        #endregion Refund

        #region RemoveEntity

        private IEnumerator RemoveAll(BaseEntity sourceEntity, BasePlayer player)
        {
            var removeList = Pool.Get<HashSet<BaseEntity>>();
            yield return GetNearbyEntities(sourceEntity, removeList, LAYER_ALL);
            yield return ProcessContainers(removeList);
            yield return DelayRemove(removeList, player, RemoveType.All);
            removeList.Clear();
            Pool.FreeUnmanaged(ref removeList);
            _removeAllCoroutine = null;
        }

        private IEnumerator RemoveExternal(StabilityEntity sourceEntity, BasePlayer player)
        {
            var removeList = Pool.Get<HashSet<StabilityEntity>>();
            yield return GetNearbyEntities(sourceEntity, removeList, Layers.Mask.Construction, IsExternalWall);
            yield return DelayRemove(removeList, player, RemoveType.External);
            removeList.Clear();
            Pool.FreeUnmanaged(ref removeList);
            _removeExternalCoroutine = null;
        }

        private IEnumerator RemoveStructure(DecayEntity sourceEntity, BasePlayer player)
        {
            var removeList = Pool.Get<HashSet<BaseEntity>>();
            yield return ProcessBuilding(sourceEntity, removeList);
            yield return DelayRemove(removeList, player, RemoveType.Structure);
            removeList.Clear();
            Pool.FreeUnmanaged(ref removeList);
            _removeStructureCoroutine = null;
        }

        private IEnumerator RemovePlayerEntity(ConsoleSystem.Arg arg, ulong targetID, PlayerEntityRemoveType playerEntityRemoveType)
        {
            var current = 0;
            var removeList = Pool.Get<HashSet<BaseEntity>>();
            switch (playerEntityRemoveType)
            {
                case PlayerEntityRemoveType.All:
                case PlayerEntityRemoveType.Building:
                    var onlyBuilding = playerEntityRemoveType == PlayerEntityRemoveType.Building;
                    foreach (var serverEntity in BaseNetworkable.serverEntities)
                    {
                        if (++current % 500 == 0)
                        {
                            yield return CoroutineEx.waitForEndOfFrame;
                        }
                        var entity = serverEntity as BaseEntity;
                        if (entity == null || entity.OwnerID != targetID)
                        {
                            continue;
                        }
                        if (!onlyBuilding || entity is BuildingBlock)
                        {
                            removeList.Add(entity);
                        }
                    }
                    foreach (var player in BasePlayer.allPlayerList)
                    {
                        if (player.userID == targetID)
                        {
                            if (player.IsConnected)
                            {
                                player.Kick("From RemoverTool Plugin");
                            }
                            removeList.Add(player);
                            break;
                        }
                    }
                    break;

                case PlayerEntityRemoveType.Cupboard:
                    foreach (var serverEntity in BaseNetworkable.serverEntities)
                    {
                        if (++current % 500 == 0)
                        {
                            yield return CoroutineEx.waitForEndOfFrame;
                        }
                        var entity = serverEntity as BuildingPrivlidge;
                        if (entity == null || entity.OwnerID != targetID)
                        {
                            continue;
                        }
                        yield return ProcessBuilding(entity, removeList);
                    }
                    break;
            }
            var removed = removeList.Count(x => x != null && !x.IsDestroyed);
            yield return DelayRemove(removeList);
            removeList.Clear();
            Pool.FreeUnmanaged(ref removeList);
            Print(arg, $"You have successfully removed {removed} entities of player {targetID}.");
            _removePlayerEntityCoroutine = null;
        }

        private IEnumerator DelayRemove(IEnumerable<BaseEntity> entities, BasePlayer player = null, RemoveType removeType = RemoveType.None)
        {
            var removed = 0;
            var destroyMode = removeType == RemoveType.None ? BaseNetworkable.DestroyMode.None : _configData.removeType[removeType].gibs ? BaseNetworkable.DestroyMode.Gib : BaseNetworkable.DestroyMode.None;
            foreach (var entity in entities)
            {
                if (DoRemove(entity, destroyMode) && ++removed % _configData.global.removePerFrame == 0)
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                }
            }

            if (removeType == RemoveType.None)
            {
                yield break;
            }
            var toolRemover = player?.GetComponent<ToolRemover>();
            if (toolRemover != null && toolRemover.RemoveType == removeType)
            {
                toolRemover.CurrentRemoved += removed;
            }
            if (player != null)
            {
                Print(player, Lang($"CompletedRemove{removeType}", player.UserIDString, removed));
            }
        }

        #region RemoveEntity Helpers

        private static IEnumerator GetNearbyEntities<T>(T sourceEntity, HashSet<T> removeList, int layers, Func<T, bool> filter = null) where T : BaseEntity
        {
            var current = 0;
            var checkFrom = Pool.Get<Queue<Vector3>>();
            var nearbyEntities = Pool.GetList<T>();
            removeList.Add(sourceEntity);
            checkFrom.Enqueue(sourceEntity.transform.position);
            while (checkFrom.Count > 0)
            {
                nearbyEntities.Clear();
                var position = checkFrom.Dequeue();
                Vis.Entities(position, 3f, nearbyEntities, layers);
                for (var i = 0; i < nearbyEntities.Count; i++)
                {
                    var entity = nearbyEntities[i];
                    if (filter != null && !filter(entity))
                    {
                        continue;
                    }
                    if (!removeList.Add(entity))
                    {
                        continue;
                    }
                    checkFrom.Enqueue(entity.transform.position);
                }
                if (++current % _configData.global.removePerFrame == 0)
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                }
            }
            checkFrom.Clear();
            Pool.FreeUnmanaged(ref checkFrom);
            Pool.FreeUnmanaged(ref nearbyEntities);
        }

        private static IEnumerator ProcessContainers(HashSet<BaseEntity> removeList)
        {
            foreach (var entity in removeList)
            {
                ProcessContainer(entity);
            }

            ItemManager.DoRemoves();
            yield break;
        }

        private static IEnumerator ProcessBuilding(DecayEntity sourceEntity, HashSet<BaseEntity> removeList)
        {
            var building = sourceEntity.GetBuilding();
            if (building != null)
            {
                foreach (var entity in building.decayEntities)
                {
                    if (!removeList.Add(entity))
                    {
                        continue;
                    }
                    ProcessContainer(entity);
                }
            }
            else
            {
                removeList.Add(sourceEntity);
            }

            ItemManager.DoRemoves();
            yield break;
        }

        private static void ProcessContainer(BaseEntity entity)
        {
            var itemContainerEntity = entity as IItemContainerEntity;
            if (itemContainerEntity != null && itemContainerEntity.inventory?.itemList?.Count > 0)
            {
                if (_configData.global.noItemContainerDrop)
                {
                    itemContainerEntity.inventory.Clear();
                }
                else
                {
                    DropItemContainer(itemContainerEntity.inventory, itemContainerEntity.GetDropPosition(), itemContainerEntity.Transform.rotation);
                }
            }
        }

        private static bool DoRemove(BaseEntity entity, BaseNetworkable.DestroyMode destroyMode)
        {
            if (entity != null && !entity.IsDestroyed)
            {
                entity.Kill(destroyMode);
                return true;
            }
            return false;
        }

        private static void DoNormalRemove(BasePlayer player, BaseEntity entity, bool gibs = true)
        {
            if (entity != null && !entity.IsDestroyed)
            {
                _instance.PrintDebug($"{player.displayName}({player.userID}) has removed {entity.ShortPrefabName}({entity.OwnerID} | {entity.transform.position})", true);
                Interface.CallHook("OnNormalRemovedEntity", player, entity);
                entity.Kill(gibs ? BaseNetworkable.DestroyMode.Gib : BaseNetworkable.DestroyMode.None);
            }
        }

        #endregion RemoveEntity Helpers

        #endregion RemoveEntity

        #region API

        public struct CurrencyInfo
        {
            [JsonProperty(PropertyName = "amount")]
            public int Amount { get; set; }

            [JsonProperty(PropertyName = "skinId")]
            public long SkinId { get; set; }

            public CurrencyInfo(int amount, long skinId = -1)
            {
                Amount = amount;
                SkinId = skinId;
            }
        }

        private struct ValueCache<T>
        {
            private T _value;
            private bool _flag;
            private readonly string _key;
            private readonly Dictionary<string, object> _dictionary;

            public ValueCache(string key, Dictionary<string, object> dictionary, T defaultValue)
            {
                _flag = false;
                _key = key;
                _value = defaultValue;
                _dictionary = dictionary;
            }

            public T Value
            {
                get
                {
                    if (!_flag)
                    {
                        _flag = true;
                        object value;
                        if (_dictionary.TryGetValue(_key, out value))
                        {
                            try
                            {
                                _value = (T)value;
                            }
                            catch (Exception)
                            {
                                _instance.PrintError($"Incorrect type for {_key}( {typeof(T)})");
                            }
                        }
                    }

                    return _value;
                }
            }
        }

        private struct CurrencyCache
        {
            private bool _name2InfoFlag;
            private bool _name2AmountFlag;
            private Dictionary<string, CurrencyInfo> _valueName2Currency;
            private Dictionary<string, ExternalItemInfo> _valueName2Info;
            private ValueCache<Dictionary<string, object>> _dictionary;

            public CurrencyCache(string key, Dictionary<string, object> dictionary)
            {
                _name2InfoFlag = false;
                _name2AmountFlag = false;
                _valueName2Info = null;
                _valueName2Currency = null;
                _dictionary = new ValueCache<Dictionary<string, object>>(key, dictionary, default(Dictionary<string, object>));
            }

            public ExternalItemInfo? this[string key]
            {
                get
                {
                    if (ValueName2Info == null)
                    {
                        return null;
                    }

                    ExternalItemInfo externalItemInfo;
                    if (!ValueName2Info.TryGetValue(key, out externalItemInfo))
                    {
                        return null;
                    }
                    return externalItemInfo;
                }
            }

            public Dictionary<string, CurrencyInfo> ValueName2Currency
            {
                get
                {
                    if (!_name2AmountFlag)
                    {
                        _name2AmountFlag = true;
                        if (ValueName2Info == null)
                        {
                            return null;
                        }

                        _valueName2Currency = new Dictionary<string, CurrencyInfo>();
                        foreach (var entry in ValueName2Info)
                        {
                            _valueName2Currency.Add(entry.Key, new CurrencyInfo(entry.Value.Amount.Value, entry.Value.SkinId.Value));
                        }
                    }

                    return _valueName2Currency;
                }
            }

            private Dictionary<string, ExternalItemInfo> ValueName2Info
            {
                get
                {
                    if (!_name2InfoFlag)
                    {
                        _name2InfoFlag = true;
                        if (_dictionary.Value == null)
                        {
                            return null;
                        }

                        _valueName2Info = new Dictionary<string, ExternalItemInfo>();
                        foreach (var entry in _dictionary.Value)
                        {
                            _valueName2Info.Add(entry.Key, new ExternalItemInfo(entry.Value as Dictionary<string, object>));
                        }
                    }

                    return _valueName2Info;
                }
            }
        }

        private struct ExternalItemInfo
        {
            public ExternalItemInfo(Dictionary<string, object> dictionary)
            {
                Amount = new ValueCache<int>(nameof(Amount), dictionary, 0);
                SkinId = new ValueCache<long>(nameof(SkinId), dictionary, -1);
                ImageId = new ValueCache<string>(nameof(ImageId), dictionary, "");
                DisplayName = new ValueCache<string>(nameof(DisplayName), dictionary, "");
            }

            public ValueCache<int> Amount { get; }
            public ValueCache<long> SkinId { get; }
            public ValueCache<string> ImageId { get; }
            public ValueCache<string> DisplayName { get; }
        }

        private struct RemovableEntityInfo
        {
            public RemovableEntityInfo(Dictionary<string, object> dictionary)
            {
                ImageId = new ValueCache<string>(nameof(ImageId), dictionary, "");
                DisplayName = new ValueCache<string>(nameof(DisplayName), dictionary, "");
                Price = new CurrencyCache(nameof(Price), dictionary);
                Refund = new CurrencyCache(nameof(Refund), dictionary);
            }

            public ValueCache<string> ImageId { get; }

            public ValueCache<string> DisplayName { get; }

            public CurrencyCache Price { get; }

            public CurrencyCache Refund { get; }
        }

        private static RemovableEntityInfo? GetRemovableEntityInfo(BaseEntity entity, BasePlayer player)
        {
            if (entity == null)
            {
                return null;
            }
            var result = Interface.CallHook("OnRemovableEntityInfo", entity, player) as Dictionary<string, object>;
            if (result != null)
            {
                return new RemovableEntityInfo(result);
            }

            return null;
        }

        private bool IsToolRemover(BasePlayer player)
        {
            return player != null && player.GetComponent<ToolRemover>() != null;
        }

        private string GetPlayerRemoveType(BasePlayer player)
        {
            return player != null ? player.GetComponent<ToolRemover>()?.RemoveType.ToString() : null;
        }

        #endregion API

        #region Commands

        private void CmdRemove(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length == 0)
            {
                var sourceRemover = player.GetComponent<ToolRemover>();
                if (sourceRemover != null)
                {
                    sourceRemover.DisableTool();
                    return;
                }
            }
            if (_removeOverride && !permission.UserHasPermission(player.UserIDString, PERMISSION_OVERRIDE))
            {
                Print(player, Lang("CurrentlyDisabled", player.UserIDString));
                return;
            }
            var removeType = RemoveType.Normal;
            var time = _configData.removeType[removeType].defaultTime;
            if (args != null && args.Length > 0)
            {
                switch (args[0].ToLower())
                {
                    case "n":
                    case "normal":
                        break;

                    case "a":
                    case "admin":
                        removeType = RemoveType.Admin;
                        time = _configData.removeType[removeType].defaultTime;
                        if (!permission.UserHasPermission(player.UserIDString, PERMISSION_ADMIN))
                        {
                            Print(player, Lang("NotAllowed", player.UserIDString, PERMISSION_ADMIN));
                            return;
                        }
                        break;

                    case "all":
                        removeType = RemoveType.All;
                        time = _configData.removeType[removeType].defaultTime;
                        if (!permission.UserHasPermission(player.UserIDString, PERMISSION_ALL))
                        {
                            Print(player, Lang("NotAllowed", player.UserIDString, PERMISSION_ALL));
                            return;
                        }
                        break;

                    case "s":
                    case "structure":
                        removeType = RemoveType.Structure;
                        time = _configData.removeType[removeType].defaultTime;
                        if (!permission.UserHasPermission(player.UserIDString, PERMISSION_STRUCTURE))
                        {
                            Print(player, Lang("NotAllowed", player.UserIDString, PERMISSION_STRUCTURE));
                            return;
                        }
                        break;

                    case "e":
                    case "external":
                        removeType = RemoveType.External;
                        time = _configData.removeType[removeType].defaultTime;
                        if (!permission.UserHasPermission(player.UserIDString, PERMISSION_EXTERNAL))
                        {
                            Print(player, Lang("NotAllowed", player.UserIDString, PERMISSION_EXTERNAL));
                            return;
                        }
                        break;

                    case "h":
                    case "help":
                        var stringBuilder = Pool.Get<StringBuilder>();
                        stringBuilder.Clear();
                        stringBuilder.AppendLine(Lang("Syntax", player.UserIDString, _configData.chat.command, GetRemoveTypeName(RemoveType.Normal)));
                        stringBuilder.AppendLine(Lang("Syntax1", player.UserIDString, _configData.chat.command, GetRemoveTypeName(RemoveType.Admin)));
                        stringBuilder.AppendLine(Lang("Syntax2", player.UserIDString, _configData.chat.command, GetRemoveTypeName(RemoveType.All)));
                        stringBuilder.AppendLine(Lang("Syntax3", player.UserIDString, _configData.chat.command, GetRemoveTypeName(RemoveType.Structure)));
                        stringBuilder.AppendLine(Lang("Syntax4", player.UserIDString, _configData.chat.command, GetRemoveTypeName(RemoveType.External)));
                        Print(player, stringBuilder.ToString());
                        stringBuilder.Clear();
                        Pool.FreeUnmanaged(ref stringBuilder);
                        return;

                    default:
                        if (int.TryParse(args[0], out time))
                        {
                            break;
                        }
                        Print(player, Lang("SyntaxError", player.UserIDString, _configData.chat.command));
                        return;
                }
            }
            if (args != null && args.Length > 1)
            {
                int.TryParse(args[1], out time);
            }
            ToggleRemove(player, removeType, time);
        }

        private bool ToggleRemove(BasePlayer player, RemoveType removeType, int time = 0)
        {
            if (removeType == RemoveType.Normal && !permission.UserHasPermission(player.UserIDString, PERMISSION_NORMAL))
            {
                Print(player, Lang("NotAllowed", player.UserIDString, PERMISSION_NORMAL));
                return false;
            }

            var maxRemovable = 0;
            bool pay = false, refund = false;
            var removeTypeS = _configData.removeType[removeType];
            var distance = removeTypeS.distance;
            var maxTime = removeTypeS.maxTime;
            var resetTime = removeTypeS.resetTime;
            var interval = _configData.global.removeInterval;
            if (removeType == RemoveType.Normal)
            {
                var permissionS = GetPermissionSettings(player);
                var cooldown = permissionS.cooldown;
                if (cooldown > 0 && !(_configData.global.cooldownExclude && player.IsAdmin))
                {
                    float lastUse;
                    if (_cooldownTimes.TryGetValue(player.userID, out lastUse))
                    {
                        var timeLeft = cooldown - (Time.realtimeSinceStartup - lastUse);
                        if (timeLeft > 0)
                        {
                            var timeRemaining = timeLeft > 300f ? TimeSpan.FromSeconds(timeLeft).ToShortString() : Mathf.CeilToInt(timeLeft).ToString();
                            Print(player, Lang("Cooldown", player.UserIDString, timeRemaining));
                            return false;
                        }
                    }
                }
                if (_removeMode == RemoveMode.MeleeHit && _configData.removerMode.meleeHitRequires)
                {
                    if (!IsMeleeTool(player))
                    {
                        var meleeToolDisplayName = GetDisplayNameByCurrencyName(lang.GetLanguage(player.UserIDString), _configData.removerMode.meleeHitItemShortname, _configData.removerMode.meleeHitModeSkin);
                        Print(player, Lang("MeleeToolNotHeld", player.UserIDString, meleeToolDisplayName));
                        return false;
                    }
                }
                if (_removeMode == RemoveMode.SpecificTool && _configData.removerMode.specificToolRequires)
                {
                    if (!IsSpecificTool(player))
                    {
                        var specificToolDisplayName = GetDisplayNameByCurrencyName(lang.GetLanguage(player.UserIDString), _configData.removerMode.specificToolShortName, _configData.removerMode.specificToolSkin);
                        Print(player, Lang("SpecificToolNotHeld", player.UserIDString, specificToolDisplayName));
                        return false;
                    }
                }

                interval = permissionS.removeInterval;
                resetTime = permissionS.resetTime;
                maxTime = permissionS.maxTime;
                maxRemovable = permissionS.maxRemovable;
                if (_configData.global.maxRemovableExclude && player.IsAdmin)
                {
                    maxRemovable = 0;
                }
                distance = permissionS.distance;
                pay = permissionS.pay;
                refund = permissionS.refund;
            }
            if (time == 0)
            {
                time = _configData.removeType[removeType].defaultTime;
            }
            if (time > maxTime)
            {
                time = maxTime;
            }
            var toolRemover = player.GetOrAddComponent<ToolRemover>();
            if (toolRemover.RemoveType == RemoveType.Normal)
            {
                if (!_configData.global.startCooldownOnRemoved)
                {
                    _cooldownTimes[player.userID] = Time.realtimeSinceStartup;
                }
            }
            toolRemover.Init(removeType, time, maxRemovable, distance, interval, pay, refund, resetTime, true);
            if (_configData.chat.showMessageWhenEnabledOrDisabled)
            {
                Print(player, Lang("ToolEnabled", player.UserIDString, time, maxRemovable == 0 ? Lang("Unlimit", player.UserIDString) : maxRemovable.ToString(), GetRemoveTypeName(removeType)));
            }
            return true;
        }

        [ConsoleCommand("remove.toggle")]
        private void CCmdRemoveToggle(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null)
            {
                Print(arg, "Syntax error!!! Please type the commands in the F1 console");
                return;
            }
            CmdRemove(player, null, arg.Args);
        }

        [ConsoleCommand("remove.target")]
        private void CCmdRemoveTarget(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length <= 1)
            {
                var stringBuilder = Pool.Get<StringBuilder>();
                stringBuilder.Clear();
                stringBuilder.AppendLine("Syntax error of target command");
                stringBuilder.AppendLine("remove.target <disable | d> <player (name or id)> - Disable remover tool for player");
                stringBuilder.AppendLine("remove.target <normal | n> <player (name or id)> [time (seconds)] [max removable objects (integer)] - Enable remover tool for player (Normal)");
                stringBuilder.AppendLine("remove.target <admin | a> <player (name or id)> [time (seconds)] - Enable remover tool for player (Admin)");
                stringBuilder.AppendLine("remove.target <all> <player (name or id)> [time (seconds)] - Enable remover tool for player (All)");
                stringBuilder.AppendLine("remove.target <structure | s> <player (name or id)> [time (seconds)] - Enable remover tool for player (Structure)");
                stringBuilder.AppendLine("remove.target <external | e> <player (name or id)> [time (seconds)] - Enable remover tool for player (External)");
                Print(arg, stringBuilder.ToString());
                stringBuilder.Clear();
                Pool.FreeUnmanaged(ref stringBuilder);
                return;
            }
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, PERMISSION_TARGET))
            {
                Print(arg, Lang("NotAllowed", player.UserIDString, PERMISSION_TARGET));
                return;
            }
            var target = RustCore.FindPlayer(arg.Args[1]);
            if (target == null || !target.IsConnected)
            {
                Print(arg, target == null ? $"'{arg.Args[0]}' cannot be found." : $"'{target}' is offline.");
                return;
            }
            var removeType = RemoveType.Normal;
            switch (arg.Args[0].ToLower())
            {
                case "n":
                case "normal":
                    break;

                case "a":
                case "admin":
                    removeType = RemoveType.Admin;
                    break;

                case "all":
                    removeType = RemoveType.All;
                    break;

                case "s":
                case "structure":
                    removeType = RemoveType.Structure;
                    break;

                case "e":
                case "external":
                    removeType = RemoveType.External;
                    break;

                case "d":
                case "disable":
                    var toolRemover = target.GetComponent<ToolRemover>();
                    if (toolRemover != null)
                    {
                        toolRemover.DisableTool();
                        Print(arg, $"{target}'s remover tool is disabled");
                    }
                    else
                    {
                        Print(arg, $"{target} did not enable the remover tool");
                    }
                    return;

                default:
                    var stringBuilder = Pool.Get<StringBuilder>();
                    stringBuilder.Clear();
                    stringBuilder.AppendLine("Syntax error of target command");
                    stringBuilder.AppendLine("remove.target <disable | d> <player (name or id)> - Disable remover tool for player");
                    stringBuilder.AppendLine("remove.target <normal | n> <player (name or id)> [time (seconds)] [max removable objects (integer)] - Enable remover tool for player (Normal)");
                    stringBuilder.AppendLine("remove.target <admin | a> <player (name or id)> [time (seconds)] - Enable remover tool for player (Admin)");
                    stringBuilder.AppendLine("remove.target <all> <player (name or id)> [time (seconds)] - Enable remover tool for player (All)");
                    stringBuilder.AppendLine("remove.target <structure | s> <player (name or id)> [time (seconds)] - Enable remover tool for player (Structure)");
                    stringBuilder.AppendLine("remove.target <external | e> <player (name or id)> [time (seconds)] - Enable remover tool for player (External)");
                    Print(arg, stringBuilder.ToString());
                    stringBuilder.Clear();
                    Pool.FreeUnmanaged(ref stringBuilder);
                    return;
            }
            var maxRemovable = 0;
            var time = _configData.removeType[removeType].defaultTime;
            if (arg.Args.Length > 2)
            {
                int.TryParse(arg.Args[2], out time);
            }
            if (arg.Args.Length > 3 && removeType == RemoveType.Normal)
            {
                int.TryParse(arg.Args[3], out maxRemovable);
            }
            var permissionS = _configData.permission[PERMISSION_NORMAL];
            var targetRemover = target.GetOrAddComponent<ToolRemover>();
            targetRemover.Init(removeType, time, maxRemovable, _configData.removeType[removeType].distance, permissionS.removeInterval, permissionS.pay, permissionS.refund, permissionS.resetTime, false);
            Print(arg, Lang("TargetEnabled", player?.UserIDString, target, time, maxRemovable, GetRemoveTypeName(removeType)));
        }

        [ConsoleCommand("remove.building")]
        private void CCmdConstruction(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length <= 1 || !arg.IsAdmin)
            {
                Print(arg, "Syntax error, Please type 'remove.building <price / refund / priceP / refundP> <percentage>', e.g.'remove.building price 60'");
                return;
            }
            float value;
            switch (arg.Args[0].ToLower())
            {
                case "price":
                    if (!float.TryParse(arg.Args[1], out value))
                    {
                        value = 50f;
                    }
                    foreach (var construction in _constructions)
                    {
                        BuildingBlocksSettings buildingBlocksSettings;
                        if (_configData.remove.buildingBlock.TryGetValue(construction.info.name.english, out buildingBlocksSettings))
                        {
                            foreach (var entry in buildingBlocksSettings.buildingGrade)
                            {
                                var grade = construction.GetGrade(entry.Key, 0);
                                var costToBuild = grade.CostToBuild();
                                entry.Value.price = costToBuild.ToDictionary(x => x.itemDef.shortname, y => new CurrencyInfo(value <= 0 ? 0 : Mathf.RoundToInt(y.amount * value / 100)));
                            }
                        }
                    }
                    Print(arg, $"Successfully modified all building prices to {value}% of the initial cost.");
                    SaveConfig();
                    LoadConfig();
                    return;

                case "refund":
                    if (!float.TryParse(arg.Args[1], out value))
                    {
                        value = 40f;
                    }
                    foreach (var construction in _constructions)
                    {
                        BuildingBlocksSettings buildingBlocksSettings;
                        if (_configData.remove.buildingBlock.TryGetValue(construction.info.name.english, out buildingBlocksSettings))
                        {
                            foreach (var entry in buildingBlocksSettings.buildingGrade)
                            {
                                var grade = construction.GetGrade(entry.Key, 0);
                                var costToBuild = grade.CostToBuild();
                                entry.Value.refund = costToBuild.ToDictionary(x => x.itemDef.shortname, y => new CurrencyInfo(value <= 0 ? 0 : Mathf.RoundToInt(y.amount * value / 100)));
                            }
                        }
                    }
                    Print(arg, $"Successfully modified all building refunds to {value}% of the initial cost.");
                    SaveConfig();
                    LoadConfig();
                    return;

                case "pricep":
                    if (!float.TryParse(arg.Args[1], out value))
                    {
                        value = 40f;
                    }
                    foreach (var buildingBlockS in _configData.remove.buildingBlock.Values)
                    {
                        foreach (var data in buildingBlockS.buildingGrade.Values)
                        {
                            data.price = value <= 0 ? 0 : value;
                        }
                    }

                    Print(arg, $"Successfully modified all building prices to {value}% of the initial cost.");
                    SaveConfig();
                    LoadConfig();
                    return;

                case "refundp":
                    if (!float.TryParse(arg.Args[1], out value))
                    {
                        value = 50f;
                    }
                    foreach (var buildingBlockS in _configData.remove.buildingBlock.Values)
                    {
                        foreach (var data in buildingBlockS.buildingGrade.Values)
                        {
                            data.refund = value <= 0 ? 0 : value;
                        }
                    }

                    Print(arg, $"Successfully modified all building refunds to {value}% of the initial cost.");
                    SaveConfig();
                    LoadConfig();
                    return;

                default:
                    Print(arg, "Syntax error, Please type 'remove.building <price / refund / priceP / refundP> <percentage>', e.g.'remove.building price 60'");
                    return;
            }
        }

        [ConsoleCommand("remove.allow")]
        private void CCmdRemoveAllow(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0)
            {
                Print(arg, "Syntax error, Please type 'remove.allow <true | false>'");
                return;
            }
            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, PERMISSION_OVERRIDE))
            {
                Print(arg, Lang("NotAllowed", player.UserIDString, PERMISSION_OVERRIDE));
                return;
            }
            switch (arg.Args[0].ToLower())
            {
                case "true":
                case "1":
                    _removeOverride = false;
                    Print(arg, "Remove is now allowed depending on your settings.");
                    return;

                case "false":
                case "0":
                    _removeOverride = true;
                    Print(arg, "Remove is now restricted for all players (exept admins)");
                    foreach (var p in BasePlayer.activePlayerList)
                    {
                        var toolRemover = p.GetComponent<ToolRemover>();
                        if (toolRemover == null)
                        {
                            continue;
                        }
                        if (toolRemover.RemoveType == RemoveType.Normal && toolRemover.CanOverride)
                        {
                            Print(toolRemover.Player, "The remover tool has been disabled by the admin");
                            toolRemover.DisableTool(false);
                        }
                    }
                    return;

                default:
                    Print(arg, "This is not a valid argument");
                    return;
            }
        }

        [ConsoleCommand("remove.playerentity")]
        private void CCmdRemoveEntity(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length <= 1 || !arg.IsAdmin)
            {
                var stringBuilder = Pool.Get<StringBuilder>();
                stringBuilder.Clear();
                stringBuilder.AppendLine("Syntax error of remove.playerentity command");
                stringBuilder.AppendLine("remove.playerentity <all | a> <player id> - Remove all entities of the player");
                stringBuilder.AppendLine("remove.playerentity <building | b> <player id> - Remove all buildings of the player");
                stringBuilder.AppendLine("remove.playerentity <cupboard | c> <player id> - Remove buildings of the player owned cupboard");
                Print(arg, stringBuilder.ToString());
                stringBuilder.Clear();
                Pool.FreeUnmanaged(ref stringBuilder);
                return;
            }
            if (_removePlayerEntityCoroutine != null)
            {
                Print(arg, "There is already a RemovePlayerEntity running, please wait.");
                return;
            }
            ulong targetID;
            if (!ulong.TryParse(arg.Args[1], out targetID) || !targetID.IsSteamId())
            {
                Print(arg, "Please enter the player's steamID.");
                return;
            }
            PlayerEntityRemoveType playerEntityRemoveType;
            switch (arg.Args[0].ToLower())
            {
                case "a":
                case "all":
                    playerEntityRemoveType = PlayerEntityRemoveType.All;
                    break;

                case "b":
                case "building":
                    playerEntityRemoveType = PlayerEntityRemoveType.Building;
                    break;

                case "c":
                case "cupboard":
                    playerEntityRemoveType = PlayerEntityRemoveType.Cupboard;
                    break;

                default:
                    Print(arg, "This is not a valid argument");
                    return;
            }
            _removePlayerEntityCoroutine = ServerMgr.Instance.StartCoroutine(RemovePlayerEntity(arg, targetID, playerEntityRemoveType));
            Print(arg, "Start running RemovePlayerEntity, please wait.");
        }

        #endregion Commands

        #region Debug

        private void PrintDebug(string message, bool warning = false)
        {
            if (_configData.global.debugEnabled)
            {
                if (warning)
                {
                    PrintWarning(message);
                }
                else
                {
                    Puts(message);
                }
            }
            if (_configData.global.logToFile)
            {
                _debugStringBuilder.AppendLine($"[{DateTime.Now.ToString(CultureInfo.InstalledUICulture)}] | {message}");
            }
        }

        private void SaveDebug()
        {
            if (!_configData.global.logToFile)
            {
                return;
            }
            var debugText = _debugStringBuilder.ToString().Trim();
            _debugStringBuilder.Clear();
            if (!string.IsNullOrEmpty(debugText))
            {
                LogToFile("debug", debugText, this);
            }
        }

        #endregion Debug

        #region RustTranslationAPI

        private string GetItemTranslationByShortName(string language, string itemShortName)
        {
            return (string)RustTranslationAPI.Call("GetItemTranslationByShortName", language, itemShortName);
        }

        private string GetConstructionTranslation(string language, string prefabName)
        {
            return (string)RustTranslationAPI.Call("GetConstructionTranslation", language, prefabName);
        }

        private string GetDeployableTranslation(string language, string deployable)
        {
            return (string)RustTranslationAPI.Call("GetDeployableTranslation", language, deployable);
        }

        private string GetItemDisplayName(string language, string itemShortName)
        {
            if (RustTranslationAPI != null)
            {
                return GetItemTranslationByShortName(language, itemShortName);
            }
            return null;
        }

        private string GetConstructionDisplayName(BasePlayer player, string shortPrefabName, string displayName)
        {
            if (RustTranslationAPI != null)
            {
                var displayName1 = GetConstructionTranslation(lang.GetLanguage(player.UserIDString), shortPrefabName);
                if (!string.IsNullOrEmpty(displayName1))
                {
                    return displayName1;
                }
            }
            return displayName;
        }

        private string GetDeployableDisplayName(BasePlayer player, string deployable, string displayName)
        {
            if (RustTranslationAPI != null)
            {
                var displayName1 = GetDeployableTranslation(lang.GetLanguage(player.UserIDString), deployable);
                if (!string.IsNullOrEmpty(displayName1))
                {
                    return displayName1;
                }
            }
            return displayName;
        }

        #endregion RustTranslationAPI

        #region ConfigurationFile

        private void UpdateConfig()
        {
            var buildingGrades = new[]
            {
                BuildingGrade.Enum.Twigs, BuildingGrade.Enum.Wood,
                BuildingGrade.Enum.Stone, BuildingGrade.Enum.Metal, BuildingGrade.Enum.TopTier
            };

            foreach (var value in buildingGrades)
            {
                if (!_configData.remove.validConstruction.ContainsKey(value))
                {
                    _configData.remove.validConstruction.Add(value, true);
                }
            }

            var newBuildingBlocks = new Dictionary<string, BuildingBlocksSettings>();
            foreach (var construction in _constructions)
            {
                BuildingBlocksSettings buildingBlocksSettings;
                if (!_configData.remove.buildingBlock.TryGetValue(construction.info.name.english, out buildingBlocksSettings))
                {
                    var buildingGrade = new Dictionary<BuildingGrade.Enum,
                            BuildingGradeSettings>();
                    foreach (var value in buildingGrades)
                    {
                        var grade = construction.GetGrade(value, 0);

                        if (grade == null)
                        {
                            continue;
                        }

                        var costToBuild = grade.CostToBuild();
                       
                        buildingGrade.Add(value, new BuildingGradeSettings
                        {
                            refund = costToBuild.ToDictionary(x => x.itemDef.shortname, y => new CurrencyInfo(Mathf.RoundToInt(y.amount * 0.4f))),
                            price = costToBuild.ToDictionary(x => x.itemDef.shortname, y => new CurrencyInfo(Mathf.RoundToInt(y.amount * 0.6f)))
                        });
                    }
                    buildingBlocksSettings = new BuildingBlocksSettings { displayName = construction.info.name.english, buildingGrade = buildingGrade };
                }
                newBuildingBlocks.Add(construction.info.name.english, buildingBlocksSettings);
            }
            _configData.remove.buildingBlock = newBuildingBlocks;
            foreach (var entry in _shortPrefabNameToDeployable)
            {
                EntitySettings entitySettings;
                if (!_configData.remove.entity.TryGetValue(entry.Key, out entitySettings))
                {
                    var itemDefinition = ItemManager.FindItemDefinition(entry.Value);
                    entitySettings = new EntitySettings
                    {
                        enabled = _configData.global.defaultEntity.removeAllowed && itemDefinition.category != ItemCategory.Food,
                        displayName = itemDefinition.displayName.english,
                        refund = new Dictionary<string, CurrencyInfo>
                        {
                            [entry.Value] = new CurrencyInfo(1)
                        },
                        price = new Dictionary<string, CurrencyInfo>()
                    };
                    _configData.remove.entity.Add(entry.Key, entitySettings);
                }
            }
            SaveConfig();
        }

        private static ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Settings")]
            public readonly GlobalSettings global = new GlobalSettings();

            [JsonProperty(PropertyName = "Container Settings")]
            public readonly ContainerSettings container = new ContainerSettings();

            [JsonProperty(PropertyName = "Remove Damaged Entities")]
            public readonly DamagedEntitySettings damagedEntity = new DamagedEntitySettings();

            [JsonProperty(PropertyName = "Chat Settings")]
            public readonly ChatSettings chat = new ChatSettings();

            [JsonProperty(PropertyName = "Permission Settings (Just for normal type)")]
            public readonly Dictionary<string, PermissionSettings> permission = new Dictionary<string, PermissionSettings>
            {
                [PERMISSION_NORMAL] = new PermissionSettings { priority = 0, distance = 3, cooldown = 60, maxTime = 300, maxRemovable = 50, removeInterval = 0.8f, pay = true, refund = true, resetTime = false }
            };

            [JsonProperty(PropertyName = "Remove Type Settings")]
            public readonly Dictionary<RemoveType, RemoveTypeSettings> removeType = new Dictionary<RemoveType, RemoveTypeSettings>
            {
                [RemoveType.Normal] = new RemoveTypeSettings { displayName = RemoveType.Normal.ToString(), distance = 3, gibs = true, defaultTime = 60, maxTime = 300, resetTime = false },
                [RemoveType.Structure] = new RemoveTypeSettings { displayName = RemoveType.Structure.ToString(), distance = 100, gibs = false, defaultTime = 300, maxTime = 600, resetTime = true },
                [RemoveType.All] = new RemoveTypeSettings { displayName = RemoveType.All.ToString(), distance = 50, gibs = false, defaultTime = 300, maxTime = 600, resetTime = true },
                [RemoveType.Admin] = new RemoveTypeSettings { displayName = RemoveType.Admin.ToString(), distance = 20, gibs = true, defaultTime = 300, maxTime = 600, resetTime = true },
                [RemoveType.External] = new RemoveTypeSettings { displayName = RemoveType.External.ToString(), distance = 20, gibs = true, defaultTime = 300, maxTime = 600, resetTime = true }
            };

            [JsonProperty(PropertyName = "Remove Mode Settings (Only one model works)")]
            public readonly RemoverModeSettings removerMode = new RemoverModeSettings();

            [JsonProperty(PropertyName = "NoEscape Settings")]
            public readonly NoEscapeSettings noEscape = new NoEscapeSettings();

            [JsonProperty(PropertyName = "Image Urls (Used to UI image)")]
            public readonly Dictionary<string, string> imageUrls = new Dictionary<string, string>
            {
                [ECONOMICS_KEY] = "https://i.imgur.com/znPwdcv.png",
                [SERVER_REWARDS_KEY] = "https://i.imgur.com/04rJsV3.png"
            };

            [JsonProperty(PropertyName = "GUI")]
            public readonly UiSettings ui = new UiSettings();

            [JsonProperty(PropertyName = "Remove Info (Refund & Price)")]
            public readonly RemoveSettings remove = new RemoveSettings();

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber version;
        }

        public class GlobalSettings
        {
            [JsonProperty(PropertyName = "Enable Debug Mode")]
            public bool debugEnabled;

            [JsonProperty(PropertyName = "Log Debug To File")]
            public bool logToFile;

            [JsonProperty(PropertyName = "Use Teams")]
            public bool useTeams = false;

            [JsonProperty(PropertyName = "Use Clans")]
            public bool useClans = true;

            [JsonProperty(PropertyName = "Use Friends")]
            public bool useFriends = true;

            [JsonProperty(PropertyName = "Use Entity Owners")]
            public bool useEntityOwners = true;

            [JsonProperty(PropertyName = "Use Building Locks")]
            public bool useBuildingLocks = false;

            [JsonProperty(PropertyName = "Use Tool Cupboards (Strongly unrecommended)")]
            public bool useToolCupboards = false;

            [JsonProperty(PropertyName = "Use Building Owners (You will need BuildingOwners plugin)")]
            public bool useBuildingOwners = false;

            //[JsonProperty(PropertyName = "Exclude Twigs (Used for \"Use Tool Cupboards\" and \"Use Entity Owners\")")]
            //public bool excludeTwigs;

            [JsonProperty(PropertyName = "Remove Button")]
            public string removeButton = BUTTON.FIRE_PRIMARY.ToString();

            [JsonProperty(PropertyName = "Remove Interval (Min = 0.2)")]
            public float removeInterval = 0.5f;

            [JsonProperty(PropertyName = "Only start cooldown when an entity is removed")]
            public bool startCooldownOnRemoved;

            [JsonProperty(PropertyName = "RemoveType - All/Structure - Remove per frame")]
            public int removePerFrame = 15;

            [JsonProperty(PropertyName = "RemoveType - All/Structure - No item container dropped")]
            public bool noItemContainerDrop = true;

            [JsonProperty(PropertyName = "RemoveType - Normal - Max Removable Objects - Exclude admins")]
            public bool maxRemovableExclude = true;

            [JsonProperty(PropertyName = "RemoveType - Normal - Cooldown - Exclude admins")]
            public bool cooldownExclude = true;

            [JsonProperty(PropertyName = "RemoveType - Normal - Entity Spawned Time Limit - Enabled")]
            public bool entityTimeLimit = false;

            [JsonProperty(PropertyName = "RemoveType - Normal - Entity Spawned Time Limit - Cannot be removed when entity spawned time more than it")]
            public float limitTime = 300f;

            [JsonProperty(PropertyName = "Default Entity Settings (When automatically adding new entities to 'Other Entity Settings')")]
            public DefaultEntitySettings defaultEntity = new DefaultEntitySettings();

            public class DefaultEntitySettings
            {
                [JsonProperty(PropertyName = "Default Remove Allowed")]
                public bool removeAllowed = true;
            }
        }

        public class ContainerSettings
        {
            [JsonProperty(PropertyName = "Storage Container - Enable remove of not empty storages")]
            public bool removeNotEmptyStorage = true;

            [JsonProperty(PropertyName = "Storage Container - Drop items from container")]
            public bool dropItemsStorage = false;

            [JsonProperty(PropertyName = "Storage Container - Drop a item container from container")]
            public bool dropContainerStorage = true;

            [JsonProperty(PropertyName = "IOEntity Container - Enable remove of not empty storages")]
            public bool removeNotEmptyIoEntity = true;

            [JsonProperty(PropertyName = "IOEntity Container - Drop items from container")]
            public bool dropItemsIoEntity = false;

            [JsonProperty(PropertyName = "IOEntity Container - Drop a item container from container")]
            public bool dropContainerIoEntity = true;
        }

        public class DamagedEntitySettings
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool enabled = false;

            [JsonProperty(PropertyName = "Exclude Quarries")]
            public bool excludeQuarries = true;

            [JsonProperty(PropertyName = "Exclude Building Blocks")]
            public bool excludeBuildingBlocks = true;

            [JsonProperty(PropertyName = "Percentage (Can be removed when (health / max health * 100) is not less than it)")]
            public float percentage = 90f;
        }

        public class ChatSettings
        {
            [JsonProperty(PropertyName = "Chat Command")]
            public string command = "remove";

            [JsonProperty(PropertyName = "Chat Prefix")]
            public string prefix = "<color=#00FFFF>[RemoverTool]</color>: ";

            [JsonProperty(PropertyName = "Chat SteamID Icon")]
            public ulong steamIDIcon = 0;

            [JsonProperty(PropertyName = "Show Message When Enabled/Disabled")]
            public bool showMessageWhenEnabledOrDisabled = true;
        }

        public class PermissionSettings
        {
            [JsonProperty(PropertyName = "Priority")]
            public int priority;

            [JsonProperty(PropertyName = "Distance")]
            public float distance;

            [JsonProperty(PropertyName = "Cooldown")]
            public float cooldown;

            [JsonProperty(PropertyName = "Max Time")]
            public int maxTime;

            [JsonProperty(PropertyName = "Remove Interval (Min = 0.2)")]
            public float removeInterval;

            [JsonProperty(PropertyName = "Max Removable Objects (0 = Unlimited)")]
            public int maxRemovable;

            [JsonProperty(PropertyName = "Pay")]
            public bool pay;

            [JsonProperty(PropertyName = "Refund")]
            public bool refund;

            [JsonProperty(PropertyName = "Reset the time after removing an entity")]
            public bool resetTime;
        }

        public class RemoveTypeSettings
        {
            [JsonProperty(PropertyName = "Display Name")]
            public string displayName;

            [JsonProperty(PropertyName = "Distance")]
            public float distance;

            [JsonProperty(PropertyName = "Default Time")]
            public int defaultTime;

            [JsonProperty(PropertyName = "Max Time")]
            public int maxTime;

            [JsonProperty(PropertyName = "Gibs")]
            public bool gibs;

            [JsonProperty(PropertyName = "Reset the time after removing an entity")]
            public bool resetTime;
        }

        public class RemoverModeSettings
        {
            [JsonProperty(PropertyName = "No Held Item Mode")]
            public bool noHeldMode = true;

            [JsonProperty(PropertyName = "No Held Item Mode - Disable remover tool when you have any item in hand")]
            public bool noHeldDisableInHand = true;

            [JsonProperty(PropertyName = "Melee Tool Hit Mode")]
            public bool meleeHitMode;

            [JsonProperty(PropertyName = "Melee Tool Hit Mode - Item shortname")]
            public string meleeHitItemShortname = "hammer";

            [JsonProperty(PropertyName = "Melee Tool Hit Mode - Item skin (-1 = All skins)")]
            public long meleeHitModeSkin = -1;

            [JsonProperty(PropertyName = "Melee Tool Hit Mode - Auto enable remover tool when you hold a melee tool")]
            public bool meleeHitEnableInHand = false;

            [JsonProperty(PropertyName = "Melee Tool Hit Mode - Requires a melee tool in your hand when remover tool is enabled")]
            public bool meleeHitRequires;

            [JsonProperty(PropertyName = "Melee Tool Hit Mode - Disable remover tool when you are not holding a melee tool")]
            public bool meleeHitDisableInHand;

            [JsonProperty(PropertyName = "Specific Tool Mode")]
            public bool specificToolMode = false;

            [JsonProperty(PropertyName = "Specific Tool Mode - Item shortname")]
            public string specificToolShortName = "hammer";

            [JsonProperty(PropertyName = "Specific Tool Mode - Item skin (-1 = All skins)")]
            public long specificToolSkin = -1;

            [JsonProperty(PropertyName = "Specific Tool Mode - Auto enable remover tool when you hold a specific tool")]
            public bool specificToolEnableInHand = false;

            [JsonProperty(PropertyName = "Specific Tool Mode - Requires a specific tool in your hand when remover tool is enabled")]
            public bool specificToolRequires = false;

            [JsonProperty(PropertyName = "Specific Tool Mode - Disable remover tool when you are not holding a specific tool")]
            public bool specificToolDisableInHand = false;
        }

        public class NoEscapeSettings
        {
            [JsonProperty(PropertyName = "Use Raid Blocker")]
            public bool useRaidBlocker;

            [JsonProperty(PropertyName = "Use Combat Blocker")]
            public bool useCombatBlocker;
        }

        public class UiSettings
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool enabled = true;

            [JsonProperty(PropertyName = "Main Box - Min Anchor (in Rust Window)")]
            public string removerToolAnchorMin = "0 1";

            [JsonProperty(PropertyName = "Main Box - Max Anchor (in Rust Window)")]
            public string removerToolAnchorMax = "0 1";

            [JsonProperty(PropertyName = "Main Box - Min Offset (in Rust Window)")]
            public string removerToolOffsetMin = "30 -330";

            [JsonProperty(PropertyName = "Main Box - Max Offset (in Rust Window)")]
            public string removerToolOffsetMax = "470 -40";

            [JsonProperty(PropertyName = "Main Box - Background Color")]
            public string removerToolBackgroundColor = "0 0 0 0";

            [JsonProperty(PropertyName = "Remove Title - Box - Min Anchor (in Main Box)")]
            public string removeAnchorMin = "0 0.84";

            [JsonProperty(PropertyName = "Remove Title - Box - Max Anchor (in Main Box)")]
            public string removeAnchorMax = "0.996 1";

            [JsonProperty(PropertyName = "Remove Title - Box - Background Color")]
            public string removeBackgroundColor = "0.31 0.88 0.71 1";

            [JsonProperty(PropertyName = "Remove Title - Text - Min Anchor (in Main Box)")]
            public string removeTextAnchorMin = "0.05 0.84";

            [JsonProperty(PropertyName = "Remove Title - Text - Max Anchor (in Main Box)")]
            public string removeTextAnchorMax = "0.6 1";

            [JsonProperty(PropertyName = "Remove Title - Text - Text Color")]
            public string removeTextColor = "1 0.1 0.1 1";

            [JsonProperty(PropertyName = "Remove Title - Text - Text Size")]
            public int removeTextSize = 18;

            [JsonProperty(PropertyName = "Timeleft - Box - Min Anchor (in Main Box)")]
            public string timeLeftAnchorMin = "0.6 0.84";

            [JsonProperty(PropertyName = "Timeleft - Box - Max Anchor (in Main Box)")]
            public string timeLeftAnchorMax = "1 1";

            [JsonProperty(PropertyName = "Timeleft - Box - Background Color")]
            public string timeLeftBackgroundColor = "0 0 0 0";

            [JsonProperty(PropertyName = "Timeleft - Text - Min Anchor (in Timeleft Box)")]
            public string timeLeftTextAnchorMin = "0 0";

            [JsonProperty(PropertyName = "Timeleft - Text - Max Anchor (in Timeleft Box)")]
            public string timeLeftTextAnchorMax = "0.9 1";

            [JsonProperty(PropertyName = "Timeleft - Text - Text Color")]
            public string timeLeftTextColor = "0 0 0 0.9";

            [JsonProperty(PropertyName = "Timeleft - Text - Text Size")]
            public int timeLeftTextSize = 15;

            [JsonProperty(PropertyName = "Entity - Box - Min Anchor (in Main Box)")]
            public string entityAnchorMin = "0 0.68";

            [JsonProperty(PropertyName = "Entity - Box - Max Anchor (in Main Box)")]
            public string entityAnchorMax = "1 0.84";

            [JsonProperty(PropertyName = "Entity - Box - Background Color")]
            public string entityBackgroundColor = "0.82 0.58 0.30 1";

            [JsonProperty(PropertyName = "Entity - Text - Min Anchor (in Entity Box)")]
            public string entityTextAnchorMin = "0.05 0";

            [JsonProperty(PropertyName = "Entity - Text - Max Anchor (in Entity Box)")]
            public string entityTextAnchorMax = "1 1";

            [JsonProperty(PropertyName = "Entity - Text - Text Color")]
            public string entityTextColor = "1 1 1 1";

            [JsonProperty(PropertyName = "Entity - Text - Text Size")]
            public int entityTextSize = 16;

            [JsonProperty(PropertyName = "Entity - Image - Enabled")]
            public bool entityImageEnabled = true;

            [JsonProperty(PropertyName = "Entity - Image - Min Anchor (in Entity Box)")]
            public string entityImageAnchorMin = "0.795 0.01";

            [JsonProperty(PropertyName = "Entity - Image - Max Anchor (in Entity Box)")]
            public string entityImageAnchorMax = "0.9 0.99";

            [JsonProperty(PropertyName = "Authorization Check Enabled")]
            public bool authorizationEnabled = true;

            [JsonProperty(PropertyName = "Authorization Check - Box - Min Anchor (in Main Box)")]
            public string authorizationsAnchorMin = "0 0.6";

            [JsonProperty(PropertyName = "Authorization Check - Box - Max Anchor (in Main Box)")]
            public string authorizationsAnchorMax = "1 0.68";

            [JsonProperty(PropertyName = "Authorization Check - Box - Allowed Background Color")]
            public string allowedBackgroundColor = "0.22 0.78 0.27 1";

            [JsonProperty(PropertyName = "Authorization Check - Box - Refused Background Color")]
            public string refusedBackgroundColor = "0.78 0.22 0.27 1";

            [JsonProperty(PropertyName = "Authorization Check - Text - Min Anchor (in Authorization Check Box)")]
            public string authorizationsTextAnchorMin = "0.05 0";

            [JsonProperty(PropertyName = "Authorization Check - Text - Max Anchor (in Authorization Check Box)")]
            public string authorizationsTextAnchorMax = "1 1";

            [JsonProperty(PropertyName = "Authorization Check - Text - Text Color")]
            public string authorizationsTextColor = "1 1 1 0.9";

            [JsonProperty(PropertyName = "Authorization Check Box - Text - Text Size")]
            public int authorizationsTextSize = 14;

            [JsonProperty(PropertyName = "Price & Refund - Image Enabled")]
            public bool imageEnabled = true;

            [JsonProperty(PropertyName = "Price & Refund - Image Scale")]
            public float imageScale = 0.18f;

            [JsonProperty(PropertyName = "Price & Refund - Distance of image from right border")]
            public float rightDistance = 0.05f;

            [JsonProperty(PropertyName = "Price Enabled")]
            public bool priceEnabled = true;

            [JsonProperty(PropertyName = "Price - Box - Min Anchor (in Main Box)")]
            public string priceAnchorMin = "0 0.3";

            [JsonProperty(PropertyName = "Price - Box - Max Anchor (in Main Box)")]
            public string priceAnchorMax = "1 0.6";

            [JsonProperty(PropertyName = "Price - Box - Background Color")]
            public string priceBackgroundColor = "0 0 0 0.8";

            [JsonProperty(PropertyName = "Price - Text - Min Anchor (in Price Box)")]
            public string priceTextAnchorMin = "0.05 0";

            [JsonProperty(PropertyName = "Price - Text - Max Anchor (in Price Box)")]
            public string priceTextAnchorMax = "0.25 1";

            [JsonProperty(PropertyName = "Price - Text - Text Color")]
            public string priceTextColor = "1 1 1 0.9";

            [JsonProperty(PropertyName = "Price - Text - Text Size")]
            public int priceTextSize = 18;

            [JsonProperty(PropertyName = "Price - Text2 - Min Anchor (in Price Box)")]
            public string price2TextAnchorMin = "0.3 0";

            [JsonProperty(PropertyName = "Price - Text2 - Max Anchor (in Price Box)")]
            public string price2TextAnchorMax = "1 1";

            [JsonProperty(PropertyName = "Price - Text2 - Text Color")]
            public string price2TextColor = "1 1 1 0.9";

            [JsonProperty(PropertyName = "Price - Text2 - Text Size")]
            public int price2TextSize = 16;

            [JsonProperty(PropertyName = "Refund Enabled")]
            public bool refundEnabled = true;

            [JsonProperty(PropertyName = "Refund - Box - Min Anchor (in Main Box)")]
            public string refundAnchorMin = "0 0";

            [JsonProperty(PropertyName = "Refund - Box - Max Anchor (in Main Box)")]
            public string refundAnchorMax = "1 0.3";

            [JsonProperty(PropertyName = "Refund - Box - Background Color")]
            public string refundBackgroundColor = "0 0 0 0.8";

            [JsonProperty(PropertyName = "Refund - Text - Min Anchor (in Refund Box)")]
            public string refundTextAnchorMin = "0.05 0";

            [JsonProperty(PropertyName = "Refund - Text - Max Anchor (in Refund Box)")]
            public string refundTextAnchorMax = "0.25 1";

            [JsonProperty(PropertyName = "Refund - Text - Text Color")]
            public string refundTextColor = "1 1 1 0.9";

            [JsonProperty(PropertyName = "Refund - Text - Text Size")]
            public int refundTextSize = 18;

            [JsonProperty(PropertyName = "Refund - Text2 - Min Anchor (in Refund Box)")]
            public string refund2TextAnchorMin = "0.3 0";

            [JsonProperty(PropertyName = "Refund - Text2 - Max Anchor (in Refund Box)")]
            public string refund2TextAnchorMax = "1 1";

            [JsonProperty(PropertyName = "Refund - Text2 - Text Color")]
            public string refund2TextColor = "1 1 1 0.9";

            [JsonProperty(PropertyName = "Refund - Text2 - Text Size")]
            public int refund2TextSize = 16;

            [JsonProperty(PropertyName = "Crosshair - Enabled")]
            public bool showCrosshair = true;

            [JsonProperty(PropertyName = "Crosshair - Image Url")]
            public string crosshairImageUrl = "https://i.imgur.com/SqLCJaQ.png";

            [JsonProperty(PropertyName = "Crosshair - Box - Min Anchor (in Rust Window)")]
            public string crosshairAnchorMin = "0.5 0.5";

            [JsonProperty(PropertyName = "Crosshair - Box - Max Anchor (in Rust Window)")]
            public string crosshairAnchorMax = "0.5 0.5";

            [JsonProperty(PropertyName = "Crosshair - Box - Min Offset (in Rust Window)")]
            public string crosshairOffsetMin = "-15 -15";

            [JsonProperty(PropertyName = "Crosshair - Box - Max Offset (in Rust Window)")]
            public string crosshairOffsetMax = "15 15";

            [JsonProperty(PropertyName = "Crosshair - Box - Image Color")]
            public string crosshairColor = "1 0 0 1";

            [JsonIgnore]
            public Vector2 Price2TextAnchorMin, Price2TextAnchorMax, Refund2TextAnchorMin, Refund2TextAnchorMax;
        }

        public class RemoveSettings
        {
            [JsonProperty(PropertyName = "Price Enabled")]
            public bool priceEnabled = true;

            [JsonProperty(PropertyName = "Refund Enabled")]
            public bool refundEnabled = true;

            [JsonProperty(PropertyName = "Refund Items In Entity Slot")]
            public bool refundSlot = true;

            [JsonProperty(PropertyName = "Allowed Building Grade")]
            public Dictionary<BuildingGrade.Enum, bool> validConstruction = new Dictionary<BuildingGrade.Enum, bool>();

            [JsonProperty(PropertyName = "Display Names (Refund & Price)")]
            public readonly Dictionary<string, string> displayNames = new Dictionary<string, string>();

            [JsonProperty(PropertyName = "Building Blocks Settings")]
            public Dictionary<string, BuildingBlocksSettings> buildingBlock = new Dictionary<string, BuildingBlocksSettings>();

            [JsonProperty(PropertyName = "Other Entity Settings")]
            public Dictionary<string, EntitySettings> entity = new Dictionary<string, EntitySettings>();
        }

        public class BuildingBlocksSettings
        {
            [JsonProperty(PropertyName = "Display Name")]
            public string displayName;

            [JsonProperty(PropertyName = "Building Grade")]
            public Dictionary<BuildingGrade.Enum, BuildingGradeSettings> buildingGrade = new Dictionary<BuildingGrade.Enum, BuildingGradeSettings>();
        }

        public class BuildingGradeSettings
        {
            [JsonProperty(PropertyName = "Price")]
            public object price;

            [JsonProperty(PropertyName = "Refund")]
            public object refund;

            [JsonIgnore]
            public float pricePercentage = -1, refundPercentage = -1;

            [JsonIgnore]
            public Dictionary<string, CurrencyInfo> priceDict, refundDict;
        }

        public class EntitySettings
        {
            [JsonProperty(PropertyName = "Remove Allowed")]
            public bool enabled;

            [JsonProperty(PropertyName = "Display Name")]
            public string displayName = string.Empty;

            [JsonProperty(PropertyName = "Price")]
            public object price;

            [JsonProperty(PropertyName = "Refund")]
            public object refund;

            [JsonIgnore]
            public Dictionary<string, CurrencyInfo> priceDict, refundDict;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                PreprocessOldConfig();
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");

                LoadDefaultConfig();
            }
            SaveConfig();
            PreprocessConfigValues();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
            _configData.version = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_configData);
        }

        private void PreprocessConfigValues()
        {
            _configData.ui.Price2TextAnchorMin = GetAnchor(_configData.ui.price2TextAnchorMin);
            _configData.ui.Price2TextAnchorMax = GetAnchor(_configData.ui.price2TextAnchorMax);
            _configData.ui.Refund2TextAnchorMin = GetAnchor(_configData.ui.refund2TextAnchorMin);
            _configData.ui.Refund2TextAnchorMax = GetAnchor(_configData.ui.refund2TextAnchorMax);

            foreach (var entry in _configData.remove.buildingBlock)
            {
                foreach (var gradeEntry in entry.Value.buildingGrade)
                {
                    var price = gradeEntry.Value.price;
                    float pricePercentage;
                    if (float.TryParse(price.ToString(), out pricePercentage))
                    {
                        gradeEntry.Value.pricePercentage = pricePercentage;
                    }
                    else
                    {
                        var priceDic = price as Dictionary<string, CurrencyInfo>;
                        if (priceDic != null)
                        {
                            gradeEntry.Value.priceDict = priceDic;
                        }
                        else
                        {
                            try
                            {
                                gradeEntry.Value.priceDict = JsonConvert.DeserializeObject<Dictionary<string, CurrencyInfo>>(price.ToString());
                            }
                            catch (Exception e)
                            {
                                gradeEntry.Value.priceDict = null;
                                PrintError($"Wrong price format for '{gradeEntry.Key}' of '{entry.Key}' in 'Building Blocks Settings'. Error Message: {e.Message}");
                            }
                        }
                    }

                    var refund = gradeEntry.Value.refund;
                    float refundPercentage;
                    if (float.TryParse(refund.ToString(), out refundPercentage))
                    {
                        gradeEntry.Value.refundPercentage = refundPercentage;
                    }
                    else
                    {
                        var refundDic = refund as Dictionary<string, CurrencyInfo>;
                        if (refundDic != null)
                        {
                            gradeEntry.Value.refundDict = refundDic;
                        }
                        else
                        {
                            try
                            {
                                gradeEntry.Value.refundDict = JsonConvert.DeserializeObject<Dictionary<string, CurrencyInfo>>(refund.ToString());
                            }
                            catch (Exception e)
                            {
                                gradeEntry.Value.refundDict = null;
                                PrintError($"Wrong refund format for '{gradeEntry.Key}' of '{entry.Key}' in 'Building Blocks Settings'. Error Message: {e.Message}");
                            }
                        }
                    }
                }
            }
            foreach (var entry in _configData.remove.entity)
            {
                var price = entry.Value.price;
                var priceDic = price as Dictionary<string, CurrencyInfo>;
                if (priceDic != null)
                {
                    entry.Value.priceDict = priceDic;
                }
                else
                {
                    try
                    {
                        entry.Value.priceDict = JsonConvert.DeserializeObject<Dictionary<string, CurrencyInfo>>(price.ToString());
                    }
                    catch (Exception e)
                    {
                        entry.Value.priceDict = null;
                        PrintError($"Wrong price format for '{entry.Key}' of '{entry.Key}' in 'Other Entity Settings'. Error Message: {e.Message}");
                    }
                }

                var refund = entry.Value.refund;
                var refundDic = refund as Dictionary<string, CurrencyInfo>;
                if (refundDic != null)
                {
                    entry.Value.refundDict = refundDic;
                }
                else
                {
                    try
                    {
                        entry.Value.refundDict = JsonConvert.DeserializeObject<Dictionary<string, CurrencyInfo>>(refund.ToString());
                    }
                    catch (Exception e)
                    {
                        entry.Value.refundDict = null;
                        PrintError($"Wrong refund format for '{entry.Key}' of '{entry.Key}' in 'Other Entity Settings'. Error Message: {e.Message}");
                    }
                }
            }
        }

        private void UpdateConfigValues()
        {
            if (_configData.version < Version)
            {
                if (_configData.version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat Settings", "Chat Prefix") && GetConfigValue(out prefixColor, "Chat Settings", "Chat Prefix Color"))
                    {
                        _configData.chat.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }

                    if (_configData.ui.removerToolAnchorMin == "0.1 0.55")
                    {
                        _configData.ui.removerToolAnchorMin = "0.04 0.55";
                    }

                    if (_configData.ui.removerToolAnchorMax == "0.4 0.95")
                    {
                        _configData.ui.removerToolAnchorMax = "0.37 0.95";
                    }
                }

                if (_configData.version <= new VersionNumber(4, 3, 22))
                {
                    bool enabled;
                    if (GetConfigValue(out enabled, "Remove Mode Settings (Only one model works)", "Hammer Hit Mode"))
                    {
                        _configData.removerMode.meleeHitMode = true;
                        _configData.removerMode.meleeHitItemShortname = "hammer";
                    }
                    if (GetConfigValue(out enabled, "Remove Mode Settings (Only one model works)", "Hammer Hit Mode - Requires a hammer in your hand when remover tool is enabled"))
                    {
                        _configData.removerMode.meleeHitRequires = true;
                    }
                    if (GetConfigValue(out enabled, "Remove Mode Settings (Only one model works)", "Hammer Hit Mode - Disable remover tool when you are not holding a hammer"))
                    {
                        _configData.removerMode.meleeHitDisableInHand = true;
                    }
                }

                if (_configData.version <= new VersionNumber(4, 3, 23))
                {
                    string value;
                    if (GetConfigValue(out value, "GUI", "Authorization Check - Box - Allowed Background"))
                    {
                        _configData.ui.allowedBackgroundColor = value == "0 1 0 0.8" ? "0.22 0.78 0.27 1" : value;
                    }
                    if (GetConfigValue(out value, "GUI", "Authorization Check - Box - Refused Background"))
                    {
                        _configData.ui.refusedBackgroundColor = value == "1 0 0 0.8" ? "0.78 0.22 0.27 1" : value;
                    }
                    if (_configData.ui.removeBackgroundColor == "0.42 0.88 0.88 1")
                    {
                        _configData.ui.removeBackgroundColor = "0.31 0.88 0.71 1";
                    }
                    if (_configData.ui.entityBackgroundColor == "0 0 0 0.8")
                    {
                        _configData.ui.entityBackgroundColor = "0.82 0.58 0.30 1";
                    }
                }
                _configData.version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue != null)
            {
                if (configValue is T)
                {
                    value = (T)configValue;
                    return true;
                }
                try
                {
                    value = Config.ConvertValue<T>(configValue);
                    return true;
                }
                catch (Exception ex)
                {
                    PrintError($"GetConfigValue ERROR: path: {string.Join("\\", path)}\n{ex}");
                }
            }

            value = default(T);
            return false;
        }

        private void SetConfigValue(params object[] pathAndTrailingValue)
        {
            Config.Set(pathAndTrailingValue);
        }

        #region Preprocess Old Config

        private void PreprocessOldConfig()
        {
            var config = Config.ReadObject<JObject>();
            if (config == null)
            {
                return;
            }
            //Interface.Oxide.DataFileSystem.WriteObject(Name + "_old", jObject);
            VersionNumber oldVersion;
            if (GetConfigVersionPre(config, out oldVersion))
            {
                if (oldVersion < Version)
                {
                    //Fixed typos
                    if (oldVersion <= new VersionNumber(4, 3, 23))
                    {
                        foreach (RemoveType value in Enum.GetValues(typeof(RemoveType)))
                        {
                            if (value == RemoveType.None)
                            {
                                continue;
                            }
                            bool enabled;
                            if (GetConfigValuePre(config, out enabled, "Remove Type Settings", value.ToString(), "Reset the time after removing a entity"))
                            {
                                SetConfigValuePre(config, enabled, "Remove Type Settings", value.ToString(), "Reset the time after removing an entity");
                            }
                        }
                        Dictionary<string, object> values;
                        if (GetConfigValuePre(config, out values, "Permission Settings (Just for normal type)"))
                        {
                            foreach (var entry in values)
                            {
                                object value;
                                if (GetConfigValuePre(config, out value, "Permission Settings (Just for normal type)", entry.Key, "Reset the time after removing a entity"))
                                {
                                    SetConfigValuePre(config, value, "Permission Settings (Just for normal type)", entry.Key, "Reset the time after removing an entity");
                                }
                            }
                        }
                    }

                    if (oldVersion <= new VersionNumber(4, 3, 25))
                    {
                        bool enabled;
                        if (GetConfigValuePre(config, out enabled, "Remove Mode Settings (Only one model works)", "No Held Item Mode - Show Crosshair"))
                        {
                            SetConfigValuePre(config, enabled, "GUI", "Crosshair - Enabled");
                        }
                        object value;
                        if (GetConfigValuePre(config, out value, "Remove Mode Settings (Only one model works)", "No Held Item Mode - Crosshair Image Url"))
                        {
                            SetConfigValuePre(config, value, "GUI", "Crosshair - Image Url");
                        }
                        if (GetConfigValuePre(config, out value, "Remove Mode Settings (Only one model works)", "No Held Item Mode - Crosshair Box - Min Anchor (in Rust Window)"))
                        {
                            SetConfigValuePre(config, value, "GUI", "Crosshair - Box - Min Anchor (in Rust Window)");
                        }
                        if (GetConfigValuePre(config, out value, "Remove Mode Settings (Only one model works)", "No Held Item Mode - Crosshair Box - Max Anchor (in Rust Window)"))
                        {
                            SetConfigValuePre(config, value, "GUI", "Crosshair - Box - Max Anchor (in Rust Window)");
                        }
                        if (GetConfigValuePre(config, out value, "Remove Mode Settings (Only one model works)", "No Held Item Mode - Crosshair Box - Min Offset (in Rust Window)"))
                        {
                            SetConfigValuePre(config, value, "GUI", "Crosshair - Box - Min Offset (in Rust Window)");
                        }
                        if (GetConfigValuePre(config, out value, "Remove Mode Settings (Only one model works)", "No Held Item Mode - Crosshair Box - Max Offset (in Rust Window)"))
                        {
                            SetConfigValuePre(config, value, "GUI", "Crosshair - Box - Max Offset (in Rust Window)");
                        }
                        if (GetConfigValuePre(config, out value, "Remove Mode Settings (Only one model works)", "No Held Item Mode - Crosshair Box - Image Color"))
                        {
                            SetConfigValuePre(config, value, "GUI", "Crosshair - Box - Image Color");
                        }
                    }
                    if (oldVersion <= new VersionNumber(4, 3, 32))
                    {
                        try
                        {
                            var permissions = GetConfigValue(config, "Permission Settings (Just for normal type)");
                            if (permissions != null)
                            {
                                foreach (var perm in permissions)
                                {
                                    var maxRemovables = perm.Value.Value<int>("Max Removable Objects (0 = Unlimit)");
                                    perm.Value["Max Removable Objects (0 = Unlimited)"] = JToken.FromObject(maxRemovables);
                                }
                            }
                            var entities = GetConfigValue(config, "Remove Info (Refund & Price)", "Other Entity Settings");
                            if (entities != null)
                            {
                                foreach (var entity in entities)
                                {
                                    var price = entity.Value.Value<JObject>("Price");
                                    var priceDict = price?.ToObject<Dictionary<string, int>>();
                                    if (priceDict != null)
                                    {
                                        entity.Value["Price"] = JToken.FromObject(priceDict.ToDictionary(x => x.Key, y => new CurrencyInfo(y.Value)));
                                    }
                                    var refund = entity.Value.Value<JObject>("Refund");
                                    var refundDict = refund?.ToObject<Dictionary<string, int>>();
                                    if (refundDict != null)
                                    {
                                        entity.Value["Refund"] = JToken.FromObject(refundDict.ToDictionary(x => x.Key, y => new CurrencyInfo(y.Value)));
                                    }
                                }
                            }

                            var buildingBlocks = GetConfigValue(config, "Remove Info (Refund & Price)", "Building Blocks Settings");
                            if (buildingBlocks != null)
                            {
                                foreach (var item in buildingBlocks)
                                {
                                    var buildingGrades = item.Value.Value<JObject>("Building Grade");
                                    foreach (var buildingGrade in buildingGrades)
                                    {
                                        float percentage;
                                        var price = buildingGrade.Value.Value<object>("Price");
                                        if (price != null && !float.TryParse(price.ToString(), out percentage))
                                        {
                                            var target = buildingGrade.Value["Price"] as JObject;
                                            var dict = target?.ToObject<Dictionary<string, int>>();
                                            if (dict != null)
                                            {
                                                buildingGrade.Value["Price"] = JToken.FromObject(dict.ToDictionary(x => x.Key, y => new CurrencyInfo(y.Value)));
                                            }
                                        }
                                        var refund = buildingGrade.Value.Value<object>("Refund");
                                        if (refund != null && !float.TryParse(refund.ToString(), out percentage))
                                        {
                                            var target = buildingGrade.Value["Refund"] as JObject;
                                            var dict = target?.ToObject<Dictionary<string, int>>();
                                            if (dict != null)
                                            {
                                                buildingGrade.Value["Refund"] = JToken.FromObject(dict.ToDictionary(x => x.Key, y => new CurrencyInfo(y.Value)));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        catch
                        {
                            // ignored
                        }
                    }
                    Config.WriteObject(config);
                    // Interface.Oxide.DataFileSystem.WriteObject(Name + "_new", jObject);
                }
            }
        }

        private JObject GetConfigValue(JObject config, params string[] path)
        {
            if (path.Length < 1)
            {
                throw new ArgumentException("path is empty");
            }

            try
            {
                JToken jToken;
                if (!config.TryGetValue(path[0], out jToken))
                {
                    return null;
                }

                for (var i = 1; i < path.Length; i++)
                {
                    var jObject = jToken as JObject;
                    if (jObject == null || !jObject.TryGetValue(path[i], out jToken))
                    {
                        return null;
                    }
                }
                return jToken as JObject;
            }
            catch (Exception ex)
            {
                PrintError($"GetConfigValue ERROR: path: {string.Join("\\", path)}\n{ex}");
            }
            return null;
        }

        private bool GetConfigValuePre<T>(JObject config, out T value, params string[] path)
        {
            if (path.Length < 1)
            {
                throw new ArgumentException("path is empty");
            }

            try
            {
                JToken jToken;
                if (!config.TryGetValue(path[0], out jToken))
                {
                    value = default(T);
                    return false;
                }

                for (var i = 1; i < path.Length; i++)
                {
                    var jObject = jToken.ToObject<JObject>();
                    if (jObject == null || !jObject.TryGetValue(path[i], out jToken))
                    {
                        value = default(T);
                        return false;
                    }
                }
                value = jToken.ToObject<T>();
                return true;
            }
            catch (Exception ex)
            {
                PrintError($"GetConfigValuePre ERROR: path: {string.Join("\\", path)}\n{ex}");
            }
            value = default(T);
            return false;
        }

        private void SetConfigValuePre(JObject config, object value, params string[] path)
        {
            if (path.Length < 1)
            {
                throw new ArgumentException("path is empty");
            }

            try
            {
                JToken jToken;
                if (!config.TryGetValue(path[0], out jToken))
                {
                    if (path.Length == 1)
                    {
                        jToken = JToken.FromObject(value);
                        config.Add(path[0], jToken);
                        return;
                    }
                    jToken = new JObject();
                    config.Add(path[0], jToken);
                }

                for (var i = 1; i < path.Length - 1; i++)
                {
                    var jObject = jToken as JObject;
                    if (jObject == null || !jObject.TryGetValue(path[i], out jToken))
                    {
                        jToken = new JObject();
                        jObject?.Add(path[i], jToken);
                    }
                }
                var targetToken = jToken as JObject;
                if (targetToken != null)
                {
                    targetToken[path[path.Length - 1]] = JToken.FromObject(value);
                }
                // (jToken as JObject)?.TryAdd(path[path.Length - 1], JToken.FromObject(value));
            }
            catch (Exception ex)
            {
                PrintError($"SetConfigValuePre ERROR: value: {value} path: {string.Join("\\", path)}\n{ex}");
            }
        }

        private bool GetConfigVersionPre(JObject config, out VersionNumber version)
        {
            try
            {
                JToken jToken;
                if (config.TryGetValue("Version", out jToken))
                {
                    version = jToken.ToObject<VersionNumber>();
                    return true;
                }
            }
            catch
            {
                // ignored
            }
            version = default(VersionNumber);
            return false;
        }

        #endregion Preprocess Old Config

        #endregion ConfigurationFile

        #region LanguageFile

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, _configData.chat.prefix, _configData.chat.steamIDIcon);
        }

        private void Print(ConsoleSystem.Arg arg, string message)
        {
            //SendReply(arg, message);
            var player = arg.Player();
            if (player == null)
            {
                Puts(message);
            }
            else
            {
                PrintToConsole(player, message);
            }
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You don't have '{0}' permission to use this command.",
                ["TargetDisabled"] = "{0}'s Remover Tool has been disabled.",
                ["TargetEnabled"] = "{0} is now using Remover Tool; Enabled for {1} seconds (Max Removable Objects: {2}, Remove Type: {3}).",
                ["ToolDisabled"] = "Remover Tool has been disabled.",
                ["ToolEnabled"] = "Remover Tool enabled for {0} seconds (Max Removable Objects: {1}, Remove Type: {2}).",
                ["Cooldown"] = "You need to wait {0} seconds before using Remover Tool again.",
                ["CurrentlyDisabled"] = "Remover Tool is currently disabled.",
                ["EntityLimit"] = "Entity limit reached, you have removed {0} entities, Remover Tool was automatically disabled.",
                ["MeleeToolNotHeld"] = "You need to be holding a {0} in order to use the Remover Tool",
                ["SpecificToolNotHeld"] = "You need to be holding a {0} in order to use the Remover Tool.",

                ["StartRemoveAll"] = "Start running RemoveAll, please wait.",
                ["StartRemoveStructure"] = "Start running RemoveStructure, please wait.",
                ["StartRemoveExternal"] = "Start running RemoveExternal, please wait.",
                ["AlreadyRemoveAll"] = "There is already a RemoveAll running, please wait.",
                ["AlreadyRemoveStructure"] = "There is already a RemoveStructure running, please wait.",
                ["AlreadyRemoveExternal"] = "There is already a RemoveExternal running, please wait.",
                ["CompletedRemoveAll"] = "You've successfully removed {0} entities using RemoveAll.",
                ["CompletedRemoveStructure"] = "You've successfully removed {0} entities using RemoveStructure.",
                ["CompletedRemoveExternal"] = "You've successfully removed {0} entities using RemoveExternal.",

                ["CanRemove"] = "You can remove this entity.",
                ["NotEnoughCost"] = "Can't remove: You don't have enough resources.",
                ["EntityDisabled"] = "Can't remove: Server has disabled the entity from being removed.",
                ["DamagedEntity"] = "Can't remove: Server has disabled damaged objects from being removed.",
                ["BeBlocked"] = "Can't remove: An external plugin blocked the usage.",
                ["InvalidEntity"] = "Can't remove: No valid entity targeted.",
                ["NotFoundOrFar"] = "Can't remove: The entity is not found or too far away.",
                ["StorageNotEmpty"] = "Can't remove: The entity storage is not empty.",
                ["RaidBlocked"] = "Can't remove: Raid blocked.",
                ["CombatBlocked"] = "Can't remove: Combat blocked.",
                ["NotRemoveAccess"] = "Can't remove: You don't have any rights to remove this.",
                ["NotStructure"] = "Can't remove: The entity is not a structure.",
                ["NotExternalWall"] = "Can't remove: The entity is not an external wall.",
                ["EntityTimeLimit"] = "Can't remove: The entity was built more than {0} seconds ago.",
                //["Can'tOpenAllLocks"] = "Can't remove: There is a lock in the building that you cannot open.",
                ["CantPay"] = "Can't remove: Paying system crashed! Contact an administrator with the time and date to help him understand what happened.",
                //["UsageOfRemove"] = "You have to hold a hammer in your hand and press the left mouse button.",

                ["Refund"] = "Refund:",
                ["Nothing"] = "Nothing",
                ["Price"] = "Price:",
                ["Free"] = "Free",
                ["TimeLeft"] = "Timeleft: {0}s\nRemoved: {1}",
                ["RemoverToolType"] = "Remover Tool ({0})",
                ["Unlimit"] = "∞",

                ["SyntaxError"] = "Syntax error, please type '<color=#ce422b>/{0} <help | h></color>' to view help",
                ["Syntax"] = "<color=#ce422b>/{0} [time (seconds)]</color> - Enable RemoverTool ({1})",
                ["Syntax1"] = "<color=#ce422b>/{0} <admin | a> [time (seconds)]</color> - Enable RemoverTool ({1})",
                ["Syntax2"] = "<color=#ce422b>/{0} <all> [time (seconds)]</color> - Enable RemoverTool ({1})",
                ["Syntax3"] = "<color=#ce422b>/{0} <structure | s> [time (seconds)]</color> - Enable RemoverTool ({1})",
                ["Syntax4"] = "<color=#ce422b>/{0} <external | e> [time (seconds)]</color> - Enable RemoverTool ({1})"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "您没有 '{0}' 权限来使用该命令",
                ["TargetDisabled"] = "'{0}' 的拆除工具已禁用",
                ["TargetEnabled"] = "'{0}' 的拆除工具已启用 {1} 秒 (可拆除数: {2}, 拆除模式: {3}).",
                ["ToolDisabled"] = "您的拆除工具已禁用",
                ["ToolEnabled"] = "您的拆除工具已启用 {0} 秒 (可拆除数: {1}, 拆除模式: {2}).",
                ["Cooldown"] = "您需要等待 {0} 秒才可以再次使用拆除工具",
                ["CurrentlyDisabled"] = "服务器当前已禁用了拆除工具",
                ["EntityLimit"] = "您已经拆除了 '{0}' 个实体，拆除工具已自动禁用",
                ["MeleeToolNotHeld"] = "您必须拿着{0}才可以使用拆除工具",
                ["SpecificToolNotHeld"] = "您必须拿着{0}才可以使用拆除工具",

                ["StartRemoveAll"] = "开始运行 '所有拆除'，请稍等片刻",
                ["StartRemoveStructure"] = "开始运行 '建筑拆除'，请稍等片刻",
                ["StartRemoveExternal"] = "开始运行 '外墙拆除'，请稍等片刻",
                ["AlreadyRemoveAll"] = "已经有一个 '所有拆除' 正在运行，请稍等片刻",
                ["AlreadyRemoveStructure"] = "已经有一个 '建筑拆除' 正在运行，请稍等片刻",
                ["AlreadyRemoveExternal"] = "已经有一个 '外墙拆除' 正在运行，请稍等片刻",
                ["CompletedRemoveAll"] = "您使用 '所有拆除' 成功拆除了 {0} 个实体",
                ["CompletedRemoveStructure"] = "您使用 '建筑拆除' 成功拆除了 {0} 个实体",
                ["CompletedRemoveExternal"] = "您使用 '外墙拆除' 成功拆除了 {0} 个实体",

                ["CanRemove"] = "您可以拆除该实体",
                ["NotEnoughCost"] = "无法拆除: 拆除所需资源不足",
                ["EntityDisabled"] = "无法拆除: 服务器已禁用拆除这种实体",
                ["DamagedEntity"] = "无法拆除: 服务器已禁用拆除已损坏的实体",
                ["BeBlocked"] = "无法拆除: 其他插件阻止您拆除该实体",
                ["InvalidEntity"] = "无法拆除: 无效的实体",
                ["NotFoundOrFar"] = "无法拆除: 没有找到实体或者距离太远",
                ["StorageNotEmpty"] = "无法拆除: 该实体内含有物品",
                ["RaidBlocked"] = "无法拆除: 拆除工具被突袭阻止了",
                ["CombatBlocked"] = "无法拆除: 拆除工具被战斗阻止了",
                ["NotRemoveAccess"] = "无法拆除: 您无权拆除该实体",
                ["NotStructure"] = "无法拆除: 该实体不是建筑物",
                ["NotExternalWall"] = "无法拆除: 该实体不是外高墙",
                ["EntityTimeLimit"] = "无法拆除: 该实体的存活时间大于 {0} 秒",
                //["Can'tOpenAllLocks"] = "无法拆除: 该建筑中有您无法打开的锁",
                ["CantPay"] = "无法拆除: 支付失败，请联系管理员，告诉他详情",

                ["Refund"] = "退还:",
                ["Nothing"] = "没有",
                ["Price"] = "价格:",
                ["Free"] = "免费",
                ["TimeLeft"] = "剩余时间: {0}s\n已拆除数: {1} ",
                ["RemoverToolType"] = "拆除工具 ({0})",
                ["Unlimit"] = "∞",

                ["SyntaxError"] = "语法错误，输入 '<color=#ce422b>/{0} <help | h></color>' 查看帮助",
                ["Syntax"] = "<color=#ce422b>/{0} [time (seconds)]</color> - 启用拆除工具 ({1})",
                ["Syntax1"] = "<color=#ce422b>/{0} <admin | a> [time (seconds)]</color> - 启用拆除工具 ({1})",
                ["Syntax2"] = "<color=#ce422b>/{0} <all> [time (seconds)]</color> - 启用拆除工具 ({1})",
                ["Syntax3"] = "<color=#ce422b>/{0} <structure | s> [time (seconds)]</color> - 启用拆除工具 ({1})",
                ["Syntax4"] = "<color=#ce422b>/{0} <external | e> [time (seconds)]</color> - 启用拆除工具 ({1})"
            }, this, "zh-CN");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "У вас нет разрешения '{0}' чтобы использовать эту команду.",
                ["TargetDisabled"] = "{0}'s Remover Tool отключен.",
                ["TargetEnabled"] = "{0} теперь использует Remover Tool; Включено на {1} секунд (Макс. объектов для удаления: {2}, Тип удаления: {3}).",
                ["ToolDisabled"] = "Remover Tool отключен.",
                ["ToolEnabled"] = "Remover Tool включен на {0} секунд (Макс. объектов для удаления: {1}, Тип удаления: {2}).",
                ["Cooldown"] = "Необходимо подождать {0} секунд, прежде чем использовать Remover Tool снова.",
                ["CurrentlyDisabled"] = "Remover Tool в данный момент отключен.",
                ["EntityLimit"] = "Достигнут предел, удалено {0} объектов, Remover Tool автоматически отключен.",
                ["MeleeToolNotHeld"] = "Вы должны держать {0}, чтобы использовать инструмент для удаления.",
                ["SpecificToolNotHeld"] = "Вы должны держать {0}, чтобы использовать инструмент для удаления.",

                ["StartRemoveAll"] = "Запускается RemoveAll, пожалуйста, подождите.",
                ["StartRemoveStructure"] = "Запускается RemoveStructure, пожалуйста, подождите.",
                ["StartRemoveExternal"] = "Запускается RemoveExternal, пожалуйста, подождите.",
                ["AlreadyRemoveAll"] = "RemoveAll уже выполняется, пожалуйста, подождите.",
                ["AlreadyRemoveStructure"] = "RemoveStructure уже выполняется, пожалуйста, подождите.",
                ["AlreadyRemoveExternal"] = "RemoveExternal уже выполняется, пожалуйста, подождите.",
                ["CompletedRemoveAll"] = "Вы успешно удалили {0} объектов используя RemoveAll.",
                ["CompletedRemoveStructure"] = "Вы успешно удалили {0} объектов используя RemoveStructure.",
                ["CompletedRemoveExternal"] = "Вы успешно удалили {0} объектов используя RemoveExternal.",

                ["CanRemove"] = "Вы можете удалить этот объект.",
                ["NotEnoughCost"] = "Нельзя удалить: У вас не достаточно ресурсов.",
                ["EntityDisabled"] = "Нельзя удалить: Сервер отключил возможность удаления этого объекта.",
                ["DamagedEntity"] = "Нельзя удалить: Сервер отключил возможность удалять повреждённые объекты.",
                ["BeBlocked"] = "Нельзя удалить: Внешний plugin блокирует использование.",
                ["InvalidEntity"] = "Нельзя удалить: Неверный объект.",
                ["NotFoundOrFar"] = "Нельзя удалить: Объект не найден, либо слишком далеко.",
                ["StorageNotEmpty"] = "Нельзя удалить: Хранилище объекта не пусто.",
                ["RaidBlocked"] = "Нельзя удалить: Рейды остановки.",
                ["CombatBlocked"] = "Нельзя удалить: боевые остановки",
                ["NotRemoveAccess"] = "Нельзя удалить: У вас нет прав удалять это.",
                ["NotStructure"] = "Нельзя удалить: Объект не конструкция.",
                ["NotExternalWall"] = "Нельзя удалить: Объект не внешняя стена.",
                ["EntityTimeLimit"] = "Нельзя удалить: Объект был построен более {0} секунд назад.",
                //["Can'tOpenAllLocks"] = "Нельзя удалить: в здании есть замок, который вы не можете открыть",
                ["CantPay"] = "Нельзя удалить: Система оплаты дала сбой! Свяжитесь с админом указав дату и время, чтобы помочь ему понять что случилось.",

                ["Refund"] = "Возврат:",
                ["Nothing"] = "Ничего",
                ["Price"] = "Цена:",
                ["Free"] = "Бесплатно",
                ["TimeLeft"] = "Осталось времени: {0}s\nУдалено: {1}",
                ["RemoverToolType"] = "Remover Tool ({0})",
                ["Unlimit"] = "∞",

                ["SyntaxError"] = "Синтаксическая ошибка! Пожалуйста, введите '<color=#ce422b>/{0} <help | h></color>' для отображения помощи",
                ["Syntax"] = "<color=#ce422b>/{0} [время (секунд)]</color> - Включить RemoverTool ({1})",
                ["Syntax1"] = "<color=#ce422b>/{0} <admin | a> [время (секунд)]</color> - Включить RemoverTool ({1})",
                ["Syntax2"] = "<color=#ce422b>/{0} <all> [время (секунд)]</color> - Включить RemoverTool ({1})",
                ["Syntax3"] = "<color=#ce422b>/{0} <structure | s> [время (секунд)]</color> - Включить RemoverTool ({1})",
                ["Syntax4"] = "<color=#ce422b>/{0} <external | e> [время (секунд)]</color> - Включить RemoverTool ({1})"
            }, this, "ru");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "No tienes permiso '{0}' para usar este comando.",
                ["TargetDisabled"] = "La herramienta de eliminación de {0} ha sido desactivada.",
                ["TargetEnabled"] = "{0} ahora está usando la herramienta de eliminación; habilitada durante {1} segundos (Máximo de objetos removibles: {2}, Tipo de eliminación: {3}).",
                ["ToolDisabled"] = "La herramienta de eliminación ha sido desactivada.",
                ["ToolEnabled"] = "Herramienta de eliminación habilitada durante {0} segundos (Máximo de objetos removibles: {1}, Tipo de eliminación: {2}).",
                ["Cooldown"] = "Debes esperar {0} segundos antes de usar la herramienta de eliminación nuevamente.",
                ["CurrentlyDisabled"] = "La herramienta de eliminación está actualmente desactivada.",
                ["EntityLimit"] = "Límite de entidades alcanzado, has eliminado {0} entidades, la herramienta de eliminación se ha desactivado automáticamente.",
                ["MeleeToolNotHeld"] = "Debes estar sosteniendo un(a) {0} para usar la herramienta de eliminación",
                ["SpecificToolNotHeld"] = "Debes estar sosteniendo un(a) {0} para usar la herramienta de eliminación.",

                ["StartRemoveAll"] = "Iniciando eliminación total, por favor espera.",
                ["StartRemoveStructure"] = "Iniciando eliminación de estructura, por favor espera.",
                ["StartRemoveExternal"] = "Iniciando eliminación de externos, por favor espera.",
                ["AlreadyRemoveAll"] = "Ya hay una eliminación total en curso, por favor espera.",
                ["AlreadyRemoveStructure"] = "Ya hay una eliminación de estructura en curso, por favor espera.",
                ["AlreadyRemoveExternal"] = "Ya hay una eliminación de externos en curso, por favor espera.",
                ["CompletedRemoveAll"] = "Has eliminado exitosamente {0} entidades utilizando la eliminación total.",
                ["CompletedRemoveStructure"] = "Has eliminado exitosamente {0} entidades utilizando la eliminación de estructura.",
                ["CompletedRemoveExternal"] = "Has eliminado exitosamente {0} entidades utilizando la eliminación de externos.",

                ["CanRemove"] = "Puedes eliminar esta entidad.",
                ["NotEnoughCost"] = "No se puede eliminar: no tienes suficientes recursos.",
                ["EntityDisabled"] = "No se puede eliminar: el servidor ha desactivado la eliminación de esta entidad.",
                ["DamagedEntity"] = "No se puede eliminar: el servidor ha desactivado la eliminación de objetos dañados.",
                ["BeBlocked"] = "No se puede eliminar: un complemento externo bloqueó su uso.",
                ["InvalidEntity"] = "No se puede eliminar: no se ha seleccionado una entidad válida.",
                ["NotFoundOrFar"] = "No se puede eliminar: la entidad no se encuentra o está demasiado lejos.",
                ["StorageNotEmpty"] = "No se puede eliminar: el almacenamiento de la entidad no está vacío.",
                ["RaidBlocked"] = "No se puede eliminar: bloqueado durante un asalto.",
                ["CombatBlocked"] = "No se puede eliminar: bloqueado durante el combate.",
                ["NotRemoveAccess"] = "No se puede eliminar: no tienes permisos para eliminar esto.",
                ["NotStructure"] = "No se puede eliminar: la entidad no es una estructura.",
                ["NotExternalWall"] = "No se puede eliminar: la entidad no es una pared externa.",
                ["EntityTimeLimit"] = "No se puede eliminar: la entidad fue construida hace más de {0} segundos.",
                //["Can'tOpenAllLocks"] = "No se puede eliminar: hay una cerradura en el edificio que no puedes abrir.",
                ["CantPay"] = "No se puede eliminar: ¡el sistema de pago ha fallado! Contacta a un administrador con la fecha y hora para ayudarlo a entender lo que sucedió.",
                //["UsageOfRemove"] = "Debes sostener un martillo en tu mano y presionar el botón izquierdo del mouse.",

                ["Refund"] = "Reembolso:",
                ["Nothing"] = "Nada",
                ["Price"] = "Precio:",
                ["Free"] = "Gratis",
                ["TimeLeft"] = "Tiempo restante: {0}s\nEliminado: {1}",
                ["RemoverToolType"] = "Herramienta de eliminación ({0})",
                ["Unlimit"] = "∞",

                ["SyntaxError"] = "Error de sintaxis, por favor escribe '<color=#ce422b>/{0} <ayuda | h></color>' para ver la ayuda",
                ["Syntax"] = "<color=#ce422b>/{0} [tiempo (segundos)]</color> - Habilitar la herramienta de eliminación ({1})",
                ["Syntax1"] = "<color=#ce422b>/{0} <admin | a> [tiempo (segundos)]</color> - Habilitar la herramienta de eliminación ({1})",
                ["Syntax2"] = "<color=#ce422b>/{0} <todos> [tiempo (segundos)]</color> - Habilitar la herramienta de eliminación ({1})",
                ["Syntax3"] = "<color=#ce422b>/{0} <estructura | s> [tiempo (segundos)]</color> - Habilitar la herramienta de eliminación ({1})",
                ["Syntax4"] = "<color=#ce422b>/{0} <externo | e> [tiempo (segundos)]</color> - Habilitar la herramienta de eliminación ({1})"
            }, this, "es");
        }

        #endregion LanguageFile
    }
}

// --- End of file: RemoverTool.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/realistic-explosions ---
// --- Original File Path: R/RealisticExplosions/RealisticExplosions.cs ---

using System;
using System.Collections.Generic;

using Facepunch;

using JetBrains.Annotations;

using Newtonsoft.Json;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Realistic Explosions", "2CHEVSKII", "1.0.0")]
    [Description("Pushes back dropped items when they are near the explosion")]
    class RealisticExplosions : CovalencePlugin
    {
        static RealisticExplosions Instance;
        PluginSettings             settings;

        #region Oxide hooks

        void Init()
        {
            Instance = this;
            RealisticExplosion.Init();
        }

        void Unload()
        {
            RealisticExplosion.Shutdown();
            Instance = null;
        }

        void OnExplosiveDropped(BasePlayer player, BaseEntity entity)
        {
            entity.gameObject.AddComponent<RealisticExplosion>();
        }

        void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            entity.gameObject.AddComponent<RealisticExplosion>();
        }

        void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            entity.gameObject.AddComponent<RealisticExplosion>();
        }

        #endregion

        #region Configuration load

        protected override void LoadDefaultConfig()
        {
            settings = PluginSettings.Default;

            SaveConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                settings = Config.ReadObject<PluginSettings>();

                if (settings == null)
                {
                    throw new Exception("Configuration is null");
                }
            }
            catch (Exception e)
            {
                LogError("Could not read configuration file:\n{0}", e.Message);
                LogWarning("Default configuration will be loaded");

                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(settings);
        }

        #endregion

        [UsedImplicitly]
        class RealisticExplosion : MonoBehaviour
        {
            static List<DroppedItem> ItemList;
            static List<BaseCorpse>  CorpseList;

            BaseEntity     entity;
            PluginSettings settings;

            public static void Init()
            {
                ItemList = Pool.GetList<DroppedItem>();
                CorpseList = Pool.GetList<BaseCorpse>();
            }

            public static void Shutdown()
            {
                Pool.Free(ref ItemList);
                Pool.Free(ref CorpseList);
            }

            void Awake()
            {
                settings = Instance.settings;
                entity = GetComponent<BaseEntity>();
            }

            void OnDestroy()
            {
                CollectItems();
                CollectCorpses();

                IterateEntities();

                Cleanup();
            }

            void IterateEntities()
            {
                for (var i = 0; i < ItemList.Count; i++)
                {
                    DroppedItem item = ItemList[i];

                    if (settings.CheckVisibility && !IsVisible(item))
                    {
                        continue;
                    }

                    Rigidbody rb = item.GetComponent<Rigidbody>();

                    ApplyForce(rb);
                }

                for (var i = 0; i < CorpseList.Count; i++)
                {
                    BaseCorpse corpse = CorpseList[i];

                    if (settings.CheckVisibility && !IsVisible(corpse))
                    {
                        continue;
                    }

                    Rigidbody rb = corpse.GetComponent<Rigidbody>();

                    ApplyForce(rb, true);
                }
            }

            void Cleanup()
            {
                ItemList.Clear();
                CorpseList.Clear();
            }

            void CollectItems()
            {
                if (!settings.AffectDroppedItems)
                {
                    return;
                }

                Vis.Entities(entity.transform.position, settings.ExplosionRadius, ItemList);
            }

            void CollectCorpses()
            {
                if (!settings.AffectRagdolls)
                {
                    return;
                }

                Vis.Entities(entity.transform.position, settings.ExplosionRadius, CorpseList);
            }

            void ApplyForce(Rigidbody rigidbody, bool isCorpse = false)
            {
                rigidbody.AddExplosionForce(
                    isCorpse ? settings.ExplosionForce * 5f : settings.ExplosionForce,
                    entity.transform.position,
                    settings.ExplosionRadius
                );
            }

            bool IsVisible(BaseEntity baseEntity)
            {
                return !settings.CheckVisibility || baseEntity.IsVisible(entity.transform.position + new Vector3(0, 0.5f));
            }
        }

        class PluginSettings
        {
            public static PluginSettings Default =>
                new PluginSettings {
                    ExplosionRadius = 15f,
                    ExplosionForce = 500f,
                    CheckVisibility = false,
                    AffectDroppedItems = true,
                    AffectRagdolls = true
                };

            [JsonProperty("Explosion force")]
            public float ExplosionForce { get; set; }
            [JsonProperty("Explosion radius")]
            public float ExplosionRadius { get; set; }
            [JsonProperty("Check visibility from explosion to object (less performant)")]
            public bool CheckVisibility { get; set; }
            [JsonProperty("Affect ragdolls")]
            public bool AffectRagdolls { get; set; }
            [JsonProperty("Affect dropped items")]
            public bool AffectDroppedItems { get; set; }
        }
    }
}


// --- End of file: RealisticExplosions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/respawner ---
// --- Original File Path: R/Respawner/Respawner.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
#if RUST
using UnityEngine;
#endif

namespace Oxide.Plugins
{
    [Info("Respawner", "Wulf/lukespragg", "1.0.3")]
    [Description("Automatically respawns players with permission and optionally wakes them up")]
    public class Respawner : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Automatically wake up (true/false)")]
            public bool AutoWakeUp;

            /*[JsonProperty(PropertyName = "Respawn at custom location (true/false)")]
            public bool CustomLocation;*/

            [JsonProperty(PropertyName = "Respawn at same location (true/false)")]
            public bool SameLocation;

            //[JsonProperty(PropertyName = "Show chat respawned messages (true/false)")]
            //public bool ShowMessages;

#if RUST
            [JsonProperty(PropertyName = "Use sleeping bags if available (true/false)")]
            public bool SleepingBags;
#endif

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    AutoWakeUp = true,
                    //CustomLocation = false,
                    SameLocation = true,
                    //ShowMessages = true,
#if RUST
                    SleepingBags = true
#endif
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.AutoWakeUp == null) LoadDefaultConfig();
            }
            catch
            {
                LogWarning($"Could not read oxide/config/{Name}.json, creating new config file");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = Configuration.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Localization

        /*private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AtLocation"] = "You've respawned at {0}",
                ["AtSameLocation"] = "You've respawned at the same location",
                ["AtSleepingBag"] = "You've respawned at your sleeping bag"
            }, this);
        }*/

        #endregion Localization

        #region Initialization

        private System.Random random = new System.Random();

        private const string permUse = "respawner.use";

        private void Init() => permission.RegisterPermission(permUse, this);

        #endregion Initialization

        #region Respawn Handling

#if RUST
        private BasePlayer.SpawnPoint FindSpawnPoint(BasePlayer basePlayer)
        {
            var player = basePlayer.IPlayer;
            var spawnPoint = new BasePlayer.SpawnPoint();
            var bags = FindSleepingBags(basePlayer);
            #if DEBUG
            LogWarning($"# of sleeping bags for {player.Name}: {bags.Length}");
            #endif

            if (config.SleepingBags && bags.Length >= 1)
            {
                var bag = bags[random.Next(0, bags.Length - 1)];
                # if DEBUG
                LogWarning($"Original location for {player.Name}: {player.Position()}");
                LogWarning($"Target location for {player.Name}: {bag.transform.position}");
                #endif
                var pos = bag.transform.position;
                spawnPoint.pos = new Vector3(pos.x, pos.y + 0.3f, pos.z);
                spawnPoint.rot = bag.transform.rotation;
            }
            else if (config.SameLocation)
            {
                var pos = basePlayer.transform.position;
                spawnPoint.pos = new Vector3(pos.x, pos.y + 0.3f, pos.z);
                spawnPoint.rot = basePlayer.transform.rotation;
            }
            /*else if (config.CustomLocation)
            {
                // TODO: Implement custom spawn location(s) (universal)
            }*/

            return spawnPoint;
        }

        private void OnEntityDeath(BaseEntity entity)
        {
            var basePlayer = entity.ToPlayer();
            if (basePlayer == null || !permission.UserHasPermission(basePlayer.UserIDString, permUse)) return;

            NextTick(() => { if (basePlayer.IsDead() && basePlayer.IsConnected) basePlayer.Respawn(); });
        }

        private BasePlayer.SpawnPoint OnPlayerRespawn(BasePlayer basePlayer) => FindSpawnPoint(basePlayer);

        private void OnPlayerRespawned(BasePlayer basePlayer)
        {
            if (permission.UserHasPermission(basePlayer.UserIDString, permUse) && basePlayer.IsSleeping()) basePlayer.EndSleeping();
        }
#else
        private void OnUserRespawned(IPlayer player)
        {
            //player.Teleport(); // TODO: Support for other games
        }
#endif

        #endregion Respawn Handling

        #region Helpers

        //private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

#if RUST
        private SleepingBag[] FindSleepingBags(BasePlayer basePlayer)
        {
            var bags = SleepingBag.FindForPlayer(basePlayer.userID, true);
            return bags.Where((SleepingBag b) => b.deployerUserID == basePlayer.userID).ToArray();
        }
#endif

        #endregion Helpers
    }
}


// --- End of file: Respawner.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/realistic-torches ---
// --- Original File Path: R/RealisticTorch/RealisticTorch.cs ---

﻿using Rust;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Realistic Torch", "Synvy", "1.1.1")]
    [Description("Prevents cold damage to players holding a lit torch.")]
    public class RealisticTorch : RustPlugin
    {
        #region Initialize

        private const string _perm = "realistictorch.use";

        private void Init()
        {
            permission.RegisterPermission(_perm, this);
        }

        #endregion Initialize

        #region Hooks

        private void OnRunPlayerMetabolism(PlayerMetabolism metabolism, BaseCombatEntity entity)
        {
            var player = entity as BasePlayer;

            if (entity is BasePlayer && entity != null)
            {
                if (HasPerm(player.UserIDString, _perm) && IsHoldingTorch(player) && IsTorchIgnited(player))
                {
                    if (player.metabolism.temperature.value < 26)
                    {
                        player.metabolism.temperature.value = 26;
                    }
                }
            }
        }

        #endregion Hooks

        #region Helpers

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private bool IsHoldingTorch(BasePlayer player)
        {
            var heldItem = player.GetActiveItem()?.info.shortname ?? "null";
            return heldItem == "torch" || heldItem == "torch.torch.skull";
        }

        private bool IsTorchIgnited(BasePlayer player)
        {
            HeldEntity heldEntity = player.GetHeldEntity();

            if (heldEntity != null)
            {
                return heldEntity.HasFlag(BaseEntity.Flags.On);
            }

            return false;
        }

        #endregion Helpers
    }
}

// --- End of file: RealisticTorch.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rust-notifications ---
// --- Original File Path: R/RustNotifications/RustNotifications.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Rust Notifications", "seanbyrne88", "0.9.3")]
    [Description("Configurable Notifications for Rust Events")]
    class RustNotifications : RustPlugin
    {
        [PluginReference]
        Plugin Discord, Slack;

        private static NotificationConfigContainer Settings;

        private List<NotificationCooldown> UserLastNotified;

        private string SlackMethodName;
        private string DiscordMethodName;

        #region oxide methods
        void Init()
        {
            LoadConfigValues();
        }

        void OnPlayerInit(BasePlayer player)
        {
            SendPlayerConnectNotification(player);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            SendPlayerDisconnectNotification(player, reason);
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || info.Initiator == null || info.WeaponPrefab == null || info.InitiatorPlayer == null)
            {
                return;
            }

            BasePlayer player = info.InitiatorPlayer;

            ulong hitEntityOwnerID = entity.OwnerID != 0 ? entity.OwnerID : info.HitEntity?.OwnerID ?? 0;

            if (hitEntityOwnerID == 0)
            {
                return;
            }

            string MessageText = lang.GetMessage("BaseAttackedMessageTemplate", this, player.UserIDString)
                                                        .Replace("{Attacker}", player.displayName)
                                                        .Replace("{Owner}", GetDisplayNameByID(hitEntityOwnerID))
                                                        .Replace("{Weapon}", info.WeaponPrefab.ShortPrefabName.Replace(".entity", ""))
                                                        .Replace("{Structure}", entity.ShortPrefabName.Replace(".entity", ""))
                                                        .Replace("{Damage}", Math.Round(info.damageTypes.Total(), 2).ToString());

            //get structure's percentage health remaining for check against threshold
            int PercentHealthRemaining = (int)((entity.Health() / entity.MaxHealth()) * 100);

            if (IsPlayerActive(hitEntityOwnerID) && IsPlayerNotificationCooledDown(hitEntityOwnerID, NotificationType.ServerNotification, Settings.ServerConfig.NotificationCooldownInSeconds))
            {
                if (PercentHealthRemaining <= Settings.ServerConfig.ThresholdPercentageHealthRemaining)
                {
                    BasePlayer p = BasePlayer.FindByID(hitEntityOwnerID);
                    PrintToChat(p, MessageText);
                }
            }
            //Slack
            if (Settings.SlackConfig.DoNotifyWhenBaseAttacked && IsPlayerNotificationCooledDown(hitEntityOwnerID, NotificationType.SlackNotification, Settings.SlackConfig.NotificationCooldownInSeconds))
            {
                if (PercentHealthRemaining <= Settings.SlackConfig.ThresholdPercentageHealthRemaining)
                {
                    SendSlackNotification(player, MessageText);
                }
            }
            //Discord
            if (Settings.DiscordConfig.DoNotifyWhenBaseAttacked && IsPlayerNotificationCooledDown(hitEntityOwnerID, NotificationType.DiscordNotification, Settings.DiscordConfig.NotificationCooldownInSeconds))
            {
                if (PercentHealthRemaining <= Settings.DiscordConfig.ThresholdPercentageHealthRemaining)
                {
                    SendDiscordNotification(player, MessageText);
                }
            }
        }

        #endregion

        #region chat commands
        [ChatCommand("rustNotifyResetConfig")]
        void CommandResetConfig(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin)
            {
                LoadDefaultConfig();
                LoadDefaultMessages();
                LoadConfigValues();
            }
            else
            {
                SendReply(player, lang.GetMessage("CommandReplyNotAdmin", this, player.UserIDString));
            }
        }

        [ChatCommand("rustNotifyResetMessages")]
        void CommandResetMessages(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin)
            {
                LoadDefaultMessages();
            }
            else
            {
                SendReply(player, lang.GetMessage("CommandReplyNotAdmin", this, player.UserIDString));
            }
        }

        //args[0] = Slack|Discord|Server|All, args[1] Value (Between 0 and 100)
        [ChatCommand("rustNotifySetHealthThreshold")]
        void CommandSetHealthThreshold(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin)
            {
                if (args.Length == 2)
                {
                    int ThresholdPercentageHealthRemaining = int.Parse(args[1]);

                    if (args[0] == "All")
                    {
                        Settings.ServerConfig.ThresholdPercentageHealthRemaining = ThresholdPercentageHealthRemaining;
                        Settings.DiscordConfig.ThresholdPercentageHealthRemaining = ThresholdPercentageHealthRemaining;
                        Settings.SlackConfig.ThresholdPercentageHealthRemaining = ThresholdPercentageHealthRemaining;
                    }
                    else if (args[0] == "Server")
                    {
                        Settings.ServerConfig.ThresholdPercentageHealthRemaining = ThresholdPercentageHealthRemaining;
                    }
                    else if (args[0] == "Discord")
                    {
                        Settings.DiscordConfig.ThresholdPercentageHealthRemaining = ThresholdPercentageHealthRemaining;
                    }
                    else if (args[0] == "Slack")
                    {
                        Settings.SlackConfig.ThresholdPercentageHealthRemaining = ThresholdPercentageHealthRemaining;
                    }

                    //save config
                    Config.WriteObject<NotificationConfigContainer>(Settings);

                    SendReply(player, lang.GetMessage("CommandReplyThresholdHealthSet", this, player.UserIDString).Replace("{Value}", ThresholdPercentageHealthRemaining.ToString()));
                }
                else
                {
                    SendReply(player, lang.GetMessage("CommandReplyThresholdHealthInvalidArgs", this, player.UserIDString));
                }
            }
            else
            {
                SendReply(player, lang.GetMessage("CommandReplyNotAdmin", this, player.UserIDString));
            }
        }

        #endregion

        #region private methods

        private string BuildConnectMessage(string PlayerUserIDString, string PlayerDisplayName)
        {
            return lang.GetMessage("PlayerConnectedMessageTemplate", this, PlayerUserIDString).Replace("{DisplayName}", PlayerDisplayName);
        }

        private string BuildDisconnectMessage(string PlayerUserIDString, string PlayerDisplayName, string Reason)
        {
            return lang.GetMessage("PlayerDisconnectedMessageTemplate", this, PlayerUserIDString).Replace("{DisplayName}", PlayerDisplayName).Replace("{Reason}", Reason);
        }

        private string GetDisplayNameByID(ulong UserID)
        {
            BasePlayer player = BasePlayer.FindAwakeOrSleeping(UserID.ToString());
            if (player == null)
            {
                PrintWarning($"Tried to find player with ID {UserID}, but they weren't in active or sleeping player list");
                return "Unknown";
            }

            return player.displayName;
        }

        private bool IsPlayerActive(ulong UserID)
        {
            if (BasePlayer.FindByID(UserID) != null)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        private bool IsPlayerNotificationCooledDown(ulong UserID, NotificationType NotificationType, int CooldownInSeconds)
        {
            if (UserLastNotified.Exists(x => x.NotificationType == NotificationType && x.PlayerID == UserID))
            {
                //check notification time per user, per notificationType, if it's cooled down send a message
                DateTime LastNotificationTime = UserLastNotified.Find(x => x.NotificationType == NotificationType && x.PlayerID == UserID).LastNotifiedAt;
                if ((DateTime.Now - LastNotificationTime).TotalSeconds > CooldownInSeconds)
                {
                    UserLastNotified.Find(x => x.NotificationType == NotificationType && x.PlayerID == UserID).LastNotifiedAt = DateTime.Now;
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                UserLastNotified.Add(new NotificationCooldown() { PlayerID = UserID, NotificationType = NotificationType, LastNotifiedAt = DateTime.Now });
                return true;
            }
        }
        #endregion

        #region notifications
        private void SendSlackNotification(BasePlayer player, string MessageText)
        {
            if (Settings.SlackConfig.Active)
            {
                Slack?.Call(SlackMethodName, MessageText, BasePlayerToIPlayer(player));
            }
        }

        private void SendDiscordNotification(BasePlayer player, string MessageText)
        {
            if (Settings.DiscordConfig.Active)
            {
                Discord?.Call(DiscordMethodName, MessageText);
            }
        }

        private IPlayer BasePlayerToIPlayer(BasePlayer player)
        {
            return covalence.Players.FindPlayerById(player.UserIDString);
        }

        private void SendPlayerConnectNotification(BasePlayer player)
        {
            string MessageText = BuildConnectMessage(player.UserIDString, player.displayName);

            if (Settings.SlackConfig.DoNotifyWhenPlayerConnects)
            {
                SendSlackNotification(player, MessageText);
            }

            if (Settings.DiscordConfig.DoNotifyWhenPlayerConnects)
            {
                SendDiscordNotification(player, MessageText);
            }
        }

        private void SendPlayerDisconnectNotification(BasePlayer player, string reason)
        {
            string MessageText = BuildDisconnectMessage(player.UserIDString, player.displayName, reason);

            if (Settings.SlackConfig.DoNotifyWhenPlayerDisconnects)
            {
                SendSlackNotification(player, MessageText);
            }

            if (Settings.DiscordConfig.DoNotifyWhenPlayerDisconnects)
            {
                SendDiscordNotification(player, MessageText);
            }
        }
        #endregion notifications

        #region localization
        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
                {
                    {"PlayerConnectedMessageTemplate", "{DisplayName} has joined the server"},
                    {"PlayerDisconnectedMessageTemplate", "{DisplayName} has left the server, reason: {Reason}"},
                    {"BaseAttackedMessageTemplate", "{Attacker} has attacked a structure built by {Owner}"},
                    {"CommandReplyNotAdmin", "Must be admin to use server commands" },
                    {"CommandReplyThresholdHealthSet", "Health Threshold has been set to {Value}" },
                    {"CommandReplyThresholdHealthInvalidArgs", "Error, Usage: \"rustNotifyThresholdHealthSet <type:All|Server|Discord|Slack> <value:Between 0 & 100>" },
                    {"TestMessage", "Hello World"}
                }, this);
        }
        #endregion

        #region config
        NotificationConfigContainer DefaultConfigContainer()
        {
            return new NotificationConfigContainer
            {
                ServerConfig = DefaultServerNotificationConfig(),
                SlackConfig = DefaultClientNotificationConfig(),
                DiscordConfig = DefaultClientNotificationConfig()
            };
        }

        ServerNotificationConfig DefaultServerNotificationConfig()
        {
            return new ServerNotificationConfig
            {
                Active = true,
                DoNotifyWhenBaseAttacked = true,
                NotificationCooldownInSeconds = 60,
                //ThresholdDamageInflicted = 0, //default to 0 so it sends after every hit.
                ThresholdPercentageHealthRemaining = 100 //default to 100 so it sends after every hit
            };
        }

        ClientNotificationConfig DefaultClientNotificationConfig()
        {
            return new ClientNotificationConfig
            {
                DoLinkSteamProfile = true,
                Active = false,
                DoNotifyWhenPlayerConnects = true,
                DoNotifyWhenPlayerDisconnects = true,
                DoNotifyWhenBaseAttacked = true,
                NotificationCooldownInSeconds = 60
            };
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config.WriteObject(DefaultConfigContainer(), true);

            PrintWarning("Default Configuration File Created");
            LoadDefaultMessages();
            PrintWarning("Default Language File Created");

            UserLastNotified = new List<NotificationCooldown>();
        }

        protected void LoadConfigValues()
        {
            Settings = Config.ReadObject<NotificationConfigContainer>();

            UserLastNotified = new List<NotificationCooldown>();

            if (Settings.SlackConfig.DoLinkSteamProfile)
                SlackMethodName = "FancyMessage";
            else
                SlackMethodName = "SimpleMessage";

            DiscordMethodName = "SendMessage";

            //Config.WriteObject<NotificationConfigContainer>(Settings);
        }
        #endregion

        #region classes
        private class ServerNotificationConfig
        {
            public bool Active { get; set; }
            public bool DoNotifyWhenBaseAttacked { get; set; }
            public int NotificationCooldownInSeconds { get; set; }
            //public int ThresholdDamageInflicted { get; set; }
            public int ThresholdPercentageHealthRemaining { get; set; }
        }

        private class ClientNotificationConfig : ServerNotificationConfig
        {
            public bool DoLinkSteamProfile { get; set; }
            public bool DoNotifyWhenPlayerConnects { get; set; }
            public bool DoNotifyWhenPlayerDisconnects { get; set; }
        }

        private class NotificationConfigContainer
        {
            public ServerNotificationConfig ServerConfig { get; set; }
            public ClientNotificationConfig SlackConfig { get; set; }
            public ClientNotificationConfig DiscordConfig { get; set; }
        }

        private enum NotificationType
        {
            SlackNotification,
            DiscordNotification,
            ServerNotification
        }

        private class NotificationCooldown
        {
            public NotificationType NotificationType { get; set; }
            public ulong PlayerID { get; set; }
            public DateTime LastNotifiedAt { get; set; }
        }

        #endregion
    }
}

// --- End of file: RustNotifications.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/battle-royale-rad-zone ---
// --- Original File Path: R/RadShrinkZone/RadShrinkZone.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("RadShrinkZone", "vaalberith", "1.0.6", ResourceId = 1828)]

    class RadShrinkZone : RustPlugin
    {
        //DEFAULT VALUES
        Vector3 target = new Vector3(0, 0, 0);
        float saferadius = 10;
        float saferadiusmin = 5;
        float eventradius = 40;
        float radpower = 50;
        float step = 1;
        float period = 20;
        //float drawtime = 5;
        //string drawmode = "both";

        string permissionrad = "RadShrinkZone.can";
        bool breaking = true;
        bool ok = true;

        //INITIALISATION\DECLARATION
        List<Vector3> position = new List<Vector3>();
        readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("RadShrinkZoneDefault");
        Dictionary<string, List<string>> radzonedata = new Dictionary<string, List<string>>();

        //LOCALIZATION

        #region Localization

        string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);

        void LoadDefaultMessages()
        {
            var messagesEn = new Dictionary<string, string>
            {
                {"EventStart", "Radiation is coming! Run to the centre to safe your life! ( {0} : {1} )"},
                {"RadiusDecreased", "Radius of safezone decreased!"},
                {"SafezoneRadiusReachedMin", "Radius of safezone reached its minimum!"},
                {"EventStopped", "Event stopped!"},
                {"NoPerm", "No permission!"},
                {"Help", "Type /rad for usage help"},
                {"Helplong", "<color=red>Config:</color>\n/rad saferad (m)\n /rad saferadmin (m)\n/rad eventrad (m)\n/rad radpower (%)\n/rad step (num)\n/rad period (seconds)\n/rad x y z\n/rad me (uses your position as target)\n<color=red>Manager:</color>\n/rad start\n/rad stop (stops decrease)\n/rad clear (close event and remove zones)"},
                {"Erased", "Erased all event rad zones"}
            };
            lang.RegisterMessages(messagesEn, this);

            var messagesRu = new Dictionary<string, string>
            {
                {"EventStart", "Радиация появляется! Беги в центр, чтобы выжить! ( {0} : {1} )"},
                {"RadiusDecreased", "Радиус безопасной зоны уменьшился!"},
                {"SafezoneRadiusReachedMin", "Радиус безопасной зоны достиг минимума!"},
                {"EventStopped", "Ивент закончился!"},
                {"NoPerm", "Нет прав!"},
                {"Help", "Напиши /rad для подсказки"},
                {"Helplong", "<color=red>Config:</color>\n/rad saferad (m)\n /rad saferadmin (m)\n/rad eventrad (m)\n/rad radpower (%)\n/rad step (num)\n/rad period (seconds)\n/rad x y z\n/rad me (uses your position as target)\n<color=red>Manager:</color>\n/rad start\n/rad stop (stops decrease)\n/rad clear (close event and remove zones)"},
                {"Erased", "Все ивент-зоны очищены"}
            };
            lang.RegisterMessages(messagesRu, this, "ru");
        }
        #endregion

        //CONFIG

        //PLUGIN REFERENCE AND HOOKS

        [PluginReference]
        Plugin ZoneManager;

        void OnServerInitialized()
        {
            LoadDefaultMessages();
            if (plugins.Exists("ZoneManager")) ok = true;
            else
            {
                PrintWarning("Install ZoneManager!");
                ok = false;
            }

            radzonedata = dataFile.ReadObject<Dictionary<string, List<string>>>();
            List<string> pos;
            if (!radzonedata.TryGetValue("Position", out pos))
            {
                //first datafile creating ("position" does not exist)
                safecfg();
                Puts("BattleRoyale RadZone created for first time.");
            }
            else Puts("BattleRoyale RadZone datafile loaded.");
            execcfg();
        }

        void execcfg()
        {
            radzonedata = dataFile.ReadObject<Dictionary<string, List<string>>>();
            List<string> value;
            if (radzonedata.TryGetValue("Position", out value))
                target.x = Convert.ToSingle(value[0]); target.y = Convert.ToSingle(value[1]); target.z = Convert.ToSingle(value[2]);
            if (radzonedata.TryGetValue("SafeRadius", out value))
                saferadius = Convert.ToSingle(value[0]);
            if (radzonedata.TryGetValue("SafeRadiusMinimum", out value))
                saferadiusmin = Convert.ToSingle(value[0]);
            if (radzonedata.TryGetValue("EventRadius", out value))
                eventradius = Convert.ToSingle(value[0]);
            if (radzonedata.TryGetValue("RadiationPower", out value))
                radpower = Convert.ToSingle(value[0]);
            if (radzonedata.TryGetValue("DecreaseStep", out value))
                step = Convert.ToSingle(value[0]);
            if (radzonedata.TryGetValue("DecreasePeriod", out value))
                period = Convert.ToSingle(value[0]);
            /*if (radzonedata.TryGetValue("DrawTime", out value))
                drawtime=Convert.ToSingle(value[0]);
            if (radzonedata.TryGetValue("DrawMode", out value))
                drawmode=value[0];*/
        }

        void safecfg()
        {
            radzonedata["Position"] = new List<string> { target.x.ToString(), target.y.ToString(), target.z.ToString() };
            radzonedata["SafeRadius"] = new List<string> { saferadius.ToString() };
            radzonedata["SafeRadiusMinimum"] = new List<string> { saferadiusmin.ToString() };
            radzonedata["EventRadius"] = new List<string> { eventradius.ToString() };
            radzonedata["RadiationPower"] = new List<string> { radpower.ToString() };
            radzonedata["DecreaseStep"] = new List<string> { step.ToString() };
            radzonedata["DecreasePeriod"] = new List<string> { period.ToString() };
            /*radzonedata["DrawTime"] = new List<string>(){drawtime.ToString()};
            radzonedata["DrawMode"] = new List<string>(){drawmode};*/

            dataFile.WriteObject(radzonedata);
        }

        void Unload()
        {
            DestroyAllSpheres();
            DelPos();
        }

        void Loaded()
        {
            permission.RegisterPermission(permissionrad, this);
        }

        /*void OnEnterZone(string ZoneID, BasePlayer player)
        {
            if (breaking) return;
            if (!ZoneID.Contains("radshrink_pos_")) return;
            if (drawmode=="rad" || drawmode=="both")
            {
                Regex regex = new Regex(@"\d+");
                Match match = regex.Match(ZoneID);
                if (match.Success)
                {
                    float sphereradius = (eventradius-saferadius)/2;
                    player.SendConsoleCommand("ddraw.sphere", drawtime, Color.red, position[Convert.ToInt32(match.Value, 16)], sphereradius);
                }
            }
            if (drawmode=="safe"|| drawmode=="both") player.SendConsoleCommand("ddraw.sphere", drawtime, Color.green, target, saferadius);
        }*/


        //MAIN FUNCTIONS
        private List<BaseEntity> Spheres = new List<BaseEntity>();
        private const string SphereEnt = "assets/prefabs/visualization/sphere.prefab";

        private void CreateSphere(Vector3 position, float radius)
        {
            BaseEntity sphere = GameManager.server.CreateEntity(SphereEnt, position, new Quaternion(), true);
            SphereEntity ent = sphere.GetComponent<SphereEntity>();
            ent.currentRadius = radius * 2;
            ent.lerpSpeed = 0f;
            sphere.Spawn();
            Spheres.Add(sphere);
        }

        private void DestroyAllSpheres()
        {
            foreach (var sphere in Spheres)
                if (sphere != null)
                    sphere.KillMessage();
        }

        private void createZone(string zoneID, Vector3 pos, float radius, float rads)
        {
            List<string> build = new List<string>();
            build.Add("radius");
            build.Add(radius.ToString());
            build.Add("radiation");
            build.Add(rads.ToString());
            string[] zoneArgs = build.ToArray();
            ZoneManager?.Call("CreateOrUpdateZone", zoneID, zoneArgs, pos);
        }

        private void eraseZone(string zoneID)
        {
            ZoneManager.Call("EraseZone", zoneID);
        }

        private void CalcPos(Vector3 pos)
        {
            if (breaking) return;
            position.Clear();
            float centerline = (eventradius + saferadius) / 2;
            float sphereradius = (eventradius - saferadius) / 2;
            float corn = centerline * 0.71f;
            Vector3 SW = new Vector3(pos.x - corn, pos.y, pos.z - corn); position.Add(SW);
            Vector3 W = new Vector3(pos.x - centerline, pos.y, pos.z); position.Add(W);
            Vector3 NW = new Vector3(pos.x - corn, pos.y, pos.z + corn); position.Add(NW);
            Vector3 N = new Vector3(pos.x, pos.y, pos.z + centerline); position.Add(N);
            Vector3 NE = new Vector3(pos.x + corn, pos.y, pos.z + corn); position.Add(NE);
            Vector3 E = new Vector3(pos.x + centerline, pos.y, pos.z); position.Add(E);
            Vector3 SE = new Vector3(pos.x + corn, pos.y, pos.z - corn); position.Add(SE);
            Vector3 S = new Vector3(pos.x, pos.y, pos.z - centerline); position.Add(S);
            int i = 0;
            foreach (Vector3 elem in position)
            {
                createZone("radshrink_pos_" + i, elem, sphereradius, radpower);
                i++;
            }
        }

        private void DelPos()
        {
            stop();
            int i = 0;
            foreach (Vector3 elem in position)
            {
                eraseZone("radshrink_pos_" + i);
                i++;
            }
            position.Clear();
            if (i > 0) Puts(GetMessage("Erased"));
        }

        private void started()
        {
            ConVar.Server.radiation = true;
            breaking = false;
            execcfg();
            PrintToChat(GetMessage("EventStart"), target.x, target.z);
            Puts(GetMessage("EventStart"), target.x, target.z);
            StartZoneShrink();
        }

        private void stop()
        {
            breaking = true;
            PrintToChat(GetMessage("EventStopped"));
            Puts(GetMessage("EventStopped"));
            ConVar.Server.radiation = true;
        }

        private void StartZoneShrink()
        {
            DestroyAllSpheres();
            if (breaking) return;
            CreateSphere(target, saferadius);
            timer.In(period, () => Shrink());
        }

        private void Shrink()
        {
            if (breaking) return;
            if (saferadius <= saferadiusmin)
            {
                PrintToChat(GetMessage("SafezoneRadiusReachedMin"));
                Puts(GetMessage("SafezoneRadiusReachedMin"));
                return;
            }
            CalcPos(target);
            saferadius = saferadius - step;
            Puts(GetMessage("RadiusDecreased"));
            PrintToChat(GetMessage("RadiusDecreased"));
            StartZoneShrink();
        }

        bool IsAllowed(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;
            return false;
        }

        // INTERFACE, COMMANDS

        [ChatCommand("rad")]
        void radchat(BasePlayer player, string cmd, string[] args)
        {
            if (!ok) return;
            if (player != null)
            {
                if (!IsAllowed(player, permissionrad))
                {
                    SendReply(player, GetMessage("NoPerm", player.UserIDString));
                    return;
                }
            }

            if (args.Length == 1)
            {
                if (args[0] == "start")
                {
                    started();
                }
                else if (args[0] == "stop")
                {
                    stop();
                }
                else if (args[0] == "clear")
                {
                    DelPos();
                }
                else if (args[0] == "me")
                {
                    if (player == null) return;
                    target = player.transform.position;
                    safecfg();
                }

                else if (player != null) SendReply(player, GetMessage("Help", player.UserIDString));

                return;
            }

            if (args.Length == 2)
            {
                /*if (args[0]=="drawmod")
                {
                    if (args[1] == "safe" || args[1] == "rad" || args[1] == "both" || args[1] == "none")
                    {
                        drawmode=args[1];
                    }
                    else  if (player !=null) SendReply(player, GetMessage("Help", player.UserIDString));
                }
                else if (args[0]=="drawtime")
                {
                    drawtime=Convert.ToSingle(args[1]);
                }

                else*/
                if (args[0] == "saferad")
                {
                    saferadius = Convert.ToSingle(args[1]);
                }

                else if (args[0] == "saferadmin")
                {
                    saferadiusmin = Convert.ToSingle(args[1]);
                }

                else if (args[0] == "eventrad")
                {
                    eventradius = Convert.ToSingle(args[1]);
                }

                else if (args[0] == "radpower")
                {
                    radpower = Convert.ToSingle(args[1]);
                }

                else if (args[0] == "step")
                {
                    step = Convert.ToSingle(args[1]);
                }

                else if (args[0] == "period")
                {
                    period = Convert.ToSingle(args[1]);
                }

                else if (player != null) SendReply(player, GetMessage("Help", player.UserIDString));

                safecfg();
                return;
            }

            if (args.Length == 3)
            {
                target.x = Convert.ToSingle(args[0]);
                target.y = Convert.ToSingle(args[1]);
                target.z = Convert.ToSingle(args[2]);
                safecfg();
            }

            else if (player != null) SendReply(player, GetMessage("Helplong", player.UserIDString));
        }

        [ConsoleCommand("rad")]
        void radconsole(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null) return;
            string[] args = arg.Args;

            if (arg.Connection != null)
            {
                BasePlayer player = arg.Connection.player as BasePlayer;
                if (!IsAllowed(player, permissionrad))
                {
                    PrintToChat(player, GetMessage("NoPerm", player.UserIDString));
                    return;
                }
                radchat(player, "rad", args);
            }

            radchat(null, "rad", args);
        }
    }
}

// --- End of file: RadShrinkZone.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rustio-friendly-fire ---
// --- Original File Path: R/RustIOFriendlyFire/RustIOFriendlyFire.cs ---

﻿using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

namespace Oxide.Plugins
{
    [Info("FriendlyFire", "playrust.io / dcode", "1.7.0")]
    public class FriendlyFire : RustPlugin
    {

        #region Rust:IO Bindings

        private Library lib;
        private MethodInfo isInstalled;
        private MethodInfo hasFriend;
        private MethodInfo addFriend;
        private MethodInfo deleteFriend;

        private void InitializeRustIO() {
            lib = Interface.GetMod().GetLibrary<Library>("RustIO");
            if (lib == null || (isInstalled = lib.GetFunction("IsInstalled")) == null || (hasFriend = lib.GetFunction("HasFriend")) == null || (addFriend = lib.GetFunction("AddFriend")) == null || (deleteFriend = lib.GetFunction("DeleteFriend")) == null) {
                lib = null;
                Puts("{0}: {1}", Title, "Rust:IO is not present. You need to install Rust:IO first in order to use this plugin!");
            }
        }

        private bool IsInstalled() {
            if (lib == null) return false;
            return (bool)isInstalled.Invoke(lib, new object[] {});
        }

        private bool HasFriend(string playerId, string friendId) {
            if (lib == null) return false;
            return (bool)hasFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        private bool AddFriend(string playerId, string friendId) {
            if (lib == null) return false;
            return (bool)addFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        private bool DeleteFriend(string playerId, string friendId) {
            if (lib == null) return false;
            return (bool)deleteFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        #endregion

        private List<ulong> manuallyEnabledBy = new List<ulong>();
        private List<ulong> apiBypassedFor = new List<ulong>();
        private List<string> texts = new List<string>() {
            "%NAME% is your friend and cannot be hurt. To disable this, unshare your location with %NAME% on the live map or type: <color=#ffd479>/ff on</color>",

            "Usage: <color=#ffd479>/ff [on|off]</color>",
            "Friendly fire is <color=#cd422b>enabled</color> for your friends:",
            "Friendly fire is <color=#8acd2b>disabled</color> for your friends:",
            "You do not have any friends currently.",
            "You may add or delete friends using the live map.",
            "To toggle friendly fire on or off, type: <color=#ffd479>/ff on|off</color>",
            "Friendly fire for your friends is already <color=#cd422b>enabled</color>. Take care!",
            "You have <color=#cd422b>enabled</color> friendly fire for your friends. Take care!",
            "Friendly fire for your friends is already <color=#8acd2b>disabled</color>. They are safe!",
            "You have <color=#8acd2b>disabled</color> friendly fire for your friends. They are safe!",

            "<color=#ffd479>/ff</color> - Displays your friendly fire status",
            "<color=#ffd479>/ff on|off</color> - Toggles friendly fire <color=#cd422b>on</color> or <color=#8acd2b>off</color>"
        };
        private Dictionary<string, string> messages = new Dictionary<string, string>();
        private Dictionary<string, DateTime> notificationTimes = new Dictionary<string, DateTime>();

        // Translates a string
        private string _(string text, Dictionary<string, string> replacements = null) {
            if (messages.ContainsKey(text) && messages[text] != null)
                text = messages[text];
            if (replacements != null)
                foreach (var replacement in replacements)
                    text = text.Replace("%" + replacement.Key + "%", replacement.Value);
            return text;
        }


        // Loads the default configuration
        protected override void LoadDefaultConfig() {
            var messages = new Dictionary<string, object>();
            foreach (var text in texts) {
                if (messages.ContainsKey(text))
                    Puts("{0}: {1}", Title, "Duplicate translation string: " + text);
                else
                    messages.Add(text, text);
            }
            Config["messages"] = messages;
        }

        // Gets a config value of a specific type
        private T GetConfig<T>(string name, T defaultValue) {
            if (Config[name] == null)
                return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized() {
            try {
                InitializeRustIO();
                LoadConfig();
                var customMessages = GetConfig<Dictionary<string, object>>("messages", null);
                if (customMessages != null)
                    foreach (var pair in customMessages)
                        messages[pair.Key] = Convert.ToString(pair.Value);
            } catch (Exception ex) {
                Error("OnServerInitialized failed: " + ex.Message);
            }
        }

        private void RestoreDefaults(BasePlayer player) {
            manuallyEnabledBy.Remove(player.userID);
        }

        [HookMethod("OnPlayerConnected")]
        void OnPlayerConnected(BasePlayer player) {
            RestoreDefaults(player);
        }

        [HookMethod("OnPlayerDisconnected")]
        void OnPlayerDisconnected(BasePlayer player) {
            RestoreDefaults(player);
        }

        private object OnAttackShared(BasePlayer attacker, BasePlayer victim, HitInfo hit) {
            if (lib == null || attacker == victim)
                return null;
            if (manuallyEnabledBy.Contains(attacker.userID) || apiBypassedFor.Contains(attacker.userID))
                return null;
            var victimId = victim.userID.ToString();
            var attackerId = attacker.userID.ToString();
            if (!HasFriend(attackerId, victimId))
                return null;
            DateTime now = DateTime.UtcNow;
            DateTime time;
            var key = attackerId + "-" + victimId;
            if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-10)) {
                attacker.SendConsoleCommand("chat.add", "", "", _("%NAME% is your friend and cannot be hurt. To disable this, unshare your location with %NAME% on the live map or type: <color=#ffd479>/ff on</color>", new Dictionary<string, string>() { { "NAME", victim.displayName } }));
                notificationTimes[key] = now;
            }
            // Clear the HitInfo (we don't want to rely on the return behavior because other plugins may cause conflicts)
            hit.damageTypes = new DamageTypeList();
            hit.DidHit = false;
            hit.HitEntity = null;
            hit.Initiator = null;
            hit.DoHitEffects = false;
            return false;
        }

        [HookMethod("OnPlayerAttack")]
        void OnPlayerAttack(BasePlayer attacker, HitInfo hit) {
            try {
                if (hit.HitEntity is BasePlayer)
                    OnAttackShared(attacker, hit.HitEntity as BasePlayer, hit);
            } catch (Exception ex) {
                Error("OnPlayerAttack failed: " + ex.Message);
            }
        }

        [HookMethod("OnEntityTakeDamage")]
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hit) {
            try {
                if (entity is BasePlayer && hit.Initiator is BasePlayer)
                    OnAttackShared(hit.Initiator as BasePlayer, entity as BasePlayer, hit);
            } catch (Exception ex) {
                Error("OnEntityTakeDamage failed: " + ex.Message);
            }
        }

        [ChatCommand("ff")]
        private void cmdChatFF(BasePlayer player, string command, string[] args) {
            if (!IsInstalled())
                return;
            if (args.Length > 1) {
                SendReply(player, _("Usage: <color=#ffd479>/ff [on|off]</color>"));
                return;
            }
            if (args.Length == 0) {
                var sb = new StringBuilder();
                int n = 0;
                sb.Append("<size=22>FriendlyFire</size> "+Version+" by <color=#ce422b>http://playrust.io</color>\n");
                if (manuallyEnabledBy.Contains(player.userID))
                    sb.Append(_("Friendly fire is <color=#cd422b>enabled</color> for your friends:")).Append("\n");
                else
                    sb.Append(_("Friendly fire is <color=#8acd2b>disabled</color> for your friends:")).Append("\n");
                var playerId = player.userID.ToString();
                foreach (var p in BasePlayer.activePlayerList) {
                    var pId = p.userID.ToString();
                    if (HasFriend(playerId, pId)) {
                        if (n > 0)
                            sb.Append(", ");
                        sb.Append(p.displayName);
                        ++n;
                    }
                }
                foreach (var p in BasePlayer.sleepingPlayerList) {
                    var pId = p.userID.ToString();
                    if (HasFriend(playerId, pId)) {
                        if (n > 0)
                            sb.Append(", ");
                        sb.Append(p.displayName);
                        ++n;
                    }
                }
                if (n == 0)
                    sb.Append(_("You do not have any friends currently."));
                sb.Append("\n").Append(_("You may add or delete friends using the live map."));
                sb.Append("\n").Append(_("To toggle friendly fire on or off, type: <color=#ffd479>/ff on|off</color>"));
                SendReply(player, sb.ToString());
            } else if (args.Length == 1) {
                switch (args[0]) {
                    case "on":
                        if (manuallyEnabledBy.Contains(player.userID)) {
                            SendReply(player, _("Friendly fire for your friends is already <color=#cd422b>enabled</color>. Take care!"));
                        } else {
                            manuallyEnabledBy.Add(player.userID);
                            SendReply(player, _("You have <color=#cd422b>enabled</color> friendly fire for your friends. Take care!"));
                        }
                        break;
                    case "off":
                        if (!manuallyEnabledBy.Contains(player.userID)) {
                            SendReply(player, _("Friendly fire for your friends is already <color=#8acd2b>disabled</color>. They are safe!"));
                        } else {
                            manuallyEnabledBy.Remove(player.userID);
                            SendReply(player, _("You have <color=#8acd2b>disabled</color> friendly fire for your friends. They are safe!"));
                        }
                        break;
                    default:
                        SendReply(player, _("Usage: <color=#ffd479>/ff [on|off]</color>"));
                        return;
                }
            }
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player) {
            var sb = new StringBuilder()
               .Append("<size=18>FriendlyFire</size> by <color=#ce422b>http://playrust.io</color>\n")
               .Append("  ").Append(_("<color=#ffd479>/ff</color> - Displays your friendly fire status")).Append("\n")
               .Append("  ").Append(_("<color=#ffd479>/ff on|off</color> - Toggles friendly fire <color=#cd422b>on</color> or <color=#8acd2b>off</color>"));
            player.ChatMessage(sb.ToString());
        }

        #region API Methods

        [HookMethod("EnableBypass")]
        private bool EnableBypass(object playerId) {
            if (playerId == null)
                throw new ArgumentException("playerId is null");
            if (playerId is string)
                playerId = Convert.ToUInt64((string)playerId);
            var uid = (ulong)playerId;
            if (!apiBypassedFor.Contains(uid)) {
                apiBypassedFor.Add(uid);
                return true;
            }
            return false;
        }

        [HookMethod("DisableBypass")]
        private bool DisableBypass(object playerId) {
            if (playerId == null)
                throw new ArgumentException("playerId is null");
            if (playerId is string)
                playerId = Convert.ToUInt64((string)playerId);
            var uid = (ulong)playerId;
            return apiBypassedFor.Remove(uid);
        }

        #endregion

        #region Utility Methods

        private void Log(string message) {
            Puts("{0}: {1}", Title, message);
        }

        private void Warn(string message) {
            PrintWarning("{0}: {1}", Title, message);
        }

        private void Error(string message) {
            PrintError("{0}: {1}", Title, message);
        }

        #endregion
    }
}


// --- End of file: RustIOFriendlyFire.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/radtown-animals ---
// --- Original File Path: R/RadtownAnimals/RadtownAnimals.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.SceneManagement;

namespace Oxide.Plugins
{
    [Info("Radtown Animals", "k1lly0u", "0.3.2"), Description("Spawns various NPC types at monuments")]
    public class RadtownAnimals : RustPlugin
    {
        #region Fields
        private readonly List<BaseCombatEntity> pluginSpawnedEntities = new List<BaseCombatEntity>();

        private readonly Hash<NPC, string> prefabLookup = new Hash<NPC, string>
        {
            [NPC.Bear] = "assets/rust.ai/agents/bear/bear.prefab",
            [NPC.Boar] = "assets/rust.ai/agents/boar/boar.prefab",
            [NPC.Chicken] = "assets/rust.ai/agents/chicken/chicken.prefab",
            [NPC.Stag] = "assets/rust.ai/agents/stag/stag.prefab",
            [NPC.Wolf] = "assets/rust.ai/agents/wolf/wolf.prefab",
            [NPC.Scarecrow] = "assets/prefabs/npc/scarecrow/scarecrow.prefab",
            [NPC.Scientist] = "assets/rust.ai/agents/npcplayer/humannpc/scientist/scientistnpc_roam.prefab",
        };

        [JsonConverter(typeof(StringEnumConverter))]
        private enum NPC { Bear, Boar, Chicken, Stag, Wolf, Scarecrow, Scientist }
        #endregion

        #region Oxide Hooks 
        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void OnServerInitialized() => InitializeSpawns();

        private void OnEntityDeath(BaseCombatEntity baseCombatEntity, HitInfo hitInfo)
        {
            if (baseCombatEntity == null) 
                return;

            if (pluginSpawnedEntities.Contains(baseCombatEntity))
            {
                string prefabName = baseCombatEntity.PrefabName;
                Vector3 homePosition = GetHomePosition(baseCombatEntity);

                timer.In(Configuration.Settings.Respawn, () => Spawn(prefabName, homePosition));

                pluginSpawnedEntities.Remove(baseCombatEntity);
            }
        }

        private void Unload()
        {
            foreach (BaseCombatEntity baseCombatEntity in pluginSpawnedEntities)
            {
                if (baseCombatEntity != null && !baseCombatEntity.IsDead())
                    baseCombatEntity.Kill(BaseNetworkable.DestroyMode.None);
            }

            pluginSpawnedEntities.Clear();

            Configuration = null;
        }
        #endregion

        #region Initial Spawning
        private void InitializeSpawns()
        {
            Hash<string, ConfigData.Monuments.MonumentSettings> monumentLookup = new Hash<string, ConfigData.Monuments.MonumentSettings>
            {
                ["lighthouse"] = Configuration.MonumentSettings.Lighthouse,
                ["powerplant_1"] = Configuration.MonumentSettings.Powerplant,
                ["military_tunnel_1"] = Configuration.MonumentSettings.Tunnels,
                ["harbor_1"] = Configuration.MonumentSettings.LargeHarbor,
                ["harbor_2"] = Configuration.MonumentSettings.SmallHarbor,
                ["airfield_1"] = Configuration.MonumentSettings.Airfield,
                ["trainyard_1"] = Configuration.MonumentSettings.Trainyard,
                ["water_treatment_plant_1"] = Configuration.MonumentSettings.WaterTreatment,
                ["warehouse"] = Configuration.MonumentSettings.Warehouse,
                ["satellite_dish"] = Configuration.MonumentSettings.Satellite,
                ["sphere_tank"] = Configuration.MonumentSettings.Dome,
                ["radtown_small_3"] = Configuration.MonumentSettings.Radtown,
                ["launch_site_1"] = Configuration.MonumentSettings.RocketFactory,
                ["gas_station_1"] = Configuration.MonumentSettings.GasStation,
                ["supermarket_1"] = Configuration.MonumentSettings.Supermarket,
                ["mining_quarry_c"] = Configuration.MonumentSettings.Quarry_HQM,
                ["mining_quarry_a"] = Configuration.MonumentSettings.Quarry_Sulfur,
                ["mining_quarry_b"] = Configuration.MonumentSettings.Quarry_Stone,
                ["junkyard_1"] = Configuration.MonumentSettings.Junkyard
            };

            Transform root = HierarchyUtil.GetRoot("Monument").transform;
            for (int i = 0; i < root.childCount; i++)
            {
                Transform child = root.GetChild(i);
                foreach (KeyValuePair<string, ConfigData.Monuments.MonumentSettings> kvp in monumentLookup)
                {
                    if (child.name.Contains(kvp.Key))
                    {
                        if (kvp.Value.Enabled)
                            ServerMgr.Instance.StartCoroutine(SpawnAnimals(child.position, kvp.Value.Counts));

                        break;
                    } 
                }
            }
        }

        private IEnumerator SpawnAnimals(Vector3 position, Hash<NPC,int> spawnCounts)
        {
            foreach (KeyValuePair<NPC, int> kvp in spawnCounts)
            {
                for (int i = 0; i < kvp.Value; i++)
                {
                    if (pluginSpawnedEntities.Count >= Configuration.Settings.Total)
                    {
                        Puts(lang.GetMessage("Notification.SpawnLimit", this));
                        yield break;
                    }

                    Spawn(kvp.Key, position);

                    yield return CoroutineEx.waitForSeconds(0.5f);
                }
            }
        }
        #endregion

        #region Spawning
        private void Spawn(NPC npc, Vector3 position) => Spawn(prefabLookup[npc], position);

        private void Spawn(string prefab, Vector3 position)
        {
            Vector2 random = Random.insideUnitCircle * Configuration.Settings.Spread;
            Vector3 spawnPosition = new Vector3(position.x + random.x, position.y, position.z + random.y);

            if (!NavmeshSpawnPoint.Find(spawnPosition, 20f, out spawnPosition))
            {
                timer.In(Configuration.Settings.Respawn, () => Spawn(prefab, position));
                return;
            }

            BaseCombatEntity baseCombatEntity = InstantiateEntity(prefab, spawnPosition);
            baseCombatEntity.enableSaving = false;

            NavMeshAgent navMeshAgent = baseCombatEntity.GetComponent<NavMeshAgent>();
            if (navMeshAgent != null)
            {
                const int AREA_MASK = 1;
                const int AGENT_TYPE_ID = -1372625422;

                navMeshAgent.agentTypeID = AGENT_TYPE_ID;
                navMeshAgent.areaMask = AREA_MASK;
            }

            BaseNavigator baseNavigator = baseCombatEntity.GetComponent<BaseNavigator>();
            if (baseNavigator != null)
            {
                const string WALKABLE = "Walkable";

                baseNavigator.DefaultArea = WALKABLE;

                baseNavigator.MaxRoamDistanceFromHome = Configuration.Settings.Spread;
                baseNavigator.BestRoamPointMaxDistance = Configuration.Settings.Spread * 0.5f;

                if (baseNavigator.topologyPreference == 0)
                    baseNavigator.topologyPreference = (TerrainTopology.Enum)1673010749;

                baseNavigator.topologyPreference |= TerrainTopology.Enum.Monument | TerrainTopology.Enum.Building;
            }

            baseCombatEntity.Spawn();

            timer.In(1f, () => SetupBrain(baseCombatEntity, position));

            pluginSpawnedEntities.Add(baseCombatEntity);
        }

        private BaseCombatEntity InstantiateEntity(string type, Vector3 position)
        {
            GameObject gameObject = Instantiate.GameObject(GameManager.server.FindPrefab(type), position, Quaternion.identity);
            gameObject.name = type;

            SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);

            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());

            if (!gameObject.activeSelf) 
                gameObject.SetActive(true);

            BaseCombatEntity component = gameObject.GetComponent<BaseCombatEntity>();
            return component;
        }
        #endregion

        #region Brain Setup
        private void SetupBrain(BaseCombatEntity baseCombatEntity, Vector3 position)
        {
            if (baseCombatEntity == null)
                return;

            if (baseCombatEntity is global::HumanNPC)
                SetupBrain<global::HumanNPC>(baseCombatEntity, position);

            if (baseCombatEntity is BaseAnimalNPC)
                SetupBrain<BaseAnimalNPC>(baseCombatEntity, position);

            if (baseCombatEntity is ScarecrowNPC)
                SetupBrain<ScarecrowNPC>(baseCombatEntity, position);
        }

        private void SetupBrain<T>(BaseCombatEntity baseCombatEntity, Vector3 position) where T : BaseEntity
        {
            BaseAIBrain baseAIBrain = baseCombatEntity.GetComponent<BaseAIBrain>();
            if (baseAIBrain != null)
            {
                baseAIBrain.Events.Memory.Position.Set(position, 4);

                GenericRoamState<T> genericRoamState = new GenericRoamState<T>();
                genericRoamState.brain = baseAIBrain;
                baseAIBrain.states[AIState.Roam] = genericRoamState;
            }
        }

        private Vector3 GetHomePosition(BaseCombatEntity baseCombatEntity)
        {
            if (baseCombatEntity != null)
            {
                if (baseCombatEntity is global::HumanNPC)
                    return GetHomePosition<global::HumanNPC>(baseCombatEntity);

                if (baseCombatEntity is BaseAnimalNPC)
                    return GetHomePosition<BaseAnimalNPC>(baseCombatEntity);

                if (baseCombatEntity is ScarecrowNPC)
                    return GetHomePosition<ScarecrowNPC>(baseCombatEntity);
            }
            return Vector3.zero;
        }

        private Vector3 GetHomePosition<T>(BaseCombatEntity baseCombatEntity) where T : BaseEntity => baseCombatEntity.GetComponent<BaseAIBrain>().Events.Memory.Position.Get(4);
        #endregion

        #region NavMesh
        private static class NavmeshSpawnPoint
        {
            private static NavMeshHit navmeshHit;

            private static RaycastHit raycastHit;

            private static readonly Collider[] _buffer = new Collider[256];

            private const int WORLD_LAYER = 65536;

            public static bool Find(Vector3 targetPosition, float maxDistance, out Vector3 position)
            {
                for (int i = 0; i < 10; i++)
                {
                    position = i == 0 ? targetPosition : targetPosition + (Random.onUnitSphere * maxDistance);
                    if (NavMesh.SamplePosition(position, out navmeshHit, maxDistance, 1))
                    {
                        if (IsInRockPrefab(navmeshHit.position))
                            continue;

                        if (IsNearWorldCollider(navmeshHit.position))
                            continue;

                        if (navmeshHit.position.y < TerrainMeta.WaterMap.GetHeight(navmeshHit.position))
                            continue;

                        position = navmeshHit.position;
                        return true;
                    }
                }
                position = default(Vector3);
                return false;
            }

            private static bool IsInRockPrefab(Vector3 position)
            {
                Physics.queriesHitBackfaces = true;

                bool isInRock = Physics.Raycast(position, Vector3.up, out raycastHit, 20f, WORLD_LAYER, QueryTriggerInteraction.Ignore) &&
                                BLOCKED_COLLIDERS.Any(s => raycastHit.collider?.gameObject?.name.Contains(s, CompareOptions.OrdinalIgnoreCase) ?? false);

                Physics.queriesHitBackfaces = false;

                return isInRock;
            }

            private static bool IsNearWorldCollider(Vector3 position)
            {
                Physics.queriesHitBackfaces = true;

                int count = Physics.OverlapSphereNonAlloc(position, 2f, _buffer, WORLD_LAYER, QueryTriggerInteraction.Ignore);
                Physics.queriesHitBackfaces = false;

                int removed = 0;
                for (int i = 0; i < count; i++)
                {
                    if (ACCEPTED_COLLIDERS.Any(s => _buffer[i].gameObject.name.Contains(s, CompareOptions.OrdinalIgnoreCase) || _buffer[i].gameObject.layer == 4))
                        removed++;
                }

                return count - removed > 0;
            }

            private static readonly string[] ACCEPTED_COLLIDERS = new string[] { "road", "carpark", "rocket_factory", "range", "train_track", "runway", "_grounds", "concrete_slabs", "lighthouse", "cave", "office", "walkways", "sphere", "tunnel", "industrial", "junkyard" };

            private static readonly string[] BLOCKED_COLLIDERS = new string[] { "rock", "cliff", "junk", "range", "invisible" };
        }
        #endregion

        #region Roam State
        public class GenericRoamState<T> : BaseAIBrain.BasicAIState
        {
            private StateStatus status = StateStatus.Error;

            private static readonly Vector3[] preferedTopologySamples = new Vector3[4];

            private static readonly Vector3[] topologySamples = new Vector3[4];

            public GenericRoamState() : base(AIState.Roam) { }

            public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
            {
                base.StateLeave(brain, entity);
                brain.Navigator.Stop();
            }

            public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
            {
                base.StateEnter(brain, entity);
                status = StateStatus.Error;

                if (brain.PathFinder == null)
                    return;

                Vector3 destination = GetBestRoamPosition(brain.Navigator, brain.Events.Memory.Position.Get(4), brain.Events.Memory.Position.Get(4), 1f, Configuration.Settings.Spread);

                if (brain.Navigator.SetDestination(destination, BaseNavigator.NavigationSpeed.Slow, 0f, 0f))
                {
                    status = StateStatus.Running;
                    return;
                }

                status = StateStatus.Error;
            }

            public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
            {
                base.StateThink(delta, brain, entity);

                if (status == StateStatus.Error)
                    return status;

                if (brain.Navigator.Moving)
                    return StateStatus.Running;

                return StateStatus.Finished;
            }

            private Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 localTo, Vector3 fallback, float minRange, float maxRange)
            {
                int topologyIndex = 0;
                int preferredTopologyIndex = 0;

                for (float degree = 0f; degree < 360f; degree += 90f)
                {
                    Vector3 position;
                    Vector3 pointOnCircle = BasePathFinder.GetPointOnCircle(localTo, Random.Range(minRange, maxRange), degree + Random.Range(0f, 90f));

                    if (navigator.GetNearestNavmeshPosition(pointOnCircle, out position, 20f) && navigator.IsAcceptableWaterDepth(position))
                    {
                        topologySamples[topologyIndex] = position;
                        topologyIndex++;
                        if (navigator.IsPositionATopologyPreference(position))
                        {
                            preferedTopologySamples[preferredTopologyIndex] = position;
                            preferredTopologyIndex++;
                        }
                    }
                }

                Vector3 chosenPosition;

                if (Random.Range(0f, 1f) <= 0.9f && preferredTopologyIndex > 0)
                    chosenPosition = preferedTopologySamples[Random.Range(0, preferredTopologyIndex)];

                else if (topologyIndex > 0)
                    chosenPosition = topologySamples[Random.Range(0, topologyIndex)];

                else chosenPosition = fallback;

                return chosenPosition;
            }
        }
        #endregion

        #region Commands
        [ChatCommand("ra_killall")]
        private void ChatCommand_KillAnimals(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) 
                return;

            foreach(BaseCombatEntity baseCombatEntity in pluginSpawnedEntities)
            {
                if (baseCombatEntity != null && !baseCombatEntity.IsDestroyed)
                    baseCombatEntity.Kill(BaseNetworkable.DestroyMode.None);
            }
            pluginSpawnedEntities.Clear();

            SendReply(player, lang.GetMessage("Message.Title", this, player.UserIDString) + lang.GetMessage("Notification.KilledAll", this, player.UserIDString));
        }

        [ConsoleCommand("ra_killall")]
        private void ConsoleCommand_KillAnimals(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                foreach (BaseCombatEntity baseCombatEntity in pluginSpawnedEntities)
                {
                    if (baseCombatEntity != null && !baseCombatEntity.IsDestroyed)
                        baseCombatEntity.Kill(BaseNetworkable.DestroyMode.None);
                }
                pluginSpawnedEntities.Clear();

                SendReply(arg, lang.GetMessage("Notification.KilledAll", this));
            }
        }
        #endregion

        #region Config 
        private static ConfigData Configuration;

        private class ConfigData
        {
            public Options Settings { get; set; }

            [JsonProperty(PropertyName = "Monument Settings")]
            public Monuments MonumentSettings { get; set; }

            public class Options
            {
                [JsonProperty(PropertyName = "Respawn timer (seconds)")]
                public int Respawn { get; set; }

                [JsonProperty(PropertyName = "Spawn spread distance from center of monument")]
                public float Spread { get; set; }

                [JsonProperty(PropertyName = "Maximum amount of animals to spawn")]
                public int Total { get; set; }
            }

            public class Monuments
            {
                public MonumentSettings Airfield { get; set; }

                public MonumentSettings Dome { get; set; }

                public MonumentSettings Junkyard { get; set; }

                public MonumentSettings Lighthouse { get; set; }

                public MonumentSettings LargeHarbor { get; set; }

                public MonumentSettings GasStation { get; set; }

                public MonumentSettings Powerplant { get; set; }

                [JsonProperty(PropertyName = "Stone Quarry")]
                public MonumentSettings Quarry_Stone { get; set; }

                [JsonProperty(PropertyName = "Sulfur Quarry")]
                public MonumentSettings Quarry_Sulfur { get; set; }

                [JsonProperty(PropertyName = "HQM Quarry")]
                public MonumentSettings Quarry_HQM { get; set; }

                public MonumentSettings Radtown { get; set; }

                public MonumentSettings RocketFactory { get; set; }

                public MonumentSettings Satellite { get; set; }

                public MonumentSettings SmallHarbor { get; set; }

                public MonumentSettings Supermarket { get; set; }

                public MonumentSettings Trainyard { get; set; }

                public MonumentSettings Tunnels { get; set; }

                public MonumentSettings Warehouse { get; set; }

                public MonumentSettings WaterTreatment { get; set; }

                public class MonumentSettings
                {
                    [JsonProperty(PropertyName = "Enable spawning at this monument")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Amount of animals to spawn at this monument")]
                    public Hash<NPC, int> Counts { get; set; } = new Hash<NPC, int>
                    {
                        [NPC.Bear] = 0,
                        [NPC.Boar] = 0,
                        [NPC.Chicken] = 0,
                        [NPC.Stag] = 0,
                        [NPC.Wolf] = 0,
                        [NPC.Scarecrow] = 0,
                        [NPC.Scientist] = 0,
                    }; 
                }
            }
            public Oxide.Core.VersionNumber Version { get; set; }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Settings = new ConfigData.Options
                {
                    Respawn = 900,
                    Spread = 60,
                    Total = 40
                },
                MonumentSettings = new ConfigData.Monuments
                {
                    Airfield = new ConfigData.Monuments.MonumentSettings(),
                    Dome = new ConfigData.Monuments.MonumentSettings(),
                    GasStation = new ConfigData.Monuments.MonumentSettings(),
                    Junkyard = new ConfigData.Monuments.MonumentSettings(),
                    LargeHarbor = new ConfigData.Monuments.MonumentSettings(),
                    Lighthouse = new ConfigData.Monuments.MonumentSettings(),
                    Powerplant = new ConfigData.Monuments.MonumentSettings(),
                    Quarry_HQM = new ConfigData.Monuments.MonumentSettings(),
                    Quarry_Stone = new ConfigData.Monuments.MonumentSettings(),
                    Quarry_Sulfur = new ConfigData.Monuments.MonumentSettings(),
                    Radtown = new ConfigData.Monuments.MonumentSettings(),
                    RocketFactory = new ConfigData.Monuments.MonumentSettings(),
                    Satellite = new ConfigData.Monuments.MonumentSettings(),
                    SmallHarbor = new ConfigData.Monuments.MonumentSettings(),
                    Supermarket = new ConfigData.Monuments.MonumentSettings(),
                    Trainyard = new ConfigData.Monuments.MonumentSettings(),
                    Tunnels = new ConfigData.Monuments.MonumentSettings(),
                    Warehouse = new ConfigData.Monuments.MonumentSettings(),
                    WaterTreatment = new ConfigData.Monuments.MonumentSettings()
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (Configuration.Version < new Core.VersionNumber(0, 3, 0))
                Configuration = baseConfig;

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Messages
        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            ["Message.Title"] = "<color=orange>Radtown Animals:</color> ",
            ["Notification.KilledAll"] = "<color=#939393>Killed all animals</color>",
            ["Notification.SpawnLimit"] = "The animal spawn limit has been hit."
        };
        #endregion
    }
}


// --- End of file: RadtownAnimals.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/report-system ---
// --- Original File Path: R/RustAppLite/RustAppLite.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Globalization;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System;
using Oxide.Game.Rust.Libraries;

namespace Oxide.Plugins
{
  [Info("RustApp Lite", "RustApp", "1.0.8")]
  [Description("Get reports on players in Discord, using a nicely designed interface or F7")]
  public class RustAppLite : RustPlugin
  {
    #region Configuration

    private class Configuration
    {

      [JsonProperty("[UI] Chat commands")]
      public List<string> report_ui_commands = new List<string>();

      [JsonProperty("[UI] Report reasons")]
      public List<string> report_ui_reasons = new List<string>();

      [JsonProperty("[UI] Cooldown between reports (seconds)")]
      public int report_ui_cooldown = 300;

      [JsonProperty("[UI] Auto-parse reports from F7 (ingame reports)")]
      public bool report_ui_auto_parse = true;

      [JsonProperty("[Discord] Webhook to send reports")]
      public string discord_webhook = "";

      [JsonProperty("[Discord-Translations] Nickname field")]
      public string discord_translations_nickname = "Nickname";

      [JsonProperty("[Discord-Translations] Reason field")]
      public string discord_translations_reason = "Reason";

      [JsonProperty("[Discord-Translations] Comment field")]
      public string discord_translations_comment = "Comment";

      [JsonProperty("[Discord-Translations] Report sent text")]
      public string discord_translations_report_sent = "Report sent";

      public static Configuration Generate()
      {
        return new Configuration
        {
          report_ui_commands = new List<string> { "report", "reports" },
          report_ui_reasons = new List<string> { "Cheat", "Abusive", "Spam" },
          report_ui_cooldown = 300,
          report_ui_auto_parse = true,
          discord_webhook = "",

          discord_translations_comment = "Comment",
          discord_translations_nickname = "Nickname",
          discord_translations_reason = "Reason",
          discord_translations_report_sent = "Report sent"
        };
      }
    }

    protected override void LoadConfig()
    {
      base.LoadConfig();
      try
      {
        _Settings = Config.ReadObject<Configuration>();
      }
      catch
      {
        PrintWarning($"Error reading config, creating one new config!");
        LoadDefaultConfig();
      }



      SaveConfig();
    }

    protected override void LoadDefaultConfig() => _Settings = Configuration.Generate();
    protected override void SaveConfig() => Config.WriteObject(_Settings);

    #endregion

    #region DiscordEmbedMessage
    public class DiscordMessage
    {
      public string content { get; set; }
      public DiscordEmbed[] embeds { get; set; }

      public DiscordMessage(string Content, DiscordEmbed[] Embeds = null)
      {
        content = Content;
        embeds = Embeds;
      }

      public void Send(string url)
      {
        _RustAppLite.webrequest.Enqueue(url, JsonConvert.SerializeObject(this), (code, response) =>
        {
          if (code == 200 || code == 204)
          {
            return;
          }

          _RustAppLite.Error(
            $"Веб-хук не был отправлен ({response})",
            $"Webhook was not sent ({response})"
          );

        }, _RustAppLite, Core.Libraries.RequestMethod.POST, _Headeers, 30f);
      }

      public static Dictionary<string, string> _Headeers = new Dictionary<string, string>
      {
        ["Content-Type"] = "application/json"
      };
    }
    public class DiscordEmbed
    {
      public string title { get; set; }
      public string description { get; set; }
      public int? color { get; set; }
      public DiscordField[] fields { get; set; }
      public DiscordFooter footer { get; set; }
      public DiscordAuthor author { get; set; }

      public DiscordEmbed(string Title, string Description, int? Color = null, DiscordField[] Fields = null, DiscordFooter Footer = null, DiscordAuthor Author = null)
      {
        title = Title;
        description = Description;
        color = Color;
        fields = Fields;
        footer = Footer;
        author = Author;
      }
    }
    public class DiscordFooter
    {
      public string text { get; set; }
      public string icon_url { get; set; }
      public string proxy_icon_url { get; set; }

      public DiscordFooter(string Text, string Icon_url, string Proxy_icon_url = null)
      {
        text = Text;
        icon_url = Icon_url;
        proxy_icon_url = Proxy_icon_url;
      }
    }
    public class DiscordAuthor
    {
      public string name { get; set; }
      public string url { get; set; }
      public string icon_url { get; set; }
      public string proxy_icon_url { get; set; }

      public DiscordAuthor(string Name, string Url, string Icon_url, string Proxy_icon_url = null)
      {
        name = Name;
        url = Url;
        icon_url = Icon_url;
        proxy_icon_url = Proxy_icon_url;
      }
    }
    public class DiscordField
    {
      public string name { get; set; }
      public string value { get; set; }
      public bool inline { get; set; }

      public DiscordField(string Name, string Value, bool Inline = false)
      {
        name = Name;
        value = Value;
        inline = Inline;
      }

    }
    #endregion DiscordEmbedMessage

    #region Interfaces

    private static string ReportLayer = "RAL_CommandHandlerUI";
    private void DrawReportInterface(BasePlayer player, int page = 0, string search = "", bool redraw = false, BasePlayer preselect = null)
    {
      var lineAmount = 6;
      var lineMargin = 8;

      var size = (float)(700 - lineMargin * lineAmount) / lineAmount;

      var list = new List<BasePlayer>();

      if (preselect != null)
      {
        list.Add(preselect);
      }

      list.AddRange(BasePlayer.activePlayerList.ToList().Where(v => v.userID != preselect?.userID));

      var finalList = list
          .FindAll(v => v.displayName.ToLower().Contains(search) || v.UserIDString.ToLower().Contains(search) || search == null)
          .Skip(page * 18)
          .Take(18);

      if (finalList.Count() == 0)
      {
        if (search == null)
        {
          DrawReportInterface(player, page - 1);
          return;
        }
      }

      CuiElementContainer container = new CuiElementContainer();

      if (!redraw)
      {
        container.Add(new CuiPanel
        {
          CursorEnabled = true,
          RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
          Image = { Color = "0 0 0 0.8", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
        }, "Overlay", ReportLayer, ReportLayer);

        container.Add(new CuiButton()
        {
          RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
          Button = { Color = HexToRustFormat("#343434"), Sprite = "assets/content/ui/ui.background.transparent.radial.psd", Close = ReportLayer },
          Text = { Text = "" }
        }, ReportLayer);
      }

      container.Add(new CuiPanel
      {
        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-368 -200", OffsetMax = "368 142" },
        Image = { Color = "1 0 0 0" }
      }, ReportLayer, ReportLayer + ".C", ReportLayer + ".C");

      container.Add(new CuiPanel
      {
        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-36 0", OffsetMax = "0 0" },
        Image = { Color = "0 0 1 0" }
      }, ReportLayer + ".C", ReportLayer + ".R");

      //↓ ↑

      container.Add(new CuiButton()
      {
        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.5", OffsetMin = "0 0", OffsetMax = "0 -4" },
        Button = { Color = HexToRustFormat($"#{(list.Count > 18 && finalList.Count() == 18 ? "D0C6BD4D" : "D0C6BD33")}"), Command = list.Count > 18 && finalList.Count() == 18 ? $"RAL_CommandHandler search {page + 1}" : "" },
        Text = { Text = "↓", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 24, Color = HexToRustFormat($"{(list.Count > 18 && finalList.Count() == 18 ? "D0C6BD" : "D0C6BD4D")}") }
      }, ReportLayer + ".R", ReportLayer + ".RD");

      container.Add(new CuiButton()
      {
        RectTransform = { AnchorMin = "0 0.5", AnchorMax = "1 1", OffsetMin = "0 4", OffsetMax = "0 0" },
        Button = { Color = HexToRustFormat($"#{(page == 0 ? "D0C6BD33" : "D0C6BD4D")}"), Command = page == 0 ? "" : $"RAL_CommandHandler search {page - 1}" },
        Text = { Text = "↑", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 24, Color = HexToRustFormat($"{(page == 0 ? "D0C6BD4D" : "D0C6BD")}") }
      }, ReportLayer + ".R", ReportLayer + ".RU");

      container.Add(new CuiPanel
      {
        RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-250 8", OffsetMax = "0 43" },
        Image = { Color = HexToRustFormat("#D0C6BD33") }
      }, ReportLayer + ".C", ReportLayer + ".S");

      container.Add(new CuiElement
      {
        Parent = ReportLayer + ".S",
        Components =
            {
                new CuiInputFieldComponent { Text = $"{lang.GetMessage("Header.Search.Placeholder", this, player.UserIDString)}", FontSize = 14, Font = "robotocondensed-regular.ttf", Color = HexToRustFormat("#D0C6BD80"), Align = TextAnchor.MiddleLeft, Command = "RAL_CommandHandler search 0", NeedsKeyboard = true},
                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 0", OffsetMax = "-85 0"}
            }
      });

      container.Add(new CuiButton
      {
        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-75 0", OffsetMax = "0 0" },
        Button = { Color = HexToRustFormat("#D0C6BD"), Material = "assets/icons/greyout.mat" },
        Text = { Text = $"{lang.GetMessage("Header.Search", this, player.UserIDString)}", Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#443F3B"), FontSize = 14, Align = TextAnchor.MiddleCenter }
      }, ReportLayer + ".S", ReportLayer + ".SB");

      container.Add(new CuiPanel
      {
        RectTransform = { AnchorMin = "0 1", AnchorMax = "0.5 1", OffsetMin = "0 7", OffsetMax = "0 47" },
        Image = { Color = "0.8 0.8 0.8 0" }
      }, ReportLayer + ".C", ReportLayer + ".LT");

      container.Add(new CuiLabel()
      {
        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
        Text = { Text = $"{lang.GetMessage("Header.Find", this, player.UserIDString)} {(search != null && search.Length > 0 ? $"- {(search.Length > 20 ? search.Substring(0, 14).ToUpper() + "..." : search.ToUpper())}" : "")}", Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#D0C6BD"), FontSize = 24, Align = TextAnchor.UpperLeft }
      }, ReportLayer + ".LT");

      container.Add(new CuiLabel()
      {
        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
        Text = { Text = search == null || search.Length == 0 ? lang.GetMessage("Header.SubDefault", this, player.UserIDString) : finalList.Count() == 0 ? lang.GetMessage("Header.SubFindEmpty", this, player.UserIDString) : lang.GetMessage("Header.SubFindResults", this, player.UserIDString), Font = "robotocondensed-regular.ttf", Color = HexToRustFormat("#D0C6BD4D"), FontSize = 14, Align = TextAnchor.LowerLeft }
      }, ReportLayer + ".LT");


      container.Add(new CuiPanel
      {
        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "-40 0" },
        Image = { Color = "0 1 0 0" }
      }, ReportLayer + ".C", ReportLayer + ".L");

      for (var y = 0; y < 3; y++)
      {
        for (var x = 0; x < 6; x++)
        {
          var target = finalList.ElementAtOrDefault(y * 6 + x);
          if (target)
          {
            container.Add(new CuiPanel
            {
              RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{x * size + lineMargin * x} -{(y + 1) * size + lineMargin * y}", OffsetMax = $"{(x + 1) * size + lineMargin * x} -{y * size + lineMargin * y}" },
              Image = { Color = HexToRustFormat("#D0C6BD33") }
            }, ReportLayer + ".L", ReportLayer + $".{target.UserIDString}");

            container.Add(new CuiElement
            {
              Parent = ReportLayer + $".{target.UserIDString}",
              Components =
                        {
                            new CuiRawImageComponent { SteamId = target.UserIDString, Sprite = "assets/icons/loading.png" },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                        }
            });

            container.Add(new CuiPanel()
            {
              RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
              Image = { Sprite = "assets/content/ui/ui.background.transparent.linear.psd", Color = HexToRustFormat("#282828f2") }
            }, ReportLayer + $".{target.UserIDString}");

            string normaliseName = NormalizeString(target.displayName);

            string name = normaliseName.Length > 14 ? normaliseName.Substring(0, 15) + ".." : normaliseName;

            container.Add(new CuiLabel
            {
              RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "6 16", OffsetMax = "0 0" },
              Text = { Text = name, Align = TextAnchor.LowerLeft, Font = "robotocondensed-bold.ttf", FontSize = 13, Color = HexToRustFormat("#D0C6BD") }
            }, ReportLayer + $".{target.UserIDString}");

            container.Add(new CuiLabel
            {
              RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "6 5", OffsetMax = "0 0" },
              Text = { Text = target.UserIDString, Align = TextAnchor.LowerLeft, Font = "robotocondensed-regular.ttf", FontSize = 10, Color = HexToRustFormat("#D0C6BD80") }
            }, ReportLayer + $".{target.UserIDString}");

            container.Add(new CuiButton()
            {
              RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
              Button = { Color = "0 0 0 0", Command = $"RAL_CommandHandler show {target.UserIDString} {x * size + lineMargin * x} -{(y + 1) * size + lineMargin * y} {(x + 1) * size + lineMargin * x} -{y * size + lineMargin * y}  {x >= 3}" },
              Text = { Text = "" }
            }, ReportLayer + $".{target.UserIDString}");
          }
          else
          {
            container.Add(new CuiPanel
            {
              RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{x * size + lineMargin * x} -{(y + 1) * size + lineMargin * y}", OffsetMax = $"{(x + 1) * size + lineMargin * x} -{y * size + lineMargin * y}" },
              Image = { Color = HexToRustFormat("#D0C6BD33") }
            }, ReportLayer + ".L");
          }
        }
      }

      CuiHelper.AddUi(player, container);

      if (preselect != null)
      {
        player.SendConsoleCommand($"RAL_CommandHandler show {preselect.UserIDString} 0 -{size} {size} 0 false");
      }
    }

    private static string HexToRustFormat(string hex)
    {
      if (string.IsNullOrEmpty(hex))
      {
        hex = "#FFFFFFFF";
      }

      var str = hex.Trim('#');

      if (str.Length == 6)
        str += "FF";

      if (str.Length != 8)
      {
        throw new Exception(hex);
        throw new InvalidOperationException("Cannot convert a wrong format.");
      }

      var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
      var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
      var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
      var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

      Color color = new Color32(r, g, b, a);

      return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
    }

    #endregion

    #region Variables


    private static RustAppLite _RustAppLite;
    private static Configuration _Settings;
    private Dictionary<ulong, double> _Cooldowns = new Dictionary<ulong, double>();

    #endregion

    #region Initialization

    private void OnServerInitialized()
    {
      _RustAppLite = this;

      if (_Settings.discord_webhook == null || _Settings.discord_webhook.Length < 5)
      {
        Error(
          "Установите discord_webhook в конфигурации плагина, и перезапустите плагин o.reload RustAppLite",
          "Setup discord_webhook in plugin config, then reload plugin o.reload RustAppLite"
        );
        return;
      }

      _Settings.report_ui_commands.ForEach(v =>
      {
        cmd.AddChatCommand(v, this, nameof(ChatCmdReport));
      });

      Log(
        "\nВы пользуетесь упрощённой версией плагина RustApp!\nВ полной версии есть:\n — статистика игрока\n — система вызова на проверку\n — бан система\n — история чата/команд\n — и многое другое на сайте: https://rustapp.io",
        "\nYou are using the simplified version of the RustApp plugin!\nThe full version includes:\n — player statistics\n — inspection system\n — ban system\n — chat/team history\n — and much more on the website: https://rustapp.io"
      );

      if (!_Settings.report_ui_auto_parse)
      {
        Unsubscribe(nameof(OnPlayerReported));
      }

      WriteLiteMarker();
    }

    private void WriteLiteMarker()
    {
      if (Interface.Oxide.DataFileSystem.ExistsDatafile(Name))
      {
        return;
      }

      // Is using in main plugin to detect users, who switched from Lite to main branch
      Interface.Oxide.DataFileSystem.WriteObject(Name, CurrentTime());
    }

    protected override void LoadDefaultMessages()
    {
      lang.RegisterMessages(new Dictionary<string, string>
      {
        ["Header.Find"] = "FIND PLAYER",
        ["Header.SubDefault"] = "Who do you want to report?",
        ["Header.SubFindResults"] = "Here are players, which we found",
        ["Header.SubFindEmpty"] = "No players was found",
        ["Header.Search"] = "Search",
        ["Header.Search.Placeholder"] = "Enter nickname/steamid",
        ["Subject.Head"] = "Select the reason for the report",
        ["Subject.SubHead"] = "For player %PLAYER%",
        ["Cooldown"] = "Wait %TIME% sec.",
        ["Sent"] = "Report succesful sent",
        ["Player.Not.Found"] = "Player with requested ID not found"
      }, this, "en");

      lang.RegisterMessages(new Dictionary<string, string>
      {
        ["Header.Find"] = "НАЙТИ ИГРОКА",
        ["Header.SubDefault"] = "На кого вы хотите пожаловаться?",
        ["Header.SubFindResults"] = "Вот игроки, которых мы нашли",
        ["Header.SubFindEmpty"] = "Игроки не найдены",
        ["Header.Search"] = "Поиск",
        ["Header.Search.Placeholder"] = "Введите ник/steamid",
        ["Subject.Head"] = "Выберите причину репорта",
        ["Subject.SubHead"] = "На игрока %PLAYER%",
        ["Cooldown"] = "Подожди %TIME% сек.",
        ["Sent"] = "Жалоба успешно отправлена",
        ["Player.Not.Found"] = "Игрок с указанным ID не найден"
      }, this, "ru");
    }


    private void Unload()
    {
      foreach (var player in BasePlayer.activePlayerList)
      {
        CuiHelper.DestroyUi(player, ReportLayer);
      }

      _RustAppLite = null;
      _Settings = null;
    }

    #endregion

    #region Hooks

    private void OnPlayerReported(BasePlayer reporter, string targetName, string targetId, string subject, string message, string type)
    {
      // TODO: Unsubscribed, if _Settings.report_ui_auto_parse is setted to false

      var target = BasePlayer.Find(targetId) ?? BasePlayer.FindSleeping(targetId);
      if (target == null)
      {
        return;
      }

      RA_ReportSend(reporter.UserIDString, targetId, type, message);
    }

    #endregion

    #region Commands

    [ConsoleCommand("RAL_CommandHandler")]
    private void CmdConsoleReportPanel(ConsoleSystem.Arg args)
    {
      var player = args.Player();
      if (player == null || !args.HasArgs(1))
      {
        return;
      }

      switch (args.Args[0].ToLower())
      {
        case "search":
          {
            int page = args.HasArgs(2) ? int.Parse(args.Args[1]) : 0;
            string search = args.HasArgs(3) ? args.Args[2] : "";

            Effect effect = new Effect("assets/prefabs/tools/detonator/effects/unpress.prefab", player, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(effect, player.Connection);

            DrawReportInterface(player, page, search, true);
            break;
          }
        case "show":
          {
            string targetId = args.Args[1];
            BasePlayer target = BasePlayer.Find(targetId) ?? BasePlayer.FindSleeping(targetId);

            Effect effect = new Effect("assets/prefabs/tools/detonator/effects/unpress.prefab", player, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(effect, player.Connection);

            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ReportLayer + $".T");

            container.Add(new CuiPanel
            {
              RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{args.Args[2]} {args.Args[3]}", OffsetMax = $"{args.Args[4]} {args.Args[5]}" },
              Image = { Color = "0 0 0 1" }
            }, ReportLayer + $".L", ReportLayer + $".T");


            container.Add(new CuiButton()
            {
              RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"-500 -500", OffsetMax = $"500 500" },
              Button = { Close = $"{ReportLayer}.T", Color = "0 0 0 1", Sprite = "assets/content/ui/ui.circlegradient.png" }
            }, ReportLayer + $".T");


            bool leftAlign = bool.Parse(args.Args[6]);
            container.Add(new CuiButton()
            {
              RectTransform = { AnchorMin = $"{(leftAlign ? -1 : 2)} 0", AnchorMax = $"{(leftAlign ? -2 : 3)} 1", OffsetMin = $"-500 -500", OffsetMax = $"500 500" },
              Button = { Close = $"{ReportLayer}.T", Color = HexToRustFormat("#343434"), Sprite = "assets/content/ui/ui.circlegradient.png" }
            }, ReportLayer + $".T");

            container.Add(new CuiButton()
            {
              RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"-1111111 -1111111", OffsetMax = $"1111111 1111111" },
              Button = { Close = $"{ReportLayer}.T", Color = "0 0 0 0.5", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, ReportLayer + $".T");


            container.Add(new CuiLabel
            {
              RectTransform = { AnchorMin = $"{(leftAlign ? "0" : "1")} 0", AnchorMax = $"{(leftAlign ? "0" : "1")} 1", OffsetMin = $"{(leftAlign ? "-350" : "20")} 0", OffsetMax = $"{(leftAlign ? "-20" : "350")} -5" },
              Text = { FadeIn = 0.4f, Text = lang.GetMessage("Subject.Head", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#D0C6BD"), FontSize = 24, Align = leftAlign ? TextAnchor.UpperRight : TextAnchor.UpperLeft }
            }, ReportLayer + ".T");

            container.Add(new CuiLabel
            {
              RectTransform = { AnchorMin = $"{(leftAlign ? "0" : "1")} 0", AnchorMax = $"{(leftAlign ? "0" : "1")} 1", OffsetMin = $"{(leftAlign ? "-250" : "20")} 0", OffsetMax = $"{(leftAlign ? "-20" : "250")} -35" },
              Text = { FadeIn = 0.4f, Text = $"{lang.GetMessage("Subject.SubHead", this, player.UserIDString).Replace("%PLAYER%", $"<b>{target.displayName}</b>")}", Font = "robotocondensed-regular.ttf", Color = HexToRustFormat("#D0C6BD80"), FontSize = 14, Align = leftAlign ? TextAnchor.UpperRight : TextAnchor.UpperLeft }
            }, ReportLayer + ".T");

            container.Add(new CuiElement
            {
              Parent = ReportLayer + $".T",
              Components =
              {
                  new CuiRawImageComponent { SteamId = target.UserIDString, Sprite = "assets/icons/loading.png" },
                  new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
              }
            });

            for (var i = 0; i < _Settings.report_ui_reasons.Count; i++)
            {
              var offXMin = (20 + (i * 5)) + i * 80;
              var offXMax = 20 + (i * 5) + (i + 1) * 80;

              container.Add(new CuiButton()
              {
                RectTransform = { AnchorMin = $"{(leftAlign ? 0 : 1)} 0", AnchorMax = $"{(leftAlign ? 0 : 1)} 0", OffsetMin = $"{(leftAlign ? -offXMax : offXMin)} 15", OffsetMax = $"{(leftAlign ? -offXMin : offXMax)} 45" },
                Button = { FadeIn = 0.4f + i * 0.2f, Color = HexToRustFormat("#D0C6BD4D"), Command = $"RAL_CommandHandler report {target.UserIDString} {_Settings.report_ui_reasons[i].Replace(" ", "0")}" },
                Text = { FadeIn = 0.4f + i * 0.2f, Text = $"{_Settings.report_ui_reasons[i]}", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#D0C6BD"), Font = "robotocondensed-bold.ttf", FontSize = 16 }
              }, ReportLayer + $".T");
            }

            CuiHelper.AddUi(player, container);
            break;
          }
        case "report":
          {
            if (!_Cooldowns.ContainsKey(player.userID))
            {
              _Cooldowns.Add(player.userID, 0);
            }

            if (_Cooldowns[player.userID] > CurrentTime())
            {
              var msg = lang.GetMessage("Cooldown", this, player.UserIDString).Replace("%TIME%",
                  $"{(_Cooldowns[player.userID] - CurrentTime()).ToString("0")}");

              SoundToast(player, msg, 1);
              return;
            }

            string targetId = args.Args[1];
            string reason = args.Args[2].Replace("0", "");

            BasePlayer target = BasePlayer.Find(targetId) ?? BasePlayer.FindSleeping(targetId);

            RA_ReportSend(player.UserIDString, target.UserIDString, reason, "");
            CuiHelper.DestroyUi(player, ReportLayer);

            SoundToast(player, lang.GetMessage("Sent", this, player.UserIDString), 2);

            _Cooldowns[player.userID] = CurrentTime() + _Settings.report_ui_cooldown;
            break;
          }
      }
    }

    private void ChatCmdReport(BasePlayer player, string command, string[] args)
    {
      var over = Interface.Oxide.CallHook("RustApp_CanOpenReportUI", player);
      if (over != null)
      {
        return;
      }

      if (!_Cooldowns.ContainsKey(player.userID))
      {
        _Cooldowns.Add(player.userID, 0);
      }

      if (_Cooldowns[player.userID] > CurrentTime())
      {
        var msg = lang.GetMessage("Cooldown", this, player.UserIDString).Replace("%TIME%",
            $"{(_Cooldowns[player.userID] - CurrentTime()).ToString("0")}");

        SoundToast(player, msg, 1);
        return;
      }

      if (args != null && args.Length == 1 && args[0].Length == 17)
      {
        var target = BasePlayer.FindAwakeOrSleeping(args[0]);
        if (target == null || !target.IsConnected)
        {
          SoundToast(player, lang.GetMessage("Player.Not.Found", this, player.UserIDString), 1);
          return;
        }

        DrawReportInterface(player, 0, "", false, target);
        return;
      }

      DrawReportInterface(player);
    }

    #endregion

    #region User Manipulation 

    private void SoundInfoToast(BasePlayer player, string text)
    {
      SoundToast(player, text, 2);
    }

    private void SoundErrorToast(BasePlayer player, string text)
    {
      SoundToast(player, text, 1);
    }

    private void SoundToast(BasePlayer player, string text, int type)
    {
      Effect effect = new Effect("assets/bundled/prefabs/fx/notice/item.select.fx.prefab", player, 0, new Vector3(), new Vector3());
      EffectNetwork.Send(effect, player.Connection);

      player.Command("gametip.showtoast", type, text, 1);
    }

    #endregion

    #region Discord

    private void RA_ReportSend(string initiator_steam_id, string target_steam_id, string reason, string message = "")
    {
      var author = permission.GetUserData(initiator_steam_id);
      var target = permission.GetUserData(target_steam_id);

      var list = new DiscordField[4] {
        new DiscordField(_Settings.discord_translations_nickname, $"```{target.LastSeenNickname}```", false),
        new DiscordField($"SteamID", $"```{target_steam_id}```", true),
        new DiscordField(_Settings.discord_translations_reason, @$"```ansi
[2;31m{reason}[0m
```", true),
        null
      };

      if (message != null && message.Length > 0)
      {
        list[3] = new DiscordField(_Settings.discord_translations_comment, $"```{message}```", false);
      }

      DiscordEmbed embed = new DiscordEmbed("", $" ", null, list.Where(v => v != null).ToArray(), new DiscordFooter($"{_Settings.discord_translations_report_sent}: {author.LastSeenNickname} [{initiator_steam_id}]", "", ""));
      DiscordMessage req = new DiscordMessage(null, new DiscordEmbed[1] { embed });

      req.Send(_Settings.discord_webhook);
    }

    #endregion

    #region Utils

    private double CurrentTime() => DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;

    private static List<char> Letters = new List<char> { '☼', 's', 't', 'r', 'e', 'т', 'ы', 'в', 'о', 'ч', 'х', 'а', 'р', 'u', 'c', 'h', 'a', 'n', 'z', 'o', '^', 'm', 'l', 'b', 'i', 'p', 'w', 'f', 'k', 'y', 'v', '$', '+', 'x', '1', '®', 'd', '#', 'г', 'ш', 'к', '.', 'я', 'у', 'с', 'ь', 'ц', 'и', 'б', 'е', 'л', 'й', '_', 'м', 'п', 'н', 'g', 'q', '3', '4', '2', ']', 'j', '[', '8', '{', '}', '_', '!', '@', '#', '$', '%', '&', '?', '-', '+', '=', '~', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ь', 'ы', 'ъ', 'э', 'ю', 'я' };

    private static string NormalizeString(string text)
    {
      string name = "";

      foreach (var @char in text)
      {
        if (Letters.Contains(@char.ToString().ToLower().ToCharArray()[0]))
          name += @char;
      }

      return name;
    }


    private long getUnixTime()
    {
      return ((DateTimeOffset)DateTime.UtcNow).ToUnixTimeSeconds();
    }

    #endregion

    #region Messages

    public void Log(string ru, string en)
    {
      if (lang.GetServerLanguage() == "ru")
      {
        Puts(ru);
      }
      else
      {
        Puts(en);
      }
    }

    public void Warning(string ru, string en)
    {
      if (lang.GetServerLanguage() == "ru")
      {
        PrintWarning(ru);
      }
      else
      {
        PrintWarning(en);
      }
    }

    public void Error(string ru, string en)
    {
      if (lang.GetServerLanguage() == "ru")
      {
        PrintError(ru);
      }
      else
      {
        PrintError(en);
      }
    }

    #endregion
  }
} 

// --- End of file: RustAppLite.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/raid-alarm ---
// --- Original File Path: R/RaidAlarm/RaidAlarm.cs ---

using System;
using System.Collections.Generic;
using CompanionServer;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("Raid Alarm", "haggbart", "0.4.0")]
    [Description("Receive raid notifications through the official Rust companion mobile app")]
    internal class RaidAlarm : RustPlugin
    {
        #region init, data and cleanup

        private static HashSet<ulong> disabled = new HashSet<ulong>();

        private const string PERMISSION = "raidalarm.use";

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, disabled);

        private void ReadData() => disabled = Interface.Oxide.DataFileSystem.ReadObject<HashSet<ulong>>(Name);

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
            permission.RegisterPermission(PERMISSION, this);
            ReadData();
        }

        private void OnServerSave() => SaveData();

        private void Unload() => SaveData();

        #endregion


        #region config

        private PluginConfig config;

        private class PluginConfig
        {
            public bool usePermissions;
        }

        protected override void LoadDefaultConfig() => Config.WriteObject(GetDefaultConfig(), true);
        private new void SaveConfig() => Config.WriteObject(config, true);

        private static PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                usePermissions = false
            };
        }

        #endregion config


        #region localization

        private static class Loc
        {
            public const string TITLE = "AlarmTitle";
            public const string BODY = "AlarmBody";
            public const string HELP = "AlarmHelp";
            public const string HELP_COMMANDS = "AlarmHelpCommands";
            public const string STATUS_ENABLED = "AlarmStatusEnabled";
            public const string STATUS_DISABLED = "AlarmStatusDisabled";
            public const string TEST_SENT = "AlarmTestSent";
            public const string TEST_DESTROYED = "AlarmTestDestroyedItem";
            public const string NO_PERMISSION = "NoPermission";
        }

        private string GetStatusText(BasePlayer player)
        {
            return lang.GetMessage(disabled.Contains(player.userID) ? Loc.STATUS_DISABLED : Loc.STATUS_ENABLED, this, player.UserIDString);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Loc.TITLE] = "You're getting raided!",
                [Loc.BODY] = "{0} destroyed at {1}",
                [Loc.HELP] = "To receive Raid Alarm notifications, " +
                             "you need the official Rust+ companion app on your mobile device and pair it this server. " +
                             "To do this, press Esc and click \"Rust+\" in main menu.\n\n" +
                             "Use /raidalarm test to test your alarm. To do disable, use /raidalarm disable",
                [Loc.HELP_COMMANDS] = "Available commands: \n/raidalarm status|enable|disable|test",
                [Loc.STATUS_ENABLED] = "Raid Alarm is enabled.",
                [Loc.STATUS_DISABLED] = "Raid Alarm is disabled.",
                [Loc.TEST_SENT] = "Test notification sent. If you don't receive it, make sure you're paired with the server.",
                [Loc.TEST_DESTROYED] = "chair",
                [Loc.NO_PERMISSION] = "You don't have the permission to use this command."
            }, this);
        }

        #endregion

        private readonly Dictionary<string, DateTime> raidblocked = new Dictionary<string, DateTime>();
        private DateTime lastAttack = DateTime.Now;

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null) return;

            if (!IsRaidEntity(entity)) return;
            if (info.InitiatorPlayer == null) return;

            // prevent spam
            TimeSpan timesince = DateTime.Now - lastAttack;
            if (timesince.TotalSeconds < 1) return;
            lastAttack = DateTime.Now;

            var buildingPrivilege = entity.GetBuildingPrivilege();
            if (buildingPrivilege == null || buildingPrivilege.authorizedPlayers.IsEmpty()) return;

            var victims = new List<ulong>(buildingPrivilege.authorizedPlayers.Count);
            foreach (PlayerNameID victim in buildingPrivilege.authorizedPlayers)
            {
                if (victim == null) continue;
                if (config.usePermissions && !permission.UserHasPermission(victim.userid.ToString(), PERMISSION)) continue;
                if (victim.userid == info.InitiatorPlayer.userID) return;
                if (disabled.Contains(victim.userid)) continue;
                victims.Add(victim.userid);
            }

            // raidblock
            String grid = GetGrid(entity.transform.position);
            raidblocked[grid] = lastAttack;

            NotificationList.SendNotificationTo(victims, NotificationChannel.SmartAlarm, lang.GetMessage(Loc.TITLE, this),
                string.Format(lang.GetMessage(Loc.BODY, this), entity.ShortPrefabName, grid), Util.GetServerPairingData());
        }

        private static bool IsRaidEntity(BaseCombatEntity entity)
        {
            if (entity is Door) return true;

            if (!(entity is BuildingBlock)) return false;

            return ((BuildingBlock) entity).grade != BuildingGrade.Enum.Twigs;
        }

        private static string GetGrid(Vector3 pos)
        {
            const float scale = 150f;
            float x = pos.x + World.Size / 2f;
            float z = pos.z + World.Size / 2f;
            int lat = (int) (x / scale);
            char latChar = (char) ('A' + lat);
            int lon = (int) (World.Size / scale - z / scale);
            return latChar + lon.ToString();
        }

        [ChatCommand("raidalarm")]
        private void ChatRaidAlarm(BasePlayer player, string command, string[] args)
        {
            if (config.usePermissions && !permission.UserHasPermission(player.UserIDString, PERMISSION))
            {
                SendReply(player, lang.GetMessage(Loc.NO_PERMISSION, this, player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, lang.GetMessage(Loc.HELP, this, player.UserIDString));
                return;
            }

            switch (args[0].ToLower())
            {
                case "status":
                    SendReply(player, GetStatusText(player));
                    break;
                case "enable":
                    disabled.Remove(player.userID);
                    SendReply(player, lang.GetMessage(Loc.STATUS_ENABLED, this, player.UserIDString));
                    break;
                case "disable":
                    disabled.Add(player.userID);
                    SendReply(player, lang.GetMessage(Loc.STATUS_DISABLED, this, player.UserIDString));
                    break;
                case "test":
                    if (disabled.Contains(player.userID))
                    {
                        SendReply(player, lang.GetMessage(Loc.STATUS_DISABLED, this, player.UserIDString));
                        return;
                    }

                    NotificationList.SendNotificationTo(player.userID, NotificationChannel.SmartAlarm,
                        lang.GetMessage(Loc.TITLE, this, player.UserIDString),
                        string.Format(lang.GetMessage(Loc.BODY, this, player.UserIDString),
                            string.Format(lang.GetMessage(Loc.TEST_DESTROYED, this, player.UserIDString)),
                            GetGrid(player.transform.position)), Util.GetServerPairingData());
                    SendReply(player, lang.GetMessage(Loc.TEST_SENT, this, player.UserIDString));
                    break;
                default:
                    SendReply(player, lang.GetMessage(Loc.HELP_COMMANDS, this, player.UserIDString));
                    break;
            }
        }

        #region Dev API

        private bool IsRaidBlocked(BasePlayer player)
        {
            DateTime now;
            return raidblocked.TryGetValue(GetGrid(player.transform.position), out now) && (DateTime.Now - now).TotalHours < 1;
        }

        #endregion Dev API
    }
}


// --- End of file: RaidAlarm.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/recycle-manager ---
// --- Original File Path: R/RecycleManager/RecycleManager.cs ---

﻿// #define ENABLE_TESTS

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Libraries;
using UnityEngine;

#if ENABLE_TESTS
using System.Collections;
using System.Reflection;
using Oxide.Core.Plugins;
#endif

namespace Oxide.Plugins
{
    [Info("Recycle Manager", "WhiteThunder", "2.1.0")]
    [Description("Allows customizing recycler speed, input, and output")]
    internal class RecycleManager : CovalencePlugin
    {
        #region Fields

        private Configuration _config;

        private const string PermissionAdmin = "recyclemanager.admin";

        private const int ScrapItemId = -932201673;
        private const float ClassicRecycleEfficiency = 0.5f;
        private const float VanillaMaxItemsInStackFraction = 0.1f;

        private readonly object True = true;
        private readonly object False = false;

        private const int NumInputSlots = 6;
        private const int NumOutputSlots = 6;

        private readonly RecyclerComponentManager _recyclerComponentManager = new();
        private readonly RecycleEditManager _recycleEditManager;
        private readonly float[] _recycleTime = new float[1];
        private readonly float[] _recycleEfficiency = new float[1];

        private static readonly FieldInfo ScrapRemainderField = typeof(Recycler).GetField("scrapRemainder", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

        private bool IsEditUIEnabled => !_config.UsingDefaults && _config.EditUISettings.Enabled;

        #if ENABLE_TESTS
        private readonly RecycleManagerTests _testRunner;
        #endif

        public RecycleManager()
        {
            #if ENABLE_TESTS
            _testRunner = new RecycleManagerTests(this);
            #endif

            _recycleEditManager = new RecycleEditManager(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init(this);
            _recyclerComponentManager.Init(this);

            permission.RegisterPermission(PermissionAdmin, this);

            if (!_config.Speed.Enabled && !_config.Efficiency.Enabled)
            {
                Unsubscribe(nameof(OnRecyclerToggle));
            }

            if (!IsEditUIEnabled)
            {
                Unsubscribe(nameof(OnLootEntity));
            }
        }

        private void OnServerInitialized()
        {
            #if ENABLE_TESTS
            _testRunner.Run();
            #endif

            if (IsEditUIEnabled)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    var container = player.inventory.loot.containers.FirstOrDefault();
                    if (container == null)
                        continue;

                    var recycler = container.entityOwner as Recycler;
                    if ((object)recycler == null)
                        continue;

                    OnLootEntity(player, recycler);
                }
            }
        }

        private void Unload()
        {
            #if ENABLE_TESTS
            _testRunner.Interrupt();
            #endif

            _recyclerComponentManager.Unload();
            _recycleEditManager.Unload();
        }

        // This hook is primarily used to determine whether an item can be placed into the recycler input,
        // but it's also called when processing each item.
        private object CanBeRecycled(Item item, Recycler recycler)
        {
            if (item == null)
                return null;

            if (_config.RestrictedInputItems.IsDisallowed(item))
            {
                // Defensively return null if vanilla would *disallow* recycling, to avoid hook conflicts.
                return IsVanillaRecyclable(item) && !RecyclableWasBlocked(item, recycler)
                    ? False
                    : null;
            }

            if (_config.OverrideOutput.GetBestOverride(item) != null)
            {
                // Defensively return null if vanilla would *allow* recycling, to avoid hook conflicts.
                return IsVanillaRecyclable(item) || RecyclableWasBlocked(item, recycler)
                    ? null
                    : True;
            }

            return null;
        }

        private object CanRecycle(Recycler recycler, Item item)
        {
            return CanBeRecycled(item, recycler);
        }

        private void OnRecyclerToggle(Recycler recycler, BasePlayer player)
        {
            _recyclerComponentManager.HandleRecyclerToggle(recycler, player);
        }

        private object OnItemRecycle(Item item, Recycler recycler)
        {
            if (RecycleItemWasBlocked(item, recycler))
                return null;

            var maxItemsInStackFraction = _config.MaxItemsPerRecycle.GetPercent(item) / 100f;
            var recycleAmount = DetermineConsumptionAmount(recycler, item, maxItemsInStackFraction);
            if (recycleAmount <= 0)
                return False;

            var customIngredientList = _config.OverrideOutput.GetBestOverride(item);
            if (customIngredientList != null)
            {
                item.UseItem(recycleAmount);

                // Overrides already account for standard recycle efficiency, so only calculate based on item condition.
                if (PopulateOutputWithOverride(recycler, customIngredientList, recycleAmount, DetermineItemRecycleEfficiency(item, 1f)))
                {
                    recycler.StopRecycling();
                }

                return False;
            }

            // If the item is not vanilla recyclable, and this plugin doesn't have an override,
            // that probably means another plugin is going to handle recycling it.
            if (!IsVanillaRecyclable(item))
                return null;

            // Issue: Last known player will always be null if speed and efficiency are both disabled, since toggle hook
            // is not subscribed to improve performance.
            var lastKnownPlayer = _recyclerComponentManager.EnsureRecyclerComponent(recycler).Player;
            var recycleEfficiency = DetermineItemRecycleEfficiency(item, GetRecyclerEfficiency(recycler, lastKnownPlayer, out var vanillaEfficiency));

            if (recycleEfficiency == vanillaEfficiency
                && maxItemsInStackFraction == VanillaMaxItemsInStackFraction
                && !IsOutputCustomized(item.info.Blueprint))
                return null;

            item.UseItem(recycleAmount);

            var outputIsFull = PopulateOutputVanilla(_config, recycler, item, recycleAmount, recycleEfficiency);
            if (outputIsFull || !recycler.HasRecyclable())
            {
                recycler.StopRecycling();
            }

            return False;
        }

        private void OnLootEntity(BasePlayer player, Recycler recycler)
        {
            if (!recycler.onlyOneUser)
                return;

            if (permission.UserHasPermission(player.UserIDString, PermissionAdmin))
            {
                var player2 = player;
                var recycler2 = recycler;
                NextTick(() =>
                {
                    var lootingContainer = player2.inventory.loot.containers.FirstOrDefault();
                    if (lootingContainer == null || lootingContainer != recycler2.inventory)
                        return;

                    _recycleEditManager.HandlePlayerStartedLooting(player2, recycler2);
                });
            }
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnRecycleManagerItemRecyclable(Item item, Recycler recycler)
            {
                return Interface.CallHook("OnRecycleManagerItemRecyclable", item, recycler);
            }

            public static object OnRecycleManagerSpeed(Recycler recycler, BasePlayer player, float[] recycleTime)
            {
                return Interface.CallHook("OnRecycleManagerSpeed", recycler, player, recycleTime);
            }

            public static void OnRecycleManagerEfficiency(Recycler recycler, BasePlayer player, float[] recyclerEfficiency)
            {
                Interface.CallHook("OnRecycleManagerEfficiency", recycler, player, recyclerEfficiency);
            }

            public static object OnRecycleManagerRecycle(Item item, Recycler recycler)
            {
                return Interface.CallHook("OnRecycleManagerRecycle", item, recycler);
            }
        }

        #endregion

        #region Commands

        [Command("recyclemanager.add", "recman.add")]
        private void CommandAddItem(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyHasPermission(player, PermissionAdmin)
                || !VerifyConfigLoaded(player))
                return;

            if (!VerifyValidItemIdOrShortName(player, args.ElementAtOrDefault(0), out var itemDefinition, cmd))
                return;

            if (!_config.OverrideOutput.AddOverride(this, itemDefinition))
            {
                ReplyToPlayer(player, LangEntry.AddExists, itemDefinition.shortname);
                return;
            }

            SaveConfig();
            ReplyToPlayer(player, LangEntry.AddSuccess, itemDefinition.shortname);
        }

        [Command("recyclemanager.reset", "recman.reset")]
        private void CommandResetItem(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyHasPermission(player, PermissionAdmin)
                || !VerifyConfigLoaded(player))
                return;

            if (!VerifyValidItemIdOrShortName(player, args.ElementAtOrDefault(0), out var itemDefinition, cmd))
                return;

            _config.OverrideOutput.ResetOverride(this, itemDefinition);
            SaveConfig();
            ReplyToPlayer(player, LangEntry.ResetSuccess, itemDefinition.shortname);
        }

        [Command("recyclemanager.ui")]
        private void CommandEdit(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer || !player.HasPermission(PermissionAdmin))
                return;

            var basePlayer = player.Object as BasePlayer;
            _recycleEditManager.GetController(basePlayer)?.HandleUICommand(basePlayer, args);
        }

        #endregion

        #region Utilities

        private readonly struct ReflectionAdapter<T>
        {
            private readonly FieldInfo _fieldInfo;
            private readonly object _object;

            public ReflectionAdapter(object obj, FieldInfo fieldInfo)
            {
                _object = obj;
                _fieldInfo = fieldInfo;
            }

            public T Value
            {
                get => _fieldInfo == null ? default : (T)_fieldInfo.GetValue(_object);
                set => _fieldInfo?.SetValue(_object, value);
            }

            public static implicit operator T(ReflectionAdapter<T> adapter)
            {
                return adapter.Value;
            }
        }

        #endregion

        #region Helper Methods - Instance

        private bool VerifyHasPermission(IPlayer player, string perm)
        {
            if (player.HasPermission(perm))
                return true;

            ReplyToPlayer(player, LangEntry.ErrorNoPermission);
            return false;
        }

        private bool VerifyConfigLoaded(IPlayer player)
        {
            if (!_config.UsingDefaults)
                return true;

            ReplyToPlayer(player, LangEntry.ErrorConfig);
            return false;
        }

        private bool VerifyValidItemIdOrShortName(IPlayer player, string itemArg, out ItemDefinition itemDefinition, string command)
        {
            if (itemArg == null)
            {
                itemDefinition = (player.Object as BasePlayer)?.GetActiveItem()?.info;
                if (itemDefinition != null)
                    return true;

                ReplyToPlayer(player, LangEntry.ItemSyntax, command);
                return false;
            }

            if (int.TryParse(itemArg, out var itemId))
            {
                itemDefinition = ItemManager.FindItemDefinition(itemId);
                if (itemDefinition != null)
                    return true;
            }

            itemDefinition = ItemManager.FindItemDefinition(itemArg);
            if (itemDefinition != null)
                return true;

            ReplyToPlayer(player, LangEntry.ErrorInvalidItem, itemArg);
            return false;
        }

        private float GetRecyclerEfficiency(Recycler recycler, BasePlayer player, out float vanillaEfficiency)
        {
            vanillaEfficiency = DetermineVanillaRecycleEfficiency(recycler);

            _recycleEfficiency[0] = _config.Efficiency.Enabled
                ? _config.Efficiency.GetRecyclerEfficiency(recycler)
                : vanillaEfficiency;

            ExposedHooks.OnRecycleManagerEfficiency(recycler, player, _recycleEfficiency);
            return Mathf.Max(0, _recycleEfficiency[0]);
        }

        private bool TryDetermineRecycleTime(Recycler recycler, BasePlayer player, out float recycleTime)
        {
            _recycleTime[0] = _config.Speed.DefaultRecycleTime
                              * _config.Speed.GetTimeMultiplierForPlayer(player);

            if (_config.Speed.SafeZoneTimeMultiplier != 1 && player.InSafeZone())
            {
                _recycleTime[0] *= _config.Speed.SafeZoneTimeMultiplier;
            }

            if (ExposedHooks.OnRecycleManagerSpeed(recycler, player, _recycleTime) is false)
            {
                recycleTime = 0;
                return false;
            }

            recycleTime = Math.Max(0, _recycleTime[0]);
            return true;
        }

        private object CallCanBeRecycled(Item item, Recycler recycler)
        {
            Unsubscribe(nameof(CanBeRecycled));
            var hookResult = Interface.CallHook(nameof(CanBeRecycled), item, recycler);
            Subscribe(nameof(CanBeRecycled));
            return hookResult;
        }

        private bool IsOutputCustomized(ItemBlueprint blueprint)
        {
            if (blueprint.scrapFromRecycle > 0 && _config.OutputMultipliers.GetOutputMultiplier(ScrapItemId) != 1)
                return true;

            foreach (var ingredient in blueprint.ingredients)
            {
                // Skip scrap since it's handled separately.
                if (ingredient.itemDef.itemid == ScrapItemId)
                    continue;

                if (_config.OutputMultipliers.GetOutputMultiplier(ingredient.itemid) != 1)
                    return true;
            }

            return false;
        }

        #endregion

        #region Helper Methods - Static

        public static void LogError(string message) => Interface.Oxide.LogError($"[Recycle Manager] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Recycle Manager] {message}");

        private static void Swap<T>(ref T a, ref T b)
        {
            (a, b) = (b, a);
        }

        private static bool IsVanillaRecyclable(Item item)
        {
            return item.info.Blueprint != null;
        }

        private static bool RecyclableWasBlocked(Item item, Recycler recycler)
        {
            return ExposedHooks.OnRecycleManagerItemRecyclable(item, recycler) is false;
        }

        private static bool RecycleItemWasBlocked(Item item, Recycler recycler)
        {
            return ExposedHooks.OnRecycleManagerRecycle(item, recycler) is false;
        }

        private static Item CreateItem(ItemDefinition itemDefinition, int amount, ulong skinId, string displayName = null)
        {
            var item = ItemManager.Create(itemDefinition, amount, skinId);

            if (!string.IsNullOrWhiteSpace(displayName))
            {
                item.name = displayName;
            }

            return item;
        }

        private static int CalculateOutputAmountVanillaRandom(int recycleAmount, float adjustedIngredientChance)
        {
            var outputAmount = 0;

            // Roll a random number for every item to consume.
            for (var i = 0; i < recycleAmount; i++)
            {
                if (UnityEngine.Random.Range(0f, 1f) <= adjustedIngredientChance)
                {
                    outputAmount++;
                }
            }

            return outputAmount;
        }

        private static int CalculateOutputAmountFast(int recycleAmount, float ingredientAmount)
        {
            // To save on performance, don't generate hundreds/thousands/millions of random numbers.
            var outputAmountDecimal = ingredientAmount * recycleAmount;

            var outputAmountInt = (int)outputAmountDecimal;

            // Roll a random number to see if the the remainder should be given.
            var remainderFractionalOutputAmount = outputAmountDecimal - outputAmountInt;
            if (remainderFractionalOutputAmount > 0 && UnityEngine.Random.Range(0f, 1f) <= remainderFractionalOutputAmount)
            {
                outputAmountInt++;
            }

            return outputAmountInt;
        }

        private static int CalculateOutputAmountRandom(int recycleAmount, float ingredientAmount, float recycleEfficiency, float outputMultiplier)
        {
            var adjustedIngredientAmount = ingredientAmount * outputMultiplier;
            if (adjustedIngredientAmount <= 1 && recycleAmount <= 100)
                return CalculateOutputAmountVanillaRandom(recycleAmount, adjustedIngredientAmount * recycleEfficiency);

            return CalculateOutputAmountFast(recycleAmount, adjustedIngredientAmount * recycleEfficiency);
        }

        private static int CalculateOutputAmountNoRandom(int recycleAmount, float ingredientAmount, float recycleEfficiency, float outputMultiplier)
        {
            var adjustedIngredientAmount = Mathf.CeilToInt(ingredientAmount * recycleEfficiency) * outputMultiplier;
            return CalculateOutputAmountFast(recycleAmount, adjustedIngredientAmount);
        }

        private static int CalculateOutputAmount(int recycleAmount, float ingredientAmount, float recycleEfficiency, float outputMultiplier = 1)
        {
            if (ingredientAmount <= 1)
                return CalculateOutputAmountRandom(recycleAmount, ingredientAmount, recycleEfficiency, outputMultiplier);

            return CalculateOutputAmountNoRandom(recycleAmount, ingredientAmount, recycleEfficiency, outputMultiplier);
        }

        private static bool AddItemToRecyclerOutput(Recycler recycler, ItemDefinition itemDefinition, int ingredientAmount, ulong skinId = 0, string displayName = null)
        {
            var outputIsFull = false;
            var numStacks = Mathf.CeilToInt(ingredientAmount / (float)itemDefinition.stackable);

            for (var i = 0; i < numStacks; i++)
            {
                var amountForStack = Math.Min(ingredientAmount, itemDefinition.stackable);
                var outputItem = CreateItem(itemDefinition, amountForStack, skinId, displayName);

                if (!recycler.MoveItemToOutput(outputItem))
                {
                    outputIsFull = true;
                }

                ingredientAmount -= amountForStack;

                if (ingredientAmount <= 0)
                    break;
            }

            return outputIsFull;
        }

        private static float DetermineVanillaRecycleEfficiency(Recycler recycler)
        {
            return recycler.IsSafezoneRecycler()
                ? recycler.safezoneRecycleEfficiency
                : recycler.radtownRecycleEfficiency;
        }

        private static IngredientInfo[] GetVanillaOutput(ItemDefinition itemDefinition)
        {
            if (itemDefinition.Blueprint?.ingredients == null)
                return Array.Empty<IngredientInfo>();

            var ingredientList = new List<IngredientInfo>();

            if (itemDefinition.Blueprint.scrapFromRecycle > 0)
            {
                var ingredientInfo = new IngredientInfo
                {
                    ShortName = "scrap",
                    Amount = itemDefinition.Blueprint.scrapFromRecycle,
                };
                ingredientInfo.Init();
                ingredientList.Add(ingredientInfo);
            }

            foreach (var blueprintIngredient in itemDefinition.Blueprint.ingredients)
            {
                if (blueprintIngredient.itemid == ScrapItemId)
                    continue;

                var amount = blueprintIngredient.amount / itemDefinition.Blueprint.amountToCreate * ClassicRecycleEfficiency;
                if (amount > 1)
                {
                    amount = Mathf.CeilToInt(amount);
                }

                var ingredientInfo = new IngredientInfo
                {
                    ShortName = blueprintIngredient.itemDef.shortname,
                    Amount = amount,
                };

                ingredientInfo.Init();
                ingredientList.Add(ingredientInfo);
            }

            return ingredientList.ToArray();
        }

        private static float DetermineItemRecycleEfficiency(Item item, float recyclerEfficiency)
        {
            return item.hasCondition
                ? Mathf.Clamp01(recyclerEfficiency * Mathf.Clamp(item.conditionNormalized * item.maxConditionNormalized, 0.1f, 1f))
                : recyclerEfficiency;
        }

        private static int DetermineConsumptionAmount(Recycler recycler, Item item, float maxItemsInStackFraction)
        {
            var recycleAmount = 1;

            if (item.amount > 1)
            {
                recycleAmount = Mathf.CeilToInt(Mathf.Min(item.amount, item.MaxStackable() * maxItemsInStackFraction));

                // In case the configured multiplier is 0, ensure at least 1 item is recycled.
                recycleAmount = Math.Max(recycleAmount, 1);
            }

            // Call standard Oxide hook for compatibility.
            if (Interface.CallHook("OnItemRecycleAmount", item, recycleAmount, recycler) is int overrideAmount)
                return overrideAmount;

            return recycleAmount;
        }

        private static bool PopulateOutputWithOverride(Recycler recycler, IngredientInfo[] customIngredientList, int recycleAmount, float recycleEfficiency = 1, bool forEditor = false)
        {
            var outputIsFull = false;

            foreach (var ingredientInfo in customIngredientList)
            {
                if (ingredientInfo.ItemDefinition == null)
                    continue;

                var ingredientAmount = ingredientInfo.Amount;
                if (ingredientAmount <= 0)
                    continue;

                var outputAmount = CalculateOutputAmount(recycleAmount, ingredientAmount, recycleEfficiency);
                if (outputAmount <= 0)
                    continue;

                if (forEditor && outputAmount < 1)
                {
                    outputAmount = 1;
                }

                if (AddItemToRecyclerOutput(recycler, ingredientInfo.ItemDefinition, outputAmount, ingredientInfo.SkinId, ingredientInfo.DisplayName))
                {
                    outputIsFull = true;
                }
            }

            return outputIsFull;
        }

        private static bool PopulateOutputVanilla(Configuration config, Recycler recycler, Item item, int recycleAmount, float recycleEfficiency)
        {
            var outputIsFull = false;

            if (item.info.Blueprint.scrapFromRecycle > 0)
            {
                var scrapOutputMultiplier = config.OutputMultipliers.GetOutputMultiplier(ScrapItemId);
                var scrapAmountDecimal = item.info.Blueprint.scrapFromRecycle * (float)recycleAmount * scrapOutputMultiplier;

                if (item.MaxStackable() == 1 && item.hasCondition)
                {
                    scrapAmountDecimal *= item.conditionNormalized;
                }

                scrapAmountDecimal *= recycleEfficiency / ClassicRecycleEfficiency;
                var scrapAmountInt = Mathf.FloorToInt(scrapAmountDecimal);
                var scrapRemainderForThisCycle = scrapAmountDecimal - scrapAmountInt;

                if (scrapRemainderForThisCycle > 0)
                {
                    var scrapRemainderAdapter = new ReflectionAdapter<float>(recycler, ScrapRemainderField);
                    var recyclerScrapRemainder = scrapRemainderAdapter.Value;
                    recyclerScrapRemainder += scrapRemainderForThisCycle;

                    var scrapRemainderToOutput = Mathf.FloorToInt(recyclerScrapRemainder);
                    if (scrapRemainderToOutput > 0)
                    {
                        recyclerScrapRemainder -= scrapRemainderToOutput;
                        scrapAmountInt += scrapRemainderToOutput;
                    }

                    scrapRemainderAdapter.Value = recyclerScrapRemainder;
                }

                if (scrapAmountInt >= 1)
                {
                    var scrapItem = ItemManager.CreateByItemID(ScrapItemId, scrapAmountInt);
                    recycler.MoveItemToOutput(scrapItem);
                }
            }

            foreach (var ingredient in item.info.Blueprint.ingredients)
            {
                // Skip scrap since it's handled separately.
                if (ingredient.itemDef.itemid == ScrapItemId)
                    continue;

                var ingredientAmount = ingredient.amount / item.info.Blueprint.amountToCreate;
                if (ingredientAmount <= 0)
                    continue;

                var outputAmount = CalculateOutputAmount(
                    recycleAmount,
                    ingredientAmount,
                    recycleEfficiency,
                    config.OutputMultipliers.GetOutputMultiplier(ingredient.itemid)
                );

                if (outputAmount <= 0)
                    continue;

                if (AddItemToRecyclerOutput(recycler, ingredient.itemDef, outputAmount))
                {
                    outputIsFull = true;
                }
            }

            return outputIsFull;
        }

        #endregion

        #region UI

        private enum IdentificationType
        {
            Item,
            Skin,
            DisplayName,
        }

        private enum OutputType
        {
            NotRecyclable,
            Default,
            Custom,
        }

        private enum UICommand
        {
            Edit,
            Reset,
            Save,
            Cancel,
            InputPercentage,
            ChangeIdentificationType,
            ChangeOutputType,
        }

        [Flags]
        private enum LayoutOptions
        {
            AnchorBottom = 1 << 0,
            AnchorRight = 1 << 1,
            Vertical = 1 << 2,
        }

        private class LayoutProvider
        {
            public const string AnchorBottomLeft = "0 0";
            public const string AnchorBottomRight = "1 0";
            public const string AnchorTopLeft = "0 1";
            public const string AnchorTopRight = "1 1";

            public static LayoutProvider Once(float width = 0, float height = 0)
            {
                return _reusable.WithOffset().WithDimensions(width, height).WithOptions(0).WithSpacing(0);
            }

            private static LayoutProvider _reusable = new(0, 0);

            private LayoutOptions _options;
            private string _anchor;
            private float _x, _y;
            private float _xSpacing, _ySpacing;
            private float _width, _height;

            private bool _isVertical => (_options & LayoutOptions.Vertical) != 0;
            private bool _isLeftToRight => (_options & LayoutOptions.AnchorRight) == 0;
            private bool _isTopToBottom => (_options & LayoutOptions.AnchorBottom) == 0;
            private int _xSign => _isLeftToRight ? 1 : -1;
            private int _ySign => _isTopToBottom ? -1 : 1;
            private float XMin, XMax, YMin, YMax;

            public string AnchorMin => _anchor;
            public string AnchorMax => _anchor;
            public string OffsetMin => $"{XMin.ToString()} {YMin.ToString()}";
            public string OffsetMax => $"{XMax.ToString()} {YMax.ToString()}";

            public LayoutProvider(float width, float height)
            {
                WithDimensions(width, height);
                WithOptions(0);
            }

            public LayoutProvider WithDimensions(float width, float height)
            {
                _width = width;
                _height = height;
                return this;
            }

            public LayoutProvider WithOptions(LayoutOptions options)
            {
                _options = options;
                _anchor = DetermineAnchor();
                return this;
            }

            public LayoutProvider WithSpacing(float x, float y = float.MaxValue)
            {
                _xSpacing = x;
                _ySpacing = y != float.MaxValue ? y : x;
                return this;
            }

            public LayoutProvider WithOffset(float x = 0, float y = 0)
            {
                _x = x * _xSign;
                _y = y * _ySign;
                return this;
            }

            public LayoutProvider Next()
            {
                XMin = _x + _xSpacing * _xSign;
                YMin = _y + _ySpacing * _ySign;
                XMax = XMin + _width * _xSign;
                YMax = YMin + _height * _ySign;

                if (_isVertical)
                {
                    _y = YMax;
                }
                else
                {
                    _x = XMax;
                }

                if (YMin > YMax)
                {
                    Swap(ref YMin, ref YMax);
                }

                if (XMin > XMax)
                {
                    Swap(ref XMin, ref XMax);
                }

                return this;
            }

            public CuiRectTransformComponent GetRectTransform()
            {
                return new CuiRectTransformComponent
                {
                    AnchorMin = _anchor,
                    AnchorMax = _anchor,
                    OffsetMin = OffsetMin,
                    OffsetMax = OffsetMax,
                };
            }

            private string DetermineAnchor()
            {
                return _isTopToBottom
                    ? _isLeftToRight ? AnchorTopLeft : AnchorTopRight
                    : _isLeftToRight ? AnchorBottomLeft : AnchorBottomRight;
            }
        }

        private class ButtonColor
        {
            public readonly string Color;
            public readonly string TextColor;

            public ButtonColor(string color, string textColor)
            {
                Color = color;
                TextColor = textColor;
            }
        }

        private class ButtonColorScheme
        {
            public ButtonColor Active;
            public ButtonColor Enabled;
            public ButtonColor Disabled;

            public ButtonColor Get(bool active = false, bool enabled = false)
            {
                return active
                    ? Active
                    : enabled
                        ? Enabled
                        : Disabled;
            }
        }

        private class CuiInputFieldComponentHud : CuiInputFieldComponent
        {
            [JsonProperty("hudMenuInput", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool HudMenuInput { get; set; }
        }

        private class CuiElementRecreate : CuiElement
        {
            [JsonProperty("destroyUi", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string DestroyUi { get; set; }
        }

        private static class EditUI
        {
            private const string UIName = "RecycleManager.UI";
            private const string EditPanelUIName = "RecycleManager.UI.EditPanel";
            private const string PercentagePanelUIName = "RecycleManager.UI.EditPanel.Percentages";

            private const string AnchorMin = "0.5 0";
            private const string AnchorMax = "0.5 0";

            private const float PanelWidth = 380.5f;
            private const float PanelHeight = 93f;
            private const float HeaderHeight = 21;

            private const int ItemPaddingLeft = 6;
            private const int ItemSize = 58;
            private const int ItemSpacing = 4;

            private const string BaseUICommand = "recyclemanager.ui";

            private const string TextColor = "0.8 0.8 0.8 1";
            private const string BackgroundColor = "0.25 0.25 0.25 1";

            private static ButtonColorScheme DefaultButtonColorScheme = new()
            {
                Active = new ButtonColor("0.25 0.5 0.75 1", "0.75 0.85 1 1"),
                Enabled = new ButtonColor("0.4 0.4 0.4 1", "0.71 0.71 0.71 1"),
                Disabled = new ButtonColor("0.4 0.4 0.4 0.5", "0.71 0.71 0.71 0.5"),
            };

            private static ButtonColorScheme SaveButtonColorScheme = new()
            {
                Enabled = new ButtonColor("0.451 0.553 0.271 1", "0.659 0.918 0.2 1"),
                Disabled = new ButtonColor("0.451 0.553 0.271 0.5", "0.659 0.918 0.2 0.5"),
            };

            private static ButtonColorScheme ResetButtonColorScheme = new()
            {
                Enabled = new ButtonColor("0.9 0.5 0.2 1", "1 0.9 0.7 1"),
                Disabled = new ButtonColor("0.9 0.5 0.2 0.25", "1 0.9 0.7 0.25"),
            };

            public static void DestroyUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, UIName);
            }

            public static void DrawUI(RecycleManager plugin, BasePlayer player, EditState state)
            {
                if (state == null)
                {
                    DrawDefaultUI(plugin, player);
                }
                else
                {
                    DrawEditUI(plugin, player, state);
                }
            }

            private static void DrawDefaultUI(RecycleManager plugin, BasePlayer player)
            {
                var elements = CreateContainer();
                AddEditButton(elements, plugin, player);

                CuiHelper.AddUi(player, elements);
            }

            private static void DrawEditUI(RecycleManager plugin, BasePlayer player, EditState state)
            {
                var elements = CreateContainer();
                AddEditPanel(elements, plugin, player, state);

                CuiHelper.AddUi(player, elements);
            }

            private static CuiElementContainer CreateContainer()
            {
                var offsetY = 109.5f;
                var offsetX = 192f;

                return new CuiElementContainer
                {
                    new CuiElementRecreate
                    {
                        Parent = "Hud.Menu",
                        Name = UIName,
                        DestroyUi = UIName,
                        Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = AnchorMin,
                                AnchorMax = AnchorMax,
                                OffsetMin = $"{offsetX} {offsetY}",
                                OffsetMax = $"{offsetX} {offsetY}",
                            },
                        },
                    },
                };
            }

            private static void AddEditButton(CuiElementContainer elements, RecycleManager plugin, BasePlayer player)
            {
                var buttonWidth = 80f;
                var offsetX = PanelWidth - buttonWidth;
                var offsetY = 266f;

                elements.Add(new CuiButton
                {
                    Text =
                    {
                        Text = plugin.GetMessage(player.UserIDString, LangEntry.UIButtonAdmin),
                        Color = SaveButtonColorScheme.Enabled.TextColor,
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 15,
                    },
                    Button =
                    {
                        Color = SaveButtonColorScheme.Enabled.Color,
                        Command = $"{BaseUICommand} {UICommand.Edit}",
                        FadeIn = 0.1f,
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{offsetX} {offsetY}",
                        OffsetMax = $"{offsetX + buttonWidth} {offsetY + HeaderHeight}",
                    },
                }, UIName);
            }

            private static void AddEditHeader(CuiElementContainer elements, RecycleManager plugin, BasePlayer player)
            {
                var offsetY = 266f;

                elements.Add(new CuiElement
                {
                    Parent = EditPanelUIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = BackgroundColor,
                            Sprite = "assets/content/ui/ui.background.tiletex.psd",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"0 {offsetY}",
                            OffsetMax = $"{PanelWidth} {offsetY + HeaderHeight}",
                        },
                    },
                });

                elements.Add(new CuiElement
                {
                    Parent = EditPanelUIName,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = plugin.GetMessage(player.UserIDString, LangEntry.UIHeader),
                            Align = TextAnchor.MiddleLeft,
                            FontSize = 14,
                            Color = TextColor,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"5 {offsetY}",
                            OffsetMax = $"{5 + PanelWidth} {offsetY + HeaderHeight}",
                        },
                    },
                });

                var buttonWidth = 80f;
                var offsetX = PanelWidth - buttonWidth;

                elements.Add(new CuiButton
                {
                    Text =
                    {
                        Text = plugin.GetMessage(player.UserIDString, LangEntry.UIButtonClose),
                        Color = DefaultButtonColorScheme.Enabled.TextColor,
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 15,
                    },
                    Button =
                    {
                        Color = DefaultButtonColorScheme.Enabled.Color,
                        Command = $"{BaseUICommand} {UICommand.Cancel}",
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{offsetX} {offsetY}",
                        OffsetMax = $"{offsetX + buttonWidth} {offsetY + HeaderHeight}",
                    },
                }, UIName);
            }

            private static void AddEditPanel(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state)
            {
                elements.Add(new CuiElement
                {
                    Parent = UIName,
                    Name = EditPanelUIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = BackgroundColor,
                            Sprite = "assets/content/ui/ui.background.tiletex.psd",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = AnchorMin,
                            AnchorMax = AnchorMax,
                            OffsetMin = "0 0",
                            OffsetMax = $"{PanelWidth} {PanelHeight}",
                        },
                    },
                });

                AddEditHeader(elements, plugin, player);

                if (state.BlockedByAnotherPlugin)
                {
                    elements.Add(new CuiElement
                    {
                        Parent = EditPanelUIName,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = plugin.GetMessage(player.UserIDString, LangEntry.UIItemBlocked),
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 12,
                                Color = TextColor,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1",
                            },
                        },
                    });
                    return;
                }

                AddPercentageControllers(elements, state);

                if (state.InputItem == null)
                {
                    elements.Add(new CuiElement
                    {
                        Parent = EditPanelUIName,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = plugin.GetMessage(player.UserIDString, LangEntry.UIEmptyState),
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 12,
                                Color = TextColor,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1",
                            },
                        },
                    });
                    return;
                }

                AddItemIdentificationControls(elements, plugin, player, state);
                AddItemAllowedControls(elements, plugin, player, state);
                AddPrimaryControls(elements, plugin, player, state);
            }

            private static void AddPercentageControllers(CuiElementContainer elements, EditState state)
            {
                var offsetY = 169;

                elements.Add(new CuiElement
                {
                    Name = PercentagePanelUIName,
                    Parent = EditPanelUIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = BackgroundColor,
                            Sprite = "assets/content/ui/ui.background.tiletex.psd",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"0 {offsetY}",
                            OffsetMax = $"{PanelWidth} {offsetY + HeaderHeight}",
                        },
                    },
                });

                if (state.InputItem == null)
                    return;

                for (var i = 0; i < 6; i++)
                {
                    if (state.Chances[i] <= 0)
                        continue;

                    var offsetX = ItemPaddingLeft + i * (ItemSize + ItemSpacing);

                    elements.Add(new CuiElement
                    {
                        Parent = PercentagePanelUIName,
                        Components =
                        {
                            new CuiInputFieldComponentHud
                            {
                                Align = TextAnchor.MiddleCenter,
                                HudMenuInput = true,
                                Text = $"{state.Chances[i]:0.##}%",
                                Color = TextColor,
                                CharsLimit = 6,
                                Command = $"{BaseUICommand} {UICommand.InputPercentage} {i}",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "0 0",
                                OffsetMin = $"{offsetX} 0",
                                OffsetMax = $"{offsetX + ItemSize} {HeaderHeight}",
                            },
                        },
                    });
                }
            }

            private static void AddButton(CuiElementContainer elements,
                LayoutProvider layoutProvider,
                ButtonColorScheme buttonColorScheme,
                string parent,
                string text,
                string command,
                bool active = false,
                bool enabled = true)
            {
                var buttonColor = buttonColorScheme.Get(active, enabled);

                elements.Add(new CuiButton
                {
                    Text =
                    {
                        Text = text,
                        Color = buttonColor.TextColor,
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 12,
                    },
                    Button =
                    {
                        Color = buttonColor.Color,
                        Command = enabled && !active ? command : null,
                    },
                    RectTransform =
                    {
                        AnchorMin = layoutProvider.AnchorMin,
                        AnchorMax = layoutProvider.AnchorMax,
                        OffsetMin = layoutProvider.OffsetMin,
                        OffsetMax = layoutProvider.OffsetMax,
                    },
                }, parent);
            }

            private static void AddItemIdentificationControls(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state)
            {
                var spacingX = 5;
                var spacingY = 2;
                var paddingY = 5;
                var numElements = 4;

                var columnWidth = PanelWidth / 3f;
                var elementHeight = (PanelHeight - 2 * paddingY - (numElements - 1) * spacingY) / numElements;

                var layoutProvider = LayoutProvider.Once(columnWidth - 2 * spacingX, elementHeight)
                    .WithOffset(0, paddingY - spacingY)
                    .WithSpacing(spacingX, spacingY)
                    .WithOptions(LayoutOptions.Vertical);

                elements.Add(new CuiElement
                {
                    Parent = EditPanelUIName,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = plugin.GetMessage(player.UserIDString, LangEntry.UILabelConfigureBy),
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 12,
                            Color = TextColor,
                        },
                        layoutProvider.Next().GetRectTransform(),
                    },
                });

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonItem),
                    $"{BaseUICommand} {UICommand.ChangeIdentificationType} {IdentificationType.Item}",
                    state.IdentificationType == IdentificationType.Item,
                    state.InputItem.skin != 0);

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonSkin),
                    $"{BaseUICommand} {UICommand.ChangeIdentificationType} {IdentificationType.Skin}",
                    state.IdentificationType == IdentificationType.Skin,
                    state.InputItem.skin != 0);

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonDisplayName),
                    $"{BaseUICommand} {UICommand.ChangeIdentificationType} {IdentificationType.DisplayName}",
                    state.IdentificationType == IdentificationType.DisplayName,
                    !string.IsNullOrWhiteSpace(state.InputItem.name));
            }

            private static void AddItemAllowedControls(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state)
            {
                var spacingX = 5;
                var spacingY = 2;
                var paddingY = 5;
                var numElements = 4;

                var columnWidth = PanelWidth / 3f;
                var elementHeight = (PanelHeight - 2 * paddingY - (numElements - 1) * spacingY) / numElements;

                var layoutProvider = LayoutProvider.Once(columnWidth - 2 * spacingX, elementHeight)
                    .WithOffset(columnWidth, paddingY - spacingY)
                    .WithSpacing(spacingX, spacingY)
                    .WithOptions(LayoutOptions.Vertical);

                elements.Add(new CuiElement
                {
                    Parent = EditPanelUIName,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = plugin.GetMessage(player.UserIDString, LangEntry.UILabelOutput),
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 12,
                            Color = TextColor,
                        },
                        layoutProvider.Next().GetRectTransform(),
                    },
                });

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonNotRecyclable),
                    $"{BaseUICommand} {UICommand.ChangeOutputType} {OutputType.NotRecyclable}",
                    state.OutputType == OutputType.NotRecyclable);

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonDefaultOutput),
                    $"{BaseUICommand} {UICommand.ChangeOutputType} {OutputType.Default}",
                    state.OutputType == OutputType.Default,
                    state.IdentificationType != IdentificationType.Item || IsVanillaRecyclable(state.InputItem));

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonCustomOutput),
                    $"{BaseUICommand} {UICommand.ChangeOutputType} {OutputType.Custom}",
                    state.OutputType == OutputType.Custom);
            }

            private static void AddPrimaryControls(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state)
            {
                var spacingX = 5;
                var spacingY = 2;
                var paddingY = 5;
                var numElements = 4;

                var columnWidth = PanelWidth / 3f;
                var elementHeight = (PanelHeight - 2 * paddingY - (numElements - 1) * spacingY) / numElements;

                var layoutProvider = LayoutProvider.Once(columnWidth - 2 * spacingX, elementHeight)
                    .WithOffset(2 * columnWidth, paddingY - spacingY)
                    .WithSpacing(spacingX, spacingY)
                    .WithOptions(LayoutOptions.Vertical);

                elements.Add(new CuiElement
                {
                    Parent = EditPanelUIName,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = plugin.GetMessage(player.UserIDString, LangEntry.UILabelActions),
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 12,
                            Color = TextColor,
                        },
                        layoutProvider.Next().GetRectTransform(),
                    },
                });

                AddButton(elements,
                    layoutProvider.Next(),
                    SaveButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonSave),
                    $"{BaseUICommand} {UICommand.Save}",
                    enabled: state.CanSave);

                AddButton(elements,
                    layoutProvider.Next(),
                    ResetButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonReset),
                    $"{BaseUICommand} {UICommand.Reset}",
                    enabled: state.CanReset);

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonCancel),
                    $"{BaseUICommand} {UICommand.Cancel}");
            }
        }

        #endregion

        #region Edit Controller

        private class EditState
        {
            public Item InputItem;
            public IdentificationType IdentificationType;
            public OutputType OutputType;

            public float[] Chances = new float[NumOutputSlots];

            public bool BlockedByAnotherPlugin;
            public bool CanSave;
            public bool CanReset;
        }

        private class EditController : FacepunchBehaviour
        {
            public static EditController AddToRecycler(RecycleManager plugin, RecycleEditManager recycleEditManager, Recycler recycler)
            {
                var component = recycler.gameObject.AddComponent<EditController>();
                component._plugin = plugin;
                component._recycleEditManager = recycleEditManager;
                component._recycler = recycler;
                return component;
            }

            private RecycleManager _plugin;
            private RecycleEditManager _recycleEditManager;
            private Recycler _recycler;
            private BasePlayer _player;
            private EditState _editState;
            private Func<Item, int, bool> _originalCanAcceptItem;
            private Action _onDirtyDelayed;
            private bool _pauseAutoChangeOutput;

            private Configuration _config => _plugin._config;

            private EditController()
            {
                _onDirtyDelayed = OnDirtyDelayed;
            }

            public void StartViewing(BasePlayer player)
            {
                _player = player;
                DrawUI();
            }

            public void DestroyImmediate()
            {
                DestroyImmediate(this);
            }

            private IngredientInfo[] GetSavedIngredients()
            {
                return GetOutput(_editState.IdentificationType, _editState.OutputType);
            }

            private bool CanSave()
            {
                if (_editState.InputItem == null)
                    return false;

                switch (_editState.OutputType)
                {
                    case OutputType.NotRecyclable:
                    {
                        if (IsDisallowed())
                            return false;

                        if (GetOverride() != null)
                            return true;

                        return _editState.IdentificationType == IdentificationType.Item && IsVanillaRecyclable(_editState.InputItem);
                    }

                    case OutputType.Default:
                    {
                        if (IsDisallowed())
                            return true;

                        if (GetOverride() != null)
                            return true;

                        return false;
                    }

                    case OutputType.Custom:
                        return GetOverride() == null
                               || !GetOutputIngredients().SequenceEqual(GetSavedIngredients());

                    default:
                        return true;
                }
            }

            private bool CanReset()
            {
                if (_editState.InputItem == null)
                    return false;

                return IsDisallowed() || GetOverride() != null;
            }

            private void DrawUI()
            {
                if (_editState != null)
                {
                    _editState.CanSave = CanSave();
                    _editState.CanReset = CanReset();

                }

                EditUI.DrawUI(_plugin, _player, _editState);
            }

            private List<IngredientInfo> GetOutputIngredients()
            {
                var customIngredientList = new List<IngredientInfo>();

                for (var i = NumInputSlots; i < NumInputSlots + NumOutputSlots; i++)
                {
                    var item = _recycler.inventory.GetSlot(i);
                    if (item == null)
                        continue;

                    var amount = (float)item.amount;
                    if (amount == 1)
                    {
                        if (_editState.Chances[i - NumInputSlots] == 0)
                        {
                            _editState.Chances[i - NumInputSlots] = 100;
                        }
                        else
                        {
                            amount = _editState.Chances[i - NumInputSlots] / 100f;
                        }
                    }

                    var ingredientInfo = new IngredientInfo
                    {
                        ShortName = item.info.shortname,
                        DisplayName = !string.IsNullOrWhiteSpace(item.name) ? item.name : null,
                        SkinId = item.skin,
                        Amount = amount,
                    };
                    ingredientInfo.Init();
                    customIngredientList.Add(ingredientInfo);
                }

                return customIngredientList;
            }

            public void HandleUICommand(BasePlayer player, string[] args)
            {
                var commandTypeArg = args.FirstOrDefault();
                if (commandTypeArg == null)
                    return;

                if (!Enum.TryParse(commandTypeArg, ignoreCase: true, result: out UICommand uiCommand))
                    return;

                switch (uiCommand)
                {
                    case UICommand.Edit:
                        StartEditing();
                        break;

                    case UICommand.Reset:
                    {
                        _editState.OutputType = OutputType.Default;

                        var changed = false;
                        changed |= _config.RestrictedInputItems.Allow(_editState.InputItem, _editState.IdentificationType);
                        changed |= _config.OverrideOutput.RemoveOverride(_editState.InputItem, _editState.IdentificationType);

                        if (changed)
                        {
                            _plugin.SaveConfig();
                        }

                        _editState.OutputType = DetermineBestOutputType();

                        RemoveOutputItems();
                        PopulateOutputItems();
                        DrawUI();
                        break;
                    }

                    case UICommand.Save:
                    {
                        if (_editState.OutputType == OutputType.Custom)
                        {
                            _config.RestrictedInputItems.Allow(_editState.InputItem, _editState.IdentificationType);
                            _config.OverrideOutput.SetOverride(_editState.InputItem, _editState.IdentificationType, GetOutputIngredients().ToArray());
                            _plugin.SaveConfig();
                        }
                        else
                        {
                            var changed = _config.OverrideOutput.RemoveOverride(_editState.InputItem, _editState.IdentificationType);

                            if (_editState.OutputType == OutputType.NotRecyclable)
                            {
                                if (_editState.IdentificationType != IdentificationType.Item || IsVanillaRecyclable(_editState.InputItem))
                                {
                                    changed |= _config.RestrictedInputItems.Disallow(_editState.InputItem, _editState.IdentificationType);
                                }
                            }
                            else
                            {
                                changed |= _config.RestrictedInputItems.Allow(_editState.InputItem, _editState.IdentificationType);
                            }

                            if (changed)
                            {
                                _plugin.SaveConfig();
                            }
                        }

                        RemoveOutputItems();
                        PopulateOutputItems();
                        DrawUI();
                        break;
                    }

                    case UICommand.Cancel:
                        StopEditing(redraw: true);
                        break;

                    case UICommand.InputPercentage:
                    {
                        var slotArg = args.ElementAtOrDefault(1);
                        var amountArg = args.ElementAtOrDefault(2)?.Replace("%", "");
                        if (slotArg == null || amountArg == null)
                            break;

                        if (!int.TryParse(slotArg, out var slot) || slot < 0 || slot > 5)
                            break;

                        if (!float.TryParse(amountArg, out var chance))
                        {
                            DrawUI();
                            break;
                        }

                        chance = Mathf.Clamp(chance, 0.01f, 100);
                        // Since we allow up to 2 decimal places, allow tolerance of half of 3rd decimal place.
                        // This makes it so if the original value is higher precision like 8.333334, clicking into the
                        // field without changing the input doesn't change the underlying value.
                        if (Math.Abs(chance - _editState.Chances[slot]) >= 0.005f)
                        {
                            _editState.Chances[slot] = chance;
                            _pauseAutoChangeOutput = false;
                            HandleChanges();
                        }

                        DrawUI();
                        break;
                    }

                    case UICommand.ChangeOutputType:
                    {
                        var allowedArg = args.ElementAtOrDefault(1);
                        if (allowedArg == null)
                            break;

                        if (!Enum.TryParse(allowedArg, out OutputType outputType))
                            break;

                        if (outputType == _editState.OutputType)
                            break;

                        _editState.OutputType = outputType;

                        if (outputType == OutputType.NotRecyclable)
                        {
                            RemoveOutputItems();
                        }
                        else
                        {
                            RemoveOutputItems();
                            PopulateOutputItems();
                        }

                        DrawUI();
                        break;
                    }

                    case UICommand.ChangeIdentificationType:
                    {
                        var identifyTypeArg = args.ElementAtOrDefault(1);
                        if (identifyTypeArg == null)
                            break;

                        if (!Enum.TryParse(identifyTypeArg, ignoreCase: true, result: out IdentificationType identificationType))
                            break;

                        if (_editState.IdentificationType == identificationType)
                            break;

                        _editState.IdentificationType = identificationType;
                        _editState.OutputType = DetermineBestOutputType();

                        RemoveOutputItems();
                        PopulateOutputItems();
                        DrawUI();
                        break;
                    }
                }
            }

            private IngredientInfo[] GetOutput(IdentificationType identificationType, OutputType outputType)
            {
                if (outputType == OutputType.NotRecyclable)
                    return null;

                if (outputType == OutputType.Custom)
                {
                    var output = GetOverride(identificationType);
                    if (output != null)
                        return output;
                }

                if (identificationType == IdentificationType.DisplayName)
                    return GetOutput(IdentificationType.Skin, DetermineBestOutputType(IdentificationType.Skin));

                if (identificationType == IdentificationType.Skin)
                    return GetOutput(IdentificationType.Item, DetermineBestOutputType(IdentificationType.Item));

                if (IsVanillaRecyclable(_editState.InputItem))
                    return GetVanillaOutput(_editState.InputItem.info);

                return null;
            }

            private void PopulateOutputItems()
            {
                var output = GetOutput(_editState.IdentificationType, _editState.OutputType);
                if (output == null)
                {
                    for (var i = 0; i < _editState.Chances.Length; i++)
                    {
                        _editState.Chances[i] = 0;
                    }
                    return;
                }

                PopulateOutputWithOverride(_recycler, output, 1, forEditor: true);
                _pauseAutoChangeOutput = true;

                for (var i = 0; i < _editState.Chances.Length; i++)
                {
                    _editState.Chances[i] = 0;

                    var customIngredient = output.ElementAtOrDefault(i);
                    if (customIngredient is { Amount: <= 1 })
                    {
                        _editState.Chances[i] = customIngredient.Amount * 100f;
                    }
                }
            }

            private void RemoveInputItems()
            {
                for (var i = 0; i < NumInputSlots; i++)
                {
                    var item = _recycler.inventory.GetSlot(i);
                    if (item == null)
                        continue;

                    _player.GiveItem(item);
                }
            }

            private void RemoveOutputItems(BasePlayer player = null)
            {
                for (var i = NumInputSlots; i < NumInputSlots + NumOutputSlots; i++)
                {
                    var item = _recycler.inventory.GetSlot(i);
                    if (item == null)
                        continue;

                    if (player != null)
                    {
                        player.GiveItem(item);
                    }
                    else
                    {
                        item.RemoveFromContainer();
                        item.Remove();
                    }
                }

                _pauseAutoChangeOutput = true;
            }

            private void StartEditing()
            {
                _recycler.StopRecycling();

                RemoveOutputItems(_player);

                _originalCanAcceptItem = _recycler.inventory.canAcceptItem;
                _recycler.inventory.canAcceptItem = (item, slot) => _editState?.InputItem != null
                    ? (slot == 0 || slot >= NumInputSlots)
                    : slot < NumInputSlots;

                _recycler.inventory.onDirty += OnDirty;

                _editState = new EditState();
                OnDirtyDelayed();
            }

            private bool CanAcceptItem(Item item)
            {
                if (IsDisallowed())
                    return false;

                if (_plugin.CallCanBeRecycled(item, _recycler) is bool result)
                    return result;

                if (GetOverride() != null)
                    return true;

                return IsVanillaRecyclable(_editState.InputItem);
            }

            private void StopEditing(bool redraw = false)
            {
                if (_editState == null || _recycler == null || _recycler.IsDestroyed)
                    return;

                _recycler.inventory.canAcceptItem = _originalCanAcceptItem;
                _recycler.inventory.onDirty -= OnDirty;

                if (_editState.InputItem != null && !CanAcceptItem(_editState.InputItem))
                {
                    RemoveInputItems();
                }

                RemoveOutputItems();

                _editState = null;

                if (redraw)
                {
                    DrawUI();
                }
            }

            private void StopViewing()
            {
                if (_player == null)
                    return;

                EditUI.DestroyUI(_player);

                _recycleEditManager.HandlePlayerStoppedLooting(_player);
                _player = null;
            }

            private Item TrimInputs()
            {
                Item firstItem = null;

                for (var i = 0; i < NumInputSlots; i++)
                {
                    var item = _recycler.inventory.GetSlot(i);
                    if (item == null)
                        continue;

                    if (firstItem == null)
                    {
                        firstItem = item;
                    }
                    else
                    {
                        item.RemoveFromContainer();
                        _player.GiveItem(item);
                    }
                }

                if (firstItem != null && firstItem.position != 0)
                {
                    firstItem.MoveToContainer(firstItem.parent, 0);
                }

                return firstItem;
            }

            private void RemoveExcessInput(Item item)
            {
                if (item.amount <= 1)
                    return;

                var splitItem = item.SplitItem(item.amount - 1);
                if (splitItem == null)
                    return;

                _player.GiveItem(splitItem);
            }

            private IngredientInfo[] GetOverride(IdentificationType identificationType)
            {
                return _config.OverrideOutput.GetOverride(_editState.InputItem, identificationType);
            }

            private IngredientInfo[] GetOverride()
            {
                return GetOverride(_editState.IdentificationType);
            }

            private bool IsDisallowed(IdentificationType identificationType)
            {
                if (_editState.InputItem == null)
                    return false;

                return _config.RestrictedInputItems.IsDisallowed(_editState.InputItem, identificationType);
            }

            private bool IsDisallowed()
            {
                return IsDisallowed(_editState.IdentificationType);
            }

            private OutputType DetermineBestOutputType(IdentificationType identificationType)
            {
                if (GetOverride(identificationType) != null)
                    return OutputType.Custom;

                if (IsDisallowed(identificationType))
                    return OutputType.NotRecyclable;

                if (identificationType == IdentificationType.Item && !IsVanillaRecyclable(_editState.InputItem))
                    return OutputType.NotRecyclable;

                return OutputType.Default;
            }

            private OutputType DetermineBestOutputType()
            {
                return DetermineBestOutputType(_editState.IdentificationType);
            }

            private IdentificationType DetermineBestIdentificationType()
            {
                if (GetOverride(IdentificationType.DisplayName) != null
                    || IsDisallowed(IdentificationType.DisplayName))
                    return IdentificationType.DisplayName;

                if (GetOverride(IdentificationType.Skin) != null
                    || IsDisallowed(IdentificationType.Skin))
                    return IdentificationType.Skin;

                return IdentificationType.Item;
            }

            private void HandleNewInputItem()
            {
                RemoveExcessInput(_editState.InputItem);
                RemoveOutputItems();

                if (_plugin.CallCanBeRecycled(_editState.InputItem, _recycler) is false)
                {
                    _editState.BlockedByAnotherPlugin = true;
                    DrawUI();
                }
                else
                {
                    _editState.BlockedByAnotherPlugin = false;
                    _editState.IdentificationType = DetermineBestIdentificationType();
                    _editState.OutputType = DetermineBestOutputType();
                    PopulateOutputItems();
                }

                DrawUI();
            }

            private void HandleChanges()
            {
                var output = GetOutputIngredients();
                if (!_pauseAutoChangeOutput)
                {
                    var customOutput = GetOverride();
                    var defaultOutput = GetOutput(_editState.IdentificationType, OutputType.Default);
                    if (output.Count == 0)
                    {
                        _editState.OutputType = OutputType.NotRecyclable;
                    }
                    else if (customOutput != null && output.SequenceEqual(customOutput))
                    {
                        _editState.OutputType = OutputType.Custom;
                    }
                    else if (defaultOutput != null && output.SequenceEqual(defaultOutput))
                    {
                        _editState.OutputType = OutputType.Default;
                    }
                    else
                    {
                        _editState.OutputType = OutputType.Custom;
                    }
                }

                for (var i = 0; i < _editState.Chances.Length; i++)
                {
                    var outputItem = _recycler.inventory.GetSlot(NumInputSlots + i);
                    if (outputItem == null || outputItem.amount > 1)
                    {
                        _editState.Chances[i] = 0;
                    }
                }
            }

            private void OnDirtyDelayed()
            {
                if (_recycler == null)
                {
                    DestroyImmediate();
                    return;
                }

                var inputItem = TrimInputs();
                var previousInputItem = _editState.InputItem;
                _editState.InputItem = inputItem;

                if (inputItem != null && inputItem == previousInputItem)
                {
                    RemoveExcessInput(inputItem);
                    HandleChanges();
                    DrawUI();
                    return;
                }

                if (inputItem == null)
                {
                    _editState.BlockedByAnotherPlugin = false;
                    RemoveOutputItems(previousInputItem == null ? _player : null);
                    DrawUI();
                    return;
                }

                HandleNewInputItem();
            }

            private void OnDirty()
            {
                _pauseAutoChangeOutput = false;
                Invoke(_onDirtyDelayed, 0);
            }

            private void PlayerStoppedLooting(BasePlayer player)
            {
                if (_player == player)
                {
                    StopEditing();
                    StopViewing();
                }
            }

            private void OnDestroy()
            {
                StopEditing();
                StopViewing();
                _recycleEditManager.HandleControllerDestroyed(_recycler);
            }
        }

        #endregion

        #region Edit Manager

        private class RecycleEditManager
        {
            private RecycleManager _plugin;
            private Dictionary<Recycler, EditController> _controllers = new();
            private Dictionary<BasePlayer, EditController> _playerControllers = new();

            public RecycleEditManager(RecycleManager plugin)
            {
                _plugin = plugin;
            }

            public void HandlePlayerStartedLooting(BasePlayer player, Recycler recycler)
            {
                var controller = EnsureController(recycler);
                _playerControllers[player] = controller;
                controller.StartViewing(player);
            }

            public EditController GetController(BasePlayer player)
            {
                return _playerControllers.TryGetValue(player, out var editController)
                    ? editController
                    : null;
            }

            public EditController EnsureController(Recycler recycler)
            {
                var editController = GetController(recycler);
                if (editController == null)
                {
                    editController = EditController.AddToRecycler(_plugin, this, recycler);
                }

                _controllers[recycler] = editController;
                return editController;
            }

            public void HandlePlayerStoppedLooting(BasePlayer player)
            {
                _playerControllers.Remove(player);
            }

            public void HandleControllerDestroyed(Recycler recycler)
            {
                _controllers.Remove(recycler);
            }

            public void Unload()
            {
                foreach (var controller in _controllers.Values.ToArray())
                {
                    controller.DestroyImmediate();
                }
            }

            private EditController GetController(Recycler recycler)
            {
                return _controllers.TryGetValue(recycler, out var editController)
                    ? editController
                    : null;
            }
        }

        #endregion

        #region Recycler Component

        private class RecyclerComponent : FacepunchBehaviour
        {
            public static RecyclerComponent AddToRecycler(RecycleManager plugin, RecyclerComponentManager recyclerComponentManager, Recycler recycler)
            {
                var component = recycler.gameObject.AddComponent<RecyclerComponent>();
                component._plugin = plugin;
                component._recyclerComponentManager = recyclerComponentManager;
                component._recycler = recycler;
                component._vanillaRecycleThink = recycler.RecycleThink;
                return component;
            }

            public BasePlayer Player { get; private set; }
            private RecycleManager _plugin;
            private RecyclerComponentManager _recyclerComponentManager;
            private Recycler _recycler;
            private Action _vanillaRecycleThink;
            private Action _customRecycleThink;
            private float _recycleTime;

            private Configuration _config => _plugin._config;
            private bool _enableIncrementalRecycling => _config.Speed.EnableIncrementalRecycling;

            private RecyclerComponent()
            {
                _customRecycleThink = CustomRecycleThink;
            }

            public void DestroyImmediate()
            {
                DestroyImmediate(this);
            }

            public void HandleRecyclerToggle(BasePlayer player)
            {
                // Delay for the following reasons.
                //   1. Allow other plugins to block toggle the recycler.
                //   2. Override other plugins after they start the recycler with custom speed.
                // If another plugin wants to alter the speed, they should use the hook that will be called on a delay.
                Invoke(() => HandleRecyclerToggleDelayed(player), 0);
            }

            private void HandleRecyclerToggleDelayed(BasePlayer player)
            {
                if (_recycler.IsOn())
                {
                    Player = player;

                    // Allow other plugins to block this, or to modify recycle time.
                    if (!_plugin.TryDetermineRecycleTime(_recycler, player, out _recycleTime))
                        return;

                    // Cancel the vanilla recycle invoke, in case another plugin started it.
                    // The custom recycle think method will also cancel it, since it may be started on a delay.
                    _recycler.CancelInvoke(_vanillaRecycleThink);

                    if (_enableIncrementalRecycling)
                    {
                        Invoke(_customRecycleThink, GetItemRecycleTime(GetNextItem()));
                    }
                    else
                    {
                        InvokeRepeating(_customRecycleThink, _recycleTime, _recycleTime);
                    }
                }
                else
                {
                    Player = null;

                    // The recycler is off, but vanilla doesn't know how to turn off custom recycling.
                    CancelInvoke(_customRecycleThink);
                }
            }

            private void CustomRecycleThink()
            {
                if (!_recycler.IsOn())
                {
                    // Vanilla or another plugin turned off the recycler, so don't process the next item.
                    if (!_enableIncrementalRecycling)
                    {
                        // Incremental recycling is disabled, so we must cancel the repeating custom invoke.
                        CancelInvoke(_customRecycleThink);
                    }

                    return;
                }

                // Stop the vanilla invokes if another plugin started them.
                // Necessary because some plugins will start the vanilla invokes on a delay to change recycler speed.
                // If another plugin wants to change recycler speed, they should use the hook designed for that.
                if (_recycler.IsInvoking(_vanillaRecycleThink))
                {
                    _recycler.CancelInvoke(_vanillaRecycleThink);
                }

                _recycler.RecycleThink();

                if (_enableIncrementalRecycling)
                {
                    var nextItem = GetNextItem();
                    if (nextItem != null)
                    {
                        Invoke(_customRecycleThink, GetItemRecycleTime(nextItem));
                    }
                }
            }

            private float GetItemRecycleTime(Item item)
            {
                if (_recycleTime == 0)
                    return _recycleTime;

                return _recycleTime * _config.Speed.GetTimeMultiplierForItem(item);
            }

            private Item GetNextItem()
            {
                for (var i = 0; i < 6; i++)
                {
                    var item = _recycler.inventory.GetSlot(i);
                    if (item != null)
                        return item;
                }

                return null;
            }

            private void OnDestroy()
            {
                _recyclerComponentManager.HandleRecyclerComponentDestroyed(_recycler);
            }
        }

        private class RecyclerComponentManager
        {
            private RecycleManager _plugin;
            private readonly Dictionary<Recycler, RecyclerComponent> _recyclerComponents = new();

            public void Init(RecycleManager plugin)
            {
                _plugin = plugin;
            }

            public void Unload()
            {
                foreach (var recyclerComponent in _recyclerComponents.Values.ToArray())
                {
                    recyclerComponent.DestroyImmediate();
                }
            }

            public void HandleRecyclerToggle(Recycler recycler, BasePlayer player)
            {
                EnsureRecyclerComponent(recycler).HandleRecyclerToggle(player);
            }

            public void HandleRecyclerComponentDestroyed(Recycler recycler)
            {
                _recyclerComponents.Remove(recycler);
            }

            public RecyclerComponent EnsureRecyclerComponent(Recycler recycler)
            {
                if (!_recyclerComponents.TryGetValue(recycler, out var recyclerComponent))
                {
                    recyclerComponent = RecyclerComponent.AddToRecycler(_plugin, this, recycler);
                    _recyclerComponents[recycler] = recyclerComponent;
                }

                return recyclerComponent;
            }
        }

        #endregion

        #region Configuration

        private class CaseInsensitiveDictionary<TValue> : Dictionary<string, TValue>
        {
            public CaseInsensitiveDictionary() : base(StringComparer.OrdinalIgnoreCase) {}
        }

        private class CaseInsensitiveHashSet : HashSet<string>
        {
            public CaseInsensitiveHashSet() : base(StringComparer.OrdinalIgnoreCase) {}
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class EditUISettings
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class PermissionSpeedProfile
        {
            [JsonProperty("Permission suffix")]
            public string PermissionSuffix;

            [JsonProperty("Recycle time (seconds)")]
            private float RecycleTime { set => TimeMultiplier = value / 5f; }

            [JsonProperty("Recycle time multiplier")]
            public float TimeMultiplier = 1;

            [JsonIgnore]
            public string Permission { get; private set; }

            public void Init(RecycleManager plugin)
            {
                if (!string.IsNullOrWhiteSpace(PermissionSuffix))
                {
                    Permission = $"{nameof(RecycleManager)}.speed.{PermissionSuffix}".ToLower();
                    plugin.permission.RegisterPermission(Permission, plugin);
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class SpeedSettings
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Default recycle time (seconds)")]
            public float DefaultRecycleTime = 5;

            [JsonProperty("Recycle time (seconds)")]
            private float DeprecatedRecycleTime { set => DefaultRecycleTime = value; }

            [JsonProperty("Recycle time multiplier while in safe zone")]
            public float SafeZoneTimeMultiplier = 1;

            [JsonProperty("Recycle time multiplier by item short name (item: multiplier)")]
            public Dictionary<string, float> TimeMultiplierByShortName = new();

            [JsonProperty("Recycle time multiplier by permission")]
            public PermissionSpeedProfile[] PermissionSpeedProfiles =
            {
                new()
                {
                    PermissionSuffix = "fast",
                    TimeMultiplier = 0.2f,
                },
                new()
                {
                    PermissionSuffix = "instant",
                    TimeMultiplier = 0,
                },
            };

            [JsonProperty("Speeds requiring permission")]
            private PermissionSpeedProfile[] DeprecatedSpeedsRequiringPermission { set => PermissionSpeedProfiles = value; }

            [JsonIgnore]
            private Permission _permission;

            [JsonIgnore]
            private Dictionary<int, float> _timeMultiplierByItemId = new();

            [JsonIgnore]
            public bool EnableIncrementalRecycling;

            public void Init(RecycleManager plugin)
            {
                _permission = plugin.permission;

                foreach (var speedProfile in PermissionSpeedProfiles)
                {
                    speedProfile.Init(plugin);
                }

                foreach (var (itemShortName, timeMultiplier) in TimeMultiplierByShortName)
                {
                    var itemDefinition = ItemManager.FindItemDefinition(itemShortName);
                    if (itemDefinition == null)
                    {
                        LogWarning($"Invalid item short name in config: {itemShortName}");
                        continue;
                    }

                    if (timeMultiplier == 1)
                        continue;

                    _timeMultiplierByItemId[itemDefinition.itemid] = timeMultiplier;
                    EnableIncrementalRecycling = true;
                }
            }

            public float GetTimeMultiplierForPlayer(BasePlayer player)
            {
                for (var i = PermissionSpeedProfiles.Length - 1; i >= 0; i--)
                {
                    var speedProfile = PermissionSpeedProfiles[i];
                    if (speedProfile.Permission != null
                        && _permission.UserHasPermission(player.UserIDString, speedProfile.Permission))
                    {
                        return speedProfile.TimeMultiplier;
                    }
                }

                return 1;
            }

            public float GetTimeMultiplierForItem(Item item)
            {
                if (_timeMultiplierByItemId.TryGetValue(item.info.itemid, out var time))
                    return time;

                return 1;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class EfficiencySettings
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Default recycle efficiency")]
            public float DefaultRecyclerEfficiency = 0.6f;

            [JsonProperty("Recycle efficiency while in safe zone")]
            public float RecyclerEfficiencyWhileInSafeZone = 0.4f;

            public float GetRecyclerEfficiency(Recycler recycler)
            {
                return recycler.IsSafezoneRecycler() ? RecyclerEfficiencyWhileInSafeZone : DefaultRecyclerEfficiency;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class MaxItemsPerRecycle
        {
            [JsonProperty("Default percent")]
            public float DefaultPercent = 10f;

            [JsonProperty("Percent by input item short name")]
            public Dictionary<string, float> PercentByShortName = new();

            [JsonProperty("Percent by input item skin ID")]
            public Dictionary<ulong, float> PercentBySkinId = new();

            [JsonProperty("Percent by input item display name (custom items)")]
            public CaseInsensitiveDictionary<float> PercentByDisplayName = new();

            [JsonIgnore]
            private Dictionary<int, float> PercentByItemId = new();

            public void Init()
            {
                foreach (var (shortName, percent) in PercentByShortName)
                {
                    if (string.IsNullOrWhiteSpace(shortName))
                        continue;

                    var itemDefinition = ItemManager.FindItemDefinition(shortName);
                    if (itemDefinition == null)
                    {
                        LogWarning($"Invalid item short name in config: {shortName}");
                        continue;
                    }

                    PercentByItemId[itemDefinition.itemid] = percent;
                }
            }

            public float GetPercent(Item item)
            {
                if (!string.IsNullOrWhiteSpace(item.name) && PercentByDisplayName.TryGetValue(item.name, out var multiplier))
                    return multiplier;

                if (item.skin != 0 && PercentBySkinId.TryGetValue(item.skin, out multiplier))
                    return multiplier;

                if (PercentByItemId.TryGetValue(item.info.itemid, out multiplier))
                    return multiplier;

                return DefaultPercent;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class OutputMultiplierSettings
        {
            [JsonProperty("Default multiplier")]
            public float DefaultMultiplier = 1f;

            [JsonProperty("Multiplier by output item short name")]
            public Dictionary<string, float> MultiplierByOutputShortName = new();

            [JsonIgnore]
            private Dictionary<int, float> MultiplierByOutputItemId = new();

            public void Init()
            {
                foreach (var (shortName, multiplier) in MultiplierByOutputShortName)
                {
                    if (string.IsNullOrWhiteSpace(shortName))
                        continue;

                    var itemDefinition = ItemManager.FindItemDefinition(shortName);
                    if (itemDefinition == null)
                    {
                        LogWarning($"Invalid item short name in config: {shortName}");
                        continue;
                    }

                    MultiplierByOutputItemId[itemDefinition.itemid] = multiplier;
                }
            }

            public float GetOutputMultiplier(int itemId)
            {
                if (MultiplierByOutputItemId.TryGetValue(itemId, out var multiplier))
                    return multiplier;

                return DefaultMultiplier;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class IngredientInfo : IEquatable<IngredientInfo>
        {
            [JsonProperty("Item short name")]
            public string ShortName;

            [JsonProperty("Item skin ID", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong SkinId;

            [JsonProperty("Display name", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string DisplayName;

            [JsonProperty("Amount")]
            public float Amount;

            [JsonIgnore]
            public ItemDefinition ItemDefinition;

            public void Init()
            {
                ItemDefinition = ItemManager.FindItemDefinition(ShortName);
                if (ItemDefinition == null)
                {
                    LogWarning($"Invalid item short name in config: {ShortName}");
                }

                if (Amount < 0)
                {
                    Amount = 0;
                }
            }

            public bool Equals(IngredientInfo other)
            {
                if (ReferenceEquals(null, other))
                    return false;

                if (ReferenceEquals(this, other))
                    return true;

                return ItemDefinition == other.ItemDefinition
                       && SkinId == other.SkinId
                       && Amount.Equals(other.Amount)
                       && string.Compare(DisplayName, other.DisplayName, StringComparison.OrdinalIgnoreCase) == 0;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class RestrictedInputItems
        {
            [JsonProperty("Item short names")]
            public CaseInsensitiveHashSet DisallowedInputShortNames = new();

            [JsonProperty("Item skin IDs")]
            public HashSet<ulong> DisallowedInputSkinIds = new();

            [JsonProperty("Item display names (custom items)")]
            public CaseInsensitiveHashSet DisallowedInputDisplayNames = new();

            [JsonIgnore]
            private HashSet<int> DisallowedInputItemIds = new();

            public void Init()
            {
                foreach (var shortName in DisallowedInputShortNames)
                {
                    if (string.IsNullOrWhiteSpace(shortName))
                        continue;

                    var itemDefinition = ItemManager.FindItemDefinition(shortName);
                    if (itemDefinition == null)
                    {
                        LogWarning($"Invalid item short name in config: {shortName}");
                        continue;
                    }

                    DisallowedInputItemIds.Add(itemDefinition.itemid);
                }
            }

            public bool IsDisallowed(Item item, IdentificationType identificationType)
            {
                switch (identificationType)
                {
                    case IdentificationType.DisplayName:
                        return DisallowedInputDisplayNames.Contains(item.name);

                    case IdentificationType.Skin:
                        return DisallowedInputSkinIds.Contains(item.skin);

                    case IdentificationType.Item:
                        return DisallowedInputItemIds.Contains(item.info.itemid);
                }

                return true;
            }

            public bool IsDisallowed(Item item)
            {
                if (!string.IsNullOrEmpty(item.name) && IsDisallowed(item, IdentificationType.DisplayName))
                    return true;

                if (item.skin != 0 && IsDisallowed(item, IdentificationType.Skin))
                    return true;

                return IsDisallowed(item, IdentificationType.Item);
            }

            public bool Allow(Item item, IdentificationType identificationType)
            {
                switch (identificationType)
                {
                    case IdentificationType.DisplayName:
                        return DisallowedInputDisplayNames.Remove(item.name);

                    case IdentificationType.Skin:
                        return DisallowedInputSkinIds.Remove(item.skin);

                    case IdentificationType.Item:
                        return DisallowedInputShortNames.Remove(item.info.shortname)
                               | DisallowedInputItemIds.Remove(item.info.itemid);
                }

                return false;
            }

            public bool Disallow(Item item, IdentificationType identificationType)
            {
                switch (identificationType)
                {
                    case IdentificationType.DisplayName:
                        return DisallowedInputDisplayNames.Add(item.name);

                    case IdentificationType.Skin:
                        return DisallowedInputSkinIds.Add(item.skin);

                    case IdentificationType.Item:
                        return DisallowedInputShortNames.Add(item.info.shortname)
                               | DisallowedInputItemIds.Add(item.info.itemid);
                }

                return false;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class OverrideOutput
        {
            [JsonProperty("Override output by input item short name")]
            public Dictionary<string, IngredientInfo[]> OverrideOutputByShortName = new();

            [JsonProperty("Override output by input item skin ID")]
            public Dictionary<ulong, IngredientInfo[]> OverrideOutputBySkinId = new();

            [JsonProperty("Override output by input item display name (custom items)")]
            public CaseInsensitiveDictionary<IngredientInfo[]> OverrideOutputByDisplayName = new();

            [JsonIgnore]
            private Dictionary<int, IngredientInfo[]> OverrideOutputByItemId = new();

            public void Init()
            {
                foreach (var (shortName, ingredientInfoList) in OverrideOutputByShortName)
                {
                    if (string.IsNullOrWhiteSpace(shortName))
                        continue;

                    var itemDefinition = ItemManager.FindItemDefinition(shortName);
                    if (itemDefinition == null)
                    {
                        LogWarning($"Invalid item short name in config: {shortName}");
                        continue;
                    }

                    foreach (var ingredientInfo in ingredientInfoList)
                    {
                        ingredientInfo.Init();
                    }

                    OverrideOutputByItemId[itemDefinition.itemid] = ingredientInfoList;
                }

                foreach (var ingredientInfoList in OverrideOutputBySkinId.Values)
                {
                    foreach (var ingredientInfo in ingredientInfoList)
                    {
                        ingredientInfo.Init();
                    }
                }

                foreach (var ingredientInfoList in OverrideOutputByDisplayName.Values)
                {
                    foreach (var ingredientInfo in ingredientInfoList)
                    {
                        ingredientInfo.Init();
                    }
                }
            }

            public IngredientInfo[] GetOverride(Item item, IdentificationType identificationType)
            {
                IngredientInfo[] customIngredientList;
                switch (identificationType)
                {
                    case IdentificationType.DisplayName:
                        return !string.IsNullOrWhiteSpace(item.name) && OverrideOutputByDisplayName.TryGetValue(item.name, out customIngredientList)
                            ? customIngredientList
                            : null;

                    case IdentificationType.Skin:
                        return item.skin != 0 && OverrideOutputBySkinId.TryGetValue(item.skin, out customIngredientList)
                            ? customIngredientList
                            : null;

                    case IdentificationType.Item:
                        return OverrideOutputByItemId.TryGetValue(item.info.itemid, out customIngredientList)
                            ? customIngredientList
                            : null;
                }

                return null;
            }

            public IngredientInfo[] GetBestOverride(Item item)
            {
                if (!string.IsNullOrWhiteSpace(item.name) && OverrideOutputByDisplayName.TryGetValue(item.name, out var ingredientInfoList))
                    return ingredientInfoList;

                if (item.skin != 0 && OverrideOutputBySkinId.TryGetValue(item.skin, out ingredientInfoList))
                    return ingredientInfoList;

                if (OverrideOutputByItemId.TryGetValue(item.info.itemid, out ingredientInfoList))
                    return ingredientInfoList;

                return null;
            }

            public bool AddOverride(RecycleManager plugin,ItemDefinition itemDefinition)
            {
                if (OverrideOutputByShortName.ContainsKey(itemDefinition.shortname))
                    return false;

                ResetOverride(plugin, itemDefinition);
                return true;
            }

            public void SetOverride(Item item, IdentificationType identificationType, IngredientInfo[] customIngredientList)
            {
                switch (identificationType)
                {
                    case IdentificationType.DisplayName:
                        OverrideOutputByDisplayName[item.name] = customIngredientList;
                        break;

                    case IdentificationType.Skin:
                        OverrideOutputBySkinId[item.skin] = customIngredientList;
                        break;

                    case IdentificationType.Item:
                        OverrideOutputByShortName[item.info.shortname] = customIngredientList;
                        OverrideOutputByItemId[item.info.itemid] = customIngredientList;
                        break;
                }
            }

            public bool RemoveOverride(Item item, IdentificationType identificationType)
            {
                switch (identificationType)
                {
                    case IdentificationType.DisplayName:
                        return OverrideOutputByDisplayName.Remove(item.name);

                    case IdentificationType.Skin:
                        return OverrideOutputBySkinId.Remove(item.skin);

                    case IdentificationType.Item:
                        return OverrideOutputByShortName.Remove(item.info.shortname)
                               | OverrideOutputByItemId.Remove(item.info.itemid);
                }

                return false;
            }

            public void ResetOverride(RecycleManager plugin,ItemDefinition itemDefinition)
            {
                var ingredients = GetVanillaOutput(itemDefinition);

                OverrideOutputByShortName[itemDefinition.shortname] = ingredients;
                OverrideOutputByItemId[itemDefinition.itemid] = ingredients;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Edit UI")]
            public EditUISettings EditUISettings = new();

            [JsonProperty("Custom recycle speed")]
            public SpeedSettings Speed = new();

            [JsonProperty("Custom recycle efficiency")]
            public EfficiencySettings Efficiency = new();

            [JsonProperty("Restricted input items")]
            public RestrictedInputItems RestrictedInputItems = new();

            [JsonProperty("Max items in stack per recycle (% of max stack size)")]
            public MaxItemsPerRecycle MaxItemsPerRecycle = new();

            [JsonProperty("Output multipliers")]
            public OutputMultiplierSettings OutputMultipliers = new();

            [JsonProperty("Override output")]
            public OverrideOutput OverrideOutput = new();

            [JsonProperty("Override output (before efficiency factor)")]
            private OverrideOutput DeprecatedOverrideOutput
            {
                set
                {
                    if (value == null)
                        return;

                    foreach (var entry in value.OverrideOutputByShortName)
                    {
                        foreach (var ingredientInfo in entry.Value)
                        {
                            ingredientInfo.Amount *= 0.5f;
                        }

                        OverrideOutput.OverrideOutputByShortName[entry.Key] = entry.Value;
                    }

                    foreach (var entry in value.OverrideOutputBySkinId)
                    {
                        foreach (var ingredientInfo in entry.Value)
                        {
                            ingredientInfo.Amount *= 0.5f;
                        }

                        OverrideOutput.OverrideOutputBySkinId[entry.Key] = entry.Value;
                    }

                    foreach (var entry in value.OverrideOutputByDisplayName)
                    {
                        foreach (var ingredientInfo in entry.Value)
                        {
                            ingredientInfo.Amount *= 0.5f;
                        }

                        OverrideOutput.OverrideOutputByDisplayName[entry.Key] = entry.Value;
                    }
                }
            }

            public void Init(RecycleManager plugin)
            {
                Speed.Init(plugin);
                RestrictedInputItems.Init();
                MaxItemsPerRecycle.Init();
                OutputMultipliers.Init();
                OverrideOutput.Init();
            }
        }

        private Configuration GetDefaultConfig() => new();

        #region Configuration Helpers

        [JsonObject(MemberSerialization.OptIn)]
        private class BaseConfiguration
        {
            [JsonIgnore]
            public bool UsingDefaults;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigSection(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigSection(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigSection(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
                _config.UsingDefaults = true;
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private class LangEntry
        {
            public static List<LangEntry> AllLangEntries = new();

            public static readonly LangEntry ErrorNoPermission = new("Error.NoPermission", "You don't have permission to do that.");
            public static readonly LangEntry ErrorConfig = new("Error.Config", "Error: The config did not load correctly. Please fix the config and reload the plugin before running this command.");
            public static readonly LangEntry ErrorInvalidItem = new("Error.InvalidItem", "Error: Invalid item: <color=#fe0>{0}</color>");

            public static readonly LangEntry ItemSyntax = new("Item.Syntax", "Syntax: <color=#fe0>{0} <item id or short name></color>");

            public static readonly LangEntry AddExists = new("Add.Exists", "Error: Item <color=#fe0>{0}</color> is already in the config. To reset that item to vanilla output, use <color=#fe0>recyclemanager.reset {0}</color>.");
            public static readonly LangEntry AddSuccess = new("Add.Success", "Successfully added item <color=#fe0>{0}</color> to the config.");

            public static readonly LangEntry ResetSuccess = new("Reset.Success", "Successfully reset item <color=#fe0>{0}</color> in the config.");

            public static readonly LangEntry UIButtonAdmin = new("UI.Button.Admin", "Admin");
            public static readonly LangEntry UIHeader = new("UI.Header", "Recycle Manager");
            public static readonly LangEntry UIButtonClose = new("UI.Button.Close", "Close");
            public static readonly LangEntry UIEmptyState = new("UI.EmptyState", "Place an item into the recycler to preview and edit its output");
            public static readonly LangEntry UIItemBlocked = new("UI.ItemBlocked", "That item is blocked by another plugin");

            public static readonly LangEntry UILabelConfigureBy = new("UI.Label.ConfigureBy", "Configure by:");
            public static readonly LangEntry UIButtonItem = new("UI.Button.Item", "Item");
            public static readonly LangEntry UIButtonSkin = new("UI.Button.Skin", "Skin");
            public static readonly LangEntry UIButtonDisplayName = new("UI.Button.DisplayName", "Display name");

            public static readonly LangEntry UILabelOutput = new("UI.Label.Output", "Output:");
            public static readonly LangEntry UIButtonNotRecyclable = new("UI.Button.NotRecyclable", "Not recyclable");
            public static readonly LangEntry UIButtonDefaultOutput = new("UI.Button.DefaultOutput", "Default output");
            public static readonly LangEntry UIButtonCustomOutput = new("UI.Button.CustomOutput", "Custom output");

            public static readonly LangEntry UILabelActions = new("UI.Label,Actions", "Actions:");
            public static readonly LangEntry UIButtonSave = new("UI.Button.Save", "Save");
            public static readonly LangEntry UIButtonReset = new("UI.Button.Reset", "Reset");
            public static readonly LangEntry UIButtonCancel = new("UI.Button.Cancel", "Cancel");

            public string Name;
            public string English;

            public LangEntry(string name, string english)
            {
                Name = name;
                English = english;

                AllLangEntries.Add(this);
            }
        }


        private string GetMessage(string playerId, LangEntry langEntry) =>
            lang.GetMessage(langEntry.Name, this, playerId);

        private string GetMessage(string playerId, LangEntry langEntry, object arg1) =>
            string.Format(GetMessage(playerId, langEntry), arg1);

        private string GetMessage(string playerId, LangEntry langEntry, object arg1, object arg2) =>
            string.Format(GetMessage(playerId, langEntry), arg1, arg2);

        private string GetMessage(string playerId, LangEntry langEntry, object arg1, object arg2, string arg3) =>
            string.Format(GetMessage(playerId, langEntry), arg1, arg2, arg3);

        private string GetMessage(string playerId, LangEntry langEntry, params object[] args) =>
            string.Format(GetMessage(playerId, langEntry), args);


        private void ReplyToPlayer(IPlayer player, LangEntry langEntry) =>
            player.Reply(GetMessage(player.Id, langEntry));

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object arg1) =>
            player.Reply(GetMessage(player.Id, langEntry, arg1));

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object arg1, object arg2) =>
            player.Reply(GetMessage(player.Id, langEntry, arg1, arg2));

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object arg1, object arg2, object arg3) =>
            player.Reply(GetMessage(player.Id, langEntry, arg1, arg2, arg3));

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry, params object[] args) =>
            player.Reply(GetMessage(player.Id, langEntry, args));


        protected override void LoadDefaultMessages()
        {
            var englishLangKeys = new Dictionary<string, string>();

            foreach (var langEntry in LangEntry.AllLangEntries)
            {
                englishLangKeys[langEntry.Name] = langEntry.English;
            }

            lang.RegisterMessages(englishLangKeys, this, "en");
        }

        #endregion

        #region Tests

        #if ENABLE_TESTS

        private class RecycleManagerTests : BaseTestSuite
        {
            private static void Assert(bool value, string message = null)
            {
                if (!value)
                    throw new Exception($"Assertion failed: {message}");
            }

            private static void AssertItemInSlot(ItemContainer container, int slot, out Item item)
            {
                item = container.GetSlot(slot);
                Assert(item != null, $"Expected item in slot {slot}, but found none.");
            }

            private static void AssertItemShortName(Item item, string shortName)
            {
                Assert(item.info.shortname == shortName, $"Expected item '{shortName}', but found '{item.info.shortname}'.");
            }

            private static void AssertItemSkin(Item item, ulong skin)
            {
                Assert(item.skin == skin, $"Expected item {item.info.shortname} to have skin '{skin}', but found '{item.skin}'.");
            }

            private static void AssertItemDisplayName(Item item, string displayName)
            {
                Assert(item.name == displayName, $"Expected item {item.info.shortname} to have display name '{displayName}', but found '{item.name}'.");
            }

            private static void AssertItemAmount(Item item, int expectedAmount)
            {
                Assert(item.amount == expectedAmount, $"Expected item '{item.info.shortname}' to have amount {expectedAmount}, but found {item.amount}.");
            }

            private static void AssertItemInContainer(ItemContainer container, int slot, string shortName, int amount)
            {
                AssertItemInSlot(container, slot, out var item);
                AssertItemShortName(item, shortName);
                AssertItemAmount(item, amount);
            }

            private static Item CreateItem(string shortName, int amount = 1, ulong skin = 0)
            {
                var item = ItemManager.CreateByName(shortName, amount, skin);
                Assert(item != null, $"Failed to create item with short name '{shortName}' and amount '{amount}' and skin '{skin}'.");
                return item;
            }

            private static Item AddItemToContainer(ItemContainer container, string shortName, int amount = 1, ulong skin = 0, int slot = -1)
            {
                var item = CreateItem(shortName, amount, skin);
                if (!item.MoveToContainer(container, slot))
                    throw new Exception($"Failed to move item '{shortName}' to container.");

                return item;
            }

            private static Action SetMaxStackSize(string shortName, int amount)
            {
                var itemDefinition = ItemManager.FindItemDefinition(shortName);
                Assert(itemDefinition != null, $"Failed to find item definition for short name '{shortName}'.");
                var originalMaxStackSize = itemDefinition.stackable;
                itemDefinition.stackable = amount;
                return () => itemDefinition.stackable = originalMaxStackSize;
            }

            private RecycleManager _plugin;
            private Configuration _originalConfig;
            private Recycler _recycler;
            private BasePlayer _player;

            public RecycleManagerTests(RecycleManager plugin)
            {
                _plugin = plugin;
            }

            protected override void BeforeAll()
            {
                _originalConfig = _plugin._config;

                _recycler = (Recycler)GameManager.server.CreateEntity("assets/bundled/prefabs/static/recycler_static.prefab", new Vector3(0, -1000, 0));
                _recycler.limitNetworking = true;
                _recycler.Spawn();

                _player = (BasePlayer)GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", new Vector3(0, -1000, 0));
                _player.limitNetworking = true;
                _player.modelState.flying = true;
                _player.Spawn();
            }

            protected override void BeforeEach()
            {
                _recycler.inventory.Clear();
                ItemManager.DoRemoves();
                SetupPlayer(123);
            }

            private HashSet<string> GetPluginPermissions()
            {
                var registeredPermissionsField = typeof(Permission).GetField("registeredPermissions", BindingFlags.Instance | BindingFlags.NonPublic);
                var permissionsMap = (Dictionary<Plugin, HashSet<string>>)registeredPermissionsField.GetValue(_plugin.permission);
                return permissionsMap.TryGetValue(_plugin, out var permissionList)
                    ? permissionList
                    : null;
            }

            private void InitializePlugin(Configuration config)
            {
                _plugin._config = config;
                GetPluginPermissions()?.Clear();

                _recycler.StopRecycling();

                // Reset recycle components since they cache the config.
                _plugin._recycleComponentManager.Unload();

                _plugin.Init();
                _plugin.OnServerInitialized();
            }

            private void SetupPlayer(ulong userId)
            {
                _player.userID = userId;
                _player.UserIDString = userId.ToString();

                foreach (var perm in _plugin.permission.GetUserPermissions(_player.UserIDString).ToArray())
                {
                    _plugin.permission.RevokeUserPermission(_player.UserIDString, perm);
                }
            }

            [TestMethod("Given rope is restricted, it should not be allowed in recyclers")]
            public void Test_ItemRestrictions_ItemShortNames()
            {
                InitializePlugin(new Configuration
                {
                    RestrictedInputItems = new RestrictedInputItems
                    {
                        DisallowedInputShortNames = new CaseInsensitiveHashSet
                        {
                            "rope",
                        },
                    },
                });

                // Tarp is not restricted, should be allowed.
                var tarp = CreateItem("tarp");
                if (_recycler.inventory.CanAcceptItem(tarp, 0) != ItemContainer.CanAcceptResult.CanAccept)
                    throw new Exception($"Expected {tarp.info.shortname} to be allowed in recycler, but it was disallowed.");

                var rope = CreateItem("rope");
                if (_recycler.inventory.CanAcceptItem(rope, 0) != ItemContainer.CanAcceptResult.CannotAccept)
                    throw new Exception($"Expected {rope.info.shortname} to be disallowed in recycler, but it was allowed.");
            }

            [TestMethod("Given recycle speed disabled, items should recycle after 5 seconds")]
            public IEnumerator Test_RecycleSpeed_Disabled()
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = false,
                        DefaultRecycleTime = 2,
                    },
                });

                var gears = AddItemToContainer(_recycler.inventory, "gears");
                _recycler.StartRecycling();

                yield return new WaitForSeconds(4.9f);
                AssertItemAmount(gears, 1);
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 0);
            }

            [TestMethod("Given default recycle speed 0.1 seconds, items should recycle after 0.1 seconds")]
            public IEnumerator Test_RecycleSpeed_Enabled()
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.1f,
                    },
                });

                var gears = AddItemToContainer(_recycler.inventory, "gears");
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                AssertItemAmount(gears, 1);
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 0);
            }

            [TestMethod("Given default recycle speed 3 seconds, player permission 0.1 multiplier, items should recycle after 0.3 seconds")]
            public IEnumerator Test_RecycleSpeed_Permission()
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 3,
                        PermissionSpeedProfiles = new PermissionSpeedProfile[]
                        {
                            new() { PermissionSuffix = "fast", TimeMultiplier = 0.1f },
                        },
                    },
                });

                _plugin.permission.GrantUserPermission(_player.UserIDString, "recyclemanager.speed.fast", _plugin);

                var gears = AddItemToContainer(_recycler.inventory, "gears");
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                AssertItemAmount(gears, 1);
                yield return new WaitForSeconds(0.31f);
                AssertItemAmount(gears, 0);
            }

            [TestMethod("Given default recycle time 0.2 seconds, gears 0.5 multiplier, gears should recycle after 0.1 seconds, metalpipes after 0.2 seconds")]
            public IEnumerator Test_RecycleSpeed()
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.2f,
                        TimeMultiplierByShortName = new Dictionary<string, float>
                        {
                            ["gears"] = 0.5f,
                        },
                    },
                });

                var gears1 = AddItemToContainer(_recycler.inventory, "gears", slot: 0);
                var pipe1 = AddItemToContainer(_recycler.inventory, "metalpipe", slot: 1);
                var gears2 = AddItemToContainer(_recycler.inventory, "gears", slot: 2);
                var pipe2 = AddItemToContainer(_recycler.inventory, "metalpipe", slot: 3);

                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears1, 0);
                AssertItemAmount(pipe1, 1);
                AssertItemAmount(gears2, 1);
                AssertItemAmount(pipe2, 1);

                yield return new WaitForSeconds(0.2f);
                AssertItemAmount(pipe1, 0);
                AssertItemAmount(gears2, 1);
                AssertItemAmount(pipe2, 1);

                yield return new WaitForSeconds(0.1f);
                AssertItemAmount(gears2, 0);
                AssertItemAmount(pipe2, 1);

                yield return new WaitForSeconds(0.2f);
                AssertItemAmount(pipe2, 0);
            }

            [TestMethod("Given gears max stack size 100, stack of 3 gears, with no override configured, should output 36 scrap and 48 metal fragments")]
            public IEnumerator Test_RecycleStacks_NoOverride(List<Action> cleanupActions)
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.1f,
                    },
                });

                cleanupActions.Add(SetMaxStackSize("gears", 100));

                var gears = AddItemToContainer(_recycler.inventory, "gears", 3);
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 0);
                AssertItemInContainer(_recycler.inventory, 6, "scrap", 36);
                AssertItemInContainer(_recycler.inventory, 7, "metal.fragments", 48);
            }

            [TestMethod("Given gears max stack size 100, stack of 75 gears, default stack percent 50%, should output 600 scrap & 975 metal fragments, then should output 900 scrap & 1200 metal fragments")]
            public IEnumerator Test_RecycleStacks_DefaultPercent(List<Action> cleanupActions)
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.1f,
                    },
                    MaxItemsPerRecycle = new MaxItemsPerRecycle
                    {
                        DefaultPercent = 50f,
                    },
                });

                cleanupActions.Add(SetMaxStackSize("gears", 100));

                var gears = AddItemToContainer(_recycler.inventory, "gears", 75);
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 25);
                AssertItemInContainer(_recycler.inventory, 6, "scrap", 600);
                AssertItemInContainer(_recycler.inventory, 7, "metal.fragments", 800);

                yield return new WaitForSeconds(0.1f);
                AssertItemAmount(gears, 0);
                AssertItemInContainer(_recycler.inventory, 6, "scrap", 900);
                AssertItemInContainer(_recycler.inventory, 7, "metal.fragments", 1200);
            }

            [TestMethod("Given gears max stack size 100, stack of 75 gears, gears stack percent 50%, should output 600 scrap & 975 metal fragments, then should output 900 scrap & 1200 metal fragments")]
            public IEnumerator Test_RecycleStacks_ShortNamePercent(List<Action> cleanupActions)
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.1f,
                    },
                    MaxItemsPerRecycle = new MaxItemsPerRecycle
                    {
                        DefaultPercent = 10f,
                        PercentByShortName = new Dictionary<string, float>
                        {
                            ["gears"] = 50,
                        },
                    },
                });

                cleanupActions.Add(SetMaxStackSize("gears", 100));

                var gears = AddItemToContainer(_recycler.inventory, "gears", 75);
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 25);
                AssertItemInContainer(_recycler.inventory, 6, "scrap", 600);
                AssertItemInContainer(_recycler.inventory, 7, "metal.fragments", 800);

                yield return new WaitForSeconds(0.1f);
                AssertItemAmount(gears, 0);
                AssertItemInContainer(_recycler.inventory, 6, "scrap", 900);
                AssertItemInContainer(_recycler.inventory, 7, "metal.fragments", 1200);
            }

            [TestMethod("Given 2.0 default multiplier, 3.0 scrap output multiplier, stack of 3 gears, should output 108 scrap & 96 metal fragments")]
            public IEnumerator Test_OutputMultipliers(List<Action> cleanupActions)
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.1f,
                    },
                    OutputMultipliers = new OutputMultiplierSettings
                    {
                        DefaultMultiplier = 2,
                        MultiplierByOutputShortName = new Dictionary<string, float>
                        {
                            ["scrap"] = 3f,
                        },
                    },
                });

                cleanupActions.Add(SetMaxStackSize("gears", 100));

                var gears = AddItemToContainer(_recycler.inventory, "gears", 3);
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 0);
                AssertItemInContainer(_recycler.inventory, 6, "scrap", 108);
                AssertItemInContainer(_recycler.inventory, 7, "metal.fragments", 96);
            }

            [TestMethod("Given override for gears, stack of 3 gears, should output custom items")]
            public IEnumerator Test_OverrideOutput_ByItemShortName(List<Action> cleanupActions)
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.1f,
                    },
                    OutputMultipliers = new OutputMultiplierSettings
                    {
                        // Output multipliers should have no effect.
                        DefaultMultiplier = 2,
                    },
                    OverrideOutput = new OverrideOutput
                    {
                        OverrideOutputByShortName = new CaseInsensitiveDictionary<IngredientInfo[]>
                        {
                            ["gears"] = new IngredientInfo[]
                            {
                                new()
                                {
                                    ShortName = "wood",
                                    Amount = 50,
                                    SkinId = 123456,
                                    DisplayName = "Vood",
                                },
                            },
                        },
                    },
                });

                cleanupActions.Add(SetMaxStackSize("gears", 100));

                var gears = AddItemToContainer(_recycler.inventory, "gears", 3);
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 0);

                AssertItemInSlot(_recycler.inventory, 6, out var outputItem);
                AssertItemShortName(outputItem, "wood");
                AssertItemSkin(outputItem, 123456);
                AssertItemDisplayName(outputItem, "Vood");
                AssertItemAmount(outputItem, 150);
            }

            protected override void AfterAll(bool interrupted)
            {
                if (_recycler != null && !_recycler.IsDestroyed)
                {
                    _recycler.Kill();
                }

                if (_player != null && !_player.IsDestroyed)
                {
                    _player.Die();
                }

                if (!interrupted)
                {
                    InitializePlugin(_originalConfig);
                }
            }
        }

        #endif

        #endregion

        #region Test Runner

        #if ENABLE_TESTS

        [AttributeUsage(AttributeTargets.Method)]
        public class TestMethodAttribute : Attribute
        {
            public readonly string Name;
            public bool Skip;
            public bool Only;

            public TestMethodAttribute(string name = null)
            {
                Name = name;
            }
        }

        public abstract class BaseTestSuite
        {
            private enum TestStatus
            {
                Skipped,
                Running,
                Success,
                Error,
            }

            private class TestInfo
            {
                public string Name;
                public bool Async;
                public MethodInfo MethodInfo;
                public TestMethodAttribute Attribute;
                public TestStatus Status = TestStatus.Skipped;
                public bool ShouldSkip;
                public Exception Exception;
            }

            public bool IsRunning { get; private set; }

            private List<TestInfo> _testInfoList = new();
            private Coroutine _coroutine;

            protected virtual void BeforeAll() {}
            protected virtual void BeforeEach() {}
            protected virtual void AfterEach() {}
            protected virtual void AfterAll(bool interrupted) {}

            public void Run()
            {
                if (IsRunning)
                    return;

                if (!TryRunBeforeAll())
                    return;

                var hasOnly = false;

                foreach (var methodInfo in GetType().GetMethods())
                {
                    if (methodInfo.GetCustomAttributes(typeof(TestMethodAttribute), true).FirstOrDefault() is not TestMethodAttribute testMethodAttribute)
                        continue;

                    var isAsync = methodInfo.ReturnType == typeof(IEnumerator);
                    if (!isAsync && methodInfo.ReturnType != typeof(void))
                    {
                        LogError($"Disallowed return type '{methodInfo.ReturnType.FullName}' for test '{testMethodAttribute.Name}'");
                        continue;
                    }

                    hasOnly |= testMethodAttribute.Only;

                    _testInfoList.Add(new TestInfo
                    {
                        Name = testMethodAttribute.Name,
                        Async = isAsync,
                        MethodInfo = methodInfo,
                        Attribute = testMethodAttribute,
                        ShouldSkip = testMethodAttribute.Skip,
                    });
                }

                if (hasOnly)
                {
                    foreach (var testInfo in _testInfoList)
                    {
                        testInfo.ShouldSkip = !testInfo.Attribute.Only;
                    }
                }

                var syncTestList = _testInfoList.Where(testInfo => !testInfo.Async).ToArray();
                var asyncTestList = _testInfoList.Where(testInfo => testInfo.Async).ToArray();

                var canKeepRunning = RunSyncTests(syncTestList);
                if (!canKeepRunning && asyncTestList.Length == 0)
                {
                    RunAfterAll();
                    return;
                }

                _coroutine = ServerMgr.Instance.StartCoroutine(RunAsyncTests(asyncTestList));
            }

            public void Interrupt()
            {
                if (!IsRunning)
                    return;

                if (_coroutine != null)
                {
                    ServerMgr.Instance.StopCoroutine(_coroutine);
                    LogWarning("Interrupted tests.");
                }

                RunAfterAll(true);
            }

            private bool TryRunBeforeAll()
            {
                IsRunning = true;

                try
                {
                    BeforeAll();
                    return true;
                }
                catch (Exception ex)
                {
                    LogError($"Failed to run BeforeAll() for test suite {GetType().FullName}:\n{ex}");
                    IsRunning = false;
                    return false;
                }
            }

            private bool TryRunBeforeEach()
            {
                try
                {
                    BeforeEach();
                    return true;
                }
                catch (Exception ex)
                {
                    LogError($"Failed to run BeforeEach() for test suite {GetType().FullName}:\n{ex}");
                    return false;
                }
            }

            private bool TryRunAfterEach()
            {
                try
                {
                    AfterEach();
                    return true;
                }
                catch (Exception ex)
                {
                    LogError($"Failed to run AfterEach() for test suite {GetType().FullName}:\n{ex}");
                    return false;
                }
            }

            private void RunAfterAll(bool interrupted = false)
            {
                try
                {
                    AfterAll(interrupted);
                }
                catch (Exception ex)
                {
                    LogError($"Failed to run AfterAll() method for test suite {GetType().FullName}:\n{ex}");
                }

                IsRunning = false;

                if (!interrupted)
                {
                    PrintResults();
                }
            }

            private bool HasParameter<T>(MethodInfo methodInfo, int parameterIndex = 0)
            {
                return methodInfo.GetParameters().ElementAtOrDefault(parameterIndex)?.ParameterType == typeof(T);
            }

            private object[] CreateTestArguments(MethodInfo methodInfo, out List<Action> cleanupActions)
            {
                if (HasParameter<List<Action>>(methodInfo))
                {
                    cleanupActions = new List<Action>();
                    return new object[] { cleanupActions };
                }

                cleanupActions = null;
                return null;
            }

            private void RunCleanupActions(List<Action> cleanupActions)
            {
                if (cleanupActions == null)
                    return;

                foreach (var action in cleanupActions)
                {
                    try
                    {
                        action.Invoke();
                    }
                    catch (Exception ex)
                    {
                        LogError($"Failed to run cleanup action:\n{ex}");
                    }
                }
            }

            private bool RunSyncTests(IEnumerable<TestInfo> syncTestList)
            {
                foreach (var testInfo in syncTestList)
                {
                    if (testInfo.ShouldSkip)
                        continue;

                    if (!TryRunBeforeEach())
                        return false;

                    var args = CreateTestArguments(testInfo.MethodInfo, out var cleanupActions);

                    try
                    {
                        testInfo.MethodInfo.Invoke(this, args);
                        testInfo.Status = TestStatus.Success;
                    }
                    catch (Exception ex)
                    {
                        testInfo.Exception = ex;
                        testInfo.Status = TestStatus.Error;
                    }

                    RunCleanupActions(cleanupActions);

                    if (!TryRunAfterEach())
                        return false;
                }

                return true;
            }

            private IEnumerator RunAsyncTests(IEnumerable<TestInfo> asyncTestList)
            {
                foreach (var testInfo in asyncTestList)
                {
                    if (testInfo.ShouldSkip)
                        continue;

                    if (!TryRunBeforeEach())
                        break;

                    var args = CreateTestArguments(testInfo.MethodInfo, out var cleanupActions);

                    IEnumerator enumerator;

                    try
                    {
                        enumerator = (IEnumerator)testInfo.MethodInfo.Invoke(this, args);
                    }
                    catch (Exception ex)
                    {
                        RunCleanupActions(cleanupActions);
                        testInfo.Exception = ex;
                        testInfo.Status = TestStatus.Error;
                        continue;
                    }

                    testInfo.Status = TestStatus.Running;

                    while (testInfo.Status == TestStatus.Running)
                    {
                        // This assumes Current is null or an instance of YieldInstruction.
                        yield return enumerator.Current;

                        try
                        {
                            if (!enumerator.MoveNext())
                            {
                                testInfo.Status = TestStatus.Success;
                                break;
                            }
                        }
                        catch (Exception ex)
                        {
                            RunCleanupActions(cleanupActions);
                            testInfo.Exception = ex;
                            testInfo.Status = TestStatus.Error;
                            break;
                        }
                    }

                    RunCleanupActions(cleanupActions);

                    if (!TryRunAfterEach())
                        break;
                }

                RunAfterAll();
            }

            private void PrintResults()
            {
                foreach (var testInfo in _testInfoList)
                {
                    switch (testInfo.Status)
                    {
                        case TestStatus.Success:
                            LogWarning($"[PASSED]  {testInfo.Name}");
                            break;

                        case TestStatus.Skipped:
                            LogWarning($"[SKIPPED] {testInfo.Name}");
                            break;

                        case TestStatus.Error:
                            LogError($"[FAILED]  {testInfo.Name}:\n{testInfo.Exception}");
                            break;

                        case TestStatus.Running:
                            LogError($"[RUNNING] {testInfo.Name}");
                            break;

                        default:
                            LogError($"[{testInfo.Status}] {testInfo.Name}");
                            break;
                    }
                }
            }
        }

        #endif

        #endregion
    }
}

// --- End of file: RecycleManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rust-game-ban-check ---
// --- Original File Path: R/RustGameBanCheck/RustGameBanCheck.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info("Rust Gameban Check", "Rogder Dodger", "1.1.2"),
     Description("Checks against GameBanDb for previous rust bans and alerts via discord")]
    public class RustGameBanCheck : RustPlugin
    {
        #region globals

        private const string DefaultWebhookURL = "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
        private const int WebTimeoutThreshold = 2000;
        private const string GameBanDbUrl = "https://rustbans.com/api";
        private const string DefaultBanMessage = "Previous Gameban Detected";

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Log To Console")]
            public bool LogToConsole;

            [JsonProperty(PropertyName = "Log To Discord")]
            public bool LogToDiscord;

            [JsonProperty(PropertyName = "Discord Webhook URL")]
            public string DiscordWebhookUrl = DefaultWebhookURL;

            [JsonProperty(PropertyName = "Whitelist Steam IDs")]
            public List<ulong> WhitelistedSteamIds;

            [JsonProperty(PropertyName = "Automatically Ban Players with previous Rust Bans")]
            public bool AutomaticallyBan;

            [JsonProperty(PropertyName = "Ban Message")]
            public string BanMessage;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("A new configuration file is being generated.");
            _config = new Configuration
            {
                LogToConsole = true,
                LogToDiscord = true,
                DiscordWebhookUrl = DefaultWebhookURL,
                WhitelistedSteamIds = new List<ulong>(),
                AutomaticallyBan = false,
                BanMessage = "Previous Gameban Detected"
            };
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["EmbedTitle"] = "GAMEBAN DETECTED!",
                ["EmbedDetailsWithBattlemetrics"] = "**Player:**\n{playerName}\n{playerId}\n[Steam Profile](https://steamcommunity.com/profiles/{playerId})\n\n**Links:**\n[Battlemetrics](https://www.battlemetrics.com/rcon/players?filter%5Bsearch%5D={playerId}&filter%5Bservers%5D=false&filter%5BplayerFlags%5D=&sort=score&showServers=true)",
                ["ConsoleMessage"] = "GAME BAN DETECTED on {playerName}/{playerId} - {twitterUrl}"
            }, this);
        }

        private string FormatMessage(string key, BasePlayer player, GameBannedDbResponse gameBanDetails)
        {
            return lang.GetMessage(key, this)
                .Replace("{playerName}", player.displayName)
                .Replace("{playerId}", player.UserIDString)
                .Replace("{serverName}", covalence.Server.Name);
        }

        #endregion

        #region Models

        private class GameBannedDbResponse
        {
            [JsonProperty("TweetLink")] public string? TweetLink { get; set; }

            [JsonProperty("BanDateMilliseconds")] public string? BanDateMilliseconds { get; set; }

            [JsonProperty("SteamID64")] public string? SteamID64 { get; set; }
            [JsonProperty("Banned")] public bool Banned { get; set; }

            [JsonProperty("TempBanCheck")] public string? TempBanCheck { get; set; }
        }

        #endregion'

        #region Hooks

        private void Init()
        {
            _config = Config.ReadObject<Configuration>();

            if (_config.BanMessage == null)
            {
                _config.BanMessage = DefaultBanMessage;
                SaveConfig();
            }

            if (_config.LogToDiscord && _config.DiscordWebhookUrl == DefaultWebhookURL)
            {
                PrintWarning($"Please set the discord webhook in the configuration file!)");
                Unsubscribe(nameof(OnPlayerConnected));
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (_config.WhitelistedSteamIds.Contains(player.userID)) return;
            CheckAndApplyGameBan(player.userID);
        }

        void CheckAndApplyGameBan(ulong userId)
        {
            string url = $"{GameBanDbUrl}/{userId}";
            webrequest.Enqueue(url, "", (httpCode, response) => HandleGameBan(httpCode, response, userId),
                this, Core.Libraries.RequestMethod.GET, null, WebTimeoutThreshold);
        }

        void HandleGameBan(int httpCode, string response, ulong userId)
        {
            if (httpCode == (int)StatusCode.Success)
            {
                var gameBanDetails = JsonConvert.DeserializeObject<IEnumerable<GameBannedDbResponse>>(response)
                    .FirstOrDefault();
                if (gameBanDetails.Banned)
                {
                    if (_config.LogToDiscord)
                    {
                        SendDiscordEmbed(gameBanDetails, BasePlayer.FindByID(userId));
                    }

                    if (_config.LogToConsole)
                    {
                        Puts(FormatMessage("ConsoleMessage", BasePlayer.FindByID(userId), gameBanDetails));
                    }

                    if (_config.AutomaticallyBan)
                    {
                        covalence.Players.FindPlayer(userId.ToString()).Ban(_config.BanMessage);
                    }
                }
            }
            else
            {
                PrintError($"Failed to check game ban for user {userId}. Status Code: {httpCode} Returned from API");
            }
        }

        #endregion

        #region Webhook

        private void SendDiscordEmbed(GameBannedDbResponse gameBanDetails, BasePlayer player)
        {
            var title = FormatMessage("EmbedTitle", player, gameBanDetails);
            var description = FormatMessage("EmbedDetailsWithBattlemetrics", player, gameBanDetails);
            var payload = new
            {
                embeds = new[]
                {
                    new
                    {
                        title,
                        description,
                        color = 10038562,
                        timestamp = DateTime.Now,
                    }
                }
            };

            var form = new WWWForm();
            form.AddField("payload_json", JsonConvert.SerializeObject(payload));
            ServerMgr.Instance.StartCoroutine(PostToDiscord(_config.DiscordWebhookUrl, form));
        }
      
        private IEnumerator PostToDiscord(string url, WWWForm data)
        {
            var www = UnityWebRequest.Post(url, data);
            yield return www.SendWebRequest();

            if (www.isNetworkError || www.isHttpError)
            {
                Puts($"Failed to post to discord: {www.error}");
            }
        }

        #endregion

        #region enums

        private enum StatusCode
        {
            Success = 200,
            BadRequest = 400,
            Unauthorized = 401,
            Forbidden = 403,
            NotFound = 404,
            MethodNotAllowed = 405,
            TooManyRequests = 429,
            InternalError = 500,
            Unavailable = 503,
        }

        #endregion
    }
}

// --- End of file: RustGameBanCheck.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rust-statistics ---
// --- Original File Path: R/RustStatistics/RustStatistics.cs ---

using System;
using CompanionServer.Handlers;
using Oxide.Core.Libraries;
using ConVar;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Game.Rust.Libraries;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Rust Statistics", "Pwenill", "1.0.0")]
    [Description("Get player statistics for sent to our website, and warn the server of potential threat")]
    class RustStatistics : RustPlugin
    {
        #region Variables
        private PluginConfig config;
        private Timer timerSendStats;

        private Dictionary<string, PlayerStats> playersData = new Dictionary<string, PlayerStats>();
        private ServerStats serversStats = new ServerStats();

        // API KEY VERSION ACCES TO API
        public string rs_token = "3x77pEqNj648XhDdMr8p9AG9p33WH4k7M6yNSUsx4Ccb8Y";
        public string rs_url = "https://plugins.ruststatistics.com";
        #endregion

        #region Class
        private class ResponseRequest
        {
            public string data;
            public string type;
        }
        private class ServerStats
        {
            public ServerOptional info = new ServerOptional();
            public Dictionary<DateTime, int> players = new Dictionary<DateTime, int>();
            public Dictionary<string, string> admins = new Dictionary<string, string>();
        }
        private class ServerOptional
        {
            public string hostname;
            public string description;
            public int queryport;
            public int port;

            public ServerOptional()
            {
                hostname = ConVar.Server.hostname;
                description = ConVar.Server.description;
                queryport = ConVar.Server.queryport;
                port = ConVar.Server.port;
            }
        }
        private class PlayerStats
        {
            public string SteamID;
            public string Username;
            public Dictionary<string, Dictionary<string, int>> Npc_hit;
            public Dictionary<string, Dictionary<string, int>> Hits;
            public Dictionary<DateTime, StatsKD> KD;
            public Dictionary<DateTime, int> Messages;
            public Dictionary<DateTime, int> Connections;
            public List<Constructions> ContructionsDestroyed;

            public PlayerStats(string steamID, string username)
            {
                SteamID = steamID;
                Username = username;
                KD = new Dictionary<DateTime, StatsKD>();
                Npc_hit = new Dictionary<string, Dictionary<string, int>>();
                Hits = new Dictionary<string, Dictionary<string, int>>();
                Messages = new Dictionary<DateTime, int>();
                Connections = new Dictionary<DateTime, int>();
                ContructionsDestroyed = new List<Constructions>();
            }
        }
        private class Constructions
        {
            public string Name;
            public string Grade;
            public Dictionary<string, int> Weapons;

            public Constructions(string name, string grade, Dictionary<string, int> weapons)
            {
                Name = name;
                Grade = grade;
                Weapons = weapons;
            }
        }
        private class StatsKD
        {
            public int Kills;
            public int Deaths;

            public StatsKD(int kills = 0, int deaths = 0)
            {
                Kills = kills;
                Deaths = deaths;
            }
        }
        #endregion

        #region Config
        private class PluginConfig
        {
            public string ClientID;
            public string ClientSecret;
            public string Token;
            public bool Linked;
            public float Interval;
            public bool DebugConsole;
            public BansLevelsConfig BansLevel;
        }
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }
        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                Token = "false",
                ClientID = "",
                ClientSecret = "",
                Linked = false,
                DebugConsole = false,
                BansLevel = new BansLevelsConfig(),
            };
        }
        private class BansLevelsConfig
        {
            public int Critical;
            public int Moderate;
            public int Minor;

            public BansLevelsConfig()
            {
                Critical = 3;
                Moderate = 5;
                Minor = -1;
            }
        }
        private void SaveConfig()
        {
            Config.WriteObject(config, true);
        }
        #endregion

        #region Hooks

        #region Server
        void OnServerSave()
        {
            if (timerSendStats != null)
                if (timerSendStats.Destroyed)
                    TimerStatistics();
        }
        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }
        void Loaded()
        {
            if (config.Token != "false")
            {
                if (config.ClientID == "" || config.ClientSecret == "")
                {
                    PrintWarning(string.Format(lang.GetMessage("RequiredLinked", this), $"https://ruststatistics/add?token={config.Token}"));
                    return;
                }
                else
                {
                    if (config.Linked)
                    {
                        PrintWarning(lang.GetMessage("PluginLinked", this));
                        TimerStatistics();
                        return;
                    }
                }
            }

            Dictionary<string, string> headers = new Dictionary<string, string>();
            Dictionary<string, string> query = new Dictionary<string, string>();

            // HEADERS
            headers.Add("rs_token", rs_token);
            headers.Add("client_id", config.ClientID);
            headers.Add("client_secret", config.ClientSecret);

            Dictionary<string, string> playersBans = new Dictionary<string, string>();
            foreach (var item in Admin.Bans())
                playersBans.Add(item.steamid.ToString(), item.notes);

            string hostname = "Rust Server";
            if (ConVar.Admin.ServerInfo().Hostname != null)
                hostname = ConVar.Admin.ServerInfo().Hostname;

            // BODY
            query.Add("token", config.Token);
            query.Add("hostname", hostname);
            query.Add("port", ConVar.Server.port.ToString());
            query.Add("queryport", ConVar.Server.queryport.ToString());
            query.Add("description", ConVar.Server.description);
            query.Add("banned", JsonConvert.SerializeObject(playersBans));

            webrequest.Enqueue($"{rs_url}/server/create", QueryString(query), (code, response) =>
            {
                if (code == 0)
                    return;

                ResponseRequest obj = JsonConvert.DeserializeObject<ResponseRequest>(response);
                if (obj.data == null)
                    return;

                if (code != 200)
                {
                    if (obj.type != null && obj.type == "linked")
                    {
                        config.Linked = true;
                        SaveConfig();
                    }

                    DebugConsole(obj.data, "error");
                    return;
                }

                if (obj.type != null)
                {
                    if (obj.type == "token")
                    {
                        config.Token = obj.data;
                        SaveConfig();

                        PrintWarning(string.Format(lang.GetMessage("SuccessToken", this), $"https://ruststatistics.com/add?token={config.Token}"));
                    }
                    if (obj.type == "linked")
                    {
                        config.Linked = true;
                        SaveConfig();

                        PrintWarning(lang.GetMessage("PluginLinked", this));
                        TimerStatistics();
                    }
                }
            }, this, RequestMethod.POST, headers);
        }
        #endregion

        #region Statistics
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            var building = entity as BuildingBlock;
            if (building == null)
                return;

            BasePlayer player = info.InitiatorPlayer;
            if (player == null)
                return;

            PlayerStats playerStats = addOrGetPlayer(player.UserIDString, player.displayName);
            if (playerStats == null)
                return;

            if (info.WeaponPrefab == null)
                return;

            if (!(info.WeaponPrefab is TimedExplosive))
                return;

            Dictionary<string, int> weapons;
            string weaponName = info.WeaponPrefab.ShortPrefabName;
            string grade = building.grade.ToString();

            var construction = playerStats.ContructionsDestroyed.Where(x => x.Name == entity.ShortPrefabName && x.Grade == grade).FirstOrDefault();
            if (construction != null)
            {
                int count;
                if (construction.Weapons.TryGetValue(weaponName, out count))
                {
                    count++;
                    return;
                }
                construction.Weapons.Add(weaponName, 1);
                return;
            }

            Dictionary<string, int> weapons2 = new Dictionary<string, int>();
            weapons2.Add(weaponName, 1);
            playerStats.ContructionsDestroyed.Add(new Constructions(entity.ShortPrefabName, grade, weapons2));
        }
        void OnPlayerBanned(string name, ulong id, string address, string reason)
        {
            getAuthToken(token =>
            {
                Dictionary<string, string> headers = new Dictionary<string, string>();
                headers.Add("Authorization", token);
                headers.Add("rs_token", rs_token);

                Dictionary<string, string> query = new Dictionary<string, string>();
                query.Add("steamid", id.ToString());
                query.Add("ip", address);
                query.Add("reason", reason);
                query.Add("port", ConVar.Server.port.ToString());

                webrequest.Enqueue($"{rs_url}/asb/ban", QueryString(query), (code, response) =>
                {
                    if (code == 0)
                        return;

                    ResponseRequest data = JsonConvert.DeserializeObject<ResponseRequest>(response);
                    if (data.data == null)
                        return;

                    if (code != 200)
                    {
                        DebugConsole(data.data, "error");
                        return;
                    }
                }, this, RequestMethod.POST, headers);
            });
        }
        object OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (!player.IsConnected)
                return null;

            if (player.IsNpc)
                return null;

            BasePlayer killed = info.InitiatorPlayer;
            if (killed == null)
                return null;

            if (killed.UserIDString == player.UserIDString)
                return null;

            if (killed.IsNpc)
                return null;

            // Get player data is death
            PlayerStats playerDeath = addOrGetPlayer(player.UserIDString, player.displayName);
            if (playerDeath != null)
            {
                if (playerDeath.KD.ContainsKey(DateTime.Today))
                    playerDeath.KD[DateTime.Today].Deaths++;
                else
                    playerDeath.KD.Add(DateTime.Today, new StatsKD(deaths: 1));
            }

            PlayerStats playerKilled = addOrGetPlayer(killed.UserIDString, killed.displayName);
            if (playerKilled != null)
            {
                if (playerKilled.KD.ContainsKey(DateTime.Today))
                    playerKilled.KD[DateTime.Today].Kills++;
                else
                    playerKilled.KD.Add(DateTime.Today, new StatsKD(kills: 1));
            }
            return null;
        }
        object OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (attacker == null)
                return null;

            if (info.HitEntity == null)
                return null;

            if (info.HitEntity is NPCPlayer || info.HitEntity is BaseAnimalNPC)
            {
                IncrementNPCHits(attacker, info);
                return null;
            }

            BasePlayer victim = info.HitEntity.ToPlayer();
            if (victim == null)
                return null;

            IncrementHits(attacker, info);
            return null;
        }
        object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            PlayerStats pstats = addOrGetPlayer(player.UserIDString, player.displayName);
            if (pstats != null)
                IncrementCountTime(pstats.Messages);
            return null;
        }
        void OnPlayerConnected(BasePlayer player)
        {
            string id = player.UserIDString;
            string ipAddress = player.net.connection.ipaddress;
            string name = player.displayName;
            ExecuteAdminSystemBans(id, ipAddress, name);

            if (serversStats.players.ContainsKey(DateTime.Today))
                serversStats.players[DateTime.Today]++;
            else
                serversStats.players.Add(DateTime.Today, 1);

            PlayerStats pstats = addOrGetPlayer(id, name);
            if (pstats != null)
                IncrementCountTime(pstats.Connections);
        }
        #endregion

        #endregion

        #region Web
        void TimerStatistics()
        {
            if (timerSendStats != null)
                timerSendStats.Destroy();

            timerSendStats = timer.Once(config.Interval, () => SendStatistics());
        }
        void SendStatistics()
        {
            serversStats.admins = new Dictionary<string, string>();
            foreach (var player in BasePlayer.allPlayerList)
                if (player.IsAdmin)
                    if (!serversStats.admins.ContainsKey(player.UserIDString))
                        serversStats.admins.Add(player.UserIDString, player.displayName);

            getAuthToken(token =>
            {
                Dictionary<string, string> headers = new Dictionary<string, string>();
                headers.Add("Authorization", token);
                headers.Add("rs_token", rs_token);

                Dictionary<string, string> query = new Dictionary<string, string>();
                query.Add("players", JsonConvert.SerializeObject(playersData.Values));
                query.Add("server", JsonConvert.SerializeObject(serversStats));

                DebugConsole("Waiting for send statistics");
                webrequest.Enqueue($"{rs_url}/statistics/send", QueryString(query), (code, response) =>
                {
                    if (code == 0)
                        return;

                    ResponseRequest data = JsonConvert.DeserializeObject<ResponseRequest>(response);
                    if (data.data == null)
                        return;

                    if (code != 200)
                    {
                        if (data.type != null)
                        {
                            if (data.type == "date")
                            {
                                float newTimer = float.Parse(data.data);

                                config.Interval = newTimer;
                                SaveConfig();

                                DebugConsole("The Time is incorect !");
                            }
                        }
                        else
                        {
                            DebugConsole(data.data, "error");
                        }
                    }

                    if (data.data == "true")
                    {
                        DebugConsole("Statistics was send succesfully");

                        config.Interval = 1800;
                        SaveConfig();

                        playersData = new Dictionary<string, PlayerStats>();
                        serversStats = new ServerStats();
                    }

                    TimerStatistics();
                }, this, RequestMethod.POST, headers);
            });
        }
        void getAuthToken(Action<string> callback)
        {
            if (config.ClientID == "" || config.ClientSecret == "")
                return;

            Dictionary<string, string> headers = new Dictionary<string, string>();
            headers.Add("rs_token", rs_token);
            headers.Add("client_id", config.ClientID);
            headers.Add("client_secret", config.ClientSecret);

            webrequest.Enqueue($"{rs_url}/token", null, (code, response) =>
            {
                if (code == 0)
                    return;

                ResponseRequest data = JsonConvert.DeserializeObject<ResponseRequest>(response);
                if (data.data == null)
                    return;

                if (code != 200)
                {
                    DebugConsole(data.data, "error");
                    return;
                }

                callback(data.data);
            }, this, RequestMethod.POST, headers);
        }
        #endregion

        #region Functions
        void ExecuteAdminSystemBans(string id, string ipAddress, string name)
        {
            getAuthToken(token =>
            {
                Dictionary<string, string> headers = new Dictionary<string, string>();
                Dictionary<string, string> query = new Dictionary<string, string>();

                headers.Add("Authorization", token);
                headers.Add("rs_token", rs_token);

                query.Add("steamid", id);
                query.Add("ip", ipAddress);
                query.Add("port", ConVar.Server.port.ToString());

                webrequest.Enqueue($"{rs_url}/asb/", QueryString(query), (code, response) =>
                {
                    if (code == 0)
                        return;

                    ResponseRequest data = JsonConvert.DeserializeObject<ResponseRequest>(response);
                    if (data.data == null)
                        return;

                    if (code != 200)
                    {
                        DebugConsole(data.data, "error");
                        return;
                    }

                    banPlayerWithLevel(data.data, id);

                    DebugConsole(data.data);
                    PrintToChat(string.Format(lang.GetMessage("ReportedMessage", this), name, data.data.Replace(',', '\n')));
                }, this, RequestMethod.POST, headers);
            });
        }
        object banPlayerWithLevel(string data, string steamid)
        {
            Dictionary<string, string> list = new Dictionary<string, string>();

            foreach (var item in data.Split(','))
            {
                string[] spliting = item.Split(' ');
                string level = spliting[1];
                string count = spliting[0];

                list.Add(level, count);
            }

            foreach (var level in list)
            {
                string reason = string.Format(lang.GetMessage("AutoBanLevel", this), level.Value, level.Key) + "B8Q9AZ";
                int count;
                if (int.TryParse(level.Value, out count))
                {
                    switch (level.Key)
                    {
                        case "critical":
                            if (config.BansLevel.Critical <= count)
                            {
                                Player.Ban(steamid, reason);
                                return reason;
                            }
                            break;
                        case "moderate":
                            if (config.BansLevel.Moderate <= count)
                            {
                                Player.Ban(steamid, reason);
                                return reason;
                            }
                            break;
                        case "minor":
                            if (config.BansLevel.Minor <= count)
                            {
                                Player.Ban(steamid, reason);
                                return reason;
                            }
                            break;
                    }
                }
            }
            return null;
        }
        void DebugConsole(string message, string type = "warning")
        {
            if (!config.DebugConsole)
                return;

            if (type == "warning")
                PrintWarning(message);

            if (type == "error")
                PrintError(message);
        }
        object IncrementNPCHits(BasePlayer player, HitInfo info)
        {
            Dictionary<string, int> keyValuePairs = new Dictionary<string, int>();
            Dictionary<string, int> statsWeapons;

            PlayerStats pstats = addOrGetPlayer(player.UserIDString, player.displayName);
            if (pstats == null)
                return null;

            if (info.HitEntity == null)
                return null;

            // Check is dead
            if (info.HitEntity.ShortPrefabName.Contains("corpse"))
                return null;

            if (pstats.Npc_hit.TryGetValue(info.HitEntity.ShortPrefabName, out statsWeapons))
            {
                if (statsWeapons.ContainsKey(info.Weapon.GetItem().info.shortname))
                    return statsWeapons[info.Weapon.GetItem().info.shortname]++;
                statsWeapons.Add(info.Weapon.GetItem().info.shortname, 1);

                return null;
            }

            keyValuePairs.Add(info.Weapon.GetItem().info.shortname, 1);
            pstats.Npc_hit.Add(info.HitEntity.ShortPrefabName, keyValuePairs);

            return null;
        }
        object IncrementHits(BasePlayer player, HitInfo info)
        {
            Dictionary<string, int> keyValuePairs = new Dictionary<string, int>();
            Dictionary<string, int> statsWeapons;

            PlayerStats stats = addOrGetPlayer(player.UserIDString, player.displayName);
            if (stats == null)
                return null;

            if (stats.Hits.TryGetValue(info.boneName, out statsWeapons))
            {
                if (statsWeapons.ContainsKey(info.Weapon.GetItem().info.shortname))
                    return statsWeapons[info.Weapon.GetItem().info.shortname]++;
                statsWeapons.Add(info.Weapon.GetItem().info.shortname, 1);

                return null;
            }

            keyValuePairs.Add(info.Weapon.GetItem().info.shortname, 1);
            stats.Hits.Add(info.boneName, keyValuePairs);
            return null;
        }
        object IncrementCountTime(Dictionary<DateTime, int> dictionary)
        {
            if (dictionary.ContainsKey(DateTime.Today))
                return dictionary[DateTime.Today]++;
            dictionary.Add(DateTime.Today, 1);
            return null;
        }
        PlayerStats addOrGetPlayer(string steamid, string username)
        {
            PlayerStats playerStats;
            if (!playersData.TryGetValue(steamid, out playerStats))
            {
                playerStats = new PlayerStats(steamid, username);
                playersData.Add(steamid, playerStats);
            }

            return playerStats;
        }
        public static string QueryString(Dictionary<string, string> dict)
        {
            var list = new List<string>();
            foreach (var item in dict)
                list.Add(item.Key + "=" + item.Value);
            return string.Join("&", list);
        }

        #endregion

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PluginLinked"] = "The plugin is well connected to ruststatistics.com",
                ["RequiredLinked"] = "You must connect your server to our website via this url {0}",
                ["SuccessToken"] = "A new token was saved, please link it via the url {0}",
                ["AutoBanLevel"] = "You were automatically banned because you have {0} \"{1}\" warnings",
                ["ReportedMessage"] = "\"{0}\" users has been reported by AdminSystemBans\n{1}",
            }, this);
        }
        #endregion
    }
}


// --- End of file: RustStatistics.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/remove-puzzle-doors ---
// --- Original File Path: R/RemovePuzzleDoors/RemovePuzzleDoors.cs ---

using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Remove Puzzle Doors", "ziptie", 1.1)]
    [Description("Removes puzzle doors.")]
    public class RemovePuzzleDoors : CovalencePlugin
    {
        #region Config
        public RemovePuzzleDoorsConfig config;
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private RemovePuzzleDoorsConfig GetDefaultConfig()
        {
            return new RemovePuzzleDoorsConfig();
        }
        #endregion

        #region Logic
        private void OnServerInitialized(bool initial)
        {
            Puts("Killing puzzle doors, this may take a few seconds.");
            config = Config.ReadObject<RemovePuzzleDoorsConfig>();
            if(config == null)
            {
                LogWarning("Config is null, aborting...");
                return;
            }
            foreach (var door in BaseNetworkable.serverEntities.OfType<Door>())
            {
                if((door.name == config.PrefabSettings.GreenDoorPrefab && config.RemovalSettings.RemoveGreenDoors) || (door.name == config.PrefabSettings.BlueDoorPrefab && config.RemovalSettings.RemoveBlueDoors) || (door.name == config.PrefabSettings.RedDoorPrefab && config.RemovalSettings.RemoveRedDoors))
                {
                    door.AdminKill();
                    Puts($"Killed door '{door.name}' at {door.transform.position}.");
                }
            }
        }
        #endregion
    }
    #region Config Classes
    public class RemovePuzzleDoorsConfig
    {
        public RemovalSettings RemovalSettings = new RemovalSettings();
        public PrefabSettings PrefabSettings = new PrefabSettings();
    }
    [System.Serializable]
    public class RemovalSettings
    {
        public bool RemoveRedDoors = true;
        public bool RemoveBlueDoors = true;
        public bool RemoveGreenDoors = true;
    }
    [System.Serializable]
    public class PrefabSettings
    {
        public string RedDoorPrefab = "assets/bundled/prefabs/static/door.hinged.security.red.prefab";
        public string BlueDoorPrefab = "assets/bundled/prefabs/static/door.hinged.security.blue.prefab";
        public string GreenDoorPrefab = "assets/bundled/prefabs/static/door.hinged.security.green.prefab";
    }
    #endregion
}

// --- End of file: RemovePuzzleDoors.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/revive-arrows ---
// --- Original File Path: R/ReviveArrows/ReviveArrows.cs ---

using Network;
using Newtonsoft.Json;
using System.Collections.Generic;
using UnityEngine;

/*
 * Rewritten from scratch and maintained to present by VisEntities
 * Originally created by redBDGR, up to version 1.0.1
 */

namespace Oxide.Plugins
{
    [Info("Revive Arrows", "VisEntities", "3.0.2")]
    [Description("Heal and revive the wounded from a distance.")]
    public class ReviveArrows : RustPlugin
    {
        #region Fields

        private static ReviveArrows _plugin;
        private static Configuration _config;

        private const string FX_INJECT_FRIEND = "assets/prefabs/tools/medical syringe/effects/inject_friend.prefab";

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Instant Health Increase")]
            public float InstantHealthIncrease { get; set; }

            [JsonProperty("Health Increase Over Time")]
            public float HealthIncreaseOverTime { get; set; }

            [JsonProperty("Can Revive Wounded")]
            public bool CanReviveWounded { get; set; }
            
            [JsonProperty("Arrow Ingredients")]
            public List<ItemInfo> ArrowIngredients { get; set; }
        }

        public class ItemInfo
        {
            [JsonProperty("Shortname")]
            public string Shortname { get; set; }

            [JsonProperty("Amount")]
            public int Amount { get; set; }

            [JsonIgnore]
            private bool _validated;

            [JsonIgnore]
            private ItemDefinition _itemDefinition;

            [JsonIgnore]
            public ItemDefinition ItemDefinition
            {
                get
                {
                    if (!_validated)
                    {
                        ItemDefinition matchedItemDefinition = ItemManager.FindItemDefinition(Shortname);
                        if (matchedItemDefinition != null)
                            _itemDefinition = matchedItemDefinition;
                        else
                            return null;

                        _validated = true;
                    }

                    return _itemDefinition;
                }
            }

            public int GetItemAmount(ItemContainer container)
            {
                return container.GetAmount(ItemDefinition.itemid, true);
            }

            public void GiveItem(BasePlayer player, ItemContainer container)
            {
                container.GiveItem(ItemManager.CreateByItemID(ItemDefinition.itemid, Amount));
                player.Command("note.inv", ItemDefinition.itemid, Amount);
            }

            public int TakeItem(BasePlayer player, ItemContainer container)
            {
                int amountTaken = container.Take(null, ItemDefinition.itemid, Amount);
                player.Command("note.inv", ItemDefinition.itemid, -amountTaken);
                return amountTaken;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                InstantHealthIncrease = 15f,
                HealthIncreaseOverTime = 20f,
                CanReviveWounded = true,
                ArrowIngredients = new List<ItemInfo>
                {
                    new ItemInfo
                    {
                        Shortname = "syringe.medical",
                        Amount = 1
                    },
                    new ItemInfo
                    {
                        Shortname = "rope",
                        Amount = 1
                    }
                }
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Init()
        {
            _plugin = this;
            PermissionUtil.RegisterPermissions();
        }

        private void Unload()
        {
            _config = null;
            _plugin = null;
        }

        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (player == null || !PermissionUtil.VerifyHasPermission(player))
                return;

            if (oldItem == null || newItem == null)
                return;

            if (!newItem.info.shortname.Contains("bow"))
                return;

            if (!ChanceSucceeded(30))
                return;

            SendGameTip(player, lang.GetMessage(Lang.HealArrowUsage, this, player.UserIDString), 5f);
        }

        private void OnPlayerAttack(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || hitInfo == null || hitInfo.HitEntity == null)
                return;

            if (!PermissionUtil.VerifyHasPermission(player))
                return;

            BasePlayer hitPlayer = hitInfo.HitEntity.ToPlayer();
            if (hitPlayer == null || hitPlayer.IsNpc)
                return;

            if (hitInfo.Weapon == null || !hitInfo.Weapon.ShortPrefabName.Contains("bow"))
                return;

            if (!player.serverInput.IsDown(BUTTON.USE))
                return;

            foreach (ItemInfo ingredient in _config.ArrowIngredients)
            {
                int amount = ingredient.GetItemAmount(player.inventory.containerMain);
                if (amount < ingredient.Amount)
                {
                    SendReplyToPlayer(player, Lang.InsufficientIngredients, ingredient.Shortname, ingredient.Amount);
                    return;
                }
            }

            foreach (ItemInfo ingredient in _config.ArrowIngredients)
            {
                ingredient.TakeItem(player, player.inventory.containerMain);
            }

            hitInfo.damageTypes.ScaleAll(0);
            Heal(hitPlayer);

            RunEffect(FX_INJECT_FRIEND, hitPlayer, boneId: 698017942);
            SendGameTip(player, lang.GetMessage(Lang.PlayerHealed, this, player.UserIDString), 5f, hitPlayer.displayName, _config.InstantHealthIncrease);
        }

        #endregion Oxide Hooks

        #region Functions

        private void Heal(BasePlayer player)
        {
            player.Heal(_config.InstantHealthIncrease);
            player.metabolism.ApplyChange(MetabolismAttribute.Type.HealthOverTime, _config.HealthIncreaseOverTime, 1f);
            
            if (_config.CanReviveWounded)
            {
                player.StopWounded();
            }
        }

        #endregion Functions

        #region Helper Functions

        private static bool ChanceSucceeded(int percentage)
        {
            return Random.Range(0, 100) < percentage;
        }

        private void SendGameTip(BasePlayer player, string message, float durationSeconds, params object[] args)
        {
            message = string.Format(message, args);

            player.SendConsoleCommand("gametip.showgametip", message);
            timer.Once(durationSeconds, () =>
            {
                if (player != null)
                    player.SendConsoleCommand("gametip.hidegametip");
            });
        }

        private static void RunEffect(string prefab, BaseEntity entity, uint boneId = 0, Vector3 localPosition = default(Vector3), Vector3 localDirection = default(Vector3), Connection effectRecipient = null, bool sendToAll = false)
        {
            Effect.server.Run(prefab, entity, boneId, localPosition, localDirection, effectRecipient, sendToAll);
        }

        #endregion Helper Functions

        #region Helper Classes

        private static class PermissionUtil
        {
            public const string USE = "revivearrows.use";

            public static void RegisterPermissions()
            {
                _plugin.permission.RegisterPermission(USE, _plugin);
            }

            public static bool VerifyHasPermission(BasePlayer player, string permissionName = USE)
            {
                return _plugin.permission.UserHasPermission(player.UserIDString, permissionName);
            }
        }

        #endregion Helper Classes

        #region Localization

        private class Lang
        {
            public const string InsufficientIngredients = "InsufficientIngredients";
            public const string PlayerHealed = "PlayerHealed ";
            public const string HealArrowUsage = "HealArrowUsage ";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.InsufficientIngredients] = "You don't have enough <color=#FABE28>{0}</color>. Required: <color=#FABE28>{1}</color>",
                [Lang.PlayerHealed] = "You healed <color=#FABE28>{0}</color> by <color=#FABE28>{1}</color> health points",
                [Lang.HealArrowUsage] = "Hold down <color=#FABE28>use</color> to heal a friend with an arrow",

            }, this, "en");
        }

        private void SendReplyToPlayer(BasePlayer player, string messageKey, params object[] args)
        {
            string message = lang.GetMessage(messageKey, this, player.UserIDString);
            if (args.Length > 0)
                message = string.Format(message, args);

            SendReply(player, message);
        }

        #endregion Localization
    }
}

// --- End of file: ReviveArrows.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/restore-upon-death ---
// --- Original File Path: R/RestoreUponDeath/RestoreUponDeath.cs ---

﻿using Facepunch;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using UnityEngine;
using System;

namespace Oxide.Plugins
{
    [Info("Restore Upon Death", "k1lly0u", "0.6.3")]
    [Description("Restores player inventories on death and removes the items from their corpse")]
    class RestoreUponDeath : RustPlugin
    {
        #region Fields

        private const int SmallBackpackItemId = 2068884361;
        private const int LargeBackpackItemId = -907422733;

        private RestoreData restoreData;
        private DynamicConfigFile restorationData;

        private bool wipeData = false;

        #endregion

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            LoadData();

            if (Configuration.DropActiveItem)
                Unsubscribe(nameof(CanDropActiveItem));

            foreach (string perm in Configuration.Permissions.Keys)
                permission.RegisterPermission(!perm.StartsWith("restoreupondeath.") ? $"restoreupondeath.{perm}" : perm, this);

            EnableBackpackDropOnDeath(SmallBackpackItemId, Configuration.DropBackpack);
            EnableBackpackDropOnDeath(LargeBackpackItemId, Configuration.DropBackpack);
        }

        private void Unload()
        {
            EnableBackpackDropOnDeath(SmallBackpackItemId, false);
            EnableBackpackDropOnDeath(LargeBackpackItemId, false);

            OnServerSave();
        }

        private void OnNewSave(string fileName)
        {
            if (Configuration.WipeOnNewSave)
                wipeData = true;
        }

        private void OnServerSave() => SaveData();

        private object CanDropActiveItem(BasePlayer player) => ShouldBlockRestore(player) ? null : (object)(!HasAnyPermission(player.UserIDString));

        private void OnEntityDeath(BasePlayer player, HitInfo info)
        {
            if (!player || !player.userID.IsSteamId() || restoreData.HasRestoreData(player.userID))
                return;

            if (ShouldBlockRestore(player))
                return;

            if (Configuration.NoSuicideRestore && info != null && info.damageTypes.GetMajorityDamageType() == Rust.DamageType.Suicide)
                return;

            if (HasAnyPermission(player.UserIDString, out ConfigData.LossAmounts lossAmounts))
            {
                double expires = CurrentTime() + (Configuration.PurgeDays * 24 * 60 * 60);
                restoreData.AddData(player, lossAmounts, expires);
            }
        }

        // Handle player death while sleeping in a safe zone.
        private void OnEntityKill(BasePlayer player)
        {
            OnEntityDeath(player, null);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (!player || !restoreData.HasRestoreData(player.userID))
                return;

            if (ShouldBlockRestore(player))
                return;

            TryRestorePlayer(player);
        }

        #endregion

        #region Functions

        private bool ShouldBlockRestore(BasePlayer player) => Interface.Call("isEventPlayer", player) != null || Interface.Call("OnRestoreUponDeath", player) != null;

        private void TryRestorePlayer(BasePlayer player)
        {
            if (!player || player.IsDead())
                return;

            if (!player.IsSleeping())
            {
                if (!Configuration.DefaultItems)
                {
                    StripContainer(player.inventory.containerWear);
                    StripContainer(player.inventory.containerBelt);
                }

                restoreData.RestorePlayer(player);
            }
            else player.Invoke(() => TryRestorePlayer(player), 0.25f);
        }

        private bool HasAnyPermission(string playerId)
        {
            foreach (string key in Configuration.Permissions.Keys)
            {
                if (permission.UserHasPermission(playerId, key))
                    return true;
            }

            return false;
        }

        private bool HasAnyPermission(string playerId, out ConfigData.LossAmounts lossAmounts)
        {
            foreach (KeyValuePair<string, ConfigData.LossAmounts> kvp in Configuration.Permissions)
            {
                if (permission.UserHasPermission(playerId, kvp.Key))
                {
                    lossAmounts = kvp.Value;
                    return true;
                }
            }

            lossAmounts = null;
            return false;
        }

        private void StripContainer(ItemContainer container)
        {
            for (int i = container.itemList.Count - 1; i >= 0; i--)
            {
                Item item = container.itemList[i];
                item.RemoveFromContainer();
                item.Remove();
            }
        }

        private void EnableBackpackDropOnDeath(int itemId, bool enabled)
        {
            ItemModBackpack itemModBackpack = ItemManager.FindItemDefinition(itemId)?.GetComponent<ItemModBackpack>();
            if (!itemModBackpack)
                return;

            itemModBackpack.DropWhenDowned = enabled;
        }

        #endregion

        #region Config

        private ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty("Give default items upon respawn if the players is having items restored")]
            public bool DefaultItems { get; set; }

            [JsonProperty("Can drop active item on death")]
            public bool DropActiveItem { get; set; }

            [JsonProperty("Can drop backpack on death")]
            public bool DropBackpack { get; set; } = true;

            [JsonProperty("Don't restore items if player commited suicide")]
            public bool NoSuicideRestore { get; set; }

            [JsonProperty("Wipe stored data when the map wipes")]
            public bool WipeOnNewSave { get; set; }

            [JsonProperty("Purge expired user data after X amount of days")]
            public int PurgeDays { get; set; } = 7;

            [JsonProperty("Percentage of total items lost (Permission Name | Percentage (0 - 100))")]
            public Dictionary<string, LossAmounts> Permissions { get; set; }

            public class LossAmounts
            {
                public int Belt { get; set; }
                public int Wear { get; set; }
                public int Main { get; set; }
            }

            public VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                DefaultItems = false,
                DropActiveItem = false,
                DropBackpack = true,
                Permissions = new Dictionary<string, ConfigData.LossAmounts>
                {
                    ["restoreupondeath.default"] = new ConfigData.LossAmounts()
                    {
                        Belt = 75,
                        Main = 75,
                        Wear = 75
                    },
                    ["restoreupondeath.beltonly"] = new ConfigData.LossAmounts()
                    {
                        Belt = 100,
                        Main = 0,
                        Wear = 0
                    },
                    ["restoreupondeath.admin"] = new ConfigData.LossAmounts()
                    {
                        Belt = 0,
                        Main = 0,
                        Wear = 0
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (Configuration.Version < new VersionNumber(0, 3, 0))
                Configuration.Permissions = baseConfig.Permissions;

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management
        
        private double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        public enum ContainerType
        {
            Main,
            Wear,
            Belt
        }

        private void SaveData()
        {
            restorationData.WriteObject(restoreData);
        }

        private void LoadData()
        {
            restorationData = Interface.Oxide.DataFileSystem.GetFile("restoreupondeath_data");

            restoreData = restorationData.ReadObject<RestoreData>();

            if (restoreData?.restoreData == null || wipeData)
                restoreData = new RestoreData();
            
            double currentTime = CurrentTime();
            List<ulong> list = Pool.Get<List<ulong>>();
            
            foreach (KeyValuePair<ulong, RestoreData.PlayerData> kvp in restoreData.restoreData)
            {
                if (kvp.Value.HasExpired(currentTime))
                    list.Add(kvp.Key);
            }
            
            foreach (ulong id in list)
                restoreData.RemoveData(id);
            
            Debug.Log($"[RestoreUponDeath] Purged {list.Count} expired user data entries");
            
            Pool.FreeUnmanaged(ref list);
        }

        private class RestoreData
        {
            public Hash<ulong, PlayerData> restoreData = new Hash<ulong, PlayerData>();

            public void AddData(BasePlayer player, ConfigData.LossAmounts lossAmounts, double expires)
            {
                restoreData[player.userID] = new PlayerData(player, lossAmounts, expires);
            }

            public void RemoveData(ulong playerId)
            {
                if (HasRestoreData(playerId))
                    restoreData.Remove(playerId);
            }

            public bool HasRestoreData(ulong playerId) => restoreData.ContainsKey(playerId);

            public void RestorePlayer(BasePlayer player)
            {
                if (restoreData.TryGetValue(player.userID, out PlayerData playerData))
                {
                    if (playerData == null || !player.IsConnected)
                        return;

                    RestoreAllItems(player, playerData);
                }
            }

            private void RestoreAllItems(BasePlayer player, PlayerData playerData)
            {
                if (RestoreItems(player, playerData.containerBelt, ContainerType.Belt) && RestoreItems(player, playerData.containerWear, ContainerType.Wear) && RestoreItems(player, playerData.containerMain, ContainerType.Main))
                {
                    RemoveData(player.userID);
                    player.ChatMessage("Your inventory has been restored");
                }
            }

            private static bool RestoreItems(BasePlayer player, ItemData[] itemData, ContainerType containerType)
            {
                ItemContainer container = containerType switch
                {
                    ContainerType.Belt => player.inventory.containerBelt,
                    ContainerType.Wear => player.inventory.containerWear,
                    _ => player.inventory.containerMain
                };

                for (int i = 0; i < itemData.Length; i++)
                {
                    Item item = CreateItem(itemData[i]);
                    if (item == null)
                        continue;

                    if (!item.MoveToContainer(container, itemData[i].position) && !item.MoveToContainer(container) && !player.inventory.GiveItem(item))
                    {
                        // If allowing default items, restored items might not fit, so drop them as a last resort.
                        item.Drop(player.inventory.containerMain.dropPosition, player.inventory.containerMain.dropVelocity);
                    }
                }

                return true;
            }

            public class PlayerData
            {
                public ItemData[] containerMain;
                public ItemData[] containerWear;
                public ItemData[] containerBelt;

                public double expires = 0;

                public PlayerData()
                {
                }

                public PlayerData(BasePlayer player, ConfigData.LossAmounts lossAmounts, double expires)
                {
                    containerBelt = GetItems(player.inventory.containerBelt, Mathf.Clamp(lossAmounts.Belt, 0, 100));
                    containerMain = GetItems(player.inventory.containerMain, Mathf.Clamp(lossAmounts.Main, 0, 100));
                    containerWear = GetItems(player.inventory.containerWear, Mathf.Clamp(lossAmounts.Wear, 0, 100));
                    this.expires = expires;
                }
                
                public bool HasExpired(double currentTime) => expires > 0 && expires < currentTime;

                private static ItemData[] GetItems(ItemContainer container, int lossPercentage)
                {
                    int keepPercentage = 100 - lossPercentage;

                    int itemCount = keepPercentage == 100 ? container.itemList.Count : Mathf.CeilToInt((float)container.itemList.Count * (float)(keepPercentage / 100f));
                    if (itemCount == 0)
                        return Array.Empty<ItemData>();

                    ItemData[] itemData = new ItemData[itemCount];

                    for (int i = 0; i < itemCount; i++)
                    {
                        Item item = container.itemList.GetRandom();
                        itemData[i] = new ItemData(item);
                        item.RemoveFromContainer();
                        item.Remove();
                    }

                    // Sort items by position to ensure they are restored in original order if desired slot is taken by pre-existing items.
                    Array.Sort(itemData, (a, b) => a.position.CompareTo(b.position));

                    return itemData;
                }
            }
        }

        public class ItemData
        {
            public int itemid;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public ulong skin;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public string displayName;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public int amount;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public float condition;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public float maxCondition;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public int ammo;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public string ammotype;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public int position;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public int frequency;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public InstanceData instanceData;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public string text;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public Item.Flag flags;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public ItemData[] contents;
            
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
            public ItemContainer container;

            public ItemData()
            {
            }

            public ItemData(Item item)
            {
                BaseEntity heldEntity = item.GetHeldEntity();
                BaseProjectile baseProjectile = heldEntity as BaseProjectile;

                itemid = item.info.itemid;
                amount = item.amount;
                displayName = item.name;
                ammo = baseProjectile ? baseProjectile.primaryMagazine.contents : heldEntity is FlameThrower flameThrower ? flameThrower.ammo : 0;
                ammotype = baseProjectile ? baseProjectile.primaryMagazine.ammoType.shortname : null;
                position = item.position;
                skin = item.skin;
                condition = item.condition;
                maxCondition = item.maxCondition;
                frequency = ItemModAssociatedEntity<PagerEntity>.GetAssociatedEntity(item)?.GetFrequency() ?? -1;
                instanceData = new InstanceData(item);
                text = item.text;
                flags = item.flags;
                container = item.contents != null ? new ItemContainer(item.contents) : null;
            }

            public class InstanceData
            {
                [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
                public int dataInt;
                
                [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
                public int blueprintTarget;
                
                [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
                public int blueprintAmount;

                public InstanceData()
                {
                }

                public InstanceData(Item item)
                {
                    if (item.instanceData == null)
                        return;

                    dataInt = item.instanceData.dataInt;
                    blueprintAmount = item.instanceData.blueprintAmount;
                    blueprintTarget = item.instanceData.blueprintTarget;
                }

                public void Restore(Item item)
                {
                    if (item.instanceData == null)
                        item.instanceData = new ProtoBuf.Item.InstanceData();

                    item.instanceData.ShouldPool = false;

                    item.instanceData.blueprintAmount = blueprintAmount;
                    item.instanceData.blueprintTarget = blueprintTarget;
                    item.instanceData.dataInt = dataInt;

                    item.MarkDirty();
                }

                public bool IsValid()
                {
                    return dataInt != 0 || blueprintAmount != 0 || blueprintTarget != 0;
                }
            }

            public class ItemContainer
            {
                [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
                public int slots;
                
                [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
                public float temperature;
                
                [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
                public int flags;
                
                [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
                public int allowedContents;
                
                [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
                public int maxStackSize;
                
                [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
                public List<int> allowedItems;
                
                [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
                public List<int> availableSlots;
                
                [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
                public int volume;
                
                [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore, NullValueHandling = NullValueHandling.Ignore)]
                public List<ItemData> contents;

                public ItemContainer()
                {
                }

                public ItemContainer(global::ItemContainer container)
                {
                    contents = new List<ItemData>();
                    slots = container.capacity;
                    temperature = container.temperature;
                    allowedContents = (int)container.allowedContents;

                    if (container.HasLimitedAllowedItems)
                    {
                        allowedItems = new List<int>();
                        for (int i = 0; i < container.onlyAllowedItems.Length; i++)
                        {
                            if (container.onlyAllowedItems[i])
                            {
                                allowedItems.Add(container.onlyAllowedItems[i].itemid);
                            }
                        }
                    }

                    flags = (int)container.flags;
                    maxStackSize = container.maxStackSize;
                    volume = container.containerVolume;

                    if (container.availableSlots is { Count: > 0 })
                    {
                        availableSlots = new List<int>();
                        for (int j = 0; j < container.availableSlots.Count; j++)
                        {
                            availableSlots.Add((int)container.availableSlots[j]);
                        }
                    }

                    for (int k = 0; k < container.itemList.Count; k++)
                    {
                        Item item = container.itemList[k];
                        if (item.IsValid())
                        {
                            contents.Add(new ItemData(item));
                        }
                    }
                }

                public void Load(global::ItemContainer itemContainer)
                {
                    itemContainer.capacity = slots;
                    itemContainer.itemList = Pool.Get<List<Item>>();
                    itemContainer.temperature = temperature;
                    itemContainer.flags = (global::ItemContainer.Flag)flags;
                    itemContainer.allowedContents = (global::ItemContainer.ContentsType)((allowedContents == 0) ? 1 : allowedContents);

                    if (allowedItems is { Count: > 0 })
                    {
                        itemContainer.onlyAllowedItems = new ItemDefinition[allowedItems.Count];
                        for (int i = 0; i < allowedItems.Count; i++)
                        {
                            itemContainer.onlyAllowedItems[i] = ItemManager.FindItemDefinition(allowedItems[i]);
                        }
                    }
                    else
                    {
                        itemContainer.onlyAllowedItems = null;
                    }

                    itemContainer.maxStackSize = maxStackSize;
                    itemContainer.containerVolume = volume;
                    itemContainer.availableSlots.Clear();

                    if (availableSlots != null)
                    {
                        for (int j = 0; j < availableSlots.Count; j++)
                        {
                            itemContainer.availableSlots.Add((ItemSlot)availableSlots[j]);
                        }
                    }

                    foreach (ItemData itemData in contents)
                    {
                        Item item = CreateItem(itemData);
                        if (item == null)
                            continue;

                        if (!item.MoveToContainer(itemContainer, itemData.position) && !item.MoveToContainer(itemContainer))
                            item.Remove();
                    }

                    itemContainer.MarkDirty();
                }
            }
        }

        public static Item CreateItem(ItemData itemData)
        {
            Item item = ItemManager.CreateByItemID(itemData.itemid, Mathf.Max(1, itemData.amount), itemData.skin);
            if (item == null)
                return null;

            item.condition = itemData.condition;
            item.maxCondition = itemData.maxCondition;

            if (itemData.displayName != null)
            {
                item.name = itemData.displayName;
            }

            if (itemData.text != null)
            {
                item.text = itemData.text;
            }

            item.flags |= itemData.flags;

            if (itemData.frequency > 0)
            {
                ItemModRFListener rfListener = item.info.GetComponentInChildren<ItemModRFListener>();
                if (rfListener)
                {
                    PagerEntity pagerEntity = BaseNetworkable.serverEntities.Find(item.instanceData.subEntity) as PagerEntity;
                    if (pagerEntity)
                    {
                        pagerEntity.ChangeFrequency(itemData.frequency);
                        item.MarkDirty();
                    }
                }
            }

            if (itemData.instanceData != null && itemData.instanceData.IsValid())
                itemData.instanceData.Restore(item);

            FlameThrower flameThrower = item.GetHeldEntity() as FlameThrower;
            if (flameThrower)
                flameThrower.ammo = itemData.ammo;

            if (itemData.contents != null && item.contents != null)
            {
                foreach (ItemData contentData in itemData.contents)
                {
                    Item childItem = CreateItem(contentData);
                    if (childItem == null)
                        continue;

                    if (!childItem.MoveToContainer(item.contents, contentData.position) && !childItem.MoveToContainer(item.contents))
                        item.Remove();
                    
                    item.MarkDirty();
                }
                
                item.contents.MarkDirty();
            }

            if (itemData.container != null)
            {
                if (item.contents == null)
                {
                    ItemModContainerArmorSlot armorSlot = FindItemMod<ItemModContainerArmorSlot>(item);
                    if (armorSlot)
                        armorSlot.CreateAtCapacity(itemData.container.slots, item);
                    else
                    {
                        item.contents = Pool.Get<ItemContainer>();
                        item.contents.ServerInitialize(item, itemData.container.slots);
                        item.contents.GiveUID();
                    }
                }

                itemData.container.Load(item.contents);
            }

            // Process weapon attachments/capacity after child items have been added.
            BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon)
            {
                weapon.DelayedModsChanged();

                if (!string.IsNullOrEmpty(itemData.ammotype))
                    weapon.primaryMagazine.ammoType = ItemManager.FindItemDefinition(itemData.ammotype);
                weapon.primaryMagazine.contents = itemData.ammo;
            }

            return item;
        }

        private static T FindItemMod<T>(Item item) where T : ItemMod
        {
            foreach (ItemMod itemMod in item.info.itemMods)
            {
                if (itemMod is T mod)
                    return mod;
            }

            return null;
        }

        #endregion
    }
}

// --- End of file: RestoreUponDeath.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/replenish ---
// --- Original File Path: R/Replenish/Replenish.cs ---

#define DEBUG

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

using Newtonsoft.Json;

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

using UnityEngine;
using UnityEngine.Assertions;

namespace Oxide.Plugins
{
    [Info("Replenish", "2CHEVSKII", "2.0.0")]
    [Description("Save and restore items in selected containers")]
    class Replenish : CovalencePlugin
    {
        PluginSettings      settings;
        ReplenishController controller;

        const string PERMISSION_USE = "replenish.use";

        const string DATAFILE_NAME = "replenish.data";

        const string M_PREFIX              = "Chat prefix",
                     M_NO_PERMISSION       = "No permission",
                     M_HELP                = "Help message",
                     M_CONTAINER_SET       = "Container set for replenish",
                     M_CONTAINER_UNSET     = "Container removed from replenish list",
                     M_CONTAINER_INFO      = "Container info",
                     M_CONTAINER_NOT_EMPTY = "Container is not empty",
                     M_TIMED               = "Timed restore",
                     M_WIPE_ONLY           = "Wipe restore",
                     M_COMMAND_ONLY        = "Command restore",
                     M_CONTAINER_NOT_FOUND = "Container not found",
                     M_CONTAINER_NOT_SAVED = "Container not saved",
                     M_NO_CONTAINERS_SAVED = "No saved containers",
                     M_CONTAINER_RESTORED  = "Container restored",
                     M_ALL_RESTORED        = "All containers restored",
                     M_ALL_REMOVED         = "All containers removed from restore";

        static Replenish Instance;

        bool isNewWipe;

        #region Command Handler

        void CommandHandler(IPlayer player, string _, string[] args) // TODO: This method requires some serious refactoring
        {
            if (player.IsServer || !player.HasPermission(PERMISSION_USE))
            {
                Message(player, M_NO_PERMISSION);
                return;
            }

            if (args.Length != 0)
            {
                var container = GetContainerInSight(player);
                switch (args[0].ToLower())
                {
                    case "save":
                        if (!container)
                        {
                            Message(player, M_CONTAINER_NOT_FOUND);
                        }
                        else
                        {
                            if (args.Length == 1)
                            {
                                var cData = controller.SaveContainer(container, settings.DefaultReplenishTimer);

                                string msg = GetSaveTimeMessage(cData.Mode);

                                Message(player, M_CONTAINER_SET, string.Format(msg, cData.RestoreTime));
                            }
                            else
                            {
                                switch (args[1].ToLower())
                                {
                                    case "cmd":
                                        controller.SaveContainer(container, 0f);

                                        Message(player, M_CONTAINER_SET, GetMessage(player, M_COMMAND_ONLY));
                                        break;

                                    case "wipe":
                                        controller.SaveContainer(container, -1f);

                                        Message(player, M_CONTAINER_SET, GetMessage(player, M_WIPE_ONLY));
                                        break;

                                    default:
                                        float seconds;
                                        if (float.TryParse(
                                            args[1],
                                            NumberStyles.Number,
                                            CultureInfo.InvariantCulture,
                                            out seconds
                                        ))
                                        {
                                            var cData = controller.SaveContainer(container, seconds);

                                            string msg = GetSaveTimeMessage(cData.Mode);

                                            Message(
                                                player,
                                                M_CONTAINER_SET,
                                                string.Format(GetMessage(player, msg), cData.RestoreTime)
                                            );
                                        }
                                        else
                                        {
                                            Message(player, M_HELP);
                                        }

                                        break;
                                }
                            }
                        }

                        break;

                    case "remove":
                        if (args.Length == 1)
                        {
                            if (!container)
                            {
                                Message(player, M_CONTAINER_NOT_FOUND);
                                return;
                            }

                            if (!controller.RemoveContainer(container))
                            {
                                Message(player, M_CONTAINER_NOT_SAVED);
                                return;
                            }

                            Message(player, M_CONTAINER_UNSET);
                        }
                        else
                        {
                            int id;

                            if (int.TryParse(args[1], out id))
                            {
                                if (!controller.RemoveContainer(id))
                                {
                                    Message(player, M_CONTAINER_NOT_SAVED);
                                }
                                else
                                {
                                    Message(player, M_CONTAINER_UNSET);
                                }
                            }
                        }

                        break;

                    case "info":
                        int cId;
                        if (args.Length == 1)
                        {
                            if (container)
                            {
                                var cData = controller.FindDataByEntity(container);

                                if (cData == null)
                                {
                                    Message(player, M_CONTAINER_NOT_SAVED);
                                }
                                else
                                {
                                    MessageRaw(player, BuildContainerInfo(player, cData));
                                }
                            }
                            else
                            {
                                Message(player, M_CONTAINER_NOT_FOUND);
                            }
                        }
                        else if (int.TryParse(args[1], out cId))
                        {
                            var cData = controller.FindDataById(cId);

                            if (cData == null)
                            {
                                Message(player, M_CONTAINER_NOT_FOUND);
                            }
                            else
                            {
                                MessageRaw(player, BuildContainerInfo(player, cData));
                            }
                        }
                        else
                        {
                            Message(player, M_HELP);
                        }

                        break;
                    case "list":
                        var data = controller.GetSaveData();

                        if (data.Count == 0)
                        {
                            Message(player, M_NO_CONTAINERS_SAVED);
                        }
                        else
                        {
                            StringBuilder builder = new StringBuilder();

                            builder.AppendLine();

                            for (int i = 0; i < data.Count; i++)
                            {
                                var cData = data[i];

                                var info = BuildContainerInfo(player, cData);

                                builder.AppendLine(info);
                            }

                            MessageRaw(player, builder.ToString());
                        }

                        break;
                    case "restore":
                        int containerId;
                        if (args.Length == 1)
                        {
                            if (!container)
                            {
                                Message(player, M_CONTAINER_NOT_FOUND);
                            }
                            else
                            {
                                var containerData = controller.FindDataByEntity(container);

                                if (containerData == null)
                                {
                                    Message(player, M_CONTAINER_NOT_SAVED);
                                }
                                else
                                {
                                    if (!controller.RestoreNow(containerData))
                                    {
                                        Message(player,M_CONTAINER_NOT_EMPTY);
                                    }
                                    else
                                    {
                                        Message(player, M_CONTAINER_RESTORED);
                                    }
                                }
                            }
                        }
                        else if (int.TryParse(args[1], out containerId))
                        {
                            var containerData = controller.FindDataById(containerId);

                            if (containerData == null)
                            {
                                Message(player, M_CONTAINER_NOT_FOUND);
                            }
                            else
                            {
                                if (!controller.RestoreNow(containerData))
                                {
                                    Message(player, M_CONTAINER_NOT_EMPTY);
                                }
                                else
                                {
                                    Message(player, M_CONTAINER_RESTORED);
                                }
                            }
                        }
                        else
                        {
                            Message(player, M_HELP);
                        }

                        break;

                    case "restoreall":
                        var saved = controller.GetSaveData();

                        if (saved.Count == 0)
                        {
                            Message(player, M_NO_CONTAINERS_SAVED);
                        }
                        else
                        {
                            for (int i = saved.Count - 1; i >= 0; i--)
                            {
                                controller.RestoreNow(saved[i]);
                            }

                            Message(player, M_ALL_RESTORED);
                        }

                        break;

                    default:
                        Message(player, M_HELP);
                        break;
                    case "clear":
                        var savedData = controller.GetSaveData();

                        if (savedData.Count == 0)
                        {
                            Message(player, M_NO_CONTAINERS_SAVED);
                        }
                        else
                        {
                            for (int i = savedData.Count - 1; i >= 0; i--)
                            {
                                controller.RemoveContainer(controller.GetDataIndex(savedData[i]));
                            }

                            Message(player, M_ALL_REMOVED);
                        }
                        break;
                }
            }
        }

        #endregion

        #region Utility methods

        StorageContainer GetContainerInSight(IPlayer player)
        {
            var basePlayer = (BasePlayer)player.Object;

            RaycastHit hit;

            bool bHit = Physics.Raycast(basePlayer.eyes.HeadRay(), out hit, 5f, LayerMask.GetMask("Deployed"));

            if (bHit)
            {
                var ent = hit.GetEntity();

                return ent as StorageContainer;
            }

            return null;
        }

        #endregion

        #region Oxide hooks

        void Init()
        {
            Instance = this;

            permission.RegisterPermission(PERMISSION_USE, this);

            AddCovalenceCommand("replenish", "CommandHandler");
        }

        void OnServerInitialized()
        {
            controller = ServerMgr.Instance.gameObject.AddComponent<ReplenishController>();

            controller.Init(LoadData());
        }

        void Unload()
        {
            SaveData(controller.GetSaveData());

            UnityEngine.Object.Destroy(controller);

            Instance = null;
        }

        void OnNewSave()
        {
            isNewWipe = true;
        }

        #endregion

        #region Lang API

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string> {
                    [M_PREFIX] = "[Replenish] ",
                    [M_NO_PERMISSION] = "You have no access to this command",
                    [M_HELP] = "Usage: /replenish [command] <args>\n" +
                               "Commands:\n" +
                               "save (<digit|'wipe'|'cmd'>) - Save container you are currently looking at or change settings for container\n" +
                               "remove (<digit>) - Remove container from replenish\n" +
                               "info (<digit>) - Get information about container\n" +
                               "list - Get list of saved containers\n" +
                               "restore (<digit>) - Restore specified container\n" +
                               "restoreall - Restore all containers\n" +
                               "clear - Remove all containers from replenish",
                    [M_CONTAINER_SET] = "Container set to '{0}'",
                    [M_CONTAINER_UNSET] = "Container removed from replenish",
                    [M_CONTAINER_INFO] = "#{0}: {1}, {2} | {3}",
                    [M_CONTAINER_NOT_EMPTY] = "Container must be empty",
                    [M_TIMED] = "Restore every {0:0} seconds",
                    [M_WIPE_ONLY] = "Restore every new wipe",
                    [M_COMMAND_ONLY] = "Restore on command",
                    [M_CONTAINER_NOT_FOUND] = "Container not found",
                    [M_CONTAINER_NOT_SAVED] = "This container is not saved",
                    [M_NO_CONTAINERS_SAVED] = "Server has no saved containers",
                    [M_CONTAINER_RESTORED] = "Container was restored",
                    [M_ALL_RESTORED] = "Restored all containers",
                    [M_ALL_REMOVED] = "All containers were removed from replenish"
                },
                this
            );
        }

        string BuildContainerInfo(IPlayer player, ContainerData data)
        {
            string fmt = GetMessage(player, M_CONTAINER_INFO);
            string msg = string.Format(
                fmt,
                controller.GetDataIndex(data),
                $"[{data.Position.x:0}, {data.Position.y:0}, {data.Position.z:0}]",
                data.NetId,
                string.Format(GetMessage(player, GetSaveTimeMessage(data.Mode)), data.RestoreTime)
            );

            return msg;
        }

        string GetSaveTimeMessage(ContainerData.RestoreMode mode)
        {
            switch (mode)
            {
                case ContainerData.RestoreMode.Timed:
                    return M_TIMED;
                case ContainerData.RestoreMode.Wipe:
                    return M_WIPE_ONLY;
                case ContainerData.RestoreMode.Command:
                    return M_COMMAND_ONLY;
                default:
                    throw new ArgumentOutOfRangeException(nameof(mode), mode, null);
            }
        }

        void MessageRaw(IPlayer player, string message)
        {
            string prefix = GetMessage(
                player,
                M_PREFIX
            );

            player.Message(prefix + message);
        }

        void Message(IPlayer player, string langKey, params object[] args)
        {
            string format = GetMessage(player, langKey);
            string prefix = GetMessage(player, M_PREFIX);

            player.Message(prefix + string.Format(format, args));
        }

        string GetMessage(IPlayer player, string langKey)
        {
            return lang.GetMessage(langKey, this, player.Id);
        }

        #endregion

        #region Data load

        List<ContainerData> LoadData()
        {
            try
            {
                var list = Interface.Oxide.DataFileSystem.ReadObject<List<ContainerData>>(DATAFILE_NAME);

                if (list == null)
                {
                    throw new Exception("Data is null");
                }

                return list;
            }
            catch (Exception e)
            {
                LogError("Failed to load plugin data: {0}", e.Message);

                return new List<ContainerData>();
            }
        }

        void SaveData(List<ContainerData> list)
        {
            Interface.Oxide.DataFileSystem.WriteObject(DATAFILE_NAME, list);
        }

        #endregion

        #region Configuration load

        protected override void LoadDefaultConfig()
        {
            settings = PluginSettings.Default;
            SaveConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                settings = Config.ReadObject<PluginSettings>();

                if (settings == null)
                {
                    throw new Exception("Configuration is null");
                }
            }
            catch (Exception e)
            {
                LogError("Failed to load plugin configuration: {0}", e.Message);
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(settings);
        }

        #endregion

        #region Nested types

        #region ReplenishController

        class ReplenishController : MonoBehaviour
        {
            List<ContainerData> allContainers;
            ContainerData       nextRestoreContainer;

            public ContainerData FindDataById(int id)
            {
                if (id <= 0 || id > allContainers.Count)
                {
                    return null;
                }

                return allContainers[id - 1];
            }

            public ContainerData FindDataByEntity(BaseNetworkable entity)
            {
                return allContainers.Find(c => c.NetId == entity.net.ID);
            }

            public int GetDataIndex(ContainerData data)
            {
                return allContainers.IndexOf(data) + 1;
            }

            public void Init(List<ContainerData> data)
            {
                data.ForEach(d => d.OnRestored());
                allContainers = data;
            }

            public List<ContainerData> GetSaveData()
            {
                return allContainers;
            }

            public ContainerData SaveContainer(StorageContainer container, float timer)
            {
                ContainerData cData = FindDataByEntity(container);

                if (cData == null)
                {
                    cData = new ContainerData(container, timer);
                    allContainers.Add(cData);
                }
                else
                {
                    cData.RestoreTime = timer;
                    cData.ItemList.Clear();
                    cData.ItemList.AddRange(container.inventory.itemList.Select(SerializableItem.FromItem));
                    cData.OnRestored();
                }

                UpdateQueue();

                return cData;
            }

            public bool RemoveContainer(StorageContainer container)
            {
                return RemoveSavedContainer(FindDataByEntity(container));
            }

            public bool RemoveContainer(int containerId)
            {
                return RemoveSavedContainer(FindDataById(containerId));
            }

            public bool RestoreNow(ContainerData data)
            {
                Assert.IsTrue(nextRestoreContainer != null, "NextRestoreContainer is null in RestoreTick!");

                var ent = BaseNetworkable.serverEntities.Find(data.NetId) as StorageContainer;

                bool shouldRestore = false;

                if (!ent)
                {
                    if (Instance.settings.RespawnContainer)
                    {
                        ent = RespawnContainer(data);
                        shouldRestore = true;
                    }
                    else
                    {
                        allContainers.Remove(data);
                    }
                }
                else
                {
                    shouldRestore = CheckEmpty(ent, data);
                }

                if (shouldRestore)
                {
                    BeforeRestore(ent);

                    RestoreContainer(ent, data);

                    AfterRestore(data);
                }

                return shouldRestore;
            }

            bool RemoveSavedContainer(ContainerData data)
            {
                if (data == null)
                {
                    return false;
                }

  