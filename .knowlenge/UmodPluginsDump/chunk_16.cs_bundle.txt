,
					new CuiRectTransformComponent {
						AnchorMin="0.650 0.022",
						AnchorMax="0.828 0.135"
					}
				}
				},
				new CuiElement
				{
					Name = "srpTitle",
					Parent = "srpPanel",
					Components = {
					new CuiImageComponent {
						Color="0.3786 0.3686 0.3686 0.5"
					},
					new CuiRectTransformComponent {
						AnchorMin="0 0.80",
						AnchorMax="1 1"
					}
				}
				},
				new CuiElement
				{
					Name = "srpTitleText",
					Parent = "srpTitle",
					Components = {
					new CuiTextComponent {
						Text = Lang("Title", player.UserIDString),
						Align = TextAnchor.MiddleLeft,
						Color = titleColor,
						FontSize = titleFont
					},
					new CuiRectTransformComponent {
						AnchorMin="0.03 0.0",
						AnchorMax="0.97 1.0"
					}
				}
				},
				new CuiElement
				{
					Name = "srpBody",
					Parent = "srpPanel",
					Components = {
					new CuiImageComponent {
						Color="0.3786 0.3686 0.3686 0.5"
					},
					new CuiRectTransformComponent {
						AnchorMin="0 0",
						AnchorMax="1 0.75"
					}
				}
				},
				new CuiElement
				{
					Name = "srpBodyText1",
					Parent = "srpBody",
					Components = {
					new CuiTextComponent {
						Text = $"{(tc.Status == ProtectionStatus.Protected ? Lang("Protected", player.UserIDString) : Lang("Unprotected", player.UserIDString))}",
						Align = TextAnchor.MiddleCenter,
						Color = (tc.Status == ProtectionStatus.Protected ? COLOR_GREEN : COLOR_RED),
						FontSize = titleFont
					},
					new CuiRectTransformComponent {
						AnchorMin="0.03 0.7",
						AnchorMax="0.97 0.9"
					}
				}
				},
				new CuiElement
				{
					Name = "srpBodyText2",
					Parent = "srpBody",
					Components = {
					new CuiTextComponent {
						Text = GetStatusMessage(player, tc),
						Align = TextAnchor.MiddleCenter,
						Color = (tc.Status == ProtectionStatus.Protected && tc.CanAffordProtection ? COLOR_GREEN : COLOR_RED),
						FontSize = textFont
					},
					new CuiRectTransformComponent {
						AnchorMin="0.03 0.3",
						AnchorMax="0.97 0.7"
					}
				}
				},
				new CuiElement
				{
					Name = "srpBodyText3a",
					Parent = "srpBody",
					Components = {
					new CuiTextComponent {
						Text = $"{Lang("Cost", player.UserIDString)}: {tc.ProtectionCostPerHour}/{Lang("Hour", player.UserIDString)}",
						Align = TextAnchor.MiddleLeft,
						Color = textColor,
						FontSize = textFont
					},
					new CuiRectTransformComponent {
						AnchorMin="0.03 0.1",
						AnchorMax="0.97 0.3"
					}
				}
				},
				new CuiElement
				{
					Name = "srpBodyText3b",
					Parent = "srpBody",
					Components = {
					new CuiTextComponent {
						Text = $"{Lang("Balance", player.UserIDString)}: {Math.Round(tc.StoredBalance, 2)}",
						Align = TextAnchor.MiddleCenter,
						Color = textColor,
						FontSize = textFont
					},
					new CuiRectTransformComponent {
						AnchorMin="0.03 0.1",
						AnchorMax="0.97 0.3"
					}
				}
				},
				new CuiElement
				{
					Name = "srpBodyText3c",
					Parent = "srpBody",
					Components = {
					new CuiTextComponent {
						Text = $"{Lang("Level", player.UserIDString)}: {tc.HighestProtectionLevel}",
						Align = TextAnchor.MiddleRight,
						Color = textColor,
						FontSize = textFont
					},
					new CuiRectTransformComponent {
						AnchorMin="0.03 0.1",
						AnchorMax="0.97 0.3"
					}
				}
				}
			};
				if (PLUGIN.config.Settings.UseEconomics || PLUGIN.config.Settings.UseRP)
				{
					double balance = GetBalance(player.userID);
					container.Add(new CuiElement
					{
						Name = "srpEconPanel",
						Parent = "Overlay",
						Components = {
					new CuiImageComponent {
						Color="0.3786 0.3686 0.3686 0.5"
					},
					new CuiRectTransformComponent {
						AnchorMin="0.650 0.005",
						AnchorMax="0.829 0.021"
					}
				}
					});
					container.Add(new CuiButton
					{
						Button = {
						Command = $"srp.balance.decrement {priv.net.ID}",
						Color = textColor
					},
						Text = {
						Text = "<",
						Align = TextAnchor.MiddleCenter,
						FontSize = 8,
					},
						RectTransform = {
						AnchorMin = "0.37 0.3",
						AnchorMax = "0.43 0.9"
					}
					}, "srpEconPanel", "srpEconSub");
					container.Add(new CuiButton
					{
						Button = {
						Command = $"srp.balance.increment {priv.net.ID}",
						Color = textColor
					},
						Text = {
						Text = ">",
						Align = TextAnchor.MiddleCenter,
						FontSize = 8,
					},
						RectTransform = {
						AnchorMin = "0.57 0.3",
						AnchorMax = "0.63 0.9"
					}
					}, "srpEconPanel", "srpEconAdd");
					container.Add(new CuiElement
					{
						Name = "srpEconLabel",
						Parent = "srpEconPanel",
						Components = {
					new CuiTextComponent {
						Text = $"{economyPanel.Get(player.UserIDString)}",
						Align = TextAnchor.MiddleCenter,
						FontSize = 8,
						Color = textColor
					},
					new CuiRectTransformComponent {
						AnchorMin="0.45 0.2",
						AnchorMax="0.55 1.0"
					}
				}
					});
					container.Add(new CuiButton
					{
						Button = {
							Command = $"srp.balance.deposit {priv.net.ID}",
							Color = balance >= economyPanel.Get(player.UserIDString) && economyPanel.Get(player.UserIDString) != 0 ? COLOR_GREEN_DARK : textColor
						},
						Text = {
							Text = $"{Lang("Deposit", player.UserIDString)}",
							Align = TextAnchor.MiddleCenter,
							FontSize = 7,
						},
						RectTransform = {
							AnchorMin = "0.67 0.2",
							AnchorMax = "0.81 1.0"
						}
					}, "srpEconPanel", "srpEconDeposit");
					container.Add(new CuiButton
					{
						Button = {
							Command = $"srp.balance.withdraw {priv.net.ID}",
							Color = tc.StoredBalance >= economyPanel.Get(player.UserIDString) && economyPanel.Get(player.UserIDString) != 0 ? COLOR_RED_DARK : textColor
						},
						Text = {
							Text = $"{Lang("Withdraw", player.UserIDString)}",
							Align = TextAnchor.MiddleCenter,
							FontSize = 7,
						},
						RectTransform = {
							AnchorMin = "0.83 0.2",
							AnchorMax = "0.97 1.0"
						}
					}, "srpEconPanel", "srpEconWithdraw");
					container.Add(new CuiElement
					{
						Name = "srpEconBalance",
						Parent = "srpEconPanel",
						Components = {
					new CuiTextComponent {
						Text = $"{Lang("Wallet", player.UserIDString)}: {FormatCurrency(GetBalance(player.userID))}",
						Align = TextAnchor.MiddleLeft,
						FontSize = 8,
						Color = textColor
					},
					new CuiRectTransformComponent {
						AnchorMin="0.035 0.3",
						AnchorMax="0.3 1.0"
					}
				}
					});
				}
				CuiHelper.DestroyUi(player, "srpPanel");
				CuiHelper.DestroyUi(player, "srpEconPanel");
				CuiHelper.AddUi(player, container);
			}
		}

		private void CloseUi(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, "srpPanel");
			CuiHelper.DestroyUi(player, "srpEconPanel");
		}

		private void CloseIndicator(BasePlayer player)
		{
			if (player != null)
				CuiHelper.DestroyUi(player, "srpIndicator");

			if (!config.Indicator.Persistent)
			{
				timer.In(3f, () =>
				{
					if (player != null && onCooldown.Contains(player.userID))
						onCooldown.Remove(player.userID);
				});
			}
		}

		private void ShowIndicatorForOwners(ProtectedCupboard tc)
		{
			if (config.Indicator.Enabled)
			{
				foreach (BasePlayer player in tc.OnlineOwners)
				{
					if (player.GetBuildingPrivilege() == tc.Priv)
					{
						PLUGIN.ShowIndicator(player, tc.Priv, false, true);
					}
				}
			}
		}

		private void ShowIndicator(BasePlayer player, BuildingPrivlidge priv, bool fromDamage = false, bool ignoreCooldown = false, bool isPersistent = false)
		{
			if (config.Indicator.Enabled && priv != null && player != null && (ignoreCooldown || !onCooldown.Contains(player.userID)) && ((config.Indicator.Persistent && isPersistent) || !config.Indicator.Persistent))
			{
				ProtectedCupboard tc = ProtectedCupboard.InitCupboard(priv);
				string anchorMin = "0.8400 0.875";
				string anchorMax = "0.9885 0.940";
				string textColor = tc.Status == ProtectionStatus.Protected ? COLOR_GREEN : COLOR_YELLOW;
				if (tc != null)
				{
					string panelColor = tc.Status == ProtectionStatus.Protected ? COLOR_GREEN_DARK_LESS : COLOR_RED_DARK_LESS;
					CuiElementContainer container = new CuiElementContainer
				{
					new CuiElement
					{
						Name = "srpIndicator",
						Parent = "Hud",
						Components = {
						new CuiImageComponent {
							Color = COLOR_TRANSPARENT
						},
						new CuiRectTransformComponent {
							AnchorMin = anchorMin,
							AnchorMax = anchorMax
						}
					}},
					new CuiElement
					{
						Name = "srpIndicatorMain",
						Parent = "srpIndicator",
						Components = {
						new CuiImageComponent {
							Color = panelColor
						},
						new CuiRectTransformComponent {
							AnchorMin = "0 0.4",
							AnchorMax = "1 1.0"
						}
					}},
					new CuiElement
					{
						Name = "srpIndicatorText",
						Parent = "srpIndicatorMain",
						Components = {
							new CuiTextComponent {
								Text = tc.Status == ProtectionStatus.Protected ? Lang("IndicatorProtected", player.UserIDString, tc.ProtectionPercentage) : Lang("IndicatorUnprotected", player.UserIDString),
								Align = TextAnchor.MiddleCenter,
								Color = textColor,
								FontSize = 12
							},
							new CuiRectTransformComponent {
								AnchorMin = "0.2 0",
								AnchorMax = "0.8 1"
							}}
						}
					};
					if (ImageLibrary)
						container.Add(new CuiElement
						{
							Name = "srpIndicatorImg",
							Parent = "srpIndicatorMain",
							Components = {
							new CuiRawImageComponent {
								Png = ImageLibrary?.Call<string>("GetImage", "SrpIndicatorIcon"),
							},
							new CuiRectTransformComponent {
								AnchorMin = "0.05 0.1",
								AnchorMax = "0.175 0.9"
							}
						}
						});
					if (tc.Status == ProtectionStatus.Protected && tc.CostPerDamage > 0 && fromDamage)
					{
						container.Add(
							new CuiElement
							{
								Name = "srpIndicatorSub",
								Parent = "srpIndicator",
								Components = {
						new CuiImageComponent {
							Color = COLOR_RED_DARK_LESS
						},
						new CuiRectTransformComponent {
							AnchorMin = "0 0",
							AnchorMax = "1 0.35"
						}}
							}
						);
						container.Add(new CuiElement
						{
							Name = "srpIndicatorSubText",
							Parent = "srpIndicatorSub",
							Components = {
						new CuiTextComponent {
							Text = Lang("IndicatorWarning", player.UserIDString),
							Align = TextAnchor.MiddleCenter,
							Color = COLOR_YELLOW,
							FontSize = 8
						},
						new CuiRectTransformComponent {
							AnchorMin = "0 0",
							AnchorMax = "1 1"
						}}
						});
					}
					CuiHelper.DestroyUi(player, "srpIndicator");
					CuiHelper.AddUi(player, container);
					if (!isPersistent)
					{
						onCooldown.Add(player.userID);
						timer.In(3f, () =>
						{
							CloseIndicator(player);
						});
					}
				}
				else
				{
					CuiHelper.DestroyUi(player, "srpIndicator");
				}
			}
		}

		#endregion UI

		#region Commands
		[Command("protection")]
		private void cmd_protection(IPlayer player, string command, string[] args)
		{
			BuildingPrivlidge priv;
			BasePlayer basePlayer = null;
			int mode = 0;
			string labelColor = "#b5b5b5";

			if (args.Length == 0)
			{
				basePlayer = BasePlayer.FindByID(ulong.Parse(player.Id));
				if (basePlayer == null)
				{
					player.Reply($"{Lang("NoPriv", player.Id)}");
					return;
				}
				priv = basePlayer.GetBuildingPrivilege();
			}
			else
			{
				if (!permission.UserHasPermission(player.Id, PermissionAdmin))
				{
					player.Reply($"{Lang("NoPerm", player.Id)}");
					return;
				}
				mode = 2;
				ulong id = ulong.Parse(args[0]);
				priv = (BuildingPrivlidge)BaseNetworkable.serverEntities.Find(new NetworkableId(id));
			}
			StringBuilder sb = new StringBuilder();
			ProtectedCupboard tc = ProtectedCupboard.InitCupboard(priv);
			if (tc != null)
			{
				sb.AppendLine($"<size=20><color=#c4341d>R</size><size=16>aid </size><size=20>P</size><size=16>rotection</color></size>");
				if (permission.UserHasPermission(player.Id, PermissionAdmin))
				{
					mode = 2;
				}
				else if (basePlayer != null & tc.AllOwnerIds.Contains(basePlayer.userID))
				{
					mode = 1;
				}
				if (mode >= 0)
				{
					sb.AppendLine($"{Label(Lang("LabelStatus", player.Id), labelColor)}{(tc.Status == ProtectionStatus.Protected ? Lang("ValueStatusProtected", player.Id, tc.ProtectionPercentage) : Lang("ValueStatusUnprotected", player.Id))}");
				}
				if (mode >= 1)
				{
					sb.AppendLine($"{Label(Lang("LabelLevel", player.Id), labelColor)}{tc.HighestProtectionLevel}");
					sb.AppendLine($"{Label(Lang("LabelProtection", player.Id), labelColor)}{Lang("ValueProtection", player.Id, tc.HighestProtectionLevel.OnlineProtectionPercentage, tc.HighestProtectionLevel.OfflineProtectionPercentage)}");
					sb.AppendLine($"{Label(Lang("LabelDelay", player.Id), labelColor)}{config.Protection.OfflineProtectionDelay}");
					sb.AppendLine($"{Label(Lang("LabelBalance", player.Id), labelColor)}{Math.Round(tc.StoredBalance, 2)}");
					sb.AppendLine($"{Label(Lang("LabelCost", player.Id), labelColor)}{Lang("ValueCost", player.Id, tc.HourlyBaseCost, tc.TotalBuildingCost, tc.ProtectionCostPerHour)}");
					sb.AppendLine($"{Label(Lang("LabelCostPerDamage", player.Id), labelColor)}{tc.CostPerDamage}");
					sb.AppendLine($"{Label(Lang("LabelTime", player.Id), labelColor)}{Math.Round(tc.HoursRemaining, 1)}");
					sb.AppendLine($"{Label(Lang("LabelOnline", player.Id), labelColor)}{tc.OnlineOwners.Count}/{tc.AllOwnerIds.Count}");
				}
				if (mode >= 2)
				{
					sb.AppendLine($"{Label(Lang("LabelId", player.Id), labelColor)}{tc.Priv.net.ID}");
					sb.AppendLine($"{Label(Lang("LabelStatus", player.Id), labelColor)}{tc.Status}");
				}
				player.Reply(sb.ToString());
			}
		}

		/* This command is used only by the UI and will not be documented */
		[Command("srp.balance.increment")]
		private void cmd_balance_increment(IPlayer player, string command, string[] args)
		{
			ulong id;
			if (args.Length > 0 && ulong.TryParse(args[0], out id))
			{
				var nid = new NetworkableId(id);
				economyPanel.Increment(player.Id, config.Settings.UseRP ? 1 : 10);
				BasePlayer basePlayer = BasePlayer.FindByID(ulong.Parse(player.Id));
				BuildingPrivlidge priv = (BuildingPrivlidge)BaseNetworkable.serverEntities.Find(nid);
				if (basePlayer != null && priv != null)
				{
					OpenUi(basePlayer, (BuildingPrivlidge)BaseNetworkable.serverEntities.Find(nid));
				}
			}
		}

		/* This command is used only by the UI and will not be documented */
		[Command("srp.balance.decrement")]
		private void cmd_balance_decrement(IPlayer player, string command, string[] args)
		{
			ulong id;
			if (args.Length > 0 && ulong.TryParse(args[0], out id))
			{
				var nid = new NetworkableId(id);
				economyPanel.Decrement(player.Id, config.Settings.UseRP ? 1 : 10);
				BasePlayer basePlayer = BasePlayer.FindByID(ulong.Parse(player.Id));
				BuildingPrivlidge priv = (BuildingPrivlidge)BaseNetworkable.serverEntities.Find(nid);
				if (basePlayer != null && priv != null)
				{
					OpenUi(basePlayer, (BuildingPrivlidge)BaseNetworkable.serverEntities.Find(nid));
				}
			}
		}

		/* This command is used only by the UI and will not be documented */
		[Command("srp.balance.deposit")]
		private void cmd_balance_deposit(IPlayer player, string command, string[] args)
		{
			ulong id;
			if (player != null && args.Length > 0 && ulong.TryParse(args[0], out id))
			{
				var nid = new NetworkableId(id);
				float amount = economyPanel.Get(player.Id);
				ulong playerId = ulong.Parse(player.Id);
				if ((config.Settings.UseEconomics || config.Settings.UseRP) && GetBalance(playerId) >= amount)
				{
					TakeBalance(playerId, amount);
					BuildingPrivlidge priv = (BuildingPrivlidge)BaseNetworkable.serverEntities.Find(nid);
					ProtectedCupboard tc = ProtectedCupboard.InitCupboard(priv);
					if (tc != null)
					{
						tc.StoredBalance += amount;
						if (tc.HasOnlineProtection)
						{
							tc.PurchaseProtection();
						}
						tc.UpdateStatus();
						BasePlayer basePlayer = BasePlayer.FindByID(ulong.Parse(player.Id));
						if (basePlayer != null && priv != null)
						{
							economyPanel.Reset(player.Id);
							OpenUi(basePlayer, (BuildingPrivlidge)BaseNetworkable.serverEntities.Find(nid));
						}
					}
				}
			}
		}

		/* This command is used only by the UI and will not be documented */
		[Command("srp.balance.withdraw")]
		private void cmd_balance_withdraw(IPlayer player, string command, string[] args)
		{
			ulong id;
			if (player != null && args.Length > 0 && ulong.TryParse(args[0], out id))
			{
				var nid = new NetworkableId(id);
				float amount = economyPanel.Get(player.Id);
				BuildingPrivlidge priv = (BuildingPrivlidge)BaseNetworkable.serverEntities.Find(nid);
				ProtectedCupboard tc = ProtectedCupboard.InitCupboard(priv);
				if (tc != null && (config.Settings.UseEconomics || config.Settings.UseRP) && priv != null && tc.StoredBalance >= amount)
				{
					GiveBalance(ulong.Parse(player.Id), amount);
					tc.StoredBalance -= amount;
					tc.UpdateStatus();
					BasePlayer basePlayer = BasePlayer.FindByID(ulong.Parse(player.Id));
					if (basePlayer != null && priv != null)
					{
						economyPanel.Reset(player.Id);
						OpenUi(basePlayer, (BuildingPrivlidge)BaseNetworkable.serverEntities.Find(nid));
					}
				}
			}
		}

		/* This command is used only by the UI and will not be documented */

		[Command("srp.test.online"), Permission(PermissionAdmin)]
		private void cmd_test_online(IPlayer player, string command, string[] args)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(ulong.Parse(player.Id));
			_onlinePlayers = new HashSet<BasePlayer>() { basePlayer };
			foreach (ProtectedCupboard tc in ProtectedCupboard.toolcupboards.Values)
			{
				tc.UpdateStatus();
			}
			player.Reply("Testing online protection");
			HandleUserConnected(player);
		}

		[Command("srp.test.offline"), Permission(PermissionAdmin)]
		private void cmd_test_offline(IPlayer player, string command, string[] args)
		{
			_onlinePlayers = new HashSet<BasePlayer>() { };
			foreach (ProtectedCupboard tc in ProtectedCupboard.toolcupboards.Values)
			{
				tc.UpdateStatus();
			}
			player.Reply("Testing offline protection");
			HandleUserDisconnected(player);
		}

		#endregion Commands

		#region Debugging

		private const bool _debugging = false;

		private HashSet<BasePlayer> _onlinePlayers = new HashSet<BasePlayer>();

		private Dictionary<string, long> _startTimes = new Dictionary<string, long>();

		private HashSet<string> _trackedHooks = new HashSet<string>() {
			"ProtectFromDamage",
			"OnLootNetworkUpdate",
			"HandleUserDisconnected",
			"HandleUserConnected",
			"PurchaseProtection",
			"UpdateTotalBuildingCost"
		};

		private void Debug(string stmt)
		{
			if (_debugging)
			{
				Puts(stmt);
			}
		}

		private void DebugTimeStart(string function)
		{
			if (_debugging && _trackedHooks.Contains(function))
			{
				if (_startTimes.ContainsKey(function))
				{
					_startTimes[function] = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
				}
				else
				{
					_startTimes.Add(function, DateTimeOffset.UtcNow.ToUnixTimeMilliseconds());
				}
			}
		}

		private void DebugTimeEnd(string function)
		{
			if (_debugging && _trackedHooks.Contains(function))
			{
				if (_startTimes.ContainsKey(function))
				{
					Puts($"{function} took {DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - _startTimes[function]}ms");
				}
			}
		}

		#endregion Debugging
	}
}


// --- End of file: RaidProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rain-of-fire ---
// --- Original File Path: R/RainOfFire/RainOfFire.cs ---

﻿using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine;
using Rust;

namespace Oxide.Plugins
{
    [Info("RainOfFire", "emu / k1lly0u", "0.2.52")]
    [Description("Simulate a meteor strike using rockets falling from the sky")]
    class RainOfFire : RustPlugin
    {
        #region Fields
        [PluginReference]
        Plugin PopupNotifications;

        private Timer EventTimer = null;
        private List<Timer> RocketTimers = new List<Timer>(); 
        #endregion

        #region Oxide Hooks       
        private void OnServerInitialized()
        {
            lang.RegisterMessages(Messages, this);
            LoadVariables();
            StartEventTimer();
        }  
        
        private void Unload()
        {
            StopTimer();
            foreach (var t in RocketTimers)
                t.Destroy();
            var objects = UnityEngine.Object.FindObjectsOfType<ItemCarrier>();
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);
        }
        #endregion

        #region Functions
        private void StartEventTimer()
        {
            if (configData.Options.EnableAutomaticEvents)
            {
                if (configData.Options.EventTimers.UseRandomTimer)
                {
                    var random = RandomRange(configData.Options.EventTimers.RandomTimerMin, configData.Options.EventTimers.RandomTimerMax);
                    EventTimer = timer.Once(random * 60, () => { StartRandomOnMap(); StartEventTimer(); });
                }
                else EventTimer = timer.Repeat(configData.Options.EventTimers.EventInterval * 60, 0, () => StartRandomOnMap());
            }
        }
        private void StopTimer()
        {
            if (EventTimer != null)
                EventTimer.Destroy();
        }

        private void StartRandomOnMap()
        {
            float mapsize = (TerrainMeta.Size.x / 2) - 600f;

            float randomX = UnityEngine.Random.Range(-mapsize, mapsize);
            float randomY = UnityEngine.Random.Range(-mapsize, mapsize);

            Vector3 callAt = new Vector3(randomX, 0f, randomY);

            StartRainOfFire(callAt, configData.z_IntensitySettings.Settings_Optimal);
        }
        private bool StartOnPlayer(string playerName, ConfigData.Settings setting)
        {
            BasePlayer player = GetPlayerByName(playerName);

            if (player == null)
                return false;

            StartRainOfFire(player.transform.position, setting);
            return true;
        }
        private void StartBarrage(Vector3 origin, Vector3 direction) => timer.Repeat(configData.BarrageSettings.RocketDelay, configData.BarrageSettings.NumberOfRockets, () => SpreadRocket(origin, direction));

        private void StartRainOfFire(Vector3 origin, ConfigData.Settings setting)
        {
            float radius = setting.Radius;
            int numberOfRockets = setting.RocketAmount;
            float duration = setting.Duration;
            bool dropsItems = setting.ItemDropControl.EnableItemDrop;
            ItemDrop[] itemDrops = setting.ItemDropControl.ItemsToDrop;

            float intervals = duration / numberOfRockets;

            if (configData.Options.NotifyEvent)
            {
                if (PopupNotifications)
                    PopupNotifications.Call("CreatePopupNotification", msg("incoming"));
                else PrintToChat(msg("incoming"));
            }

            timer.Repeat(intervals, numberOfRockets, () => RandomRocket(origin, radius, setting));
        }      

        private void RandomRocket(Vector3 origin, float radius, ConfigData.Settings setting)
        {
            bool isFireRocket = false;
            Vector2 rand = UnityEngine.Random.insideUnitCircle;
            Vector3 offset = new Vector3(rand.x * radius, 0, rand.y * radius);

            Vector3 direction = (Vector3.up * -2.0f + Vector3.right).normalized;
            Vector3 launchPos = origin + offset - direction * 200;

            if (RandomRange(1, setting.FireRocketChance) == 1)
                isFireRocket = true;

            BaseEntity rocket = CreateRocket(launchPos, direction, isFireRocket);
            if (setting.ItemDropControl.EnableItemDrop)
            {
                var comp = rocket.gameObject.AddComponent<ItemCarrier>();
                comp.SetCarriedItems(setting.ItemDropControl.ItemsToDrop);
                comp.SetDropMultiplier(configData.Options.GlobalDropMultiplier);
            }
        }

        private void SpreadRocket(Vector3 origin, Vector3 direction)
        {
            var barrageSpread = configData.BarrageSettings.RocketSpread;
            direction = Quaternion.Euler(UnityEngine.Random.Range((float)(-(double)barrageSpread * 0.5), barrageSpread * 0.5f), UnityEngine.Random.Range((float)(-(double)barrageSpread * 0.5), barrageSpread * 0.5f), UnityEngine.Random.Range((float)(-(double)barrageSpread * 0.5), barrageSpread * 0.5f)) * direction;
            CreateRocket(origin, direction, false);
        }

        private BaseEntity CreateRocket(Vector3 startPoint, Vector3 direction, bool isFireRocket)
        {
            ItemDefinition projectileItem;
         
            if (isFireRocket)
                projectileItem = ItemManager.FindItemDefinition("ammo.rocket.fire");
            else projectileItem = ItemManager.FindItemDefinition("ammo.rocket.basic");

            ItemModProjectile component = projectileItem.GetComponent<ItemModProjectile>();
            BaseEntity entity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, startPoint, new Quaternion(), true);

            TimedExplosive timedExplosive = entity.GetComponent<TimedExplosive>();
            ServerProjectile serverProjectile = entity.GetComponent<ServerProjectile>();

            serverProjectile.gravityModifier = 0;
            serverProjectile.speed = 25;
            timedExplosive.timerAmountMin = 300;
            timedExplosive.timerAmountMax = 300;
            ScaleAllDamage(timedExplosive.damageTypes, configData.DamageControl.DamageMultiplier);

            serverProjectile.InitializeVelocity(direction.normalized * 25);
            entity.Spawn();
            return entity;
        }

        private void ScaleAllDamage(List<DamageTypeEntry> damageTypes, float scale)
        {
            for (int i = 0; i < damageTypes.Count; i++)
            {
                damageTypes[i].amount *= scale;
            }
        }
        #endregion

        #region Config editing
        private void SetIntervals(int intervals)
        {
            StopTimer();

            configData.Options.EventTimers.EventInterval = intervals;
            SaveConfig(configData);

            StartEventTimer();
        }
        private void SetDamageMult(float scale)
        {
            configData.DamageControl.DamageMultiplier = scale;
            SaveConfig(configData);
        }
        private void SetNotifyEvent(bool notify)
        {
            configData.Options.NotifyEvent = notify;
            SaveConfig(configData);
        }
        private void SetDropRate(float rate)
        {
            configData.Options.GlobalDropMultiplier = rate;
            SaveConfig(configData);
        }
        #endregion

        #region Commands
        [ChatCommand("rof")]
        private void cmdROF(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin || args.Length == 0)
            {
                SendReply(player, msg("help1", player.UserIDString));
                SendReply(player, msg("help2", player.UserIDString));
                SendReply(player, msg("help3", player.UserIDString));
                SendReply(player, msg("help4", player.UserIDString));
                SendReply(player, msg("help5", player.UserIDString));
                SendReply(player, msg("help6", player.UserIDString));
                SendReply(player, msg("help7", player.UserIDString));
                SendReply(player, msg("help8", player.UserIDString));
                return;
            }
                

            switch (args[0].ToLower())
            {
                case "onplayer":
                    if (args.Length == 2)
                    {
                        if (StartOnPlayer(args[1], configData.z_IntensitySettings.Settings_Optimal))
                            SendReply(player, string.Format(msg("calledOn", player.UserIDString), args[1]));
                        else
                            SendReply(player, msg("noPlayer", player.UserIDString));
                    }
                    else
                    {
                        StartRainOfFire(player.transform.position, configData.z_IntensitySettings.Settings_Optimal);
                        SendReply(player, msg("onPos", player.UserIDString));
                    }
                    break;

                case "onplayer_extreme":
                    if (args.Length == 2)
                    {
                        if (StartOnPlayer(args[1], configData.z_IntensitySettings.Settings_Extreme))
                            SendReply(player, msg("Extreme", player.UserIDString) + string.Format(msg("calledOn", player.UserIDString), args[1]));
                        else
                            SendReply(player, msg("noPlayer", player.UserIDString));
                    }
                    else
                    {
                        StartRainOfFire(player.transform.position, configData.z_IntensitySettings.Settings_Extreme);
                        SendReply(player, msg("Extreme", player.UserIDString) + msg("onPos", player.UserIDString));
                    }
                    break;

                case "onplayer_mild":
                    if (args.Length == 2)
                    {
                        if (StartOnPlayer(args[1], configData.z_IntensitySettings.Settings_Mild))
                            SendReply(player, msg("Mild", player.UserIDString) + string.Format(msg("calledOn", player.UserIDString), args[1]));
                        else
                            SendReply(player, msg("noPlayer", player.UserIDString));
                    }
                    else
                    {
                        StartRainOfFire(player.transform.position, configData.z_IntensitySettings.Settings_Mild);
                        SendReply(player, msg("Mild", player.UserIDString) + msg("onPos", player.UserIDString));
                    }
                    break;

                case "barrage":
                    StartBarrage(player.eyes.position + player.eyes.HeadForward() * 1f, player.eyes.HeadForward());
                    break;

                case "random":
                    StartRandomOnMap();
                    SendReply(player, msg("randomCall", player.UserIDString));
                    break;

                case "intervals":
                    if (args.Length > 1)
                    {
                        int newIntervals;
                        bool isValid;
                        isValid = int.TryParse(args[1], out newIntervals);

                        if (isValid)
                        {
                            if (newIntervals >= 4 || newIntervals == 0)
                            {
                                SetIntervals(newIntervals);
                                SendReply(player, string.Format(msg("interSet", player.UserIDString), newIntervals));
                                StopTimer();
                                StartEventTimer();
                            }
                            else
                            {
                                SendReply(player, msg("smallInter", player.UserIDString));
                            }
                        }
                        else
                        {
                            SendReply(player, string.Format(msg("invalidParam", player.UserIDString), args[1]));
                        }
                    }
                    break;
                case "droprate":
                    if (args.Length > 1)
                    {
                        float newDropMultiplier;
                        bool isValid;
                        isValid = float.TryParse(args[1], out newDropMultiplier);
                        if (isValid)
                        {
                            SetDropRate(newDropMultiplier);
                            SendReply(player, msg("dropMulti", player.UserIDString) + newDropMultiplier);
                        }
                        else
                        {
                            SendReply(player, string.Format(msg("invalidParam", player.UserIDString), args[1]));
                        }
                    }
                    break;
                case "damagescale":
                    if (args.Length > 1)
                    {
                        float newDamageMultiplier;
                        bool isValid;
                        isValid = float.TryParse(args[1], out newDamageMultiplier);

                        if (isValid)
                        {
                            SetDamageMult(newDamageMultiplier);
                            SendReply(player, msg("damageMulti", player.UserIDString) + newDamageMultiplier);
                        }
                        else
                        {
                            SendReply(player, string.Format(msg("invalidParam", player.UserIDString), args[1]));
                        }
                    }
                    break;

                case "togglemsg":
                    if (configData.Options.NotifyEvent)
                    {
                        SetNotifyEvent(false);
                        SendReply(player, msg("notifDeAct", player.UserIDString));
                    }
                    else
                    {
                        SetNotifyEvent(true);
                        SendReply(player, msg("notifAct", player.UserIDString));
                    }                    
                    break;

                default:
                    SendReply(player, string.Format(msg("unknown", player.UserIDString), args[0]));
                    break;
            }
        }

        [ConsoleCommand("rof.random")]
        private void ccmdEventRandom(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
                return;

            StartRandomOnMap();
            Puts("Random event started");
        }

        [ConsoleCommand("rof.onposition")]
        private void ccmdEventOnPosition(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
                return;

            float x, z;

            if (arg.Args.Length == 2 && float.TryParse(arg.Args[0], out x) && float.TryParse(arg.Args[1], out z))
            {
                var position = new Vector3(x, 0, z);
                StartRainOfFire(GetGroundPosition(position), configData.z_IntensitySettings.Settings_Optimal);
                Puts($"Random event started on position {x}, {position.y}, {z}");
            }
            else
                Puts("Usage: rof.onposition x z");
        }
        #endregion

        #region Helpers
        private BasePlayer GetPlayerByName(string name)
        {
            string currentName;
            string lastName;
            BasePlayer foundPlayer = null;
            name = name.ToLower();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                currentName = player.displayName.ToLower();

                if (currentName.Contains(name))
                {
                    if (foundPlayer != null)
                    {
                        lastName = foundPlayer.displayName;
                        if (currentName.Replace(name, "").Length < lastName.Replace(name, "").Length)
                        {
                            foundPlayer = player;
                        }
                    }

                    foundPlayer = player;
                }
            }

            return foundPlayer;
        }

        private static int RandomRange(int min, int max) => UnityEngine.Random.Range(min, max);
       
        private Vector3 GetGroundPosition(Vector3 sourcePos)
        {
            RaycastHit hitInfo;

            if (Physics.Raycast(sourcePos, Vector3.down, out hitInfo, LayerMask.GetMask("Terrain", "World", "Construction")))
            {
                sourcePos.y = hitInfo.point.y;
            }
            sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
            return sourcePos;
        }        
        #endregion

        #region Classes 
        private class ItemCarrier : MonoBehaviour
        {
            private ItemDrop[] carriedItems = null;

            private float multiplier;

            public void SetCarriedItems(ItemDrop[] carriedItems) => this.carriedItems = carriedItems;

            public void SetDropMultiplier(float multiplier) => this.multiplier = multiplier;

            private void OnDestroy()
            {
                if (carriedItems == null)
                    return;

                int amount;

                for (int i = 0; i < carriedItems.Length; i++)
                {
                    if ((amount = (int)(RandomRange(carriedItems[i].Minimum, carriedItems[i].Maximum) * multiplier)) > 0)
                        ItemManager.CreateByName(carriedItems[i].Shortname, amount).Drop(gameObject.transform.position, Vector3.up);
                }
            }           
        }

        private class ItemDrop
        {
            public string Shortname { get; set; }
            public int Minimum { get; set; }
            public int Maximum { get; set; }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        
        class ConfigData
        {
            public BarrageOptions BarrageSettings { get; set; }
            public DamageOptions DamageControl { get; set; }
            public ConfigOptions Options { get; set; }
            public IntensityOptions z_IntensitySettings { get; set; }

            public class DamageOptions
            {
                public float DamageMultiplier { get; set; }
            }

            public class BarrageOptions
            {
                public int NumberOfRockets { get; set; }
                public float RocketDelay { get; set; }
                public float RocketSpread { get; set; }
            }

            public class Drops
            {
                public bool EnableItemDrop { get; set; }
                public ItemDrop[] ItemsToDrop { get; set; }
            }

            public class ConfigOptions
            {
                public bool EnableAutomaticEvents { get; set; }
                public Timers EventTimers { get; set; }
                public float GlobalDropMultiplier { get; set; }
                public bool NotifyEvent { get; set; }
            }

            public class Timers
            {
                public int EventInterval { get; set; }
                public bool UseRandomTimer { get; set; }
                public int RandomTimerMin { get; set; }
                public int RandomTimerMax { get; set; }
            }

            public class Settings
            {
                public int FireRocketChance { get; set; }
                public float Radius { get; set; }
                public int RocketAmount { get; set; }
                public int Duration { get; set; }
                public Drops ItemDropControl { get; set; }
            }

            public class IntensityOptions
            {
                public Settings Settings_Mild { get; set; }
                public Settings Settings_Optimal { get; set; }
                public Settings Settings_Extreme { get; set; }
            }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                BarrageSettings = new ConfigData.BarrageOptions
                {
                    NumberOfRockets = 20,
                    RocketDelay = 0.33f,
                    RocketSpread = 16f
                },
                DamageControl = new ConfigData.DamageOptions
                {
                    DamageMultiplier = 0.2f,
                },                
                Options = new ConfigData.ConfigOptions
                {
                    EnableAutomaticEvents = true,
                    EventTimers = new ConfigData.Timers
                    {
                        EventInterval = 30,
                        RandomTimerMax = 45,
                        RandomTimerMin = 15,
                        UseRandomTimer = false
                    },
                    GlobalDropMultiplier = 1.0f,
                    NotifyEvent = true
                    
                },
                z_IntensitySettings = new ConfigData.IntensityOptions
                {
                    Settings_Mild = new ConfigData.Settings
                    {
                        FireRocketChance = 30,
                        Radius = 500f,
                        Duration = 240,
                        ItemDropControl = new ConfigData.Drops
                        {
                            EnableItemDrop = true,
                            ItemsToDrop = new ItemDrop[]
                        {
                            new ItemDrop
                            {
                                Maximum = 120,
                                Minimum = 80,
                                Shortname = "stones"
                            },
                            new ItemDrop
                            {
                                Maximum = 50,
                                Minimum = 25,
                                Shortname = "metal.ore"
                            }
                        }
                        },
                        RocketAmount = 20
                    },
                    Settings_Optimal = new ConfigData.Settings
                    {
                        FireRocketChance = 20,
                        Radius = 300f,
                        Duration = 120,
                        ItemDropControl = new ConfigData.Drops
                        {
                            EnableItemDrop = true,
                            ItemsToDrop = new ItemDrop[]
                        {
                            new ItemDrop
                            {
                                Maximum = 250,
                                Minimum = 160,
                                Shortname = "stones"
                            },
                            new ItemDrop
                            {
                                Maximum = 120,
                                Minimum = 60,
                                Shortname = "metal.fragments"
                            },
                            new ItemDrop
                            {
                                Maximum = 50,
                                Minimum = 20,
                                Shortname = "hq.metal.ore"
                            }
                        }
                        },
                        RocketAmount = 45
                    },
                    Settings_Extreme = new ConfigData.Settings
                    {
                        FireRocketChance = 10,
                        Radius = 100f,
                        Duration = 30,
                        ItemDropControl = new ConfigData.Drops
                        {
                            EnableItemDrop = true,
                            ItemsToDrop = new ItemDrop[]
                        {
                            new ItemDrop
                            {
                                Maximum = 400,
                                Minimum = 250,
                                Shortname = "stones"
                            },
                            new ItemDrop
                            {
                                Maximum = 300,
                                Minimum = 125,
                                Shortname = "metal.fragments"
                            },
                            new ItemDrop
                            {
                                Maximum = 50,
                                Minimum = 20,
                                Shortname = "metal.refined"
                            },
                            new ItemDrop
                            {
                                Maximum = 120,
                                Minimum = 45,
                                Shortname = "sulfur.ore"
                            }
                        }
                        },
                        RocketAmount = 70
                    }
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Localization
        string msg(string key, string playerId = "") => lang.GetMessage(key, this, playerId);
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"incoming", "Meteor shower incoming" },
            {"help1", "/rof onplayer <opt:playername> - Calls a event on your position, or the player specified"},
            {"help2", "/rof onplayer_extreme <opt:playername> - Starts a extreme event on your position, or the player specified"},
            {"help3", "/rof onplayer_mild <opt:playername> - Starts a optimal event on your position, or the player specified"},
            {"help4", "/rof barrage - Fire a barrage of rockets from your position"},
            {"help5", "/rof random - Calls a event at a random postion"},
            {"help6", "/rof intervals <amount> - Change the time between events"},
            {"help7", "/rof damagescale <amount> - Change the damage scale"},
            {"help8", "/rof togglemsg - Toggle public event broadcast"},
            {"calledOn", "Event called on {0}'s position"},
            {"noPlayer", "No player found with that name"},
            {"onPos", "Event called on your position"},
            {"Extreme", "Extreme"},
            {"Mild", "Mild" },
            {"randomCall", "Event called on random position"},
            {"invalidParam", "Invalid parameter '{0}'"},
            {"smallInter", "Event intervals under 4 minutes are not allowed"},
            {"interSet", "Event intervals set to {0} minutes"},
            {"dropMulti", "Global item drop multiplier set to "},
            {"damageMulti", "Damage scale set to "},
            {"notifDeAct", "Event notification de-activated"},
            {"notifAct", "Event notification activated"},
            {"unknown", "Unknown parameter '{0}'"}
        };
        #endregion

    }
}


// --- End of file: RainOfFire.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/raid-markers ---
// --- Original File Path: R/RaidMarkers/RaidMarkers.cs ---

﻿/*
 ########### README ####################################################
                                                                             
  !!! DON'T EDIT THIS FILE !!!
                                                                     
 ########### CHANGES ###################################################

 1.0.0
    - Plugin release
 1.0.1
    - Added Localization
 1.0.2
    - Added permissions to see markers
    - Added hook CanNetworkTo
 1.0.3
    - Added option grid position
    - Added config update
    - Added option for entity owner
    - Added option for authorized players
    - Added option show online/offline raid
    - Change CanNetworkTo to object

 #######################################################################
*/

using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using System;
using Rust;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Raid Markers", "Paulsimik", "1.0.3")]
    [Description("Raid Markers on the map")]
    class RaidMarkers : RustPlugin
    {
        #region [Fields]

        private const string permAllow = "raidmarkers.allow";
        private Configuration config;
        private HashSet<MapMarkerGenericRadius> raidMarkers = new HashSet<MapMarkerGenericRadius>();

        #endregion

        #region [Oxide Hooks]

        private void Init() => permission.RegisterPermission(permAllow, this);

        private void Unload() => ClearRaidMarkers();

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null)
                return;

            if (entity.lastDamage != DamageType.Explosion)
                return;

            if (config.blacklistedPrefab.Contains(entity.ShortPrefabName))
                return;

            if (entity.name.Contains("building") || config.additionalPrefab.Contains(entity.ShortPrefabName))
            {
                if (!IsFar(entity.ServerPosition))
                    return;

                var attacker = info.InitiatorPlayer;
                if (attacker == null)
                    return;

                var buildingPrivlidge = entity.GetBuildingPrivilege();
                if (buildingPrivlidge != null && buildingPrivlidge.authorizedPlayers.Count > 0)
                {
                    if (config.authorizedPlayer && IsAuthed(attacker, buildingPrivlidge))
                        return;

                    var online = IsOnlineRaid(buildingPrivlidge);
                    if (!config.showOnline && online)
                        return;

                    if (!config.showOffline && !online)
                        return;
                }

                if (config.chatGridPosition)
                    Server.Broadcast(GetLang("GridPosition", null, GetGridPosition(entity.ServerPosition)));

                CreateRaidMarker(entity.ServerPosition);
            }
        }

        private object CanNetworkTo(MapMarkerGenericRadius marker, BasePlayer player)
        {
            if (marker == null || player == null)
                return null;

            if (raidMarkers.Contains(marker) && !permission.UserHasPermission(player.UserIDString, permAllow))
                return false;

            return null;
        }

        #endregion

        #region [Hooks]   

        private void CreateRaidMarker(Vector3 position)
        {
            MapMarkerGenericRadius marker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", position) as MapMarkerGenericRadius;
            if (marker == null)
                return;

            raidMarkers.Add(marker);
            marker.alpha = config.markerConfiguration.markerAlpha;
            marker.radius = config.markerConfiguration.markerRadius;
            marker.color1 = ParseColor(config.markerConfiguration.markerColor1);
            marker.color2 = ParseColor(config.markerConfiguration.markerColor2);
            marker.Spawn();
            marker.SendUpdate();

            timer.In(config.markerConfiguration.markerDuration, () =>
            {
                marker.Kill();
                marker.SendUpdate();
                raidMarkers.Remove(marker);
            });
        }

        private void ClearRaidMarkers()
        {
            foreach (var marker in raidMarkers)
            {
                if (marker != null)
                {
                    marker.Kill();
                    marker.SendUpdate();
                }
            }

            raidMarkers.Clear();
        }

        private bool IsFar(Vector3 position)
        {
            bool isFar = true;
            foreach (var marker in raidMarkers)
            {
                if (GetDistance(marker.ServerPosition, position) < config.markerDistance)
                {
                    isFar = false;
                    break;
                }
            }

            return isFar;
        }

        private bool IsAuthed(BasePlayer player, BuildingPrivlidge buildingPrivlidge)
        {
            return buildingPrivlidge.IsAuthed(player);
        }

        private bool IsOnlineRaid(BuildingPrivlidge buildingPrivlidge)
        {
            foreach (var authPlayer in buildingPrivlidge.authorizedPlayers)
            {
                BasePlayer player = BasePlayer.FindByID(authPlayer.userid);
                if (player != null && player.IsConnected)
                    return true;
            }

            return false;
        }

        private double GetDistance(Vector3 pos1, Vector3 pos2)
        {
            return Math.Round(Vector3.Distance(pos1, pos2), 0);
        }

        private Color ParseColor(string hexColor)
        {
            if (!hexColor.StartsWith("#"))
                hexColor = $"#{hexColor}";

            Color color;
            if (ColorUtility.TryParseHtmlString(hexColor, out color))
                return color;

            return Color.white;
        }

        public static string GetGridPosition(Vector3 position)
        {
            Vector2 vector = new Vector2(TerrainMeta.NormalizeX(position.x), TerrainMeta.NormalizeZ(position.z));
            float num = TerrainMeta.Size.x / 1024f;
            int num2 = 7;
            Vector2 vector2 = vector * num * num2;
            float num3 = Mathf.Floor(vector2.x) + 1f;
            float num4 = Mathf.Floor(num * (float)num2 - vector2.y);
            string text = string.Empty;
            float num5 = num3 / 26f;
            float num6 = num3 % 26f;
            if (num6 == 0f)
            {
                num6 = 26f;
            }

            if (num5 > 1f)
            {
                text += Convert.ToChar(64 + (int)num5);
            }

            text += Convert.ToChar(64 + (int)num6);
            return $"{text}{num4}";
        }

        #endregion 

        #region [Chat Commands]

        [ChatCommand("rmtest")]
        private void cmdRaidMarker(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                SendReply(player, GetLang("NoPerm", player.UserIDString));
                return;
            }

            CreateRaidMarker(player.ServerPosition);
            SendReply(player, GetLang("TestRaidMarker", player.UserIDString));
        }

        #endregion

        #region [Classes]

        private class Configuration
        {
            [JsonProperty(PropertyName = "Blaclisted prefabs")]
            public List<string> blacklistedPrefab = new List<string>();

            [JsonProperty(PropertyName = "Additional prefabs")]
            public List<string> additionalPrefab = new List<string>();

            [JsonProperty(PropertyName = "Distance when place new marker from another marker")]
            public int markerDistance;

            [JsonProperty("Enable write grid position to chat")]
            public bool chatGridPosition;

            [JsonProperty("Disable marker for authorized players in cupboard")]
            public bool authorizedPlayer;

            [JsonProperty("Create marker for online raid")]
            public bool showOnline;

            [JsonProperty("Create marker for offline raid")]
            public bool showOffline;

            [JsonProperty(PropertyName = "Marker configuration")]
            public MarkerConfiguration markerConfiguration;

            public VersionNumber version;
        }

        private class MarkerConfiguration
        {
            [JsonProperty(PropertyName = "Alpha")]
            public float markerAlpha;

            [JsonProperty(PropertyName = "Radius")]
            public float markerRadius;

            [JsonProperty(PropertyName = "Color1")]
            public string markerColor1;

            [JsonProperty(PropertyName = "Color2")]
            public string markerColor2;

            [JsonProperty(PropertyName = "Duration")]
            public float markerDuration;
        }

        #endregion

        #region [Config]

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                blacklistedPrefab = new List<string>
                {
                    "wall.external.high.wood",
                    "wall.external.high.stone"
                },
                additionalPrefab = new List<string>
                {
                    "cupboard.tool.deployed"
                },
                markerDistance = 100,
                chatGridPosition = true,
                authorizedPlayer = true,
                showOnline = true,
                showOffline = true,
                markerConfiguration = new MarkerConfiguration
                {
                    markerAlpha = 0.6f,
                    markerRadius = 0.7f,
                    markerDuration = 90f,
                    markerColor1 = "#000000",
                    markerColor2 = "#FF0000",
                },
                version = Version
            };
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
            Puts("Generating new configuration file........");
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();

                if (config == null)
                    LoadDefaultConfig();

                if (config.version < Version)
                    UpdateConfig();
            }
            catch
            {
                PrintError("######### Configuration file is not valid! #########");
                return;
            }

            SaveConfig();
        }

        private void UpdateConfig()
        {
            Puts("Updating configuration values.....");
            config.version = Version;
            Puts("Configuration updated");
        }

        #endregion

        #region [Localization]

        private string GetLang(string key, string playerID, params object[] args) => string.Format(lang.GetMessage(key, this, playerID), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "NoPerm", "You don't have permissions" },
                { "TestRaidMarker", "Test Raid Marker created on your position" },
                { "GridPosition", "Starting raid at {0} position" }

            }, this);
        }

        #endregion
    }
}

// --- End of file: RaidMarkers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ridable-horse-options ---
// --- Original File Path: R/RidableHorseOptions/RidableHorseOptions.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Ridable Horse Options", "Arainrr", "1.1.3")]
    [Description("Controls all rideable horses on your server")]
    public class RidableHorseOptions : RustPlugin
    {
        private const string PREFAB_RIDABLE_HORSE = "assets/rust.ai/nextai/testridablehorse.prefab";

        private void Init() => Unsubscribe(nameof(OnEntitySpawned));

        private void OnServerInitialized()
        {
            UpdateConfig();
            Subscribe(nameof(OnEntitySpawned));
            foreach (var ridableHorse in BaseNetworkable.serverEntities.OfType<RidableHorse>())
            {
                OnEntitySpawned(ridableHorse);
            }
        }

        private void OnEntitySpawned(RidableHorse ridableHorse)
        {
            if (ridableHorse == null) return;
            ApplyHorseSettings(ridableHorse);
        }

        private void UpdateConfig()
        {
            var ridableHorse = GameManager.server.FindPrefab(PREFAB_RIDABLE_HORSE)?.GetComponent<RidableHorse>();
            if (ridableHorse?.breeds == null) return;

            for (var i = 0; i < ridableHorse.breeds.Length; i++)
            {
                var horseBreed = ridableHorse.breeds[i];
                ridableHorse.SetBreed(i);
                if (configData.horseSettings.ContainsKey(horseBreed.breedName.english))
                {
                    continue;
                }
                configData.horseSettings.Add(horseBreed.breedName.english, new HorseSettings
                {
                    maxHealth = ridableHorse.MaxHealth() * horseBreed.maxHealth,
                    maxSpeed = ridableHorse.maxSpeed * horseBreed.maxSpeed,
                    walkSpeed = ridableHorse.walkSpeed,
                    trotSpeed = ridableHorse.trotSpeed,
                    runSpeed = ridableHorse.runSpeed,
                    turnSpeed = ridableHorse.turnSpeed,
                    roadSpeedBonus = ridableHorse.roadSpeedBonus,

                    maxStaminaSeconds = ridableHorse.maxStaminaSeconds,
                    staminaCoreSpeedBonus = ridableHorse.staminaCoreSpeedBonus,
                    staminaReplenishRatioMoving = ridableHorse.staminaReplenishRatioMoving,
                    staminaReplenishRatioStanding = ridableHorse.staminaReplenishRatioStanding,
                    staminaCoreLossRatio = ridableHorse.staminaCoreLossRatio,

                    maxWaterDepth = ridableHorse.maxWaterDepth,
                    maxWallClimbSlope = ridableHorse.maxWallClimbSlope,
                    maxStepHeight = ridableHorse.maxStepHeight,
                    maxStepDownHeight = ridableHorse.maxStepDownHeight,
                    maxStaminaCoreFromWater = ridableHorse.maxStaminaCoreFromWater,

                    caloriesToDigestPerHour = ridableHorse.CaloriesToDigestPerHour,
                    dungProducedPerCalorie = ridableHorse.DungProducedPerCalorie,
                    obstacleDetectionRadius = ridableHorse.obstacleDetectionRadius,
                    calorieToStaminaRatio = ridableHorse.calorieToStaminaRatio,
                    hydrationToStaminaRatio = ridableHorse.hydrationToStaminaRatio,
                });
            }

            SaveConfig();
        }

        private void ApplyHorseSettings(RidableHorse ridableHorse)
        {
            var horseBreed = ridableHorse.GetBreed();
            if (horseBreed == null) return;
            HorseSettings horseSettings;
            if (!configData.horseSettings.TryGetValue(horseBreed.breedName.english, out horseSettings))
            {
                return;
            }
            ridableHorse.InitializeHealth(horseSettings.maxHealth, horseSettings.maxHealth);
            ridableHorse.maxSpeed = horseSettings.maxSpeed;
            ridableHorse.walkSpeed = horseSettings.walkSpeed;
            ridableHorse.trotSpeed = horseSettings.trotSpeed;
            ridableHorse.runSpeed = horseSettings.runSpeed;
            ridableHorse.turnSpeed = horseSettings.turnSpeed;
            ridableHorse.roadSpeedBonus = horseSettings.roadSpeedBonus;

            ridableHorse.maxStaminaSeconds = horseSettings.maxStaminaSeconds;
            ridableHorse.staminaCoreSpeedBonus = horseSettings.staminaCoreSpeedBonus;
            ridableHorse.staminaReplenishRatioMoving = horseSettings.staminaReplenishRatioMoving;
            ridableHorse.staminaReplenishRatioStanding = horseSettings.staminaReplenishRatioStanding;
            ridableHorse.staminaCoreLossRatio = horseSettings.staminaCoreLossRatio;

            ridableHorse.maxWaterDepth = horseSettings.maxWaterDepth;
            ridableHorse.maxWallClimbSlope = horseSettings.maxWallClimbSlope;
            ridableHorse.maxStepHeight = horseSettings.maxStepHeight;
            ridableHorse.maxStepDownHeight = horseSettings.maxStepDownHeight;
            ridableHorse.maxStaminaCoreFromWater = horseSettings.maxStaminaCoreFromWater;

            ridableHorse.CaloriesToDigestPerHour = horseSettings.caloriesToDigestPerHour;
            ridableHorse.DungProducedPerCalorie = horseSettings.dungProducedPerCalorie;
            ridableHorse.obstacleDetectionRadius = horseSettings.obstacleDetectionRadius;
            ridableHorse.calorieToStaminaRatio = horseSettings.calorieToStaminaRatio;
            ridableHorse.hydrationToStaminaRatio = horseSettings.hydrationToStaminaRatio;

            ridableHorse.SendNetworkUpdate();
        }

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Horse Settings")]
            public Dictionary<string, HorseSettings> horseSettings = new Dictionary<string, HorseSettings>();
        }

        private class HorseSettings
        {
            public float maxHealth;
            public float maxSpeed;
            public float walkSpeed;
            public float trotSpeed;
            public float runSpeed;
            public float turnSpeed;
            public float roadSpeedBonus;

            public float maxStaminaSeconds;
            public float staminaCoreSpeedBonus;
            public float staminaReplenishRatioMoving;
            public float staminaReplenishRatioStanding;
            public float staminaCoreLossRatio;

            public float maxWaterDepth;
            public float maxWallClimbSlope;
            public float maxStepHeight;
            public float maxStepDownHeight;
            public float maxStaminaCoreFromWater;

            public float caloriesToDigestPerHour;
            public float dungProducedPerCalorie;
            public float obstacleDetectionRadius;
            public float calorieToStaminaRatio;
            public float hydrationToStaminaRatio;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile
    }
}

// --- End of file: RidableHorseOptions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/raid-notes ---
// --- Original File Path: R/RaidNotes/RaidNotes.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Text.RegularExpressions;

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;

using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

using UnityEngine;
using Rust;
using Facepunch;

namespace Oxide.Plugins
{
    [Info ("RaidNotes", "Calytic", "1.0.21", ResourceId = 2117)]
    [Description ("Broadcasts raid activity to chat & more")]
    public class RaidNotes : RustPlugin
    {
        #region Variables

        [PluginReference]
        Plugin Discord, Slack, Clans, LustyMap;

        DynamicConfigFile data;
        public static JsonSerializer SERIALIZER = new JsonSerializer ();
        public static JsonConverter [] CONVERTERS = new JsonConverter [] { new UnityVector3Converter (), new DateTimeConverter () };
        Dictionary<string, bool> _raidableCache = new Dictionary<string, bool> ();
        int blockLayer = UnityEngine.LayerMask.GetMask (new string [] { "Player (Server)" });
        static Dictionary<string, int> reverseItems = new Dictionary<string, int> ();
        static List<string> explosionRadiusPrefabs = new List<string> ();
        Dictionary<Raid, Timer> timers = new Dictionary<Raid, Timer> ();
        Dictionary<string, DateTime> detectionCooldowns = new Dictionary<string, DateTime> ();
        static Regex _htmlRegex = new Regex ("<.*?>", RegexOptions.Compiled);
        Color [] colors = new Color [7] { Color.blue, Color.cyan, Color.gray, Color.green, Color.magenta, Color.red, Color.yellow };

        float raidDuration = 300f;
        float raidDistance = 50f;
        float shoulderHeight = 0.45f;
        bool isNewSave = false;
        float detectionDuration = 60f;
        string slackType = "FancyMessage";
        int logHours = 12;

        bool trackExplosives = true;
        bool checkEntityDamage, checkEntityDeath, announceGlobal, printToLog = true;
        bool announceRaidStart, announceRaidEnd, announceToVictims, announceToSlack, announceToDiscord, announceToLustyMap, announceClan = false;
        string announcePrefixColor = "orange";
        string announceIcon;
        string announceNameColor = "lightblue";
        string announceClanColor = "#00eaff";
        string lustyMapIcon = "special";
        float lustyMapDuration = 10f;
        int detectionDistance = 50;
        float detectionCountdown = 1f;

        private Dictionary<string, object> weaponColors = new Dictionary<string, object> ()
        {
            { "0", "#666333" },
            { "498591726", "#666666" }
        };

        private Dictionary<string, object> gradeColors = new Dictionary<string, object> ()
        {
            { "Wood", "#a68b44" },
            { "Stone", "#a4a4a4" },
            { "Metal", "#9b5050" },
            { "TopTier", "#473131" }
        };

        private float announceDelay, announceRadius = 0f;

        internal int announceMinParticipants, announceMinWeapons, announceMinKills, announceMinDestroyed, announceMinMinutes = 0;

        List<string> prefabs = new List<string> ()
        {
            "door.hinged",
            "door.double.hinged",
            "window.bars",
            "floor.ladder.hatch",
            "floor.frame",
            "wall.frame",
            "shutter"
        };

        Dictionary<long, Raid> raids = new Dictionary<long, Raid> ();

        #endregion

        #region Classes

        public class AttackVector
        {
            public Vector3 start;
            public Vector3 end;
            public int weapon;
            public ulong victim;
            public ulong initiator;

            [JsonConstructor]
            public AttackVector (Vector3 start, Vector3 end, int weapon, ulong victim = 0, ulong initiator = 0)
            {
                this.start = start;
                this.end = end;
                this.weapon = weapon;
                this.victim = victim;
                this.initiator = initiator;
            }
        }

        public class Raid
        {
            public long start = DateTime.Now.ToBinary ();
            public long end = 0;
            public Vector3 firstDamage;
            public Vector3 lastDamage;
            public List<AttackVector> attackVector = new List<AttackVector> ();
            public List<AttackVector> killMap = new List<AttackVector> ();
            public ulong initiator;
            public ulong victim;
            public List<ulong> blockOwners = new List<ulong> ();
            public List<ulong> participants = new List<ulong> ();
            public int lastWeapon;
            public Dictionary<int, int> weapons = new Dictionary<int, int> ();

            public Dictionary<BuildingGrade.Enum, int> blocksDestroyed = new Dictionary<BuildingGrade.Enum, int> ();
            public Dictionary<string, int> entitiesDestroyed = new Dictionary<string, int> ();

            [JsonConstructor]
            public Raid (
                long start,
                long end,
                Vector3 firstDamage,
                Vector3 lastDamage,
                List<AttackVector> attackVector,
                ulong initiator,
                ulong victim,
                List<ulong> blockOwners,
                List<ulong> participants,
                int lastWeapon,
                Dictionary<int, int> weapons,
                List<AttackVector> killMap = null,
                Dictionary<BuildingGrade.Enum, int> blocksDestroyed = null,
                Dictionary<string, int> entitiesDestroyed = null
            )
            {
                this.start = start;
                this.end = end;
                this.firstDamage = firstDamage;
                this.lastDamage = lastDamage;
                this.attackVector = attackVector;
                this.initiator = initiator;
                this.victim = victim;
                this.blockOwners = blockOwners;
                this.participants = participants;
                this.lastWeapon = lastWeapon;
                this.weapons = weapons;
                if (killMap != null) {
                    this.killMap = killMap;
                }

                if (blocksDestroyed != null) {
                    this.blocksDestroyed = blocksDestroyed;
                }

                if (entitiesDestroyed != null) {
                    this.entitiesDestroyed = entitiesDestroyed;
                }
            }

            [JsonIgnore]
            internal AttackVector lastAttackVector = null;

            [JsonIgnore]
            RaidNotes plugin;

            [JsonIgnore]
            public bool Completed {
                get {
                    return end != 0;
                }
            }

            [JsonIgnore]
            public DateTime lastRefresh;

            [JsonIgnore]
            public IPlayer Initiator {
                get {
                    return plugin.covalence.Players.FindPlayerById (initiator.ToString ());
                }
            }

            [JsonIgnore]
            public IPlayer Victim {
                get {
                    return plugin.covalence.Players.FindPlayerById (victim.ToString ());
                }
            }

            [JsonIgnore]
            [JsonConverter (typeof (IsoDateTimeConverter))]
            public DateTime Start {
                get {
                    return DateTime.FromBinary (start);
                }
            }

            [JsonIgnore]
            [JsonConverter (typeof (IsoDateTimeConverter))]
            public DateTime End {
                get {
                    return DateTime.FromBinary (end);
                }
            }

            public Raid (RaidNotes plugin, ulong initiator, ulong victim, Vector3 firstDamage)
            {
                this.plugin = plugin;
                this.initiator = initiator;
                this.victim = victim;
                this.firstDamage = firstDamage;
            }

            [JsonIgnore]
            public double Hours {
                get {
                    if (!Completed) {
                        return 0;
                    }
                    var ts = DateTime.Now - End;
                    return ts.TotalHours;
                }
            }

            public bool HasHours (int hours)
            {
                if (Hours >= hours) {
                    return true;
                }

                return false;
            }

            public void Participate (BasePlayer player)
            {
                var behavior = player.gameObject.AddComponent<RaidBehavior> ();
                behavior.raid = this;
                if (!participants.Contains (player.userID)) {
                    participants.Add (player.userID);
                }
            }

            public bool IsAnnounced ()
            {
                if (participants.Count < plugin.announceMinParticipants)
                    return false;
                if (killMap.Count < plugin.announceMinKills)
                    return false;
                if (weapons.Count < plugin.announceMinWeapons)
                    return false;
                if ((entitiesDestroyed.Count + blocksDestroyed.Count) < plugin.announceMinDestroyed)
                    return false;

                var ts = End - Start;
                if (ts.TotalMinutes < plugin.announceMinMinutes)
                    return false;

                return true;
            }

            internal JObject Vector2JObject (Vector3 vector)
            {
                var obj = new JObject ();
                obj.Add ("x", vector.x);
                obj.Add ("y", vector.y);
                obj.Add ("z", vector.z);

                return obj;
            }

            public override string ToString ()
            {
                return ToJObject ().ToString ();
            }

            internal JObject ToJObject ()
            {
                var obj = new JObject ();

                obj ["start"] = Start.ToString ();
                obj ["end"] = End.ToString ();
                var explosions = new JObject ();
                explosions.Add ("first", Vector2JObject (firstDamage));
                explosions.Add ("last", Vector2JObject (lastDamage));
                obj ["explosions"] = explosions;

                obj ["initiator"] = initiator;
                obj ["victim"] = victim;

                JArray owners = new JArray ();
                foreach (var owner in blockOwners)
                    owners.Add (owner);

                obj ["owners"] = owners;

                JArray participantsData = new JArray ();
                foreach (var participant in participants)
                    participantsData.Add (participant);

                obj ["participants"] = participantsData;


                JObject weaponsData = new JObject ();
                foreach (var kvp in weapons)
                    weaponsData.Add (kvp.Key.ToString (), kvp.Value);

                obj ["weapons"] = weaponsData;

                obj ["attackvector"] = JArray.FromObject (attackVector, SERIALIZER);
                obj ["kills"] = JArray.FromObject (killMap, SERIALIZER);

                return obj;
            }

            internal void OnEnded ()
            {
                end = DateTime.Now.ToBinary ();
                Interface.CallHook ("OnRaidEnded", ToJObject ());
            }

            internal void OnStarted ()
            {
                Interface.CallHook ("OnRaidStarted", ToJObject ());
            }

            internal void Attack (AttackVector vector)
            {
                lastAttackVector = vector;
                attackVector.Add (vector);
            }

            internal void Kill (AttackVector vector)
            {
                killMap.Add (vector);
            }
        }

        public class RaidBehavior : MonoBehaviour
        {
            public BasePlayer player;
            internal Raid raid;


            void Awake ()
            {
                player = GetComponent<BasePlayer> ();
            }

            void OnDestroy ()
            {
                GameObject.Destroy (this);
            }
        }

        public class ExplosiveTracker : MonoBehaviour
        {
            public BaseEntity entity;
            public Vector3 lastValidPosition;

            public BasePlayer thrownBy;
            public Vector3 thrownFrom;

            void Awake ()
            {
                entity = GetComponent<BaseEntity> ();
                lastValidPosition = entity.transform.position;
            }

            void Update ()
            {
                if (Vector3.Distance (entity.transform.position, Vector3.zero) > 3) {
                    lastValidPosition = entity.transform.position;
                }
            }

            void OnDestroy ()
            {
                if (thrownBy == null)
                    return;
                var behavior = thrownBy.GetComponent<RaidBehavior> ();

                if (behavior != null && behavior.raid != null) {
                    int itemid;
                    if (reverseItems.TryGetValue (entity.PrefabName, out itemid))
                        behavior.raid.Attack (new AttackVector (thrownFrom, lastValidPosition, itemid, 0, thrownBy.userID));

                }
                GameObject.Destroy (this);
            }
        }

        enum AnnouncementType
        {
            Start = 1,
            End = 2,
            Slack_Start = 3,
            Slack_End = 4,
            Discord_Start = 5,
            Discord_End = 6
        }

        #endregion

        #region Initialization

        protected override void LoadDefaultConfig ()
        {
            PrintToConsole ("Creating new configuration");
            Config.Clear ();

            Config ["Settings", "trackEntityDamage"] = true;
            Config ["Settings", "trackEntityDeath"] = true;
            Config ["Settings", "trackExplosives"] = true;

            Config ["Raid", "distance"] = 50f;
            Config ["Raid", "duration"] = 300f;
            Config ["Raid", "logUpToHours"] = 3;
            Config ["Raid", "detectionDistance"] = 50;
            Config ["Raid", "detectionDuration"] = 60f;
            Config ["Raid", "detectionCountdownMinutes"] = 1f;

            Config ["AnnounceWhen", "raidEnds"] = false;
            Config ["AnnounceWhen", "raidStarts"] = false;
            Config ["AnnounceWhen", "minParticipants"] = 0;
            Config ["AnnounceWhen", "minWeapons"] = 0;
            Config ["AnnounceWhen", "minKills"] = 0;
            Config ["AnnounceWhen", "minMinutes"] = 0;

            Config ["AnnounceTo", "global"] = false;
            Config ["AnnounceTo", "clan"] = true;
            Config ["AnnounceTo", "victims"] = true;
            Config ["AnnounceTo", "slack"] = false;
            Config ["AnnounceTo", "discord"] = false;
            Config ["AnnounceTo", "lustymap"] = false;
            Config ["AnnounceTo", "log"] = true;

            Config ["Announcements", "icon"] = 0;
            Config ["Announcements", "prefixColor"] = "orange";
            Config ["Announcements", "nameColor"] = "lightblue";
            Config ["Announcements", "clanColor"] = "#00eaff";
            Config ["Announcements", "weaponColors"] = weaponColors;
            Config ["Announcements", "delay"] = 0f;
            Config ["Announcements", "radius"] = 0f;

            Config ["LustyMap", "icon"] = "special";
            Config ["LustyMap", "duration"] = 10f;

            Config ["Slack", "messageType"] = "FancyMessage";
        }

        void LoadMessages ()
        {
            lang.RegisterMessages (new Dictionary<string, string>
                {
                    { "Announce: Prefix", "Raid" },
                    { "Announce: Start", "{initiatorClan} {initiator} ({initiatorClanMates}) is raiding {victimClan} {victim} ({victimClanMates})" },
                    { "Announce: End", "{initiatorClan} {initiator} ({initiatorClanMates}) raided {victimClan} {victim} ({victimClanMates}) using {weaponList} destroying {destroyedList}" },
                    { "Announce: Slack Start", "{initiatorClan} {initiator} ({initiatorClanMates}) is raiding {victimClan} {victim} ({victimClanMates})" },
                    { "Announce: Slack End", "{initiatorClan} {initiator} ({initiatorClanMates}) raided {victimClan} {victim} ({victimClanMates}) with {weaponList} destroying {destroyedList}" },
                    { "Announce: Discord Start", "{initiatorClan} {initiator} ({initiatorClanMates}) is raiding {victimClan} {victim} ({victimClanMates})" },
                    { "Announce: Discord End", "{initiatorClan} {initiator} ({initiatorClanMates}) raided {victimClan} {victim} ({victimClanMates}) with {weaponList} destroying {destroyedList}" },
                    { "Denied: Permission", "You lack permission to do that" },
                    { "Raid: Found", "<size=15>Raid(s) found: {raidCount}</size>" },
                    { "Raid: Started", "Started: <b>{date}</b>" },
                    { "Raid: Ended", "Ended: <b>{date}</b>" },
                    { "Raid: Duration", "Duration: <b>{duration}</b> minutes" },
                    { "Raid: Initiator", "Initiator: <b>{initiatorName}</b> ({initiatorID})" },
                    { "Raid: PlayerList", "{listName}: <b>{list}</b>" },
                    { "Raid: Activity", "Raid" },
                    { "Target: Nothing", "Nothing" },
                    { "Cooldown: Seconds", "You are doing that too often, try again in a {0} seconds(s)." },
                    { "Cooldown: Minutes", "You are doing that too often, try again in a {0} minute(s)." },
                }, this);
        }

        void OnServerInitialized ()
        {
            LoadData ();
            LoadMessages ();

            foreach (JsonConverter converter in CONVERTERS) {
                SERIALIZER.Converters.Add (converter);
            }

            permission.RegisterPermission ("raidnotes.inspect", this);

            raidDistance = GetConfig ("Raid", "distance", 50f);
            raidDuration = GetConfig ("Raid", "duration", 300f);
            logHours = GetConfig ("Raid", "logUpToHours", 3);
            detectionDistance = GetConfig ("Raid", "detectionDistance", 50);
            detectionDuration = GetConfig ("Raid", "detectionDuration", 60f);
            detectionDuration = GetConfig ("Raid", "detectionCountdownMinutes", 1f);

            checkEntityDamage = GetConfig ("Settings", "hookEntityDamage", true);
            checkEntityDeath = GetConfig ("Settings", "hookEntityDeath", true);
            trackExplosives = GetConfig ("Settings", "trackExplosives", true);

            announceGlobal = GetConfig ("AnnounceTo", "global", false);
            announceClan = GetConfig ("AnnounceTo", "clan", true);
            announceToVictims = GetConfig ("AnnounceTo", "victims", true);
            announceToSlack = GetConfig ("AnnounceTo", "slack", false);
            announceToLustyMap = GetConfig ("AnnounceTo", "lustymap", false);
            announceToDiscord = GetConfig ("AnnounceTo", "discord", false);
            printToLog = GetConfig ("AnnounceTo", "log", true);

            announceRaidEnd = GetConfig ("AnnounceWhen", "raidEnds", false);
            announceRaidStart = GetConfig ("AnnounceWhen", "raidStarts", false);
            announceMinParticipants = GetConfig ("AnnounceWhen", "minParticipants", 0);
            announceMinWeapons = GetConfig ("AnnounceWhen", "minWeapons", 0);
            announceMinDestroyed = GetConfig ("AnnounceWhen", "minDestroyed", 0);
            announceMinKills = GetConfig ("AnnounceWhen", "minKills", 0);
            announceMinMinutes = GetConfig ("AnnounceWhen", "minMinutes", 0);

            announceIcon = GetConfig ("Announcements", "icon", "0");
            announcePrefixColor = GetConfig ("Announcements", "prefixColor", "orange");
            announceNameColor = GetConfig ("Announcements", "nameColor", "lightblue");
            announceClanColor = GetConfig ("Announcements", "clanColor", "#00eaff");
            weaponColors = GetConfig ("Announcements", "weaponColors", weaponColors);
            announceDelay = GetConfig ("Announcements", "delay", 0f);
            announceRadius = GetConfig ("Announcements", "radius", 0f);

            lustyMapIcon = GetConfig ("LustyMap", "icon", "special");
            lustyMapDuration = GetConfig ("LustyMap", "duration", 10f);

            slackType = GetConfig ("Slack", "messageType", "FancyMessage");

            if (announceToSlack && !Slack) {
                PrintWarning ("Slack plugin not found, please install http://oxidemod.org/plugins/slack.1952/");
                announceToSlack = false;
            }

            if (announceToDiscord && !Discord) {
                PrintWarning ("Discord plugin not found, please install http://oxidemod.org/plugins/discord.2149/");
                announceToDiscord = false;
            }

            if (announceToLustyMap && !LustyMap) {
                PrintWarning ("LustyMap plugin not found, please install http://oxidemod.org/plugins/lustymap.1333/");
            }

            if (logHours == 0) {
                Unsubscribe (nameof (OnServerSave));
            }

            if (!trackExplosives) {
                Unsubscribe (nameof (OnExplosiveThrown));
                Unsubscribe (nameof (OnRocketLaunched));
            }

            foreach (ItemDefinition def in ItemManager.GetItemDefinitions ()) {
                var modEntity = def.GetComponent<ItemModEntity> ();
                if (modEntity != null && modEntity.entityPrefab != null) {
                    var prefab = modEntity.entityPrefab.Get ();
                    var thrownWeapon = prefab.GetComponent<ThrownWeapon> ();

                    if (thrownWeapon != null && !string.IsNullOrEmpty (thrownWeapon.prefabToThrow.guid) && !reverseItems.ContainsKey (thrownWeapon.prefabToThrow.resourcePath)) {
                        reverseItems.Add (thrownWeapon.prefabToThrow.resourcePath, def.itemid);
                        continue;
                    }
                }

                var baseProjectile = def.GetComponent<ItemModProjectile> ();
                if (baseProjectile != null && !string.IsNullOrEmpty (baseProjectile.projectileObject.guid) && !reverseItems.ContainsKey (baseProjectile.projectileObject.resourcePath)) {
                    if (baseProjectile.projectileObject.resourcePath.Contains ("rocket") && !baseProjectile.projectileObject.resourcePath.Contains ("smoke")) {
                        explosionRadiusPrefabs.Add (baseProjectile.projectileObject.resourcePath);
                        reverseItems.Add (baseProjectile.projectileObject.resourcePath, def.itemid);
                    }
                }
            }

            if (announceClan) {
                if (!plugins.Exists ("Clans")) {
                    announceClan = false;
                    PrintWarning ("Clans plugin not found, please install http://oxidemod.org/plugins/clans.2087/");
                }
            }
        }

        protected void ReloadConfig ()
        {
            Config ["VERSION"] = Version.ToString ();
            ClearData ();
            PrintToConsole ("Upgrading configuration file");
            SaveConfig ();
        }

        void LoadData ()
        {
            if (logHours > 0) {
                data = Interface.Oxide.DataFileSystem.GetFile (nameof (RaidNotes));
                data.Settings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
                data.Settings.Converters = CONVERTERS;

                raids = data.ReadObject<Dictionary<long, Raid>> ();

                if (isNewSave) {
                    ClearData ();
                    isNewSave = false;
                }
            }

            if (Config ["VERSION"] == null) {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig ();
            } else if (GetConfig<string> ("VERSION", "") != Version.ToString ()) {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig ();
            }
        }

        void SaveData (bool force = false)
        {
            if (raids.Count > 0 && !force) {
                var toRemove = raids.Where (pair => pair.Value.Hours > logHours)
                                             .Select (pair => pair.Key)
                                             .ToList ();

                foreach (var key in toRemove)
                    raids.Remove (key);
            }

            data.WriteObject<Dictionary<long, Raid>> (raids);
        }

        void ClearData ()
        {
            raids.Clear ();
            SaveData ();
        }

        void OnNewSave (string filename)
        {
            isNewSave = true;
        }

        void OnServerSave ()
        {
            SaveData ();
        }

        void Unload ()
        {
            var objects = GameObject.FindObjectsOfType (typeof (RaidBehavior));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy (gameObj);

            objects = GameObject.FindObjectsOfType (typeof (ExplosiveTracker));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy (gameObj);

            if (logHours > 0) {
                SaveData (true);
            }
        }

        #endregion

        #region Oxide Hooks

        void OnExplosiveThrown (BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity.net == null)
                return;
            AddTracker (player, entity);
        }

        void OnRocketLaunched (BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity.net == null || !reverseItems.ContainsKey (entity.PrefabName))
                return;

            AddTracker (player, entity);
        }

        List<uint> recentAttacks = new List<uint> ();

        private void OnEntityTakeDamage (BaseCombatEntity entity, HitInfo hitInfo)
        {
            if(entity == null)
                return;
            if (!checkEntityDamage)
                return;
            if (hitInfo == null ||
                hitInfo.Initiator == null ||
                hitInfo.WeaponPrefab == null ||
                !IsEntityRaidable (entity))
                return;

            var prefabName = hitInfo.WeaponPrefab.PrefabName;

            if (explosionRadiusPrefabs.Contains (prefabName) && hitInfo.Initiator.net != null) {
                if (recentAttacks.Contains (hitInfo.Initiator.net.ID)) {
                    return;
                } else {
                    recentAttacks.Add (hitInfo.Initiator.net.ID);
                }

                Interface.Oxide.NextTick (delegate () {
                    if (recentAttacks.Contains (hitInfo.Initiator.net.ID)) {
                        recentAttacks.Remove (hitInfo.Initiator.net.ID);
                    }
                });
            }

            int itemUsed;
            if (!reverseItems.TryGetValue (prefabName, out itemUsed))
                return;

            if(hitInfo.damageTypes != null) {
                var majorityDamageType = hitInfo.damageTypes.GetMajorityDamageType ();
    
                switch (majorityDamageType) {
                case DamageType.Explosion:
                case DamageType.Heat:
                    StructureAttack (entity, hitInfo.Initiator, itemUsed);
                    break;
                }
            }
        }

        private void OnEntityDeath (BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (!checkEntityDeath || hitInfo == null || hitInfo.WeaponPrefab == null || hitInfo.Initiator == null || !(hitInfo.Initiator is BasePlayer))
                return;
            if (IsEntityRaidable (entity)) {
                var majorityDamageType = hitInfo.damageTypes.GetMajorityDamageType ();

                var prefabName = hitInfo.WeaponPrefab.PrefabName;
                int itemUsed;
                if (reverseItems.TryGetValue (prefabName, out itemUsed)) {
                    switch (majorityDamageType) {
                    case DamageType.Explosion:
                    case DamageType.Heat:
                        StructureAttack (entity, hitInfo.Initiator as BasePlayer, itemUsed, true);
                        break;
                    }
                }
            } else if (entity is BasePlayer)
                RegisterKill (entity as BasePlayer, hitInfo.Initiator as BasePlayer);

        }

        #endregion

        #region Commands

        [ConsoleCommand ("raids.wipe")]
        private void ccRaidsWipe (ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || (arg.Connection != null && arg.Connection.authLevel > 0)) {
                ClearData ();

                SendReply (arg, "Data wiped");
                return;
            }

            SendReply (arg, GetMsg ("Denied: Permission"));
        }

        [ChatCommand ("inspect")]
        private void cmdInspect (BasePlayer player, string command, string [] args)
        {
            var permission = HasPerm (player, "raidnotes.inspect");
            if (permission || (!permission && player.net.connection.authLevel > 0)) {
                if (!CheckCooldown (player))
                    return;
                else
                    PlayerCooldown (player);

                SendRaids (player, args);
                return;
            }

            SendReply (player, GetMsg ("Denied: Permission", player));
        }

        #endregion

        #region Core Methods

        void PlayerCooldown (BasePlayer player)
        {
            if (player.IsAdmin)
                return;

            if (detectionCooldowns.ContainsKey (player.UserIDString))
                detectionCooldowns.Remove (player.UserIDString);

            detectionCooldowns.Add (player.UserIDString, DateTime.Now);
        }

        bool CheckCooldown (BasePlayer player)
        {
            if (detectionCountdown > 0) {
                DateTime startTime;
                if (detectionCooldowns.TryGetValue (player.UserIDString, out startTime)) {
                    var endTime = DateTime.Now;

                    var span = endTime.Subtract (startTime);
                    if (span.TotalMinutes > 0 && span.TotalMinutes < Convert.ToDouble (detectionCountdown)) {
                        var timeleft = System.Math.Round (Convert.ToDouble (detectionCountdown) - span.TotalMinutes, 2);
                        if (timeleft < 1) {
                            var timelefts = System.Math.Round ((Convert.ToDouble (detectionCountdown) * 60) - span.TotalSeconds);
                            SendReply (player, string.Format (GetMsg ("Cooldown: Seconds", player), timelefts.ToString ()));
                        } else
                            SendReply (player, string.Format (GetMsg ("Cooldown: Minutes", player), System.Math.Round (timeleft).ToString ()));

                        return false;
                    } else
                        detectionCooldowns.Remove (player.UserIDString);

                }
            }

            return true;
        }

        void AddTracker (BasePlayer player, BaseEntity entity)
        {
            var tracker = entity.gameObject.AddComponent<ExplosiveTracker> ();
            tracker.thrownBy = player;
            tracker.thrownFrom = player.transform.position;
            tracker.thrownFrom.y += player.GetHeight () * shoulderHeight;
        }

        Vector3 Track (BaseEntity initiator, BaseEntity entity)
        {
            var fromPos = Vector3.zero;
            var tracker = trackExplosives ? initiator.gameObject.GetComponent<ExplosiveTracker> () : null;
            if (tracker != null)
                fromPos = tracker.thrownFrom;
            else
                fromPos = initiator.transform.position;

            return fromPos;
        }

        List<Raid> GetRaids (BasePlayer player, string [] args)
        {
            var defaultDistance = detectionDistance;
            if (args != null && args.Length == 1)
                int.TryParse (args [0], out defaultDistance);

            if (defaultDistance > detectionDistance)
                defaultDistance = detectionDistance;

            return raids.Where (pair => Vector3.Distance (pair.Value.firstDamage, player.transform.position) <= defaultDistance).Select (pair => pair.Value).ToList ();
        }

        void SendRaids (BasePlayer player, string [] args)
        {
            if (player.net.connection == null)
                return;

            var nearbyRaids = GetRaids (player, args);

            if (nearbyRaids.Count > 0) {
                int found = 0;
                var sbs = new List<StringBuilder> ();
                foreach (var raid in nearbyRaids) {
                    var sb = new StringBuilder ();
                    if (SendRaid (player, raid, sb, found)) {
                        found++;
                        sbs.Add (sb);
                    }
                }

                if (found > 0) {
                    SendReply (player, Format (GetMsg ("Raid: Found", player), raidCount => found));
                    foreach (var sb in sbs) {
                        SendReply (player, sb.ToString ());
                    }
                    return;
                }
            }

            SendReply (player, "No raids found");
        }

        public string ToHex (Color c)
        {
            return string.Format ("#{0:X2}{1:X2}{2:X2}", ToByte (c.r), ToByte (c.g), ToByte (c.b));
        }

        private byte ToByte (float f)
        {
            f = Mathf.Clamp01 (f);
            return (byte)(f * 255);
        }

        bool SendRaid (BasePlayer player, Raid raid, StringBuilder sb, int found = 0)
        {
            var uiduration = detectionDuration * 60;
            var admin = false;
            if (player.net.connection.authLevel > 0)
                admin = true;

            var randomColor = colors [UnityEngine.Random.Range (0, colors.Length - 1)];
            var validAttack = false;
            foreach (AttackVector attack in raid.attackVector) {
                if (!admin && attack.victim != player.userID)
                    continue;

                validAttack = true;
                var weapName = string.Empty;
                var def = ItemManager.FindItemDefinition (attack.weapon);
                if (def is ItemDefinition)
                    weapName = def.displayName.english;

                player.SendConsoleCommand ("ddraw.arrow", uiduration, randomColor, attack.start, attack.end, 0.2);

                if (!string.IsNullOrEmpty (weapName))
                    player.SendConsoleCommand ("ddraw.text", uiduration, GetWeaponColor (attack.weapon), attack.start, weapName);
            }

            foreach (AttackVector kill in raid.killMap) {
                if (!admin && kill.victim != player.userID)
                    continue;

                validAttack = true;

                player.SendConsoleCommand ("ddraw.arrow", uiduration, randomColor, kill.start, kill.end, 0.2);
                player.SendConsoleCommand ("ddraw.sphere", uiduration, Color.red, kill.end, 0.5f);

                var victimPlayer = covalence.Players.FindPlayerById (kill.victim.ToString ());
                var initiatorPlayer = covalence.Players.FindPlayerById (kill.initiator.ToString ());

                if (victimPlayer is IPlayer) {
                    player.SendConsoleCommand ("ddraw.text", uiduration, Color.red, kill.end + Vector3.up, victimPlayer.Name);
                }

                if (initiatorPlayer is IPlayer) {
                    player.SendConsoleCommand ("ddraw.text", uiduration, Color.red, kill.start + Vector3.up, initiatorPlayer.Name);
                }
            }

            if (validAttack) {
                player.SendConsoleCommand ("ddraw.arrow", uiduration, Color.green, raid.firstDamage + new Vector3 (0, 5, 0), raid.firstDamage, 0.2);
                if (raid.lastDamage != Vector3.zero) {
                    player.SendConsoleCommand ("ddraw.arrow", uiduration, Color.red, raid.lastDamage + new Vector3 (0, 5, 0), raid.lastDamage, 0.2);
                }
                sb.Append (Format ("<color={color}><size=17>#{count}</size></color> + ", count => (found + 1), color => ToHex (randomColor)));
                var start = (raid.Start != null) ? raid.Start.ToString () : "N/A";
                sb.AppendLine (Format (GetMsg ("Raid: Started"), date => start));
                if (raid.Completed) {
                    TimeSpan ts = raid.End - raid.Start;
                    var end = (raid.End != null) ? raid.End.ToString () : "N/A";
                    sb.Append ("   |- ").AppendLine (Format (GetMsg ("Raid: Duration"), duration => Math.Round (ts.TotalMinutes, 2)));
                    sb.Append ("   |- ").AppendLine (Format (GetMsg ("Raid: Ended"), date => end));
                }

                var initiator = covalence.Players.FindPlayerById (raid.initiator.ToString ());
                if (initiator != null) {
                    sb.Append ("   |- ").AppendLine (Format (GetMsg ("Raid: Initiator"), initiatorName => initiator.Name, initiatorID => initiator.Id));
                }

                if (raid.blockOwners.Count > 0) {
                    var victimList = string.Join (", ", raid.blockOwners.Select (x => covalence.Players.FindPlayerById (x.ToString ()).Name).ToArray ());
                    sb.Append ("   |- ").AppendLine (Format (GetMsg ("Raid: PlayerList"), listName => "Property Of", list => victimList));
                }

                if (raid.participants.Count > 0) {
                    var participantList = string.Join (", ", raid.blockOwners.Where (x => !raid.blockOwners.Contains (x)).Select (x => covalence.Players.FindPlayerById (x.ToString ()).Name).ToArray ());
                    if (!string.IsNullOrEmpty (participantList.Trim ())) {
                        sb.Append ("   |- ").AppendLine (Format (GetMsg ("Raid: PlayerList"), listName => "Perpetrators", list => participantList));
                    }
                }

                if (raid.weapons.Count > 0)
                    sb.Append ("   |- ").AppendLine (GetWeaponList (raid));


                if (raid.blocksDestroyed.Count > 0 || raid.entitiesDestroyed.Count > 0)
                    sb.Append ("   |- ").AppendLine (GetDestroyedList (raid));


                return true;
            }

            return false;
        }

        void RegisterKill (BasePlayer player, BasePlayer attacker)
        {
            var behavior = player.GetComponent<RaidBehavior> ();
            if (behavior != null && behavior.raid != null) {
                var activeItem = attacker.GetActiveItem ();
                var itemid = 0;
                if (activeItem != null)
                    itemid = activeItem.info.itemid;

                behavior.raid.Kill (new AttackVector (attacker.transform.position, player.transform.position, itemid, player.userID, attacker.userID));

                GameObject.Destroy (behavior);
            }
        }

        void StructureAttack (BaseEntity targetEntity, BaseEntity sourceEntity, int weapon, bool destroy = false)
        {
            BasePlayer source;

            if (sourceEntity.ToPlayer () is BasePlayer)
                source = sourceEntity.ToPlayer ();
            else {
                var ownerID = (sourceEntity.OwnerID == 0) ? sourceEntity.OwnerID.ToString () : string.Empty;
                if (!string.IsNullOrEmpty (ownerID))
                    source = BasePlayer.Find (ownerID);
                else
                    return;
            }

            if (source == null)
                return;

            var targetID = targetEntity.OwnerID.IsSteamId () ? targetEntity.OwnerID.ToString () : string.Empty;

            if (!string.IsNullOrEmpty (targetID) && targetID != source.UserIDString) {
                var targetIDUint = Convert.ToUInt64 (targetID);
                /* var target = covalence.Players.FindPlayerById (targetID);*/
                Raid raid;
                var raidFound = TryGetRaid (source, targetIDUint, targetEntity.transform.position, out raid);
                raid.lastWeapon = weapon;


                if (raid.blockOwners.Count == 0)
                    raid.victim = targetIDUint;

                if (!raid.blockOwners.Contains (targetIDUint))
                    raid.blockOwners.Add (targetIDUint);

                if (destroy) {
                    if (targetEntity is BuildingBlock) {
                        var grade = ((BuildingBlock)targetEntity).grade;
                        if (raid.blocksDestroyed.ContainsKey (grade))
                            raid.blocksDestroyed [grade]++;
                        else
                            raid.blocksDestroyed.Add (grade, 1);
                    } else if (targetEntity is BaseCombatEntity) {
                        var name = targetEntity.ShortPrefabName;
                        if (raid.entitiesDestroyed.ContainsKey (name))
                            raid.entitiesDestroyed [name]++;
                        else
                            raid.entitiesDestroyed.Add (name, 1);
                    }
                } else {
                    if (raid.weapons.ContainsKey (weapon))
                        raid.weapons [weapon]++;
                    else
                        raid.weapons.Add (weapon, 1);
                }

                if (raid.lastAttackVector != null)
                    raid.lastAttackVector.victim = targetIDUint;

                raid.lastDamage = targetEntity.transform.position;

                if (!raidFound && announceRaidStart) {
                    AnnounceRaidMsg (raid, AnnouncementType.Start);
                    if (announceToSlack)
                        AnnounceRaidMsg (raid, AnnouncementType.Slack_Start);

                    if (announceToDiscord)
                        AnnounceRaidMsg (raid, AnnouncementType.Discord_Start);
                }
            }
        }

        Raid FindRaid (Vector3 position, out List<BasePlayer> nearbyTargets)
        {
            Raid existingRaid = null;

            nearbyTargets = GetNearbyPlayers (position);

            if (existingRaid == null && nearbyTargets.Count > 0) {
                foreach (var nearbyTarget in nearbyTargets) {
                    var behavior = nearbyTarget.GetComponent<RaidBehavior> ();
                    if (behavior != null && behavior.raid != null && existingRaid != behavior.raid && !behavior.raid.Completed) {
                        existingRaid = behavior.raid;
                        break;
                    }
                }
            }

            return existingRaid;
        }

        List<BasePlayer> GetNearbyPlayers (Vector3 position)
        {
            var nearbyTargets = Pool.GetList<BasePlayer> ();
            Vis.Entities<BasePlayer> (position, raidDistance, nearbyTargets, blockLayer);
            nearbyTargets = Sort (position, nearbyTargets);

            return nearbyTargets;
        }

        bool TryGetRaid (BasePlayer source, ulong victim, Vector3 position, out Raid raid)
        {
            Raid existingRaid = null;
            List<BasePlayer> nearbyTargets = null;
            var sourceBehavior = source.GetComponent<RaidBehavior> ();

            if (sourceBehavior != null && sourceBehavior.raid != null && !sourceBehavior.raid.Completed)
                existingRaid = sourceBehavior.raid;
            else
                existingRaid = FindRaid (position, out nearbyTargets);

            bool found = true;

            if (existingRaid == null || (existingRaid != null && existingRaid.Completed)) {
                found = false;
                var newRaid = StartRaid (source, victim, position);
                existingRaid = newRaid;

                if (nearbyTargets == null)
                    nearbyTargets = GetNearbyPlayers (position);

                foreach (var nearbyTarget in nearbyTargets) {
                    var behavior = nearbyTarget.GetComponent<RaidBehavior> ();
                    if (behavior == null || (behavior != null && behavior.raid == null)) {
                        existingRaid.Participate (nearbyTarget);
                    }
                }
            } else if (sourceBehavior == null || (sourceBehavior != null && sourceBehavior.raid == null))
                existingRaid.Participate (source);


            if (nearbyTargets != null)
                Pool.FreeList<BasePlayer> (ref nearbyTargets);

            RefreshRaid (existingRaid);
            raid = existingRaid;
            return found;
        }

        public Raid StartRaid (BasePlayer source, ulong victim, Vector3 position)
        {
            var raid = new Raid (this, source.userID, victim, position);

            RefreshRaid (raid);

            raid.Participate (source);
            raid.OnStarted ();

            return raid;
        }

        private string GetAnnouncementMsg (AnnouncementType type)
        {
            var msgName = string.Empty;
            switch (type) {
            case AnnouncementType.Start:
                msgName = "Announce: Start";
                break;
            case AnnouncementType.End:
                msgName = "Announce: End";
                break;
            case AnnouncementType.Slack_Start:
                msgName = "Announce: Slack Start";
                break;
            case AnnouncementType.Slack_End:
                msgName = "Announce: Slack End";
                break;
            case AnnouncementType.Discord_Start:
                msgName = "Announce: Discord Start";
                break;
            case AnnouncementType.Discord_End:
                msgName = "Announce: Discord End";
                break;
            }

            if (!string.IsNullOrEmpty (msgName))
                return GetMsg (msgName);

            return msgName;
        }

        public void CheckRaid (Raid raid)
        {
            var ts = DateTime.Now - raid.lastRefresh;
            if (ts.TotalSeconds > raidDuration) {
                if (announceToLustyMap && lustyMapDuration > 0)
                    LustyMap?.Call ("RemoveMarker", raid.start.ToString ());

                StopRaid (raid);
                if (announceRaidEnd) {
                    AnnounceRaidMsg (raid, AnnouncementType.End);
                    if (announceToSlack)
                        AnnounceRaidMsg (raid, AnnouncementType.Slack_End);

                    if (announceToDiscord)
                        AnnounceRaidMsg (raid, AnnouncementType.Discord_End);

                }
            }
        }

        void AnnounceRaidMsg (Raid raid, AnnouncementType type)
        {
            if (announceDelay > 0)
                timer.In (announceDelay, delegate () {
                    AnnounceRaid (raid, type);
                });
            else
                AnnounceRaid (raid, type);
        }

        public void RefreshRaid (Raid raid)
        {

            raid.lastRefresh = DateTime.Now;
            Timer t;

            if (timers.TryGetValue (raid, out t)) {
                if (t.Destroyed) {
                    timers.Add (raid, t = timer.Repeat (raidDuration, 0, () => CheckRaid (raid)));
                }
            } else {
                timers.Add (raid, t = timer.Repeat (raidDuration, 0, () => CheckRaid (raid)));
            }
        }

        public void DestroyTimer (Raid raid)
        {
            Timer raidTimer;
            if (timers.TryGetValue (raid, out raidTimer)) {
                if (!raidTimer.Destroyed)
                    raidTimer.Destroy ();

                timers.Remove (raid);
            }
        }

        public void StopRaid (Raid raid)
        {
            foreach (ulong part in raid.participants) {
                var partPlayer = BasePlayer.FindByID (part);
                if (partPlayer != null && partPlayer.GetComponent<RaidBehavior> () != null)
                    GameObject.Destroy (partPlayer.GetComponent<RaidBehavior> ());
            }

            DestroyTimer (raid);

            raid.OnEnded ();
            var raidKey = raid.start;
            if (!raids.ContainsKey (raidKey))
                raids.Add (raidKey, raid);
        }

        string GetWeaponColor (int weaponid)
        {
            object color = "#666666";
            if (weaponColors.TryGetValue (weaponid.ToString (), out color))
                return color.ToString ();


            if (weaponColors.TryGetValue ("0", out color))
                return color.ToString ();

            return color.ToString ();
        }

        string GetGradeColor (int grade)
        {
            object color = "#FFFFFF";
            var name = Enum.GetName (typeof (BuildingGrade.Enum), grade);
            if (!string.IsNullOrEmpty(name) && gradeColors.TryGetValue (name, out color))
                return color.ToString ();

            return color.ToString ();
        }

        string GetWeaponList (Raid raid)
        {
            string weaponsNameText = string.Empty;
            var weaponsList = new List<string> ();
            foreach (var kvp in raid.weapons) {
                var weaponsItem = ItemManager.FindItemDefinition (kvp.Key);
                if (weaponsItem is ItemDefinition)
                    weaponsList.Add (kvp.Value + " x " + string.Format ("<color={0}>{1}(s)</color>", GetWeaponColor (weaponsItem.itemid), weaponsItem.displayName.english));
            }

            if (weaponsList.Count > 0)
                weaponsNameText = string.Join (", ", weaponsList.ToArray ());

            return weaponsNameText;
        }

        string GetDestroyedList (Raid raid)
        {
            string destroyedText = string.Empty;
            var destroyedList = new List<string> ();
            foreach (var kvp in raid.blocksDestroyed)
                destroyedList.Add (kvp.Value + " x " + string.Format ("<color={0}>{1}(s)</color>", GetGradeColor ((int)kvp.Key), Enum.GetName (typeof (BuildingGrade.Enum), kvp.Key) + " Structure"));

            foreach (var kvp in raid.entitiesDestroyed)
                destroyedList.Add (kvp.Value + " x " + string.Format ("<color={0}>{1}(s)</color>", "white", kvp.Key));

            if (destroyedList.Count > 0)
                destroyedText = string.Join (", ", destroyedList.ToArray ());

            return destroyedText;
        }

        void AnnounceRaid (Raid raid, AnnouncementType type)
        {
            var format = GetAnnouncementMsg (type);
            if (string.IsNullOrEmpty (format)) {
                return;
            }
            var initiatorClanTag = string.Empty;
            var victimClanTag = string.Empty;
            var initiatorText = raid.Initiator.Name;
            var victimText = raid.Victim.Name;
            var initiatorClanText = string.Empty;
            var victimClanText = string.Empty;
            var initiatorClanMatesText = "1";
            var victimClanMatesText = "1";

            if (announceClan) {
                initiatorClanTag = Clans.Call<string> ("GetClanOf", raid.initiator);
                victimClanTag = Clans.Call<string> ("GetClanOf", raid.victim);

                if (initiatorClanTag != null) {
                    initiatorClanText = string.Format ("<color={0}>{1}</color>", announceClanColor, initiatorClanTag);
                    initiatorClanMatesText = GetClanMembers (initiatorClanTag).Count.ToString ();
                }

                if (victimClanTag != null) {
                    victimClanText = string.Format ("<color={0}>{1}</color>", announceClanColor, victimClanTag);
                    victimClanMatesText = GetClanMembers (victimClanTag).Count.ToString ();
                }
            }

            initiatorText = string.Format ("<color={0}>{1}</color>", announceNameColor, initiatorText);
            victimText = string.Format ("<color={0}>{1}</color>", announceNameColor, victimText);

            var announcePrefix = string.Format ("<color={0}>{1}</color>", announcePrefixColor, GetMsg ("Announce: Prefix"));

            var weaponsNameText = GetWeaponList (raid);
            var destroyedNameText = GetMsg ("Target: Nothing");
            if (raid.blocksDestroyed.Count > 0 || raid.entitiesDestroyed.Count > 0)
                destroyedNameText = GetDestroyedList (raid);

            var message = Format (format,
                              initiator => initiatorText,
                              victim => victimText,
                              initiatorClanMates => initiatorClanMatesText,
                              victimClanMates => victimClanMatesText,
                              initiatorClan => initiatorClanText,
                              victimClan => victimClanText,
                              weaponList => weaponsNameText,
                              destroyedList => destroyedNameText
                          );

            if (type == AnnouncementType.Slack_Start || type == AnnouncementType.Slack_End) {
                Slack?.Call (slackType, StripTags (message), raid.Initiator);
            } else if (type == AnnouncementType.Discord_Start || type == AnnouncementType.Discord_End) {
                Discord?.Call ("SendMessage", StripTags (message));
            } else {
                if (printToLog)
                    PrintToConsole (message);

                if (announceGlobal) {
                    if (announceRadius > 0)
                        BroadcastLocal (announcePrefix, message, raid.firstDamage);
                    else
                        BroadcastGlobal (announcePrefix, message);
                } else {
                    if (announceClan && raid.victim.IsSteamId ()) {
                        string tag = Clans.Call<string> ("GetClanOf", raid.victim);

                        var clan = GetClanMembers (tag);

                        if (clan.Count > 0)
                            foreach (string memberId in clan)
                                if (!string.IsNullOrEmpty (memberId))
                                    BroadcastToPlayer (announcePrefix, memberId, message);
                    }
                    if (announceToVictims)
                        foreach (ulong owner in raid.blockOwners)
                            BroadcastToPlayer (announcePrefix, owner.ToString (), message);
                }

                if (announceToLustyMap && lustyMapDuration > 0 && raid.firstDamage != Vector3.zero) {
                    var obj = LustyMap?.Call ("AddMarker", raid.firstDamage.x, raid.firstDamage.z, raid.start.ToString (), lustyMapIcon);
                    if (obj is bool && (bool)obj == true) {
                        timer.In (lustyMapDuration, delegate () {
                            LustyMap?.Call ("RemoveMarker", raid.start.ToString ());
                        });
                    }
                }
            }
        }

        void BroadcastGlobal (string prefix, string message)
        {
            rust.BroadcastChat (prefix, message, announceIcon);
        }

        void BroadcastLocal (string prefix, string message, Vector3 position)
        {
            foreach (var player in BasePlayer.activePlayerList)
                if (player.Distance (position) <= announceRadius)
                    player.ChatMessage (prefix + ": " + message);
        }

        void BroadcastToPlayer (string prefix, string userID, string message)
        {
            var player = BasePlayer.Find (userID);

            if (player is BasePlayer)
                player.ChatMessage (prefix + ": " + message);
        }

        void OnPlayerAttack (BasePlayer attacker, HitInfo hitInfo)
        {
            if (!(hitInfo.HitEntity is BasePlayer))
                return;
            if (hitInfo.damageTypes.GetMajorityDamageType () != DamageType.Explosion)
                return;

            var victim = (hitInfo.HitEntity as BasePlayer);

            if (victim != null) {
                var victimBehavior = victim.GetComponent<RaidBehavior> ();
                var attackerBehavior = attacker.GetComponent<RaidBehavior> ();

                if (victimBehavior != null && victimBehavior.raid != null && (attackerBehavior == null || (attackerBehavior != null && attackerBehavior.raid == null)))
                    victimBehavior.raid.Participate (attacker);
            }
        }

        public List<string> GetClanMembers (string tag)
        {
            var members = new List<string> ();

            if (string.IsNullOrEmpty (tag))
                return members;

            var clan = Clans.Call<JObject> ("GetClan", tag);

            if (clan == null)
                return members;

            foreach (string memberid in clan ["members"])
                members.Add (memberid);

            return members;
        }

        public List<string> GetOnlineClanMembers (string tag)
        {
            var allMembers = GetClanMembers (tag);

            var onlineMembers = new List<string> ();
            if (allMembers == null) {
                return onlineMembers;
            }

            foreach (string mid in allMembers) {
                var p = covalence.Players.FindPlayerById (mid);
                if (p is IPlayer && p.IsConnected)
                    onlineMembers.Add (mid);
            }

            return onlineMembers;
        }

        public List<Raid> GetRaids ()
        {
            var raids = new List<Raid> ();
            var objects = GameObject.FindObjectsOfType (typeof (RaidBehavior));
            if (objects != null)
                foreach (var gameObj in objects) {
                    var raidBehavior = gameObj as RaidBehavior;
                    if (raidBehavior.raid != null)
                        raids.Add (raidBehavior.raid);
                }

            return raids;
        }

        public bool IsEntityRaidable (BaseCombatEntity entity)
        {
            if (entity is BuildingBlock) {
                return true;
            }
            var result = false;
            var prefabName = entity.ShortPrefabName;
            if (_raidableCache.TryGetValue (prefabName, out result))
                return result;

            foreach (string p in prefabs) {
                if (prefabName.IndexOf (p, StringComparison.InvariantCultureIgnoreCase) != -1) {
                    result = true;
                    break;
                }
            }

            _raidableCache.Add (prefabName, result);

            return result;
        }

        #endregion

        #region Helper Methods

        string Format (string str, params Expression<Func<string, object>> [] args)
        {
            var sb = new StringBuilder (str);

            if (args.Length > 0) {
                Dictionary<string, object> parameters = new Dictionary<string, object> ();

                foreach (Expression<Func<string, object>> e in args) {
                    if (e == null)
                        continue;
                    if (e.Parameters == null)
                        continue;
                    if (e.Parameters.Count == 0)
                        continue;
                    var func = e.Compile ();
                    if (func == null)
                        continue;

                    var name = e.Parameters [0].Name;
                    if (name == null)
                        continue;
                    var result = func.Invoke (name);
                    if (result == null)
                        continue;
                    parameters.Add ("{" + name + "}", result);
                }

                foreach (var kv in parameters) {
                    if (kv.Key != null && kv.Value != null) {
                        sb.Replace (kv.Key, kv.Value != null ? kv.Value.ToString () : "");
                    }
                }
            }

            return sb.ToString ();
        }

        T GetConfig<T> (string key, T defaultValue)
        {
            try {
                var val = Config [key];
                if (val == null)
                    return defaultValue;
                if (val is List<object>) {
                    var t = typeof (T).GetGenericArguments () [0];
                    if (t == typeof (String)) {
                        var cval = new List<string> ();
                        foreach (var v in val as List<object>)
                            cval.Add ((string)v);
                        val = cval;
                    } else if (t == typeof (int)) {
                        var cval = new List<int> ();
                        foreach (var v in val as List<object>)
                            cval.Add (Convert.ToInt32 (v));
                        val = cval;
                    }
                } else if (val is Dictionary<string, object>) {
                    var t = typeof (T).GetGenericArguments () [1];
                    if (t == typeof (int)) {
                        var cval = new Dictionary<string, int> ();
                        foreach (var v in val as Dictionary<string, object>)
                            cval.Add (Convert.ToString (v.Key), Convert.ToInt32 (v.Value));
                        val = cval;
                    }
                }
                return (T)Convert.ChangeType (val, typeof (T));
            } catch (Exception ex) {
                PrintWarning ("Invalid config value: " + key + " (" + ex.Message + ")");
                return defaultValue;
            }
        }

        T GetConfig<T> (string name, string name2, T defaultValue)
        {
            if (Config [name, name2] == null) {
                return defaultValue;
            }

            return (T)Convert.ChangeType (Config [name, name2], typeof (T));
        }

        string GetMsg (string key, BasePlayer player = null)
        {
            return lang.GetMessage (key, this, player == null ? null : player.UserIDString);
        }

        public static List<BasePlayer> Sort (Vector3 position, List<BasePlayer> hits)
        {
            return hits.OrderBy (i => i.Distance (position)).ToList ();
        }

        bool HasPerm (BasePlayer p, string pe)
        {
            return permission.UserHasPermission (p.userID.ToString (), pe);
        }

        bool HasPerm (string userid, string pe)
        {
            return permission.UserHasPermission (userid, pe);
        }

        class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson (JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue ($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson (JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String) {
                    var values = reader.Value.ToString ().Trim ().Split (' ');
                    return new Vector3 (Convert.ToSingle (values [0]), Convert.ToSingle (values [1]), Convert.ToSingle (values [2]));
                }
                var o = JObject.Load (reader);
                return new Vector3 (Convert.ToSingle (o ["x"]), Convert.ToSingle (o ["y"]), Convert.ToSingle (o ["z"]));
            }

            public override bool CanConvert (Type objectType)
            {
                return objectType == typeof (Vector3);
            }
        }

        class DateTimeConverter : JsonConverter
        {
            public override void WriteJson (JsonWriter writer, object value, JsonSerializer serializer)
            {
                var datetime = (DateTime)value;
                writer.WriteValue (datetime.ToBinary ().ToString ());
            }

            public override object ReadJson (JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                long binaryDate;
                if (reader.TokenType == JsonToken.String && long.TryParse (reader.Value.ToString (), out binaryDate))
                    return DateTime.FromBinary (binaryDate);

                return DateTime.MinValue;
            }

            public override bool CanConvert (Type objectType)
            {
                return objectType == typeof (DateTime);
            }
        }

        public string StripTags (string source)
        {
            return _htmlRegex.Replace (source, string.Empty);
        }

        #endregion

        #region HelpText

        void SendHelpText (BasePlayer player)
        {
            if (HasPerm (player, "raidnotes.inspect")) {
                var sb = new StringBuilder ()
                   .Append ("RaidNotes\n");

                if (logHours > 0) {
                    if (player.net.connection.authLevel > 0) {
                        sb.Append ("  ").Append ("<color=\"#ffd479\">/raids</color> - Detect any raiding activity up to " + logHours + " hours ago").Append ("\n");
                    } else {
                        sb.Append ("  ").Append ("<color=\"#ffd479\">/raids</color> - Detect raiding activity against structures you own up to " + logHours + " hours ago").Append ("\n");
                    }
                }

                player.ChatMessage (sb.ToString ());
            }
        }

        #endregion
    }
}

// --- End of file: RaidNotes.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/recycler-speed ---
// --- Original File Path: R/RecyclerSpeed/RecyclerSpeed.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins {

	[Info("Recycler Speed", "Ryz0r/yetzt", "2.0.2")]
	[Description("Easily set the speed at which the recycler... recycles")]

	public class RecyclerSpeed : RustPlugin {

		private const string UsePerm = "recyclerspeed.use";

		#region Config
		private Configuration _config;
		protected override void SaveConfig() => Config.WriteObject(_config);
		protected override void LoadDefaultConfig() => _config = new Configuration();

		private class Configuration {
			[JsonProperty(PropertyName = "Recyler Speed (Lower = Faster) (Seconds)")]
			public float RecyclerSpeed = 5.0f;
		}

		protected override void LoadConfig() {
			base.LoadConfig();
			try
			{
				_config = Config.ReadObject<Configuration>();
				if (_config == null) throw new Exception();

				Convert.ToSingle(_config.RecyclerSpeed);
				SaveConfig();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
			}
		}
		#endregion

		private void Init() {
			permission.RegisterPermission(UsePerm, this);
		}

		private void OnRecyclerToggle(Recycler recycler, BasePlayer player) {
			if (recycler.IsOn()) return;
			if (!permission.UserHasPermission(player.userID.ToString(), UsePerm)) return;

			recycler.CancelInvoke(nameof(recycler.RecycleThink));
			timer.Once(0.1f, () => recycler.InvokeRepeating(recycler.RecycleThink, _config.RecyclerSpeed - 0.1f, _config.RecyclerSpeed));
		}
	}
}

// --- End of file: RecyclerSpeed.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rust-lax ---
// --- Original File Path: R/RustLax/RustLax.cs ---

using System.Linq;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Rust Lax", "Colon Blow", "1.0.3")]
    [Description("Control when Horses drop dung in minutes")]

    public class RustLax : CovalencePlugin
    {

        #region Load

        private const string permAdmin = "rustlax.admin";
        private const string permMounted = "rustlax.mounted";

        private void Init()
        {
            permission.RegisterPermission(permAdmin, this);
            permission.RegisterPermission(permMounted, this);
            config = Config.ReadObject<PluginConfig>();
        }

        private void OnServerInitialized()
        {
            ProcessExistingAnimals(config.dungTimeGlobal);
        }

        #endregion

        #region Configuration

        private PluginConfig config;

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Dung Time - Number of Minutes between dung drops : ")] public float dungTimeGlobal { get; set; }
            [JsonProperty(PropertyName = "Dung Time Mounted - Mounted players with rustlax.mounted perms, will change dung drop time to (Minutes) : ")] public float dungTimeMounted { get; set; }
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                dungTimeGlobal = 15f,
                dungTimeMounted = 1f
            };
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private void SaveConfig()
        {
            Config.WriteObject(config, true);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["notallowed"] = "You are not authorized to do that.",
                ["resettxt"] = "All dung droppings have been reset to Rust Defualts"
            }, this);
        }

        #endregion

        #region Commands

        [Command("rustlax.reset")]
        private void cmdRustLaxReset(IPlayer player, string command, string[] args)
        {
            if (player.HasPermission(permAdmin))
            {
                ProcessExistingAnimals(600f);
                player.Message(lang.GetMessage("resettxt", this, player.Id));
                return;
            }
            player.Message(lang.GetMessage("notallowed", this, player.Id));
        }

        #endregion

        #region Hooks

        private void OnEntitySpawned(BaseRidableAnimal animal)
        {
            ProcessAnimal(animal, config.dungTimeGlobal);
        }

        private void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            var animal = entity.GetComponentInParent<BaseRidableAnimal>() ?? null;
            if (animal != null && permission.UserHasPermission(player.UserIDString, permMounted)) ProcessAnimal(animal, config.dungTimeMounted);
        }

        private void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            var animal = entity.GetComponentInParent<BaseRidableAnimal>() ?? null;
            if (animal != null && permission.UserHasPermission(player.UserIDString, permMounted)) ProcessAnimal(animal, config.dungTimeGlobal);
        }

        private void ProcessExistingAnimals(float dungAdjustment)
        {
            var animalList = BaseNetworkable.serverEntities.OfType<BaseRidableAnimal>();
            foreach (var ridableAnimal in animalList)
            {
                ProcessAnimal(ridableAnimal, dungAdjustment);
            }
        }

        private void ProcessAnimal(BaseRidableAnimal animal, float dungAdjustment)
        {
            animal.DungProducedPerCalorie = (0.6f / dungAdjustment);
        }

        #endregion
    }
}


// --- End of file: RustLax.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/repair-delay-modifier ---
// --- Original File Path: R/RepairDelayModifier/RepairDelayModifier.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Repair Delay Modifier", "Ryz0r", "1.0.1")]
    [Description("Takes away the repair delay, or increases/decreases it for players with permission.")]
    public class RepairDelayModifier : RustPlugin
    {
        private Configuration _config;
        private const string NoDelayPerm = "norepairdelay.perm";
        private const string TimeDelayPerm = "norepairdelay.timed";

        private class Configuration
        {
            [JsonProperty(PropertyName = "RepairTime")]
            public float RepairTime = 20f;
        }
    		
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }
		
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["RepairInstant"] = "Congratulations, your structure has been instantly repaired.",
                ["RepairTimed"] = "You have been upgraded before the 30 second timer.",
                ["RepairTimedWait"] = "It has only been {0} seconds since damage, and you must wait {1} seconds."
            }, this);
        }
		
        protected override void LoadDefaultConfig()
        {
            PrintWarning("A new configuration file is being generated.");
            _config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);    

        private void Init()
        {
            permission.RegisterPermission(TimeDelayPerm, this);
            permission.RegisterPermission(NoDelayPerm, this);
        }
        private object OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, NoDelayPerm) && 
                entity.SecondsSinceAttacked >= 0)
            {
                player.ChatMessage(lang.GetMessage("RepairInstant", this, player.UserIDString));
                entity.lastAttackedTime = float.MinValue;
                return null;
            }
            else if(permission.UserHasPermission(player.UserIDString, TimeDelayPerm) && 
                    entity.SecondsSinceAttacked >= _config.RepairTime)
            {
                player.ChatMessage(lang.GetMessage("RepairTimed", this, player.UserIDString));
                entity.lastAttackedTime = float.MinValue;
                return null;
            }
            else if (permission.UserHasPermission(player.UserIDString, TimeDelayPerm) &&
                     entity.SecondsSinceAttacked <= _config.RepairTime)
            {
                player.ChatMessage(string.Format(lang.GetMessage("RepairTimedWait", this, player.UserIDString), entity.SecondsSinceAttacked, _config.RepairTime));
                return true;
            }
            
            return null;
        }
    }
}

// --- End of file: RepairDelayModifier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/random-gather ---
// --- Original File Path: R/RandomGatherPremium/RandomGatherPremium.cs ---

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Random = System.Random;
namespace Oxide.Plugins
{
    [Info("Random Gather Premium", "Kaysharp", "1.0.8")]
    [Description("Get random items on gathering resources, quarry gather, Excavator gather and loot containers")]
    class RandomGatherPremium : CovalencePlugin
    {
        private readonly Random _random = new Random();
        public static ConfigData config { get; set; }
        public List<string> ContainterBlacklist = new List<string>
        {
            "crate_tools",
            "crate_mine",
            "crate_normal_2_food",
            "crate_normal_2_medical",
            "crate_ammunition",
            "crate_food_1",
            "crate_food_2",
            "crate_fuel",
            "crate_medical",
            "heli_crate",
            "survey_crater",
            "survey_crater_oil"
        };
        private void Init()
        {
            if (!config.OnCollectiblePickup)
                Unsubscribe(nameof(OnCollectiblePickup));

            if (!config.isOnDispenserBonus)
                Unsubscribe(nameof(OnDispenserBonus));

            if (!config.isOnDispenserGather)
                Unsubscribe(nameof(OnDispenserGather));

            if(!config.isOnQuarryGather)
                Unsubscribe(nameof(OnQuarryGather));

            if (!config.isOnLootEntity)
                Unsubscribe(nameof(OnLootSpawn));

            if (!config.isOnExcavatorGather)
                Unsubscribe(nameof(OnExcavatorGather));

            if (!config.isOnEntityDeath)
                Unsubscribe(nameof(OnEntityDeath));

            if (!config.isOnSupplyDropDropped)
                Unsubscribe(nameof(OnSupplyDropDropped));
            if (!config.isOnCorpsePopulate)
                Unsubscribe(nameof(OnCorpsePopulate));
        }
        private void OnServerInitialized()
        {
            if (config.isOnLootEntity)
                RepopulateContainers();
        }
        private ItemDefinition FindItem(string itemNameOrId)
        {
            ItemDefinition itemDef = ItemManager.FindItemDefinition(itemNameOrId.ToLower());
            if (itemDef == null)
            {
                int itemId;
                if (int.TryParse(itemNameOrId, out itemId))
                {
                    itemDef = ItemManager.FindItemDefinition(itemId);
                }
            }
            return itemDef;
        }
        #region Oxide Hooks
        private void Unload()
        {
            config = null;
        }
        private void RepopulateContainers()
        {
            foreach (var container in BaseNetworkable.serverEntities.OfType<LootContainer>())
            {
                if (container == null || !container.ShortPrefabName.Contains("crate") || ContainterBlacklist.Contains(container.ShortPrefabName)) return;
                int Slots = 0;
                foreach (var LootSpawnSlot in container.LootSpawnSlots)
                {
                    Slots += LootSpawnSlot.numberToSpawn;
                }
                container.inventory.itemList.Clear();
                for (int i = 0; i < Slots; i++)
                {
                    var index = _random.Next(0, config.Items.Count());
                    if (ItemManager.itemDictionaryByName.ContainsKey(config.Items[index]))
                    {
                        var randomItem = ItemManager.itemDictionaryByName[config.Items[index]];
                        if (randomItem != null)
                        {
                            int amount;
                            if (!config.Amount.TryGetValue(config.Items[index], out amount))
                            {
                                amount = 1;
                            }
                            container.inventory.AddItem(randomItem, amount);
                        }
                    }
                }
            }
        }
        BaseCorpse OnCorpsePopulate(BasePlayer npcPlayer, BaseCorpse corpse)
        {
            var npcplayerCorpse = corpse.GetComponent<NPCPlayerCorpse>();
            var humanNPC = npcPlayer as HumanNPC;
            foreach (global::LootContainer.LootSpawnSlot lootSpawnSlot in humanNPC.LootSpawnSlots)
            {
                for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
                {
                    var index = _random.Next(0, config.Items.Count());
                    if (ItemManager.itemDictionaryByName.ContainsKey(config.Items[index]))
                    {
                        var randomItem = ItemManager.itemDictionaryByName[config.Items[index]];
                        if (randomItem != null)
                        {
                            int amount;
                            if (!config.Amount.TryGetValue(config.Items[index], out amount))
                            {
                                amount = 1;
                            }
                            npcplayerCorpse.containers[0].AddItem(randomItem, amount);
                        }
                    }
                }
            }
            return corpse;
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            var container = entity as LootContainer;
            if (container == null || info == null || !container.ShortPrefabName.Contains("barrel")) return;
            
            var items = Facepunch.Pool.GetList<Item>();
            for (int i = 0; i < config.NumbOfItemsInBarrels; i++)
            {
                var index = _random.Next(0, config.Items.Count());
                var itemName = config.Items[index];
                var item = ItemManager.Create(FindItem(itemName));
                if (item != null)
                {
                    int amount = 1;
                    if (config.Amount.TryGetValue(itemName, out amount))
                    {
                        item.amount = amount;
                    }
                    item.Drop(entity.GetDropPosition() + UnityEngine.Vector3.up, entity.GetDropVelocity());
                }
            }
            container.inventory.itemList.Clear();
            Facepunch.Pool.FreeList(ref items);
        }
        object OnExcavatorGather(ExcavatorArm excavator, Item item)
        {
            var index = _random.Next(0, config.Items.Count());
            var itemName = config.Items[index];
            
            foreach (ExcavatorOutputPile excavatorOutputPile in excavator.outputPiles)
            {
                item = ItemManager.Create(FindItem(itemName));
                if (item != null)
                {
                    int amount;
                    if (config.Amount.TryGetValue(itemName, out amount))
                    {
                        item.amount = amount;
                    }
                    if (!item.MoveToContainer(excavatorOutputPile.inventory, -1, true, false))
                    {
                        item.Drop(excavatorOutputPile.GetDropPosition(), excavatorOutputPile.GetDropVelocity(), default(Quaternion));
                    }
                }
            }
            return true;
        }
        object OnQuarryGather(MiningQuarry quarry, Item item)
        {
            var index = _random.Next(0, config.Items.Count());
            var itemName = config.Items[index];
            item = ItemManager.Create(FindItem(itemName));
            if (item != null)
            {
                int amount;
                if (config.Amount.TryGetValue(itemName, out amount))
                {
                    item.amount = amount;
                }
            }
            if (!item.MoveToContainer(quarry.hopperPrefab.instance.GetComponent<global::StorageContainer>().inventory, -1, true, false))
            {
                item.Remove(0f);
                quarry.SetOn(false);
            }
            return true;
        }
        private object OnLootSpawn(LootContainer container)
        {
            if (container == null || !container.ShortPrefabName.Contains("crate") || ContainterBlacklist.Contains(container.ShortPrefabName)) return null;
            int Slots = 0;
            foreach (var LootSpawnSlot in container.LootSpawnSlots)
            {
                Slots += LootSpawnSlot.numberToSpawn;
            }
            container.inventory.itemList.Clear();
            for (int i = 0; i < Slots; i++)
            {
                var index = _random.Next(0, config.Items.Count());
                if (ItemManager.itemDictionaryByName.ContainsKey(config.Items[index]))
                {
                    var randomItem = ItemManager.itemDictionaryByName[config.Items[index]];
                    if (randomItem != null)
                    {
                        int amount;
                        if (!config.Amount.TryGetValue(config.Items[index], out amount))
                        {
                            amount = 1;
                        }
                        container.inventory.AddItem(randomItem, amount);
                    }
                }
            }
            return container;
        }
        void OnSupplyDropDropped(SupplyDrop SupplyDrop, CargoPlane plane)
        {
            var container = SupplyDrop as LootContainer;
            if (container != null)
            {
                int Slots = 0;
                foreach (var LootSpawnSlot in container.LootSpawnSlots)
                {
                    Slots += LootSpawnSlot.numberToSpawn;
                }
                container.inventory.itemList.Clear();
                for (int i = 0; i < Slots; i++)
                {
                    var index = _random.Next(0, config.Items.Count());
                    if (ItemManager.itemDictionaryByName.ContainsKey(config.Items[index]))
                    {
                        var randomItem = ItemManager.itemDictionaryByName[config.Items[index]];
                        if (randomItem != null)
                        {
                            int amount;
                            if (!config.Amount.TryGetValue(config.Items[index], out amount))
                            {
                                amount = 1;
                            }
                            container.inventory.AddItem(randomItem, amount);
                        }
                    }
                }
            }
        }
        object OnCollectiblePickup(CollectibleEntity entity, BasePlayer player)
        {
            foreach (var itemPicked in entity.itemList)
            {
                var item = ItemManager.Create(itemPicked.itemDef, (int)itemPicked.amount, 0UL);
                if (item.info.displayName.english.ToLower().Contains("seed"))
                    return null;
                var InitItem = item;
                var index = _random.Next(0, config.Items.Count());
                var itemName = config.Items[index];
                item = ItemManager.Create(FindItem(itemName));
                if (item != null)
                {
                    int amount;
                    if (config.Amount.TryGetValue(itemName, out amount))
                    {
                        item.amount = amount;
                    }
                    try
                    {
                        player.GiveItem(item);
                    }
                    catch (Exception E)
                    {
                        item.Drop(player.GetDropPosition(), player.GetDropVelocity());
                    }
                    try
                    {
                        player.GiveItem(InitItem, global::BaseEntity.GiveItemReason.ResourceHarvested);
                    }
                    catch
                    {
                        InitItem.Drop(player.GetDropPosition(), player.GetDropVelocity());
                    }
                    if (entity.pickupEffect.isValid)
                    {
                        Effect.server.Run(entity.pickupEffect.resourcePath, entity.transform.position, entity.transform.up, null, false);
                    }
                    RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(entity.prefabID);
                    if (randomItemDispenser != null)
                    {
                        randomItemDispenser.DistributeItems(player, entity.transform.position);
                    }
                    entity.Kill(global::BaseNetworkable.DestroyMode.None);
                    return true;
                }
            }

            return null;
        }
        object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            var index = _random.Next(0, config.Items.Count());
            var itemName = config.Items[index];
            item = ItemManager.Create(FindItem(itemName));
            if (item != null)
            {
                int amount;
                if (config.Amount.TryGetValue(itemName, out amount))
                {
                    item.amount = amount;
                }
                return item;
            }
            return null;
        }
        object OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            var index = _random.Next(0, config.Items.Count());
            var itemName = config.Items[index];
            item = ItemManager.Create(FindItem(itemName));

            bool hasActiveModifier = false;
            float Value = 0f;
            string GatherType = dispenser.gatherType.ToString();
            if (player.modifiers.ActiveModifierCoount > 0 && config.isBoost)
            {
                var Modifiers = Facepunch.Pool.GetList<Modifier>();
                Modifiers = player.modifiers.All;
                if (GatherType.Contains("Tree"))
                    GatherType = "Wood";
                foreach (var Modifier in Modifiers)
                {
                    if (Modifier.Type.ToString().Contains(GatherType))
                    {
                        hasActiveModifier = true;
                        Value = 1 + Modifier.Value;
                        break;
                    }
                }
            }
               
            if (item != null)
            {
                int amount;
                if (config.Amount.TryGetValue(itemName, out amount))
                {
                    if (Value > 0 && hasActiveModifier && config.isBoost)
                        item.amount = (int)(amount * Value);
                    else
                        item.amount = amount;
                }
                else
                {
                    if (hasActiveModifier && config.isBoost)
                        item.amount = (int)(item.amount * Value);
                }
                    
                try
                {
                    player.GiveItem(item);
                }
                catch
                {
                    item.Drop(player.GetDropPosition(), player.GetDropVelocity());
                }
                return true;
            }
            return null;
        }
        #endregion
        #region Config
        public class ConfigData
        {
            [JsonProperty(PropertyName = "Give bonuses if player have active boost")]
            public bool isBoost;

            [JsonProperty(PropertyName = "How many items should spawn when barrel is destroyed?")]
            public int NumbOfItemsInBarrels;

            [JsonProperty(PropertyName = "Give random items when barrel is destroyed")]
            public bool isOnEntityDeath { get; set; }

            [JsonProperty(PropertyName = "Give random items on gathering resources")]
            public bool isOnDispenserGather { get; set; }

            [JsonProperty(PropertyName = "Give random items only on full gather")]
            public bool isOnDispenserBonus { get; set; }

            [JsonProperty(PropertyName = "Give random item when collecting resources")]
            public bool OnCollectiblePickup { get; set; }

            [JsonProperty(PropertyName = "Give random items on quarry gather")]
            public bool isOnQuarryGather { get; set; }

            [JsonProperty(PropertyName = "Give random items on Excavator gather")]
            public bool isOnExcavatorGather { get; set; }

            [JsonProperty(PropertyName = "Fill loot containers with random items")]
            public bool isOnLootEntity { get; set; }

            [JsonProperty(PropertyName = "Fill airdrops with random items")]
            public bool isOnSupplyDropDropped { get; set; }

            [JsonProperty(PropertyName = "Populate NPC corps with random loot")]
            public bool isOnCorpsePopulate { get; set; }

            [JsonProperty(PropertyName = "Items")]
            public List<string> Items = new List<string>();

            [JsonProperty(PropertyName = "Amount")]
            public Dictionary<string, int> Amount = new Dictionary<string, int>();

        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null) throw new Exception();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }
        protected override void LoadDefaultConfig() => config = GetDefaultSettings();
        private ConfigData GetDefaultSettings()
        {
            return new ConfigData
            {
                isBoost = true,
                NumbOfItemsInBarrels = 2,
                isOnSupplyDropDropped = true,
                isOnEntityDeath = true,
                isOnExcavatorGather = true,
                isOnLootEntity = true,
                isOnQuarryGather = true,
                OnCollectiblePickup = true,
                isOnDispenserGather = true,
                isOnDispenserBonus = false,
                isOnCorpsePopulate = true,
                Items = new List<string>
                {
                    "ammo.grenadelauncher.buckshot",
                    "ammo.grenadelauncher.he",
                    "ammo.grenadelauncher.smoke",
                    "ammo.handmade.shell",
                    "ammo.nailgun.nails",
                    "ammo.pistol",
                    "ammo.pistol.fire",
                    "ammo.pistol.hv",
                    "ammo.rifle",
                    "ammo.rifle.explosive",
                    "ammo.rifle.hv",
                    "ammo.rifle.incendiary",
                    "ammo.rocket.basic",
                    "ammo.rocket.fire",
                    "ammo.rocket.hv",
                    "ammo.rocket.sam",
                    "ammo.rocket.smoke",
                    "ammo.shotgun",
                    "ammo.shotgun.fire",
                    "ammo.shotgun.slug",
                    "apple",
                    "arcade.machine.chippy",
                    "arrow.bone",
                    "arrow.fire",
                    "arrow.hv",
                    "arrow.wooden",
                    "attire.bunnyears",
                    "attire.hide.boots",
                    "attire.hide.helterneck",
                    "attire.hide.pants",
                    "attire.hide.poncho",
                    "attire.hide.skirt",
                    "attire.hide.vest",
                    "attire.ninja.suit",
                    "autoturret",
                    "axe.salvaged",
                    "barricade.concrete",
                    "barricade.metal",
                    "barricade.sandbags",
                    "barricade.stone",
                    "barricade.wood.cover",
                    "battery.small",
                    "bbq",
                    "bed",
                    "black.berry",
                    "black.raspberries",
                    "blue.berry",
                    "blueberries",
                    "bone.armor.suit",
                    "boots.frog",
                    "bow.compound",
                    "bow.hunting",
                    "box.repair.bench",
                    "box.wooden",
                    "box.wooden.large",
                    "bucket.helmet",
                    "building.planner",
                    "burlap.gloves",
                    "burlap.gloves.new",
                    "burlap.headwrap",
                    "burlap.shirt",
                    "burlap.shoes",
                    "burlap.trousers",
                    "can.beans",
                    "can.tuna",
                    "cctv.camera",
                    "ceilinglight",
                    "chainsaw",
                    "chocholate",
                    "clatter.helmet",
                    "coffeecan.helmet",
                    "coffin.storage",
                    "computerstation",
                    "corn",
                    "crossbow",
                    "crude.oil",
                    "cupboard.tool",
                    "cursedcauldron",
                    "diving.fins",
                    "diving.mask",
                    "diving.tank",
                    "diving.wetsuit",
                    "door.double.hinged.metal",
                    "door.double.hinged.toptier",
                    "door.double.hinged.wood",
                    "door.hinged.industrial.a",
                    "door.hinged.metal",
                    "door.hinged.toptier",
                    "door.hinged.wood",
                    "dropbox",
                    "explosive.satchel",
                    "explosive.timed",
                    "explosives",
                    "flamethrower",
                    "flameturret",
                    "flashlight.held",
                    "floor.grill",
                    "floor.ladder.hatch",
                    "floor.triangle.grill",
                    "floor.triangle.ladder.hatch",
                    "fridge",
                    "furnace",
                    "furnace.large",
                    "fuse",
                    "gates.external.high.stone",
                    "gates.external.high.wood",
                    "gears",
                    "generator.wind.scrap",
                    "grenade.beancan",
                    "grenade.f1",
                    "grenade.smoke",
                    "guntrap",
                    "habrepair",
                    "hammer.salvaged",
                    "hat.beenie",
                    "hat.boonie",
                    "hat.cap",
                    "hat.ratmask",
                    "hat.wolf",
                    "hatchet",
                    "hazmatsuit",
                    "hazmatsuit.spacesuit",
                    "healingtea",
                    "healingtea.advanced",
                    "healingtea.pure",
                    "heavy.plate.helmet",
                    "heavy.plate.jacket",
                    "heavy.plate.pants",
                    "hitchtroughcombo",
                    "hobobarrel",
                    "hoodie",
                    "horse.armor.roadsign",
                    "horse.armor.wood",
                    "horse.saddle",
                    "horse.saddlebag",
                    "horse.shoes.advanced",
                    "horse.shoes.basic",
                    "icepick.salvaged",
                    "innertube",
                    "innertube.horse",
                    "innertube.unicorn",
                    "jacket",
                    "jacket.snow",
                    "jackhammer",
                    "jackolantern.angry",
                    "jackolantern.happy",
                    "jar.pickle",
                    "ammo.grenadelauncher.buckshot",
                    "ammo.grenadelauncher.he",
                    "ammo.grenadelauncher.smoke",
                    "ammo.handmade.shell",
                    "ammo.nailgun.nails",
                    "ammo.pistol",
                    "ammo.pistol.fire",
                    "ammo.pistol.hv",
                    "ammo.rifle",
                    "ammo.rifle.explosive",
                    "ammo.rifle.hv",
                    "ammo.rifle.incendiary",
                    "ammo.rocket.basic",
                    "ammo.rocket.fire",
                    "ammo.rocket.hv",
                    "ammo.rocket.sam",
                    "ammo.rocket.smoke",
                    "ammo.shotgun",
                    "ammo.shotgun.fire",
                    "ammo.shotgun.slug",
                    "jumpsuit.suit",
                    "jumpsuit.suit.blue",
                    "kayak",
                    "keycard_blue",
                    "keycard_green",
                    "keycard_red",
                    "knife.bone",
                    "knife.butcher",
                    "knife.combat",
                    "ladder.wooden.wall",
                    "lantern",
                    "largecandles",
                    "largemedkit",
                    "laserlight",
                    "lmg.m249",
                    "locker",
                    "longsword",
                    "lowgradefuel",
                    "mace",
                    "machete",
                    "mask.balaclava",
                    "mask.bandana",
                    "maxhealthtea",
                    "maxhealthtea.advanced",
                    "maxhealthtea.pure",
                    "metal.facemask",
                    "metal.fragments",
                    "metal.plate.torso",
                    "metal.refined",
                    "metalblade",
                    "metalpipe",
                    "metalspring",
                    "microphonestand",
                    "minihelicopter.repair",
                    "mining.quarry",
                    "mixingtable",
                    "multiplegrenadelauncher",
                    "mushroom",
                    "nightvisiongoggles",
                    "oretea",
                    "oretea.advanced",
                    "oretea.pure",
                    "paddle",
                    "paddlingpool",
                    "pants",
                    "pants.shorts",
                    "paper",
                    "partyhat",
                    "pickaxe",
                    "pistol.eoka",
                    "pistol.m92",
                    "pistol.nailgun",
                    "pistol.python",
                    "pistol.revolver",
                    "pistol.semiauto",
                    "pitchfork",
                    "planter.large",
                    "planter.small",
                    "plantfiber",
                    "pookie.bear",
                    "potato",
                    "powered.water.purifier",
                    "propanetank",
                    "pumpkin",
                    "pumpkinbasket",
                    "radiationremovetea",
                    "radiationremovetea.advanced",
                    "radiationremovetea.pure",
                    "radiationresisttea",
                    "radiationresisttea.advanced",
                    "radiationresisttea.pure",
                    "red.berry",
                    "research.table",
                    "rf.detonator",
                    "rf_pager",
                    "rifle.ak",
                    "rifle.bolt",
                    "rifle.l96",
                    "rifle.lr300",
                    "rifle.m39",
                    "rifle.semiauto",
                    "riflebody",
                    "riot.helmet",
                    "roadsign.gloves",
                    "roadsign.jacket",
                    "roadsign.kilt",
                    "roadsigns",
                    "rocket.launcher",
                    "rope",
                    "rug",
                    "rug.bear",
                    "salvaged.cleaver",
                    "salvaged.sword",
                    "samsite",
                    "scraptea",
                    "scraptea.advanced",
                    "scraptea.pure",
                    "scraptransportheli.repair",
                    "searchlight",
                    "secretlabchair",
                    "semibody",
                    "sewingkit",
                    "sheetmetal",
                    "shelves",
                    "ammo.grenadelauncher.buckshot",
                    "ammo.grenadelauncher.he",
                    "ammo.grenadelauncher.smoke",
                    "ammo.handmade.shell",
                    "ammo.nailgun.nails",
                    "ammo.pistol",
                    "ammo.pistol.fire",
                    "ammo.pistol.hv",
                    "ammo.rifle",
                    "ammo.rifle.explosive",
                    "ammo.rifle.hv",
                    "ammo.rifle.incendiary",
                    "ammo.rocket.basic",
                    "ammo.rocket.fire",
                    "ammo.rocket.hv",
                    "ammo.rocket.sam",
                    "ammo.rocket.smoke",
                    "ammo.shotgun",
                    "ammo.shotgun.fire",
                    "ammo.shotgun.slug",
                    "shirt.collared",
                    "shirt.tanktop",
                    "shoes.boots",
                    "shotgun.double",
                    "shotgun.pump",
                    "shotgun.spas12",
                    "shotgun.waterpipe",
                    "shutter.metal.embrasure.a",
                    "shutter.metal.embrasure.b",
                    "shutter.wood.a",
                    "sickle",
                    "sleepingbag",
                    "small.oil.refinery",
                    "smg.2",
                    "smg.mp5",
                    "smg.thompson",
                    "smgbody",
                    "spear.stone",
                    "spear.wooden",
                    "speargun",
                    "speargun.spear",
                    "stone.pickaxe",
                    "stonehatchet",
                    "storage.monitor",
                    "strobelight",
                    "submarine.torpedo.rising",
                    "submarine.torpedo.straight",
                    "supply.signal",
                    "surveycharge",
                    "syringe.medical",
                    "table",
                    "tactical.gloves",
                    "targeting.computer",
                    "tarp",
                    "techparts",
                    "tool.instant_camera",
                    "vending.machine",
                    "wall.external.high",
                    "wall.external.high.ice",
                    "wall.external.high.stone",
                    "waterpump",
                    "weapon.mod.8x.scope",
                    "weapon.mod.flashlight",
                    "weapon.mod.holosight",
                    "weapon.mod.lasersight",
                    "weapon.mod.muzzleboost",
                    "weapon.mod.muzzlebrake",
                    "weapon.mod.silencer",
                    "weapon.mod.simplesight",
                    "weapon.mod.small.scope",
                    "white.berry",
                    "wood.armor.helmet",
                    "wood.armor.jacket",
                    "wood.armor.pants",
                    "woodtea",
                    "woodtea.advanced",
                    "workbench1",
                    "workbench2",
                    "workbench3"
                },
                Amount = new Dictionary<string, int>
                {
                    {"ammo.grenadelauncher.buckshot",10},
                    {"ammo.grenadelauncher.he",1},
                    {"ammo.grenadelauncher.smoke",1},
                    {"ammo.handmade.shell",15},
                    {"ammo.nailgun.nails",30},
                    {"ammo.pistol",30},
                    {"ammo.pistol.fire",10},
                    {"ammo.pistol.hv",10},
                    {"ammo.rifle",30},
                    {"ammo.rifle.explosive",10},
                    {"ammo.rifle.hv",15},
                    {"ammo.rifle.incendiary",15},
                    {"ammo.rocket.basic",1},
                    {"ammo.rocket.fire",1},
                    {"ammo.rocket.hv",1},
                    {"ammo.rocket.sam",5},
                    {"ammo.rocket.smoke",1},
                    {"ammo.shotgun",10},
                    {"ammo.shotgun.fire",10},
                    {"ammo.shotgun.slug",10}
                }
            };
        }

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion
    }
}

// --- End of file: RandomGatherPremium.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/recycle ---
// --- Original File Path: R/Recycle/Recycle.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using Oxide.Core;
using System;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("Recycle", "nivex", "3.1.7")]
    [Description("Recycle items into their resources")]
    public class Recycle : RustPlugin
    {
        private const string 
            RecyclePrefab = "assets/bundled/prefabs/static/recycler_static.prefab",
            BackpackPrefab = "assets/prefabs/misc/item drop/item_drop_backpack.prefab",
            AdminPermission = "recycle.admin",
            RecyclerPermission = "recycle.use",
            CooldownBypassPermission = "recycle.bypass";

        private readonly Dictionary<ulong, (DroppedItemContainer container, BasePlayer player)> _droppedContainers = new();
        private readonly Dictionary<ulong, (Recycler recycler, BasePlayer player)> _recyclers = new();
        private readonly Dictionary<string, long> _cooldowns = new();
        private ConfigData config;

        #region Hooks

        private void Loaded()
        {
            string recycleCommand = string.IsNullOrEmpty(config.Settings.RecycleCommand) ? "recycle" : config.Settings.RecycleCommand;
            AddCovalenceCommand(recycleCommand, "RecycleCommand");
            AddCovalenceCommand("purgerecyclers", "PurgeRecyclersCommand");
            AddCovalenceCommand("purgebags", "PurgeBagsCommand");
            permission.RegisterPermission(AdminPermission, this);
            permission.RegisterPermission(RecyclerPermission, this);
            permission.RegisterPermission(CooldownBypassPermission, this);
            if (!config.Settings.ToInventory) Unsubscribe(nameof(CanMoveItem));
        }

        private void Unload()
        {
            DestroyRecyclers();
            DestroyBags();
        }

        private void OnLootEntityEnd(BasePlayer player, Recycler recycler)
        {
            if (player != null) DestroyRecycler(player);
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (player == null) return;

            DestroyRecycler(player);

            if (_droppedContainers.Count == 0) return;

            var tmp = Pool.Get<List<KeyValuePair<ulong, (DroppedItemContainer, BasePlayer)>>>();

            tmp.AddRange(_droppedContainers);

            foreach (var (uid, (container, target)) in tmp)
            {
                if (!IsValid(container) || !IsValid(target) || target.userID == player.userID)
                {
                    if (IsValid(container))
                        container.Kill();

                    _droppedContainers.Remove(uid);
                }
            }

            Pool.FreeUnmanaged(ref tmp);
        }

        private object CanMoveItem(Item item, PlayerInventory inv, ItemContainerId targetContainerId, int targetSlot, int amount)
        {
            if (targetSlot < 6) return null;

            foreach (ItemContainer container in inv.loot.containers)
            {
                if (container.uid != targetContainerId || container.entityOwner == null) continue;

                if (container.entityOwner is Recycler recycler && IsRecycleBox(recycler)) return false;
            }

            return null;
        }

        private object CanAcceptItem(ItemContainer container, Item item, int targetPos)
        {
            if (container == null || !(container.entityOwner is Recycler recycler)) return null;

            if (!IsRecycleBox(recycler)) return null;

            BasePlayer player = PlayerFromRecycler(recycler.net.ID.Value);

            if (player == null) return null;

            if (targetPos < 6)
            {
                string type = Enum.GetName(typeof(ItemCategory), item.info.category);

                if (!config.Settings.RecyclableTypes.Contains(type) || config.Settings.Blacklist.Contains(item.info.shortname))
                {
                    Message(player, "Recycle", "Invalid");
                    return ItemContainer.CanAcceptResult.CannotAcceptRightNow;
                }
                else
                {
                    recycler.Invoke(() =>
                    {
                        if (recycler.IsOn()) return;

                        if (!recycler.HasRecyclable()) return;

                        float time = config.Settings.InstantRecycling ? 0.0625f : recycler.GetRecycleThinkDuration();

                        recycler.InvokeRepeating(recycler.RecycleThink, time, time);
                        recycler.SetFlag(BaseEntity.Flags.On, b: true);
                        recycler.SendNetworkUpdateImmediate();
                    }, 0.0625f);
                }
            }
            else if (config.Settings.ToInventory)
            {
                player.Invoke(() => player.inventory.GiveItem(item), 0f);
            }

            return null;
        }

        private object CanLootEntity(BasePlayer player, DroppedItemContainer container)
        {
            if (container.IsValid() && _droppedContainers.TryGetValue(container.net.ID.Value, out var t) && t.player.userID != player.userID) return true;
            return null;
        }

        private void OnEntityKill(DroppedItemContainer container)
        {
            if (container.IsValid()) _droppedContainers.Remove(container.net.ID.Value);
        }

        protected override void LoadDefaultMessages()
        {
            Func<string, string> youCannot = (thing) => "You cannot recycle while " + thing;

            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Recycle -> Reloaded", "Configuration file has been reloaded" },
                { "Recycle -> DestroyedAllBags", "All bags have been destroyed" },
                { "Recycle -> DestroyedAll", "All recyclers have been destroyed" },
                { "Recycle -> Dropped", "You left some items in the recycler!" },
                { "Recycle -> Invalid", "You cannot recycle that!" },
                { "Denied -> Npc Only", "You must use the recycler at specific npcs only" },
                { "Denied -> Permission", "You don't have permission to use that command" },
                { "Denied -> Privilege", "You cannot recycle within someone's building privilege" },
                { "Denied -> Swimming", youCannot("swimming") },
                { "Denied -> Falling", youCannot("falling") },
                { "Denied -> Mounted", youCannot("mounted") },
                { "Denied -> Wounded", youCannot("wounded") },
                { "Denied -> Irradiation", youCannot("irradiated") },
                { "Denied -> Ship", youCannot("on a ship") },
                { "Denied -> Elevator", youCannot("on an elevator") },
                { "Denied -> Balloon", youCannot("on a balloon") },
                { "Denied -> Safe Zone", youCannot("in a safe zone") },
                { "Denied -> Hook Denied", "You can't recycle right now" },
                { "Cooldown -> In", "You need to wait {0} before recycling" },
                { "Timings -> second", "second" },
                { "Timings -> seconds", "seconds" },
                { "Timings -> minute", "minute" },
                { "Timings -> minutes", "minutes" }
            }, this);
        }

        private void OnUseNPC(BasePlayer npc, BasePlayer player) // HumanNPC plugin support
        {
            if (npc == null || !config.Settings.NPCIds.Contains(npc.UserIDString)) return;
            OpenRecycler(player);
        }

        #endregion

        #region Commands

        private void RecycleCommand(IPlayer user, string command, string[] args)
        {
            if (CanManageRecyclers(user) && args.Contains("reloadconfig"))
            {
                LoadConfig();
                Message(user, "Recycle", "Reloaded");
            }

            if (config.Settings.NPCOnly)
                return;

            BasePlayer player = user.Object as BasePlayer;
            
            if (player == null || !CanPlayerOpenRecycler(player)) 
                return;

            OpenRecycler(player);

            if (config.Settings.Cooldown > 0 && !CanBypassCooldown(user)) 
                _cooldowns[player.UserIDString] = DateTimeOffset.Now.ToUnixTimeSeconds() + (long)(config.Settings.Cooldown * 60);
        }

        private void PurgeRecyclersCommand(IPlayer user, string command, string[] args)
        {
            if (CanManageRecyclers(user))
            {
                DestroyRecyclers();
                Message(user, "Recycle", "DestroyedAll");
            }
            else Message(user, "Denied", "Permission");
        }

        private void PurgeBagsCommand(IPlayer user, string command, string[] args)
        {
            if (CanManageRecyclers(user))
            {
                DestroyBags();
                Message(user, "Recycle", "DestroyedAllBags");
            }
            else Message(user, "Denied", "Permission");
        }

        private void Message(IPlayer user, string top, string bottom)
        {
            if (user.Object is BasePlayer player)
            {
                Message(player, top, bottom);
                return;
            }

            string message = GetMessage(top, bottom, user.Id);

            if (string.IsNullOrEmpty(message))
            {
                return; // set a message value to empty to disable that message
            }

            if (user.IsServer)
            {
                Puts(message);
            }
            else
            {
                user.Message(message);
            }
        }

        private void Message(BasePlayer player, string top, string bottom, params object[] args)
        {
            string message = GetMessage(top, bottom, player.UserIDString);
            if (string.IsNullOrEmpty(message)) return;
            PrintToChat(player, args.Length > 0 ? string.Format(message, args) : message);
        }

        public bool IsValid(BaseNetworkable e) => e.IsValid() && !e.IsDestroyed;

        #endregion

        #region Structs

        public class ConfigData
        {
            public class SettingsWrapper
            {
                [JsonProperty("Command To Open Recycler")]
                public string RecycleCommand = "recycle";

                [JsonProperty("Cooldown (in minutes)")]
                public float Cooldown = 5.0f;

                [JsonProperty("Maximum Radiation")] 
                public float RadiationMax = 1f;

                [JsonProperty("Refund Ratio")] 
                public float RefundRatio = 0.5f;

                [JsonProperty("NPCs Only")] 
                public bool NPCOnly;

                [JsonProperty("Allowed In Safe Zones")]
                public bool AllowedInSafeZones = true;

                [JsonProperty("Instant Recycling")] 
                public bool InstantRecycling = false;

                [JsonProperty("Send Recycled Items To Inventory")]
                public bool ToInventory = false;

                [JsonProperty("Send Items To Inventory Before Bag")]
                public bool InventoryBeforeBag = false;

                [JsonProperty("NPC Ids", ObjectCreationHandling = ObjectCreationHandling.Replace)] 
                public List<object> NPCIds = new();

                [JsonProperty("Recyclable Types", ObjectCreationHandling = ObjectCreationHandling.Replace)] 
                public List<object> RecyclableTypes = new();

                [JsonProperty("Blacklisted Items", ObjectCreationHandling = ObjectCreationHandling.Replace)] 
                public List<object> Blacklist = new();
            }

            public SettingsWrapper Settings = new();
            public string VERSION = "3.1.4";
        }

        #endregion

        #region Configuration

        protected override void LoadDefaultConfig()
        {
            config = new()
            {
                Settings =
                {
                    RecyclableTypes = new()
                    {
                        "Ammunition", "Attire", "Common", "Component", "Construction", "Electrical",
                        "Fun", "Items", "Medical", "Misc", "Tool", "Traps", "Weapon"
                    }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            canSaveConfig = false;
            try
            {
                config = Config.ReadObject<ConfigData>();
                config ??= new();
                config.Settings ??= new();
                config.Settings.NPCIds ??= new();
                canSaveConfig = true;
                SaveConfig();
            }
            catch (Exception ex)
            {
                Puts(ex.ToString());
                LoadDefaultConfig();
            }
        }

        private bool canSaveConfig = true;

        protected override void SaveConfig()
        {
            if (canSaveConfig)
            {
                config.VERSION = Version.ToString();
                Config.WriteObject(config, true);
            }
        }

        #endregion

        #region Helpers

        private Recycler CreateRecycler(BasePlayer player)
        {
            var recycler = GameManager.server.CreateEntity(RecyclePrefab, player.transform.position.WithY(-5f)) as Recycler;

            if (recycler == null) return null;

            recycler.enableSaving = false;
            recycler.Spawn();

            if (!IsValid(recycler)) return null;

            recycler.radtownRecycleEfficiency = config.Settings.RefundRatio;
            recycler.safezoneRecycleEfficiency = config.Settings.RefundRatio;
            recycler.SetFlag(BaseEntity.Flags.Locked, true);
            recycler.UpdateNetworkGroup();
            recycler.gameObject.layer = 0;
            recycler.SendNetworkUpdateImmediate(true);

            OpenContainer(player, recycler);

            _recyclers.Add(recycler.net.ID.Value, (recycler, player));

            return recycler;
        }

        private void OpenContainer(BasePlayer player, StorageContainer container)
        {
            player.Invoke(() =>
            {
                if (container == null || container.IsDestroyed) return;
                player.EndLooting();
                if (!player.inventory.loot.StartLootingEntity(container, false)) return;
                player.inventory.loot.AddContainer(container.inventory);
                player.inventory.loot.SendImmediate();
                player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), container.panelName);
                player.SendNetworkUpdate();
            }, 0.2f);
        }

        private void DropRecyclerContents(Recycler recycler, BasePlayer player)
        {
            if (player == null || player.inventory == null || player.inventory.containerMain == null || player.inventory.containerBelt == null) return;
            if (recycler == null || recycler.inventory == null || recycler.inventory.itemList.IsNullOrEmpty()) return;

            List<Item> items = Pool.Get<List<Item>>();

            items.AddRange(recycler.inventory.itemList);

            if (config.Settings.InventoryBeforeBag)
            {
                for (int i = 0; i < items.Count; i++)
                {
                    Item item = items[i];

                    if (player.inventory.GiveItem(item))
                    {
                        items.RemoveAt(i);
                        i--;
                    }
                }
            }

            if (items.Count == 0)
            {
                Pool.FreeUnmanaged(ref items);
                return;
            }

            Message(player, "Recycle", "Dropped");

            Pool.FreeUnmanaged(ref items);

            var container = GameManager.server.CreateEntity(BackpackPrefab, player.transform.position + Vector3.up) as DroppedItemContainer;

            if (container == null) return;

            container.enableSaving = false;
            container.lootPanelName = "generic_resizable";
            container.playerSteamID = player.userID;
            container.TakeFrom(new[] { recycler.inventory });
            container.Spawn();

            if (IsValid(container))
            {
                _droppedContainers[container.net.ID.Value] = (container, player);
            }
        }

        private void DestroyRecycler(BasePlayer player)
        {
            Recycler recycler = RecyclerFromPlayer(player.userID);

            if (IsValid(recycler) && _recyclers.TryGetValue(recycler.net.ID.Value, out var t))
            {
                DropRecyclerContents(recycler, t.player);
                _recyclers.Remove(recycler.net.ID.Value);
                recycler.Kill();
            }
        }

        private void DestroyRecyclers()
        {
            if (_recyclers.Count == 0) return;
            var tmp = Pool.Get<List<KeyValuePair<ulong, (Recycler, BasePlayer)>>>();
            tmp.AddRange(_recyclers);
            foreach (var (uid, (recycler, player)) in tmp)
            {
                if (IsValid(recycler))
                {
                    DropRecyclerContents(recycler, player);
                    recycler.Kill();
                }
                _recyclers.Remove(uid);
            }
            Pool.FreeUnmanaged(ref tmp);
        }

        private void DestroyBags()
        {
            if (_droppedContainers.Count == 0) return;
            var tmp = Pool.Get<List<KeyValuePair<ulong, (DroppedItemContainer, BasePlayer)>>>();
            tmp.AddRange(_droppedContainers);
            foreach (var (uid, (container, _)) in tmp)
            {
                if (IsValid(container))
                {
                    container.Kill();
                }
                _droppedContainers.Remove(uid);
            }
            Pool.FreeUnmanaged(ref tmp);
        }

        private string GetMessage(string top, string bottom, string userid)
        {
            return lang.GetMessage(top + " -> " + bottom, this, userid);
        }

        private int[] GetCooldown(string userid)
        {
            if (!_cooldowns.TryGetValue(userid, out var time)) return Array.Empty<int>();

            time += (long)config.Settings.Cooldown * 60;

            long now = DateTimeOffset.Now.ToUnixTimeSeconds();

            if (now > time) return Array.Empty<int>();

            TimeSpan diff = TimeSpan.FromSeconds(time - DateTimeOffset.Now.ToUnixTimeSeconds());

            return new int[] { diff.Minutes, diff.Seconds };
        }

        private string CooldownTimesToString(int[] times, BasePlayer player)
        {
            if (times == null || times.Length != 2) return string.Empty;

            int mins = times[0], secs = times[1];

            return (string.Format(
                mins == 0 ? string.Empty : ("{0} " + GetMessage("Timings", mins == 1 ? "minute" : "minutes", player.UserIDString)), mins) +
                string.Format(" {0} " + GetMessage("Timings", secs == 1 ? "second" : "seconds", player.UserIDString), secs)
            ).Trim();
        }

        #endregion

        #region API

        private BasePlayer PlayerFromRecycler(ulong netID) => _recyclers.TryGetValue(netID, out var t) ? t.player : null;

        private Recycler RecyclerFromPlayer(ulong userid)
        {
            foreach (var (recycler, player) in _recyclers.Values)
                if (player?.userID == userid)
                    return recycler;
            return null;
        }

        private bool IsOnCooldown(IPlayer user) => config.Settings.Cooldown > 0 && !CanBypassCooldown(user) && _cooldowns.ContainsKey(user.Id) && DateTimeOffset.Now.ToUnixTimeSeconds() < _cooldowns[user.Id];

        private bool CanUseRecycler(IPlayer user) => user.HasPermission(RecyclerPermission);

        private bool CanManageRecyclers(IPlayer user) => user.HasPermission(AdminPermission);

        private bool CanBypassCooldown(IPlayer user) => user.HasPermission(CooldownBypassPermission);

        private bool IsRecycleBox(BaseNetworkable e) => IsValid(e) && _recyclers.ContainsKey(e.net.ID.Value);

        private bool CanPlayerOpenRecycler(BasePlayer player)
        {
            if (player == null || !(player.IPlayer is IPlayer user) || !player.IsAlive())
                Message(player, "Denied", "Hook Denied");
            else if (!CanUseRecycler(user) && !CanManageRecyclers(user))
                Message(player, "Denied", "Permission");
            else if (IsOnCooldown(user))
                Message(player, "Cooldown", "In", CooldownTimesToString(GetCooldown(player.UserIDString), player));
            else if (player.IsWounded())
                Message(player, "Denied", "Wounded");
            else if (!player.CanBuild())
                Message(player, "Denied", "Privilege");
            else if (config.Settings.RadiationMax > 0 && player.radiationLevel > config.Settings.RadiationMax)
                Message(player, "Denied", "Irradiation");
            else if (player.IsSwimming())
                Message(player, "Denied", "Swimming");
            else if (!player.IsOnGround() || player.IsFlying || player.isInAir)
                Message(player, "Denied", "Falling");
            else if (player.isMounted || player.GetParentEntity() is BaseMountable)
                Message(player, "Denied", "Mounted");
            else if (player.GetComponentInParent<CargoShip>())
                Message(player, "Denied", "Ship");
            else if (player.GetComponentInParent<HotAirBalloon>())
                Message(player, "Denied", "Balloon");
            else if (player.GetComponentInParent<Lift>())
                Message(player, "Denied", "Elevator");
            else if (!config.Settings.AllowedInSafeZones && player.InSafeZone())
                Message(player, "Denied", "Safe Zone");
            else if (Interface.Call("CanOpenRecycler", player) is object obj && obj != null && (obj is not bool val || !val))
                Message(player, "Denied", obj is string str && str.Length > 0 ? str : "Hook Denied");
            else
                return true;

            return false;
        }

        private void OpenRecycler(BasePlayer player)
        {
            if (player == null) 
                return;

            DestroyRecycler(player);
            CreateRecycler(player);
        }

        private void AddNpc(string id)
        {
            if (config.Settings.NPCIds.Contains(id)) 
                return;

            config.Settings.NPCIds.Add(id);
            SaveConfig();
        }

        private void RemoveNpc(string id)
        {
            if (config.Settings.NPCIds.Remove(id)) 
                SaveConfig();
        }

        #endregion
    }
}

// --- End of file: Recycle.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rotating-death-bags ---
// --- Original File Path: R/RotatingDeathBags/RotatingDeathBags.cs ---

﻿using Rust;
using Oxide.Core;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("RotatingDeathBags", "k1lly0u", "0.1.0", ResourceId = 0)]
    class RotatingDeathBags : RustPlugin
    {
        #region Fields
        static RotatingDeathBags instance;
        static int[] layerTypes = new int[] { 4, 8, 16, 21, 23, 25, 26 };

        private bool initialized;
        #endregion

        #region Oxide Hooks       
        void OnServerInitialized()
        {
            instance = this;
            LoadVariables();
            initialized = true;
        }
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (initialized)
            {
                if (entity.GetComponent<DroppedItemContainer>())
                {
                    NextTick(() =>
                    {
                        if (entity != null)
                            entity.gameObject.AddComponent<BagRotator>();
                    });
                }
            }
        }
        void Unload()
        {
            var objects = UnityEngine.Object.FindObjectsOfType<BagRotator>();
            if (objects != null)
            {
                foreach (var obj in objects)
                    UnityEngine.Object.Destroy(obj);
            }
            instance = null;
        }
        #endregion

        #region Item Rotator           
        class BagRotator : MonoBehaviour
        {
            private DroppedItemContainer entity;
            private Rigidbody rigidBody;
            private bool hasBegun;

            private float secsToTake;
            void Awake()
            {
                entity = GetComponent<DroppedItemContainer>();
                enabled = false;
            }
            void OnDestroy()
            {
                CancelInvoke();
                if (entity == null) return;
                if (rigidBody != null)
                {
                    rigidBody.useGravity = true;
                    rigidBody.isKinematic = false;
                }
            }
            void FixedUpdate()
            {
                entity.transform.RotateAround(entity.transform.position, Vector3.up, secsToTake);
                entity.transform.hasChanged = true;
            }
            void OnCollisionEnter(Collision collision)
            {
                if (hasBegun || collision.gameObject == null) return;

                if (layerTypes.Contains(collision.gameObject.layer) || collision.gameObject.name.Contains("junk_pile"))
                {
                    hasBegun = true;
                    Invoke("BeginRotation", instance.configData.RotateIn);
                }
            }
            private void BeginRotation()
            {
                gameObject.layer = (int)Layer.Reserved1;

                rigidBody = entity.GetComponent<Rigidbody>();
                rigidBody.useGravity = false;
                rigidBody.isKinematic = true;
                rigidBody.detectCollisions = true;
                rigidBody.collisionDetectionMode = CollisionDetectionMode.Discrete;

                secsToTake = instance.configData.Speed;

                entity.transform.position = entity.transform.position + Vector3.up;
                enabled = true;
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Rotation speed")]
            public float Speed { get; set; }
            [JsonProperty(PropertyName = "Seconds before initiating rotation")]
            public float RotateIn { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Speed = 5f,
                RotateIn = 3f
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}

// --- End of file: RotatingDeathBags.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/recycle-blueprints ---
// --- Original File Path: R/RecycleBlueprints/RecycleBlueprints.cs ---

﻿using Oxide.Core.Configuration;
using Rust;

namespace Oxide.Plugins
{
	[Info("Recycle Blueprints", "Zugzwang", "1.0.7")]
	[Description("Allows players to recycle blueprints for scrap.")]

	class RecycleBlueprints : CovalencePlugin
   {
		#region Configuration and Scrap Yields

		// Scrap ID
		int scrapID = -932201673; 
		
		// Default scrap yields.
		int defaultbp = 5;
		int common = 10;
		int uncommon = 25;		
		int rare = 100;
		int veryrare = 300;	

		// Save scrap yields if file doesnt exist.
		protected override void LoadDefaultConfig()
		{
			Config["Category_DefaultBP"] = defaultbp;
			Config["Category_Common"] = common;
			Config["Category_Uncommon"] = uncommon;
			Config["Category_Rare"] = rare;
			Config["Category_VeryRare"] = veryrare;
			
			PrintWarning("New configuration file created.");
		}
	
		// Load scrap yields on startup.
		void Init()
		{
			// Check for new 'DefaultBP' setting.
			if (Config["Category_DefaultBP"] == null)
			{
				Config["Category_DefaultBP"] = defaultbp;
				PrintWarning("Adding 'DefaultBP' setting to configuration.");
				SaveConfig();				
			}
				
			defaultbp = (int)Config["Category_DefaultBP"];
			common =		(int)Config["Category_Common"];
			uncommon =	(int)Config["Category_Uncommon"];
			rare = 		(int)Config["Category_Rare"];
			veryrare = 	(int)Config["Category_VeryRare"];
		}

		void OnServerInitialized()
		{
			// Look for scrap ID on load, just in case they change it again...
			ItemDefinition scrap = ItemManager.FindItemDefinition("scrap");
			if (scrap?.itemid != null)
				scrapID = scrap.itemid;

			bool changed = false;
			var bpList = ItemManager.bpList;
			
			// Look for new blueprints	
			foreach (ItemBlueprint bp in bpList)
			{
				//if (bp.defaultBlueprint || !(bp.isResearchable))
				if (!bp.isResearchable)
					continue;

				if (Config["Custom_" + bp.targetItem.shortname] == null)
				{
					Config["Custom_" + bp.targetItem.shortname] = -1;
					changed = true;
				}
			}
			
			// Add default blueprints.  (Necessary since addition of Industrial Crafter.)
			foreach (int id in ItemManager.defaultBlueprints)
			{
				ItemDefinition itemdef = ItemManager.FindItemDefinition(id);
				if (itemdef == null) continue;
				if (Config["Custom_" + itemdef.shortname] == null)
				{
					Config["Custom_" + itemdef.shortname] = -1;
					changed = true;
				}
			}
			
			if (changed)
			{				
				PrintWarning("Updating configuration file with new blueprints.");
				SaveConfig();				
			}
		}

		int ScrapValue(Item i)
		{
			int amount = 0;
			
			if (i?.IsBlueprint() == true)
			{
				ItemDefinition target = ItemManager.FindItemDefinition(i.blueprintTarget);
				if (target == null) return 0;
				
				int custom = 0;
				
				if (Config["Custom_" + target.shortname] != null)
				{
					custom = (int)Config["Custom_" + target.shortname];
				}
				
				// Set scrap amount based on custom setting, or rarity category.
				if (custom > -1)
					amount = custom;
				else if (ItemManager.FindBlueprint(i.blueprintTargetDef)?.defaultBlueprint == true)
					amount = defaultbp;
				else if (target?.rarity == null)
					amount = 1;
				else if (target.rarity == Rarity.Common || target.rarity == Rarity.None)
					amount = common;
				else if (target.rarity == Rarity.Uncommon)
					amount = uncommon;
				else if (target.rarity == Rarity.Rare)
					amount = rare;
				else if (target.rarity == Rarity.VeryRare)
					amount = veryrare;
			}

			return amount;
		}
		
		#endregion Configuration and Scrap Yields


		#region Oxide Hooks 

		// Allow recycling of enabled blueprint categories.
		object CanRecycle(Recycler recycler, Item item)
		{
			if (item?.IsBlueprint() == true && ScrapValue(item) > 0)	
			{
				return true;
			}
			
			return null;
		}

		// Allow blueprints to be put into the recycler.
		object CanBeRecycled(Item i, Recycler r)
		{
			return CanRecycle(r, i);
		}
		
		// Turn those blueprints into scrap.
		object OnItemRecycle(Item item, Recycler recycler)
		{
			if (item?.IsBlueprint() == true)
			{
				int amount = ScrapValue(item);

				if (amount > 0)
				{
					Item reward = ItemManager.CreateByItemID(scrapID, amount);
					if (reward != null)
					{
						recycler.MoveItemToOutput(reward);
						item.UseItem(1);
						return true;
					}
				}
			}

			return null;
		}
		
		#endregion Oxide Hooks 
	}
}


// --- End of file: RecycleBlueprints.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/remove-default-radiation ---
// --- Original File Path: R/RemoveDefaultRadiation/RemoveDefaultRadiation.cs ---

﻿using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("RemoveDefaultRadiation", "k1lly0u", "0.1.0", ResourceId = 0)]
    class RemoveDefaultRadiation : RustPlugin
    {        
        #region Oxide Hooks        
        void OnServerInitialized()
        {
            LoadVariables();
            var allobjects = UnityEngine.Object.FindObjectsOfType<TriggerRadiation>();
            for (int i = 0; i < allobjects.Length; i++)
            {
                UnityEngine.Object.Destroy(allobjects[i]);
            }
            if (configData.PluginList.Count > 0)
            {
                PrintWarning("All radiation elements destroyed, reloading plugins that use radiation");
                foreach (var plugin in configData.PluginList)
                {
                    if (plugins.Exists(plugin))
                    {
                        rust.RunServerCommand($"oxide.reload {plugin}");
                    }
                }
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public List<string> PluginList { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                PluginList = new List<string>
                {
                    "MonumentRadiation",
                    "RadPockets",
                    "ZoneManager"
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion       
    }
}

// --- End of file: RemoveDefaultRadiation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rocket-guns ---
// --- Original File Path: R/RocketGuns/RocketGuns.cs ---

﻿using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Rocket Guns", "Sapnu Puas #3696", "1.2.4")]
    [Description("Allow 556 guns to fire rockets based on ammo type")]
    public class RocketGuns : RustPlugin
    {
        List<ulong> ActiveGUNS = new List<ulong>();
        private const string PermUse = "rocketguns.use";
        #region[Rocket prefabs]
        public string Rocket = "assets/prefabs/ammo/rocket/rocket_basic.prefab";
        public string Hv = "assets/prefabs/ammo/rocket/rocket_hv.prefab";
        public string Fire = "assets/prefabs/ammo/rocket/rocket_fire.prefab";
        // public string Mrls = "assets/content/vehicles/mlrs/rocket_mlrs.prefab";
        #endregion[Rocket prefabs]

        #region GUI
        void DestroyCUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "GunUI");
        }
        public void CreateAmmoIcon(BasePlayer player, int ammo)
        {
            DestroyCUI(player);
            CuiElementContainer elements = new CuiElementContainer();
            string panel = elements.Add(new CuiPanel
            {
                Image = { Color = "0.5 0.5 0.5 0.0" },
                RectTransform = { AnchorMin = config.ImageAnchorMin, AnchorMax = config.ImageAnchorMax }
            }, "Hud.Menu", "GunUI");
            elements.Add(new CuiElement
            {
                Parent = panel,
                Components =
                {
                    new CuiImageComponent { ItemId = ammo },
                    new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                }
            });
            CuiHelper.AddUi(player, elements);
        }
        #endregion GUI

        #region[Commands]
        private void ToggleRocketCMD(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
                return;

            BasePlayer basePlayer = player.Object as BasePlayer;
            if(basePlayer != null)
            {
                if (!permission.UserHasPermission(basePlayer.userID.ToString(), PermUse))
                {
                    SendReply(basePlayer, lang.GetMessage("NoPerm", this, basePlayer.userID.ToString()));
                    return;
                }
                if (ActiveGUNS.Contains(basePlayer.userID))
                {
                    SendReply(basePlayer, lang.GetMessage("Off", this, basePlayer.userID.ToString()));
                    ActiveGUNS.Remove(basePlayer.userID);
                    DestroyCUI(basePlayer);
                    return;
                }
                else
                {
                    SendReply(basePlayer, lang.GetMessage("On", this, basePlayer.userID.ToString()));
                    ActiveGUNS.Add(basePlayer.userID);
                    UpdateIcon(basePlayer);
                    return;
                }
            }


           

        }
        #endregion[Commands]

        #region[Hooks]

        #region[load/unload]
        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                DestroyCUI(player);
            }
            ActiveGUNS = null;
        }
        private void Init()
        {
            permission.RegisterPermission(PermUse, this);
            AddCovalenceCommand(config.Command, nameof(ToggleRocketCMD));
        }
        #endregion[load/unload]

        #region[gui Hooks]
        void OnPlayerDisconnected(BasePlayer player) => DestroyCUI(player);
        void OnPlayerDeath(BasePlayer player, HitInfo info) => DestroyCUI(player);
        object OnWeaponReload(BaseProjectile weapon, BasePlayer player)
        {
            if (player != null && player.userID.IsSteamId())
            {
                if (ActiveGUNS.Contains(player.userID))
                {
                   

                   
                    timer.Once(weapon.reloadTime + 0.2f, () =>
                    {
                        
                        UpdateIcon(player);
                    });

                   
                }
            }
            return null;
        }
        void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
           DestroyCUI(player);
            var heldEntity = player.GetActiveItem();
            if (heldEntity != null)
            {
                var weapon = heldEntity.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    if (ActiveGUNS.Contains(player.userID))
                    {
                        NextFrame(() =>
                        {
                            UpdateIcon(player);
                        });

                    }
                }
            }
        }
        void OnAmmoUnload(BaseProjectile weapon, Item item, BasePlayer player)
        {

            if (ActiveGUNS.Contains(player.userID))
            {
                NextFrame(() =>
                {
                    UpdateIcon(player);
                });

            }
            return;
        }
        #endregion[gui hooks]

        void OnWeaponFired(BaseProjectile weapon, BasePlayer player, ItemModProjectile ammo, ProtoBuf.ProjectileShoot projectiles)
        {
            if (player == null) return;
            if (ActiveGUNS.Contains(player.userID) && ammo.ammoType == Rust.AmmoTypes.RIFLE_556MM)
            {
                string rocket = string.Empty;

                switch (ammo.name)
                {
                    case "ammo_rifle.item":
                        rocket = RocketToFire(config.Normal);
                        break;

                    case "ammo_rifle_hv.item":
                        rocket = RocketToFire(config.Hv);
                        break;

                    case "ammo_rifle_fire.item":
                        rocket = RocketToFire(config.Fire);
                        break;

                    case "ammo_rifle_explosive.item":
                        rocket = RocketToFire(config.Explo);
                        break;

                    default:
                        break;
                }

                if (string.IsNullOrEmpty(rocket))
                {
                    return;
                }
                FireRockets(player, rocket);
            }
            else return;
        }

        #endregion[Hooks]

        #region[Methods]
        public string RocketToFire(int id)
        {
            switch (id)
            {
                case 1:
                    return Rocket;

                case 2:
                    return Hv;

                case 3:
                    return Fire;

                default:
                    return string.Empty;
            }

        }
        public int RocketIcon(int id)
        {
            switch (id)
            {
                case 1:
                    return -742865266;

                case 2:
                    return -1841918730;

                case 3:
                    return 1638322904;

                default:
                    return 0;
            }
        }
        public void UpdateIcon(BasePlayer player)
        {
            DestroyCUI(player);
            var heldEntity = player.GetActiveItem();
            if (heldEntity != null)
            {
                var weapon = heldEntity.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    var ammodef = weapon.primaryMagazine.ammoType;
                    ItemDefinition itemDefinition = ItemManager.FindItemDefinition(ammodef.itemid);
                    ItemModProjectile ammo = itemDefinition.GetComponent<ItemModProjectile>();
                    if (ammo.ammoType == Rust.AmmoTypes.RIFLE_556MM)
                    {
                        int rocketicon = 0;
                        var ammount = weapon.primaryMagazine.contents;

                        if (ammount < 1) return;
                        

                        var ammotype = weapon.primaryMagazine.ammoType;

                        switch (ammo.name)
                        {
                            case "ammo_rifle.item":
                                rocketicon = RocketIcon(config.Normal);
                                break;

                            case "ammo_rifle_hv.item":
                                rocketicon = RocketIcon(config.Hv);
                                break;

                            case "ammo_rifle_fire.item":
                                rocketicon = RocketIcon(config.Fire);
                                break;

                            case "ammo_rifle_explosive.item":
                                rocketicon = RocketIcon(config.Explo);
                                break;

                            default:
                                break;
                        }

                        if (rocketicon == 0)
                        {
                            rocketicon = ammotype.itemid;
                        }

                        CreateAmmoIcon(player, rocketicon);
                    }
                }
            }

        }
        public void FireRockets(BasePlayer player, string rocketPrefab)
        {
            if (player == null) return;
            var rocket = GameManager.server.CreateEntity(rocketPrefab, player.eyes.position, new Quaternion());
            if (rocket != null)
            {
                if(rocketPrefab != null)
                {
                    float speed = 0;

                    switch (rocketPrefab)
                    {
                        case "assets/prefabs/ammo/rocket/rocket_basic.prefab":
                            speed = config.NormalSpeed;
                            break;

                        case "assets/prefabs/ammo/rocket/rocket_hv.prefab":
                            speed = config.HvSpeed;
                            break;

                        case "assets/prefabs/ammo/rocket/rocket_fire.prefab":
                            speed = config.FireSpeed;
                            break;

                        default:
                            break;
                    }
                    rocket.creatorEntity = player;
                    rocket.SendMessage("InitializeVelocity", player.eyes.HeadForward() * speed);
                    rocket.OwnerID = player.userID;
                    rocket.Spawn();
                    rocket.ClientRPC(null, "RPCFire");


                    Interface.CallHook("OnRocketLaunched", player,rocket);


                }
                
            }
        }

        
        #endregion[Methods]

        #region Config
        public Configuration config;
        public class Configuration
        {
            [JsonProperty("Toggle command")]
            public string Command = "togglegun";

            [JsonProperty("1 = normal rocket, 2 = hv rocket , 3 = incendiary rocket , 0 = none")]
            public int notused = 0;

            [JsonProperty("rocket type to fire when using normall 5.56")]
            public int Normal = 1;

            [JsonProperty("rocket type to fire when using hv 5.56")]
            public int Hv = 2;

            [JsonProperty("rocket type to fire when using Incendiary 5.56")]
            public int Fire = 3;

            [JsonProperty("rocket type to fire when using explosive 5.56")]
            public int Explo = 0;


            //[JsonProperty("Allow Incendiary rockets (may cause server lag if too many fired)")]
           // public bool UseFire = false;

            [JsonProperty("Hv rocket speed ")]
            public float HvSpeed = 200;

            [JsonProperty("Normal rocket speed")]
            public float NormalSpeed = 100;

            [JsonProperty("Incendiary rocket speed")]
            public float FireSpeed = 100;

            [JsonProperty("Image AnchorMin")]
            public string ImageAnchorMin = "0.645 0.023";

            [JsonProperty("Image AnchorMax")]
            public string ImageAnchorMax = "0.688 0.095";

        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }
        protected override void LoadDefaultConfig() => config = new Configuration();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region[Localization]
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPerm"] = "You dont have permission to use this command",
                ["Off"] = "Raid gun disengaged",
                ["On"] = "Raid gun engaged"
            }, this);
        }
        #endregion[Localization]
    }
}


// --- End of file: RocketGuns.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/research-block ---
// --- Original File Path: R/ResearchBlock/ResearchBlock.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Research Block", "Orange", "1.0.1")]
    [Description("Allows to block researching several items")]
    public class ResearchBlock : RustPlugin
    {
        #region Fields
        
        private List<ItemDefinition> _disabledResearchable = null;

        #endregion
        
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            if (!config.blockExperimenting)
            {
                return;
            }
            
            Unsubscribe(nameof(CanResearchItem));
            
            _disabledResearchable = new List<ItemDefinition>();
            foreach (var itemShortname in config.shortnames)
            {
                var itemDef = ItemManager.FindItemDefinition(itemShortname);
                if (itemDef == null)
                {
                    PrintWarning("Unable to find Item Defintion for Shortname: " + itemShortname);
                    continue;
                }

                if (!itemDef.Blueprint.isResearchable)
                {
                    PrintWarning("Trying to blacklist item that isn't researchable by default: " + itemShortname);
                    continue;
                }

                itemDef.Blueprint.isResearchable = false;
                _disabledResearchable.Add(itemDef);
            }
        }

        private void Unload()
        {
            if (_disabledResearchable == null)
            {
                return;
            }
            
            foreach (var itemDef in _disabledResearchable)
            {
                itemDef.Blueprint.isResearchable = true;
            }
        }

        private object CanResearchItem(BasePlayer player, Item item)
        {
            return config.shortnames.Contains(item.info.shortname) ? false : (object) null;
        }

        #endregion
        
        #region Config
        
        private static ConfigData config;
        
        private class ConfigData
        {    
            [JsonProperty(PropertyName = "Blocked shortnames")]
            public List<string> shortnames;
            [JsonProperty(PropertyName = "Additionally block Experimenting")]
            public bool blockExperimenting;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                shortnames = new List<string>
                {
                    "rifle.ak",
                    "ammo.rifle"
                },
                blockExperimenting = false
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        
        #endregion
    }
}

// --- End of file: ResearchBlock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rusty-rockets ---
// --- Original File Path: R/RustyRockets/RustyRockets.cs ---

﻿using System;
using Oxide.Core;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Rusty Rockets", "Strrobez", "1.1.0")]
    [Description("Allow players to use explosives during a certain time frame.")]
    public class RustyRockets : RustPlugin
    {
        private readonly int Date = (int)DateTime.UtcNow.DayOfWeek;
        private readonly int Hour = (int)DateTime.UtcNow.Hour;
        private readonly Dictionary<string, DateTime> Cooldown = new Dictionary<string, DateTime>();
        private readonly string UsePermission = "rustyrockets.use";

        #region Config

        private static Configuration _config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Rocket Cooldown")]
            public int RocketCooldown;
            
            [JsonProperty(PropertyName = "Day (To Allow Spawning)")]
            public string Day;

            [JsonProperty(PropertyName = "Hour (To Allow Spawning)")]
            public string Hour;

            [JsonProperty(PropertyName = "Items (To Give Players)")]
            public Item[] Items;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    RocketCooldown = 60,
                    Day = "Monday",
                    Hour = "12",
                    Items = new[] { new Item { ID = -742865266, Name = "Rockets", Amount = 20 } }
                };
            }
        }

        public class Item
        {
            [JsonProperty(PropertyName = "Item ID")]
            public int ID;

            [JsonProperty(PropertyName = "Item Name")]
            public string Name;
            
            [JsonProperty(PropertyName = "Item Amount")]
            public int Amount;

            public Item()
            {
            }

            public Item(int id, string name, int amount)
            {
                ID = id;
                Name = name;
                Amount = amount;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = Configuration.DefaultConfig();
        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion

        #region Hooks

        private void Loaded()
        {
            if (!permission.PermissionExists(UsePermission))
                permission.RegisterPermission(UsePermission, this);
        }

        #endregion
        
        #region Command

        [ChatCommand("rustyrockets")]
        private void RustyRocketsCmd(BasePlayer player)
        {
            if (player == null) return;

            if (!permission.UserHasPermission(player.UserIDString, UsePermission)) return;

            if (Date != (int)Enum.Parse(typeof(DayOfWeek), _config.Day) || Hour != int.Parse(_config.Hour))
            {
                player.ChatMessage(lang.GetMessage("Error", this, player.UserIDString));
                return;
            }
            
            if (Cooldown.ContainsKey(player.UserIDString))
            {
                player.ChatMessage(
                    string.Format(lang.GetMessage("Cooldown", this, player.UserIDString),
                    (Cooldown[player.UserIDString] - DateTime.UtcNow).Seconds)
                );
                return;
            }

            var items = _config.Items;

            foreach (Item item in items)
            {
                if (item.ID == 0 || item.Amount == 0) continue;

                var createdItem = ItemManager.CreateByItemID(item.ID, item.Amount);

                player.inventory.GiveItem(createdItem);

                player.ChatMessage(
                    string.Format(lang.GetMessage("Success", this, player.UserIDString), item.Amount,
                    item.Name)
                );
            }

            Cooldown.Add(player.UserIDString, DateTime.UtcNow.AddSeconds(_config.RocketCooldown));
            
            timer.Once(60, () => Cooldown.Remove(player.UserIDString));
        }
        
        #endregion
        
        #region Language
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Success"] = "You have been given {0} {1}.",
                ["Error"] = "You can't use this command right now.",
                ["Cooldown"] = "You can use this command again in {0} seconds."
            }, this);
        }
        #endregion
    }
}

// --- End of file: RustyRockets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/realtime-wipe-info ---
// --- Original File Path: R/RealtimeWipeInfo/RealtimeWipeInfo.cs ---

﻿// Reference: Facepunch.Sqlite

using System;
using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Realtime Wipe Info", "Ryan", "2.1.68")]
    [Description("Auto title and description updating, auto wipe schedule, chat filter, and more")]
    public class RealtimeWipeInfo : RustPlugin
    {
        #region Declaration

        // Plugin references
        [PluginReference] private Plugin BetterChat, ColouredChat;

        // Datetimes
        private DateTime _cachedWipeTime;

        // Permissions
        private const string BypassPerm = "realtimewipeinfo.chatbypass";

        // Timers
        private Timer _descriptionTimer;
        private Timer _titleTimer;

        // Configuration and data
        private static ConfigFile _config;
        private static DataFile _data;

        // Instance
        //private static RealtimeWipeInfo _instance;

        // Other variables
        private bool _newConfig;

        #endregion

        #region Configuration

        private class ConfigFile
        {
            [JsonProperty("Description Settings")]
            public DescriptionSettings Description;

            [JsonProperty("Title Settings")]
            public TitleSettings Title;

            [JsonProperty("Phrase Settings")]
            public PhraseSettings Phrase;

            [JsonProperty("Connect Message Settings")]
            public ConnectSettings Connect;

            [JsonProperty("Command Settings")]
            public CommandSettings Command;

            [JsonProperty("Blueprint settings")]
            public BlueprintSettings Blueprint;

            public VersionNumber Version;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    Description = new DescriptionSettings
                    {
                        Enabled = false,
                        Description = "Your description here. Put {0} where you want plugin info to go",
                        UseTime = true,
                        Date = new Date
                        {
                            Enabled = true,
                            Format = "dddd d/M"
                        },
                        Refresh = 120
                    },
                    Title = new TitleSettings
                    {
                        Enabled = false,
                        Title = "Your title here. Put {0} where you want plugin info to go",
                        UseTime = true,
                        Date = new Date
                        {
                            Enabled = true,
                            Format = "d/M"
                        },
                        Refresh = 60
                    },
                    Phrase = new PhraseSettings
                    {
                        Enabled = false,
                        Phrases = new Dictionary<string, PhraseItem>
                        {
                            ["wipe"] = new PhraseItem(true, true),
                            ["wipe?"] = new PhraseItem(true, false),
                            ["wiped"] = new PhraseItem(false, true),
                            ["wiped?"] = new PhraseItem(false, false)
                        },
                        UseTime = true,
                        Date = new Date
                        {
                            Enabled = true,
                            Format = "d/M"
                        },
                        Schedule = new ScheduleSettings
                        {
                            Enabled = true,
                            Schedule = 7,
                            Format = "dddd d/M"
                        }
                    },
                    Connect = new ConnectSettings
                    {
                        Enabled = false
                    },
                    Command = new CommandSettings()
                    {
                        Enabled = true,
                        Command = "wipe"
                    },
                    Blueprint = new BlueprintSettings()
                };
            }
        }

        #region Config Classes

        private class DescriptionSettings
        {
            [JsonProperty("Enable Description")]
            public bool Enabled;

            [JsonProperty("Full Server Description")]
            public string Description;

            [JsonProperty("Include Seed & Map Size")]
            public bool SeedSize;

            [JsonProperty("Enable Use Of Time")]
            public bool UseTime;

            public Date Date;

            [JsonProperty("Refresh Interval")]
            public float Refresh;
        }

        private class TitleSettings
        {
            [JsonProperty("Enable Title")]
            public bool Enabled;

            [JsonProperty("Full Server Hostname")]
            public string Title;

            [JsonProperty("Enable Use Of Time")]
            public bool UseTime;

            public Date Date;

            [JsonProperty("Refresh Interval")]
            public float Refresh;
        }

        private class PhraseSettings
        {
            [JsonProperty("Enable Phrases")]
            public bool Enabled;

            public Dictionary<string, PhraseItem> Phrases;

            [JsonProperty("Enable Use Of Time")]
            public bool UseTime;

            public Date Date;

            [JsonProperty("Schedule Settings")]
            public ScheduleSettings Schedule;
        }

        private class ConnectSettings
        {
            [JsonProperty("Enable Connect Messages")]
            public bool Enabled;
        }

        private class CommandSettings
        {
            public bool Enabled;
            public string Command;
        }

        private class Date
        {
            [JsonProperty("Enable Use Of Date")]
            public bool Enabled;

            [JsonProperty("Date format")]
            public string Format;
        }

        private class ScheduleSettings
        {
            [JsonProperty("Enable Wipe Schedule Messages")]
            public bool Enabled;

            [JsonProperty("Wipe Schedule In Days")]
            public int Schedule;

            [JsonProperty("Date Format")]
            public string Format;
        }

        private class PhraseItem
        {
            [JsonProperty("Send Reply")]
            public bool Message;

            [JsonProperty("Block Message")]
            public bool Block;

            public PhraseItem(bool message, bool block)
            {
                Message = message;
                Block = block;
            }
        }

        private class BlueprintSettings
        {
            [JsonProperty("Enable blueprint wipe tracking")]
            public bool Enabled;

            [JsonProperty("Add BP wipe to description")]
            public bool UseDescription;

            [JsonProperty("Use BP chat reply")]
            public bool UseChat;

            public BlueprintSettings()
            {
                Enabled = true;
                UseDescription = true;
                UseChat = true;
            }
        }

        #endregion

        protected override void LoadDefaultConfig()
        {
            PrintWarning($"All values are disabled by default, set them up at oxide/config/{Name}.json!");
            _newConfig = true;
            _config = ConfigFile.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<ConfigFile>();
                if (_config == null)
                {
                    Regenerate();
                    return;
                }
                if (_config.Blueprint == null)
                {
                    _config.Blueprint = new BlueprintSettings();
                    SaveConfig();
                }
            }
            catch { Regenerate(); }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        private void Regenerate()
        {
            PrintWarning($"Configuration file at 'oxide/config/{Name}.json' seems to be corrupt! Regenerating...");
            _config = ConfigFile.DefaultConfig();
            SaveConfig();
        }

        #endregion

        #region Lang

        private struct Msg
        {
            public const string TitleDay = "TitleDay";
            public const string TitleDays = "TitleDays";
            public const string TitleHour = "TitleHour";
            public const string TitleHours = "TitleHours";
            public const string TitleMinutes = "TitleMinutes";
            public const string DescLastWipe = "DescLastWipe";
            public const string DescNextWipe = "DescNextWipe";
            public const string DescSeedSize = "DescSeedSize";
            public const string MsgTime = "MsgTime";
            public const string MsgDate = "MsgDate";
            public const string MsgDateTime = "MsgDateTime";
            public const string MsgNextWipe = "MsgNextWipe";
            public const string DescBpWipe = "DescBpWipe";
            public const string DescMsgBpWipe = "DescMsgBpWipe";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Msg.TitleDay] = "{0} day ago",
                [Msg.TitleDays] = "{0} days ago",
                [Msg.TitleHour] = "{0} hour ago",
                [Msg.TitleHours] = "{0} hrs ago",
                [Msg.TitleMinutes] = "{0} mins ago",
                [Msg.DescLastWipe] = "The last wipe was on {0}",
                [Msg.DescNextWipe] = "The next wipe will be on {0} ({1} day wipe schedule)",
                [Msg.DescSeedSize] = "The map size is {0} and the seed is {1}",
                [Msg.MsgTime] = "The last wipe was {0} ago",
                [Msg.MsgDate] = "The last wipe was on {0}",
                [Msg.MsgDateTime] = "The last wipe was on {0} ({1} ago)",
                [Msg.MsgNextWipe] = "The next wipe will be on <color=orange>{0}</color> (<color=orange>{1}</color> day wipe schedule)",
                ["DayFormat"] = "<color=orange>{0}</color> day and <color=orange>{1}</color> hours",
                ["DaysFormat"] = "<color=orange>{0}</color> days and <color=orange>{1}</color> hours",
                ["HourFormat"] = "<color=orange>{0}</color> hour and <color=orange>{1}</color> minutes",
                ["HoursFormat"] = "<color=orange>{0}</color> hours and <color=orange>{1}</color> minutes",
                ["MinFormat"] = "<color=orange>{0}</color> minute and <color=orange>{1}</color> seconds",
                ["MinsFormat"] = "<color=orange>{0}</color> minutes and <color=orange>{1}</color> seconds",
                ["SecsFormat"] = "<color=orange>{0}</color> seconds",
                [Msg.DescBpWipe] = "(BP wiped {0})",
                [Msg.DescMsgBpWipe] = "(Blueprints wiped <color=orange>{0}</color>)"
            }, this);
        }

        #endregion

        #region Data

        private class DataFile
        {
            public string Hostname;
            public string Description;
            public DateTime BlueprintWipe;

            public DataFile()
            {
                Hostname = "";
                Description = "";
                BlueprintWipe = DateTime.MinValue;
            }

            public DataFile(string hostname, string description)
            {
                Hostname = hostname;
                Description = description;
            }
        }

        #endregion

        #region Methods

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private string GetFormattedTime(double time)
        {
            TimeSpan timeSpan = TimeSpan.FromSeconds(time);
            if (timeSpan.TotalSeconds < 1) 
			{
				return null;
			}

            if (Math.Floor(timeSpan.TotalDays) >= 1)
			{
				return string.Format(timeSpan.Days > 1 ? Lang("DaysFormat", null, timeSpan.Days, timeSpan.Hours) : Lang("DayFormat", null, timeSpan.Days, timeSpan.Hours));
			}
			
            if (Math.Floor(timeSpan.TotalMinutes) >= 60)
			{
				return string.Format(timeSpan.Hours > 1 ? Lang("HoursFormat", null, timeSpan.Hours, timeSpan.Minutes) : Lang("HourFormat", null, timeSpan.Hours, timeSpan.Minutes));
			}
			
            if (Math.Floor(timeSpan.TotalSeconds) >= 60)
			{
				return string.Format(timeSpan.Minutes > 1 ? Lang("MinsFormat", null, timeSpan.Minutes, timeSpan.Seconds) : Lang("MinFormat", null, timeSpan.Minutes, timeSpan.Seconds));
			}
			
            return Lang("SecsFormat", null, timeSpan.Seconds);
        }

        #region Title Methods

        private void ApplyTitle(string title) => ConVar.Server.hostname = string.Format(_config.Title.Title, title);

        private void StartTitleRefresh()
        {
            ApplyTitle(GetFormattedTitle());
            timer.Every(_config.Title.Refresh, () =>
            {
                ApplyTitle(GetFormattedTitle());
            });
        }

        private string GetFormattedTitleTime()
        {
            TimeSpan timeSpan = TimeSpan.FromSeconds((DateTime.UtcNow.ToLocalTime() - _cachedWipeTime).TotalSeconds);
            if (timeSpan.TotalSeconds < 1) 
			{
				return null;
			}

            if (Math.Floor(timeSpan.TotalDays) >= 1)
			{
				return string.Format(timeSpan.Days > 1 ? Lang(Msg.TitleDays, null, timeSpan.Days) : Lang(Msg.TitleDay, null, timeSpan.Days));
			}
			
            if (Math.Floor(timeSpan.TotalMinutes) >= 60)
			{
				return string.Format(timeSpan.Hours > 1 ? Lang(Msg.TitleHours, null, timeSpan.Hours) : Lang(Msg.TitleHour, null, timeSpan.Hours));
			}
			
            return Lang(Msg.TitleMinutes, null, timeSpan.Minutes);
        }

        private string GetFormattedTitle()
        {
            if (_config.Title.UseTime && !_config.Title.Date.Enabled)
            {
                return GetFormattedTitleTime();
            }
			
            if (_config.Title.Date.Enabled && !_config.Title.UseTime)
            {
                return _cachedWipeTime.ToString(_config.Title.Date.Format);
            }
			
            if (_config.Title.Date.Enabled && _config.Title.UseTime)
            {
                return _cachedWipeTime.ToString(_config.Title.Date.Format) + " " + GetFormattedTitleTime();
            }
			
            return string.Empty;
        }

        #endregion

        #region Description Methods

        private void ApplyDescription(string description) => ConVar.Server.description = description;

        private void StartDescriptionRefresh()
        {
            ApplyDescription(GetFormattedDescription());
            timer.Every(_config.Description.Refresh, () =>
            {
                ApplyDescription(GetFormattedDescription());
            });
        }

        private string GetFormattedDescription()
        {
            var output = "";
            if (_config.Phrase.Schedule.Enabled)
            {
                output = string.Format(Lang(Msg.DescLastWipe, null, _cachedWipeTime.ToString(_config.Description.Date.Format)) + "\n" +
                    Lang(Msg.DescNextWipe, null, _cachedWipeTime.AddDays(_config.Phrase.Schedule.Schedule)
                    .ToString(_config.Description.Date.Format), _config.Phrase.Schedule.Schedule));
            }
            else
            {
                output = Lang(Msg.DescLastWipe, null, _cachedWipeTime.ToString(_config.Description.Date.Format));
            }
			
            if (_config.Description.SeedSize)
            {
                output += "\n" + Lang(Msg.DescSeedSize, null, ConVar.Server.worldsize, ConVar.Server.seed);
            }
			
            if (_config.Blueprint.Enabled)
            {
                output += " " + Lang(Msg.DescBpWipe, null, _data.BlueprintWipe.ToLocalTime().ToString(_config.Description.Date.Format));
            }
			
            return string.Format(_config.Description.Description, output);
        }

        #endregion

        #region Phrase Methods

        private object ChatMessageResult(BasePlayer player, string input, bool reply)
        {
            if (!_config.Phrase.Enabled) return null;
            foreach (var phrase in _config.Phrase.Phrases)
            {
                if (input.ToLower().Contains(phrase.Key.ToLower()))
                {
                    if (phrase.Value.Message && reply)
                    {
                        PrintToChat(player, GetFormattedMessage(player));
                    }
                    if (phrase.Value.Block)
                    {
                        return false;
                    }
                    //return null;
                }
            }
            return null;
        }

        private string GetFormattedMessageTime() => GetFormattedTime((DateTime.UtcNow.ToLocalTime() - _cachedWipeTime).TotalSeconds);

        private string GetFormattedMessage(BasePlayer player)
        {
            var addition = string.Empty;
            if (_config.Blueprint.Enabled) 
			{
				addition = " " + Lang(Msg.DescMsgBpWipe, player.UserIDString, _data.BlueprintWipe.ToLocalTime().ToString(_config.Phrase.Date.Format));
			}
			
            if (_config.Phrase.UseTime && !_config.Phrase.Date.Enabled)
            {
                var output = Lang(Msg.MsgTime, player.UserIDString, GetFormattedMessageTime());
                if (_config.Phrase.Schedule.Enabled)
				{
					output += "\n" + Lang(Msg.MsgNextWipe, player.UserIDString, _cachedWipeTime.AddDays(_config.Phrase.Schedule.Schedule).ToString(_config.Phrase.Schedule.Format),
                                  _config.Phrase.Schedule.Schedule);
				}				
                return output + addition;
            }
			
            if (_config.Phrase.Date.Enabled && !_config.Phrase.UseTime)
            {
                var output = Lang(Msg.MsgDate, player.UserIDString, _cachedWipeTime.ToString(_config.Phrase.Date.Format));
                if (_config.Phrase.Schedule.Enabled)
                {
                    output += Lang(Msg.MsgNextWipe, player.UserIDString, _cachedWipeTime.AddDays(_config.Phrase.Schedule.Schedule).ToString(_config.Phrase.Schedule.Format),
                        _config.Phrase.Schedule.Schedule);
                }
                return output + addition;
            }
			
            if (_config.Phrase.Date.Enabled && _config.Phrase.UseTime)
            {
                var output = Lang(Msg.MsgDateTime, player.UserIDString, _cachedWipeTime.ToString(_config.Phrase.Date.Format), GetFormattedMessageTime());
                if (_config.Phrase.Schedule.Enabled)
                {
                    output += "\n" + Lang(Msg.MsgNextWipe, player.UserIDString, _cachedWipeTime.AddDays(_config.Phrase.Schedule.Schedule).ToString(_config.Phrase.Schedule.Format),
                                  _config.Phrase.Schedule.Schedule);
                }
                return output + addition;
            }
			
            return null;
        }

        #endregion

        private void OnBpsWiped()
        {
            PrintWarning("Blueprint wipe detected!");
            Interface.Oxide.CallHook("OnUsersCleared");
            Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
        }

        #endregion

        #region Hooks

        private void Init()
        {
			Unsubscribe("OnPluginLoaded");
			Unsubscribe("OnPluginUnloaded");
			
            _data = Interface.Oxide.DataFileSystem.ReadObject<DataFile>(Name);
            permission.RegisterPermission(BypassPerm, this);
            cmd.AddChatCommand(_config.Command.Command, this, WipeCommand);
            //_instance = this;

            if (_config.Phrase.Enabled && BetterChat && BetterChat.Version < new VersionNumber(5, 1, 0))
            {
                PrintWarning("This plugin is only compatible with BetterChat version 5.1.0 or greater!");
                Unsubscribe("OnBetterChat");
            }

			if (_config.Phrase.Enabled && ColouredChat)
            {
				if (ColouredChat.Version < new VersionNumber(1, 4, 3))
				{
					PrintWarning("This plugin is only compatible with ColouredChat version 1.4.3 or greater!");
					Unsubscribe("OnColouredChat");
				}
                else
				{
					// Resolve the hook conflict
					Unsubscribe("OnPlayerChat");
				}
            }
			
            if (_newConfig)
            {
                PrintWarning("Saved your current hostname and description to apply at a later date if needed");
                _data = new DataFile(ConVar.Server.hostname, ConVar.Server.description);
                Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
            }

            if (_config.Version == default(VersionNumber))
            {
                _config.Version = Version;
                SaveConfig();
            }
        }

        private void OnServerInitialized()
        {
            _cachedWipeTime = SaveRestore.SaveCreatedTime.ToLocalTime();
			
            if (_config.Blueprint.Enabled)
            {
                var blueprints = UserPersistance.blueprints;
                var playerCount = blueprints?.Query<int, ulong>("SELECT COUNT(*) FROM data", 0uL);
				
                if (playerCount != null && playerCount == 0)
                {
                    _data.BlueprintWipe = DateTime.UtcNow;
                    OnBpsWiped();
                }
				
                if (_data.BlueprintWipe == null || _data.BlueprintWipe == DateTime.MinValue)
                {
                    _data.BlueprintWipe = SaveRestore.SaveCreatedTime;
                    OnBpsWiped();
                }
            }
			
            if (!_config.Phrase.Enabled)
            {
                Unsubscribe("OnPlayerChat");
                Unsubscribe("OnBetterChat");
				Unsubscribe("OnColouredChat");
            }
			
            if (!_config.Connect.Enabled)
            {
                Unsubscribe("OnPlayerConnected");
            }
			
            if (_config.Description.Enabled)
            {
                if (_config.Description.UseTime)
				{
					StartDescriptionRefresh();
				}
                else
				{
					ApplyDescription(GetFormattedDescription());
				}
            }
			
            if (_config.Title.Enabled)
            {
                if (_config.Title.UseTime)
				{
					StartTitleRefresh();
				}
                else
				{
					ApplyTitle(GetFormattedTitle());
				}
            }
			
			// Subscribe to these hooks if the phrases are enabled (the hooks are required for 3rd party plugins)
			if (_config.Phrase.Enabled)
			{
				Subscribe("OnPluginLoaded");
				Subscribe("OnPluginUnloaded");
			}			
        }

        private void Unload()
        {
            _titleTimer?.Destroy();
            _descriptionTimer?.Destroy();

            if (!ConVar.Admin.ServerInfo().Restarting)
            {
                PrintWarning($"Setting servers hostname and description to the originally stored ones in oxide/data/{Name}.json");

                if (_config.Title.Enabled)
                {
                    ConVar.Server.hostname = _data.Hostname;
                }

                if (_config.Description.Enabled)
                {
                    ConVar.Server.description = _data.Description;
                }
            }

            //_instance = null;
        }

		private void OnPluginUnloaded(Plugin plugin)
		{
			// Fix if ColouredChat is unloaded after this one is loaded
			if (plugin == ColouredChat)
			{
				Unsubscribe("OnColouredChat");
				Subscribe("OnPlayerChat");
				return;
			}
		}
		
		private void OnPluginLoaded(Plugin plugin)
		{
			if (plugin == ColouredChat)
			{
				// Resolve the hook call conflict if the ColouredChat plugin is loaded after this one
				Unsubscribe("OnPlayerChat");
				Subscribe("OnColouredChat");
				return;
			}
		}
		
        private void OnPlayerConnected(BasePlayer player)
        {
            timer.Once(3, () =>
            {
                PrintToChat(player, GetFormattedMessage(player));
            });
        }

        private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (!permission.UserHasPermission(player.UserIDString, BypassPerm) && !player.IsAdmin)
            {
                return ChatMessageResult(player, message, true);
            }
            return null;
        }
		
		private object OnColouredChat(Dictionary<string, object> data)
        {
            var player = (IPlayer)data["Player"];
            if (!player.HasPermission(BypassPerm) && !player.IsAdmin)
            {
                return ChatMessageResult((BasePlayer)player.Object, data["Message"].ToString(), false);
            }
            return null;
        }

        private object OnBetterChat(Dictionary<string, object> data)
        {
            var player = (IPlayer)data["Player"];
            if (!player.HasPermission(BypassPerm) && !player.IsAdmin)
            {
                return ChatMessageResult((BasePlayer)player.Object, data["Message"].ToString(), false);
            }
            return null;
        }

        #endregion

        #region Commands

        private void WipeCommand(BasePlayer player, string command, string[] args)
        {
            PrintToChat(player, GetFormattedMessage(player));
        }

        #endregion
    }
}

// --- End of file: RealtimeWipeInfo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/raid-alerts ---
// --- Original File Path: R/RaidAlerts/RaidAlerts.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Rust;
using UnityEngine;
using Server = ConVar.Server;

namespace Oxide.Plugins
{
    [Info("Raid Alerts", "Ryz0r/Mevent", "1.0.2")]
    [Description("Allows players with permissions to receive alerts when explosives are thrown or fired.")]
    public class RaidAlerts : CovalencePlugin
    {
        private const string RaidAlertCommands = "raidalerts.use";

        private readonly Dictionary<string, float> _alertedUsers = new Dictionary<string, float>();

        private readonly List<string> _enabledPlayersList = new List<string>();

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _enabledPlayersList);
        }

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "UseWebhook")]
            public bool UseWebhook;

            [JsonProperty(PropertyName = "WebhookURL")]
            public string WebhookUrl = "";

            [JsonProperty(PropertyName = "OutputCooldown")]
            public float OutputCooldown = 5f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("A new configuration file is being generated.");
            _config = new Configuration();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["IncorrectArgs"] = "You are using the command incorrectly. Try /alerts on or /alerts off.",
                ["AlreadyReceiving"] = "You are already receiving alerts. Try /alerts off.",
                ["NotReceiving"] = "You are not receiving alerts. Try /alerts on.",
                ["NowReceiving"] = "You will now receive alerts when a raid is happening.",
                ["NoLongerReceiving"] = "You will no longer receive alerts when a raid is happening.",
                ["ThrownAlert"] = "{0} has thrown a {1} at the location {2}.",
                ["FiredAlert"] = "{0} has fired a Rocket/HE Grenade at the location {1}.",
                ["GenRaidAlert"] = "{0} is using explosive ammo or fire ammo at the location {1}.",
                ["NoPerm"] = "You don't have the permissions to use this command."
            }, this);
        }

        private void OnNewSave(string filename)
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile(Name))
            {
                Interface.Oxide.DataFileSystem.GetFile(Name).Clear();
                Interface.Oxide.DataFileSystem.GetFile(Name).Save();

                Puts($"Wiped '{Name}.json'");
            }
        }

        private void Init()
        {
            permission.RegisterPermission(RaidAlertCommands, this);
        }

        [Command("alerts")]
        private void AlertsCommand(IPlayer player, string command, string[] args)
        {
            if (player.HasPermission(RaidAlertCommands))
            {
                if (args.Length == 0 || args.Length > 1)
                {
                    player.Reply(lang.GetMessage("IncorrectArgs", this, player.Id));
                    return;
                }

                switch (args[0])
                {
                    case "on":
                        if (_enabledPlayersList.Contains(player.Id))
                        {
                            player.Reply(lang.GetMessage("AlreadyReceiving", this, player.Id));
                            return;
                        }

                        _enabledPlayersList.Add(player.Id);
                        player.Reply(lang.GetMessage("NowReceiving", this, player.Id));
                        SaveData();
                        break;
                    case "off":
                        if (!_enabledPlayersList.Contains(player.Id))
                        {
                            player.Reply(lang.GetMessage("NotReceiving", this, player.Id));
                            return;
                        }

                        _enabledPlayersList.Remove(player.Id);
                        player.Reply(lang.GetMessage("NoLongerReceiving", this, player.Id));
                        SaveData();
                        break;
                }
            }
            else
            {
                player.Reply(lang.GetMessage("NoPerm", this, player.Id));
            }
        }

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity, ThrownWeapon item)
        {
            var playerThrow = player.displayName;
            var entityLocation = entity.transform.position;
            var explosiveUsed = item.ShortPrefabName;

            switch (explosiveUsed)
            {
                case "explosive.timed.entity":
                    explosiveUsed = "C4";
                    break;
                case "explosive.satchel.entity":
                    explosiveUsed = "Satchel";
                    break;
                case "grenade.beancan.entity":
                    explosiveUsed = "Beancan";
                    break;
                case "grenade.f1.entity":
                    explosiveUsed = "Grenade";
                    break;
                case "survey_charge":
                    explosiveUsed = "Survey Charge";
                    break;
            }

            foreach (var user in BasePlayer.activePlayerList)
                if (_enabledPlayersList.Contains(user.UserIDString))
                    user.ChatMessage(string.Format(lang.GetMessage("ThrownAlert", this, player.UserIDString),
                        playerThrow, explosiveUsed, GetGrid(entityLocation)));

            if (_config.UseWebhook && _config.WebhookUrl != null)
                SendDiscordMessage(playerThrow, entityLocation, explosiveUsed);
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (!info.damageTypes.Has(DamageType.Explosion) || info.InitiatorPlayer == null ||
                _alertedUsers.ContainsValue(entity.transform.position.x)) return null;

            var attackerName = info.InitiatorPlayer.displayName;

            timer.Once(_config.OutputCooldown, () => _alertedUsers.Remove(attackerName));

            _alertedUsers[attackerName] = entity.transform.position.x;

            foreach (var user in BasePlayer.activePlayerList.Where(user =>
                _enabledPlayersList.Contains(user.UserIDString)))
            {
                user.ChatMessage(string.Format(lang.GetMessage("GenRaidAlert", this, user.UserIDString),
                    attackerName, GetGrid(entity.transform.position)));
                return true;
            }

            if (_config.UseWebhook && _config.WebhookUrl != null)
                SendDiscordMessage(attackerName, entity.transform.position, "Explo/Fire");

            return null;
        }

        private void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            var playerThrow = player.displayName;
            var entityLocation = entity.transform.position;

            foreach (var user in BasePlayer.activePlayerList.Where(user =>
                _enabledPlayersList.Contains(user.UserIDString)))
                user.ChatMessage(string.Format(lang.GetMessage("FiredAlert", this, player.UserIDString),
                    playerThrow, GetGrid(entityLocation)));

            if (_config.UseWebhook && _config.WebhookUrl != null)
                SendDiscordMessage(playerThrow, entityLocation, "Rocket/HE Grenade");
        }

        private void SendDiscordMessage(string playerName, Vector3 entityLocation, string explosive)
        {
            var embed = new Embed()
                .AddField("Player Name:", playerName, true)
                .AddField("Explosive Used:", explosive, false)
                .AddField("Rocket Location:", GetGrid(entityLocation), false);

            webrequest.Enqueue(_config.WebhookUrl, new DiscordMessage("", embed).ToJson(), (code, response) => { },
                this,
                RequestMethod.POST, new Dictionary<string, string>
                {
                    { "Content-Type", "application/json" }
                });
        }

        #region Discord Stuff

        private class DiscordMessage
        {
            public DiscordMessage(string content, params Embed[] embeds)
            {
                Content = content;
                Embeds = embeds.ToList();
            }

            [JsonProperty("content")] public string Content { get; set; }
            [JsonProperty("embeds")] public List<Embed> Embeds { get; set; }

            public string ToJson()
            {
                return JsonConvert.SerializeObject(this);
            }
        }

        private class Embed
        {
            [JsonProperty("fields")] public List<Field> Fields { get; set; } = new List<Field>();

            public Embed AddField(string name, string value, bool inline)
            {
                Fields.Add(new Field(name, Regex.Replace(value, "<.*?>", string.Empty), inline));

                return this;
            }
        }

        private class Field
        {
            public Field(string name, string value, bool inline)
            {
                Name = name;
                Value = value;
                Inline = inline;
            }

            [JsonProperty("name")] public string Name { get; set; }
            [JsonProperty("value")] public string Value { get; set; }
            [JsonProperty("inline")] public bool Inline { get; set; }
        }

        #endregion

        #region Utils

        private static string GetGrid(Vector3 pos)
        {
            var letter = 'A';
            var x = Mathf.Floor((pos.x + Server.worldsize / 2f) / 146.3f) % 26;
            var z = Mathf.Floor(Server.worldsize / 146.3f) -
                    Mathf.Floor((pos.z + Server.worldsize / 2f) / 146.3f);
            letter = (char)(letter + x);
            return $"{letter}{z}";
        }

        #endregion
    }
}

// --- End of file: RaidAlerts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/restart-by-uptime ---
// --- Original File Path: R/RestartByUptime/RestartByUptime.cs ---

using System;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Restart By Uptime", "Orange", "1.0.4")]
    [Description("Restarts server when uptime reaches specific time and players count is specific")]
    public class RestartByUptime : CovalencePlugin
    {
        #region Vars

        private DateTime nextRestartTime;
        private Timer timerObject;

        #endregion
        
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            nextRestartTime = DateTime.UtcNow.AddSeconds(config.maxUptimeSeconds);
            timerObject = timer.Every(60, CheckUptime);
        }

        private void Unload()
        {
            config = null;
        }

        #endregion

        #region Core

        private void CheckUptime()
        {
            if (server.Players > config.playersBound)
            {
                return;
            }

            #if RUST
            if (UnityEngine.Time.realtimeSinceStartup < config.maxUptimeSeconds)
            {
                return;
            }
            #else
            if (DateTime.UtcNow < nextRestartTime)
            {
                return;
            }
            #endif

            if (timerObject != null && timerObject.Destroyed == false)
            {
                timerObject.Destroy();
            }
            
            server.Command(config.command);
        }

        #endregion
        
        #region Configuration | 24.05.2020

        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Max Uptime (seconds)")]
            public float maxUptimeSeconds = 12 * 60 * 60;

            [JsonProperty(PropertyName = "If on server more than X players, don't trigger restart")]
            public int playersBound = 0;

            [JsonProperty(PropertyName = "Command")]
            public string command = "restart 1";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    LogError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }
                
                LoadDefaultConfig();
                return;
            }

            ValidateConfig();
            SaveConfig();
        }

        private void ValidateConfig()
        {
            if (server.Name.Contains("[DEBUG]") == true)
            {
                LogWarning("Using default configuration on debug server");
                config = new ConfigData();
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: RestartByUptime.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/robbery ---
// --- Original File Path: R/Robbery/Robbery.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using UnityEngine;

// TODO: Add option to set maximum amount that a player can steal
// TODO: Combine messages when multiple supported plugins for one type are in use
// TODO: Improve item stealing chances, very slim chance to get an item right now

namespace Oxide.Plugins
{
    [Info("Robbery", "Wulf", "4.1.5")]
    [Description("Players can steal money, points, and/or items from other players")]
    public class Robbery : RustPlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Allow item stealing (true/false)")]
            public bool ItemStealing;

            [JsonProperty(PropertyName = "Allow money stealing (true/false)")]
            public bool MoneyStealing;

            [JsonProperty(PropertyName = "Allow point stealing (true/false)")]
            public bool PointStealing;

            [JsonProperty(PropertyName = "Clan protection (true/false)")]
            public bool ClanProtection;

            [JsonProperty(PropertyName = "Friend protection (true/false)")]
            public bool FriendProtection;

            [JsonProperty(PropertyName = "Maximum chance of stealing an item (0 - 100)")]
            public int MaxChanceItem;

            [JsonProperty(PropertyName = "Maximum chance of stealing money (0 - 100)")]
            public int MaxChanceMoney;

            [JsonProperty(PropertyName = "Maximum chance of stealing points (0 - 100)")]
            public int MaxChancePoints;

            [JsonProperty(PropertyName = "Usage cooldown (seconds, 0 to disable)")]
            public int UsageCooldown;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    ItemStealing = true,
                    MoneyStealing = true,
                    PointStealing = true,
                    ClanProtection = false,
                    FriendProtection = false,
                    MaxChanceItem = 25,
                    MaxChanceMoney = 50,
                    MaxChancePoints = 50,
                    UsageCooldown = 30
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.MoneyStealing == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Could not read oxide/config/{Name}.json, creating new config file");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = Configuration.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Localization

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CanBeSeen"] = "You can't pickpocket right now, you were seen",
                ["CantHoldItem"] = "You can't pickpocket while holding an item",
                ["Cooldown"] = "Wait a bit before attempting to steal again",
                ["IsClanmate"] = "You can't steal from a clanmate",
                ["IsFriend"] = "You can't steal from a friend",
                ["IsProtected"] = "You can't steal from a protected player",
                ["NoLootZone"] = "You can't steal from players in this zone",
                ["StoleItem"] = "You stole {0} {1} from {2}!",
                ["StoleMoney"] = "You stole ${0} from {1}!",
                ["StoleNothing"] = "You stole pocket lint from {0}!",
                ["StolePoints"] = "You stole {0} points from {1}!"
            }, this);
        }

        #endregion Localization

        #region Initialization

        [PluginReference]
        private Plugin Clans, Economics, EventManager, Factions, Friends, RustIO, ServerRewards, UEconomics, ZoneManager;

        private readonly Hash<string, float> cooldowns = new Hash<string, float>();
        private static System.Random random = new System.Random();

        private const string permKilling = "robbery.killing";
        private const string permMugging = "robbery.mugging";
        private const string permPickpocket = "robbery.pickpocket";
        private const string permProtection = "robbery.protection";

        private void Init()
        {
            permission.RegisterPermission(permKilling, this);
            permission.RegisterPermission(permMugging, this);
            permission.RegisterPermission(permPickpocket, this);
            permission.RegisterPermission(permProtection, this);
        }

        #endregion Initialization

        #region Point Stealing

        private void StealPoints(BasePlayer victim, BasePlayer attacker)
        {
            var chance = random.NextDouble() * (config.MaxChancePoints / 100f);

            // ServerRewards plugin support - https://umod.org/plugins/server-rewards
            if (ServerRewards != null)
            {
                var balance = ServerRewards.Call("CheckPoints", victim.userID) ?? 0;
                var points = Math.Floor((int)balance * chance);

                if (points > 0)
                {
                    ServerRewards.Call("TakePoints", victim.userID, points);
                    ServerRewards.Call("AddPoints", attacker.userID, points);
                    Player.Reply(attacker, Lang("StolePoints", attacker.UserIDString, points, victim.displayName));
                }
                else
                    Player.Reply(attacker, Lang("StoleNothing", attacker.UserIDString, victim.displayName));
            }
        }

        #endregion Point Stealing

        #region Money Stealing

        private void StealMoney(BasePlayer victim, BasePlayer attacker)
        {
            var chance = random.NextDouble() * (config.MaxChanceMoney / 100f);

            // Economics plugin support - http://umod.org/plugins/economics
            if (Economics != null)
            {
                var balance = Economics.Call<double>("Balance", victim.UserIDString);
                var money = Math.Floor(balance * chance);

                if (money > 0)
                {
                    Economics.Call("Transfer", victim.UserIDString, attacker.UserIDString, money);
                    Player.Reply(attacker, Lang("StoleMoney", attacker.UserIDString, money, victim.displayName));
                }
                else
                    Player.Reply(attacker, Lang("StoleNothing", attacker.UserIDString, victim.displayName));
            }

            // UEconomics plugin support
            if (UEconomics != null)
            {
                var balance = UEconomics.Call<int>("GetPlayerMoney", victim.UserIDString);
                var money = Math.Floor(balance * chance);

                if (money > 0)
                {
                    UEconomics.Call("Withdraw", victim.UserIDString, money);
                    UEconomics.Call("Deposit", attacker.UserIDString, money);
                    Player.Reply(attacker, Lang("StoleMoney", attacker.UserIDString, money, victim.displayName));
                }
                else
                    Player.Reply(attacker, Lang("StoleNothing", attacker.UserIDString, victim.displayName));
            }
        }

        #endregion Money Stealing

        #region Item Stealing

        private void StealItem(BasePlayer victim, BasePlayer attacker)
        {
            var victimInv = victim.inventory.containerMain;
            var attackerInv = attacker.inventory.containerMain;
            if (victimInv == null || attackerInv == null) return;

            var chance = random.NextDouble() * (config.MaxChanceItem / 100f);
            var item = victimInv.GetSlot(random.Next(1, victimInv.capacity));
            if (item != null && !attackerInv.IsFull() && chance > 0)
            {
                item.MoveToContainer(attackerInv);
                Player.Reply(attacker, Lang("StoleItem", attacker.UserIDString, item.amount, item.info.displayName.english, victim.displayName));
            }
            else
                Player.Reply(attacker, Lang("StoleNothing", attacker.UserIDString, victim.displayName));
        }

        #endregion Item Stealing

        #region Zone Checks

        private bool InNoLootZone(BasePlayer victim, BasePlayer attacker)
        {
            // Event Manager plugin support - http://oxidemod.org/plugins/event-manager.740/
            if (EventManager != null)
            {
                if (!((bool)EventManager.Call("isPlaying", victim))) return false;
                Player.Reply(attacker, Lang("NoLootZone", attacker.UserIDString));
                return true;
            }

            // Zone Manager plugin support - http://oxidemod.org/plugins/zones-manager.739/
            if (ZoneManager != null)
            {
                var noLooting = Enum.Parse(ZoneManager.GetType().GetNestedType("ZoneFlags"), "NoPlayerLoot", true);
                if (!((bool)ZoneManager.Call("HasPlayerFlag", victim, noLooting))) return false;
                Player.Reply(attacker, Lang("NoLootZone", attacker.UserIDString));
                return true;
            }

            return false;
        }

        #endregion Zone Checks

        #region Friend Checks

        private bool IsFriend(BasePlayer victim, BasePlayer attacker)
        {
            // Friends plugin support - http://oxidemod.org/plugins/friends-api.686/
            if (config.FriendProtection && Friends != null)
            {
                // Check if victim is friend of attacker
                if (!((bool)Friends.Call("AreFriends", attacker.userID, victim.userID))) return false;
                Player.Reply(attacker, Lang("IsFriend", attacker.UserIDString));
                return true;
            }

            // Rust:IO plugin support - http://oxidemod.org/extensions/rust-io.768/
            if (config.FriendProtection && RustIO != null)
            {
                // Check if victim is friend of attacker
                if (!((bool)RustIO.Call("HasFriend", attacker.UserIDString, victim.UserIDString))) return false;
                Player.Reply(attacker, Lang("IsFriend", attacker.UserIDString));
                return true;
            }

            return false;
        }

        #endregion Friend Checks

        #region Clan Checks

        private bool IsClanmate(BasePlayer victim, BasePlayer attacker)
        {
            // Clans plugin support - http://oxidemod.org/plugins/rust-io-clans.842/
            if (config.ClanProtection && Clans != null)
            {
                var victimClan = (string)Clans.Call("GetClanOf", victim.UserIDString);
                var attackerClan = (string)Clans.Call("GetClanOf", attacker.UserIDString);
                if (victimClan == null || attackerClan == null || !victimClan.Equals(attackerClan)) return false;
                Player.Reply(attacker, Lang("IsClanmate", attacker.UserIDString));
                return true;
            }

            // Factions plugin support - http://oxidemod.org/plugins/factions.1919/
            if (config.ClanProtection && Factions != null)
            {
                if (!((bool)Factions.Call("CheckSameFaction", attacker.userID, victim.userID))) return false;
                Player.Reply(attacker, Lang("IsClanmate", attacker.UserIDString));
                return true;
            }

            return false;
        }

        #endregion Clan Checks

        #region Killing

        private void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            var victim = entity.ToPlayer();
            var attacker = info?.Initiator?.ToPlayer();

            // Check if victim and attacker are invalid or equal
            if (victim == null || attacker == null || victim.Equals(attacker)) return;

            // Check if victim or attacker is an NPCPlayer (ie. scientist)
            if (entity is NPCPlayer || info.Initiator is NPCPlayer) return;

            // Check if victim or attacker is a manually spawned BasePlayer
            if (victim.Connection == null || attacker.Connection == null) return;

            // Check if victim is protected from being killed
            if (permission.UserHasPermission(victim.UserIDString, permProtection)) return;

            // Check if attacker is allowed to kill
            if (!permission.UserHasPermission(attacker.UserIDString, permKilling)) return;

            // Check if victim or attacker are in a loot zone, are friends, or share a clan
            if (InNoLootZone(victim, attacker) || IsFriend(victim, attacker) || IsClanmate(victim, attacker)) return;

            // Check if config options for stealing are enabled
            if (config.MoneyStealing) StealMoney(victim, attacker);
            if (config.PointStealing) StealPoints(victim, attacker);
        }

        #endregion Killing

        #region Mugging

        private void OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            var victim = entity.ToPlayer();
            var attacker = info?.Initiator?.ToPlayer();

            // Check if victim and attacker are invalid or equal
            if (victim == null || attacker == null || victim.Equals(attacker)) return;

            // Check if victim or attacker is an NPCPlayer (ie. scientist)
            if (entity is NPCPlayer || info.Initiator is NPCPlayer) return;

            // Check if victim or attacker is a manually spawned BasePlayer
            if (victim.Connection == null || attacker.Connection == null) return;

            // Make sure player isn't using ranged weapons
            if (info.IsProjectile()) return;

            // Check if victim is protected from being mugged
            if (permission.UserHasPermission(victim.UserIDString, permProtection)) return;

            // Check if attacker is allowed to mug
            if (!permission.UserHasPermission(attacker.UserIDString, permMugging)) return;

            // Check if victim or attacker are in a loot zone, are friends, or share a clan
            if (InNoLootZone(victim, attacker) || IsFriend(victim, attacker) || IsClanmate(victim, attacker)) return;

            // Check for a cooldown and set one if it doesn't exist
            if (!cooldowns.ContainsKey(attacker.UserIDString)) cooldowns.Add(attacker.UserIDString, 0f);
            if (config.UsageCooldown != 0 && cooldowns[attacker.UserIDString] + config.UsageCooldown > Interface.Oxide.Now)
            {
                Player.Reply(attacker, Lang("Cooldown", attacker.UserIDString));
                return;
            }

            // Check if config options are enabled for stealing
            if (config.ItemStealing) StealItem(victim, attacker);
            if (config.MoneyStealing) StealMoney(victim, attacker);
            if (config.PointStealing) StealPoints(victim, attacker);

            // Set time for next cooldown check
            cooldowns[attacker.UserIDString] = Interface.Oxide.Now;
        }

        #endregion Mugging

        #region Pickpocketing

        private void OnPlayerInput(BasePlayer attacker, InputState input)
        {
            // Only listen for presses of use key (E by default)
            if (!input.WasJustPressed(BUTTON.USE)) return;

            // Check if attacker is allowed to pickpocket
            if (!permission.UserHasPermission(attacker.UserIDString, permPickpocket)) return;

            // Look for a valid player to pickpocket
            var ray = new Ray(attacker.eyes.position, attacker.eyes.HeadForward());
            var entity = FindObject(ray, 1);
            var victim = entity?.ToPlayer();

            // Check if victim is invalid
            if (victim == null) return;

            // Check if victim is an NPCPlayer (ie. scientist)
            if (entity is NPCPlayer) return;

            // Check if victim is a manually spawned BasePlayer
            if (victim.Connection == null) return;

            // Check if victim is protected from being pickpocketed
            if (permission.UserHasPermission(victim.UserIDString, permProtection)) return;

            // Check if victim or attacker are in a loot zone, are friends, or share a clam
            if (InNoLootZone(victim, attacker) || IsFriend(victim, attacker) || IsClanmate(victim, attacker)) return;

            // Check if attacker is in line of sight of victim
            var victimToAttacker = (attacker.transform.position - victim.transform.position).normalized;
            if (Vector3.Dot(victimToAttacker, victim.eyes.HeadForward().normalized) > 0)
            {
                Player.Reply(attacker, Lang("CanBeSeen", attacker.UserIDString));
                return;
            }

            // Check if attacker is holding an item
            if (attacker.GetActiveItem()?.GetHeldEntity() != null)
            {
                Player.Reply(attacker, Lang("CantHoldItem", attacker.UserIDString));
                return;
            }

            // Check for a cooldown and set one if it doesn't exist
            if (!cooldowns.ContainsKey(attacker.UserIDString)) cooldowns.Add(attacker.UserIDString, 0f);
            if (config.UsageCooldown != 0 && cooldowns[attacker.UserIDString] + config.UsageCooldown > Interface.Oxide.Now)
            {
                Player.Reply(attacker, Lang("Cooldown", attacker.UserIDString));
                return;
            }

            // Check if config options are enabled for stealing
            if (config.ItemStealing) StealItem(victim, attacker);
            if (config.MoneyStealing) StealMoney(victim, attacker);
            if (config.PointStealing) StealPoints(victim, attacker);

            // Set time for next cooldown check
            cooldowns[attacker.UserIDString] = Interface.Oxide.Now;
        }

        #endregion Pickpocketing

        #region Helpers

        private static BaseEntity FindObject(Ray ray, float distance)
        {
            RaycastHit hit;
            return Physics.Raycast(ray, out hit, distance) ? hit.GetEntity() : null;
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion Helpers
    }
}


// --- End of file: Robbery.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rusty-cuffs ---
// --- Original File Path: R/RustyCuffs/RustyCuffs.cs ---

// UMod build

// DCON
// using Oxide.Ext.DCON;

using System.IO;
using System.Linq;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;

//Oxide
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Oxide.Core;

//Rust
using Network;

//Unity
using UnityEngine;

// Yes I'm aware how hacky these methods are, It's almost impossible to achieve smooth anything given how limited mod support for rust is
// If there was a better more realistic way to achieve this I would have done it, if I haven't and there really is, I will update.
// I tried.

namespace Oxide.Plugins
{
    [Info("Rusty Cuffs", "Revolving DCON", "0.9.35")]
    [Description("Handcuffs allowing you to restrain and escort players")]

    public class RustyCuffs : CovalencePlugin
    {
        protected Oxide.Game.Rust.Libraries.Player Player = Interface.Oxide.GetLibrary<Oxide.Game.Rust.Libraries.Player>(null);
        
        // private static readonly DCONPlugin DCON = new DCONPlugin();
        // private static readonly Dictionary<string, string> AP = DCON.GetColors();

        #region variables

        private ulong cuffsSkinID = 2415236504;
        private string cuffsItemShortname = "metalspring";

        // private static ulong keysSkinID = 2415236504;
        private string keysItemShortname = "door.key";

        private StoredData storedData;
        private bool storageChanged;

        private Vector3 chairPositionOffset = new Vector3(0f,-1000f,0);

        // [PluginReference]
        // private Plugin DCON;

        private Dictionary<string, UIContainer> userUIContainers = new Dictionary<string, UIContainer>();
        private Dictionary<string, Timer> userTimers = new Dictionary<string, Timer>();
        private Dictionary<string,string> listenToUsers = new Dictionary<string,string>();
        private Dictionary<BasePlayer,BasePlayer> selectedUsers = new Dictionary<BasePlayer,BasePlayer>();
        private Dictionary<BasePlayer,BasePlayer> escortingUsers = new Dictionary<BasePlayer,BasePlayer>();
        private List<BasePlayer> usersInputDisabled = new List<BasePlayer>();
        private Dictionary<string,ChairHack> restrainChairs = new Dictionary<string,ChairHack>();
        private List<BaseMountable> chairEnts = new List<BaseMountable>();

        private int obstructionMask = LayerMask.GetMask("Construction", "Deployable", "Default", "Deployed", "Resource", "Terrain", "World", "Tree", "Impostor");
        private int baseMask = LayerMask.GetMask("Construction", "Deployable", "Deployed");

        private Dictionary<string,string> perms = new Dictionary<string,string>(){
            // primary perms
            {"admin","rustycuffs.admin"},
            {"use","rustycuffs.use"},
            {"unlimited","rustycuffs.unlimited"},
            {"usecuffkeys","rustycuffs.usecuffkeys"},
            {"lockpick","rustycuffs.lockpick"},

            // button perms
            {"escort","rustycuffs.escort"},
            {"viewinventory","rustycuffs.viewinventory"},
            {"execute","rustycuffs.execute"},
            {"createkey","rustycuffs.createkey"},
            {"unrestrain","rustycuffs.unrestrain"},
        };

        private new Dictionary<string, string> messages = new Dictionary<string, string> {
            // notifications player
            ["scriptreload"] = "Script reload, escorting stopped",
            ["givecuffs"] = "Gave cuffs to {0}",
            ["keycreated"] = "Key created for {0}",
            ["restrained"] = "{0} was restrained",
            ["unrestrained"] = "{0} was unrestrained",

            // notifications target
            ["restrained_tgt"] = "You have been restrained",
            ["unrestrained_tgt"] = "You have been unrestrained",
            ["givekey_tgt"] = "You got keys",
            ["givecuffs_tgt"] = "You got cuffs",
            ["bot_created"] = "Bot created at your location",
            ["restraining_tgt"] = "You are being restrained",

            // errors
            ["error_noperms"] = "You do not have permission to use this command",
            ["error_noperms_keys"] = "You do not have permission to use cuff keys",
            ["error_noperms_cuffs"] = "You do not have permission to use cuffs",
            ["error_not_restrained"] = "{0} is not restrained",
            ["error_select_self"] = "You can not select yourself",
            ["error_restrain_self"] = "You can not restrain yourself",
            ["error_tgt_selected"] = "{0} is already selected",
            ["error_tgt_restrained"] = "{0} is already restrained",
            ["error_restrain_npc"] = "Can not restrain NPCs",
            ["error_restrained_cuff_use"] = "You can not use cuffs while restrained",
            ["error_static_ground"] = "Must be standing on static ground",
            ["error_cuffs_missing"] = "Can not find cuffs in tool belt",
            ["error_key_missing"] = "Can not find correct key in tool belt",
            ["error_wrong_key"] = "This key is not for {0}",
            ["error_mount_escorting"] = "Can not mount while escorting",
            ["error_escort_self"] = "You can not escort yourself..",
            ["error_escort_view_obstructed"] = "Can not escort, view obstructed",
            ["error_escort_stop_view_obstructed"] = "Can not stop escorting, view obstructed",
            ["error_unrestrain_view_obstructed"] = "Can not unrestrain, view obstructed",

            ["error_invalid_selection"] = "Invalid number, use the number in front of the player's name. Use /{0} to check the list of players again",
            ["error_multiple_players_found"] = "Multiple players matching: {1}, please select one of these players by using /{0} list <number>:",
            ["error_no_list_available"] = "You do not have a players list available for /{0}",
            ["error_no_players_found"] = "Couldn't find any players matching: {0}" ,
            ["error_too_many_players_found"] = "Too many players were found, the list of matches is only showing the first 5. Try to be more specific" 
        };

        private static RustyCuffs _ins;
        private Configuration config;

        #endregion

        #region lang

        // umod compliance
        protected override void LoadDefaultMessages() => lang.RegisterMessages(messages, this);

        #endregion

        #region config

        public class Configuration {
            [JsonProperty(PropertyName = "Chat Prefix")]
            public string prefix = "[+16][#00ffff]Rusty Cuffs[/#][/+]: ";

            [JsonProperty(PropertyName = "Chat Icon")]
            public ulong icon = 76561199105408156;

            // [JsonProperty(PropertyName = "Destroy Key [Destroy key when player is unrestrained]")]
            // public bool destroyKey = true;

            [JsonProperty(PropertyName = "Return Cuffs [Give cuffs back when player is unrestrained]")]
            public bool returnCuffs = false;

            [JsonProperty(PropertyName = "Restrain Time [How long does it take to restrain a player]")]
            public float restrainTime = 1;

            [JsonProperty(PropertyName = "Restrain Distance [Maximum distance players can be restrained from]")]
            public float restrainDist = 2f;

            [JsonProperty(PropertyName = "Escort Distance [Distance players are while being escorted]")]
            public float escortDist = 0.9f;

            [JsonProperty(PropertyName = "Restrain NPCs [Can NPCs be restrained]")]
            public bool npcsEnabled = false;
        }

        protected override void LoadConfig() {
            base.LoadConfig();
            try {
                config = Config.ReadObject<Configuration>();
                if (config == null) {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig(){
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            LogWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region data

        public class StoredData {
            public Dictionary<ulong, string> keys = new Dictionary<ulong, string>();
            public Dictionary<string, string> restrained = new Dictionary<string, string>();
        }

        private void SaveData(){
            if(storageChanged){
                storageChanged = false;

                Puts("Saving Rusty Cuffs");
                Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
            }
        }
        private void OnServerSave() => SaveData();

        #endregion

        #region setup

        private void Init() {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            _ins = this;

            AddCovalenceCommand(new []{
                "restrain",
                "unrestrain",

                "cuffsmenu",
                "cuffskey",
                "cuffkeys",
                "cuffkey",
                "cuffs",

                "cuffsbot"
            },"RestrainCmd");

            AddCovalenceCommand(new []{"rustycuffs.ui_btn_callback"},"UIBtnCallback");

            foreach(var perm in perms.Values){
                permission.RegisterPermission(perm, this);
            }
        }

        private void OnServerInitialized() {
            ConsoleNetwork.BroadcastToAllClients($"cinematic_stop");

            foreach(IPlayer pr in players.Connected){
                if(storedData.restrained.Keys.Contains(pr.Id)){
                    DisableUserInput(pr.Object as BasePlayer);
                }
            }

            foreach (var player in BasePlayer.activePlayerList){
                ConsoleNetwork.BroadcastToAllClients($"cinematic_stop {player.UserIDString}");
            }

            timer.Every(20f,() => {
                // Puts("Syncing handcuffs aimation state al all clients");
                foreach(var id in storedData.restrained.Keys){
                    PlayNetworkAnimation(id,$"cinematic_play idle_stand_handcuff {id}");
                }
            });
        }

        private void Unload() {
            RestrainInspector[] inspectors = UnityEngine.Object.FindObjectsOfType<RestrainInspector>();
            foreach (RestrainInspector inspector in inspectors)inspector.Remove();

            ForceLocation[] forceLocations = UnityEngine.Object.FindObjectsOfType<ForceLocation>();
            foreach (ForceLocation forceLocation in forceLocations)forceLocation.Remove();

            AntiHack[] antihacks = UnityEngine.Object.FindObjectsOfType<AntiHack>();
            foreach (AntiHack antihack in antihacks)antihack.Remove();

            foreach (var player in BasePlayer.activePlayerList){      
                if(userUIContainers.ContainsKey(player.UserIDString)){
                    userUIContainers[player.UserIDString].Progress.Destroy();
                    userUIContainers[player.UserIDString].Menu.Destroy();
                }

                if(escortingUsers.ContainsKey(player)){
                    SendMessage(player,new[]{"scriptreload"});
                    StopEscorting(player,Vector3.zero,true);
                }
            }

            foreach(IPlayer pr in players.Connected){
                if(storedData.restrained.Keys.Contains(pr.Id)){
                    EnableUserInput(pr.Object as BasePlayer);
                }
            }

            SaveData();

            _ins = null;
        }

        #endregion

        #region chat command

        private void RestrainCmd(IPlayer player, string command, string[] args){
            if(!player.HasPermission(perms["admin"])){
                SendMessage(player,new[]{"error_noperms"});
                return;
            }

            BasePlayer bplayer = player.Object as BasePlayer;
            UIContainer UICont;

            string name = string.Join(" ", args);
            BasePlayer target = null;

            if(name == "")target = bplayer;

            if(target == null){
                if(!FindPlayer(name,player,command,ref args,ref target))return;
            }

            if(!userUIContainers.ContainsKey(bplayer.UserIDString)){
                UICont = new UIContainer(bplayer,target);

                userUIContainers[bplayer.UserIDString] = UICont;
            }
            else
            {
                UICont = userUIContainers[bplayer.UserIDString];
            }

            switch(command.ToLower()){
                case "cuffs":
                case "givecuffs":
                    GiveItem(target,CreateCuffs(1));

                    SendMessage(player,new[]{"givecuffs",target.displayName});
                    PlayEffect(target,"assets/prefabs/weapons/arms/effects/pickup_item.prefab");

                    SendMessage(target,new[]{"givecuffs_tgt"});
                break;
                case "cuffskey":
                case "cuffkeys":
                case "cuffkey":
                    Item key = CreateCuffsKey(target.displayName);
                    storedData.keys[key.uid.Value] = target.UserIDString;
                    GiveItem(bplayer,key);

                    SendMessage(player,new[]{"keycreated",target.displayName});
                    // SendMessage(target,new[]{"givekey_tgt"});

                    PlayEffect(player,"assets/prefabs/weapons/arms/effects/pickup_item.prefab");
                break;
                case "cuffsmenu":
                    if(!IsRestrained(target)){
                        SendMessage(player,new[]{"error_not_restrained",target.displayName});

                        return;
                    }

                    if(bplayer == target){
                        SendMessage(player,new[]{"error_select_self"});
                        break;
                    }

                    UICont.UpdateTarget(target);

                    if(!PlayerSelect(bplayer,target,false)){
                        SendMessage(player,new[]{"error_tgt_selected",target.displayName});
                    }
                break;
                case "restrain":
                    if(IsRestrained(target)){
                        SendMessage(player,new[]{"error_tgt_restrained",target.displayName});
                        return;
                    }

                    if(Restrain(target,bplayer)){
                        SendMessage(player,new[]{"restrained",target.displayName});
                        SendMessage(target,new[]{"restrained_tgt"});

                        PlayEffect(target,"assets/prefabs/building/wall.frame.fence/effects/chain-link-fence-deploy.prefab",true);
                    }
                break;
                case "unrestrain":
                    if(!IsRestrained(target)){
                        SendMessage(player,new[]{"error_not_restrained",target.displayName});
                        return;
                    }

                    if(Unrestrain(target)){
                        SendMessage(player,new[]{"unrestrained",target.displayName});
                        SendMessage(target,new[]{"unrestrained_tgt"});

                        PlayEffect(target,"assets/prefabs/deployable/signs/effects/large-banner-deploy.prefab",true);
                    };

                break;
                case "cuffsbot":
                    CreateBot(bplayer.transform.position);
                    SendMessage(player,new[]{"bot_created"});
                break;
            }
        }

        #endregion

        #region hooks

        private void OnPlayerInput(BasePlayer player, InputState state){
            if(state.WasJustPressed(BUTTON.RELOAD)){
                if(!listenToUsers.ContainsKey(player.UserIDString))return;

                if(!permission.UserHasPermission(player.UserIDString, perms["use"])){
                    SendMessage(player,new[]{"error_noperms_cuffs"});
                    return;
                }

                // player.SetParent(null,true,true);

                string item = listenToUsers[player.UserIDString];

                BasePlayer target;
                UIContainer UICont = null;

                target = RayToPlayer(player);
                if(escortingUsers.ContainsKey(player)){
                    target = escortingUsers[player];
                }

                if(target == null)return;

                if(IsNPC(target) && !config.npcsEnabled){
                    SendMessage(player,new[]{"error_restrain_npc"});
                    return;
                }

                // Puts($"ID: {player.UserIDString}");

                if(!userUIContainers.ContainsKey(player.UserIDString)){
                    UICont = new UIContainer(player,target);

                    userUIContainers[player.UserIDString] = UICont;
                    // Puts($"ID: {player.UserIDString}");

                    // Puts($"New Cont - Owner:{UICont.player.displayName} - NPC:{UICont.target.displayName}");
                }
                else
                {
                    UICont = userUIContainers[player.UserIDString];
                }

                UICont.UpdateTarget(target);
                // BroadcastPlayer(player,$"UI Cont - Owner:{UICont.player.displayName} - NPC:{UICont.target.displayName}");

                float dist = Vector3.Distance(player.transform.position,target.transform.position);
                if(dist > config.restrainDist && !escortingUsers.ContainsKey(player))return;

                switch(item){
                    case "cuffs":
                        if(storedData.restrained.ContainsKey(player.UserIDString)){
                            SendMessage(player,new[]{"error_restrained_cuff_use"});
                            return;
                        }

                        // Puts($"Use Key Pressed: Cuffs");

                        if(userTimers.ContainsKey(player.UserIDString))userTimers[player.UserIDString].Destroy();

                        if(IsRestrained(target)){
                            if(Interface.CallHook("CanCuffsPlayerUseCuffs", target, player) != null) return;

                            if(permission.UserHasPermission(player.UserIDString, perms["unlimited"])){
                                if(!permission.UserHasPermission(player.UserIDString, perms["usecuffkeys"])){
                                    SendMessage(player,new[]{"error_noperms_keys"});
                                    return;
                                }

                                if(!PlayerSelect(player,target) && !PlayerDeselect(player)){
                                    // BroadcastPlayer(player,$"{target.displayName} is already selected");
                                }

                                Interface.CallHook("OnCuffsPlayerUseCuffs", target, player);

                                return;
                            }
                            else
                            {
                                SendMessage(player,new[]{"error_tgt_restrained",target.displayName});
                                return;
                            }
                        }
                        else
                        {
                            if(escortingUsers.ContainsKey(player)){
                                if(!PlayerSelect(player,target)){
                                    SendMessage(player,new[]{"error_tgt_selected",target.displayName});
                                }
                                return;
                            }
                        }

                        if(player.GetParentEntity() != null) {
                            SendMessage(player,new[]{"error_static_ground"});
                            return;
                        }

                        if(player == target) {
                            SendMessage(player,new[]{"error_restrain_self"});
                            return;
                        }

                        if(Interface.CallHook("CanCuffsPlayerStartRestrain", target, player) != null)return;

                        int complete = 0;
                        float duration = config.restrainTime;
                        float steps = 10;
                        // Timer toktoktok = null;

                        // being restrained
                        UICont.Progress.Draw();

                        SendMessage(target,new[]{"restraining_tgt"});

                        userTimers[player.UserIDString] = timer.Every((duration/steps),() => {
                            complete++;

                            if(complete > steps){
                                StopProgress(player,UICont);
                                if(storedData.restrained.ContainsKey(target.UserIDString)){
                                    SendMessage(player,new[]{"error_tgt_restrained",target.displayName});
                                    return;
                                };

                                Item cuffs = null;

                                foreach(Item cItem in player.inventory.containerBelt.itemList){
                                    if(cItem.info.shortname == cuffsItemShortname && cItem.skin == cuffsSkinID){
                                        cuffs = cItem;
                                        break;
                                    }
                                }

                                if(cuffs == null){
                                    SendMessage(player,new[]{"error_cuffs_missing"});
                                    return;
                                }

                                if(!permission.UserHasPermission(player.UserIDString, perms["unlimited"])){
                                    if(cuffs.amount > 1){
                                        cuffs.MarkDirty();
                                        cuffs.amount--;
                                    }
                                    else
                                    {
                                        cuffs.Remove();
                                        cuffs.DoRemove();
                                    }

                                    Item key = CreateCuffsKey(target.displayName);
                                    storedData.keys[key.uid.Value] = target.UserIDString;
                                    GiveItem(player,key);
                                }

                                if(Restrain(target,player)){
                                    SendMessage(player,new[]{"restrained",target.displayName});
                                    SendMessage(target,new[]{"restrained_tgt"});

                                    PlayEffect(target,"assets/prefabs/building/wall.frame.fence/effects/chain-link-fence-deploy.prefab",true);
                                }

                                storageChanged = true;

                                Interface.CallHook("OnCuffsPlayerUseCuffs", target, player);

                                // userTimers[player.UserIDString].Destroy();
                                return;
                            }

                            target = RayToPlayer(player);
                            if(target != null)dist = Vector3.Distance(player.transform.position,target.transform.position);
                            if(target == null || dist > config.restrainDist){
                                StopProgress(player,UICont);
                                return;
                            }

                            UICont.Progress.Update((complete/steps));
                        });
                    break;
                    case "key":
                        if(!permission.UserHasPermission(player.UserIDString, perms["usecuffkeys"])){
                            SendMessage(player,new[]{"error_noperms_keys"});
                            return;
                        }
                        
                        if(Interface.CallHook("CanCuffsPlayerUseKey", target, player) != null)return;

                        if(storedData.restrained.ContainsKey(player.UserIDString)){
                            SendMessage(player,new[]{"error_restrained_cuff_use"});
                            return;
                        }

                        // Puts($"Use Key Pressed: Key");

                        if(!IsRestrained(target)){
                            SendMessage(player,new[]{"error_not_restrained",target.displayName});
                            return;
                        }

                        Item activeItem = player.GetActiveItem();

                        if(!storedData.keys.ContainsKey(activeItem.uid.Value) || storedData.keys[activeItem.uid.Value] != target.UserIDString){
                            SendMessage(player,new[]{"error_wrong_key",target.displayName});
                            return;
                        }

                        if(!PlayerSelect(player,target)){
                            SendMessage(player,new[]{"error_tgt_selected",target.displayName});
                            return;
                        }

                        Interface.CallHook("OnCuffsPlayerUseKey", target, player);
                    break;
                }
            }

            if(state.WasJustReleased(BUTTON.RELOAD)){
                if(!listenToUsers.ContainsKey(player.UserIDString) || !userTimers.ContainsKey(player.UserIDString) || !userUIContainers.ContainsKey(player.UserIDString))return;
                string item = listenToUsers[player.UserIDString];
                
                switch(item){
                    case "cuffs":
                        // Puts($"Use Key Released: Cuffs");

                        UIContainer UICont = userUIContainers[player.UserIDString];
                        StopProgress(player,UICont);
                    break;
                    case "key":
                        // Puts($"Use Key Released: Key");

                        
                    break;
                }
            }
        }

        void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem){
            listenToUsers.Remove(player.UserIDString);
            UIContainer UICont = null;

            if(userUIContainers.ContainsKey(player.UserIDString)){
                UICont = userUIContainers[player.UserIDString];
                StopProgress(player,UICont);
            }

            if(oldItem != null && oldItem.skin == cuffsSkinID){
                
            }

            // check newly selected item
            if(newItem != null && newItem.skin == cuffsSkinID){
                listenToUsers.Add(player.UserIDString,"cuffs");
                return;
            }

            if(newItem != null && newItem.info.itemid == -1112793865 && newItem.name != ""){
                listenToUsers.Add(player.UserIDString,"key");
                // Puts($"key {newItem.name}");
                return;
            }
        }

        private void OnPlayerRevive(BasePlayer reviver, BasePlayer player){
            if(storedData.restrained.ContainsKey(player.UserIDString))PlayNetworkAnimation(player.UserIDString,$"cinematic_play idle_stand_handcuff {player.UserIDString}");
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo info){
            listenToUsers.Remove(player.UserIDString);

            if(storedData.restrained.ContainsKey(player.UserIDString)){
                if(config.returnCuffs && !permission.UserHasPermission(storedData.restrained[player.UserIDString], perms["unlimited"])){
                    DropItem(CreateCuffs(),player.transform.position);
                }

                Unrestrain(player);
            }

            if(escortingUsers.ContainsKey(player)){
                StopEscorting(player,Vector3.zero);
            }
        }

        void OnPlayerSleepEnded(BasePlayer player){
            if(!storedData.restrained.ContainsKey(player.UserIDString))return;

            SendMessage(player,new[]{"restrained_tgt"});
            timer.In(0.5f,() => {
                Restrain(player);
            });
        }

        void OnPlayerConnected(BasePlayer player){
            if(!storedData.restrained.ContainsKey(player.UserIDString))return;
            listenToUsers.Remove(player.UserIDString);
            EnableUserInput(player);
        }

        void OnPlayerDisconnected(BasePlayer player){
            if(userUIContainers.ContainsKey(player.UserIDString)){
                userUIContainers[player.UserIDString].Progress.Destroy();
                userUIContainers[player.UserIDString].Menu.Destroy();

                userUIContainers.Remove(player.UserIDString);
            }

            if(escortingUsers.ContainsKey(player)){
                StopEscorting(player,Vector3.zero);
            }

            if(escortingUsers.ContainsValue(player)){
                BasePlayer p = escortingUsers.FirstOrDefault(x => x.Value == player).Key;
                StopEscorting(p,Vector3.zero,true);
                // EnableUserInput(player);
            }
        }

        private object CanLootPlayer(BasePlayer target, BasePlayer looter){
            if(storedData.restrained.ContainsKey(looter.UserIDString))return false;
            if (looter.GetComponent<RestrainInspector>() == null){
                return null;
            }

            return true;
        }

        private object CanLootEntity(BasePlayer player, StorageContainer container){
            if(storedData.restrained.ContainsKey(player.UserIDString))return false;
            return null;
        }
        private object CanLootEntity(BasePlayer player, LootableCorpse container){
            if(storedData.restrained.ContainsKey(player.UserIDString))return false;
            return null;
        }
        private object CanLootEntity(BasePlayer player, DroppedItemContainer container){
            if(storedData.restrained.ContainsKey(player.UserIDString))return false;
            return null;
        }

        private object CanPickupEntity(BasePlayer player, BaseCombatEntity ent){
            if(storedData.restrained.ContainsKey(player.UserIDString))return false;
            return null;
        }

        private object CanMountEntity(BasePlayer player, BaseMountable mount){
            if(storedData.restrained.ContainsKey(player.UserIDString) && !chairEnts.Contains(mount))return false;
            if(escortingUsers.ContainsKey(player)){
                SendMessage(player,new[]{"error_mount_escorting"});
                return false;
            }
            return null;
        }

        // object CanDismountEntity(BasePlayer player, BaseMountable entity){
        //     if(storedData.restrained.ContainsKey(player.UserIDString))return false;
        //     return null;
        // }

        private object CanUnlock(BasePlayer player, BaseLock baseLock){
            if(storedData.restrained.ContainsKey(player.UserIDString))return false;
            return null;
        }

        private void OnServerCommand(ConsoleSystem.Arg arg){
            if (arg.cmd.FullName == "inventory.endloot")
            {
                BasePlayer player = arg.Player();
                player.GetComponent<RestrainInspector>()?.Remove();
            }
        }

        private object CanSpectateTarget(BasePlayer player, string name){
            if(usersInputDisabled.Contains(player))return false;
            return null;
        }

        // plugin hooks - credit NoEscape
        object CanTeleport (BasePlayer player){
            return IsRestrained(player)?"Can not use this command while restrained":null;
        }

        object canTeleport (BasePlayer player){
            return IsRestrained(player)?"Can not use this command while restrained":null;
        }

        object CanGridTeleport (BasePlayer player){
            return IsRestrained(player)?"Can not use this command while restrained":null;
        }

        #endregion

        #region UI

        private void UIBtnCallback(IPlayer player, string command, string[] args){
            BasePlayer bplayer = player.Object as BasePlayer;
            command = args[0];
            UIContainer UICont = userUIContainers[player.Id.ToString()];
            Item key = null;

            // BroadcastPlayer(bplayer,$"{command} - Owner:{UICont.player.displayName} - NPC:{UICont.target.displayName}");

            switch(command.ToLower()){
                case "close":
                    PlayerDeselect(bplayer);
                break;
                case "viewinventory":
                    PlayerDeselect(bplayer);
                    if(StartInspecting(UICont.target,bplayer)){
                        PlayEffect(player,"assets/prefabs/misc/summer_dlc/beach_chair/effects/beach-parasol-deploy.prefab",true);
                    }
                break;
                case "execute":
                    PlayerDeselect(bplayer);
                    if(Interface.CallHook("CanCuffsPlayerExecute", UICont.target, bplayer) != null) break;

                    PlayEffect(UICont.target,"assets/bundled/prefabs/fx/player/gutshot_scream.prefab",true);
                    PlayEffect(UICont.target,"assets/bundled/prefabs/fx/takedamage_generic.prefab");
                    PlayEffect(UICont.target,"assets/bundled/prefabs/fx/headshot.prefab",true);

                    UICont.target.Hurt(100, Rust.DamageType.Stab);

                    Interface.CallHook("OnCuffsPlayerExecute", UICont.target, bplayer);
                break;
                case "escort":
                    PlayerDeselect(bplayer);

                    if(bplayer.GetParentEntity() != null) {
                        SendMessage(player,new[]{"error_static_ground"});
                        PlayEffect(player,"assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
                        return;
                    }

                    if(UICont.target == bplayer){
                        SendMessage(player,new[]{"error_escort_self"});
                        break;
                    }

                    if(!escortingUsers.ContainsKey(bplayer)){
                        if(IsViewObstructed(bplayer,obstructionMask)){
                            SendMessage(player,new[]{"error_escort_view_obstructed"});
                            PlayEffect(player,"assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
                            break;
                        }

                        StartEscorting(UICont.target,bplayer);
                        PlayEffect(UICont.target,"assets/prefabs/deployable/small stash/effects/small-stash-deploy.prefab",true);
                    }
                    else
                    {
                        if(IsViewObstructed(bplayer,obstructionMask)){
                            SendMessage(player,new[]{"error_escort_stop_view_obstructed"});
                            PlayEffect(player,"assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
                            break;
                        }

                        StopEscorting(bplayer,Vector3.zero);
                        PlayEffect(UICont.target,"assets/prefabs/deployable/sleeping bag/effects/sleeping-bag-deploy.prefab",true);
                    }
                break;
                case "createkey":
                    PlayerDeselect(bplayer);
                    if(Interface.CallHook("CanCuffsPlayerCreateKey", UICont.target, bplayer) != null) break;

                    key = CreateCuffsKey(UICont.target.displayName);
                    storedData.keys[key.uid.Value] = UICont.target.UserIDString;
                    GiveItem(bplayer,key);

                    SendMessage(player,new[]{"keycreated",UICont.target.displayName});

                    PlayEffect(player,"assets/prefabs/weapons/arms/effects/pickup_item.prefab");

                    Interface.CallHook("OnCuffsPlayerCreateKey", UICont.target, bplayer);
                    break;
                break;
                case "unrestrain":
                    PlayerDeselect(bplayer);
                    if(bplayer.GetParentEntity() != null) {
                        SendMessage(player,new[]{"error_static_ground"});

                        PlayEffect(player,"assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
                        return;
                    }

                    if(IsViewObstructed(bplayer,obstructionMask)){
                        SendMessage(player,new[]{"error_unrestrain_view_obstructed"});
                        PlayEffect(player,"assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
                        break;
                    }

                    if(!permission.UserHasPermission(bplayer.UserIDString, perms["unlimited"])){
                        key = null;

                        foreach(Item item in bplayer.inventory.containerBelt.itemList){
                            if(storedData.keys.ContainsKey(item.uid.Value) && storedData.keys[item.uid.Value] == UICont.target.UserIDString){
                                key = item;
                                break;
                            }
                        }

                        if(key == null){
                            SendMessage(player,new[]{"error_key_missing"});
                            PlayEffect(player,"assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
                            break;
                        }

                        key.Remove();
                        key.DoRemove();

                        if(config.returnCuffs){
                            GiveItem(bplayer,CreateCuffs());
                        }
                    }

                    StopEscorting(bplayer,Vector3.zero);
                    
                    if(Unrestrain(UICont.target)){
                        SendMessage(player,new[]{"unrestrained",UICont.target.displayName});
                        SendMessage(UICont.target,new[]{"unrestrained_tgt"});

                        PlayEffect(UICont.target,"assets/prefabs/deployable/signs/effects/large-banner-deploy.prefab",true);
                    }

                    UICont.UpdateTarget(null);
                break;
            }

            // PlayEffect(player,"assets/prefabs/tools/detonator/effects/attack.prefab");
            // PlayEffect(player,"assets/prefabs/deployable/dropbox/effects/submit_items.prefab");

            // Puts($"Here! {command}");
        }

        public class UIContainer {
            // Yes I know I should have built this class differently, I will refactor next update.
            public static string panel_overlay_cuffs_id = "panel_overlay_cuffs_id";
            public static string panel_overlay_menu_id = "panel_overlay_menu_id";

            public BasePlayer player;
            public BasePlayer target;

            public readonly ProgressBar Progress = new ProgressBar();
            public readonly DynamicMenu Menu = new DynamicMenu();

            public UIContainer(BasePlayer p, BasePlayer t){
                player = p;
                target = t;

                Update();
            }

            public void Update() {
                Progress.Update(player,target);
                Menu.Update(player,target);
            }

            public void UpdateTarget(BasePlayer t) {
                target = t;
                Update();
            }

            public class ProgressBar {
                private CuiElementContainer parentContainer;
                private string Name = "progress";
                private string Parent;

                private BasePlayer player;
                private BasePlayer target;

                public void Update(BasePlayer p, BasePlayer t) {
                    player = p;
                    target = t;
                }

                public void Draw(){
                    Destroy();
                    parentContainer = new CuiElementContainer();

                    var background = parentContainer.Add(new CuiPanel {
                        Image = {
                            Color = $"1 0 0 0",
                        },
                        RectTransform = {
                            AnchorMin = $"0.5 0.5",
                            AnchorMax = $"0.5 0.5",

                            OffsetMin = $"{-90} {-16 + 4}",
                            OffsetMax = $"{90} {16 + 4}"
                        },
                    },"Hud",panel_overlay_cuffs_id);

                    Parent = background;

                    CuiElement title = new CuiElement {
                        Name = "title",
                        Parent = background,
                        Components = {
                            new CuiTextComponent  {
                                Text = $"Restraining",
                                FontSize = 16,
                                Color = "1.0 1.0 1.0 1.0",
                                Align = TextAnchor.UpperCenter
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = $"0 1",
                                AnchorMax = $"1 1",

                                OffsetMin = "0 -30",
                                OffsetMax = "0 0",
                            }
                        }
                    };
                    parentContainer.Add(title);

                    CuiHelper.AddUi(player, parentContainer);
                    UpdateFill(0);
                }

                public void UpdateFill(double amount = 0){
                    string el_name = $"{Name}_bar";
                    CuiHelper.DestroyUi(player,el_name);

                    CuiElementContainer container = new CuiElementContainer();

                    CuiElement progress_bg = new CuiElement {
                        Name = el_name,
                        Parent = Parent,
                        Components = {
                            new CuiImageComponent {
                                Color = "1 1 1 0.5" // "0 0 0 0.6" - nice black,
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = $"0 0",
                                AnchorMax = $"1 0",

                                OffsetMin = "0 0",
                                OffsetMax = "0 10",
                            }
                        }
                    };
                    container.Add(progress_bg);

                    CuiElement progress_fill = new CuiElement {
                        Name = el_name+"_fill",
                        Parent = progress_bg.Name,
                        Components = {
                            new CuiImageComponent {
                                Color = "1 1 1 1" // "0 0 0 0.6" - nice black,
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = $"0 0",
                                AnchorMax = $"{amount} 1",

                                OffsetMin = "0 0",
                                OffsetMax = "0 0",
                            }
                        }
                    };
                    container.Add(progress_fill);

                    parentContainer.AddRange(container);

                    CuiHelper.AddUi(player, container);
                }

                public void Update(float amount = 0){
                    UpdateFill(amount);
                }

                public void Destroy(){
                    parentContainer = new CuiElementContainer();
                    CuiHelper.DestroyUi(player,panel_overlay_cuffs_id);
                }
            }

            public class DynamicMenu {
                private CuiElementContainer parentContainer;
                private string Name = "menu";

                private BasePlayer player;
                private BasePlayer target;

                public void Update(BasePlayer p, BasePlayer t) {
                    player = p;
                    target = t;
                }

                public void Draw(){
                    List<string[]> buttons = new List<string[]>(){
                        new[]{"Execute","execute","0.1 0.1 0.1 0.8",_ins.perms["execute"]},
                        new[]{"View Inventory","viewinventory","0.1 0.1 0.1 0.8",!_ins.escortingUsers.ContainsKey(player)?_ins.perms["viewinventory"]:"FAKE_PERM_ASDF"},
                        new[]{"Get Key","createkey","0.1 0.1 0.1 0.8",!_ins.escortingUsers.ContainsKey(player)?_ins.perms["createkey"]:"FAKE_PERM_ASDF"},
                        new[]{(target != null && _ins.escortingUsers.ContainsKey(player))?"Stop Escorting":"Escort","escort","0.1 0.1 0.1 0.8",_ins.perms["escort"]},
                        new[]{"Unrestrain","unrestrain","0.1 0.1 0.1 0.8",_ins.perms["unrestrain"]},
                        new[]{"Close","close","1 0 0 0.8",_ins.perms["use"]}, // dont change this or people will get stuck
                    };

                    for (int indx = buttons.Count - 1; indx >= 0; indx--){
                        if(!_ins.permission.UserHasPermission(player.UserIDString, buttons[indx][3]))buttons.RemoveAt(indx);
                    }

                    Destroy();
                    parentContainer = new CuiElementContainer();

                    var panel = parentContainer.Add(new CuiPanel {
                        Image = {
                            Color = $"1 0 0 0",
                        },
                        RectTransform = {
                            AnchorMin = $"0 0",
                            AnchorMax = $"1 1",

                            
                        },
                        CursorEnabled = true
                    },"Overlay",panel_overlay_menu_id);

                    CuiElement background = new CuiElement {
                        Name = $"{Name}_bg",
                        Parent = panel,
                        Components = {
                            new CuiButtonComponent {
                                Color = "1 0 0 0",
                                Command = $"rustycuffs.ui_btn_callback close",
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = $"0 0",
                                AnchorMax = $"1 1",

                                OffsetMin = $"0 0",
                                OffsetMax = $"0 0",
                            }
                        },
                    };
                    parentContainer.Add(background);

                    CuiElement elements = new CuiElement {
                        Name = $"{Name}_btns_container",
                        Parent = background.Name,
                        Components = {
                            new CuiImageComponent {
                                Color = "0 0 0 0.6" // "0 0 0 0.6" - nice black,
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = "0.5 0.5",
                                AnchorMax = $"0.5 0.5",

                                OffsetMin = $"{-100} -{(((6+32) * (double.Parse(buttons.Count.ToString())/2)) + 6) + 10}",
                                OffsetMax = $"{100} {(((6+32) * (double.Parse(buttons.Count.ToString())/2)) + 6) - 10}",
                            }
                        }
                    };
                    parentContainer.Add(elements);

                    CuiElement title = new CuiElement {
                        Name = $"{Name}_title",
                        Parent = elements.Name,
                        Components = {
                            new CuiTextComponent  {
                                Text = target.displayName,
                                FontSize = 22,
                                Color = "1.0 1.0 1.0 1.0",
                                Align = TextAnchor.UpperCenter
                            },
                            new CuiOutlineComponent {
                                Color = "0 0 0 1",
                                Distance = "1 -1"
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = $"0 1",
                                AnchorMax = $"1 1",

                                OffsetMin = "0 -60",
                                OffsetMax = "0 30",
                            }
                        }
                    };
                    parentContainer.Add(title);

                    int i = 0;
                    foreach(var cmds in buttons){
                        OptionBtn(cmds[0],cmds[1],cmds[2],i);
                        i++;
                    }

                    CuiHelper.AddUi(player, parentContainer);
                    _ins.PlayEffect(player,"assets/prefabs/tools/detonator/effects/attack.prefab");
                }

                private void OptionBtn (string label, string command, string color, float posy) {
                    double height = 32;
                    double gap = 6;
                    double offset = ((height+gap) * posy);
                    double padding = 8;

                    CuiElement btn_el = new CuiElement {
                        Name = $"{Name}_{posy}",
                        Parent = $"{Name}_btns_container",
                        Components = {
                            new CuiButtonComponent {
                                Color = color,
                                Command = $"rustycuffs.ui_btn_callback {command}",
                            },
                            new CuiRectTransformComponent {
                                AnchorMin = $"0 1",
                                AnchorMax = $"1 1",

                                OffsetMin = $"{padding} -{height + (offset + padding)}",
                                OffsetMax = $"-{padding} {0 - (offset + padding)}",
                            }
                        },
                    };
                    parentContainer.Add(btn_el);

                    CuiElement label_el = new CuiElement {
                        Name = $"{Name}_{posy}_label",
                        Parent = btn_el.Name,
                        Components = {
                            new CuiTextComponent  {
                                Text = label,
                                FontSize = 16,
                                Color = "1.0 1.0 1.0 1.0",
                                Align = TextAnchor.MiddleCenter
                            },
                            // new CuiOutlineComponent {
                            //     Color = "0 0 0 1",
                            //     Distance = "1 -1"
                            // },
                            new CuiRectTransformComponent {
                                AnchorMin = $"0 0",
                                AnchorMax = $"1 1",
                            }
                        }
                    };
                    parentContainer.Add(label_el);
                }

                public void Destroy(){
                    parentContainer = new CuiElementContainer();
                    CuiHelper.DestroyUi(player,panel_overlay_menu_id);
                }
            }
        }

        #endregion

        #region API

        private bool API_IsRestrained(BasePlayer player) => IsRestrained(player);
        private Item API_CreateCuffs(int amount) => CreateCuffs(amount);
        private Item API_CreateCuffsKey(BasePlayer player){
            Item key = CreateCuffsKey(player.displayName);
            storedData.keys[key.uid.Value] = player.UserIDString;

            storageChanged = true;

            return key;
        }

        private bool API_Restrain(BasePlayer target, BasePlayer player) => Restrain(target,player);
        private bool API_Unrestrain(BasePlayer target) => Unrestrain(target);

        #endregion

        #region methods

        private bool IsNPC(BasePlayer player){
            if (player == null) return false;
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L))return true;
            return false;
        }

        private bool IsViewObstructed(BasePlayer player, int mask){
            Vector3 padding = player.eyes.MovementForward() * 0.2f;
            Vector3 startPos = (padding+player.eyes.transform.position) + Vector3.up * 1.5f;
            Vector3 endPos = (startPos + player.eyes.MovementForward() * (config.escortDist * 0.9f));

            bool los = GamePhysics.CheckCapsule(startPos, endPos, 0.4f, mask);

            // player.SendConsoleCommand("ddraw.arrow", 0.3f, los?Color.red:Color.cyan, startPos , endPos, 0.5f);

            return los;
        }

        private bool IsRestrained(BasePlayer target){
            if(storedData.restrained.ContainsKey(target.UserIDString))return true;
            return false;
        }

        private bool Restrain(BasePlayer target, BasePlayer player = null){
            if(!storedData.restrained.ContainsKey(target.UserIDString)){
                if(Interface.CallHook("CanCuffsPlayerRestrain", target, player) != null)return false;

                storageChanged = true;
            }

            listenToUsers.Remove(target.UserIDString);
            target.EnsureDismounted();

            target.GetActiveItem()?.Drop(target.eyes.position,Vector3.zero);
            // target.SendNetworkUpdate();

            if(userUIContainers.ContainsKey(target.UserIDString)){
                userUIContainers[target.UserIDString].Progress.Destroy();
                userUIContainers[target.UserIDString].Menu.Destroy();
            }

            if(escortingUsers.ContainsKey(target)){
                StopEscorting(target,Vector3.zero);
            }

            DisableUserInput(target);

            if(player != null)storedData.restrained.Add(target.UserIDString,player.UserIDString);

            if(!target.IsSleeping())PlayNetworkAnimation(target,$"cinematic_play idle_stand_handcuff {target.UserIDString}");

            Interface.CallHook("OnCuffsPlayerRestrained", target, player);

            return true;
        }

        private bool Unrestrain(BasePlayer target){
            if(storedData.restrained.ContainsKey(target.UserIDString)){
                storageChanged = true;
            }

            BasePlayer player = escortingUsers.FirstOrDefault(x => x.Value == target).Key;

            if(Interface.CallHook("CanCuffsPlayerUnrestrain", target) != null)return false;
            
            if(player != null){
                StopEscorting(player,Vector3.zero);
            }

            EnableUserInput(target);

            if(!target.IsSleeping())PlayNetworkAnimation(target,$"cinematic_stop {target.UserIDString}");
            storedData.restrained.Remove(target.UserIDString);

            Interface.CallHook("OnCuffsPlayerUnrestrained", target);

            return true;
        }

        private bool PlayerSelect(BasePlayer player, BasePlayer target, bool limitDist = true){
            if(selectedUsers.ContainsKey(player) || selectedUsers.ContainsValue(target)){
                return false;
            }

            object obj = Interface.CallHook("CanCuffsPlayerSelect", target, player);
            if (obj is bool){
                return (bool)obj;
            }

            UIContainer UICont = userUIContainers[player.UserIDString];

            if(!escortingUsers.ContainsKey(player) && limitDist)userTimers[$"{player.UserIDString}_player_selected"] = timer.Every(0.5f,() => {
                float dist = Vector3.Distance(player.transform.position,target.transform.position);
                if(dist > config.restrainDist){
                    PlayerDeselect(player);
                    return;
                }
            });

            selectedUsers[player] = target;
            UICont.Menu.Draw();
            PlayEffect(player,"assets/prefabs/tools/detonator/effects/attack.prefab");

            Interface.CallHook("OnCuffsPlayerSelected", target, player);

            return true;
        }

        private bool PlayerDeselect(BasePlayer player){
            if(selectedUsers.ContainsValue(player)){
                return false;
            }

            UIContainer UICont = userUIContainers[player.UserIDString];

            if(userTimers.ContainsKey($"{player.UserIDString}_player_selected"))userTimers[$"{player.UserIDString}_player_selected"]?.Destroy();

            selectedUsers.Remove(player);
            // UIBtnCallback(player.IPlayer,"",new[]{"close"});

            UICont.Menu.Destroy();
            PlayEffect(player,"assets/prefabs/tools/detonator/effects/attack.prefab");

            return true;
        }

        private bool StartInspecting(BasePlayer target, BasePlayer player){
            object obj = Interface.CallHook("CanCuffsPlayerViewInventory", target, player);
            if (obj is bool){
                return (bool)obj;
            }

            RestrainInspector inspector = player.gameObject.GetComponent<RestrainInspector>();
            inspector?.Remove();

            inspector = player.gameObject.AddComponent<RestrainInspector>();
            inspector.Instantiate(player, target);

            Interface.CallHook("OnCuffsPlayerViewInventory", target, player);

            return true;
        }

        private bool StartEscorting(BasePlayer target, BasePlayer player){
            if(escortingUsers.ContainsKey(player))return false;
            object obj = Interface.CallHook("CanCuffsPlayerEscort",target, player);
            if (obj is bool){
                return (bool)obj;
            }

            EnableUserInput(target);

            target.inventory.containerBelt.capacity = 0;
            target.SendNetworkUpdate();

            player.EnsureDismounted();

            ChairHack chairHack = new ChairHack();
            BaseVehicle chair = chairHack.chair;

            chair.SetParent(player,"collision",false,false);

            chair.transform.position = player.transform.position;
            chair.transform.localPosition += (chairPositionOffset + new Vector3(0,0,config.escortDist));

            chair.SendNetworkUpdateImmediate();

            restrainChairs[target.UserIDString] = chairHack;

            chairHack.mount.MountPlayer(target);

            escortingUsers[player] = target;

            AntiHack antihack = target.gameObject.AddComponent<AntiHack>();
            antihack.Instantiate(player,target);

            Interface.CallHook("OnCuffsPlayerEscort", target, player);

            return true;
        }

        private bool StopEscorting(BasePlayer player, Vector3 pos, bool soft = false){
            if(!escortingUsers.ContainsKey(player))return false;
            BasePlayer target = escortingUsers[player];

            object obj = Interface.CallHook("CanCuffsPlayerEscortStop",target, player);
            if (obj is bool){
                return (bool)obj;
            }

            if(pos == Vector3.zero)pos = player.transform.position + player.eyes.MovementForward() * config.escortDist;
            ChairHack chairHack = restrainChairs[target.UserIDString];

            target.inventory.containerBelt.capacity = 6;
            target.SendNetworkUpdate();

            DestroyChair(chairHack);

            if(soft){
                UnityEngine.Object.Destroy(target.GetComponent<AntiHack>());
                restrainChairs.Remove(target.UserIDString);

                escortingUsers.Remove(player);
                return true;
            }

            ForceLocation forceLocation = target.gameObject.AddComponent<ForceLocation>();
            forceLocation.pos = pos;

            UnityEngine.Object.Destroy(target.GetComponent<AntiHack>());
            restrainChairs.Remove(target.UserIDString);

            timer.In(.3f, () => {
                forceLocation.Remove();

                if(storedData.restrained.ContainsKey(target.UserIDString)){
                    DisableUserInput(target);
                }

                target.OverrideViewAngles(player.viewAngles);
            });

            escortingUsers.Remove(player);

            Interface.CallHook("OnCuffsPlayerEscortStop", target, player);

            return true;
        }

        private void DestroyChair(ChairHack chairHack){
            BaseVehicle chair = chairHack.chair;
            BasePlayer player = chair.GetParentEntity() as BasePlayer;

            Vector3 pos = player.transform.position + player.eyes.MovementForward() * 2;

            chair.transform.position = pos;
            chair.SendNetworkUpdate(BasePlayer.NetworkQueue.UpdateDistance);

            chairHack.Destroy();
        }

        private Item CreateCuffs(int amount = 1){
            Item item = ItemManager.Create(ItemManager.FindItemDefinition(cuffsItemShortname),amount,cuffsSkinID);
            item.name = "Rusty Cuffs";

            return item;
        }

        private Item CreateCuffsKey(string name, int amount = 1){
            Item item = ItemManager.Create(ItemManager.FindItemDefinition(keysItemShortname),amount,0);
            item.name = $"Handcuff Key - {name}";

            return item;
        }

        private void DropItem(Item item, Vector3 pos){
            item.Drop(pos,Vector3.zero);
        }

        private void GiveItem(BasePlayer player, Item item){
            if(!player.inventory.GiveItem(item, player.inventory.containerBelt) && !player.inventory.GiveItem(item, player.inventory.containerMain)){
                DropItem(item,player.eyes.position);
            }
        }

        // testing asset unused
        private BaseEntity CreateBot(Vector3 pos){
            var player = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab",pos).ToPlayer();

            player.Spawn();

            RelationshipManager.ServerInstance.playerToTeam.Remove(player.userID);
            player.ClearTeam();
            RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.CreateTeam();
            RelationshipManager.PlayerTeam playerTeam = team;
            playerTeam.teamLeader = player.userID;

            if (!playerTeam.AddPlayer(player))
            {
                player.currentTeam = playerTeam.teamID;
                playerTeam.members.Add(player.userID);
                player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }


            return player;
        }

        private void BroadcastPlayer(BasePlayer player, string msg, bool prefix = true) => Player.Message(player,$"{(prefix?config.prefix:"")}{msg}",config.icon);
        // private void BroadcastPlayer(IPlayer player, string msg, bool prefix = true) => BroadcastPlayer((BasePlayer)player.Object,msg,prefix);

        // umod compliance
        private void SendMessage(BasePlayer player, string[] args, bool prefix = true) => BroadcastPlayer(player,string.Format(lang.GetMessage(args[0],this),args.Skip(1).ToArray()),prefix);
        // private void SendMessage(BasePlayer player, string[] args, bool prefix = true) => BroadcastPlayer(player,string.Format(lang.GetMessage(messages[args[0]],this),args.Skip(1).ToArray()),prefix);
        
        private void SendMessage(IPlayer player, string[] args, bool prefix = true) => SendMessage((BasePlayer)player.Object,args,prefix);


        private void StopProgress(BasePlayer player, UIContainer cont){
            // Puts($"Progress Cleared");

            if(userTimers.ContainsKey(player.UserIDString)){
                userTimers[player.UserIDString].Destroy();
            }
            userTimers.Remove(player.UserIDString);

            cont.Progress.Destroy();
        }

        private void DisableUserInput(BasePlayer player){
            if(usersInputDisabled.Contains(player))return;
            player.SetParent(null,true,true);

            usersInputDisabled.Add(player);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
        }

        private void EnableUserInput(BasePlayer player){
            if(!usersInputDisabled.Contains(player))return;
            player.SetParent(null,true,true);

            usersInputDisabled.Remove(player);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
        }

        private void PlayNetworkAnimation(BasePlayer bpr, string command){
            // Puts($"Found: {bpr.UserIDString} - {command}");

            if(bpr.IsWounded() || bpr.IsSleeping())return;

            Network.Visibility.Group nGroup = Network.Net.sv.visibility.GetGroup(bpr.transform.position);

            foreach(IPlayer p2 in players.Connected){
                BasePlayer bp2 = p2.Object as BasePlayer;
                if(!Network.Net.sv.visibility.IsInside(nGroup,bp2.transform.position))continue;
                
                // Puts($"{(p2.Object as BasePlayer).displayName} can see {bpr.displayName} over net");

                NetWrite netWrite = Network.Net.sv.StartWrite();
                netWrite.PacketID(Network.Message.Type.ConsoleMessage);
                netWrite.String(ConsoleSystem.BuildCommand(command));
                netWrite.Send(new SendInfo(bp2.net.connection));
            }
        }

        private void PlayNetworkAnimation(string id, string command){
            BasePlayer bpr = null;
            foreach(BasePlayer p1 in BasePlayer.allPlayerList){
                if(p1.UserIDString == id){
                    bpr = p1;
                    break;
                }
            }
            if(bpr == null)return;

            PlayNetworkAnimation(bpr,command);
        }

        public void PlayEffect(BasePlayer player, string prefab, bool global = false){
            var effect = new Effect();
            effect.Init(Effect.Type.Generic, player.transform.position, Vector3.zero);
            effect.pooledString = prefab;

            if(global){
                EffectNetwork.Send(effect);
            }
            else
            {
                EffectNetwork.Send(effect, player.net.connection);
            }
        }
        public void PlayEffect(IPlayer player, string prefab, bool global = false) => PlayEffect((player.Object as BasePlayer),prefab,global);

        private float mdist = 9999f;
        private int generalColl = LayerMask.GetMask("Player (Server)","Construction", "Deployable", "Default", "Prevent Building", "Deployed", "Resource", "Terrain", "World","Tree");

        private bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle) {
            viewAngle = Quaternion.identity;

            if (player.serverInput.current == null)
                return false;

            viewAngle = Quaternion.Euler(player.serverInput.current.aimAngles);

            return true;
        }

        private bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint){
            float closestdist = 999999f;

            Vector3 sourceEye = sourcePos + new Vector3(0f, 1.5f, 0f);
            Ray ray = new Ray(sourceEye, sourceDir * Vector3.forward);
            
            closestHitpoint = sourcePos;
            closestEnt = false;

            foreach (var hit in Physics.RaycastAll(ray, mdist, generalColl)){
                if (hit.collider.GetComponentInParent<TriggerBase>() == null){
                    if (hit.distance < closestdist){
                        closestdist = hit.distance;
                        closestEnt = hit.GetCollider();
                        closestHitpoint = hit.point;
                    }
                }
            }

            if (closestEnt is bool)return false;
            return true;
        }

        // player finder
        public List<BasePlayer> FindPlayers(string nameOrIdOrIp){
            if (string.IsNullOrEmpty(nameOrIdOrIp)) return new List<BasePlayer>();
            return BasePlayer.allPlayerList.Where(p => p && (p.UserIDString == nameOrIdOrIp || p.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase) || (p.IsConnected && p.net.connection.ipaddress.Contains(nameOrIdOrIp)))).ToList();
        }

        public List<BasePlayer> FindPlayersOnline(string nameOrIdOrIp){
            if (string.IsNullOrEmpty(nameOrIdOrIp)) return new List<BasePlayer>();
            return BasePlayer.activePlayerList.Where(p => p && (p.UserIDString == nameOrIdOrIp || p.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase) || (p.IsConnected && p.net.connection.ipaddress.Contains(nameOrIdOrIp)))).ToList();
        }

        private Dictionary<string, List<BasePlayer>> findPlayerMatches = new Dictionary<string, List<BasePlayer>>();
        private Dictionary<string, string[]> findPlayerArgs = new Dictionary<string, string[]>();

        public bool FindPlayer(string name, object player, string command, ref string[] args, ref BasePlayer target){
            BasePlayer bplayer = (player is IPlayer)?(((IPlayer)player).Object as BasePlayer):player as BasePlayer;
            IPlayer iplayer = (player is IPlayer)?(player as IPlayer):(bplayer.IPlayer != null?bplayer.IPlayer:covalence.Players.FindPlayer(bplayer.UserIDString));
            string key = bplayer.UserIDString;

            if(args[0] == "list"){
                if (args.Length == 1){
                    if (!findPlayerMatches.ContainsKey(key) || findPlayerMatches[key] == null){
                        SendMessage(bplayer,new[]{"error_no_list_available",command});
                        return false;
                    }

                    FindPlayerShowMatches(bplayer);
                    return false;
                }

                int num;
                if (int.TryParse(args[1], out num)){
                    if (!findPlayerMatches.ContainsKey(key) || findPlayerMatches[key] == null){
                        SendMessage(bplayer,new[]{"error_no_list_available",command});
                        return false;
                    }

                    if (num > findPlayerMatches[key].Count){
                        SendMessage(bplayer,new[]{"error_invalid_selection",command});

                        FindPlayerShowMatches(bplayer);
                        return false;
                    }

                    args = findPlayerArgs[key];
                    target = findPlayerMatches[key][num - 1];

                    findPlayerArgs.Remove(key);
                    findPlayerMatches.Remove(key);
                    return true;
                }

                // BroadcastPlayer(bplayer,"InvalidArguments");
                return false;
            }
            else
            {   
                if(name == null || name == "")return false;
                List<BasePlayer> players = (List<BasePlayer>)FindPlayers(name);

                switch (players.Count){
                    case 0:
                        SendMessage(bplayer,new[]{"error_no_players_found",name});
                    break;

                    case 1:
                        target = players[0];
                        return true;
                    break;

                    default:
                        SendMessage(bplayer,new[]{"error_multiple_players_found",command,name});

                        if (!findPlayerMatches.ContainsKey(key)){
                            findPlayerMatches.Add(key, players);
                            findPlayerArgs.Add(key, args);
                        }
                        else
                        {
                            findPlayerMatches[key] = players;
                            findPlayerArgs[key] = args;
                        }

                        FindPlayerShowMatches(bplayer);
                    break;
                }

                return false;
            }
        }

        private void FindPlayerShowMatches(BasePlayer player){
            string key = player.UserIDString;

            for (int i = 0; i < findPlayerMatches[key].Count; i++){
                BroadcastPlayer(player,$"{i + 1}. {findPlayerMatches[key][i].displayName}",false);

                if (i == 4 && i < findPlayerMatches[key].Count){
                    SendMessage(player,new[]{"error_too_many_players_found"});
                    break;
                }
            }
        }

        private BasePlayer RayToPlayer(BasePlayer bplayer){
            object closestEnt = null;
            Vector3 closestHitpoint = new Vector3();
            Quaternion currentRot = new Quaternion();
            Quaternion currentRotate = Quaternion.Euler(0f, 45f, 0f);
            Collider currentCollider = null;
            BaseNetworkable currentBaseNet = null;
            Vector3 myPos = bplayer.transform.position;
            BasePlayer target = null;

            if(!TryGetPlayerView(bplayer, out currentRot) || !TryGetClosestRayPoint(myPos, currentRot, out closestEnt, out closestHitpoint)){
                return null;
            }

            currentCollider = closestEnt as Collider;
            if(!(currentCollider is UnityEngine.CapsuleCollider)){
                // Puts($"That isn't a person..");
                return null;
            }

            target = currentCollider.GetComponentInParent<BaseNetworkable>() as BasePlayer;
            if(target == null){
                // Puts($"Bad hit");
                return null;
            }

            return target;
        }

        #endregion

        #region components

        class ChairHack {
            // assets/bundled/prefabs/static/chair.invisible.static.prefab
            // assets/prefabs/deployable/chair/chair.deployed.prefab
            // assets/prefabs/deployable/sofa/sofa.deployed.prefab

            public BaseVehicle chair = null;
            public BaseMountable mount = null;

            public ChairHack(){
                chair = GameManager.server.CreateEntity("assets/prefabs/deployable/sofa/sofa.deployed.prefab") as BaseVehicle;

                UnityEngine.Object.Destroy(chair.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.Destroy(chair.GetComponent<GroundWatch>());

                chair.isMobile = true;
                chair.enableSaving = false;
                // chair.OwnerID = player.userID;

                // vehicle = chair.GetComponent<BaseVehicle>();

                chair.mountPoints.Add(new BaseVehicle.MountPointInfo {
                    pos = -_ins.chairPositionOffset,
                    rot = chair.mountPoints[0].rot,
                    prefab = chair.mountPoints[0].prefab,
                    mountable = chair.mountPoints[0].mountable,
                });

                BaseVehicle.MountPointInfo point = chair.mountPoints[2];

                chair.Spawn();

                mount = point.mountable.GetComponent<BaseMountable>();
                _ins.chairEnts.Add(mount);
                mount.isMobile = true;
            }

            public void Destroy(){
                chair?.Kill();
                _ins.chairEnts.Remove(mount);
            }
        }

        private class ForceLocation : MonoBehaviour {
            internal Vector3 pos = Vector3.zero;
            public BasePlayer target;

            private void Awake() {
                target = GetComponent<BasePlayer>();
            }

            public void Remove() {
                Destroy(this);
            }

            private void FixedUpdate() {
                if (target == null || pos == Vector3.zero)return;
                if (target != null && !target.IsDestroyed){
                    // target.transform.position = pos;
                    target.MovePosition(pos);
                    target.SendNetworkUpdate(BasePlayer.NetworkQueue.UpdateDistance);

                }
            }
        }

        private class AntiHack : MonoBehaviour {
            public BasePlayer player = null;
            public BasePlayer target = null;

            public void Instantiate(BasePlayer player, BasePlayer target){
                this.player = player;
                this.target = target;
            }

            public void Remove() {
                Destroy(this);
            }

            private void FixedUpdate() {
                if (target == null)return;
                if(_ins.IsViewObstructed(player,_ins.baseMask)){
                    _ins.StopEscorting(player,player.transform.position);
                }
            }
        }

        private class RestrainInspector : MonoBehaviour {
            private BasePlayer player;
            private BasePlayer target;
            private int ticks;

            public void Instantiate(BasePlayer player, BasePlayer target){
                this.player = player;
                this.target = target;

                BeginLooting();

                InvokeRepeating("UpdateLoot", 0f, 0.1f);
            }

            private void UpdateLoot(){
                if (!target)
                {
                    return;
                }

                if (!target.inventory)
                {
                    return;
                }

                ticks++;

                if (!player.inventory.loot.IsLooting())
                {
                    BeginLooting();
                }

                player.inventory.loot.SendImmediate();

                player.SendNetworkUpdateImmediate();
            }

            private void StopInspecting(bool forced = false){
                if (ticks < 5 && !forced)
                {
                    return;
                }

                CancelInvoke("UpdateLoot");

                EndLooting();
            }

            private void BeginLooting(){
                player.inventory.loot.Clear();

                if (!target)
                {
                    return;
                }

                if (!target.inventory)
                {
                    return;
                }

                player.inventory.loot.AddContainer(target.inventory.containerMain);
                player.inventory.loot.AddContainer(target.inventory.containerWear);
                player.inventory.loot.AddContainer(target.inventory.containerBelt);
                player.inventory.loot.PositionChecks = false;
                player.inventory.loot.entitySource = target;
                player.inventory.loot.itemSource = null;
                player.inventory.loot.MarkDirty();
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "player_corpse");
                player.SendNetworkUpdateImmediate();
            }

            private void EndLooting(){
                player.inventory.loot.MarkDirty();

                if (player.inventory.loot.entitySource)
                {
                    player.inventory.loot.entitySource.SendMessage("PlayerStoppedLooting", player, SendMessageOptions.DontRequireReceiver);
                }

                foreach (ItemContainer container in player.inventory.loot.containers)
                {
                    if (container != null)
                    {
                        container.onDirty -= player.inventory.loot.MarkDirty;
                    }
                }

                player.inventory.loot.containers.Clear();
                player.inventory.loot.entitySource = null;
                player.inventory.loot.itemSource = null;
            }

            public void Remove(bool forced = false){
                if (ticks < 5 && !forced){
                    return;
                }

                StopInspecting(forced);

                Destroy(this);
            }
        }

        #endregion

        #region DEBUG

        public void jPrint(object type) {
            string jsonString;
            jsonString = JsonConvert.SerializeObject(type);

            Puts(jsonString);
        }

        #endregion
    }
}

// --- End of file: RustyCuffs.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rock-block ---
// --- Original File Path: R/RockBlock/RockBlock.cs ---

﻿using Rust;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Rock Block", "Author Nogrod, Maintainer nivex", "1.1.4")]
    [Description("Blocks players from building in rocks")]
    class RockBlock : RustPlugin
    {
        private ConfigData config;
        private RaycastHit _hit;
        private const string permBypass = "rockblock.bypass";
        private readonly int worldLayer = LayerMask.GetMask("World", "Default");
        private Dictionary<string, string> _displayNames = new Dictionary<string, string>();

        private class ConfigData
        {
            public bool AllowCave { get; set; }
            public bool Logging { get; set; }
            public int MaxHeight { get; set; }
            public bool Kill { get; set; } = true;
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData
            {
                AllowCave = false,
                Logging = true,
                MaxHeight = -1,
                Kill = true
            };
            Config.WriteObject(config, true);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["DistanceTooHigh"] = "Distance to ground too high: {0}",
                ["PlayerSuspected"] = "{0} is suspected of building {1} inside a rock at {2}!"
            }, this);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try { config = Config.ReadObject<ConfigData>(); } catch { }
            if (config == null) LoadDefaultConfig();
            Config.WriteObject(config, true);
        }

        private void Init()
        {            
            permission.RegisterPermission(permBypass, this);
            if (!config.Logging) Unsubscribe(nameof(OnServerInitialized));
        }

        private void OnServerInitialized()
        {
            foreach (var def in ItemManager.GetItemDefinitions())
            {
                var imd = def.GetComponent<ItemModDeployable>();
                if (imd == null || _displayNames.ContainsKey(imd.entityPrefab.resourcePath)) continue;
                _displayNames.Add(imd.entityPrefab.resourcePath, def.displayName.english);
            }
        }

        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            BasePlayer player = planner.GetOwnerPlayer();
            if (player == null || permission.UserHasPermission(player.UserIDString, permBypass))
            {
                return;
            }
            
            BaseEntity entity = gameObject.GetComponent<BaseEntity>();

            if (config.MaxHeight > 0)
            {
                RaycastHit hit;
                if (Physics.Raycast(new Ray(entity.transform.position, Vector3.down), out hit, float.PositiveInfinity, Rust.Layers.Terrain))
                {
                    if (hit.distance > config.MaxHeight)
                    {
                        SendReply(player, string.Format(lang.GetMessage("DistanceTooHigh", this, player.UserIDString), hit.distance));
                        entity.Invoke(entity.KillMessage, 0.1f);
                        return;
                    }
                }
            }

            CheckEntity(entity, player);
        }

        private void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            BasePlayer player = deployer.GetOwnerPlayer();

            if (player != null && !permission.UserHasPermission(player.UserIDString, permBypass))
            {
                CheckEntity(entity, player);
            }
        }

        private void CheckEntity(BaseEntity entity, BasePlayer player)
        {
            if (entity == null)
            {
                return;
            }

            RaycastHit[] targets = Physics.RaycastAll(new Ray(entity.transform.position + Vector3.up * 200f, Vector3.down), 250, worldLayer);

            foreach (RaycastHit hit in targets)
            {
                if (hit.collider == null || !hit.collider.name.Contains("rock_") || !IsInside(hit.collider, entity) && !IsInCave(entity))
                {
                    continue;
                }

                if (config.Logging)
                {
                    string name;
                    if (!_displayNames.TryGetValue(entity.gameObject.name, out name))
                    {
                        name = entity.ShortPrefabName;
                    }

                    Puts(lang.GetMessage("PlayerSuspected", this), player.displayName, name, entity.transform.position);
                }

                if (config.Kill) entity.Invoke(entity.KillMessage, 0.1f);
                
                break;
            }
        }

        private bool IsInCave(BaseEntity entity)
        {
            if (!config.AllowCave)
            {
                return false;
            }

            RaycastHit[] targets = Physics.RaycastAll(new Ray(entity.transform.position, Vector3.up), 250, worldLayer);

            foreach (RaycastHit hit in targets)
            {
                if (hit.collider.name.Contains("rock_"))
                {
                    return true;
                }
            }

            return false;
        }

        private bool IsInside(Collider collider, BaseEntity entity)
        {
            var center = entity.WorldSpaceBounds().ToBounds().center;
            var rotation = entity.transform.rotation;
            var size = entity.bounds.extents;

            var points = new List<Vector3> // credits ZoneManger/k1lly0u
            {
                RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z + size.z), center, rotation),
                RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z + size.z), center, rotation),
                RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z - size.z), center, rotation),
                RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z - size.z), center, rotation),
                RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z + size.z), center, rotation),
                RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z + size.z), center, rotation),
                RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z - size.z), center, rotation),
                RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z - size.z), center, rotation)
            };

            Physics.queriesHitBackfaces = true;

            bool isInside = points.TrueForAll(point => IsInside(point));

            Physics.queriesHitBackfaces = false;

            return isInside;
        }

        private bool IsInside(Vector3 point)
        {
            if (Physics.Raycast(point, Vector3.up, out _hit, 20f, Layers.Mask.World, QueryTriggerInteraction.Ignore) && _hit.collider.name.Contains("rock_"))
            {
                var hits = Physics.RaycastAll(point + new Vector3(0f, 0.1f, 0f), Vector3.down, 50f, Layers.Mask.World | Layers.Mask.Terrain, QueryTriggerInteraction.Ignore);

                if (hits != null && hits.Length > 0)
                {
                    return hits.Last().collider.name.Contains("rock_");
                }

                return true;
            }

            return false;
        }

        private Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation) => rotation * (point - pivot) + pivot; // credits ZoneManger/k1lly0u
    }
}


// --- End of file: RockBlock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rust-spawner ---
// --- Original File Path: R/RustSpawner/RustSpawner.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Rust Spawner ", "Daano123", "3.0.1")]
    [Description("Rust Spawner Reworked is a plugin that you can spawn cars/helis/boats/animals/scarecrow. REWORKED Zoin plugin")]
    class RustSpawner : CovalencePlugin
    {
        #region Variables
        Dictionary<string, Timer> CoolDownsHorse = new Dictionary<string, Timer>();
        Dictionary<string, Timer> CoolDownsWolf = new Dictionary<string, Timer>();
        Dictionary<string, Timer> CoolDownsBear = new Dictionary<string, Timer>();
        Dictionary<string, Timer> CoolDownsMini = new Dictionary<string, Timer>();
        Dictionary<string, Timer> CoolDownsSedan = new Dictionary<string, Timer>();
        Dictionary<string, Timer> CoolDownsScrapHeli = new Dictionary<string, Timer>();
        Dictionary<string, Timer> CoolDownsChinook = new Dictionary<string, Timer>();
        Dictionary<string, Timer> CoolDownsRhib = new Dictionary<string, Timer>();
        Dictionary<string, Timer> CoolDownsBoat = new Dictionary<string, Timer>();

        const string Horse_Perm = "rustspawner.horse";
        const string Wolf_Perm = "rustspawner.wolf";
        const string Bear_Perm = "rustspawner.bear";
        const string Sedan_Perm = "rustspawner.sedan";
        const string Minicopter_Perm = "rustspawner.minicopter";
        const string ScrapHeli_Perm = "rustspawner.scrapheli";
        const string Chinook_Perm = "rustspawner.chinook";
        const string Rhib_Perm = "rustspawner.rhib";
        const string Boat_Perm = "rustspawner.boat";
        const string NoCooldown_Perm = "rustspawner.nocooldown";
        #endregion

        #region Configuaration
        protected override void LoadDefaultConfig()
        {
            LogWarning("Creating a new configuration file");
            Config["CooldownHorse"] = 3600;
            Config["CooldownWolf"] = 3600;
            Config["CooldownBear"] = 3600;
            Config["CooldownMini"] = 3600;
            Config["CooldownSedan"] = 3600;
            Config["CooldownScrapHeli"] = 14400;
            Config["CooldownChinook"] = 86400;
            Config["CooldownRhib"] = 14400;
            Config["CooldownBoat"] = 3600;
            Config["BuildingSpawn"] = false;
        }
        #endregion

        #region LanguageAPI
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You do not have access to that command!",
                ["InvalidInput"] = "Please enter a valid spawnable name!",
                ["IndoorsBlocked"] = "You cannot spawn indoors only outside!",
                ["Info"] = "You can spawn the following entitys\nhorse, wolf, bear, mini, scrapheli, chinook, sedan, rhib, boat\nIE /rspawn mini",
                ["Cooldown"] = "You are still on cooldown!",
                ["OutOfReach"] = "Please look closer to the ground!",
                ["Spawned"] = "Your {0} has been spawned!",
                ["Prefix"] = "[Rust Spawner] "
            }, this);
        }
        #endregion

        #region Hooks
        private void Init()
        {
            permission.RegisterPermission(NoCooldown_Perm, this);
            permission.RegisterPermission(Horse_Perm, this);
            permission.RegisterPermission(Wolf_Perm, this);
            permission.RegisterPermission(Bear_Perm, this);
            permission.RegisterPermission(Minicopter_Perm, this);
            permission.RegisterPermission(Sedan_Perm, this);
            permission.RegisterPermission(ScrapHeli_Perm, this);
            permission.RegisterPermission(Chinook_Perm, this);
            permission.RegisterPermission(Rhib_Perm, this);
            permission.RegisterPermission(Boat_Perm, this);
        }
        #endregion

        #region Commands
        [Command("rspawn")]
        private void Spawn(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                return;
            }

            string prefix = lang.GetMessage("Prefix", this, player.Id);

            if (args.Length < 1)
            {
                player.Reply(prefix + lang.GetMessage("InvalidInput", this, player.Id));
                return;
            }

            switch (args[0])
            {
                case "horse":
                    {
                        if (player.HasPermission(Horse_Perm))
                            SpawnEntity(player, "assets/rust.ai/nextai/testridablehorse.prefab", "CooldownHorse");
                        else
                            player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                        break;
                    }
                case "wolf":
                    {
                        if (player.HasPermission(Wolf_Perm))
                            SpawnEntity(player, "assets/rust.ai/agents/wolf/wolf.prefab", "CooldownWolf");
                        else
                            player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                        break;
                    }
                case "bear":
                    {
                        if (player.HasPermission(Bear_Perm))
                            SpawnEntity(player, "assets/rust.ai/agents/bear/bear.prefab", "CooldownBear");
                        else
                            player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                        break;
                    }
                case "mini":
                    {
                        if (player.HasPermission(Minicopter_Perm))
                            SpawnEntity(player, "assets/content/vehicles/minicopter/minicopter.entity.prefab", "CooldownMini");
                        else
                            player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                        break;
                    }
                case "scrapheli":
                    {
                        if (player.HasPermission(ScrapHeli_Perm))
                            SpawnEntity(player, "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab", "CooldownScrapHeli");
                        else
                            player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                        break;
                    }
                case "chinook":
                    {
                        if (player.HasPermission(Chinook_Perm))
                            SpawnEntity(player, "assets/prefabs/npc/ch47/ch47.entity.prefab", "CooldownChinook");
                        else
                            player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                        break;
                    }
                case "car":
                    {
                        if (player.HasPermission(Sedan_Perm))
                            SpawnEntity(player, "assets/content/vehicles/sedan_a/sedantest.entity.prefab", "CooldownSedan");
                        else
                            player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                        break;
                    }
                case "rhib":
                    {
                        if (player.HasPermission(Rhib_Perm))
                            SpawnEntity(player, "assets/content/vehicles/boats/rhib/rhib.prefab", "CooldownRhib");
                        else
                            player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                        break;
                    }
                case "boat":
                    {
                        if (player.HasPermission(Boat_Perm))
                            SpawnEntity(player, "assets/content/vehicles/boats/rowboat/rowboat.prefab", "CooldownBoat");
                        else
                            player.Reply(prefix + lang.GetMessage("NoPermission", this, player.Id));
                        break;
                    }
                case "info":
                    {
                            player.Reply(prefix + lang.GetMessage("Info", this, player.Id));
                        break;
                    }
                default:
                    player.Reply(prefix + lang.GetMessage("InvalidInput", this, player.Id));
                    break;
            }
        }
        #endregion

        #region Functions
        void SpawnEntity(IPlayer player, string entity_name, string cooldown)
        {
            BasePlayer PlayerObject = player.Object as BasePlayer;
            string prefix = lang.GetMessage("Prefix", this, player.Id);

            #region Raycast
            Vector3 ViewAdjust = new Vector3(0f, 1.5f, 0f);
            Vector3 position = PlayerObject.transform.position + ViewAdjust;
            Vector3 rotation = Quaternion.Euler(PlayerObject.serverInput.current.aimAngles) * Vector3.forward;
            int range = 10;

            RaycastHit hit;
            if (!Physics.Raycast(position, rotation, out hit, range))
            {
                player.Reply(prefix + lang.GetMessage("OutOfReach", this, player.Id));
                return;
            }
            #endregion

            #region Cooldown
            if (!player.HasPermission(NoCooldown_Perm))
            {
                switch (cooldown)
                {
                    case "CooldownHorse":
                        {
                            if (CoolDownsHorse.ContainsKey(player.Id))
                            {
                                player.Reply(prefix + lang.GetMessage("Cooldown", this, player.Id));
                                return;
                            }
                            else {
                                object timerObj = Config["CooldownHorse"];
                                float timerTime = float.Parse(timerObj.ToString());
                                string id = player.Id;
                                Timer Cooldown = timer.Once(timerTime, () =>
                                {
                                    CoolDownsHorse.Remove(id);
                                });
                                CoolDownsHorse.Add(id, Cooldown);
                            }
                            break;
                        }
                    case "CooldownWolf":
                        {
                            if (CoolDownsWolf.ContainsKey(player.Id))
                            {
                                player.Reply(prefix + lang.GetMessage("Cooldown", this, player.Id));
                                return;
                            }
                            else
                            {
                                object timerObj = Config["CooldownWolf"];
                                float timerTime = float.Parse(timerObj.ToString());
                                string id = player.Id;
                                Timer Cooldown = timer.Once(timerTime, () =>
                                {
                                    CoolDownsWolf.Remove(id);
                                });
                                CoolDownsWolf.Add(id, Cooldown);
                            }
                            break;
                        }
                    case "CooldownBear":
                        {
                            if (CoolDownsBear.ContainsKey(player.Id))
                            {
                                player.Reply(prefix + lang.GetMessage("Cooldown", this, player.Id));
                                return;
                            }
                            else
                            {
                                object timerObj = Config["CooldownBear"];
                                float timerTime = float.Parse(timerObj.ToString());
                                string id = player.Id;
                                Timer Cooldown = timer.Once(timerTime, () =>
                                {
                                    CoolDownsBear.Remove(id);
                                });
                                CoolDownsBear.Add(id, Cooldown);
                            }
                            break;
                        }
                    case "CooldownMini":
                        {
                            if (CoolDownsMini.ContainsKey(player.Id))
                            {
                                player.Reply(prefix + lang.GetMessage("Cooldown", this, player.Id));
                                return;
                            }
                            else
                            {
                                object timerObj = Config["CooldownMini"];
                                float timerTime = float.Parse(timerObj.ToString());
                                string id = player.Id;
                                Timer Cooldown = timer.Once(timerTime, () =>
                                {
                                    CoolDownsMini.Remove(id);
                                });
                                CoolDownsMini.Add(id, Cooldown);
                            }
                            break;
                        }
                    case "CooldownSedan":
                        {
                            if (CoolDownsSedan.ContainsKey(player.Id))
                            {
                                player.Reply(prefix + lang.GetMessage("Cooldown", this, player.Id));
                                return;
                            }
                            else
                            {
                                object timerObj = Config["CooldownSedan"];
                                float timerTime = float.Parse(timerObj.ToString());
                                string id = player.Id;
                                Timer Cooldown = timer.Once(timerTime, () =>
                                {
                                    CoolDownsSedan.Remove(id);
                                });
                                CoolDownsSedan.Add(id, Cooldown);
                            }
                            break;
                        }
                    case "CooldownScrapHeli":
                        {
                            if (CoolDownsScrapHeli.ContainsKey(player.Id))
                            {
                                player.Reply(prefix + lang.GetMessage("Cooldown", this, player.Id) + CoolDownsScrapHeli[player.Id]);
                                return;
                            }
                            else
                            {
                                object timerObj = Config["CooldownScrapHeli"];
                                float timerTime = float.Parse(timerObj.ToString());
                                string id = player.Id;
                                Timer Cooldown = timer.Once(timerTime, () =>
                                {
                                    CoolDownsScrapHeli.Remove(id);
                                });
                                CoolDownsScrapHeli.Add(id, Cooldown);
                            }
                            break;
                        }
                    case "CooldownChinook":
                        {
                            if (CoolDownsChinook.ContainsKey(player.Id))
                            {
                                player.Reply(prefix + lang.GetMessage("Cooldown", this, player.Id));
                                return;
                            }
                            else
                            {
                                object timerObj = Config["CooldownChinook"];
                                float timerTime = float.Parse(timerObj.ToString());
                                string id = player.Id;
                                Timer Cooldown = timer.Once(timerTime, () =>
                                {
                                    CoolDownsChinook.Remove(id);
                                });
                                CoolDownsChinook.Add(id, Cooldown);
                            }
                            break;
                        }
                    case "CooldownRhib":
                        {
                            if (CoolDownsRhib.ContainsKey(player.Id))
                            {
                                player.Reply(prefix + lang.GetMessage("Cooldown", this, player.Id));
                                return;
                            }
                            else
                            {
                                object timerObj = Config["CooldownRhib"];
                                float timerTime = float.Parse(timerObj.ToString());
                                string id = player.Id;
                                Timer Cooldown = timer.Once(timerTime, () =>
                                {
                                    CoolDownsRhib.Remove(id);
                                });
                                CoolDownsRhib.Add(id, Cooldown);
                            }
                            break;
                        }
                    case "CooldownBoat":
                        {
                            if (CoolDownsBoat.ContainsKey(player.Id))
                            {
                                player.Reply(prefix + lang.GetMessage("Cooldown", this, player.Id));
                                return;
                            }
                            else
                            {
                                object timerObj = Config["CooldownBoat"];
                                float timerTime = float.Parse(timerObj.ToString());
                                string id = player.Id;
                                Timer Cooldown = timer.Once(timerTime, () =>
                                {
                                    CoolDownsBoat.Remove(id);
                                });
                                CoolDownsBoat.Add(id, Cooldown);
                            }
                            break;
                        }
                    default:
                        break;
                }
            }
            #endregion

            #region Building Check
            if (!(bool)Config["BuildingSpawn"] & !PlayerObject.IsOutside())
            {
                player.Reply(prefix + lang.GetMessage("IndoorsBlocked", this, player.Id));
                return;
            }
            #endregion


            #region Actual Spawning
            BaseEntity Entity = GameManager.server.CreateEntity(entity_name, hit.point);

            if (Entity)
            {
                Entity.Spawn();
                player.Reply(prefix + string.Format(lang.GetMessage("Spawned", this, player.Id), Entity.ShortPrefabName));
            }
            #endregion
        }
        #endregion
    }
}

// --- End of file: RustSpawner.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/remote-detonated-explosives ---
// --- Original File Path: R/RemoteDetonatedExplosives/RemoteDetonatedExplosives.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Remote Detonated Explosives", "birthdates", "2.0.2")]
    [Description("Allows players to detonate explosives remotely with a RF Transmitter")]
    public class RemoteDetonatedExplosives : RustPlugin
    {

        #region Variables

        private const string DetonatePermission = "remotedetonatedexplosives.use"; 
        private static float Time => UnityEngine.Time.realtimeSinceStartup;
        private IDictionary<ulong, Queue<Explosive>> ActiveExplosives { get; } =
            new Dictionary<ulong, Queue<Explosive>>();

        /// <summary>
        ///     A class that stores a reference to <see cref="TimedExplosive"/> & an expiry of the initial throw delay
        /// </summary>
        private class Explosive
        {
            public TimedExplosive Entity { get; set; }
            public float Expiry { get; set; }
            public ExplosiveSettings Settings { get; set; }
        }

        #endregion
        
        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(DetonatePermission, this);
        }

        
        private void OnExplosiveThrown(BasePlayer player, TimedExplosive timedExplosive, BaseNetworkable item)
        {
            ExplosiveSettings explosiveSettings;
            if (!_config.AllExplosiveSettings.TryGetValue(item.ShortPrefabName, out explosiveSettings))
            {
                return;
            }
            UpdateCollider(explosiveSettings, timedExplosive);
            if (!player.IPlayer.HasPermission(DetonatePermission)) return;
            CancelExplode(timedExplosive);
            AddActiveExplosive(explosiveSettings, player.userID, timedExplosive);
        }

        /// <summary>
        ///     Cleanup the infinitely timed C4
        /// </summary>
        private void Unload()
        {
            foreach (var allExplosives in ActiveExplosives.Values)
            foreach (var timedExplosive in allExplosives)
            {
                timedExplosive.Entity.Kill();
            }
        }
        
        /// <summary>
        ///     <para>
        ///         First, we check if the <paramref name="frequency"/> is equal to <see cref="ExplosiveSettings.Frequency"/>, if applicable.
        ///     </para>
        ///     <para>
        ///         Second, we get all the active <see cref="Explosive"/> associated with the player
        ///     </para>
        ///     <para>
        ///         Finally, we explode & remove all the <see cref="TimedExplosive"/> that is not on cooldown
        ///     </para>
        /// </summary>
        /// <param name="detonator"><see cref="Detonator"/> used to get the player who triggered this hook</param>
        /// <param name="frequency">Used to check against <see cref="ExplosiveSettings.Frequency"/> if applicable</param>
        private void OnRfBroadcasterAdded(Detonator detonator, int frequency)
        {
            var ownerPlayer = detonator.GetOwnerPlayer();
            if (ownerPlayer == null) return;
            var owner = ownerPlayer.userID;
            var explosives = GetExplosives(owner);
            if (explosives == null) return;
            var count = 0;
            var max = explosives.Count-1;
            do
            {
                var explosive = explosives.Peek();
                if (explosive.Settings.Frequency >= 0 && explosive.Settings.Frequency != frequency || explosive.Expiry > Time || 
                    explosive.Entity.Distance2D(ownerPlayer.transform.position) > explosive.Settings.MaxDistance) continue;
                CancelExplode(explosive.Entity);
                try
                {
                    explosive.Entity.Explode();
                }
                catch (Exception exception)
                {
                    PrintError("Failed to explode C4: {0}\n{1}", exception.Message, exception.StackTrace);
                }

                explosives.Dequeue();
                if (count++ == explosive.Settings.MaxExplosions) break;

            } while (max-- > 0);

            if (explosives.Count == 0) ActiveExplosives.Remove(owner);
        }

        #endregion

        #region Helpers

        /// <summary>
        ///     Track a <see cref="TimedExplosive"/> for <see cref="OnRfBroadcasterAdded"/>
        /// </summary>
        /// <param name="settings"><paramref name="timedExplosive"/> settings</param>
        /// <param name="id">ID of player who threw this explosive</param>
        /// <param name="timedExplosive">Target <see cref="TimedExplosive"/></param>
        private void AddActiveExplosive(ExplosiveSettings settings, ulong id, TimedExplosive timedExplosive)
        {
            var explosives = GetExplosives(id, true);
            var explosive = new Explosive {Entity = timedExplosive, Expiry = Time + settings.InitialDelay, Settings = settings};
            explosives.Enqueue(explosive);
            if(settings.MaxLifespan > 0f) timedExplosive.Invoke(() => LifespanExplode(id, explosives, explosive), settings.MaxLifespan);
        }

        /// <summary>
        ///     A method to explode once a <see cref="TimedExplosive"/> lifespan is over
        /// </summary>
        /// <param name="id">Target id</param>
        /// <param name="explosives">All explosives from <paramref name="id"/></param>
        /// <param name="explosive">Target <see cref="TimedExplosive"/></param>
        private void LifespanExplode(ulong id, IEnumerable<Explosive> explosives, Explosive explosive)
        {
            if (explosive.Entity == null) return;
            explosive.Entity.Explode();
            ActiveExplosives[id] = new Queue<Explosive>(explosives.Where(ex => ex != explosive));
        }
        
        /// <summary>
        ///     Cancel the <see cref="MonoBehaviour.Invoke"/> that calls <see cref="TimedExplosive.Explode"/> from <paramref name="timedExplosive"/>
        /// </summary>
        /// <param name="timedExplosive">Target explosive</param>
        private static void CancelExplode(TimedExplosive timedExplosive)
        {
            timedExplosive.CancelInvoke(timedExplosive.Explode);
        }
        
        /// <summary>
        ///     Get all the explosives associated with <paramref name="id"/>
        /// </summary>
        /// <param name="id">Target id</param>
        /// <param name="create">Do we create an entry if it doesn't exist?</param>
        /// <returns>A <see cref="IList{T}"/> of <see cref="Explosive"/></returns>
        private Queue<Explosive> GetExplosives(ulong id, bool create = false)
        {
            Queue<Explosive> timedExplosives;
            if (ActiveExplosives.TryGetValue(id, out timedExplosives)) return timedExplosives;
            if (!create) return null;
            ActiveExplosives[id] = timedExplosives = new Queue<Explosive>();
            return timedExplosives;
        }

        /// <summary>
        ///     Update a collider's physics
        /// </summary>
        /// <param name="explosiveSettings"><paramref name="obj"/> settings</param>
        /// <param name="obj">Target <see cref="Component"/> with a <see cref="Collider"/> component</param>
        private static void UpdateCollider(ExplosiveSettings explosiveSettings, Component obj)
        {
            var useMass = explosiveSettings.PhysicsSettings.Mass > 0f;
            var useFriction = explosiveSettings.PhysicsSettings.Friction > 0f;
            if (!useFriction && !useMass) return;
            var collider = obj.GetComponent<Collider>();
            var material = collider.material;
            var rigidBody = collider.attachedRigidbody;
            if(useMass) rigidBody.mass = explosiveSettings.PhysicsSettings.Mass;
            if(useFriction) material.dynamicFriction = material.staticFriction = explosiveSettings.PhysicsSettings.Friction;
        }

        #endregion
        
        #region Configuration

        private ConfigFile _config;

        /// <summary>
        ///     C4 collider physics settings
        /// </summary>
        private class PhysicsSettings
        {
            public float Friction { get; set; }
            public float Mass { get; set; }
        }

        private class ConfigFile
        {
            [JsonProperty("Explosive Settings")]
            public IDictionary<string, ExplosiveSettings> AllExplosiveSettings { get; set; }
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    AllExplosiveSettings = new Dictionary<string, ExplosiveSettings>
                    {
                        {"explosive.timed.entity", new ExplosiveSettings{
                            InitialDelay = 3f,
                            MaxExplosions = 2,
                            MaxLifespan = 15f,
                            MaxDistance = 100f,
                            PhysicsSettings = new PhysicsSettings {Mass = 0.5f, Friction = 1f},
                            Frequency = -1
                        }}
                    }
                };
            }
        }

        private class ExplosiveSettings
        {
            [JsonProperty("Collision Settings")]
            public PhysicsSettings PhysicsSettings { get; set; }
            [JsonProperty("Max Time Before it Automatically Explodes (-1 to disable)")]
            public float MaxLifespan { get; set; }
            [JsonProperty("Max Detonation Distance")]
            public float MaxDistance { get; set; }
            [JsonProperty("Max Explosions with One Click")]
            public int MaxExplosions { get; set; }
            [JsonProperty("Initial Delay (time before you can explode in seconds)")]
            public float InitialDelay { get; set; }
            [JsonProperty("Required Frequency (-1 for all)")]
            public int Frequency;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}

// --- End of file: RemoteDetonatedExplosives.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rustcord ---
// --- Original File Path: R/Rustcord/Rustcord.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Net;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Plugins;
using UnityEngine;
using Facepunch;
using Oxide.Core.Libraries.Covalence;
using Oxide.Ext.Discord.Builders;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Logging;


namespace Oxide.Plugins
{
    [Info("Rustcord", "Kirollos & OuTSMoKE", "3.4.1")]
    [Description("Complete game server monitoring through discord.")]
    internal class Rustcord : RustPlugin, IDiscordPlugin
    {
        [PluginReference] Plugin PrivateMessages, BetterChatMute, Clans, AdminChat, DiscordAuth, AdminHammer, AdminRadar, Kits, Vanish, RaidableBases, DangerousTreasures, NoGiveNotices, Give, AirEvent, HarborEvent, JunkyardEvent, PowerPlantEvent;
        public DiscordClient Client { get; set; }

        #region Back End Shit

        private Settings _settings;

        private int? _channelCount;

        private Snowflake _botId;

        private UpdatePresenceCommand DiscordPresence = new UpdatePresenceCommand
        {
            Activities = new List<DiscordActivity>
            {
                new DiscordActivity
                {
                    Type = ActivityType.Game,
                    Name = "Rustcord Initializing..."
                }
            }
        };

        private Timer StatusTimer = null;

        private object FindUserByID(DiscordUser user)
        {
            throw new NotImplementedException();
        }

        private static string FormatTime(TimeSpan time)
        {
            var values = new List<string>();

            if (time.Days != 0)
                values.Add($"{time.Days} day(s)");

            if (time.Hours != 0)
                values.Add($"{time.Hours} hour(s)");

            if (time.Minutes != 0)
                values.Add($"{time.Minutes} minute(s)");

            if (time.Seconds != 0)
                values.Add($"{time.Seconds} second(s)");

            return values.ToSentence();
        }

        private string GetPlayerFormattedField(IPlayer player)
        {
            return $"{player.Name} ([{player.Id}](https://steamcommunity.com/profiles/{player.Id}))";
        }

        private string GetFormattedSteamID(string id)
        {
            return $"[{id}](https://steamcommunity.com/profiles/{id})";
        }

        private string FindGridPosition(Vector3 position) => MapHelper.GridToString(MapHelper.PositionToGrid(position));

        enum CacheType
        {
            OnPlayerChat = 0,
            OnPlayerConnected = 1,
            OnPlayerDisconnected = 2,
            OnPlayerJoin = 3
        }

        Dictionary<CacheType, Dictionary<BasePlayer, Dictionary<string, string>>> cache = new Dictionary<CacheType, Dictionary<BasePlayer, Dictionary<string, string>>>();
        private string rbdiff;

        Dictionary<string, string> GetPlayerCache(BasePlayer player, string message, CacheType type)
        {
            switch (type)
            {
                case CacheType.OnPlayerChat:
                    {
                        Dictionary<string, string> dict;
                        if (!cache[CacheType.OnPlayerChat].TryGetValue(player, out dict))
                        {
                            cache[CacheType.OnPlayerChat].Add(player, dict = new Dictionary<string, string>
                            {
                                ["playername"] = player.displayName,
                                ["message"] = message,
                                ["playersteamid"] = player.UserIDString,
                                ["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")
                            });
                        }

                        dict["playername"] = player.displayName;
                        dict["message"] = message;
                        dict["playersteamid"] = player.UserIDString;
                        dict["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt");
                        return dict;
                    }
                case CacheType.OnPlayerConnected:
                    {
                        Dictionary<string, string> dict;
                        if (!cache[CacheType.OnPlayerConnected].TryGetValue(player, out dict))
                        {
                            cache[CacheType.OnPlayerConnected].Add(player, dict = new Dictionary<string, string>
                            {
                                ["playername"] = player.displayName,
                                ["playerip"] = message.Substring(0, message.IndexOf(":")),
                                ["playersteamid"] = player.UserIDString,
                                ["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")
                            });
                        }

                        dict["playername"] = player.displayName;
                        dict["playerip"] = message.Substring(0, message.IndexOf(":"));
                        dict["playersteamid"] = player.UserIDString;
                        dict["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt");
                        return dict;
                    }
                case CacheType.OnPlayerJoin:
                    {
                        Dictionary<string, string> dict;
                        if (!cache[CacheType.OnPlayerJoin].TryGetValue(player, out dict))
                        {
                            cache[CacheType.OnPlayerDisconnected].Add(player, dict = new Dictionary<string, string>
                            {
                                ["playername"] = player.displayName,
                                ["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")
                            });
                        }

                        dict["playername"] = player.displayName;
                        dict["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt");
                        return dict;
                    }
                case CacheType.OnPlayerDisconnected:
                default:
                    {
                        Dictionary<string, string> dict;
                        if (!cache[CacheType.OnPlayerDisconnected].TryGetValue(player, out dict))
                        {
                            cache[CacheType.OnPlayerDisconnected].Add(player, dict = new Dictionary<string, string>
                            {
                                ["playername"] = player.displayName,
                                ["reason"] = message,
                                ["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")
                            });
                        }

                        dict["playername"] = player.displayName;
                        dict["reason"] = message;
                        dict["time"] = DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt");
                        return dict;
                    }
            }
        }

        private void OnDiscordClientCreated()
        {
            if (string.IsNullOrEmpty(_settings.General.Apikey) || _settings.General.Apikey == null || _settings.General.Apikey == "BotToken")
            {
                PrintError("API key is empty or invalid!");
                return;
            }

            bool flag = true;
            try
            {
                BotConnection settings = new BotConnection
                {
                    ApiToken = _settings.General.Apikey,
                    Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers | GatewayIntents.GuildMessages | GatewayIntents.DirectMessages | GatewayIntents.MessageContent,
                    LogLevel = _settings.General.ExtensionDebugging
                };
                Client.Connect(settings);
            }
            catch (Exception e)
            {
                flag = false;
                PrintError($"Rustcord failed to create client! Exception message: {e}");
            }

            if (flag)
            {
                cmd.AddChatCommand(_settings.General.ReportCommand, this, "cmdReport");
                cmd.AddChatCommand("bug", this, "cmdBug");
                SubscribeHooks();
            }

            if (_settings.GameLog.EnableCustomLogging)
                UnityEngine.Application.logMessageReceived += ConsoleLog;
        }

        private void Reload()
        {
            rust.RunServerCommand("oxide.reload Rustcord");
        }

        void OnDiscordGatewayReady(GatewayReadyEvent rdy)
        {
            _botId = rdy.User.Id;
            SubscribeHooks();
            _channelCount = _settings?.Channels.Count;
            if (_settings.General.EnableBotStatus)
            {
                NextFrame(() =>
                {
                    if (StatusTimer != null && !StatusTimer.Destroyed)
                    {
                        StatusTimer.Destroy();
                    }
                    StatusTimer = timer.Every(6f, () =>
                    {
                        var text = new Dictionary<string, string>
                        {
                            ["playercount"] = Convert.ToString(BasePlayer.activePlayerList.Count),
                            ["maxplayers"] = Convert.ToString(ConVar.Server.maxplayers),
                            ["sleepercount"] = Convert.ToString(BasePlayer.sleepingPlayerList.Count)
                        };
                        var msg = Translate("Discord_Status", text);
                        DiscordPresence.Activities[0].Name = string.IsNullOrEmpty(msg) ? "Rustcord initializing...." : msg;
                        Client.UpdateStatus(DiscordPresence);
                    });
                });
            }
        }

        void OnDiscordGuildCreated(DiscordGuild newguild)
        {

            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("msg_plugininit"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, c => {
                        c.CreateMessage(Client, "Rustcord Initialized!");
                    }, newguild.Id);
                }
            }
        }

        private void Unload()
        {
            if (StatusTimer != null && !StatusTimer.Destroyed)
            {
                StatusTimer.Destroy();
            }
            if (_settings.GameLog.EnableCustomLogging)
                UnityEngine.Application.logMessageReceived -= ConsoleLog;
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMessageCreated)]
        private void OnDiscordGuildMessageCreated(DiscordMessage message)
        {
            //Puts($"{nameof(OnDiscordGuildMessageCreated)} New Message: {message.Author.FullUserName}: {message.Content}.");
            if ((message.Content?.Length ?? 0) == 0)
            {
                //Puts($"{nameof(OnDiscordGuildMessageCreated)} Skipping Message {message.Author.FullUserName}: {message.Content}. Content Length is 0");
                return;
            }
            
            Settings.Channel channelidx = FindChannelById(message.ChannelId);
            if (channelidx == null)
            {
                //Puts($"{nameof(OnDiscordGuildMessageCreated)} Skipping Message {message.Author.FullUserName}: {message.Content}. Channel Not Found");
                return;
            }

            if (message.Author.Id == _botId)
            {
                return;
            }
            
            if (message.Content[0] == _settings.DiscordSide.Commandprefix[0])
            {
                if (!channelidx.perms.Contains("cmd_allow"))
                    return;
                string cmd;
                string msg;
                try
                {
                    cmd = message.Content.Split(' ')[0].ToLower();
                    if (string.IsNullOrEmpty(cmd.Trim()))
                        cmd = message.Content.Trim().ToLower();
                }
                catch
                {
                    cmd = message.Content.Trim().ToLower();
                }

                cmd = cmd.Remove(0, 1);

                msg = message.Content.Remove(0, 1 + cmd.Length).Trim();
                cmd = cmd.Trim();
                cmd = cmd.ToLower();

                if (!channelidx.perms.Contains("cmd_" + cmd))
                    return;
                if (!_settings.Commandroles.ContainsKey(cmd))
                {
                    DiscordToGameCmd(cmd, msg, message.Author, message.ChannelId);
                    return;
                }
                var roles = _settings.Commandroles[cmd];
                if (roles.Count == 0)
                {
                    DiscordToGameCmd(cmd, msg, message.Author, message.ChannelId);
                    return;
                }

                foreach (var roleid in message.Member.Roles)
                {
                    var rolename = GetRoleNameById(roleid);
                    if (roles.Contains(rolename))
                    {
                        DiscordToGameCmd(cmd, msg, message.Author, message.ChannelId);
                        break;
                    }
                }
            }
            else
            {
                var chattag = _settings.DiscordSide.GameChatTag;
                var chattagcolor = _settings.DiscordSide.GameChatTagColor;
                var chatnamecolor = _settings.DiscordSide.GameChatNameColor;
                var chattextcolor = _settings.DiscordSide.GameChatTextColor;
                if (!channelidx.perms.Contains("msg_chat")) return;
                string nickname = message.Member?.Nickname ?? "";
                if (nickname.Length == 0)
                    nickname = message.Author.Username;
                //PrintToChat("<color=" + chattagcolor + ">" + chattag + "</color> " + "<color=" + chatnamecolor + ">" + nickname + ":</color> " + "<color=" + chattextcolor + ">" + message.content + "</color>");
                string text = $"<color={chattagcolor}>{chattag}</color> <color={chatnamecolor}>{nickname}:</color> <color={chattextcolor}>{message.Content}</color>";
                foreach (var player in BasePlayer.activePlayerList) Player.Message(player, text, _settings.DiscordSide.GameChatIconSteamID);
                Puts("[DISCORD] " + nickname + ": " + message.Content);
            }
        }

        private string Translate(string msg, Dictionary<string, string> parameters = null)
        {
            if (string.IsNullOrEmpty(msg))
                return string.Empty;

            msg = lang.GetMessage(msg, this);

            if (parameters != null)
            {
                foreach (var lekey in parameters)
                {
                    if (msg.Contains("{" + lekey.Key + "}"))
                        msg = msg.Replace("{" + lekey.Key + "}", lekey.Value);
                }
            }

            return msg;
        }


        private Settings.Channel FindChannelById(Snowflake id)
        {
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].Channelid == id)
                    return _settings.Channels[i];
            }

            return null;
        }

        private void GetChannel(DiscordClient c, Snowflake chan_id, Action<DiscordChannel> cb, Snowflake guildid = default(Snowflake))
        {
            //Guild g = guildid == null ? c.DiscordServers.FirstOrDefault(x => x.channels.FirstOrDefault(y => y.id == chan_id) != null) : c.GetGuild(guildid);
            DiscordGuild g = null;
            DiscordChannel foundchan = null;
            if (guildid.IsValid())
                g = c.Bot.GetGuild(guildid);
            else
                foreach (var G in c.Bot.Servers.Values)
                {
                    foundchan = G.Channels[chan_id];
                    if (foundchan != null)
                    {
                        g = G;
                        break;
                    }
                }
            if (g == null)
            {
                PrintWarning($"Rustcord failed to fetch channel! (chan_id={chan_id}). Guild is invalid.");
                return;
            }
            if (g.Unavailable ?? false == true)
            {
                PrintWarning($"Rustcord failed to fetch channel! (chan_id={chan_id}). Guild is possibly invalid or not available yet.");
                return;
            }
            //Channel foundchan = g?.channels?.FirstOrDefault(z => z.id == chan_id);
            if (foundchan == null)
            {
                if (guildid.IsValid()) return; // Ignore printing error
                PrintWarning($"Rustcord failed to fetch channel! (chan_id={chan_id}).");
                return;
            }
            if (foundchan.Id != chan_id) return;
            cb?.Invoke(foundchan);
        }

        private string GetRoleNameById(Snowflake id)
        {
            //var role = _client.DiscordServers.FirstOrDefault(x => x.roles.FirstOrDefault(y => y.id == id) != null)?.roles.FirstOrDefault(z => z.id == id);
            //return role?.name ?? "";
            foreach (var r in Client.Bot.Servers.Values)
            {
                var role = r.Roles[id];
                if (role != null)
                {
                    return role.Name;
                }
            }
            return string.Empty;
        }

        private IPlayer FindPlayer(string nameorId)
        {
            foreach (var player in covalence.Players.Connected)
            {
                if (player.Id == nameorId)
                    return player;

                if (player.Name == nameorId)
                    return player;
            }

            return null;
        }

        private DiscordUser FindUserByID(Snowflake id)
        {
            foreach (DiscordGuild guild in Client.Bot.Servers.Values)
            {
                var member = guild.Members[id];
                if (member != null)
                {
                    return member.User;
                }
            }

            return null;
        }

        private BasePlayer FindPlayerByID(string Id)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.UserIDString == Id)
                    return player;
            }

            return null;
        }

        private IPlayer GetPlayer(string id)
        {
            return covalence.Players.FindPlayerById(id);
        }

        private IPlayer GetPlayer(ulong id)
        {
            return GetPlayer(id.ToString());
        }

        #endregion

        #region Config Layout
        private class Settings
        {
            [JsonProperty(PropertyName = "General Settings")]
            public GeneralSettings General { get; set; }

            [JsonProperty(PropertyName = "Discord to Game Settings")]
            public DiscordSideSettings DiscordSide { get; set; }

            [JsonProperty(PropertyName = "Rust Logging Settings")]
            public GameLogSettings GameLog { get; set; }

            [JsonProperty(PropertyName = "Plugin Logging Settings")]
            public PluginLogSettings PluginLog { get; set; }

            [JsonProperty(PropertyName = "Premium Plugin Logging Settings")]
            public PremiumPluginLogSettings PremiumPluginLog { get; set; }

            [JsonProperty(PropertyName = "Discord Output Formatting")]
            public OutputSettings OutputFormat { get; set; }

            [JsonProperty(PropertyName = "Logging Exclusions")]
            public ExcludedSettings Excluded { get; set; }

            [JsonProperty(PropertyName = "Filter Settings")]
            public FilterSettings Filters { get; set; }

            [JsonProperty(PropertyName = "Discord Logging Channels")]
            public List<Channel> Channels { get; set; }

            [JsonProperty(PropertyName = "Discord Command Role Assignment (Empty = All roles can use command.)")]
            public Dictionary<string, List<string>> Commandroles { get; set; }

            public class Channel
            {
                [JsonProperty(PropertyName = "Discord Channel ID #")]
                public Snowflake Channelid { get; set; }

                [JsonProperty(PropertyName = "Channel Flags")]
                public List<string> perms { get; set; }

                [JsonProperty(PropertyName = "Custom: Words/Phrases to Log")]
                public List<string> CustomFilter { get; set; }

                [JsonIgnore]
                public readonly StringBuilder FilterBuilder = new StringBuilder();

                [JsonIgnore]
                public Timer Timer;
            }
        }

        public class GeneralSettings
        {
            [JsonProperty(PropertyName = "API Key (Bot Token)")]
            public string Apikey { get; set; }

            [JsonProperty(PropertyName = "Auto Reload Plugin")]
            public bool AutoReloadPlugin { get; set; }

            [JsonProperty(PropertyName = "Auto Reload Time (Seconds)")]
            public int AutoReloadTime { get; set; }

            [JsonProperty(PropertyName = "Enable Bot Status")]
            public bool EnableBotStatus { get; set; }

            [JsonProperty(PropertyName = "In-Game Report Command")]
            public string ReportCommand { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose/Debug/Info/Warning/Error/Exception/Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; } = DiscordLogLevel.Info;
        }

        public class DiscordSideSettings
        {
            [JsonProperty(PropertyName = "Discord Command Prefix")]
            public string Commandprefix { get; set; }

            [JsonProperty(PropertyName = "Discord to Game Chat: Icon (Steam ID)")]
            public ulong GameChatIconSteamID { get; set; }

            [JsonProperty(PropertyName = "Discord to Game Chat: Tag")]
            public string GameChatTag { get; set; }

            [JsonProperty(PropertyName = "Discord to Game Chat: Tag Color (Hex)")]
            public string GameChatTagColor { get; set; }

            [JsonProperty(PropertyName = "Discord to Game Chat: Player Name Color (Hex)")]
            public string GameChatNameColor { get; set; }

            [JsonProperty(PropertyName = "Discord to Game Chat: Message Color (Hex)")]
            public string GameChatTextColor { get; set; }
        }

        public class GameLogSettings
        {
            [JsonProperty(PropertyName = "Enable Logging: Player Chat")]
            public bool LogChat { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Joins & Quits")]
            public bool LogJoinQuits { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Deaths")]
            public bool LogDeaths { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Vehicle Spawns (Heli/APC/Plane/Ship)")]
            public bool LogVehicleSpawns { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Crate Drops (Hackable/Supply)")]
            public bool LogCrateDrops { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Usergroup Changes")]
            public bool LogUserGroups { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Permission Changes")]
            public bool LogPermissions { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Kicks & Bans")]
            public bool LogKickBans { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Player Name Changes")]
            public bool LogNameChanges { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Server Commands (Gestures/Note Edits)")]
            public bool LogServerCommands { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Server Messages (Give/Item Spawns)")]
            public bool LogServerMessages { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Player F7 Reports")]
            public bool LogF7Reports { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Team Changes")]
            public bool LogTeams { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: RCON Connections")]
            public bool LogRCON { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Spectates")]
            public bool LogSpectates { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Server Wipe")]
            public bool LogServerWipe { get; set; }

            [JsonProperty(PropertyName = "Enable Custom Logging")]
            public bool EnableCustomLogging { get; set; }
        }

        public class PluginLogSettings
        {
            [JsonProperty(PropertyName = "Enable Logging: AdminHammer")]
            public bool LogPluginAdminHammer { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Admin Radar")]
            public bool LogPluginAdminRadar { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Better Chat Mute")]
            public bool LogPluginBetterChatMute { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Clans")]
            public bool LogPluginClans { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Dangerous Treasures")]
            public bool LogPluginDangerousTreasures { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Discord Auth")]
            public bool LogPluginDiscordAuth { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Godmode")]
            public bool LogPluginGodmode { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Kits")]
            public bool LogPluginKits { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Private Messages")]
            public bool LogPluginPrivateMessages { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Raidable Bases")]
            public bool LogPluginRaidableBases { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Sign Artist")]
            public bool LogPluginSignArtist { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Vanish")]
            public bool LogPluginVanish { get; set; }
        }
        public class PremiumPluginLogSettings
        {
            [JsonProperty(PropertyName = "Enable Logging: Air Event")]
            public bool LogPluginAirEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Armored Train Event")]
            public bool LogPluginArmoredTrainEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Cargo Train Event")]
            public bool LogPluginCargoTrainEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Convoy Event")]
            public bool LogPluginConvoyEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Harbor Event")]
            public bool LogPluginHarborEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Junkyard Event")]
            public bool LogPluginJunkyardEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Power Plant Event")]
            public bool LogPluginPowerPlantEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Satellite Dish Event")]
            public bool LogPluginSatDishEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Sputnik Event")]
            public bool LogPluginSputnikEvent { get; set; }

            [JsonProperty(PropertyName = "Enable Logging: Water Event")]
            public bool LogPluginWaterEvent { get; set; }
        }

        public class OutputSettings
        {
            [JsonProperty(PropertyName = "Output Type: Bans (Simple/Embed)")]
            public string OutputTypeBans { get; set; }

            [JsonProperty(PropertyName = "Output Type: Bug Report (Simple/Embed)")]
            public string OutputTypeBugs { get; set; }

            [JsonProperty(PropertyName = "Output Type: Deaths (Simple/Embed/DeathNotes)")]
            public string OutputTypeDeaths { get; set; }

            [JsonProperty(PropertyName = "Output Type: F7 Reports (Simple/Embed)")]
            public string OutputTypeF7Report { get; set; }

            [JsonProperty(PropertyName = "Output Type: Join/Quit (Simple/Embed)")]
            public string OutputTypeJoinQuit { get; set; }

            [JsonProperty(PropertyName = "Output Type: Join Player Info (Admin Channel) (Simple/Embed)")]
            public string OutputTypeJoinAdminChan { get; set; }

            [JsonProperty(PropertyName = "Output Type: Kicks (Simple/Embed)")]
            public string OutputTypeKicks { get; set; }

            [JsonProperty(PropertyName = "Output Type: Note Logging (Simple/Embed)")]
            public string OutputTypeNoteLog { get; set; }

            [JsonProperty(PropertyName = "Output Type: Player Name Change (Simple/Embed)")]
            public string OutputTypeNameChange { get; set; }

            [JsonProperty(PropertyName = "Output Type: /Report (Simple/Embed)")]
            public string OutputTypeReports { get; set; }

            [JsonProperty(PropertyName = "Output Type: Server Wipe (Simple/Embed)")]
            public string OutputTypeServerWipe { get; set; }

            [JsonProperty(PropertyName = "Output Type: Teams (Simple/Embed)")]
            public string OutputTypeTeams { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Admin Hammer (Simple/Embed)")]
            public string OutputTypeAdminHammer { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Admin Radar (Simple/Embed)")]
            public string OutputTypeAdminRadar { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Better Chat Mute (Simple/Embed)")]
            public string OutputTypeBetterChatMute { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Clans (Simple/Embed)")]
            public string OutputTypeClans { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Dangerous Treasures (Simple/Embed)")]
            public string OutputTypeDangerousTreasures { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Discord Auth (Simple/Embed)")]
            public string OutputTypeDiscordAuth { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Godmode (Simple/Embed)")]
            public string OutputTypeGodmode { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Kits (Simple/Embed)")]
            public string OutputTypeKits { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Private Messages (Simple/Embed)")]
            public string OutputTypePMs { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Raidable Bases (Simple/Embed)")]
            public string OutputTypeRaidableBases { get; set; }

            [JsonProperty(PropertyName = "Output Type (Plugin): Vanish (Simple/Embed)")]
            public string OutputTypeVanish { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): AirEvent (Simple/Embed)")]
            public string OutputTypeAirEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): ArmoredTrainEvent (Simple/Embed)")]
            public string OutputTypeArmoredTrainEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): CargoTrainEvent (Simple/Embed)")]
            public string OutputTypeCargoTrainEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): ConvoyEvent (Simple/Embed)")]
            public string OutputTypeConvoyEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): HarborEvent (Simple/Embed)")]
            public string OutputTypeHarborEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): JunkyardEvent (Simple/Embed)")]
            public string OutputTypeJunkyardEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): PowerPlantEvent (Simple/Embed)")]
            public string OutputTypePowerPlantEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): SatDishEvent (Simple/Embed)")]
            public string OutputTypeSatDishEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): SputnikEvent (Simple/Embed)")]
            public string OutputTypeSputnikEvent { get; set; }

            [JsonProperty(PropertyName = "Output Type (Premium Plugin): WaterEvent (Simple/Embed)")]
            public string OutputTypeWaterEvent { get; set; }
        }

        public class ExcludedSettings
        {
            [JsonProperty(PropertyName = "Exclude Listed Groups From log_groups")]
            public List<string> LogExcludeGroups { get; set; }

            [JsonProperty(PropertyName = "Exclude Listed Permissions From log_perms")]
            public List<string> LogExcludePerms { get; set; }
        }

        public class FilterSettings
        {
            [JsonProperty(PropertyName = "Chat Filter: Replacement Word")]
            public string FilteredWord { get; set; }

            [JsonProperty(PropertyName = "Chat Filter: Words to Filter")]
            public List<string> FilterWords { get; set; }
        }
        #endregion

        #region Default Config
        private Settings GetDefaultSettings()
        {
            return new Settings
            {
                General = new GeneralSettings
                {
                    Apikey = "BotToken",
                    AutoReloadPlugin = false,
                    AutoReloadTime = 901,
                    EnableBotStatus = false,
                    ReportCommand = "report",
                    ExtensionDebugging = DiscordLogLevel.Info
                },
                DiscordSide = new DiscordSideSettings
                {
                    Commandprefix = "!",
                    GameChatIconSteamID = 76561199066612103,
                    GameChatTag = "[RUSTCORD]",
                    GameChatTagColor = "#7289DA",
                    GameChatNameColor = "#55aaff",
                    GameChatTextColor = "#ffffff",
                },
                GameLog = new GameLogSettings
                {
                    LogChat = true,
                    LogJoinQuits = true,
                    LogDeaths = false,
                    LogVehicleSpawns = false,
                    LogCrateDrops = false,
                    LogUserGroups = false,
                    LogPermissions = false,
                    LogKickBans = true,
                    LogNameChanges = false,
                    LogServerCommands = false,
                    LogServerMessages = false,
                    LogF7Reports = false,
                    LogTeams = false,
                    LogRCON = false,
                    LogSpectates = false,
                    LogServerWipe = false,
                    EnableCustomLogging = false
                },
                PluginLog = new PluginLogSettings
                {
                    LogPluginAdminHammer = false,
                    LogPluginAdminRadar = false,
                    LogPluginBetterChatMute = false,
                    LogPluginClans = false,
                    LogPluginDangerousTreasures = false,
                    LogPluginDiscordAuth = false,
                    LogPluginGodmode = false,
                    LogPluginKits = false,
                    LogPluginPrivateMessages = false,
                    LogPluginRaidableBases = false,
                    LogPluginSignArtist = false,
                    LogPluginVanish = false
                },
                PremiumPluginLog = new PremiumPluginLogSettings
                {
                    LogPluginAirEvent = false,
                    LogPluginArmoredTrainEvent = false,
                    LogPluginCargoTrainEvent = false,
                    LogPluginConvoyEvent = false,
                    LogPluginHarborEvent = false,
                    LogPluginJunkyardEvent = false,
                    LogPluginPowerPlantEvent = false,
                    LogPluginSputnikEvent = false,
                    LogPluginSatDishEvent = false,
                    LogPluginWaterEvent = false
                },
                OutputFormat = new OutputSettings
                {
                    OutputTypeBans = "Simple",
                    OutputTypeBugs = "Simple",
                    OutputTypeDeaths = "Simple",
                    OutputTypeF7Report = "Simple",
                    OutputTypeJoinQuit = "Simple",
                    OutputTypeJoinAdminChan = "Simple",
                    OutputTypeKicks = "Simple",
                    OutputTypeNameChange = "Simple",
                    OutputTypeNoteLog = "Simple",
                    OutputTypeReports = "Simple",
                    OutputTypeServerWipe = "Simple",
                    OutputTypeTeams = "Simple",
                    OutputTypeAdminHammer = "Simple",
                    OutputTypeAdminRadar = "Simple",
                    OutputTypeBetterChatMute = "Simple",
                    OutputTypeClans = "Simple",
                    OutputTypeDangerousTreasures = "Simple",
                    OutputTypeDiscordAuth = "Simple",
                    OutputTypeGodmode = "Simple",
                    OutputTypeKits = "Simple",
                    OutputTypePMs = "Simple",
                    OutputTypeRaidableBases = "Simple",
                    OutputTypeVanish = "Simple",
                    OutputTypeAirEvent = "Simple",
                    OutputTypeArmoredTrainEvent = "Simple",
                    OutputTypeCargoTrainEvent = "Simple",
                    OutputTypeConvoyEvent = "Simple",
                    OutputTypeHarborEvent = "Simple",
                    OutputTypeJunkyardEvent = "Simple",
                    OutputTypePowerPlantEvent = "Simple",
                    OutputTypeSputnikEvent = "Simple",
                    OutputTypeSatDishEvent = "Simple",
                    OutputTypeWaterEvent = "Simple"
                },

                Channels = new List<Settings.Channel>
                    {
                        new Settings.Channel
                            {
                                perms = new List<string>
                                {
                                    "cmd_allow",
                                    "cmd_players",
                                    "cmd_kick",
                                    "cmd_com",
                                    "cmd_mute",
                                    "cmd_unmute",
                                    "msg_join",
                                    "msg_quit",
                                    "death_pvp",
                                    "msg_chat",
                                    "game_bug",
                                    "msg_serverinit"
                                },
                                CustomFilter = new List<string>
                                {
                                    "keyword1",
                                    "keyword2"
                                }
                        },
                        new Settings.Channel
                        {
                            perms = new List<string>
                            {
                                "msg_joinlog",
                                "game_report",
                                "msg_teamchat",
                                "game_bug"
                            },
                            CustomFilter = new List<string>
                            {
                                "keyword1",
                                "keyword2"
                            }
                        }
                    },
                Commandroles = new Dictionary<string, List<string>>
                {
                    {
                        "players", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "mute", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "unmute", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "kick", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "ban", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "timeban", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "unban", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    },
                    {
                        "com", new List<string>()
                        {
                            "DiscordRoleName",
                            "DiscordRoleName2"
                        }
                    }
                },
                Filters = new FilterSettings
                {
                    FilterWords = new List<string>
                    {
                        "badword1",
                        "badword2"
                    },
                    FilteredWord = "<censored>",
                },
                Excluded = new ExcludedSettings
                {
                    LogExcludeGroups = new List<string>
                    {
                        "example-group1",
                        "example-group2"
                    },
                    LogExcludePerms = new List<string>
                    {
                        "example.permission1",
                        "example.permission2"
                    }
                },

            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Attempting to create default config...");
            Config.Clear();
            Config.WriteObject(GetDefaultSettings(), true);
            Config.Save();
        }
        #endregion

        #region Hooks
        void SubscribeHooks()
        {
            if (_settings.GameLog.LogChat) Subscribe(nameof(OnPlayerChat));
            if (_settings.GameLog.LogJoinQuits)
            {
                Subscribe(nameof(OnPlayerConnected));
                Subscribe(nameof(OnPlayerDisconnected));
            }



            if (_settings.GameLog.LogDeaths)
            {
                if (_settings.OutputFormat.OutputTypeDeaths == "DeathNotes") Subscribe(nameof(OnDeathNotice));
                if ((_settings.OutputFormat.OutputTypeDeaths == "Simple") || (_settings.OutputFormat.OutputTypeDeaths == "Embed")) Subscribe(nameof(OnPlayerDeath));
            }


            if (_settings.GameLog.LogVehicleSpawns) Subscribe(nameof(OnEntitySpawned));
            if (_settings.GameLog.LogCrateDrops)
            {
                Subscribe(nameof(OnCrateDropped));
                Subscribe(nameof(OnSupplyDropLanded));
            }
            if (_settings.GameLog.LogUserGroups)
            {
                Subscribe(nameof(OnGroupCreated));
                Subscribe(nameof(OnGroupDeleted));
                Subscribe(nameof(OnUserGroupAdded));
                Subscribe(nameof(OnUserGroupRemoved));
            }
            if (_settings.GameLog.LogPermissions)
            {
                Subscribe(nameof(OnUserPermissionGranted));
                Subscribe(nameof(OnGroupPermissionGranted));
                Subscribe(nameof(OnUserPermissionRevoked));
                Subscribe(nameof(OnGroupPermissionRevoked));
            }
            if (_settings.GameLog.LogKickBans)
            {
                Subscribe(nameof(OnUserKicked));
                Subscribe(nameof(OnUserBanned));
                Subscribe(nameof(OnUserUnbanned));
            }
            if (_settings.GameLog.LogNameChanges) Subscribe(nameof(OnUserNameUpdated));
            if (_settings.GameLog.LogServerMessages) Subscribe(nameof(OnServerMessage));
            if (_settings.GameLog.LogServerCommands) Subscribe(nameof(OnServerCommand));
            if (_settings.GameLog.LogF7Reports) Subscribe(nameof(OnPlayerReported));
            if (_settings.GameLog.LogServerWipe) Subscribe(nameof(OnNewSave));
            if (_settings.GameLog.LogTeams)
            {
                Subscribe(nameof(OnTeamCreated));
                Subscribe(nameof(OnTeamAcceptInvite));
                Subscribe(nameof(OnTeamLeave));
                Subscribe(nameof(OnTeamKick));
                Subscribe(nameof(OnTeamDisbanded));
            }
            if (_settings.GameLog.LogRCON)
            {
                Subscribe(nameof(OnRconConnection));
            }
            if (_settings.GameLog.LogSpectates)
            {
                Subscribe(nameof(OnPlayerSpectate));
                Subscribe(nameof(OnPlayerSpectateEnd));
            }
            if (_settings.PluginLog.LogPluginAdminHammer)
            {
                Subscribe(nameof(OnAdminHammerEnabled));
                Subscribe(nameof(OnAdminHammerDisabled));
            }
            if (_settings.PluginLog.LogPluginAdminRadar)
            {
                Subscribe(nameof(OnRadarActivated));
                Subscribe(nameof(OnRadarDeactivated));
            }
            if (_settings.PluginLog.LogPluginBetterChatMute)
            {
                Subscribe(nameof(OnBetterChatMuted));
                Subscribe(nameof(OnBetterChatTimeMuted));
                Subscribe(nameof(OnBetterChatUnmuted));
                Subscribe(nameof(OnBetterChatMuteExpired));
            }
            if (_settings.PluginLog.LogPluginClans)
            {
                Subscribe(nameof(OnClanCreate));
                Subscribe(nameof(OnClanDisbanded));
                Subscribe(nameof(OnClanChat));
            }
            if (_settings.PluginLog.LogPluginDangerousTreasures)
            {
                Subscribe(nameof(OnDangerousEventStarted));
                Subscribe(nameof(OnDangerousEventEnded));
            }
            if (_settings.PluginLog.LogPluginGodmode)
            {
                Subscribe(nameof(OnGodmodeToggled));
            }
            if (_settings.PluginLog.LogPluginKits)
            {
                Subscribe(nameof(OnKitRedeemed));
            }
            if (_settings.PluginLog.LogPluginPrivateMessages) Subscribe(nameof(OnPMProcessed));
            if (_settings.PluginLog.LogPluginRaidableBases)
            {
                Subscribe(nameof(OnRaidableBaseStarted));
                Subscribe(nameof(OnRaidableBaseEnded));
            }
            if (_settings.PluginLog.LogPluginSignArtist) Subscribe(nameof(OnImagePost));
            if (_settings.PluginLog.LogPluginDiscordAuth)
            {
                Subscribe(nameof(OnDiscordPlayerLinked));
                Subscribe(nameof(OnDiscordPlayerUnlinked));
            }
            if (_settings.PluginLog.LogPluginVanish)
            {
                Subscribe(nameof(OnVanishDisappear));
                Subscribe(nameof(OnVanishReappear));
            }
            if (_settings.PremiumPluginLog.LogPluginAirEvent)
            {
                Subscribe(nameof(OnAirEventStart));
                Subscribe(nameof(OnAirEventEnd));
            }
            if (_settings.PremiumPluginLog.LogPluginArmoredTrainEvent)
            {
                Subscribe(nameof(OnArmoredTrainEventStart));
                Subscribe(nameof(OnArmoredTrainEventStop));
            }
            if (_settings.PremiumPluginLog.LogPluginCargoTrainEvent)
            {
                Subscribe(nameof(OnTrainEventStarted));
                Subscribe(nameof(OnTrainEventEnded));
            }
            if (_settings.PremiumPluginLog.LogPluginConvoyEvent)
            {
                Subscribe(nameof(OnConvoyStart));
                Subscribe(nameof(OnConvoyStop));
            }
            if (_settings.PremiumPluginLog.LogPluginHarborEvent)
            {
                Subscribe(nameof(OnHarborEventStart));
                Subscribe(nameof(OnHarborEventEnd));
            }
            if (_settings.PremiumPluginLog.LogPluginJunkyardEvent)
            {
                Subscribe(nameof(OnJunkyardEventStart));
                Subscribe(nameof(OnJunkyardEventEnd));
            }
            if (_settings.PremiumPluginLog.LogPluginPowerPlantEvent)
            {
                Subscribe(nameof(OnPowerPlantEventStart));
                Subscribe(nameof(OnPowerPlantEventEnd));
            }
            if (_settings.PremiumPluginLog.LogPluginSputnikEvent)
            {
                Subscribe(nameof(OnSputnikEventStart));
                Subscribe(nameof(OnSputnikEventStop));
            }
            if (_settings.PremiumPluginLog.LogPluginSatDishEvent)
            {
                Subscribe(nameof(OnSatDishEventStart));
                Subscribe(nameof(OnSatDishEventEnd));
            }
            if (_settings.PremiumPluginLog.LogPluginWaterEvent)
            {
                Subscribe(nameof(OnWaterEventStart));
                Subscribe(nameof(OnWaterEventEnd));
            }
        }
        private void Init()
        {
            cache[CacheType.OnPlayerChat] = new Dictionary<BasePlayer, Dictionary<string, string>>();
            cache[CacheType.OnPlayerConnected] = new Dictionary<BasePlayer, Dictionary<string, string>>();
            cache[CacheType.OnPlayerDisconnected] = new Dictionary<BasePlayer, Dictionary<string, string>>();
            cache[CacheType.OnPlayerJoin] = new Dictionary<BasePlayer, Dictionary<string, string>>();
            UnsubscribeHooks();
        }

        void UnsubscribeHooks()
        {
            Unsubscribe(nameof(OnPlayerChat));
            Unsubscribe(nameof(OnPlayerConnected));
            Unsubscribe(nameof(OnPlayerDisconnected));
            Unsubscribe(nameof(OnDeathNotice));
            Unsubscribe(nameof(OnPlayerDeath));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnCrateDropped));
            Unsubscribe(nameof(OnSupplyDropLanded));
            Unsubscribe(nameof(OnGroupCreated));
            Unsubscribe(nameof(OnGroupDeleted));
            Unsubscribe(nameof(OnUserGroupAdded));
            Unsubscribe(nameof(OnUserGroupRemoved));
            Unsubscribe(nameof(OnUserPermissionGranted));
            Unsubscribe(nameof(OnGroupPermissionGranted));
            Unsubscribe(nameof(OnUserPermissionRevoked));
            Unsubscribe(nameof(OnGroupPermissionRevoked));
            Unsubscribe(nameof(OnUserKicked));
            Unsubscribe(nameof(OnUserBanned));
            Unsubscribe(nameof(OnUserUnbanned));
            Unsubscribe(nameof(OnUserNameUpdated));
            Unsubscribe(nameof(OnServerMessage));
            Unsubscribe(nameof(OnServerCommand));
            Unsubscribe(nameof(OnPlayerReported));
            Unsubscribe(nameof(OnTeamCreated));
            Unsubscribe(nameof(OnTeamAcceptInvite));
            Unsubscribe(nameof(OnTeamLeave));
            Unsubscribe(nameof(OnTeamKick));
            Unsubscribe(nameof(OnTeamDisbanded));
            Unsubscribe(nameof(OnRconConnection));
            Unsubscribe(nameof(OnPlayerSpectate));
            Unsubscribe(nameof(OnPlayerSpectateEnd));
            Unsubscribe(nameof(OnAdminHammerEnabled));
            Unsubscribe(nameof(OnAdminHammerDisabled));
            Unsubscribe(nameof(OnRadarActivated));
            Unsubscribe(nameof(OnRadarDeactivated));
            Unsubscribe(nameof(OnBetterChatTimeMuted));
            Unsubscribe(nameof(OnBetterChatMuted));
            Unsubscribe(nameof(OnBetterChatTimeMuted));
            Unsubscribe(nameof(OnBetterChatUnmuted));
            Unsubscribe(nameof(OnBetterChatMuteExpired));
            Unsubscribe(nameof(OnClanCreate));
            Unsubscribe(nameof(OnClanDisbanded));
            Unsubscribe(nameof(OnClanChat));
            Unsubscribe(nameof(OnPMProcessed));
            Unsubscribe(nameof(OnImagePost));
            Unsubscribe(nameof(OnDiscordPlayerLinked));
            Unsubscribe(nameof(OnDiscordPlayerUnlinked));
            Unsubscribe(nameof(OnRaidableBaseStarted));
            Unsubscribe(nameof(OnRaidableBaseEnded));
            Unsubscribe(nameof(OnGodmodeToggled));
            Unsubscribe(nameof(OnKitRedeemed));
            Unsubscribe(nameof(OnDangerousEventStarted));
            Unsubscribe(nameof(OnDangerousEventEnded));
            Unsubscribe(nameof(OnAirEventStart));
            Unsubscribe(nameof(OnAirEventEnd));
            Unsubscribe(nameof(OnArmoredTrainEventStart));
            Unsubscribe(nameof(OnArmoredTrainEventStop));
            Unsubscribe(nameof(OnTrainEventStarted));
            Unsubscribe(nameof(OnTrainEventEnded));
            Unsubscribe(nameof(OnConvoyStart));
            Unsubscribe(nameof(OnConvoyStop));
            Unsubscribe(nameof(OnHarborEventStart));
            Unsubscribe(nameof(OnHarborEventEnd));
            Unsubscribe(nameof(OnJunkyardEventStart));
            Unsubscribe(nameof(OnJunkyardEventEnd));
            Unsubscribe(nameof(OnPowerPlantEventStart));
            Unsubscribe(nameof(OnPowerPlantEventEnd));
            Unsubscribe(nameof(OnSatDishEventStart));
            Unsubscribe(nameof(OnSatDishEventEnd));
            Unsubscribe(nameof(OnSputnikEventStart));
            Unsubscribe(nameof(OnSputnikEventStop));
            Unsubscribe(nameof(OnWaterEventStart));
            Unsubscribe(nameof(OnWaterEventEnd));
        }
        #endregion

        #region Null Config Check
        private void Loaded()
        {
            _settings = Config.ReadObject<Settings>();

            // Make sure objects are not taken off the config, otherwise some parts of code will release NRE.

            if (_settings.OutputFormat.OutputTypeBans == null)
                _settings.OutputFormat.OutputTypeBans = "Simple";
            if (_settings.OutputFormat.OutputTypeBugs == null)
                _settings.OutputFormat.OutputTypeBugs = "Simple";
            if (_settings.OutputFormat.OutputTypeDeaths == null)
                _settings.OutputFormat.OutputTypeDeaths = "Simple";
            if (_settings.OutputFormat.OutputTypeF7Report == null)
                _settings.OutputFormat.OutputTypeF7Report = "Simple";
            if (_settings.OutputFormat.OutputTypeJoinQuit == null)
                _settings.OutputFormat.OutputTypeJoinQuit = "Simple";
            if (_settings.OutputFormat.OutputTypeJoinAdminChan == null)
                _settings.OutputFormat.OutputTypeJoinAdminChan = "Simple";
            if (_settings.OutputFormat.OutputTypeKicks == null)
                _settings.OutputFormat.OutputTypeKicks = "Simple";
            if (_settings.OutputFormat.OutputTypeNameChange == null)
                _settings.OutputFormat.OutputTypeNameChange = "Simple";
            if (_settings.OutputFormat.OutputTypeNoteLog == null)
                _settings.OutputFormat.OutputTypeNoteLog = "Simple";
            if (_settings.OutputFormat.OutputTypeReports == null)
                _settings.OutputFormat.OutputTypeReports = "Simple";
            if (_settings.OutputFormat.OutputTypeServerWipe == null)
                _settings.OutputFormat.OutputTypeServerWipe = "Simple";
            if (_settings.OutputFormat.OutputTypeTeams == null)
                _settings.OutputFormat.OutputTypeTeams = "Simple";
            if (_settings.OutputFormat.OutputTypeAdminHammer == null)
                _settings.OutputFormat.OutputTypeAdminHammer = "Simple";
            if (_settings.OutputFormat.OutputTypeAdminRadar == null)
                _settings.OutputFormat.OutputTypeAdminRadar = "Simple";
            if (_settings.OutputFormat.OutputTypeBetterChatMute == null)
                _settings.OutputFormat.OutputTypeBetterChatMute = "Simple";
            if (_settings.OutputFormat.OutputTypeClans == null)
                _settings.OutputFormat.OutputTypeClans = "Simple";
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == null)
                _settings.OutputFormat.OutputTypeDangerousTreasures = "Simple";
            if (_settings.OutputFormat.OutputTypeDiscordAuth == null)
                _settings.OutputFormat.OutputTypeDiscordAuth = "Simple";
            if (_settings.OutputFormat.OutputTypeKits == null)
                _settings.OutputFormat.OutputTypeKits = "Simple";
            if (_settings.OutputFormat.OutputTypePMs == null)
                _settings.OutputFormat.OutputTypePMs = "Simple";
            if (_settings.OutputFormat.OutputTypeRaidableBases == null)
                _settings.OutputFormat.OutputTypeRaidableBases = "Simple";
            if (_settings.OutputFormat.OutputTypeVanish == null)
                _settings.OutputFormat.OutputTypeVanish = "Simple";
            if (_settings.OutputFormat.OutputTypeAirEvent == null)
                _settings.OutputFormat.OutputTypeAirEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == null)
                _settings.OutputFormat.OutputTypeArmoredTrainEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == null)
                _settings.OutputFormat.OutputTypeCargoTrainEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeConvoyEvent == null)
                _settings.OutputFormat.OutputTypeConvoyEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeHarborEvent == null)
                _settings.OutputFormat.OutputTypeHarborEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == null)
                _settings.OutputFormat.OutputTypeJunkyardEvent = "Simple";
            if (_settings.OutputFormat.OutputTypePowerPlantEvent == null)
                _settings.OutputFormat.OutputTypePowerPlantEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeSatDishEvent == null)
                _settings.OutputFormat.OutputTypeSatDishEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeSputnikEvent == null)
                _settings.OutputFormat.OutputTypeSputnikEvent = "Simple";
            if (_settings.OutputFormat.OutputTypeWaterEvent == null)
                _settings.OutputFormat.OutputTypeWaterEvent = "Simple";

            foreach (var channel in _settings.Channels)
            {
                if (channel.CustomFilter == null)
                {
                    channel.CustomFilter = new List<string>();
                }
            }
            if (_settings.General.ReportCommand == null)
                _settings.General.ReportCommand = "report";
            if (string.IsNullOrEmpty(_settings.DiscordSide.GameChatTag))
                _settings.DiscordSide.GameChatTag = "[Rustcord]";
            if (string.IsNullOrEmpty(_settings.DiscordSide.GameChatTagColor))
                _settings.DiscordSide.GameChatTagColor = "#7289DA";
            if (string.IsNullOrEmpty(_settings.DiscordSide.GameChatNameColor))
                _settings.DiscordSide.GameChatNameColor = "#55aaff";
            if (string.IsNullOrEmpty(_settings.DiscordSide.GameChatTextColor))
                _settings.DiscordSide.GameChatTextColor = "#ffffff";
            if (_settings.DiscordSide.GameChatIconSteamID.Equals(0uL))
                _settings.DiscordSide.GameChatIconSteamID = 76561199066612103;
            if (_settings.Channels == null)
                _settings.Channels = new List<Settings.Channel>();
            if (_settings.Commandroles == null)
                _settings.Commandroles = new Dictionary<string, List<string>>();
            _settings.Filters = new FilterSettings
            {
                FilteredWord = _settings.Filters?.FilteredWord ?? "<censored>",
                FilterWords = _settings.Filters?.FilterWords ?? new List<string>()
            };
            if (_settings.Excluded.LogExcludeGroups == null)
                _settings.Excluded.LogExcludeGroups = new List<string>();
            if (_settings.Excluded.LogExcludePerms == null)
                _settings.Excluded.LogExcludePerms = new List<string>();

            Config.WriteObject(_settings, true);
            // ------------------------------------------------------------------------
        }
        #endregion

        #region Language File
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Discord_PlayersResponse", ":mag_right: Connected Players [{playercount}/{maxplayers}]: {playerslist}" },
                { "Discord_Status", "{playercount}/{maxplayers} Online, {sleepercount} Sleepers." },
                { "RUST_OnInitMsg", ":vertical_traffic_light: Server is back online! Players may now re-join. :vertical_traffic_light:" },
                { "RUST_OnServerShutdown", ":vertical_traffic_light: Server shutting down. :vertical_traffic_light:" },
                { "RUST_OnPlayerGesture", ":speech_left: {playername}: {gesture}"},
                { "RUST_OnPlayerChat", ":speech_left: {playername}: {message}"},
                { "RUST_OnPlayerTeamChat", ":speech_left: {playername}: {message}"},
                { "RUST_OnPlayerJoin", ":white_check_mark: {playername} has connected!" },
                { "RUST_OnPlayerJoinAdminLog", ":clipboard: {playername} has connected! (IP: {playerip}    SteamID: {playersteamid})" },
                { "RUST_OnPlayerQuit", ":x: {playername} has disconnected! ({reason})" },
                { "RUST_OnPlayerBug", ":beetle: {playername}: {message}"},
                { "RUST_OnPlayerReport", ":warning: {playername}: {message}"},
                { "RUST_OnPlaneSpawn", ":airplane: Cargo Plane has spawned."},
                { "RUST_OnBradleySpawn", ":trolleybus: Bradley APC has spawned."},
                { "RUST_OnShipSpawn", ":ship: Cargo Ship has spawned."},
                { "RUST_OnSupplyDrop", ":airplane: A supply drop has landed."},
                { "RUST_OnHeliSpawn", ":helicopter: Patrol Helicopter has spawned."},
                { "RUST_OnChinookSpawn", ":helicopter: Chinook Helicopter has spawned."},
                { "RUST_OnCrateDropped", ":helicopter: A Chinook has delivered a crate."},
                { "RUST_OnTeamAcceptInvite", ":family_mwgb: {playername} joined {teamleader}'s team. ({teamid})"},
                { "RUST_OnTeamCreated", ":family_mwgb: {playername} created a new team. ({teamid})"},
                { "RUST_OnTeamKicked", ":family_mwgb: {teamleader} kicked {playername} from their team. ({teamid})"},
                { "RUST_OnTeamLeave", ":family_mwgb: {playername} left {teamleader}'s team ({teamid})."},
                { "RUST_OnTeamDisbanded", ":family_mwgb: {teamleader}'s team has been disbanded. ({teamid})"},
                { "RUST_OnGroupCreated", ":desktop: Group {groupname} has been created."},
                { "RUST_OnGroupDeleted", ":desktop: Group {groupname} has been deleted."},
                { "RUST_OnUserGroupAdded", ":desktop: {playername} ({playersteamid}) has been added to group: {groupname}."},
                { "RUST_OnUserGroupRemoved", ":desktop: {playername} ({playersteamid}) has been removed from group: {groupname}."},
                { "RUST_OnUserPermissionGranted", ":desktop: {playername} ({playersteamid}) has been granted permission: {permission}."},
                { "RUST_OnGroupPermissionGranted", ":desktop: Group {groupname} has been granted permission: {permission}."},
                { "RUST_OnUserPermissionRevoked", ":desktop: {playername} ({playersteamid}) has been revoked permission: {permission}."},
                { "RUST_OnGroupPermissionRevoked", ":desktop: Group {groupname} has been revoked permission: {permission}."},
                { "RUST_OnPlayerKicked", ":desktop: {playername} has been kicked for: {reason}"},
                { "RUST_OnPlayerBanned", ":desktop: {playername} ({playersteamid}/{playerip}) has been banned for: {reason}"}, //only works with vanilla/native system atm
				{ "RUST_OnPlayerUnBanned", ":desktop: {playername} ({playersteamid}/{playerip}) has been unbanned."}, //only works with vanilla/native system atm
				{ "RUST_OnPlayerNameChange", ":desktop: {oldname} ({playersteamid}) is now playing as {newname}."},
                { "RUST_OnPlayerReported", ":desktop: {reporter} reported {targetname} ({targetsteamid}) to Facepunch for {reason}. Message: {message}"},
                { "RUST_OnPlayerDeath", ":skull_crossbones: {killer} killed {victim}."},
                { "RUST_OnF1ItemSpawn", ":desktop: {playername}: {givemessage}."},
                { "RUST_OnNoteUpdate", ":desktop: [NOTES] {playername}: {notemessage}."},
                { "RUST_OnRCONConnected", ":desktop: [RCON] New connection from: {ip}."},
                { "RUST_OnPlayerSpectate", ":desktop: {playername} is spectating {targetname}"},
                { "RUST_CustomLog", ":desktop: [Custom] {logtext}"},
                { "RUST_OnPlayerSpectateEnd", ":desktop: {playername} stopped spectating {targetname}"},
                { "RUST_OnServerWipe", ":map: Server has started a fresh wipe!"},
                { "PLUGIN_AdminHammer_Enabled", ":hammer: {playername} has enabled Admin Hammer."},
                { "PLUGIN_AdminHammer_Disabled", ":hammer: {playername} has disabled Admin Hammer."},
                { "PLUGIN_AdminRadar_Enabled", ":satellite: {playername} has enabled Admin Radar."},
                { "PLUGIN_AdminRadar_Disabled", ":satellite: {playername} has disabled Admin Radar."},
                { "PLUGIN_BetterChatMute_Mute", "[MUTE] :zipper_mouth: {muter} has permanently muted {targetname}. Reason: {reason}"},
                { "PLUGIN_BetterChatMute_UnMute", "[MUTE] :loudspeaker: {unmuter} has unmuted {targetname}."},
                { "PLUGIN_BetterChatMute_TimedMute", "[MUTE] :hourglass_flowing_sand: {muter} has been temporarily muted {targetname} for {duration}. Reason: {reason}"},
                { "PLUGIN_BetterChatMute_MuteExpire", "[MUTE] :hourglass: {targetname}'s temporary mute has expired."},
                { "PLUGIN_Clans_Chat", ":speech_left: [CLANS] {playername}: {message}"},
                { "PLUGIN_Clans_CreateClan", ":family_mwgb: Clan [{clantag}] has been created."},
                { "PLUGIN_Clans_DisbandClan", ":family_mwgb: Clan [{clantag}] has been disbanded."},
                { "PLUGIN_DangerousTreasures_Started", ":moneybag: Dangerous Treasure event has started at {gridposition} {position}."},
                { "PLUGIN_DangerousTreasures_Ended", ":moneybag: Dangerous Treasure event at {gridposition} has ended."},
                { "PLUGIN_DeathNotes_Death", ":skull_crossbones: {deathmessage}"},
                { "PLUGIN_DiscordAuth_Auth", ":lock: {gamename} has linked to Discord account {discordname}."},
                { "PLUGIN_DiscordAuth_Deauth", ":unlock: {gamename} has been unlinked from Discord."},
                { "PLUGIN_Godmode_Enabled", ":shield: {playername} has enabled God Mode."},
                { "PLUGIN_Godmode_Disabled", ":shield: {playername} has disabled God Mode."},
                { "PLUGIN_Kits_Redeemed", ":gift: {playername} redeemed kit: {kitname}."},
                { "PLUGIN_PrivateMessages_PM", "[PM] {sendername}  :incoming_envelope: {targetname}: {message}"},
                { "PLUGIN_RaidableBases_Started", ":house: {difficulty} Raidable Base has spawned at {position}."},
                { "PLUGIN_RaidableBases_Ended", ":house: {difficulty} Raidable Base at {position} has ended."},
                { "PLUGIN_SignArtist", "{playername} posted an image to a sign.\nPosition: ({position})"},
                { "PLUGIN_Vanish_Disappear", ":ghost: {playername} has vanished." },
                { "PLUGIN_Vanish_Reappear", ":ghost: {playername} has reappeared." },
                { "PLUGIN_AirEvent_Started", ":helicopter: Air Event has started." },
                { "PLUGIN_AirEvent_Ended", ":helicopter: Air Event has ended." },
                { "PLUGIN_ArmoredTrainEvent_Started", ":train2: Armored Train Event has started." },
                { "PLUGIN_ArmoredTrainEvent_Ended", ":train2: Armored Train Event has ended." },
                { "PLUGIN_CargoTrainEvent_Started", ":tram: Cargo Train Event has started." },
                { "PLUGIN_CargoTrainEvent_Ended", ":tram: Cargo Train Event has ended." },
                { "PLUGIN_ConvoyEvent_Started", ":truck: Convoy Event has started." },
                { "PLUGIN_ConvoyEvent_Ended", ":truck: Convoy Event has ended." },
                { "PLUGIN_HarborEvent_Started", ":ship: Harbor Event has started." },
                { "PLUGIN_HarborEvent_Ended", ":ship: Harbor Event has ended." },
                { "PLUGIN_JunkyardEvent_Started", ":construction_site: Junkyard Event has started." },
                { "PLUGIN_JunkyardEvent_Ended", ":construction_site: Junkyard Event has ended." },
                { "PLUGIN_PowerPlantEvent_Started", ":zap: Power Plant Event has started." },
                { "PLUGIN_PowerPlantEvent_Ended", ":zap: Power Plant Event has ended." },
                { "PLUGIN_SatDishEvent_Started", ":satellite: Satellite Dish Event has started." },
                { "PLUGIN_SatDishEvent_Ended", ":satellite: Satellite Dish Event has ended." },
                { "PLUGIN_SputnikEvent_Started", ":satellite_orbital: Sputnik Event has started." },
                { "PLUGIN_SputnikEvent_Ended", ":satellite_orbital: Sputnik Dish Event has ended." },
                { "PLUGIN_WaterEvent_Started", ":anchor: Water Event has started." },
                { "PLUGIN_WaterEvent_Ended", ":anchor: Water Event has ended." }
            }, this);
        }
        #endregion

        #region Discord Commands
        private void DiscordToGameCmd(string command, string param, DiscordUser author, Snowflake channelid)
        {
            switch (command)
            {
                case "players":
                    {
                        string listStr = string.Empty;
                        var pList = BasePlayer.activePlayerList;
                        int i = 0;
                        foreach (var player in pList)
                        {
                            listStr += player.displayName + " " + "[" + (i++ + 1) + "]";
                            if (i != pList.Count)
                                listStr += ", ";

                            

                            if (i % 25 == 0 || i == pList.Count)
                            {
                                var text = new Dictionary<string, string>
                                {
                                    ["playercount"] = Convert.ToString(BasePlayer.activePlayerList.Count),
                                    ["maxplayers"] = Convert.ToString(ConVar.Server.maxplayers),
                                    ["playerslist"] = listStr
                                };
                                GetChannel(Client, channelid, chan =>
                                {
                                    chan.CreateMessage(Client, Translate("Discord_PlayersResponse", text));
                                });
                                text.Clear();
                                listStr = string.Empty;
                            }
                            
                        }
                        if (pList.Count < 1)
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Server is empty!");
                            });
                        }
                        break;
                    }
                case "kick":
                    {
                        if (String.IsNullOrEmpty(param))
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Syntax: !kick <steam id> <reason>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length < 2)
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Syntax: !kick <steam id> <reason>");
                            });
                            return;
                        }
                        BasePlayer plr = BasePlayer.Find(_param[0]);
                        if (plr == null)
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Error: player not found");
                            });
                            return;
                        }
                        plr.Kick(param.Remove(0, _param[0].Length + 1));
                        GetChannel(Client, channelid, chan =>
                        {
                            chan.CreateMessage(Client, "Success: Kick command executed!");
                        });
                        break;
                    }
                case "timeban":
                    {
                        if (string.IsNullOrEmpty(param))
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Syntax: !timeban <steamid> <name> <duration> <reason>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length < 3)
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Syntax: !timeban <steamid> <name> <duration> <reason>");
                            });
                            return;
                        }
                        var plr = covalence.Players.FindPlayer(_param[0]);
                        if (plr == null)
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Error: player not found");
                            });
                            return;
                        }
                        string[] args = new string[4];
                        args[0] = _param[0]; // id
                        args[1] = _param[1]; // name
                        args[2] = "\""; // reason
                        for (int i = 3; i < _param.Length; i++)
                        {
                            args[2] += _param[i];
                            if (i != _param.Length - 1)
                                args[2] += " ";
                        }
                        args[2] += "\"";
                        args[3] = _param[2];
                        this.Server.Command("banid", args);
                        GetChannel(Client, channelid, chan =>
                        {
                            chan.CreateMessage(Client, "Success: Ban command executed!");
                        });
                        break;
                    }
                case "ban":
                    {
                        if (string.IsNullOrEmpty(param))
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Syntax: !ban <name/id> <reason>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length < 2)
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Syntax: !ban <name/id> <reason>");
                            });
                            return;
                        }
                        var plr = covalence.Players.FindPlayer(_param[0]);
                        if (plr == null)
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Error: player not found");
                            });
                            return;
                        }
                        plr.Ban(param.Remove(0, _param[0].Length + 1));
                        GetChannel(Client, channelid, chan =>
                        {
                            chan.CreateMessage(Client, "Success: Ban command executed!");
                        });
                        break;
                    }
                case "unban":
                    {
                        if (string.IsNullOrEmpty(param))
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Syntax: !unban <name/id>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        var plr = covalence.Players.FindPlayer(_param[0]);
                        if (plr == null)
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Error: player not found");
                            });
                            return;
                        }
                        plr.Unban();
                        GetChannel(Client, channelid, chan =>
                        {
                            chan.CreateMessage(Client, "Success: Unban command executed!");
                        });
                        break;
                    }
                case "com":
                    {
                        if (String.IsNullOrEmpty(param))
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Syntax: !com <command>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length > 1)
                        {
                            string[] args = new string[_param.Length - 1];
                            Array.Copy(_param, 1, args, 0, args.Length);
                            this.Server.Command(_param[0], args);
                        }
                        else
                        {
                            this.Server.Command(param);
                        }
                        GetChannel(Client, channelid, chan =>
                        {
                            chan.CreateMessage(Client, "Success: Console command executed!");
                        });
                        break;
                    }
                case "mute":
                    {
                        if (BetterChatMute == null)
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "This command requires the Better Chat Mute plugin.");
                                return;
                            });
                        }
                        if (string.IsNullOrEmpty(param))
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Syntax: !mute <playername/steamid> <time (optional)> <reason (optional)>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length >= 1)
                        {
                            this.Server.Command($"mute {string.Join(" ", _param)}");
                            return;
                        }
                        GetChannel(Client, channelid, chan =>
                        {
                            chan.CreateMessage(Client, "Success: Mute command executed!");
                        });
                        break;
                    }
                case "unmute":
                    {
                        if (BetterChatMute == null)
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "This command requires the Better Chat Mute plugin.");
                                return;
                            });
                        }
                        if (String.IsNullOrEmpty(param))
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Syntax: !unmute <playername/steamid>");
                            });
                            return;
                        }
                        string[] _param = param.Split(' ');
                        if (_param.Length > 1)
                        {
                            GetChannel(Client, channelid, chan =>
                            {
                                chan.CreateMessage(Client, "Syntax: !unmute <playername/steamid>");
                            });
                            return;
                        }
                        if (_param.Length == 1)
                        {
                            this.Server.Command($"unmute {string.Join(" ", _param)}");
                            return;
                        }
                        break;
                    }
            }

        }
        #endregion

        #region Game Commands
        // /report [message]
        void cmdReport(BasePlayer player, string command, string[] args)
        {
            if (args.Length < 1)
            {
                SendReply(player, "Syntax: /report [message]");
                return;
            }

            if (_settings.OutputFormat.OutputTypeReports == "Embed")
            {
                string message = string.Join(" ", args);
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("PLAYER REPORT")
                                                  .AddColor("#FF0000")
                                                  .AddThumbnail("https://i.imgur.com/qg7v0Tv.png")
                                                  .AddDescription($"{player.displayName} has submitted a report.")
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddField("Message", message, true);



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("game_report"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeReports == "Simple")
            {
                string message = string.Join(" ", args);

                var dict = new Dictionary<string, string>
                    {
                        { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                        { "playername", player.displayName },
                        { "message", message }
                    };

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("game_report"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnPlayerReport", dict));
                        });
                    }
                }
            }

            SendReply(player, "Your report has been submitted to Discord.");

        }

        void cmdBug(BasePlayer player, string command, string[] args)
        {
            if (args.Length < 1)
            {
                SendReply(player, "Syntax: /bug [message]");
                return;
            }
            if (_settings.OutputFormat.OutputTypeBugs == "Embed")
            {
                string message = string.Join(" ", args);
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("BUG REPORT")
                                                  .AddThumbnail("https://i.imgur.com/GLjfCFd.png")
                                                  .AddColor("#FF0000")
                                                  .AddDescription($"{player.displayName} has reported a bug.")
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddField("Bug", message, true);



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("game_bug"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBugs == "Simple")
            {
                string message = string.Join(" ", args);
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("game_bug"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnPlayerBug", new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName },
                            { "message", message }
                        }));
                        });
                    }
                }
            }

            SendReply(player, "Your bug report has been submitted to Discord.");

        }
        #endregion

        #region Rust Logging

        #region Chat Logging
        private void OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            if (Client == null) return;
            if (player == null || message == null) return;
            if (permission.UserHasPermission(player.UserIDString, "rustcord.hidechat")) return;
            if (BetterChatMute?.Call<bool>("API_IsMuted", player.IPlayer) ?? false) return;
            if (_settings.Filters.FilterWords != null && _settings.Filters.FilterWords.Count > 0)
            {
                for (int i = _settings.Filters.FilterWords.Count - 1; i >= 0; i--)
                {
                    while (message.Contains(" " + _settings.Filters.FilterWords[i] + " ") || message.Contains(_settings.Filters.FilterWords[i]))
                        message = message.Replace(_settings.Filters.FilterWords[i], _settings.Filters.FilteredWord ?? "");
                }
            }

            var text = GetPlayerCache(player, message, CacheType.OnPlayerChat);

            for (int i = 0; i < _settings.Channels.Count; i++)
            {
                if (_settings.Channels[i].perms.Contains(channel == ConVar.Chat.ChatChannel.Team ? "msg_teamchat" : "msg_chat"))
                {
                    if (!(player.IsValid())) continue;

                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate(channel == ConVar.Chat.ChatChannel.Team ? "RUST_OnPlayerTeamChat" : "RUST_OnPlayerChat", text));

                    });
                }
            }

            text.Clear();
        }
        #endregion

        #region Crate Logging
        void OnCrateDropped(HackableLockedCrate crate)
        {
            var dict = new Dictionary<string, string>
            {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_cratedrop"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnCrateDropped", dict));
                    });
                }
            }
        }

        void OnSupplyDropLanded(SupplyDrop entity)
        {
            var dict = new Dictionary<string, string>
            {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_supplydrop"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnSupplyDrop", dict));
                    });
                }
            }
        }
        #endregion

        #region Death Logging
        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null) return;
            if (info?.InitiatorPlayer == null) return;
            if ((player.IsNpc) || (info.InitiatorPlayer.IsNpc)) return;

            if (_settings.OutputFormat.OutputTypeDeaths == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER DEATH")
                                              .AddColor("#000000")
                                              .AddThumbnail("https://i.imgur.com/UZZTf08.png")
                                              .AddField("Victim", player.displayName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Killer", info.InitiatorPlayer.displayName, true);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_deaths"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDeaths == "Simple")
            {
                var dict = new Dictionary<string, string>
                {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                    { "victim", player.displayName },
                    { "killer", info.InitiatorPlayer.displayName }
                };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_deaths"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnPlayerDeath", dict));
                        });

                    }
                }
            }
        }
        #endregion

        #region Group Logging
        void OnGroupCreated(string name)
        {
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "groupname", name }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_groups"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnGroupCreated", dict));
                    });
                }
            }
        }

        void OnGroupDeleted(string name)
        {
            var dict = new Dictionary<string, string>
            {
                { "groupname", name }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_groups"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnGroupDeleted", dict));
                    });
                }
            }
        }



        void OnUserGroupAdded(string id, string groupName)
        {
            if (_settings.Excluded.LogExcludeGroups.Contains(groupName)) { return; }
            if (groupName == "default") return;
            var player = covalence.Players.FindPlayerById(id);
            if (player == null) return;
            var dict = new Dictionary<string, string>
            {
                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                { "playername", player.Name },
                { "playersteamid", id },
                { "groupname", groupName }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_groups"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnUserGroupAdded", dict));
                    });
                }
            }
        }

        void OnUserGroupRemoved(string id, string groupName)
        {
            if (_settings.Excluded.LogExcludeGroups.Contains(groupName)) return;
            if (groupName == "default") return;
            var player = covalence.Players.FindPlayerById(id);
            if (player == null) return;
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name },
                            { "playersteamid", id },
                            { "groupname", groupName }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_groups"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnUserGroupRemoved", dict));
                    });
                }
            }
        }
        #endregion

        #region Join & Quit Logging
        private void OnPlayerConnected(BasePlayer player)
        {
            if (Client == null) return;
            if (player == null) return;
            if (!player.IsValid()) return;

            HandleAdminJoin(player);
            HandlePlayerJoin(player);
        }

        private void HandleAdminJoin(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeJoinAdminChan == "Simple")
            {
                var text = GetPlayerCache(player, player.net.connection.ipaddress, CacheType.OnPlayerConnected);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_joinlog"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            // Admin
                            chan.CreateMessage(Client, Translate("RUST_OnPlayerJoinAdminLog", text));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJoinAdminChan == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("PLAYER INFO")
                                                  .AddColor("#00FF00")
                                                  .AddThumbnail("https://i.imgur.com/AfbPIrb.png")
                                                  .AddField("Name", player.displayName, true)
                                                  .AddField("IP", player.net.connection.ipaddress.Split(':')[0], true)
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddField("Steam ID", GetFormattedSteamID(player.UserIDString), true);



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_joinlog"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }

        private void HandlePlayerJoin(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "rustcord.hidejoinquit")) return;

            if (_settings.OutputFormat.OutputTypeJoinQuit == "Simple")
            {
                var text = GetPlayerCache(player, null, CacheType.OnPlayerJoin);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_join"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan => { chan.CreateMessage(Client, Translate("RUST_OnPlayerJoin", text)); });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJoinQuit == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("PLAYER JOIN")
                                                  .AddColor("#00FF00")
                                                  .AddThumbnail("https://i.imgur.com/hQK7Jjv.png")
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddDescription($"{player.displayName} has joined the server.");



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_join"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (Client == null) return;
            if (player == null || string.IsNullOrEmpty(reason)) return;
            if (permission.UserHasPermission(player.UserIDString, "rustcord.hidejoinquit"))
                return;
            if (_settings.OutputFormat.OutputTypeJoinQuit == "Simple")
            {
                var text = GetPlayerCache(player, reason, CacheType.OnPlayerDisconnected);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_quit"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnPlayerQuit", text));
                        });
                    }
                }

                cache[CacheType.OnPlayerChat].Remove(player);
                cache[CacheType.OnPlayerConnected].Remove(player);
                cache[CacheType.OnPlayerDisconnected].Remove(player);
                cache[CacheType.OnPlayerJoin].Remove(player);
            }
            if (_settings.OutputFormat.OutputTypeJoinQuit == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("PLAYER QUIT")
                                                  .AddColor("#00FF00")
                                                  .AddThumbnail("https://i.imgur.com/py6bHm0.png")
                                                  .AddDescription($"{player.displayName} has left the server.")
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                                  .AddNowTimestamp()
                                                  .AddField("Reason", reason, true);



                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_quit"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Permission Logging
        void OnUserPermissionGranted(string id, string permName)
        {
            if (_settings.Excluded.LogExcludePerms.Contains(permName)) return;
            var player = covalence.Players.FindPlayerById(id);
            if (player == null) return;
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name },
                            { "playersteamid", id },
                            { "permission", permName }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_perms"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnUserPermissionGranted", dict));
                    });
                }
            }
        }

        void OnGroupPermissionGranted(string name, string perm)
        {
            if (_settings.Excluded.LogExcludePerms.Contains(perm)) return;
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "groupname", name },
                            { "permission", perm }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_perms"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnGroupPermissionGranted", dict));
                    });
                }
            }
        }

        void OnUserPermissionRevoked(string id, string permName)
        {
            if (_settings.Excluded.LogExcludePerms.Contains(permName)) return;
            var player = covalence.Players.FindPlayerById(id);
            if (player == null) return;
            var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name },
                            { "playersteamid", id },
                            { "permission", permName }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_perms"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnUserPermissionRevoked", dict));
                    });
                }
            }
        }

        void OnGroupPermissionRevoked(string name, string perm)
        {
            if (_settings.Excluded.LogExcludePerms.Contains(perm)) return;
            var dict = new Dictionary<string, string>
            {
                        { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                        { "groupname", name },
                        { "permission", perm }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_perms"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnGroupPermissionRevoked", dict));
                    });
                }
            }
        }
        #endregion

        #region Kick & Ban Logging
        void OnUserKicked(IPlayer player, string reason)
        {
            if (_settings.OutputFormat.OutputTypeKicks == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name },
                            { "reason", reason }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_kicks"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnPlayerKicked", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeKicks == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER KICKED")
                                              .AddThumbnail("https://i.imgur.com/ekF9ClZ.png")
                                              .AddField("Name", player.Name, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Reason", reason, true);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_kicks"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }

        void OnUserBanned(string name, string bannedId, string address, string reason)
        {
            if (_settings.OutputFormat.OutputTypeBans == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                        { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                        { "playername", name },
                        { "playersteamid", bannedId },
                        { "playerip", address },
                        { "reason", reason }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_bans"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnPlayerBanned", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBans == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER BANNED")
                                              .AddThumbnail("https://i.imgur.com/ekF9ClZ.png")
                                              .AddField("Name", name, true)
                                              .AddField("IP", address, true)
                                              .AddField("Steam ID", GetFormattedSteamID(bannedId), true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Ban Reason", reason, false);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_bans"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }

        }
        
        private void OnUserUnbanned(string name, string id, string ip)
        {
            if (_settings.OutputFormat.OutputTypeBans == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", name },
                            { "playersteamid", id },
                            { "playerip", ip }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_bans"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnPlayerUnBanned", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBans == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER UNBANNED")
                                              .AddThumbnail("https://i.imgur.com/ekF9ClZ.png")
                                              .AddField("Name", name, true)
                                              .AddField("IP", ip, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Steam ID", GetFormattedSteamID(id), true);
                
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_bans"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Player Name Change Logging
        void OnUserNameUpdated(string id, string oldName, string newName) //TESTING FUNCTION
        {

            if ((oldName == newName) || (oldName == "Unnamed")) return;
            if (_settings.OutputFormat.OutputTypeNameChange == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER NAME CHANGE")
                                              .AddThumbnail("https://i.imgur.com/Fq4LvFz.png")
                                              .AddField("Old Name", oldName, true)
                                              .AddField("New Name", newName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Steam ID", GetFormattedSteamID(id), false);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_namechange"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeNameChange == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "oldname", oldName },
                            { "newname", newName },
                            { "playersteamid", id }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_namechange"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnPlayerNameChange", dict));
                        });
                    }
                }
            }

        }
        #endregion

        #region Server Init/Shutdown Logging
        private void OnServerInitialized(bool isStartup)
        {
            var reloadtime = _settings.General.AutoReloadTime;

            permission.RegisterPermission("rustcord.hidejoinquit", this);
            permission.RegisterPermission("rustcord.hidechat", this);

            if (_settings.General.AutoReloadPlugin && _settings.General.AutoReloadTime > 59)
            {
                timer.Every(reloadtime, () => Reload());
            }

            if (Client != null && isStartup)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_serverinit"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnInitMsg"));
                        });
                    }
                }
            }
        }
        void OnServerShutdown()
        {

            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("msg_serverinit"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnServerShutdown"));
                    });
                }
            }
        }
        #endregion

        #region Server Message Logging (F1 Spawns)
        private object OnServerMessage(string message, string name)
        {
            if (message.Contains("gave") && name == "SERVER")
            {
                var dict = new Dictionary<string, string>
                        {
                                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                                { "playername", name },
                                { "givemessage", message }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_admingive"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnF1ItemSpawn", dict));
                        });
                    }
                }
            }

            return null;
        }
        #endregion

        #region Server Wipe Logging
        private void OnNewSave(string filename)
        {
            var mapseed = ConVar.Server.seed.ToString();
            var servername = ConVar.Server.hostname;
            var serverip = covalence.Server.Address.ToString();
            var serverport = covalence.Server.Port.ToString();
            var serverworldsize = ConVar.Server.worldsize.ToString();

            if (_settings.OutputFormat.OutputTypeServerWipe == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                                { "mapseed", mapseed },
                                { "servername", servername },
                                { "serverip", serverip },
                                { "serverport", serverport },
                                { "serverworldsize", serverworldsize }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_serverwipe"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnServerWipe", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeServerWipe == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                          .AddTitle("SERVER HAS WIPED")
                                          .AddThumbnail("https://i.imgur.com/EODRYQQ.png")
                                          .AddDescription(servername)
                                          .AddField("Map Seed", mapseed, true)
                                          .AddField("World Size", serverworldsize, true)
                                          .AddField("Server IP", serverip, false)
                                          .AddField("Server Port", serverport, true)
                                          .AddField("Quick Join:", $"steam://connect/{serverip}:{serverport}", false)
                                          .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                          .AddNowTimestamp();

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_serverwipe"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Server Command Logging (Note/Gestures)
        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            var player1 = arg.Player();
            var emote = arg.GetString(0);

            if (arg.cmd.Name == "gesture")
            {
                if (_emotes.ContainsKey(emote))
                {
                    var emoji = _emotes[emote];
                    var dict = new Dictionary<string, string>
                        {
                                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                                    {"playername", player1.displayName },
                                    {"gesture", emoji }
                        };
                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("msg_gestures"))
                        {
                            GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(Client, Translate("RUST_OnPlayerGesture", dict));
                            });
                        }
                    }
                }
            }
            if (arg.cmd.FullName == "note.update")
            {
                BasePlayer player = arg.Connection.player as BasePlayer;
                if (player == null)
                    return;
                var notemsg = arg.GetString(1, string.Empty);
                if (string.IsNullOrEmpty(notemsg)) return;

                if (_settings.OutputFormat.OutputTypeNoteLog == "Simple")
                {
                    var dict = new Dictionary<string, string>
                        {
                                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                                { "playername", player.displayName },
                                { "notemessage", notemsg }
                        };
                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("log_itemnote"))
                        {
                            GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(Client, Translate("RUST_OnNoteUpdate", dict));
                            });
                        }
                    }
                }
                if (_settings.OutputFormat.OutputTypeNoteLog == "Embed")
                {
                    DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("NOTE UPDATE")
                                              .AddThumbnail("https://i.imgur.com/AZvqSSf.png")
                                              .AddField("Author", player.displayName, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Message", notemsg, false);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("log_itemnote"))
                        {
                            GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(Client, builder.Build());
                            });
                        }
                    }
                }
            }
        }
        private readonly Dictionary<string, string> _emotes = new Dictionary<string, string>
        {
            ["wave"] = ":wave:",
            ["shrug"] = ":shrug:",
            ["victory"] = ":trophy:",
            ["thumbsup"] = ":thumbsup:",
            ["chicken"] = ":chicken:",
            ["hurry"] = ":runner:",
            ["whoa"] = ":flag_white:"
        };
        #endregion

        #region F7 Report Logging
        void OnPlayerReported(BasePlayer reporter, string targetName, string targetId, string subject, string message, string type)
        {
            if (reporter == null || message == null || targetName == null || targetId == null || subject == null || type == null) return;
            if (_settings.OutputFormat.OutputTypeF7Report == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("PLAYER F7 REPORT")
                                              .AddThumbnail("https://i.imgur.com/qg7v0Tv.png")
                                              .AddField("Reporter", reporter.displayName, false)
                                              .AddField("User Reported", $"{targetName} ([{targetId}](https://steamcommunity.com/profiles/{targetId})", false)
                                              .AddField("Reason", subject, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddField("Message", message, false);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_f7reports"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeF7Report == "Simple")
            {
                var dict = new Dictionary<string, string>
             {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "reporter", reporter.displayName },
                            { "targetname", targetName },
                            { "targetsteamid", targetId },
                            { "reason", subject },
                            { "message", message }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_f7reports"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnPlayerReported", dict));
                        });
                    }
                }
            }

        }
        #endregion

        #region Custom Logging
        private void ConsoleLog(string condition, string stackTrace, LogType type)
        {
            if (string.IsNullOrEmpty(condition))
            {
                return;
            }
            var dict = new Dictionary<string, string>
            {
                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                { "logtext", condition }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                Settings.Channel channel = _settings.Channels[i];
                if (channel.CustomFilter.Any(c => condition.Contains(c)))
                {
                    string log = Translate("RUST_CustomLog", dict);
                    if (channel.FilterBuilder.Length + log.Length > 2000)
                    {
                        string message = channel.FilterBuilder.ToString();
                        GetChannel(Client, channel.Channelid, chan =>
                        {
                            chan.CreateMessage(Client, message);
                        });
                        channel.FilterBuilder.Clear();
                        channel.Timer?.Destroy();
                        channel.Timer = null;
                    }

                    channel.FilterBuilder.AppendLine(log);
                    if (channel.Timer == null)
                    {
                        channel.Timer = timer.In(5f, () =>
                        {
                            channel.Timer = null;
                            string message = channel.FilterBuilder.ToString();
                            GetChannel(Client, channel.Channelid, chan =>
                            {
                                chan.CreateMessage(Client, message);
                            });
                            channel.FilterBuilder.Clear();
                        });
                    }
                }
            }
        }
        #endregion

        #region RCON Logging
        private void OnRconConnection(IPAddress ip)
        {
            var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "ip", ip.ToString() }
                        };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_rcon"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnRCONConnected", dict));
                    });
                }
            }
        }
        #endregion

        #region Spectate Logging
        private void OnPlayerSpectate(BasePlayer player, string spectateFilter)
        {
            var dict = new Dictionary<string, string>
            {
                { "playername", player.displayName },
                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                { "targetname", spectateFilter }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_spectates"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnPlayerSpectate", dict));
                    });

                }
            }
        }
        private void OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            var dict = new Dictionary<string, string>
            {
                { "playername", player.displayName },
                { "targetname", spectateFilter }
            };
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_spectates"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("RUST_OnPlayerSpectateEnd", dict));
                    });
                }
            }
        }
        #endregion

        #region SignShit

        /*private void OnSignUpdated(Signage sign, BasePlayer player, int textureIndex)
        {
            using (Image image = Image.FromStream(new MemoryStream(FileStorage.server.Get(sign.textureIDs[textureIndex], FileStorage.Type.png, sign.net.ID, (uint)0))))
            {
                image.Save($"{sign.net.ID}.png");
            }
            DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Sign Update")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has updated a sign.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddImage($"{sign.net.ID}.png")
                                              .AddThumbnail("https://i.imgur.com/qkI2B4l.png");

            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("log_signs"))
                {
                    GetChannel(_client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(_client, builder.Build());
                    });
                }
            }
        }*/
        #endregion

        #region Team Logging
        void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team)
        {
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;

                List<string> players = Pool.GetList<string>();
                foreach (ulong member in team.members)
                {
                    IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                    if (memberPlayer != null)
                    {
                        players.Add(GetPlayerFormattedField(memberPlayer));
                    }
                    else
                    {
                        players.Add(member.ToString());
                    }
                }

                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("NEW TEAM CREATED")
                                              .AddThumbnail("https://i.imgur.com/ChdmYGD.png")
                                              .AddColor("#800080")
                                              .AddField("Team ID", team.teamID.ToString(), true)
                                              .AddField("Leader", leaderName, true)
                                              .AddField("Members", string.Join("\n", players), false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp();

                Pool.FreeList(ref players);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                { "playername", player.displayName },
                { "teamid", team.teamID.ToString() }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnTeamCreated", dict));
                        });
                    }
                }
            }

        }
        void OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                NextTick(() =>
                {
                    string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;

                    List<string> players = Pool.GetList<string>();
                    foreach (ulong member in team.members)
                    {
                        IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                        if (memberPlayer != null)
                        {
                            players.Add(GetPlayerFormattedField(memberPlayer));
                        }
                        else
                        {
                            players.Add(member.ToString());
                        }
                    }

                    DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                        .AddTitle("TEAM JOIN")
                        .AddColor("#00FF00")
                        .AddThumbnail("https://i.imgur.com/nV7KfWf.png")
                        .AddDescription($"{player.displayName} has joined {leaderName}'s team.")
                        .AddField("Team ID", team.teamID.ToString(), true)
                        .AddField("Team Leader", leaderName, true)
                        .AddField("Team Members", string.Join("\n", players), false)
                        .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                        .AddNowTimestamp();

                    Pool.FreeList(ref players);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("log_teams"))
                        {
                            GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(Client, builder.Build());
                            });
                        }
                    }
                });
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                var dict = new Dictionary<string, string>
                {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                    { "playername", player.displayName },
                    { "teamleader", team.GetLeader().displayName },
                    { "teamid", team.teamID.ToString() }
                };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnTeamAcceptInvite", dict));
                        });
                    }
                }
            }
        }

        void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            if (team == null || player == null) return;
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;
                if (player.displayName == team.GetLeader().displayName) return;
                List<string> players = Pool.GetList<string>();
                foreach (ulong member in team.members)
                {
                    IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                    if (memberPlayer != null)
                    {
                        players.Add(GetPlayerFormattedField(memberPlayer));
                    }
                    else
                    {
                        players.Add(member.ToString());
                    }
                }
                    
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                    .AddTitle("TEAM PART")
                    .AddColor("#FFA500")
                    .AddThumbnail("https://i.imgur.com/92y7DWt.png")
                    .AddDescription($"{player.displayName} left {leaderName}'s team.")
                    .AddField("Team ID", team.teamID.ToString(), true)
                    .AddField("Team Leader", leaderName, true)
                    .AddField("Team Members", string.Join("\n", players), false)
                    .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                    .AddNowTimestamp();
                    
                Pool.FreeList(ref players);

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
                
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                if (player == team.GetLeader()) return;
                if ((team == null) || (player == null)) return;
                var dict = new Dictionary<string, string>
                {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                    { "playername", player.displayName },
                    { "teamleader", team.GetLeader().displayName },
                    { "teamid", team.teamID.ToString() }
                };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnTeamLeave", dict));
                        });
                    }
                }
            }
        }
        void OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong target)
        {
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                NextTick(() =>
                {
                    string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;
                    var targetplayer = GetPlayer(target);

                    List<string> players = Pool.GetList<string>();
                    foreach (ulong member in team.members)
                    {
                        IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                        if (memberPlayer != null)
                        {
                            players.Add(GetPlayerFormattedField(memberPlayer));
                        }
                        else
                        {
                            players.Add(member.ToString());
                        }
                    }

                    DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                                  .AddTitle("TEAM KICK")
                                                  .AddColor("#FF0000")
                                                  .AddThumbnail("https://i.imgur.com/92y7DWt.png")
                                                  .AddDescription($"{targetplayer.Name} was kicked from {leaderName}'s team.")
                                                  .AddField("Team ID", team.teamID.ToString(), true)
                                                  .AddField("Team Leader", leaderName, true)
                                                  .AddField("Team Members", string.Join("\n", players), false)
                                                  .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp();

                    Pool.FreeList(ref players);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("log_teams"))
                        {
                            GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(Client, builder.Build());
                            });
                        }
                    }
                });
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                var targetplayer = FindPlayerByID(target.ToString());
                var dict = new Dictionary<string, string>
                        {
                            { "playername", targetplayer.displayName },
                            { "teamleader", team.GetLeader().displayName },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "teamid", team.teamID.ToString() }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnTeamKicked", dict));
                        });
                    }
                }
            }
        }
        void OnTeamDisbanded(RelationshipManager.PlayerTeam team)
        {
            if (_settings.OutputFormat.OutputTypeTeams == "Embed")
            {
                string leaderName = covalence.Players.FindPlayerById(team.teamLeader.ToString())?.Name;

                List<string> players = Pool.GetList<string>();
                foreach (ulong member in team.members)
                {
                    IPlayer memberPlayer = covalence.Players.FindPlayerById(member.ToString());
                    if (memberPlayer != null)
                    {
                        players.Add(GetPlayerFormattedField(memberPlayer));
                    }
                    else
                    {
                        players.Add(member.ToString());
                    }
                }

                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("TEAM DISBANDED")
                                              .AddColor("#FF0000")
                                              .AddThumbnail("https://i.imgur.com/B9mPg0l.png")
                                              .AddField("Team ID", team.teamID.ToString(), true)
                                              .AddField("Leader", leaderName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp();

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeTeams == "Simple")
            {
                var dict = new Dictionary<string, string>
            {
                            { "teamleader", team.GetLeader().displayName },
                            { "teamid", team.teamID.ToString() }
            };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("log_teams"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnTeamDisbanded", dict));
                        });
                    }
                }
            }
        }
        #endregion

        #region Vehicle Spawn Logging

        private void OnEntitySpawned(BaseEntity Entity)
        {
            var dict = new Dictionary<string, string>
            {
                    { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
            };
            if (Entity == null) return;
            if (Entity is BaseHelicopter)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_helispawn"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnHeliSpawn"));
                        });
                    }
                }
            }
            if (Entity is CargoPlane)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_planespawn"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnPlaneSpawn"));
                        });
                    }
                }
            }
            if (Entity is CargoShip)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_shipspawn"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnShipSpawn"));
                        });
                    }
                }

            }
            if (Entity is CH47Helicopter)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_chinookspawn"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnChinookSpawn"));
                        });
                    }
                }
            }
            if (Entity is BradleyAPC)
            {
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("msg_bradleyspawn"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("RUST_OnBradleySpawn"));
                        });
                    }
                }
            }

        }
        #endregion

        #endregion

        #region External Plugin Logging

        #region Admin Hammer

        void OnAdminHammerEnabled(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeAdminHammer == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminhammer"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_AdminHammer_Enabled", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAdminHammer == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Admin Hammer Plugin")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has enabled Admin Hammer.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5ebb965d00f21.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminhammer"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }

        }
        void OnAdminHammerDisabled(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeAdminHammer == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminhammer"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_AdminHammer_Disabled", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAdminHammer == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Admin Hammer Plugin")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has disabled Admin Hammer.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5ebb965d00f21.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminhammer"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Admin Radar
        void OnRadarActivated(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeAdminRadar == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminradar"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_AdminRadar_Enabled", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAdminRadar == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Admin Radar Plugin")
                                              .AddUrl("https://umod.org/plugins/admin-radar")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has enabled Admin Radar.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b7e1bc17d769.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminradar"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnRadarDeactivated(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeAdminRadar == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminradar"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_AdminRadar_Disabled", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAdminRadar == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Admin Radar Plugin")
                                              .AddUrl("https://umod.org/plugins/admin-radar")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has disabled Admin Radar.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b7e1bc17d769.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_adminradar"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Better Chat Mute

        private void OnBetterChatMuted(IPlayer target, IPlayer player, string reason)
        {
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "targetname", target.Name },
                            { "reason", reason },
                            { "muter", player.Name }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_BetterChatMute_Mute", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Better Chat Mute Plugin")
                                              .AddUrl("https://umod.org/plugins/better-chat-mute")
                                              .AddColor("#800080")
                                              .AddDescription($"Permanent Mute Issued By: {player.Name}.")
                                              .AddField("Muted Player", target.Name, false)
                                              .AddField("Reason", reason, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5f242f4c92225.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }

        private void OnBetterChatTimeMuted(IPlayer target, IPlayer player, TimeSpan time, string reason)
        {
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "targetname", target.Name },
                            { "reason", reason },
                            { "muter", player.Name },
                            { "duration", FormatTime((TimeSpan) time) }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_BetterChatMute_TimedMute", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Better Chat Mute Plugin")
                                              .AddUrl("https://umod.org/plugins/better-chat-mute")
                                              .AddColor("#800080")
                                              .AddDescription($"Temporary Mute Issued By: {player.Name}.")
                                              .AddField("Muted Player", target.Name, true)
                                              .AddField("Duration", FormatTime((TimeSpan)time), true)
                                              .AddField("Reason", reason, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5f242f4c92225.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }

        private void OnBetterChatUnmuted(IPlayer target, IPlayer player)
        {
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "targetname", target.Name },
                            { "unmuter", player.Name }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_BetterChatMute_UnMute", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Better Chat Mute Plugin")
                                              .AddUrl("https://umod.org/plugins/better-chat-mute")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.Name} removed {target.Name}'s mute.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5f242f4c92225.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }


        private void OnBetterChatMuteExpired(IPlayer target)
        {
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "targetname", target.Name }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_BetterChatMute_MuteExpire", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeBetterChatMute == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Better Chat Mute Plugin")
                                              .AddUrl("https://umod.org/plugins/better-chat-mute")
                                              .AddColor("#800080")
                                              .AddDescription($"{target.Name}'s mute has expired.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5f242f4c92225.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_betterchatmute"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Clans

        void OnClanCreate(string tag, string ownerID)
        {
            if ((_settings.PluginLog.LogPluginClans == true) && (_settings.OutputFormat.OutputTypeClans == "Simple"))
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "clantag", tag }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_clans"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_Clans_CreateClan", dict));
                        });
                    }
                }

            }
            if ((_settings.PluginLog.LogPluginClans == true) && (_settings.OutputFormat.OutputTypeClans == "Embed"))
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                          .AddTitle("Clans Plugin")
                                          .AddUrl("https://umod.org/plugins/clans")
                                          .AddColor("#800080")
                                          .AddDescription($"Clan {tag} has been created.")
                                          .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                          .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b63bf642ea2c.jpg");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_clans"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnClanDisbanded(string tag, List<string> memberUserIDs)
        {
            if ((_settings.PluginLog.LogPluginClans == true) && (_settings.OutputFormat.OutputTypeClans == "Simple"))
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "clantag", tag }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_clans"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_Clans_DisbandClan", dict));
                        });
                    }
                }
            }
            if ((_settings.PluginLog.LogPluginClans == true) && (_settings.OutputFormat.OutputTypeClans == "Embed"))
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                          .AddTitle("Clans Plugin")
                                          .AddUrl("https://umod.org/plugins/clans")
                                          .AddColor("#800080")
                                          .AddDescription($"Clan {tag} has been Disbanded.")
                                          .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                          .AddNowTimestamp()
                                          .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b63bf642ea2c.jpg");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_clans"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnClanChat(IPlayer player, string message)
        {
            var dict = new Dictionary<string, string>
                        {
                            { "playername", player.Name },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "message", message }
                        };
            if (player.Name == null || message == null) return;
            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("plugin_clanchat"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, Translate("PLUGIN_Clans_Chat", dict));
                    });
                }
            }
        }
        #endregion

        #region Dangerous Treasures

        private void OnDangerousEventStarted(Vector3 containerPos)
        {
            if (containerPos == null) return;
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "position", containerPos.ToString() },
                            { "gridposition", FindGridPosition(containerPos).ToString() }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_dangeroustreasures"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_DangerousTreasures_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Dangerous Treasures Plugin")
                                              .AddUrl("https://umod.org/plugins/dangerous-treasures")
                                              .AddDescription("Dangerous Event Started")
                                              .AddField("Position", $"{ FindGridPosition(containerPos)} {containerPos} ", true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b7d66ce65af7.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_dangeroustreasures"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        private void OnDangerousEventEnded(Vector3 containerPos)
        {
            if (containerPos == null) return;
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "position", containerPos.ToString() },
                            { "gridposition", FindGridPosition(containerPos).ToString() }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_dangeroustreasures"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_DangerousTreasures_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDangerousTreasures == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Dangerous Treasures Plugin")
                                              .AddUrl("https://umod.org/plugins/dangerous-treasures")
                                              .AddDescription("Dangerous Event Ended")
                                              .AddField("Position", $"{FindGridPosition(containerPos)} {containerPos} ", true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b7d66ce65af7.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_dangeroustreasures"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Death Notes
        private void OnDeathNotice(Dictionary<string, object> data, string message)
        {
            if (Client == null) return;
            if (data["VictimEntityType"] == null || data["KillerEntityType"] == null) return;
            int victimType = (int)data["VictimEntityType"];
            int killerType = (int)data["KillerEntityType"];

            var _DeathNotes = plugins.Find("DeathNotes");
            var deathmessage = (string)_DeathNotes.Call("StripRichText", message);

            var dict = new Dictionary<string, string>
                    {
                        { "deathmessage", deathmessage},
                        { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                    };

            if (_DeathNotes != null)
                if ((victimType == 5 && (killerType == 5 || killerType == 6 || killerType == 7 || killerType == 8 || killerType == 9 || killerType == 10 || killerType == 11 || killerType == 12 || killerType == 14 || killerType == 15)))
                {
                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("plugin_deathnotes_pvp"))
                        {
                            GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(Client, Translate("PLUGIN_DeathNotes_Death", dict));
                            });
                        }
                    }

                }
                else if ((victimType == 2 && killerType == 5) || (victimType == 5 && killerType == 2))
                {
                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("plugin_deathnotes_animal"))
                        {
                            GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(Client, Translate("PLUGIN_DeathNotes_Death", dict));
                            });
                        }
                    }

                }
                else if ((victimType == 5 && (killerType == 0 || killerType == 1)) || ((victimType == 0 || victimType == 1) && (killerType == 5)))
                {
                    message = (string)_DeathNotes.Call("StripRichText", message);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("plugin_deathnotes_vehicle"))
                        {
                            GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(Client, Translate("PLUGIN_DeathNotes_Death", dict));
                            });
                        }
                    }
                }
                else if ((victimType == 5 && (killerType == 3 || killerType == 4 || killerType == 16 || killerType == 17 || killerType == 18)) || ((victimType == 3 || victimType == 4 || victimType == 16 || victimType == 17 || victimType == 18) && (killerType == 5)))
                {
                    message = (string)_DeathNotes.Call("StripRichText", message);

                    for (int i = 0; i < _channelCount; i++)
                    {
                        if (_settings.Channels[i].perms.Contains("plugin_deathnotes_npc"))
                        {
                            GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                            {
                                chan.CreateMessage(Client, Translate("PLUGIN_DeathNotes_Death", dict));
                            });
                        }
                    }

                }
        }
        #endregion

        #region Discord Auth
        private void OnDiscordPlayerLinked(IPlayer player, DiscordUser user)
        {
            if (player == null || user == null) return;
            if (_settings.OutputFormat.OutputTypeDiscordAuth == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "gamename", player.Name },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "discordname", user.FullUserName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_discordauth"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_DiscordAuth_Auth", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDiscordAuth == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Discord Auth Plugin")
                                              .AddUrl("https://umod.org/plugins/discord-auth")
                                              .AddColor("#800080")
                                              .AddDescription("Player Account Linked.")
                                              .AddField("Rust Player", player.Name, true)
                                              .AddField("Discord Account", user.FullUserName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddColor("#00FF00")
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5d20e5691c3c5.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_discordauth"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }

        }
        private void OnDiscordPlayerUnlinked(IPlayer player, DiscordUser user)
        {
            if (player == null || user == null) return;
            if (_settings.OutputFormat.OutputTypeDiscordAuth == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "gamename", player.Name },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "discordname", user.FullUserName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_discordauth"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_DiscordAuth_Deauth", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeDiscordAuth == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Discord Auth Plugin")
                                              .AddUrl("https://umod.org/plugins/discord-auth")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.Name} Unlinked From Discord.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddColor("#FF0000")
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5d20e5691c3c5.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_discordauth"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Godmode
        private void OnGodmodeToggled(string playerId, bool enabled)
        {
            var player = covalence.Players.FindPlayerById(playerId);
            if (player.Name == null) return;
            if (_settings.OutputFormat.OutputTypeGodmode == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.Name }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_godmode"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            if (enabled == true)
                            {
                                chan.CreateMessage(Client, Translate("PLUGIN_Godmode_Enabled", dict));
                            }
                            if (enabled == false)
                            {
                                chan.CreateMessage(Client, Translate("PLUGIN_Godmode_Disabled", dict));
                            }
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeGodmode == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Godmode Plugin")
                                              .AddUrl("https://umod.org/plugins/godmode")
                                              .AddColor("#800080")
                                              .AddDescription("Godmode has been toggled")
                                              .AddField("Player", player.Name, true)
                                              .AddField("Enabled", enabled.ToString(), true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b6394e5e597b.jpg");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_godmode"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Kits
        void OnKitRedeemed(BasePlayer player, string kitName)
        {
            if (player == null || kitName == null) return;
            if (_settings.OutputFormat.OutputTypeKits == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "kitname", kitName },
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_kits"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_Kits_Redeemed", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeKits == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Kits Plugin")
                                              .AddUrl("https://umod.org/plugins/kits")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has redeemd a kit.")
                                              .AddField("Kit", kitName, true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b910ab50f5d1.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_kits"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Private Messages
        [HookMethod("OnPMProcessed")]
        void OnPMProcessed(IPlayer sender, IPlayer target, string message)
        {
            if (_settings.OutputFormat.OutputTypePMs == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "sendername", sender.Name },
                            { "targetname", target.Name },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "message", message }
                        };

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_privatemessages"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_PrivateMessages_PM", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypePMs == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Private Messages Plugin")
                                              .AddUrl("https://umod.org/plugins/private-messages")
                                              .AddColor("#800080")
                                              .AddField("From", sender.Name, true)
                                              .AddField("To", target.Name, true)
                                              .AddField("Message", message, false)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5b66ed6b7e606.jpg");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_privatemessages"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Raidable Bases
        void OnRaidableBaseStarted(Vector3 pos, int difficulty)
        {
            string rbdiff = string.Empty;
            if (difficulty == 0) rbdiff = "Easy";
            if (difficulty == 1) rbdiff = "Medium";
            if (difficulty == 2) rbdiff = "Hard";
            if (difficulty == 3) rbdiff = "Expert";
            if (difficulty == 4) rbdiff = "Nightmare";
            if (difficulty == 512) rbdiff = "Normal";

            if (_settings.OutputFormat.OutputTypeRaidableBases == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "position", pos.ToString() },
                            { "gridposition", FindGridPosition(pos).ToString() },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "difficulty", rbdiff }
                        };

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_raidablebases"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_RaidableBases_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeRaidableBases == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Raidable Bases Plugin")
                                              .AddUrl("https://umod.org/plugins/raidable-bases")
                                              .AddColor("#800080")
                                              .AddDescription("A Raidable Base Has Spawned.")
                                              .AddField("Difficulty", rbdiff, true)
                                              .AddField("Location", $"{FindGridPosition(pos)} {pos}", true)
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5e986213be8c8.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_raidablebases"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnRaidableBaseEnded(Vector3 pos, int difficulty)
        {
            string rbdiff = string.Empty;
            if (difficulty == 0) rbdiff = "Easy";
            if (difficulty == 1) rbdiff = "Medium";
            if (difficulty == 2) rbdiff = "Hard";

            if (_settings.OutputFormat.OutputTypeRaidableBases == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "position", pos.ToString() },
                            { "gridposition", FindGridPosition(pos).ToString() },
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "difficulty", rbdiff }
                        };

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_raidablebases"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_RaidableBases_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeRaidableBases == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Raidable Bases Plugin")
                                              .AddUrl("https://umod.org/plugins/raidable-bases")
                                              .AddColor("#800080")
                                              .AddDescription($"Raidable Base at {FindGridPosition(pos)} Has Ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5e986213be8c8.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_raidablebases"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Sign Artist
        private void OnImagePost(BasePlayer player, string image)
        {
            var dict = new Dictionary<string, string>
                        {
                            { "playername", player.displayName },
                            { "position", $"{player.transform.position.x} {player.transform.position.y} {player.transform.position.z}" }
                        };

            for (int i = 0; i < _channelCount; i++)
            {
                if (_settings.Channels[i].perms.Contains("plugin_signartist"))
                {
                    GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                    {
                        chan.CreateMessage(Client, SignArtistEmbed(Translate("PLUGIN_SignArtist", dict), image));
                    });
                }
            }
        }

        private DiscordEmbed SignArtistEmbed(string text, string image)
        {
            DiscordEmbed embed = new DiscordEmbedBuilder()
                                 .AddTitle("SignArtist Plugin")
                                 .AddUrl("https://umod.org/plugins/sign-artist")
                                 .AddThumbnail("https://i.imgur.com/NBu6OjS.png")
                                 .AddDescription(text)
                                 .AddColor(52326)
                                 .AddImage(image)
                                 .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                 .AddNowTimestamp()
                                 .Build();

            return embed;
        }
        #endregion

        #region Vanish
        void OnVanishDisappear(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeVanish == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_vanish"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_Vanish_Disappear", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeVanish == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Vanish Plugin")
                                              .AddUrl("https://umod.org/plugins/vanish")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has vanished.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5e2c4da074770.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_vanish"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnVanishReappear(BasePlayer player)
        {
            if (_settings.OutputFormat.OutputTypeVanish == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")},
                            { "playername", player.displayName }
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_vanish"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_Vanish_Reappear", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeVanish == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Vanish Plugin")
                                              .AddUrl("https://umod.org/plugins/vanish")
                                              .AddColor("#800080")
                                              .AddDescription($"{player.displayName} has reappeared.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://assets.umod.org/images/icons/plugin/5e2c4da074770.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_vanish"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion


        #endregion

        #region Premium Plugins

        #region Air Event
        void OnAirEventStart(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeAirEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_airevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_AirEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAirEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Air Event Plugin")
                                              .AddUrl("https://lone.design/product/airevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Air Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1010785120237649961/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_airevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnAirEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeAirEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_airevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_AirEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeAirEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Air Event Plugin")
                                              .AddUrl("https://lone.design/product/airevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Air Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1010785120237649961/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_airevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Armored Train Event
        void OnArmoredTrainEventStart()
        {
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_armoredtrainevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_ArmoredTrainEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Armored Train Event Plugin")
                                              .AddUrl("https://lone.design/product/armored-train-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Armored Train Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012196381617815584/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_armoredtrainevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnArmoredTrainEventStop()
        {
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_armoredtrainevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_ArmoredTrainEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeArmoredTrainEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Armored Train Event Plugin")
                                              .AddUrl("https://lone.design/product/armored-train-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Armored Train Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012196381617815584/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_armoredtrainevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Cargo Train Event
        void OnTrainEventStarted(TrainEngine train)
        {
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_cargotrainevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_CargoTrainEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Cargo Train Event Plugin")
                                              .AddUrl("https://lone.design/product/cargo-train-event-rust/")
                                              .AddColor("#800080")
                                              .AddDescription("Cargo Train Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012200951647588422/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_cargotrainevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnTrainEventEnded(TrainEngine train)
        {
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_cargotrainevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_CargoTrainEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeCargoTrainEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Cargo Train Event Plugin")
                                              .AddUrl("https://lone.design/product/cargo-train-event-rust/")
                                              .AddColor("#800080")
                                              .AddDescription("Cargo Train Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012200951647588422/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_cargotrainevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Convoy Event
        void OnConvoyStart()
        {
            if (_settings.OutputFormat.OutputTypeConvoyEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_convoyevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_ConvoyEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeConvoyEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Convoy Event Plugin")
                                              .AddUrl("https://lone.design/product/convoy-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Convoy Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012202423940567150/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_convoyevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnConvoyStop()
        {
            if (_settings.OutputFormat.OutputTypeConvoyEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_convoyevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_ConvoyEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeConvoyEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Convoy Event Plugin")
                                              .AddUrl("https://lone.design/product/convoy-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Convoy Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1012202423940567150/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_convoyevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Harbor Event
        void OnHarborEventStart()
        {
            if (_settings.OutputFormat.OutputTypeHarborEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_harborevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_HarborEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeHarborEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Harbor Event Plugin")
                                              .AddUrl("https://lone.design/product/harborevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Harbor Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1010813485791326288/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_harborevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnHarborEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeHarborEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_harborevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_HarborEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeHarborEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Harbor Event Plugin")
                                              .AddUrl("https://lone.design/product/harborevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Harbor Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1010813485791326288/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_harborevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Junkyard Event
        void OnJunkyardEventStart()
        {
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_junkyardevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_JunkyardEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Junkyard Event Plugin")
                                              .AddUrl("https://lone.design/product/junkyardevent-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Junkyard Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011142703939063868/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_junkyardevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnJunkyardEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_junkyardevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_JunkyardEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Junkyard Event Plugin")
                                              .AddUrl("https://lone.design/product/junkyardevent-rust-plugin/")
                                              .AddColor("#800080")
                                              .AddDescription("Junkyard Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011142703939063868/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_junkyardevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Power Plant Event
        void OnPowerPlantEventStart()
        {
            if (_settings.OutputFormat.OutputTypePowerPlantEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_powerplantevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_PowerPlantEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypePowerPlantEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Power Plant Event Plugin")
                                              .AddUrl("https://lone.design/product/power-plant-event/")
                                              .AddColor("#800080")
                                              .AddDescription("Power Plant Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011144872826253372/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_powerplantevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnPowerPlantEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypePowerPlantEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_powerplantevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_PowerPlantEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeJunkyardEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Power Plant Event Plugin")
                                              .AddUrl("https://lone.design/product/power-plant-event/")
                                              .AddColor("#800080")
                                              .AddDescription("Power Plant Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011144872826253372/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_powerplantevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Satellite Dish Event
        void OnSatDishEventStart()
        {
            if (_settings.OutputFormat.OutputTypeSatDishEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_satdishevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_SatDishEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeSatDishEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Satellite Dish Event Plugin")
                                              .AddUrl("https://lone.design/product/satdishevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Satellite Dish Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011145882395213854/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_satdishevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnSatDishEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeSatDishEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_satdishevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_SatDishEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeSatDishEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Satellite Dish Event Plugin")
                                              .AddUrl("https://lone.design/product/satdishevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Satellite Dish Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011145882395213854/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_satdishevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Sputnik Event
        void OnSputnikEventStart()
        {
            if (_settings.OutputFormat.OutputTypeSputnikEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_sputnikevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_SputnikEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeSputnikEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Sputnik Event Plugin")
                                              .AddUrl("https://lone.design/product/sputnik/")
                                              .AddColor("#800080")
                                              .AddDescription("Sputnik Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011495773936037888/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_sputnikevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnSputnikEventStop()
        {
            if (_settings.OutputFormat.OutputTypeSputnikEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_sputnikevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_SputnikEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeSputnikEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Sputnik Event Plugin")
                                              .AddUrl("https://lone.design/product/sputnik/")
                                              .AddColor("#800080")
                                              .AddDescription("Sputnik Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011495773936037888/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_sputnikevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #region Water Event
        void OnWaterEventStart()
        {
            if (_settings.OutputFormat.OutputTypeWaterEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_waterevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_WaterEvent_Started", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeWaterEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Water Event Plugin")
                                              .AddUrl("https://lone.design/product/waterevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Water Event has started.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011166741310754836/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_waterevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        void OnWaterEventEnd(HashSet<BaseEntity> entities)
        {
            if (_settings.OutputFormat.OutputTypeWaterEvent == "Simple")
            {
                var dict = new Dictionary<string, string>
                        {
                            { "time", DateTimeOffset.UtcNow.DateTime.ToLocalTime().ToString("hh:mm tt")}
                        };
                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_waterevent"))
                    {

                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, Translate("PLUGIN_WaterEvent_Ended", dict));
                        });
                    }
                }
            }
            if (_settings.OutputFormat.OutputTypeWaterEvent == "Embed")
            {
                DiscordEmbedBuilder builder = new DiscordEmbedBuilder()
                                              .AddTitle("Water Event Plugin")
                                              .AddUrl("https://lone.design/product/waterevent/")
                                              .AddColor("#800080")
                                              .AddDescription("Water Event has ended.")
                                              .AddFooter($"Rustcord {this.Version}", "https://media.discordapp.net/attachments/571482804475527168/1010803785632841768/unknown.png")
                                              .AddNowTimestamp()
                                              .AddThumbnail("https://media.discordapp.net/attachments/571482804475527168/1011166741310754836/unknown.png");

                for (int i = 0; i < _channelCount; i++)
                {
                    if (_settings.Channels[i].perms.Contains("plugin_waterevent"))
                    {
                        GetChannel(Client, _settings.Channels[i].Channelid, chan =>
                        {
                            chan.CreateMessage(Client, builder.Build());
                        });
                    }
                }
            }
        }
        #endregion

        #endregion
    }
}

// --- End of file: Rustcord.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/reset-hostile-on-death ---
// --- Original File Path: R/ResetHostileOnDeath/ResetHostileOnDeath.cs ---

namespace Oxide.Plugins
{
    [Info("Reset Hostile On Death", "WhiteThunder", "1.0.0")]
    [Description("Resets player hostile status on death.")]
    public class ResetHostileOnDeath : CovalencePlugin
    {
        private void OnPlayerDeath(BasePlayer player)
        {
            if (player.IsNpc || !player.userID.IsSteamId() || !player.IsHostile())
                return;

            player.State.unHostileTimestamp = Network.TimeEx.currentTimestamp;
            player.MarkHostileFor(0);
        }
    }
}

// --- End of file: ResetHostileOnDeath.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rustadmin-online ---
// --- Original File Path: R/RustadminOnline/RustadminOnline.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Network;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Rustadmin Online", "misticos", "1.2.0")]
    [Description("Extends Rustadmin Online features")]
    class RustadminOnline : CovalencePlugin
    {
       #region Variables

       private const string CommandPlayerList = "global.playerlist";
       private Action<ConsoleSystem.Arg> _commandPlayerListGet = null;

       #endregion

       #region Hooks

       private void OnServerInitialized()
       {
          var command = FindCommand(CommandPlayerList);
          _commandPlayerListGet = command.Call;
          command.Call = OnPlayerList;
          BuildCommands();
       }

        private void Unload()
        {
           var command = FindCommand(CommandPlayerList);
           command.Call = _commandPlayerListGet;
           BuildCommands();
        }

        #endregion

        #region Commands

        [Command("rustadmin.run")]
        private void CommandRun(IPlayer player, string command, string[] args)
        {
           if (!player.IsServer)
              return;

           if (args.Length < 2)
              return;

           var target = players.FindPlayerById(args[0])?.Object as BasePlayer;
           if (target == null || !target.IsConnected)
              return;

           target.SendConsoleCommand(args[1], args.Skip(2));
        }

        [Command("rustadmin.rendermap")]
        private void CommandRenderMap(IPlayer player, string command, string[] args)
        {
           if (!player.IsServer)
              return;

           const float defaultRes = 3000;

           float scale;
           if (args.Length == 0 || !float.TryParse(args[0], out scale))
              scale = (defaultRes - 1000f) / World.Size;

           scale = Mathf.Clamp(scale, 0.1f, 4f);

           int height, width;
           Color background;

           var imageData =
              Convert.ToBase64String(MapImageRenderer.Render(out width, out height, out background, scale, false));

           player.Reply(JsonConvert.SerializeObject(new
           {
              Height = height,
              Width = width,
              Base64 = imageData
           }));
        }

        private void OnPlayerList(ConsoleSystem.Arg arg)
        {
           arg.ReplyWithObject(BasePlayer.activePlayerList.Select(x => new
           {
              SteamID = x.UserIDString, OwnerSteamID = x.OwnerID.ToString(), DisplayName = x.displayName,
              Ping = Net.sv.GetAveragePing(x.net.connection), Address = x.net.connection.ipaddress,
              ConnectedSeconds = x.net.connection.GetSecondsConnected(), VoiationLevel = x.violationLevel,
              Health = x.Health(), Position = x.transform.position, TeamId = shrinkTeamId(x.currentTeam), NetworkId = x.net.ID.Value
           }));
        }

        #endregion

        #region Helpers

        // For Clan plugin using huge teamIDs
        private int shrinkTeamId(ulong id) {

           if (id >= int.MaxValue) {
              string tmp = id.ToString();
              tmp = tmp.Substring(tmp.Length - 5);
              return int.Parse(tmp);
           }

            return (int)id;
        }

        private ConsoleSystem.Command FindCommand(string fullName)
        {
            for (var i = 0; i < ConsoleGen.All.Length; i++)
            {
                if (ConsoleGen.All[i].FullName == fullName)
                    return ConsoleGen.All[i];
            }

            return null;
        }

        private void BuildCommands()
        {
           ConsoleSystem.Index.Server.Dict.Clear();
           ConsoleSystem.Index.Client.Dict.Clear();

           foreach (var command in ConsoleSystem.Index.All)
           {
              if (command.Server)
              {
                 if (ConsoleSystem.Index.Server.Dict.ContainsKey(command.FullName))
                 {
                    Debug.LogWarning("Server Vars have multiple entries for " + command.FullName);
                 }
                 else
                 {
                    ConsoleSystem.Index.Server.Dict.Add(command.FullName, command);
                 }

                 if (command.Parent != "global" &&
                     !ConsoleSystem.Index.Server.GlobalDict.ContainsKey(command.Name))
                 {
                    ConsoleSystem.Index.Server.GlobalDict.Add(command.Name, command);
                 }

                 if (command.Replicated)
                 {
                    if (!command.Variable || !command.ServerAdmin)
                    {
                       Debug.LogWarning("Replicated server var " + command.FullName + " has a bad config");
                    }
                 }
              }

              if (command.Client)
              {
                 if (ConsoleSystem.Index.Client.Dict.ContainsKey(command.FullName))
                 {
                    Debug.LogWarning("Client Vars have multiple entries for " + command.FullName);
                 }
                 else
                 {
                    ConsoleSystem.Index.Client.Dict.Add(command.FullName, command);
                 }

                 if (command.Parent != "global" &&
                     !ConsoleSystem.Index.Client.GlobalDict.ContainsKey(command.Name))
                 {
                    ConsoleSystem.Index.Client.GlobalDict.Add(command.Name, command);
                 }
              }
           }
        }

        #endregion
    }
}


// --- End of file: RustadminOnline.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/remove-vanilla ---
// --- Original File Path: R/RemoveVanilla/RemoveVanilla.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Remove Vanilla", "Orange/Ryz0r", "1.3.0")]
    [Description("Remove pretty much any entity within a specified amount of time, without commands.")]
    public class RemoveVanilla : RustPlugin
    {
        #region Vars

        private const string PermUse = "removevanilla.use";

        private Dictionary<uint, double> entities = new Dictionary<uint, double>();

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(PermUse, this);

            if (config.pickupTime != 0)
            {
                timer.Every(300f, () =>
                {
                    foreach (var entity in entities.ToList())
                    {
                        if (Passed(entity.Value) > config.pickupTime)
                        {
                            entities.Remove(entity.Key);
                        }
                    }
                });
            }
            else
            {
                Unsubscribe("OnEntitySpawned");
            }
        }

        private void OnEntitySpawned(BaseCombatEntity entity)
        {
            if (!entity.OwnerID.IsSteamId()) { return; }
            entities.TryAdd(entity.net.ID, 0);
            entities[entity.net.ID] = Now();
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            CheckInput(player, input);
        }

        #endregion

        #region Core

        private void CheckInput(BasePlayer player, InputState input)
        {
            if (!input.WasJustPressed(BUTTON.FIRE_PRIMARY))
            {
                return;
            }

            if (!ActiveItemIsHammer(player))
            {
                return;
            }

            if (!permission.UserHasPermission(player.UserIDString, PermUse))
            {
                return;
            }

            var entity = GetLookEntity(player);
            if (entity == null)
            {
                return;
            }

            if (!CanPickup(entity, player))
            {
                return;
            }

            if (GiveRefund(entity, player))
            {
                entity.Die();
            }
        }

        private bool GiveRefund(BaseCombatEntity entity, BasePlayer player)
        {
            var name = entity.ShortPrefabName;
            name = Regex.Replace(name, "\\.deployed|_deployed", "");
            name = FixNames(name);

            var item = ItemManager.CreateByName(name);
            if (item != null)
            {
                player.inventory.GiveItem(item);
                return true;
            }

            if (entity != null)
            {
                var cost = entity.BuildCost();
                if (cost != null)
                {
                    foreach (var value in cost)
                    {
                        var x = ItemManager.Create(value.itemDef, Convert.ToInt32(value.amount));
                        if (x == null) { continue; }
                        player.GiveItem(x);
                    }

                    return true;
                }

                return false;
            }

            return false;
        }

        private bool CanPickup(BaseEntity entity, BasePlayer player)
        {
            if (entity.OwnerID == 0 || !player.CanBuild())
            {
                return false;
            }

            var name = entity.ShortPrefabName;

            if (config.blocked.Contains(name))
            {
                return false;
            }

            if (entity.HasAnySlot())
            {
                return false;
            }

            if (!Regex.IsMatch(entity.ShortPrefabName, @"floor|wall|foundation|stair|roof|cupboard|door\.|barricade|gates|sign|workbench|watchtower|vendingmachine|light|dropbox|fridge|bed|bbq|planter|refinery|locker\.|mailbox|shelves|graveyardfence|windmill|turret|trap|box\.wooden|coffinstorage|cursedcauldron")) return false;
            var container = entity.GetComponent<StorageContainer>();
            if (container != null && container?.inventory.itemList.Count > 0)
            {
                return false;
            }

            var combat = entity.GetComponent<BaseCombatEntity>();
            if (combat != null && combat.SecondsSinceAttacked < 30f)
            {
                return false;
            }

            if (entities.ContainsKey(entity.net.ID))
            {
                return Passed(entities[entity.net.ID]) < config.pickupTime;
            }

            return config.pickupTime == 0;
        }

        private BaseCombatEntity GetLookEntity(BasePlayer player)
        {
            RaycastHit RaycastHit;
            if (!Physics.Raycast(player.eyes.HeadRay(), out RaycastHit, 5f)) { return null; }
            var entity = RaycastHit.GetEntity() as BaseCombatEntity;
            return entity;
        }

        private bool ActiveItemIsHammer(BasePlayer player)
        {
            var item = player.GetActiveItem()?.info.shortname ?? "null";
            return item == "hammer";
        }

        #endregion

        #region Configuration

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "1. Timer while pickup will be available (0 to disable)")]
            public int pickupTime;

            [JsonProperty(PropertyName = "2. Blocked entities to remove (shortname of entity, not item):")]
            public List<string> blocked;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                pickupTime = 300,
                blocked = new List<string>
                {
                    "example",
                    "example",
                    "example"
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Time

        private double Now()
        {
            return DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        }

        private int Passed(double a)
        {
            return Convert.ToInt32(Now() - a);
        }

        private string FixNames(string name)
        {
            switch (name)
            {
                case "wall.external.high.wood": return "wall.external.high";
                case "electric.windmill.small": return "generator.wind.scrap";
                case "graveyardfence": return "wall.graveyard.fence";
                case "coffinstorage": return "coffin.storage";
            }
            return name;
        }

        #endregion
    }
}

// --- End of file: RemoveVanilla.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/random-warps ---
// --- Original File Path: R/RandomWarps/RandomWarps.cs ---

﻿using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Random Warps", "LaserHydra", "1.2.0", ResourceId = 1397)]
    [Description("Teleports you to a random location of a multi-location warp")]
    class RandomWarps : RustPlugin
    {
        string pluginColor = "#00FF8D";

        ////////////////////////////////////////////
        ///     Data Handling
        ////////////////////////////////////////////
        class Data
        {
            public Dictionary<string, List<Dictionary<char, float>>> warps = new Dictionary<string, List<Dictionary<char, float>>>();

            public Data()
            {
            }
        }

        Data data;

        void LoadData()
        {
            data = Interface.GetMod().DataFileSystem.ReadObject<Data>("RandomWarps_Data");
        }

        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("RandomWarps_Data", data);
        }

        ////////////////////////////////////////////
        ///     Get Random Position
        ////////////////////////////////////////////

        Vector3 GetRandom(List<Dictionary<char, float>> warpPositions)
        {
            int random = UnityEngine.Random.Range(0, warpPositions.Count - 1);
            Dictionary<char, float> pos = warpPositions[random];

            return new Vector3(pos['x'], pos['y'], pos['z']);
        }

        ////////////////////////////////////////////
        ///     On Plugin Loaded
        ////////////////////////////////////////////

        void Loaded()
        {
            if (!permission.PermissionExists("randomwarps.admin")) permission.RegisterPermission("randomwarps.admin", this);

            LoadData();
            LoadConfig();
        }

        ////////////////////////////////////////////
        ///     Config Handling
        ////////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("Settings", "Time until teleport", 20);

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Generating new configfile...");
        }

        ////////////////////////////////////////////
        ///     Chat Command
        ////////////////////////////////////////////

        [ChatCommand("rwarp")]
        void rWarp(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length < 1)
            {
                if (data.warps.Keys.Count == 0)
                {
                    SendChatMessage(player, "rWarp", "There are no random warps set up!");
                    return;
                }

                SendChatMessage(player, "rWarp", "Warps:");

                foreach (string warp in data.warps.Keys)
                {
                    SendChatMessage(player, "/rwarp " + warp);
                }

                return;
            }

            if ((bool) (Interface.CallHook("IsPrisoner", player) ?? false))
            {
                SendChatMessage(player, "You may not teleport while in jail!");
                return;
            }

	        object canTeleport = Interface.CallHook("CanTeleport", player);

	        if (canTeleport is string)
	        {
		        SendChatMessage(player, (string)canTeleport);
		        return;
	        }

			if (args.Length == 1)
            {
                if (!data.warps.ContainsKey(args[0]))
                {
                    SendChatMessage(player, "rWarp", "Warp does not exist!");
                }
                else
                {
                    SendChatMessage(player, "rWarp", $"You will be teleported in {(int)Config["Settings", "Time until teleport"]} seconds");

                    timer.Once((int)Config["Settings", "Time until teleport"], () => {
                        Teleport(player, GetRandom(data.warps[args[0]]));
                        SendChatMessage(player, "rWarp", $"Teleported to random warp <color={pluginColor}>{args[0]}</color>");
                    });
                }

                return;
            }

            if (!IsAdmin(player)) return;

            string warpName = args[1];

            switch (args[0])
            {
                case "add":
                    if (args.Length != 2) return;
                    if (data.warps.ContainsKey(warpName))
                    {
                        Dictionary<char, float> position = new Dictionary<char, float>();
                        position.Add('x', player.transform.position.x);
                        position.Add('y', player.transform.position.y);
                        position.Add('z', player.transform.position.z);
                        data.warps[warpName].Add(position);
                        SendChatMessage(player, "rWarp", $"You have added a spot to warp <color={pluginColor}>{warpName}</color>");
                    }
                    else
                    {
                        List<Dictionary<char, float>> warpPositions = new List<Dictionary<char, float>>();
                        Dictionary<char, float> position = new Dictionary<char, float>();
                        position.Add('x', player.transform.position.x);
                        position.Add('y', player.transform.position.y);
                        position.Add('z', player.transform.position.z);

                        warpPositions.Add(position);

                        data.warps.Add(warpName, warpPositions);

                        SendChatMessage(player, "rWarp", $"You have added a spot to warp <color={pluginColor}>{warpName}</color>");
                    }

                    SaveData();

                    break;

                case "remove":
                    if (args.Length != 2) return;

                    if (data.warps.ContainsKey(warpName))
                    {
                        data.warps.Remove(warpName);
                        SendChatMessage(player, "rWarp", $"You have removed the random warp <color={pluginColor}>{warpName}</color>");
                    }
                    else
                        SendChatMessage(player, "rWarp", $"Could not remove random warp <color={pluginColor}>{warpName}</color>. Warp does not exist!");

                    SaveData();

                    break;

                default:
                    break;
            }
        }

        ////////////////////////////////////////////
        ///     Admin Check
        ////////////////////////////////////////////

        bool IsAdmin(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "randomwarps.admin")) return true;
            return false;
        }

        ////////////////////////////////////////////
        ///     Teleportation
        ////////////////////////////////////////////

        public void Teleport(BasePlayer player, Vector3 pos)
        {
            //  Thanks to mughisi's Teleportation plugin for this!
            player.ClientRPCPlayer(null, player, "StartLoading");
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);

            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);
                    
            player.MovePosition(pos);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", pos);

            player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();

            player.SendNetworkUpdateImmediate(false);
            player.ClientRPCPlayer(null, player, "StartLoading");
            player.SendFullSnapshot();
        }

        ////////////////////////////////////////////
        ///     Player Finding
        ////////////////////////////////////////////

        BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix)
        {
            var foundPlayers =
                (from player in BasePlayer.activePlayerList
                 where player.displayName.ToLower().Contains(searchedPlayer.ToLower())
                 select player.displayName).ToList();

            switch (foundPlayers.Count)
            {
                case 0:
                    SendChatMessage(executer, prefix, "The Player can not be found.");
                    break;

                case 1:
                    return BasePlayer.Find(foundPlayers[0]);

                default:
                    string players = ListToString(foundPlayers, 0, ", ");
                    SendChatMessage(executer, prefix, "Multiple matching players found: \n" + players);
                    break;
            }

            return null;
        }

        ////////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////////

        string ListToString(List<string> list, int first, string seperator)
        {
            return String.Join(seperator, list.Skip(first).ToArray());
        }

        ////////////////////////////////////////////
        ///     Config Setup
        ////////////////////////////////////////////

        void SetConfig(string Arg1, object Arg2, object Arg3 = null, object Arg4 = null)
        {
            if (Arg4 == null)
            {
                Config[Arg1, Arg2.ToString()] = Config[Arg1, Arg2.ToString()] ?? Arg3;
            }
            else if (Arg3 == null)
            {
                Config[Arg1] = Config[Arg1] ?? Arg2;
            }
            else
            {
                Config[Arg1, Arg2.ToString(), Arg3.ToString()] = Config[Arg1, Arg2.ToString(), Arg3.ToString()] ?? Arg4;
            }
        }

        ////////////////////////////////////////////
        ///     Chat Handling
        ////////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => PrintToChat(msg == null ? prefix : $"<color={pluginColor}>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => SendReply(player, msg == null ? prefix : $"<color={pluginColor}>" + prefix + "</color>: " + msg);
    }
}

// --- End of file: RandomWarps.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/runaway-boats ---
// --- Original File Path: R/RunawayBoats/RunawayBoats.cs ---

﻿using System;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Runaway Boats", "0x89A", "1.2.1")]
    [Description("Stops boats from sailing away on dismount")]
    class RunawayBoats : RustPlugin
    {
        private const string _canUse = "runawayboats.use";

        void Init() => permission.RegisterPermission(_canUse, this);

        private void OnEntityDismounted(BaseMountable mount, BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, _canUse))
            {
                return;
            }

            MotorRowboat boat = mount.GetParentEntity() as MotorRowboat;
            if (boat == null)
            {
                return;
            }

            StopBoat(boat);
        }

        private void StopBoat(MotorRowboat boat)
        {
            bool hasDriver = boat.HasDriver();

            if ((!hasDriver && (!boat.AnyMounted() || _config.stopWithPassengers)) || (hasDriver && _config.stopIfNotDriver))
            {
                boat.gasPedal = 0;
            }
        }

        #region -Configuration-

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty("Stop if dismounted player is not driver")]
            public bool stopIfNotDriver = true;

            [JsonProperty("Stop if boat has passengers")]
            public bool stopWithPassengers = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Failed to load config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
    }
}

// --- End of file: RunawayBoats.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/repair-tool ---
// --- Original File Path: R/RepairTool/RepairTool.cs ---

﻿using System.Collections.Generic;
using UnityEngine;
using System.Reflection;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("RepairTool", "k1lly0u", "0.1.3", ResourceId = 1883)]
    [Description("Repairs any entity that has health")]
    class RepairTool : RustPlugin
    {
        #region Fields
        private static FieldInfo serverinput;
        private string panelName = "RTUI";
        private List<Repairer> activeRepairers = new List<Repairer>();
        #endregion

        #region Oxide Hooks
        void OnServerInitialized() => InitPlugin();
        void Unload() => DestroyAllPlayers();
        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (player.GetComponent<Repairer>())
                if (input.WasJustPressed(BUTTON.FIRE_PRIMARY))
                {
                    if (!player.IsConnected || player.IsDead()) { player.GetComponent<Repairer>().DestroyComponent(); return; }

                    if (player.GetActiveItem() != null)
                    {
                        MSG(player, GetMSG("HandsFull"));
                        return;
                    }
                    player.GetComponent<Repairer>().FindTarget();
                }
        }
        #endregion

        #region UI
        private void CreateUI(BasePlayer player, int time, string name)
        {
            var element = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = "0.2 0.2 0.2 0.7"},
                        RectTransform = {AnchorMin = "0.005 0.89", AnchorMax = "0.2 0.99"},
                    },
                    new CuiElement().Parent = "Overlay",
                    panelName
                }
            };
            element.Add(new CuiLabel
            {
                Text = { FontSize = 20, Align = TextAnchor.MiddleCenter, Text = $"Repair time remaining: {time}" },
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "1 1" }
            },
            panelName);
            element.Add(new CuiLabel
            {
                Text = { FontSize = 16, Align = TextAnchor.MiddleCenter, Text = name },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.5" }
            },
            panelName);
            CuiHelper.AddUi(player, element);
        }
        private void DestroyUI(BasePlayer player) => CuiHelper.DestroyUi(player, panelName);
        #endregion

        #region Functions
        private void InitPlugin()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Repaired", "Repaired " },
                { "RepairNum", "You have repaired {0} entities across the map"},
                { "NoRepair", "Unable to find any repairable entities" },
                { "RepairRad", "You have repaired {0} entities in a {1} radius" },
                { "RepairMap", "You have repaired {0} entities across the map" },
                { "NoRad", "You must enter a radius amount" },
                { "ChatAll", "/rt all - Repairs everything on the map" },
                { "ChatRad", "/rt radius <radius> - Repairs all items found in <radius>" },
                { "ChatRepair", "/rt repair <opt:time> - Activates the repair tool for <time>" },
                { "Chat", "- Chat Commands" },
                { "Deactive", "Repair tool de-activated" },
                { "MaxHealth", "The target already has max health" },
                { "HandsFull", "You cannot use the repair tool with a item in your hands" }
            }, this);
            permission.RegisterPermission("repairtool.use", this);
        }
        private object RepairEntity(BaseEntity entity)
        {
            var r = entity.GetComponent<ResourceDispenser>();
            var e = entity.GetComponent<BaseCombatEntity>();
            if (e != null)
            {
                if (e.health != e.MaxHealth())
                {
                    if (r != null)
                        r.fractionRemaining = 1f;
                    e.health = e.MaxHealth();
                    e.SendNetworkUpdate();
                    return true;
                }
                return GetMSG("MaxHealth");
            }
            return false;
        }
        private BaseEntity FindEntity(BasePlayer player)
        {
            var currentRot = Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward;
            var rayResult = Ray(player, currentRot);
            if (rayResult is BaseEntity)
            {
                var ent = rayResult as BaseEntity;
                return ent;
            }
            else
            {
                var ent = FindBuildingBlock(new Ray(player.eyes.position, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward), 50);
                if (ent == null) return null;
                return ent;
            }

        }
        private object Ray(BasePlayer player, Vector3 Aim)
        {
            var hits = Physics.RaycastAll(player.transform.position + new Vector3(0f, 1.5f, 0f), Aim);
            float distance = 50f;
            object target = null;

            foreach (var hit in hits)
            {
                if (hit.collider.GetComponentInParent<BaseEntity>() != null)
                {
                    if (hit.distance < distance)
                    {
                        distance = hit.distance;
                        target = hit.collider.GetComponentInParent<BaseEntity>();
                    }
                }
            }
            return target;
        }
        private BaseEntity FindBuildingBlock(Ray ray, float distance)
        {
            RaycastHit hit;
            if (!UnityEngine.Physics.Raycast(ray, out hit, distance, LayerMask.GetMask(new string[] { "Construction", "Deployable", "Prevent Building", "Deployed" })))
                return null;
            return hit.GetEntity();
        }
        private void MSG(BasePlayer player, string msg, bool title = true)
        {
            msg = "<color=#939393>" + msg + "</color>";
            if (title) msg = "<color=#FF8C00>Repair Tool:</color> " + msg;
            SendReply(player, msg);
        }
        private string GetMSG(string key) => lang.GetMessage(key, this);
        private void DestroyAllPlayers()
        {
            for (int i = 0; i < activeRepairers.Count - 1; i++)
                if (activeRepairers[i] != null)
                    activeRepairers[i].DestroyComponent();
        }
        #endregion

        #region Chat Commands
        [ChatCommand("rt")]
        private void cmdRA(BasePlayer player, string command, string[] args)
        {
            if (HasPerm(player))
            {
                if (player.GetComponent<Repairer>())
                {
                    player.GetComponent<Repairer>().DestroyComponent();
                    MSG(player, GetMSG("Deactive"));
                    return;
                }
                if (args == null || args.Length == 0)
                {
                    MSG(player, GetMSG("Chat"));
                    MSG(player, GetMSG("ChatRepair"), false);
                    MSG(player, GetMSG("ChatRad"), false);
                    MSG(player, GetMSG("ChatAll"), false);
                    return;
                }
                else switch (args[0].ToLower())
                    {
                        case "repair":
                            {
                                int time = 30;
                                if (args.Length > 1)
                                    int.TryParse(args[1], out time);
                                activeRepairers.Add(player.gameObject.AddComponent<Repairer>());
                                player.GetComponent<Repairer>().InitPlayer(player, time, this);
                            }
                            return;
                        case "radius":
                            if (args.Length > 1)
                            {
                                int radius;
                                if (!int.TryParse(args[1], out radius))
                                {
                                    MSG(player, GetMSG("NoRad"));
                                    return;
                                }
                                List<BaseEntity> foundEntities = new List<BaseEntity>();
                                Vis.Entities(player.transform.position, radius, foundEntities);
                                if (foundEntities == null)
                                {
                                    MSG(player, GetMSG("NoRepair"));
                                    return;
                                }
                                int i = 0;
                                foreach (var entity in foundEntities)
                                {
                                    var success = RepairEntity(entity);
                                    if (success is string) continue;
                                    if (success is bool)
                                        if ((bool) success)
                                            i++;
                                }
                                MSG(player, string.Format(GetMSG("RepairRad"), i, radius));
                            }
                            return;
                        case "all":
                            {
                                var foundEntities = UnityEngine.Object.FindObjectsOfType<BaseEntity>();
                                if (foundEntities == null)
                                {
                                    MSG(player, GetMSG("NoRepair"));
                                    return;
                                }
                                int i = 0;
                                foreach (var entity in foundEntities)
                                {
                                    var success = RepairEntity(entity);
                                    if (success is string) continue;
                                    if (success is bool)
                                        if ((bool)success)
                                            i++;
                                }
                                MSG(player, string.Format(GetMSG("RepairMap"), i));
                            }
                            return;
                    }
            }
        }
        private bool HasPerm(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "repairtool.use")) return true;
            else if (player.IsAdmin) return true;
            return false;
        }
        #endregion

        #region Player Class
        class Repairer : MonoBehaviour
        {
            public BasePlayer player;
            public int TimeRemaining;
            public InputState inputState;
            RepairTool ra;

            public void InitPlayer(BasePlayer p, int time, RepairTool repairtool)
            {
                player = p;
                TimeRemaining = time;
                ra = repairtool;
                ra.activeRepairers.Add(this);
                InvokeRepeating("RefreshGUI", 0.01f, 1);
            }
            public void FindTarget()
            {
                var entity = ra.FindEntity(player);
                if (entity == null) return;
                var success = ra.RepairEntity(entity);
                if (success is string)
                {
                    ra.MSG(player, (string)success);
                    return;
                }
                else if (success is bool)
                    if ((bool)success)
                    {
                        string name = entity.ShortPrefabName.Replace(".prefab", "").Replace("_deployed", "").Replace(".deployed", "").Replace("_", " ").Replace(".", " ");
                        ra.MSG(player, ra.GetMSG("Repaired") + name);
                    }
            }
            private void RefreshGUI()
            {
                DestroyGUI();
                if (TimeRemaining > 0)
                {
                    string name = "---";
                    var entity = ra.FindEntity(player);
                    if (entity != null) name = entity.ShortPrefabName.Replace(".prefab", "").Replace("_deployed", "").Replace(".deployed", "").Replace("_", " ").Replace(".", " ");
                    ra.CreateUI(player, TimeRemaining, name);
                }
                else DestroyComponent();
                TimeRemaining--;
            }
            void DestroyGUI() => ra.DestroyUI(player);
            public void DestroyComponent()
            {
                CancelInvoke("RefreshGUI");
                ra.activeRepairers.Remove(this);
                DestroyGUI();
                UnityEngine.Object.Destroy(this);
            }
        }
        #endregion
    }
}

// --- End of file: RepairTool.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/repairbench-block ---
// --- Original File Path: R/RepairbenchBlock/RepairbenchBlock.cs ---

using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Repairbench Block" , "Krungh Crow", "1.0.2")]
    [Description("Disables using the repairbench")]

    class RepairbenchBlock : RustPlugin
    {
        void Init() => permission.RegisterPermission("repairbenchblock.bypass" , this);

        private object CanLootEntity(BasePlayer player, RepairBench repairbench)
        {

            if (player == null || repairbench == null) return null;
            if (permission.UserHasPermission(player.UserIDString, "repairbenchblock.bypass")) return null;
            return false;
        }
    }
}

// --- End of file: RepairbenchBlock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/research-unlocked ---
// --- Original File Path: R/ResearchUnlocked/ResearchUnlocked.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Research Unlocked", "MJSU", "1.0.2")]
    [Description("Displays a ui if you have already unlocked the item placed in a research table")]
    public class ResearchUnlocked : RustPlugin
    {
        #region Class Fields
        private PluginConfig _pluginConfig; //Plugin Config

        private const string UsePermission = "researchunlocked.use";

        private readonly Hash<ResearchTable, List<BasePlayer>> _lootingPlayers = new Hash<ResearchTable, List<BasePlayer>>();
        
        private string _notLearnedColor;
        private string _learnedColor;
        #endregion

        #region Setup & Loading

        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
            Unsubscribe(nameof(OnItemAddedToContainer));
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.AlreadyLearned] = "Already Learned",
                [LangKeys.NotLearned] = "Not Learned"
            }, this);
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Pos = config.Pos ?? new UiPosition(0.86525f, 0.8025f, 0.86525f + 0.08f, 0.8025f + 0.03f);
            return config;
        }

        private void OnServerInitialized()
        {
            _notLearnedColor = Ui.Color(_pluginConfig.NotLearnedColor);
            _learnedColor = Ui.Color(_pluginConfig.LearnedColor);
            
            Subscribe(nameof(OnItemAddedToContainer));
            
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                ResearchTable table = player.inventory.loot.entitySource as ResearchTable;
                if (table != null)
                {
                    OnLootEntity(player, table);
                }
            }
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                DestroyAllUi(player);
            }
        }
        #endregion

        #region uMod Hooks
        private void OnLootEntity(BasePlayer player, ResearchTable table)
        {
            if (!HasPermission(player, UsePermission) && !player.IsAdmin)
            {
                return;
            }
            
            if (!_lootingPlayers.ContainsKey(table))
            {
                _lootingPlayers[table] = new List<BasePlayer>();
            }

            _lootingPlayers[table].Add(player);

            Item item = table.GetTargetItem();
            if (item == null)
            {
                return;
            }

            if (!table.IsItemResearchable(item))
            {
                return;
            }

            CreateUnlockedUi(player, player.blueprints.HasUnlocked(item.info));
        }

        private void OnLootEntityEnd(BasePlayer player, ResearchTable table)
        {
            if (!_lootingPlayers.ContainsKey(table))
            {
                return;
            }

            _lootingPlayers[table].RemoveAll(p => p.userID == player.userID);

            if (_lootingPlayers[table].Count == 0)
            {
                _lootingPlayers.Remove(table);
            }

            DestroyAllUi(player);
        }

        private void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            NextTick(() =>
            {
                if (item.position != 0)
                {
                    return;
                }
                
                ResearchTable table = container.entityOwner as ResearchTable;
                if (table == null)
                {
                    return;
                }

                if (!_lootingPlayers.ContainsKey(table))
                {
                    return;
                }

                if (!table.IsItemResearchable(item))
                {
                    foreach (BasePlayer player in _lootingPlayers[table])
                    {
                        DestroyAllUi(player);
                    }

                    return;
                }

                foreach (BasePlayer player in _lootingPlayers[table])
                {
                    CreateUnlockedUi(player, player.blueprints.HasUnlocked(item.info));
                }
            });
        }

        private void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            NextTick(() =>
            {
                ResearchTable table = container.entityOwner as ResearchTable;
                if (table == null)
                {
                    return;
                }
                
                if (!_lootingPlayers.ContainsKey(table))
                {
                    return;
                }

                if (!table.IsItemResearchable(item))
                {
                    return;
                }

                foreach (BasePlayer player in _lootingPlayers[table])
                {
                    DestroyAllUi(player);
                }
            });
        }

        #endregion

        #region Helpers
        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        private string Lang(string key, BasePlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
            }
            catch(Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception\n:{ex}");
                throw;
            }
        }

        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue("##00CC00FF")]
            [JsonProperty(PropertyName = "Learned Color")]
            public string LearnedColor { get; set; }
        
            [DefaultValue("#CC0000FF")]
            [JsonProperty(PropertyName = "Not Learned Color")]
            public string NotLearnedColor { get; set; }
            
            [JsonProperty(PropertyName = "Ui Position")]
            public UiPosition Pos { get; set; }
        }
        
        private class LangKeys
        {
            public const string AlreadyLearned = "AlreadyLearned";
            public const string NotLearned = "NotLearned";
        }
        #endregion

        #region UI
        private const string UiPanelName = "ResearchUnlocked_UI";

        private static class Ui
        {
            private static string UiPanel { get; set; }

            public static CuiElementContainer Container(string color, UiPosition pos, bool useCursor, string panel, string parent = "Hud.Menu")
            {
                UiPanel = panel;
                return new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = pos.GetMin(), AnchorMax = pos.GetMax()},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panel
                    }
                };
            }

            public static void Panel(ref CuiElementContainer container, string color, UiPosition pos, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = pos.GetMin(), AnchorMax = pos.GetMax() },
                    CursorEnabled = cursor
                },
                    UiPanel);
            }

            public static void Label(ref CuiElementContainer container, string text, int size, UiPosition pos, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = pos.GetMin(), AnchorMax = pos.GetMax() }

                },
                    UiPanel);
            }

            public static string Color(string hexColor)
            {
                hexColor = hexColor.TrimStart('#');
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                int alpha = 255;
                if (hexColor.Length == 8)
                {
                    alpha = int.Parse(hexColor.Substring(6, 2), NumberStyles.AllowHexSpecifier);
                }
                return $"{red / 255.0} {green / 255.0} {blue / 255.0} {alpha / 255}";
            }
        }

        private class UiPosition
        {
            public float XMin { get; set; }
            public float YMin { get; set; }
            public float XMax { get; set; }
            public float YMax { get; set; }

            public UiPosition(float xMin, float yMin, float xMax, float yMax)
            {
                XMin = xMin;
                YMin = yMin;
                XMax = xMax;
                YMax = yMax;
            }

            public string GetMin() => $"{XMin} {YMin}";
            public string GetMax() => $"{XMax} {YMax}";

            public override string ToString()
            {
                return $"{XMin} {YMin} {XMax} {YMax}";
            }
        }

        private void DestroyAllUi(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UiPanelName);
        }
        #endregion

        #region UI Variables
        private readonly string _clear = Ui.Color("#00000000");
        
        private readonly UiPosition _fullArea = new UiPosition(0, 0, 1, 1);
        #endregion

        #region UI Creation
        private void CreateUnlockedUi(BasePlayer player, bool unlocked)
        {
            CuiElementContainer container = Ui.Container(_clear, _pluginConfig.Pos, false, UiPanelName, "Overlay");

            string key = unlocked ? LangKeys.AlreadyLearned : LangKeys.NotLearned;
            
            Ui.Panel(ref container, unlocked ? _notLearnedColor : _learnedColor, _fullArea);
            Ui.Label(ref container, Lang(key, player), 14, _fullArea);

            CuiHelper.DestroyUi(player, UiPanelName);
            CuiHelper.AddUi(player, container);
        }
        #endregion
    }
}


// --- End of file: ResearchUnlocked.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/radiation-manager ---
// --- Original File Path: R/RadiationManager/RadiationManager.cs ---

﻿using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Radiation Manager", "redBDGR", "1.0.0")]
    [Description("Allows for slight management of radiated zones around the map")]
    class RadiationManager : RustPlugin
    {
        private bool Changed;

        // Minimal
        private float minimalAmount;

        // Low
        private float lowAmount;

        // Medium
        private float mediumAmount;

        // High
        private float highAmount;

        private void OnServerInitialized()
        {
            LoadVariables();
            foreach (TriggerRadiation rad in UnityEngine.Object.FindObjectsOfType<TriggerRadiation>())
            {
                switch (rad.radiationTier)
                {
                    case TriggerRadiation.RadiationTier.MINIMAL:
                        rad.RadiationAmountOverride = minimalAmount;
                        break;
                    case TriggerRadiation.RadiationTier.LOW:
                        rad.RadiationAmountOverride = lowAmount;
                        break;
                    case TriggerRadiation.RadiationTier.MEDIUM:
                        rad.RadiationAmountOverride = mediumAmount;
                        break;
                    case TriggerRadiation.RadiationTier.HIGH:
                        rad.RadiationAmountOverride = highAmount;
                        break;
                }
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            minimalAmount = Convert.ToSingle(GetConfig("Minimal Tier Zones", "Radiation Amount", 2f));

            lowAmount = Convert.ToSingle(GetConfig("Low Tier Zones", "Radiation Amount", 10f));

            mediumAmount = Convert.ToSingle(GetConfig("Medium Tier Zones", "Radiation Amount", 25f));

            highAmount = Convert.ToSingle(GetConfig("High Tier Zones", "Radiation Amount", 51));    // Change to 50 to get rid of "radiation leak"

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (data.TryGetValue(datavalue, out value)) return value;
            value = defaultValue;
            data[datavalue] = value;
            Changed = true;
            return value;
        }
    }
}


// --- End of file: RadiationManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rename ---
// --- Original File Path: R/Rename/Rename.cs ---

/***********************************************************************************************************************/
/*** DO NOT edit this file! Edit the files under `oxide/config` and/or `oxide/lang`, created once plugin has loaded. ***/
/*** Please note, support cannot be provided if the plugin has been modified. Please use a fresh copy if modified.   ***/
/***********************************************************************************************************************/

//#define DEBUG

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Rename", "Wulf", "1.1.2")]
    [Description("Allows players with permission to instantly rename other players or themselves")]
    internal class Rename : CovalencePlugin
    {
        #region Configuration

        private Configuration _config;

        public class Configuration
        {
            [JsonProperty("Notify player of rename")]
            public bool NotifyPlayer = true;

            [JsonProperty("Persistence for renames")]
            public bool Persistence = true;

            [JsonProperty("Prevent admin renames")]
            public bool PreventAdmin = true;

            private string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                // Try loading existing configuration
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                // Check if configuration needs to be updated
                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                // Load default configuration if existing is invalid
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion Configuration

        #region Stored Data

        private class StoredData
        {
            public readonly HashSet<RenameInfo> Renames = new HashSet<RenameInfo>();
        }

        private class RenameInfo : IEquatable<RenameInfo>
        {
            public string Id;
            public string Old;
            public string New;

            public RenameInfo()
            {
            }

            public RenameInfo(string playerId, string oldName, string newName)
            {
                Id = playerId;
                Old = oldName;
                New = newName;
            }

            public override int GetHashCode()
            {
                return Id?.GetHashCode() ?? 0;
            }

            public bool Equals(RenameInfo other)
            {
                return other != null && (Id?.Equals(other.Id) ?? false);
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);

        private void OnServerSave() => SaveData();

        private void Unload() => SaveData();

        #endregion Stored Data

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandRename"] = "rename",
                ["CommandResetName"] = "resetname",
                ["CommandUsageRename"] = "Usage: {0} <name or id> [new name] (new name only if renaming self)",
                ["CommandUsageReset"] = "Usage: {0} [name or id] (optional if resetting self)",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PlayerAlreadyNamed"] = "{0} is already named {1}",
                ["PlayerIsAdmin"] = "{0} is admin and cannot be renamed",
                ["PlayerNameReset"] = "Reset the player name for {0} to {1}",
                ["PlayerNotFound"] = "{0} was not found",
                ["PlayerNotRenamed"] = "{0} is not renamed",
                ["PlayerRenamed"] = "{0} was renamed to {1}",
                ["YouAreNotRenamed"] = "You are not renamed",
                ["YouWereRenamed"] = "You were renamed to {0}",
                ["YourNameIsAlready"] = "Your name is already {0}",
                ["YourNameReset"] = "Your name was reset to {0}",
                ["NoPlayersFound"] = "No players found with name or ID {0}",
                ["PlayersFound"] = "Multiple players were found, please specify: {0}"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string PermissionOthers = "rename.others";
        private const string PermissionSelf = "rename.self";

        private StoredData _storedData;

        private void Init()
        {
            // Load stored data from file to memory
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name) ?? new StoredData();

            // Clean up any old data with null values
            foreach (RenameInfo renameInfo in _storedData.Renames)
            {
                if (renameInfo.Id == null || renameInfo.Old == null || renameInfo.New == null)
                {
                    _storedData.Renames.Remove(renameInfo);
                }
            }

            // Register permissions and add commands
            permission.RegisterPermission(PermissionOthers, this);
            permission.RegisterPermission(PermissionSelf, this);
            AddLocalizedCommand(nameof(CommandRename));
            AddLocalizedCommand(nameof(CommandResetName));

            // Disable select hooks if persistence is disabled
            if (!_config.Persistence)
            {
                Unsubscribe(nameof(OnServerSave));
                Unsubscribe(nameof(Unload));
            }
        }

        #endregion Initialization

        #region Name Handling

        private void OnUserConnected(IPlayer player)
        {
            // Check if player should be renamed on connection
            RenameInfo renameInfo = _storedData.Renames.FirstOrDefault(r => r.Id == player.Id);
            if (renameInfo != null && _config.Persistence)
            {
                player.Rename(renameInfo.New);
                if (_config.NotifyPlayer)
                {
                    Message(player, "YouWereRenamed", renameInfo.New);
                }
                Log(GetLang("PlayerRenamed", null, player.Name, renameInfo.New));
            }
        }

        #endregion Name Handling

        #region Commands

        private void CommandRename(IPlayer player, string command, string[] args)
        {
            if ((args.Length >= 2 && !player.HasPermission(PermissionOthers)) || !player.HasPermission(PermissionSelf))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 1 || args.Length == 1 && player.IsServer)
            {
                Message(player, "CommandUsageRename", command);
                return;
            }

            IPlayer target = args.Length >= 2 ? FindPlayer(args[0], player) : player;
            if (target == null)
            {
                return;
            }

            if (args.Length >= 2 && _config.PreventAdmin && target.IsAdmin && !Equals(target, player))
            {
                Message(player, "PlayerIsAdmin", target.Name);
                return;
            }

            string newName = args.Length >= 2 ? args[1] : args[0];

            if (target.Name.Equals(newName))
            {
                if (Equals(target, player))
                {
                    Message(target, "YourNameIsAlready", newName);
                }
                else
                {
                    Message(target, "PlayerAlreadyNamed", target.Name, newName);
                }
                return;
            }

            RenameInfo renameInfo = _storedData.Renames.FirstOrDefault(r => r.Id == target.Id);
            if (renameInfo == null)
            {
                _storedData.Renames.Add(new RenameInfo(target.Id, target.Name, newName));
            }
            else
            {
                renameInfo.New = newName;
            }

            if (!Equals(target, player))
            {
                Message(player, "PlayerRenamed", target.Name, newName);
            }

            if (target.IsConnected)
            {
                if (_config.NotifyPlayer)
                {
                    Message(target, "YouWereRenamed", newName);
                }
                target.Rename(newName);
            }
        }

        private void CommandResetName(IPlayer player, string command, string[] args)
        {
            if ((args.Length >= 1 && !player.HasPermission(PermissionOthers)) || !player.HasPermission(PermissionSelf))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 1 && player.IsServer)
            {
                Message(player, "CommandUsageReset", command);
                return;
            }

            IPlayer target = args.Length >= 1 ? FindPlayer(args[0], player) : player;
            if (target == null)
            {
                return;
            }

            RenameInfo renameInfo = _storedData.Renames.FirstOrDefault(r => r.Id == target.Id);
            if (renameInfo == null)
            {
                if (args.Length > 0)
                {
                    Message(player, "PlayerNotRenamed", args[0]);
                }
                else
                {
                    Message(player, "YouAreNotRenamed");
                }

                return;
            }

            _storedData.Renames.Remove(renameInfo);

            if (!Equals(target, player))
            {
                Message(player, "PlayerNameReset", target.Name, renameInfo.Old);
            }

            if (target.IsConnected)
            {
                if (_config.NotifyPlayer)
                {
                    Message(target, "YourNameReset", renameInfo.Old);
                }
                target.Rename(renameInfo.Old);
            }
        }

        #endregion Commands

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                foreach (KeyValuePair<string, string> message in lang.GetMessages(language, this))
                {
                    if (message.Key.Equals(command) && !string.IsNullOrEmpty(message.Value))
                    {
                        AddCovalenceCommand(message.Value, command);
                    }
                }
            }
        }

        private IPlayer FindPlayer(string playerNameOrId, IPlayer player)
        {
            IPlayer[] foundPlayers = players.FindPlayers(playerNameOrId).ToArray();
            if (foundPlayers.Length > 1)
            {
                Message(player, "PlayersFound", string.Join(", ", foundPlayers.Select(p => p.Name).Take(10).ToArray()).Truncate(60));
                return null;
            }

            IPlayer target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target == null)
            {
                Message(player, "NoPlayersFound", playerNameOrId);
                return null;
            }

            return target;
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}

// --- End of file: Rename.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/roulette-broadcast ---
// --- Original File Path: R/RouletteBroadcast/RouletteBroadcast.cs ---

﻿
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Roulette Broadcast", "supreme", "1.2.0")]
    [Description("Broadcasts the payout on the roulette")]
    public class RouletteBroadcast : RustPlugin
    {
        
        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Amount of scrap to win in order to broadcast")]
            public int amount = 300;
            
            [JsonProperty(PropertyName = "Broadcast Icon (SteamID)")]
            public ulong chatIcon = 0;
            
            [JsonProperty(PropertyName = "Enable Broadcast Delay")]
            public bool delay = true;
            
            [JsonProperty(PropertyName = "Broadcast Delay Time (seconds)")]
            public int delayTime = 30;
            
            [JsonProperty(PropertyName = "Gametip Message")]
            public bool gameTip = true;
            
            [JsonProperty(PropertyName = "Gametip Message Time")]
            public float gameTipTime = 5f;
            
            [JsonProperty(PropertyName = "Custom Rewards")]
            public bool enableRewards = true;
            
            [JsonProperty(PropertyName = "Custom Rewards Message")]
            public bool enableRewardsMessage = true;

            [JsonProperty(PropertyName = "Custom Rewards Items")]
            public Dictionary<string, int> Items;
            
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration
            {
                Items = new Dictionary<string, int>
                {
                    {"rock", 1},
                    {"torch", 1},
                    {"stones", 500},
                    {"rifle.ak", 1}
                }
            };
        }

        #endregion
        
        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Broadcast Message"] = "<color=#e3e3e3><color=#ACFA58>{0}</color> just won <color=#ACFA58>{1}</color> scrap on the roulette!</color>",
                ["Custom Rewards"] = "<color=#e3e3e3>You have been <color=#ACFA58>rewarded</color> with custom items!</color>"
            }, this);
        }
        
        #endregion

        private void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            BigWheelBettingTerminal entity = container.entityOwner as BigWheelBettingTerminal;
            if (entity == null) return;
            if (!entity.inventory.IsLocked()) return;
            BasePlayer seatedPlayer = null;
            List<BasePlayer> nearbyPlayers = Facepunch.Pool.GetList<BasePlayer>();
            Vis.Entities(container.entityOwner.transform.position, entity.offsetCheckRadius + 1f, nearbyPlayers);
            Vector3 offset = entity.transform.TransformPoint(entity.seatedPlayerOffset);
            foreach (BasePlayer player in nearbyPlayers)
            {
                if (!player.isMounted) continue;
                if (Vector3Ex.Distance2D(player.transform.position, offset) <= entity.offsetCheckRadius)
                {
                    seatedPlayer = player;
                    break;
                }
            }
            Facepunch.Pool.FreeList(ref nearbyPlayers);
            if (seatedPlayer == null) return;
            if (item.amount >= _config.amount)
            {
                if (_config.delay)
                {
                    timer.In(_config.delayTime, () => Server.Broadcast(Lang("Broadcast Message", null, seatedPlayer.displayName, item.amount), _config.chatIcon));
                }
                else
                {
                    Server.Broadcast(Lang("Broadcast Message", null, seatedPlayer.displayName, item.amount), _config.chatIcon);
                }
                
                if (_config.enableRewards)
                {
                    foreach (var i in _config.Items)
                    {
                        var give = ItemManager.CreateByName(i.Key, i.Value);
                        if (give == null) continue;
                        seatedPlayer.GiveItem(give);
                    }
                    if (_config.enableRewardsMessage) seatedPlayer.ChatMessage(Lang("Custom Rewards", seatedPlayer.UserIDString));
                    if (_config.gameTip)
                    {
                        seatedPlayer.SendConsoleCommand("gametip.showgametip", Lang("Custom Rewards", seatedPlayer.UserIDString));
                        timer.In(_config.gameTipTime, () => seatedPlayer.Command("gametip.hidegametip"));
                    }
                }
            }
        }

        #region Helpers

        string Lang(string key, string id, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}

// --- End of file: RouletteBroadcast.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/real-time ---
// --- Original File Path: R/RealTime/RealTime.cs ---

using System;
using System.Collections;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Real Time", "haggbart", "1.0.0")]
    [Description("Syncs ingame time with real time")]
    class RealTime : RustPlugin
    {
        private bool enabled = true;
        private TOD_Time todTime;
        private WaitForSeconds waitForSeconds;
        private float offsetHours;

        private const string OFFSET_HOURS = "Time offset in hours";
        private const float SECONDS_BETWEEN = 59f;

        protected override void LoadDefaultConfig()
        {
            Config[OFFSET_HOURS] = 0f;
        }
        
        private void OnServerInitialized()
        {
            waitForSeconds = new WaitForSeconds(SECONDS_BETWEEN);
            offsetHours = Convert.ToSingle(Config[OFFSET_HOURS]);
            todTime = TOD_Sky.Instance.Components.Time;
            todTime.ProgressTime = false;
            todTime.UseTimeCurve = false;
            SyncRealTime();
            todTime.RefreshTimeCurve();
            ServerMgr.Instance.StartCoroutine(AddTimeAndSync());
        }

        private void Unload()
        {
            todTime.ProgressTime = true;
            todTime.UseTimeCurve = true;
            enabled = false;
        }

        private IEnumerator AddTimeAndSync()
        {
            while (enabled)
            {
                yield return waitForSeconds;
                todTime.AddHours(SECONDS_BETWEEN / 3600f, false);
                SyncRealTime();
            }
        }
        
        private void SyncRealTime()
        {
            TOD_Sky.Instance.Cycle.Hour = (float)DateTime.Now.TimeOfDay.TotalHours + offsetHours;
        }
    }
}

// --- End of file: RealTime.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/realistic-igniter ---
// --- Original File Path: R/RealisticIgniter/RealisticIgniter.cs ---

using Rust;
using ConVar;
using Network;
using Oxide.Core;
using System;
using UnityEngine;
using UnityEngine.Assertions;

namespace Oxide.Plugins
{
    [Info("Realistic Igniter", "ArtiIOMI", "1.1.4")]
    [Description("You can now set fire to the fireplace using the flamethrower or torch.")]
    internal class RealisticIgniter : RustPlugin
    {
        void OnEntityTakeDamage(BaseOven entity, HitInfo info)
        {
            if(entity == null || info == null)
                return;

            if(!entity.ShortPrefabName.Contains("campfire"))
                return;

            if(entity.IsOn())
                return;

            if(entity == null)
                return;

            if(!entity.inventory.itemList.Exists(x => x.info.shortname == "wood"))
                return;

            if(!info.damageTypes.Has(DamageType.Heat) && !info.damageTypes.Has(DamageType.Blunt))
                return;

            if(info.damageTypes.Has(DamageType.Heat)){
                entity.StartCooking();
                info.damageTypes = new DamageTypeList();
            }else{
                if(info.WeaponPrefab == null)
                    return;
                if((info.WeaponPrefab.ShortPrefabName.Contains("torch.entity") && info.WeaponPrefab.IsOn())){
                    entity.StartCooking();
                }
                info.damageTypes = new DamageTypeList();
            }
        }
    }
}


// --- End of file: RealisticIgniter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rotating-billboards ---
// --- Original File Path: R/RotatingBillboards/RotatingBillboards.cs ---

﻿using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Rotating Billboards", "k1lly0u", "0.1.3", ResourceId = 2199)]
    [Description("Creates signs that rotate on the spot")]
    class RotatingBillboards : RustPlugin
    {
        #region Fields
        StoredData storedData;
        private DynamicConfigFile data;

        private List<Rotator> billBoards;
        static RotatingBillboards instance;

        private Vector3 eyesAdjust;

        private bool initialized;
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            billBoards = new List<Rotator>();
            data = Interface.Oxide.DataFileSystem.GetFile("billboard_data");
            eyesAdjust = new Vector3(0f, 1.5f, 0f);
            lang.RegisterMessages(Messages, this);
        }
        void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            instance = this;
            initialized = true;
            FindAllEntities();
        }
        void OnEntityKill(BaseNetworkable netEntity)
        {
            if (!initialized) return;
            if (netEntity?.net?.ID == null) return;
            if (storedData.data.Contains(netEntity.net.ID))
            {
                storedData.data.Remove(netEntity.net.ID);
                return;
            }
        }
        void Unload()
        {
            var objects = UnityEngine.Object.FindObjectsOfType<Rotator>();
            if (objects != null)
            {
                foreach(var obj in objects)
                {
                    UnityEngine.Object.Destroy(obj);
                }
            }
        }
        #endregion

        #region Class
        class Rotator : Signage
        {
            private Signage entity;
            private float secsToTake;

            private float initialRot;
            private bool isRotating;

            void Awake()
            {
                entity = GetComponent<Signage>();
                initialRot = entity.transform.eulerAngles.y;
                secsToTake = instance.configData.RotationSpeed;
                isRotating = false;
            }
            void Destroy()
            {
                entity.transform.eulerAngles = new Vector3(entity.transform.eulerAngles.x, initialRot, entity.transform.eulerAngles.z);
                entity.transform.hasChanged = true;
                entity.SendNetworkUpdateImmediate();
                Destroy(this);
            }
            void FixedUpdate()
            {
                if (!isRotating) return;
                entity.transform.RotateAround(entity.transform.position, Vector3.up, secsToTake);
                entity.transform.hasChanged = true;
                entity.SendNetworkUpdateImmediate();
            }
            public void ToggleRotation()
            {
                if (isRotating)
                    isRotating = false;
                else isRotating = true;
            }
            public bool IsRotating() => isRotating;
        }
        #endregion

        #region Functions
        void FindAllEntities()
        {
            var signs = UnityEngine.Object.FindObjectsOfType<Signage>();
            foreach(var sign in signs)
            {
                if (sign == null) continue;
                if (storedData.data.Contains(sign.net.ID))
                {
                    if (!sign.GetComponent<Rotator>())
                    {
                        var rotator = sign.gameObject.AddComponent<Rotator>();
                        rotator.enabled = true;
                        billBoards.Add(rotator);
                        rotator.ToggleRotation();
                    }
                }
            }
        }
        object FindEntityFromRay(BasePlayer player)
        {
            Ray ray = new Ray(player.eyes.position, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward);
            RaycastHit hit;
            if (!Physics.Raycast(ray, out hit, 20))
                return null;

            var hitEnt = hit.collider.GetComponentInParent<Signage>();
            if (hitEnt != null)
                return hitEnt;
            return null;
        }
        #endregion

        #region Commands
        [ChatCommand("rot")]
        void cmdRot(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            if (args.Length == 0)
            {
                SendReply(player, msg("/rot add - Adds a rotator to the sign you are looking at", player.UserIDString));
                SendReply(player, msg("/rot remove - Removes a rotator from the sign you are looking at", player.UserIDString));
                SendReply(player, msg("/rot remove all - Removes all rotators and wipes data", player.UserIDString));
                SendReply(player, msg("/rot start - Starts the rotation of the sign you are looking at", player.UserIDString));
                SendReply(player, msg("/rot stop - Stops the rotation of the sign you are looking at", player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "add":
                    {
                        var entity = FindEntityFromRay(player);
                        if (entity != null)
                        {
                            Signage sign = entity as Signage;
                            if (!storedData.data.Contains(sign.net.ID))
                            {
                                storedData.data.Add(sign.net.ID);
                                var rotator = sign.gameObject.AddComponent<Rotator>();
                                rotator.enabled = true;
                                billBoards.Add(rotator);
                                rotator.ToggleRotation();
                                SaveData();
                                SendReply(player, msg("You have successfully created a rotating billboard"));
                            }
                            else SendReply(player, msg("This sign already has a rotator attached to it"));
                        }
                        else SendReply(player, msg("Unable to find a valid sign"));
                    }
                    return;
                case "remove":
                    if (args.Length == 2 && args[1].ToLower() == "all")
                    {
                        foreach (var rotator in billBoards)
                            UnityEngine.Object.Destroy(rotator);
                        billBoards.Clear();
                        storedData.data.Clear();
                        SaveData();
                        SendReply(player, msg("Removed all rotating billboards"));
                    }
                    else
                    {
                        var entity = FindEntityFromRay(player);
                        if (entity != null)
                        {
                            BaseEntity sign = (entity as BaseEntity);
                            if (sign.GetComponent<Rotator>())
                            {
                                billBoards.Remove(sign.GetComponent<Rotator>());
                                UnityEngine.Object.Destroy(sign.GetComponent<Rotator>());
                                if (storedData.data.Contains(sign.net.ID))
                                    storedData.data.Remove(sign.net.ID);
                                SaveData();
                                SendReply(player, msg("You have successfully removed this rotating billboard"));
                            }
                            else SendReply(player, msg("This sign does not have a rotator attached to it"));
                        }
                        else SendReply(player, msg("Unable to find a valid sign"));
                    }
                    return;
                case "start":
                    {
                        var entity = FindEntityFromRay(player);
                        if (entity != null)
                        {
                            Rotator sign = (entity as BaseEntity).GetComponent<Rotator>();
                            if (sign != null)
                            {
                                if (sign.IsRotating())
                                    SendReply(player, msg("This sign is already rotating"));
                                else
                                {
                                    sign.ToggleRotation();
                                    SendReply(player, msg("Rotation started"));
                                }
                                return;
                            }
                            else SendReply(player, msg("This sign does not have a rotator attached to it"));
                        }
                        else SendReply(player, msg("Unable to find a valid sign"));
                    }
                    return;
                case "stop":
                    {
                        var entity = FindEntityFromRay(player);
                        if (entity != null)
                        {
                            Rotator sign = (entity as BaseEntity).GetComponent<Rotator>();
                            if (sign != null)
                            {
                                if (!sign.IsRotating())
                                    SendReply(player, msg("This sign is already stopped"));
                                else
                                {
                                    sign.ToggleRotation();
                                    SendReply(player, msg("Rotation stopped"));
                                }
                                return;
                            }
                            else SendReply(player, msg("This sign does not have a rotator attached to it"));
                        }
                        else SendReply(player, msg("Unable to find a valid sign"));
                    }
                    return;
                default:
                    break;
            }
        }

        string msg(string key, string userId = null) => lang.GetMessage(key, this, userId);
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"Unable to find a valid sign", "Unable to find a valid sign" },
            {"This sign does not have a rotator attached to it","This sign does not have a rotator attached to it" },
            {"Rotation stopped","Rotation stopped" },
            {"This sign is already stopped","This sign is already stopped" },
            {"Rotation started","Rotation started" },
            {"This sign is already rotating","This sign is already rotating" },
            {"You have successfully removed this rotating billboard","You have successfully removed this rotating billboard" },
            {"Removed all rotating billboards","Removed all rotating billboards" },
            {"You have successfully created a rotating billboard","You have successfully created a rotating billboard" },
            {"/rot stop - Stops the rotation of the sign you are looking at","/rot stop - Stops the rotation of the sign you are looking at" },
            {"/rot start - Starts the rotation of the sign you are looking at","/rot start - Starts the rotation of the sign you are looking at" },
            {"/rot remove all - Removes all rotators and wipes data","/rot remove all - Removes all rotators and wipes data" },
            {"/rot remove - Removes a rotator from the sign you are looking at","/rot remove - Removes a rotator from the sign you are looking at" },
            {"/rot add - Adds a rotator to the sign you are looking at","/rot add - Adds a rotator to the sign you are looking at" }
        };
        #endregion

        #region Config
        private ConfigData configData;
        class ConfigData
        {
            public float RotationSpeed { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                RotationSpeed = 5f
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management
        void SaveData() => data.WriteObject(storedData);
        void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }
        }
        class StoredData
        {
            public List<uint> data = new List<uint>();
        }
        #endregion
    }
}

// --- End of file: RotatingBillboards.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rf-tool ---
// --- Original File Path: R/RfTool/RfTool.cs ---

/*
    RfTool - A Rust umod plugin to manipulate/intercept in-game RF objects/signals
    Copyright (C) 2019 by Pinguin

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("RF Tool", "PinguinNordpol", "0.2.4")]
    [Description("Manipulates/intercepts in-game RF objects and signals")]
    class RfTool : CovalencePlugin
    {
        private int frequency_min = 1;
        private int frequency_max = 9999;
        private RfToolConfig config_data;
        private Timer listener_timer;

        #region Plugin Config
        /*
         * Classes & functions to load / store plugin configuration
         */
        private class ListenerData
        {
            public int frequency;
            public string msg;
            public int block_delay;
            public int cur_block_delay;

            /*
             * Constructor
             */
            public ListenerData(int _frequency, string _msg, int _block_delay)
            {
                this.frequency = _frequency;
                this.msg = _msg;
                this.block_delay = _block_delay;
                this.cur_block_delay = 0;
            }

            /*
             * Get configured frequency
             */
            public int GetFrequency()
            {
                return this.frequency;
            }

            /*
             * Get configured message
             */
            public string GetMessage()
            {
                return this.msg;
            }

            /*
             * Get block delay
             */
            public int GetBlockDelay()
            {
                return this.block_delay;
            }

            /*
             * Enable blocking
             */
            public void EnableBlocking()
            {
                if (this.block_delay != 0)
                {
                    this.cur_block_delay = this.block_delay;
                }
            }

            /*
             * Clear blocking
             */
            public void DisableBlocking()
            {
                this.cur_block_delay = 0;
            }

            /*
             * Check if listener is currently blocked and decrement block counter if it is
             */
            public bool IsBlocked()
            {
                if(this.cur_block_delay == 0)
                {
                    return false;
                }
                this.cur_block_delay -= 1;
                return true;
            }
        }
        private class RfToolConfig
        {
            public float tick_interval = 1f;
            public bool debug = false;
            public List<ListenerData> configured_listeners = new List<ListenerData>();
        }
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }
        private RfToolConfig GetDefaultConfig()
        {
            return new RfToolConfig();
        }
        #endregion

        #region Umod Hooks
        /*
         * Initialize plugin
         */
        void Init()
        {
            // Load plugin config
            this.config_data = Config.ReadObject<RfToolConfig>();

            // All configured listeners should be unblocked at the start
            this.ResetListenersCurBlockDelay();
        }

        /*
         * Get things rolling once server is ready
         */
        void OnServerInitialized()
        {
            // Get actual min/max frequencies in case they changed after development
            this.frequency_min = RFManager.minFreq; // Was 1
            this.frequency_max = RFManager.maxFreq; // Was 9999

            // Start listener loop timer
            this.listener_timer = timer.Every(this.config_data.tick_interval, this.CheckListeners);
        }

        /*
         * Clear up before server shuts down
         */
        void OnServerShutdown()
        {
            // Stop listener loop timer
            this.listener_timer.Destroy();
        }
        #endregion

        #region Localization
        /*
         * Load default messages
         */
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["cmd_rftool_help"] = "RfTool v{0} - A Rust umod plugin to manipulate/intercept in-game RF objects and signals\r\n" +
                                      "Copyright(C) 2019 by Pinguin and released under GPLv3\r\n" +
                                      "\r\n" +
                                      "The following commands are available:\r\n" +
                                      "  rftool.inspect : List all currently in-game exisiting receivers / broadcasters and their frequencies.\r\n" +
                                      "  rftool.enable : Enable all in-game receivers on the specified frequency.\r\n" +
                                      "  rftool.disable : Disable all in-game receivers on the specified frequency.\r\n" +
                                      "  rftool.listeners.list : List all configured virtual receivers.\r\n" +
                                      "  rftool.listeners.add : Add a virtual receiver on the specified frequency.\r\n" +
                                      "  rftool.listeners.del : Delete the virtual receiver on the specified frequency.\r\n" +
                                      "  rftool.listeners.get_interval : Get the interval in which virtual receivers operate.\r\n" +
                                      "  rftool.listeners.set_interval : Set the interval in which virtual receivers operate.\r\n" +
                                      "  rftool.debug : Toggle (enable/disable) internal debugging. Only used for testing!\r\n" +
                                      "\r\n" +
                                      "For commands that take arguments, more help is available by executing them without any arguments.\r\n" +
                                      "\r\n" +
                                      "To be able to execute any rftool commands, you need to have the umod 'rftool.use' right assigned to your user.",
                ["cmd_rftool.inspect_listeners"] = "Found {0} listener(s) on frequency {1}",
                ["cmd_rftool.inspect_broadcaster"] = "Found {0} broadcaster(s) on frequency {1}",
                ["cmd_rftool.enable_help"] = "Usage:\r\n" +
                                             "  rftool.enable <frequency>\r\n" +
                                             "\r\n" +
                                             "Description:\r\n" +
                                             "  This command enables all currently available in-game receivers listening on the specified\r\n" +
                                             "  frequency <frequency>. This is similiar to broadcasting on the given frequency in-game\r\n" +
                                             "  except that receivers set to the given frequency after this command was executed won't\r\n" +
                                             "  get enabled!\r\n" +
                                             "\r\n" +
                                             "Options:\r\n" +
                                             "  <frequency> : The frequency on which in-game receivers have to listen to get enabled ({0}-{1}).",
                ["cmd_rftool.enable_success"] = "Enabled {0} listener(s) on frequency {1}",
                ["cmd_rftool.disable_help"] = "Usage:\r\n" +
                                              "  rftool.disable <frequency>\r\n" +
                                              "\r\n" +
                                              "Description:\r\n" +
                                              "  This command disables all currently available in-game receivers listening on the specified\r\n" +
                                              "  frequency <frequency>.\r\n" +
                                              "\r\n" +
                                              "Options:\r\n" +
                                              "  <frequency> : The frequency on which in-game receivers have to listen to get disabled ({0}-{1}).",
                ["cmd_rftool.disable_success"] = "Disabled {0} listener(s) on frequency {1}",
                ["cmd_rftool.listeners.add_help"] = "Usage:\r\n" +
                                                    "  rftool.listeners.add <frequency> <log_message> [<block_delay>]\r\n" +
                                                    "\r\n" +
                                                    "Description:\r\n" +
                                                    "  This command adds a new virtual RF receiver that, when triggered in-game\r\n" +
                                                    "  on the specified frequency <frequency>, will log the specified <log_message>\r\n" +
                                                    "  message to the console. Optionally, a block delay <block_delay> may be specified\r\n" +
                                                    "  during which no more messages should be send to the console once triggered. The\r\n" +
                                                    "  actual delay is <block_delay> * 'configured interval'. See also the help message\r\n" +
                                                    "  of the command rftool.listeners.set_interval\r\n" +
                                                    "\r\n" +
                                                    "Options:\r\n" +
                                                    "  <frequency> : The frequency on which to listen for broadcasts ({0}-{1}).\r\n" +
                                                    "  <log_message> : The message that should be logged to the console.\r\n" +
                                                    "  <block_delay> : Delay to block once triggered (0=no delay).",
                ["cmd_rftool.listeners.add_error"] = "A listener on frequency {0} is already configured!",
                ["cmd_rftool.listeners.add_success"] = "Added listener on frequency {0} with a block delay of {1} and the log message '{2}'",
                ["cmd_rftool.listeners.del_help"] = "Usage:\r\n" +
                                                    "  rftool.listeners.del <frequency>\r\n" +
                                                    "\r\n" +
                                                    "Description:\r\n" +
                                                    "  This command removes a previously added virtual RF receiver operating on the\r\n" +
                                                    "  specified frequency <frequency>.\r\n" +
                                                    "\r\n" +
                                                    "Options:\r\n" +
                                                    "  <frequency> : The frequency on which the virtual receiver is listening ({0}-{1}).",
                ["cmd_rftool.listeners.del_error"] = "Currently no listeners on frequency {0} configured!",
                ["cmd_rftool.listeners.del_success"] = "Removed listener on frequency {0}",
                ["cmd_rftool.listeners.list_error"] = "Currently no listeners configured",
                ["cmd_rftool.listeners.list_success"] = "The following {0} listener(s) is/are currently configured (Frequency | Log message | Block delay):",
                ["cmd_rftool.listeners.set_interval_help"] = "Usage:\r\n" +
                                                             "  rftool.listeners.set_interval <interval>\r\n" +
                                                             "\r\n" +
                                                             "Description:\r\n" +
                                                             "  This command changes the delay in which this plugin will check for broadcasts\r\n" +
                                                             "  to <interval> seconds. A check whether one of the virtual receivers should be\r\n" +
                                                             "  triggered is only carried out once in this interval. This will also control\r\n" +
                                                             "  the final value of the block delay of a triggered receiver. As an example, if\r\n" +
                                                             "  interval is 5 and block delay is 2, a triggered receiver will be silet for the\r\n" +
                                                             "  next 5 * 2 = 10 seconds. See also the help message of the command rftool.listeners.add\r\n" +
                                                             "\r\n" +
                                                             "Options:\r\n" +
                                                             "  <interval> : Interval in seconds (>0).",
                ["cmd_rftool.listeners.set_interval_error"] = "Current listeners interval is already set to {0} second(s)",
                ["cmd_rftool.listeners.set_interval_success"] = "Updated listeners interval to {0} second(s)",
                ["cmd_rftool.listeners.get_interval_success"] = "Current listeners interval is set to {0} second(s)",
                ["cmd_rftool.debug_enabled"] = "Internal debugging has been enabled",
                ["cmd_rftool.debug_disabled"] = "Internal debugging has been disabled",
                ["errmsg_freq_invalid"] = "Invalid frequency specified!",
                ["errmsg_freq_bounds"] = "Specified frequency is out of bounds!",
                ["errmsg_interval_invalid"] = "Invalid interval value specified!",
                ["debug_checklisteners"] = "Checking listeners",
                ["debug_listenerblocked"] = "Listener on frequency {0} currently blocked",
            }, this);
        }

        #endregion

        #region Console Commands
        /*
         * Print available commands and a short description
         */
        [Command("rftool")]
        void RfToolHelp(IPlayer player, string command, string[] args)
        {
            this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool_help", this, player.Id), Version));
        }

        /*
         * List all registered listeners / broadcasters
         */
        [Command("rftool.inspect"), Permission("rftool.use")]
        void RfToolInspect(IPlayer player, string command, string[] args)
        {
            for (int cur_freq = frequency_min; cur_freq <= frequency_max; cur_freq++)
            {
                var listeners = RFManager.GetListenList(cur_freq);
                if(listeners.Count>0)
                {
                    this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.inspect_listeners", this, player.Id), listeners.Count, cur_freq));
                }
            }
            for (int cur_freq = frequency_min; cur_freq <= frequency_max; cur_freq++)
            {
                var broadcasters = RFManager.GetBroadcasterList(cur_freq);
                if (broadcasters.Count > 0)
                {
                    this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.inspect_broadcaster", this, player.Id), broadcasters.Count, cur_freq));
                }
            }
        }

        /*
         * Enable all RF listeners on a given frequency
         */
        [Command("rftool.enable"), Permission("rftool.use")]
        void RfToolEnable(IPlayer player, string command, string[] args)
        {
            int frequency = 0;

            // Check if player specified a frequency
            if (args.Length != 1)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.enable_help", this, player.Id), this.frequency_min, this.frequency_max));
                return;
            }

            // Get & check frequency
            frequency = this.GetFrequency(player, args);
            if (frequency == 0) return;

            // Get all listeners for given frequency and enable them
            var listeners = RFManager.GetListenList(frequency);
            for (int i=0; i < listeners.Count; i++)
            {
                listeners[i].RFSignalUpdate(true);
            }
            
            this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.enable_success", this, player.Id), listeners.Count, frequency));
        }

        /*
         * Disable all RF listeners on a given frequency
         */
        [Command("rftool.disable"), Permission("rftool.use")]
        void RfToolDisable(IPlayer player, string command, string[] args)
        {
            int frequency = 0;

            // Check if player specified a frequency
            if (args.Length != 1)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.disable_help", this, player.Id), this.frequency_min, this.frequency_max));
                return;
            }

            // Get & check frequency
            frequency = this.GetFrequency(player, args);
            if (frequency == 0) return;

            // Get all listeners for given frequency and disable them
            var listeners = RFManager.GetListenList(frequency);
            for (int i = 0; i < listeners.Count; i++)
            {
                listeners[i].RFSignalUpdate(false);
            }

            this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.disable_success", this, player.Id), listeners.Count, frequency));
        }

        /*
         * Start listening on specific frequency and log broadcasts
         */
        [Command("rftool.listeners.add"), Permission("rftool.use")]
        void RfToolListenersAdd(IPlayer player, string command, string[] args)
        {
            int frequency=0;
            int block_delay = 0;

            // Check command line args
            if (args.Length == 0 || args.Length > 3)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.listeners.add_help", this, player.Id), this.frequency_min, this.frequency_max));
                return;
            }
            if (!int.TryParse(args[0], out frequency))
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("errmsg_freq_invalid", this, player.Id)));
                return;
            }
            if (args.Length == 3 && !int.TryParse(args[2], out block_delay))
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("errmsg_freq_invalid", this, player.Id)));
                return;
            }
            if (frequency < frequency_min || frequency > frequency_max)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("errmsg_freq_bounds", this, player.Id)));
                return;
            }

            // Make sure we are not already listening on that frequency
            if(IsListenerConfigured(frequency))
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.listeners.add_error", this, player.Id), frequency));
                return;
            }

            // Add and save listener for given frequency
            this.config_data.configured_listeners.Add(new ListenerData(frequency, args[1], block_delay));
            Config.WriteObject<RfToolConfig>(this.config_data, true);
            this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.listeners.add_success", this, player.Id), frequency, block_delay, args[1]));
        }

        /*
         * Stop listening on specific frequency and log broadcasts
         */
        [Command("rftool.listeners.del"), Permission("rftool.use")]
        void RfToolListenersDel(IPlayer player, string command, string[] args)
        {
            int frequency = 0;

            // Check command line args
            if (args.Length != 1)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.listeners.del_help", this, player.Id), this.frequency_min, this.frequency_max));
                return;
            }
            if (!int.TryParse(args[0], out frequency))
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("errmsg_freq_invalid", this, player.Id)));
                return;
            }
            if (frequency < frequency_min || frequency > frequency_max)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("errmsg_freq_bounds", this, player.Id)));
                return;
            }

            // Make sure we are listening on that frequency
            if (!IsListenerConfigured(frequency))
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.listeners.del_error", this, player.Id), frequency));
                return;
            }

            // Remove listener for given frequency
            for (int i = 0; i < this.config_data.configured_listeners.Count; i++)
            {
                if (this.config_data.configured_listeners[i].GetFrequency() == frequency)
                {
                    this.config_data.configured_listeners.RemoveAt(i);
                    Config.WriteObject<RfToolConfig>(this.config_data, true);
                    this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.listeners.del_success", this, player.Id), frequency));
                    break;
                }
            }
        }

        /*
         * List all configured listeners
         */
        [Command("rftool.listeners.list"), Permission("rftool.use")]
        void RfToolListenersList(IPlayer player, string command, string[] args)
        {
            // Make sure there are listeners configured
            if(this.config_data.configured_listeners.Count==0)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.listeners.list_error", this, player.Id)));
                return;
            }

            // Show a list of configured listeners
            string reply=string.Format(lang.GetMessage("cmd_rftool.listeners.list_success", this, player.Id), this.config_data.configured_listeners.Count);
            for (int i = 0; i < this.config_data.configured_listeners.Count; i++)
            {
                reply += "\r\n" + this.config_data.configured_listeners[i].GetFrequency().ToString() + " | '" + this.config_data.configured_listeners[i].GetMessage() + "' | " + this.config_data.configured_listeners[i].GetBlockDelay().ToString();
            }
            this.ReplyToPlayer(player, reply);
        }

        /*
         * Change interval time of listener loop
         */
        [Command("rftool.listeners.set_interval"), Permission("rftool.use")]
        void RfToolListenersSetInterval(IPlayer player, string command, string[] args)
        {
            float interval = 0f;

            // Check command line args
            if (args.Length != 1)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.listeners.set_interval_help", this, player.Id)));
                return;
            }
            if (!float.TryParse(args[0], out interval) || interval == 0f)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("errmsg_interval_invalid", this, player.Id)));
                return;
            }

            // Make sure player actually specified a new value
            if(this.config_data.tick_interval == interval)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.listeners.set_interval_error", this, player.Id), this.config_data.tick_interval));
                return;
            }

            // Stop current timer loop
            this.listener_timer.Destroy();

            // Reset current block delay
            this.ResetListenersCurBlockDelay();

            // Change interval and update config file
            this.config_data.tick_interval = interval;
            Config.WriteObject<RfToolConfig>(this.config_data);

            // Start new timer with new interval
            this.listener_timer = timer.Every(this.config_data.tick_interval, this.CheckListeners);

            this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.listeners.set_interval_success", this, player.Id), interval));
        }

        /*
         * Get interval time of listener loop
         */
        [Command("rftool.listeners.get_interval"), Permission("rftool.use")]
        void RfToolListenersGetInterval(IPlayer player, string command, string[] args)
        {
            this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.listeners.get_interval_success", this, player.Id), this.config_data.tick_interval));
        }

        [Command("rftool.debug"), Permission("rftool.use")]
        void RfToolDebug(IPlayer player, string command, string[] args)
        {
            // Toggle debugging
            this.config_data.debug = !this.config_data.debug;

            if(this.config_data.debug)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.debug_enabled", this, player.Id)));
            }
            else
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("cmd_rftool.debug_disabled", this, player.Id)));
            }
        }
        #endregion

        #region Listener Callback
        /*
         * Callback function getting called by the listener loop timer
         */
        private void CheckListeners()
        {
            this.LogDebug(lang.GetMessage("debug_checklisteners", this, ""));

            // Iterate over every configured listener
            for (int i = 0; i < this.config_data.configured_listeners.Count; i++)
            {
                // Make sure listener is currently not blocked
                if (!this.config_data.configured_listeners[i].IsBlocked())
                {
                    // Check if broadcasters on the listeners configured frequency are currently active
                    var broadcasters = RFManager.GetBroadcasterList(this.config_data.configured_listeners[i].GetFrequency());
                    if (broadcasters.Count > 0)
                    {
                        this.Log(this.config_data.configured_listeners[i].GetMessage());
                        // Enable blocking for next loop(s) if configured
                        this.config_data.configured_listeners[i].EnableBlocking();
                    }
                }
                else
                {
                    this.LogDebug(string.Format(lang.GetMessage("debug_listenerblocked", this, ""), this.config_data.configured_listeners[i].GetFrequency()));
                }
            }
        }
        #endregion

        #region Helper Functions
        /*
         * Helper function to parse and check a given frequency
         */
        private int GetFrequency(IPlayer player, string[] args)
        {
            // Check if player specified a correct frequency
            int frequency;
            if (!int.TryParse(args[0], out frequency))
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("errmsg_freq_invalid", this, player.Id)));
                return 0;
            }

            // Make sure frequency is valid
            if (frequency < frequency_min || frequency > frequency_max)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("errmsg_freq_bounds", this, player.Id)));
                return 0;
            }

            return frequency;
        }

        /*
         * Helper function to check if a listener for a certain frequency has already been configured
         */
        private bool IsListenerConfigured(int frequency)
        {
            for(int i = 0; i < this.config_data.configured_listeners.Count; i++)
            {
                if (this.config_data.configured_listeners[i].GetFrequency() == frequency) return true;
            }
            return false;
        }

        /*
         * Helper function to reset all configured listeners current block delay
         */
        private void ResetListenersCurBlockDelay()
        {
            // All configured listeners shall be unblocked
            for (int i = 0; i < this.config_data.configured_listeners.Count; i++)
            {
                this.config_data.configured_listeners[i].DisableBlocking();
            }
        }

        /*
         * Helper functions to send messages to players / console
         */
        private void ReplyToPlayer(IPlayer player, string msg)
        {
            player.Reply(msg);
        }
        private void Log(string msg)
        {
            Puts(msg);
        }
        private void LogDebug(string msg)
        {
            if(this.config_data.debug)
            {
                this.Log("DEBUG :: " + msg);
            }
        }
        #endregion
    }
}


// --- End of file: RfTool.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rc-identifier-fix ---
// --- Original File Path: R/RCIdentifierFix/RCIdentifierFix.cs ---

﻿using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("RC Identifier Fix", "WhiteThunder", "1.0.0")]
    [Description("Automatically updates saved RC identifiers in computer stations after an entity is destroyed and the ID is reused.")]
    internal class RCIdentifierFix : CovalencePlugin
    {
        #region Hooks

        private void OnEntityMounted(ComputerStation computerStation, BasePlayer player)
        {
            if (computerStation.controlBookmarks.IsEmpty())
                return;

            var bookmarkModifications = new Dictionary<string, uint>();

            foreach (var entry in computerStation.controlBookmarks)
            {
                var bookmarkName = entry.Key;
                var cachedEntityId = entry.Value;

                BaseEntity entityWithRCIdentifier;
                var controllable = FindControllable(bookmarkName, cachedEntityId, out entityWithRCIdentifier);
                if (controllable == null && entityWithRCIdentifier != null)
                    bookmarkModifications[bookmarkName] = entityWithRCIdentifier.net.ID;
            }

            // Performing modifications outside of the above foreach to avoid InvalidOperationException errors.
            foreach (var entry in bookmarkModifications)
                computerStation.controlBookmarks[entry.Key] = entry.Value;
        }

        #endregion

        #region Helper Methods

        private BaseEntity FindControllable(string bookmarkName, uint cachedEntityId, out BaseEntity entityWithRCIdentifier)
        {
            entityWithRCIdentifier = null;

            foreach (var controllable in RemoteControlEntity.allControllables)
            {
                var entity = controllable.GetEnt();
                if (entity == null)
                    continue;

                if (entity.net.ID == cachedEntityId)
                    return entity;

                if (ReferenceEquals(entityWithRCIdentifier, null) && controllable.GetIdentifier() == bookmarkName)
                    entityWithRCIdentifier = entity;
            }

            return null;
        }

        #endregion
    }
}


// --- End of file: RCIdentifierFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/random-deployables ---
// --- Original File Path: R/RandomDeployables/RandomDeployables.cs ---

﻿//#define DEBUG
#define MORE_SKIN

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Random Deployables", "Norn/Arainrr", "1.1.0", ResourceId = 2187)]
    [Description("Randomize deployable skins")]
    public class RandomDeployables : RustPlugin
    {
        #region Fields

        private const string PERMISSION_USE = "randomdeployables.use";
        private readonly Hash<string, List<ulong>> itemSkins = new Hash<string, List<ulong>>();
        private readonly Dictionary<string, string> deployed2Item = new Dictionary<string, string>();
        private readonly Dictionary<string, List<ulong>> approvedSkins = new Dictionary<string, List<ulong>>();

        #endregion Fields

        #region Oxide Hooks

        private void Init() => permission.RegisterPermission(PERMISSION_USE, this);

        private void OnServerInitialized()
        {
            FindApprovedSkins();
            bool changed = false;
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                var deployablePrefab = itemDefinition.GetComponent<ItemModDeployable>()?.entityPrefab?.resourcePath;
                if (!string.IsNullOrEmpty(deployablePrefab) && !deployed2Item.ContainsKey(deployablePrefab))
                {
                    deployed2Item.Add(deployablePrefab, itemDefinition.shortname);
                    if (!configData.blockItems.Contains(itemDefinition.shortname))
                    {
                        var skins = new HashSet<ulong>(GetItemSkins(itemDefinition)).ToList();
                        if (skins.Count > 0)
                        {
                            if (!configData.customSkins.ContainsKey(itemDefinition.shortname))
                            {
                                changed = true;
                                configData.customSkins.Add(itemDefinition.shortname, new List<ulong>());
                            }
                            skins.RemoveAll(skin => configData.blockSkins.Contains(skin) || skin == 0);
                            if (configData.defaultSkin)
                            {
                                skins.Add(0);
                            }
                            itemSkins[itemDefinition.shortname] = skins;
                        }
                    }
                }
            }

            if (changed)
            {
                SaveConfig();
            }
#if DEBUG
            Interface.Oxide.DataFileSystem.WriteObject(Name, itemSkins);
#endif
        }

        private void OnEntityBuilt(Planner planner, GameObject obj)
        {
            var entity = obj?.ToBaseEntity();
            if (entity == null) return;
            var player = planner?.GetOwnerPlayer();
            if (player == null) return;
            if (configData.blockRandom && entity.skinID != 0)
            {
                return;
            }
            string shortName;
            if (deployed2Item.TryGetValue(entity.PrefabName, out shortName))
            {
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
                {
                    List<ulong> skins;
                    if (itemSkins.TryGetValue(shortName, out skins))
                    {
                        entity.skinID = skins.GetRandom();
                        entity.SendNetworkUpdate();
                    }
                }
            }
        }

        #endregion Oxide Hooks

        #region Methods

        private void FindApprovedSkins()
        {
            foreach (var skinInfo in Rust.Workshop.Approved.All.Values)
            {
                List<ulong> skins;
                var shortName = skinInfo.Skinnable.ItemName == "lr300.item" ? "rifle.lr300" : skinInfo.Skinnable.ItemName;
                if (!approvedSkins.TryGetValue(shortName, out skins))
                {
                    skins = new List<ulong>();
                    approvedSkins.Add(shortName, skins);
                }
                skins.Add(skinInfo.WorkshopdId);
            }
        }

        private IEnumerable<ulong> GetItemSkins(ItemDefinition itemDefinition)
        {
            if (itemDefinition.skins?.Length > 0)
            {
                foreach (var skin in itemDefinition.skins)
                {
                    yield return (ulong)skin.id;
                }
            }

#if MORE_SKIN

            if (itemDefinition.skins2?.Length > 0)
            {
                foreach (var skin in itemDefinition.skins2)
                {
                    yield return skin.WorkshopDownload;
                }
            }

#endif

            List<ulong> skins;
            if (approvedSkins.TryGetValue(itemDefinition.shortname, out skins))
            {
                foreach (var skin in skins)
                {
                    yield return skin;
                }
            }

            if (configData.customSkins.TryGetValue(itemDefinition.shortname, out skins))
            {
                foreach (var skin in skins)
                {
                    yield return skin;
                }
            }
        }

        #endregion Methods

        #region Commands

        [ConsoleCommand("rd.skins")]
        private void CmdOutputSkins()
        {
            Dictionary<string, HashSet<ulong>> allSkins = new Dictionary<string, HashSet<ulong>>();
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                var skins = new HashSet<ulong>(GetItemSkins(itemDefinition));
                if (skins.Count > 0)
                {
                    skins.RemoveWhere(x => x == 0);
                    allSkins.TryAdd(itemDefinition.shortname, skins);
                }
            }
            Interface.Oxide.DataFileSystem.WriteObject(Name, allSkins);
        }

        #endregion Commands

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Allow default skin")]
            public bool defaultSkin = false;

            [JsonProperty(PropertyName = "If the item has skin, block random skin")]
            public bool blockRandom = true;

            [JsonProperty(PropertyName = "Block item list (item short name)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> blockItems = new List<string> { "item short name" };

            [JsonProperty(PropertyName = "Block skin list (item skin id)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> blockSkins = new List<ulong> { 492800372 };

            [JsonProperty(PropertyName = "Custom skin list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, List<ulong>> customSkins = new Dictionary<string, List<ulong>> { ["door.hinged.metal"] = new List<ulong> { 2465885372 } };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile
    }
}

// --- End of file: RandomDeployables.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ragnarok ---
// --- Original File Path: R/Ragnarok/Ragnarok.cs ---

using System;
using UnityEngine;
using System.Linq;  //ToList
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Ragnarok", "BuzZ", "1.0.1")]
    [Description("A barrage of meteors and crappy weather")]
/*======================================================================================================================= 
*   26th december 2018
*   chat commands : 
*   original authors of this plugin : Drefetr et Shmitt
*
*   1.0.0   20181227    with new maintainer, new changes : added MapMarkers(can change rate to show more/less explosions) + HUD with permission + Removed from OnTick +
*                       permission.admin => /ragna_start + /ragna_stop + /ragna_timer = new possibilities to start/stop or launch on timer settings
*                       /ragna no need permission to see if Ragnarok is On or not. + changed config file to be more readable
*   1.0.1   20190209    added console commands ragna_start ragna_stop ragna_timer + weather in config % + changed ragnarok spawn locations
*
*=======================================================================================================================*/
    class Ragnarok : RustPlugin
    {

#region SETTINGS & VARIABLES
        bool debug = false;
        bool RagnarokIsOn;
        private bool ConfigChanged;

		const string RagnarokHUD = "ragnarok.hud"; 
		const string RagnarokAdmin = "ragnarok.admin"; 
        string ONRagnarokHUD;
		Timer RagnaTimer;
		Timer RagnaEndTimer;
		Timer RagnaMeteorTimer;
        float MarkerRate = 10f;
        bool MarkersIsOn;

    // Minimum clockwise angular deviation from the normal vector;
    // Where 0.0f is 0 rad, and 1.0f is 1/2 rad. 
        float minLaunchAngle = 0.25f;// (0.0f, ..., maxLaunchAngle).
    // Maximum clockwise angular deviation from the normal vector;
    // Where 0.0f is 0 rad, and 1.0f is 1/2 rad.
        float maxLaunchAngle = 0.5f;    // (minLaunchAngle, ..., 1.0f)
    // Minimum launch height (m); suggested sensible bounds:
    // x >= 1 * maxLaunchVelocity.
        float minLaunchHeight = 100.0f;
    // Maximum launch height (m); suggested sensible bounds:
    // x <= 10*minLaunchVelocity.
        float maxLaunchHeight = 250.0f;
    //Minimum launch velocity (m/s^-1).
        float minLaunchVelocity = 25.0f;
    // Maximum launch velocity (m/s^-1).
    // Suggested sensible maximum: 75.0f.
        float maxLaunchVelocity = 75.0f;
    //Seconds between Meteor(s) launch
        float meteorFrequency = 2f;
    //Maximum number of Meteors per cluster
        int maxClusterMeteors = 5;
    //The minimum range (+/- x, & +/- z) of a Meteor cluster
        int minClusterRange = 1;
    // The maximum range (+/- x, & +/- z) of a Meteor clutser.
        int maxClusterRange = 5;
    // Percent chance of the Meteor dropping loose resources at the point of impact.
        float spawnResourcePercent = 0.05f;
    // Percent chance of the Meteor spawning a resource node at the point of impact.
        float spawnResourceNodePercent = 1.0f;
    // For Timer mode - repeat every X minutes
        float repeater = 15;
    // For Timer mode - duration of Ragnarok in minutes
        float duration = 5;

        double cloud = 80;
        double fog = 80;

#endregion
#region INIT & CONFIG

        void Init()
        {
            LoadVariables();
			permission.RegisterPermission(RagnarokHUD, this);
			permission.RegisterPermission(RagnarokAdmin, this);
        }

        void OnServerInitialized()
        {
            if (duration > repeater)
            {
                PrintWarning("Check your configuration file. Duration is superior to repeat frequency. Change it please.");
            }
        }

        void Unload()
        {
            ConsoleSystem.Run(ConsoleSystem.Option.Server, "weather.clouds 0");
            ConsoleSystem.Run(ConsoleSystem.Option.Server, "weather.fog 0");
            RemoveRagnarokHUD();
        }

    protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            meteorFrequency = Convert.ToSingle(GetConfig("Cluster", "Meteor Launch Frequency in seconds (2 by default)", "2"));
            maxClusterMeteors = Convert.ToInt32(GetConfig("Cluster", "Maximum number of Meteors (5 by default)", "5"));
            minClusterRange = Convert.ToInt32(GetConfig("Cluster Size", "Minimum range of cluster (1 by default)", "1"));
            maxClusterRange = Convert.ToInt32(GetConfig("Cluster Size", "Maximum range of cluster (5 by default)", "5"));
            minLaunchAngle = Convert.ToSingle(GetConfig("Launch Angle", "Minimum (0.25 by default)", "0.25"));
            maxLaunchAngle = Convert.ToSingle(GetConfig("Launch Angle", "Maximum (0.5 by default)", "0.5"));
            minLaunchHeight = Convert.ToSingle(GetConfig("Launch Height", "Minimum (100 by default)", "100"));
            maxLaunchHeight = Convert.ToSingle(GetConfig("Launch Height", "Maximum (250 by default)", "250"));
            minLaunchVelocity = Convert.ToSingle(GetConfig("Launch Velocity", "Minimum (25 by default)", "25"));
            maxLaunchVelocity = Convert.ToSingle(GetConfig("Launch Velocity", "Maximum (75 by default)", "75"));
            spawnResourcePercent = Convert.ToSingle(GetConfig("Resources Loot", "Percent chance of the Meteor dropping (0.05 by default)", "0.05"));
            spawnResourceNodePercent = Convert.ToSingle(GetConfig("Resources Loot", "Percent chance of the Meteor spawning node (1 by default)", "1"));
            repeater = Convert.ToSingle(GetConfig("Timer Settings", "Repeat Ragnarok every (15 by default) minutes", "15"));
            duration = Convert.ToSingle(GetConfig("Timer Settings", "Ragnarok will be there for (5 by default) minutes", "5"));
            cloud = Convert.ToDouble(GetConfig("Meteo Settings", "Cloud value (in percent)", "80"));
            fog = Convert.ToDouble(GetConfig("Meteo Settings", "Fog value (in percent)", "80"));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

#endregion
#region RAGNAROOOOK N ROLL
////////////////////////////////////////////////////////////////////////////////////
        void LaunchDaRagnarokOnDaFace()
        {
            ConsoleSystem.Run(ConsoleSystem.Option.Server, $"weather.clouds {(cloud/100).ToString()}");
            ConsoleSystem.Run(ConsoleSystem.Option.Server, $"weather.fog {(fog/100).ToString()}");
            RagnarokIsOn = true;

            DisplayRagnarokHUD();

            // Fetch a random position, with an altitude of {0}.
            var location = GetRandomMapPosition();
            var clusterSize = UnityEngine.Random.Range(1, maxClusterMeteors);

            RagnaMeteorTimer = timer.Every(meteorFrequency, () =>
            {
                for (var i = 0; i < clusterSize; i++)
                {
                    var r = UnityEngine.Random.Range(0.0f, 100.0f);

                    // Add a (slight) degree of randomness to the launch position(s):
                    location.x += UnityEngine.Random.Range(minClusterRange, maxClusterRange);
                    location.z += UnityEngine.Random.Range(minClusterRange, maxClusterRange);

                    if (r < spawnResourcePercent)
                        // Spawn a loose resource:
                        SpawnResource(location);

                    if (r < spawnResourceNodePercent)
                        // Spawn a resource node:
                        SpawnResourceNode(location);

                    SpawnMeteor(location);
                }
		    });
        }
#endregion
#region CHAT & CONSOLE COMMANDS
////////////////////////
// CHAT & CONSOLE COMMANDS
//////////////////////////
        [ChatCommand("ragna")]
        private void RagnarokEmptyChatCommand(BasePlayer player, string command, string[] args)
        {        
            SendReply(player, $"Ragnarok is {RagnarokIsOn}");
        }
//////////////////////
// CHAT START
//////////////////////
        [ChatCommand("ragna_start")]
        private void StartThisRagnarokBabeChatCommand(BasePlayer player, string command, string[] args)
        {        
            bool isadmin = permission.UserHasPermission(player.UserIDString, RagnarokAdmin);

            if (!isadmin)
            {
                SendReply(player, $"You don't have permission for this.");
                return;
            }
            else
            {
                if (!RagnarokIsOn)
                {
                    StartThisRagnarokBabe();
                    SendReply(player, $"Ragnarok has started !");
                }
                else SendReply(player, $"Ragnarok is already On.");
            }
        }

//////////////////////
// CONSOLE START
//////////////////////
        [ConsoleCommand("ragna_start")]
        private void StartThisRagnarokBabeConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (!RagnarokIsOn) StartThisRagnarokBabe();
        }

//////////////////////
// CHAT TIMER LAUNCH
//////////////////////   
        [ChatCommand("ragna_timer")]
        private void GetThisRagnarokBabeOnTimerChatCommand(BasePlayer player, string command, string[] args)
        {
            bool isadmin = permission.UserHasPermission(player.UserIDString, RagnarokAdmin);
            if (!isadmin)
            {
                SendReply(player, $"You don't have permission for this.");
                return;
            }
            StopThisRagnarokBabeChatCommand(player, null, null);
            float repeaterseconds = repeater*60;
            // For Timer mode - duration of Ragnarok in minutes
            float durationseconds = duration*60;
            StartThisRagnarokBabeChatCommand(player, null, null);
            RagnaEndTimer = timer.Every(durationseconds, () =>
            {
                StopThisRagnarokBabe();
            });
            RagnaTimer = timer.Every(repeaterseconds, () =>
            {
                StartThisRagnarokBabe();
            });
            RagnarokIsOn = true;
            SendReply(player, $"Ragnarok has started on timer.\nWill repeat every {repeater} minutes, for {duration} minutes.");

        }
//////////////////////
// CONSOLE TIMER LAUNCH
//////////////////////   
        [ConsoleCommand("ragna_timer")]
        private void GetThisRagnarokBabeOnTimerConsoleCommand(ConsoleSystem.Arg arg)
        {
            StopThisRagnarokBabeConsoleCommand(null);
            float repeaterseconds = repeater*60;
            // For Timer mode - duration of Ragnarok in minutes
            float durationseconds = duration*60;
            StartThisRagnarokBabeConsoleCommand(null);
            RagnaEndTimer = timer.Every(durationseconds, () =>
            {
                StopThisRagnarokBabe();
            });
            RagnaTimer = timer.Every(repeaterseconds, () =>
            {
                StartThisRagnarokBabe();
            });
            RagnarokIsOn = true;
        }

//////////////////////
// CHAT STOP
//////////////////////

        [ChatCommand("ragna_stop")]
        private void StopThisRagnarokBabeChatCommand(BasePlayer player, string command, string[] args)
        {
            bool isadmin = permission.UserHasPermission(player.UserIDString, RagnarokAdmin);
            if (!isadmin)
            {
                SendReply(player, $"You don't have permission for this.");
                return;
            }
            if (RagnarokIsOn)
            {
                if (RagnaEndTimer != null) RagnaEndTimer.Destroy();
                if (RagnaTimer != null ) RagnaTimer.Destroy();
                StopThisRagnarokBabe();
                SendReply(player, $"Ragnarok has stopped.");
            }
            else SendReply(player, $"Ragnarok is already Off.");
        }
//////////////////
// CONSOLE STOP
//////////////////
        [ConsoleCommand("ragna_stop")]
        private void StopThisRagnarokBabeConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (RagnarokIsOn)
            {
                if (RagnaEndTimer != null) RagnaEndTimer.Destroy();
                if (RagnaTimer != null ) RagnaTimer.Destroy();
                StopThisRagnarokBabe();
            }
        }

//////////////////
// STOP
//////////////
        void StopThisRagnarokBabe()
        {
            if (RagnaMeteorTimer != null) RagnaMeteorTimer.Destroy();
            ConsoleSystem.Run(ConsoleSystem.Option.Server, "weather.clouds 0");
            ConsoleSystem.Run(ConsoleSystem.Option.Server, "weather.fog 0");
            RagnarokIsOn = false;
            RemoveRagnarokHUD();
        }
///////////////
// START
///////////////
        void StartThisRagnarokBabe()
        {
            LaunchDaRagnarokOnDaFace();
        }


/////// change location


/////////// 
#endregion

//////////////////
// PLAYER CONNECTION - if Ragnarok on -> HUD
/////////////////////////


//////////////////
// PLAYER DISCONNECT - kill HUD
/////////////////////////

#region HUD
/////////////////////////
// HUD
//////////////////////////
		void DisplayRagnarokHUD()
		{
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                var CuiElement = new CuiElementContainer();
                ONRagnarokHUD = CuiElement.Add(new CuiPanel{Image ={Color = "0.0 0.0 0.0 0.0"},RectTransform ={AnchorMin = $"0.97 0.70",AnchorMax = $"1.0 0.73"},CursorEnabled = false
                    }, new CuiElement().Parent = "Overlay", ONRagnarokHUD);
                    
                        CuiElement.Add(new CuiElement
                        {
                            Name = CuiHelper.GetGuid(),
                            Parent = ONRagnarokHUD,
                            Components =
                                {
                                    new CuiRawImageComponent {Url = "https://i.ibb.co/m4SCRxc/ragnarok-01.png"},
                                    new CuiRectTransformComponent {AnchorMin = $"0.0 0.0", AnchorMax = $"1.0 1.0"}
                                }
                        });
                bool HUDview = permission.UserHasPermission(player.UserIDString, RagnarokHUD);
                if (HUDview) CuiHelper.AddUi(player, CuiElement);
            }
		}

		void RemoveRagnarokHUD()
		{
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                CuiHelper.DestroyUi(player, ONRagnarokHUD);
            }
		}

#endregion
#region SPAWNS
//////////////////////
// METEOR SPAWN
//////////////////////
        void SpawnMeteor(Vector3 origin)
        {
            var launchAngle = UnityEngine.Random.Range(minLaunchAngle, maxLaunchAngle);
            var launchHeight = UnityEngine.Random.Range(minLaunchHeight, maxLaunchHeight);
            var launchDirection = (Vector3.up * -launchAngle + Vector3.right).normalized;
            var launchPosition = origin - launchDirection * launchHeight;
            var r = UnityEngine.Random.Range(0, 3);
            ItemDefinition projectileItem;
            // Fetch rocket of type <x>:
            switch (r)
            {
                case 0:
                    projectileItem = GetBasicRocket();
                    break;

                case 1:
                    projectileItem = GetHighVelocityRocket();
                    break;

                case 2:
                    projectileItem = GetSmokeRocket();
                    break;

                default:
                    projectileItem = GetFireRocket();
                    break;
            }
            // Create the in-game "Meteor" entity:
            var component = projectileItem.GetComponent<ItemModProjectile>();
            var entity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, launchPosition, new Quaternion(), true);
            if (entity == null)
            {
                if (debug) Puts("entity is NULL !!");
                return;
            }
            // Set Meteor speed:
            var serverProjectile = entity.GetComponent<ServerProjectile>();
            serverProjectile.speed = UnityEngine.Random.Range(minLaunchVelocity, maxLaunchVelocity);
            entity.SendMessage("InitializeVelocity", (object)(launchDirection * 1.0f));
            entity.OwnerID = 666999666999666;
            entity.Spawn();
            GenerateMarkers(launchPosition);
        }

/////////////////////////////////
// METEOR DAMAGE NULLED
////////////


//////////////////////
// RESOURCE SPAWN
//////////////////////
        void SpawnResource(Vector3 location)
        {
            string resourceName;
            int resourceQuantity;
            var r = UnityEngine.Random.Range(0, 3);
            switch (r)
            {
                case 1:
                    resourceName = "hq.metal.ore";
                    resourceQuantity = 100;
                    break;

                case 2:
                    resourceName = "metal.ore";
                    resourceQuantity = 1000;
                    break;

                case 3:
                    resourceName = "stones";
                    resourceQuantity = 2500;
                    break;

                default:
                    resourceName = "sulfur.ore";
                    resourceQuantity = 1000;
                    break;
            }
            ItemManager.CreateByName(resourceName, resourceQuantity).Drop(location, Vector3.up);
        }
//////////////////////
// RESOURCE NODE SPAWN
//////////////////////
        void SpawnResourceNode(Vector3 location)
        {
            var prefabName = "assets/bundled/prefabs/autospawn/resource/ores/";
            var r = UnityEngine.Random.Range(0, 2);
            switch (r)
            {
                case 1:
                    prefabName += "metal-ore";
                    break;

                case 2:
                    prefabName += "stone-ore";
                    break;

                default:
                    prefabName += "sulfur-ore";
                    break;
            }
            prefabName += ".prefab";
            // & spawn the ResourceNode at Vector3(location).
            var resourceNode = GameManager.server.CreateEntity(prefabName, location, new Quaternion(0, 0, 0, 0));
            resourceNode?.Spawn();
        }
#endregion
#region RANDOM ROCKETS
///////////////
// RANDOMIZED ROCKET TYPE - it it useful to separate from void ?
//////////////
        ItemDefinition GetBasicRocket()
        {
            return ItemManager.FindItemDefinition("ammo.rocket.basic");
        }
        ItemDefinition GetFireRocket()
        {
            return ItemManager.FindItemDefinition("ammo.rocket.fire");
        }
        ItemDefinition GetHighVelocityRocket()
        {
            return ItemManager.FindItemDefinition("ammo.rocket.hv");
        }
        ItemDefinition GetSmokeRocket()
        {
            return ItemManager.FindItemDefinition("ammo.rocket.smoke");
        }
#endregion
#region MAP
///////////////
// MAP
//////////////////
        Vector3 GetRandomMapPosition()
        {
//            var mapsize = GetMapSize() - 500f;
            var mapsize = GetMapSize();
            var randomX = UnityEngine.Random.Range(-mapsize, mapsize);
            var randomY = UnityEngine.Random.Range(-mapsize, mapsize);
            return new Vector3(randomX, 0f, randomY);
        }

        float GetMapSize()
        {
            return TerrainMeta.Size.x / 2;
        }

///////////////
// MAPMARKER - EXPLOSION
///////////////////
        void GenerateMarkers(Vector3 position)
		{
            if (!RagnarokIsOn) return;
            if (!MarkersIsOn)
            {
                MarkersIsOn = true;
                MapMarkerExplosion RagnarokMarker = new MapMarkerExplosion();
                RagnarokMarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/explosionmarker.prefab", position) as MapMarkerExplosion;
                if (RagnarokMarker == null) return;
                RagnarokMarker.SetDuration(1);
                RagnarokMarker.Spawn();
                timer.Once(MarkerRate, () =>
                {
                    MarkersIsOn = false;
                });
            }
        }
#endregion
///////////////
// MESSAGE ONLINE PLAYERS
//////////////////
    }
}

// --- End of file: Ragnarok.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/real-bear-traps ---
// --- Original File Path: R/RealBearTraps/RealBearTraps.cs ---

using Facepunch;
using Rust;
using System;
using System.Linq;
using System.Globalization;
using System.Collections.Generic;
using System.Text;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Oxide.Plugins
{
    [Info("Real Bear Traps", "XavierB", "0.0.8")]
	[Description("Makes bear traps actually trap bears")]
	
	public class RealBearTraps : RustPlugin
    {

		static RealBearTraps plugin;
		const string perms = "realbeartraps.auth";

		private bool ConfigChanged;
		private DynamicConfigFile data;
		private StoredData storedData;
		
		// Confiig defaults
		bool TrapTeam = true;
		float TrapDamage = 1000f;
		float TrapRadius = 1f;
		bool TrapBears = true;
		bool TrapChicken = true;
		bool TrapStag = true;
		bool TrapBoar = true;
		bool TrapWolf = true;
		bool Messages = true;

		// Dictionaries and Lists
		private List<ulong> BearTrapList = new List<ulong>();
		
		private class StoredData
        {
            public List<ulong> BearTrapList = new List<ulong>();
		}
		
		
		private void SaveData()
        {
            storedData.BearTrapList = BearTrapList;
			data.WriteObject(storedData);
			PrintWarning(lang.GetMessage("saving", this));
		}
		
		void LoadVariables()
		{
			Messages = Convert.ToBoolean(GetConfig("Chat Settings","Show chat messages?", "true"));
			TrapDamage = Convert.ToSingle(GetConfig("Settings", "Damage delt to animals", "1000"));
			TrapTeam = Convert.ToBoolean(GetConfig("Settings","Team members authed on trap?", "true"));
			TrapRadius = Convert.ToSingle(GetConfig("Settings", "Radius to trigger traps", "1"));
			TrapBears = Convert.ToBoolean(GetConfig("Settings","Can trap bears?", "true"));
			TrapChicken = Convert.ToBoolean(GetConfig("Settings","Can trap chickens?", "true"));
			TrapStag = Convert.ToBoolean(GetConfig("Settings","Can trap stags?", "true"));
			TrapWolf = Convert.ToBoolean(GetConfig("Settings","Can trap wolves?", "true"));
			TrapBoar = Convert.ToBoolean(GetConfig("Settings","Can trap boars?", "true"));
			
			if (ConfigChanged)
			{
				PrintWarning(lang.GetMessage("configchange", this));
				SaveConfig();
			}
			else
			{
				ConfigChanged = false;
				return;
			}
		}
		
		#region Config Reader
		
		private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }
		
		#endregion
		
		protected override void LoadDefaultConfig()
		{
			LoadVariables();
		}
		
		void Init()
		{
			LoadVariables();
			permission.RegisterPermission(perms, this);
			
			plugin = this;
			
			data = Interface.Oxide.DataFileSystem.GetFile(Name);
			
			try
            {
                storedData = data.ReadObject<StoredData>();
				BearTrapList = storedData.BearTrapList;
				}
            catch
            {
                PrintWarning(lang.GetMessage("failedload", this));
                storedData = new StoredData();
            }
		}
		
		private void OnServerSave() => SaveData();
		
		void Unload()
        {
			foreach (var trap in UnityEngine.Object.FindObjectsOfType<BaseTrap>())
            {
				var bearTrap = trap.GetComponent<ColliderCheck>();
				if (bearTrap)
				{
					bearTrap.UnloadComponent();
				}
			}
			
			SaveData();	
			plugin = null;
		}
		
		void OnServerInitialized()
		{
			foreach (var trap in UnityEngine.Object.FindObjectsOfType<BaseTrap>())
            {
				if (BearTrapList.Contains(trap.net.ID))
				{
					trap.gameObject.AddComponent<ColliderCheck>();
				}
			}
		}
		
		private static BasePlayer FindOwner(string nameOrId)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrId)
                    return activePlayer;
                if (activePlayer.displayName.Contains(nameOrId, CompareOptions.OrdinalIgnoreCase))
                    return activePlayer;
            }
			return null;
		}
		
		#region Hooks
		private void OnEntitySpawned(BearTrap trap)
		{
			trap.gameObject.AddComponent<ColliderCheck>();
			var player = FindOwner(trap.OwnerID.ToString());
			if (player == null) return;
			BearTrapList.Add(trap.net.ID);
			if (Messages)
				Player.Message(player, $"{lang.GetMessage("TrapPlaced", this, player.UserIDString)}");
		}
		
		private object OnTrapTrigger(BearTrap trap, GameObject obj)
		{
			BasePlayer target = obj.GetComponent<BasePlayer>();
			
			if (target == null)
				return null;
			
			bool hasPermission = permission.UserHasPermission(target.UserIDString, perms);
			if (!hasPermission)
				return null;
			
			if (target.UserIDString == trap.OwnerID.ToString())
			{
				return true;
			}
			
			if (target.currentTeam != (long)0)
			{
				RelationshipManager.PlayerTeam trapTeam = RelationshipManager.ServerInstance.FindTeam(target.currentTeam);
				if (TrapTeam)
				{
					if (trapTeam.members.Contains(trap.OwnerID))
					{
						return true;
					}
				}
			}
			
			return null;
		}

		private void OnEntityKill(BearTrap trap)
		{
			trap.GetComponent<ColliderCheck>()?.OnKill(trap);
		}
		
		#endregion
		
		#region Behaviour
		
		class ColliderCheck : FacepunchBehaviour
		{
			private BaseTrap trap;
			private BaseCombatEntity targetEnt;
			private float radius;
			
			void Awake()
			{
				trap = GetComponent<BaseTrap>();
				radius = plugin.TrapRadius;
			}
			
			void FixedUpdate()
			{
				if (targetEnt == null && trap.HasFlag(BaseEntity.Flags.On))
				{
					List<BaseNpc> nearby = new List<BaseNpc>();
					Vis.Entities(transform.position, radius, nearby);
					foreach (var e in nearby)
					{
						if (e == null) continue;
						if (e is Bear && !plugin.TrapBears) continue;
						if (e is Stag && !plugin.TrapStag) continue;
						if (e is Wolf && !plugin.TrapWolf) continue;
						if (e is Boar && !plugin.TrapBoar) continue;
						if (e is Chicken && !plugin.TrapChicken) continue;
						targetEnt = e;
					}
				}
				
				if (targetEnt != null)
				{
					var distance = Vector3.Distance(transform.position, targetEnt.transform.position);
					if (distance > radius)
					{
						targetEnt = null;
					}
					else
					{
						trap.SetFlag(BaseEntity.Flags.On, false, false, true);
						trap.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
						targetEnt.Hurt(plugin.TrapDamage);
						targetEnt = null;
					}
				}
			}
	
			internal void OnKill(BearTrap trap)
			{
				if (plugin.BearTrapList.Contains(trap.net.ID))
					plugin.BearTrapList.Remove(trap.net.ID);
			}
			
			public void UnloadComponent()
			{
				Destroy(this);
			}
			
			public void Destroy()
			{
				if (plugin.BearTrapList.Contains(trap.net.ID))
					plugin.BearTrapList.Remove(trap.net.ID);
			}

		}
		
		#endregion
		
		
		#region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
				{"TrapPlaced", "You have placed a BearTrap."},
				{"saving", "Saving..."},
				{"configchange", "Config has changed."},
				{"failedload", "Falied to load, creating new config."},
            }, this, "en");
        }
        #endregion
	}
	
}

// --- End of file: RealBearTraps.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rad-town-loot ---
// --- Original File Path: R/RadTownLoot/RadTownLoot.cs ---

using System;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Facepunch;
using Rust;
using Rust.Ai.Gen2;

namespace Oxide.Plugins
{
    [Info("RadTownLoot", "Krungh Crow", "2.2.2")]
    [Description("Return of Radanimals with animal settings")]

    #region Changelogs and ToDo < 2.0.0
    /**********************************************************************
    * 
    * v1.1.2    :   Changed spawnchance from 0-1 to 0-100 (to make it more clear)
    * v1.1.3    :   Added check if initiator is player or npc
    * v1.1.3    :   Added additional checks
    * v1.1.4    :   Added nullchecks (OnEntityDeath)
    * v1.1.5    :   Fix for wolf NRE
    * v1.1.6    :   Better Null check
    * 
    **********************************************************************/
    #endregion

    #region Changelogs and ToDo > 2.0.0
    /**********************************************************************
    * 
    * 2.0.0     :   Rewrite
    *           :   Optimised Hook Calls
    *           :   Backpacks show animal type
    *           :   Changed permissions
    *           :   Added support for Alpha and Omega animal types
    *           :   Extended internal Debug System
    * 2.1.0     :   Added Boars
    *           :   Added Chickens
    *           :   Added Stags
    *           :   Added Wild Horses
    *           :   Added Animal Type Prefix (lootcontainer title) in cfg
    * 2.2.0     :   Fixed Animal names
    *           :   Fixed Animal Spawn values
    *           :   Updated language file , backup old file and delete
    *           :   Changed /rad animals command info
    *           :   Added radtownloot.admin permission
    *           :   Added /rad admin command with extended cfg info
    * 2.2.1     :   Added support for the new wolf AI (wolf2)
    * 2.2.2     :   Patched for feb 6 rust update
    * 
    **********************************************************************/
    #endregion

    class RadTownLoot : RustPlugin
    {
        [PluginReference]
        Plugin Clans, Friends;

        #region Variables

        string Admin_Perm = "radtownloot.admin";
        string Chat_Perm = "radtownloot.chat";
        string Command_Perm = "radtownloot.command";
        string Loot_Perm = "radtownloot.loot";

        ulong chaticon = 0;
        string prefix;
        string animalprefix;
        bool Debug = false;

        bool IgnoreAlpha;
        bool IgnoreOmega;

        int HealthMin;
        int HealthMax;
        int RandomHealth;
        int DamageMin;
        int DamageMax;
        int RandomDamage;
        float Speed;
        bool ShowConsole = false;
        bool ChangeValues;

        #endregion

        #region Configuration

        void Init()
        {
            if (!LoadConfigVariables())
            {
                Puts($"Config file ({this.Name}.json) issue detected. Please check syntax and fix.");
                return;
            }
            permission.RegisterPermission(Admin_Perm, this);
            permission.RegisterPermission(Chat_Perm, this);
            permission.RegisterPermission(Command_Perm, this);
            permission.RegisterPermission(Loot_Perm, this);

            Debug = configData.PlugCFG.Debug;
            IgnoreAlpha = configData.Animals.IgnoreAlpha;
            IgnoreOmega = configData.Animals.IgnoreOmega;
            prefix = configData.PlugCFG.Prefix;
            animalprefix = configData.PlugCFG.AnimalPrefix;
            chaticon = configData.PlugCFG.Chaticon;
            if (Debug) Puts($"[Debug]  Debug for [{this.Name}] is active if unintentional change cfg and reload");
        }

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Main config")]
            public SettingsPlugin PlugCFG = new SettingsPlugin();
            [JsonProperty(PropertyName = "Animal config")]
            public SettingsAnimals Animals = new SettingsAnimals();
        }

        class SettingsPlugin
        {
            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;
            [JsonProperty(PropertyName = "Chat Steam64ID")]
            public ulong Chaticon = 0;
            [JsonProperty(PropertyName = "Chat Prefix")]
            public string Prefix = "[<color=orange>RadTownLoot</color>] : ";
            [JsonProperty(PropertyName = "Animal Type Prefix")]
            public string AnimalPrefix = "Radtown ";
            [JsonProperty(PropertyName = "Use Random Skins")]
            public bool RandomSkins = false;
        }

        class SettingsAnimals
        {
            [JsonProperty(PropertyName = "Skip Alpha Animals")]
            public bool IgnoreAlpha = true;
            [JsonProperty(PropertyName = "Skip Omega Animals")]
            public bool IgnoreOmega = true;
            [JsonProperty(PropertyName = "Bear settings")]
            public Spawns BearSpawns = new Spawns();
            [JsonProperty(PropertyName = "Boar settings")]
            public Spawns BoarSpawns = new Spawns();
            [JsonProperty(PropertyName = "Chicken settings")]
            public Spawns ChickenSpawns = new Spawns();
            [JsonProperty(PropertyName = "Polarbear settings")]
            public Spawns PBearSpawns = new Spawns();
            [JsonProperty(PropertyName = "Stag settings")]
            public Spawns StagSpawns = new Spawns();
            [JsonProperty(PropertyName = "Wolf settings")]
            public Spawns WolfSpawns = new Spawns();
        }

        class Spawns
        {
            [JsonProperty(PropertyName = "Change stats on spawns")]
            public bool Change = false;
            [JsonProperty(PropertyName = "Show spawns in Console")]
            public bool ShowConsole = false;
            [JsonProperty(PropertyName = "Droprate 0-100")]
            public float ChanceOfCrate = 10.0f;
            [JsonProperty(PropertyName = "Minimum Health")]
            public int Healthmin = 150;
            [JsonProperty(PropertyName = "Maximum Health")]
            public int Healthmax = 250;
            [JsonProperty(PropertyName = "Minimum Strength (Att dmg)")]
            public int Damage = 20;
            [JsonProperty(PropertyName = "Maximum Strength (Att dmg")]
            public int DamageMax = 25;
            [JsonProperty(PropertyName = "Running Speed")]
            public float Speed = 6f;
            [JsonProperty(PropertyName = "Loot settings")]
            public LootSettings Loots = new LootSettings();
        }

        class LootSettings
        {
            [JsonProperty(PropertyName = "Spawn Min Amount Items")]
            public int MinAmount = 1;
            [JsonProperty(PropertyName = "Spawn Max Amount Items")]
            public int MaxAmount = 3;
            [JsonProperty(PropertyName = "Loot Table", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<LootItems> Loot { get; set; } = DefaultLoot;
        }

        private bool LoadConfigVariables()
        {
            try { configData = Config.ReadObject<ConfigData>(); }
            catch { return false; }
            SaveConf();
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Fresh install detected Creating a new config file.");
            configData = new ConfigData();
            SaveConf();
        }
        void SaveConf() => Config.WriteObject(configData, true);

        #endregion

        #region LanguageAPI

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Info"] = "Animals can drop backpacks like in Legacy Rust.\n\n",
                ["AdminInfo"] = "If Change stats on spawn is false values are not changed by this plugin.\n\n",
                ["InvalidInput"] = "Please enter a valid command!",
                ["NoPermission"] = "You do not have permission to use that command!",
                ["RadTownLoot"] = "The {0} dropped something!",
            }, this);
        }

        #endregion

        #region Commands

        [ChatCommand("rad")]
        private void cmdRad(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player, Command_Perm))
            {
                Player.Message(player, msg("NoPermission", player.UserIDString), chaticon);
                if (Debug) Puts($"[Debug] {player} had no permission for using Commands");
                return;
            }
            if (args.Length == 0) Player.Message(player, msg("InvalidInput", player.UserIDString), chaticon);
            else
            {
                if (args[0].ToLower() == "admin")
                {
                    if (!HasPerm(player, Admin_Perm))
                    {
                        Player.Message(player, msg("NoPermission", player.UserIDString), chaticon);
                        if (Debug) Puts($"[Debug] {player} had no permission for using the /rad admin command.");
                        return;
                    }
                    Player.Message(player, string.Format(msg("AdminInfo", player.UserIDString))
                    //Bear Info
                    + info("<color=orange>Bear</color> : Pop <color=purple>") + Bear.Population.ToString() + info("</color> ")
                    + info("Health <color=green>") + configData.Animals.BearSpawns.Healthmin.ToString() + info("</color>/<color=red>") + configData.Animals.BearSpawns.Healthmax.ToString() + info("</color>")
                    + info($" Alive <color=green> {AnimalCount("Bear")}</color> ")
                    + info($"\nChange stats on spawns : <color=green>{configData.Animals.BearSpawns.Change}</color>\n")
                    + info($"Droprate 0-100 : <color=green>{configData.Animals.BearSpawns.ChanceOfCrate}</color>%\n")
                    + info($"Max items : <color=green>{configData.Animals.BearSpawns.Loots.MaxAmount}</color>\n")

                    //Polarbear info
                    + info("\n<color=orange>Polarbear</color> : Pop <color=purple>") + Polarbear.Population.ToString() + info("</color> ")
                    + info($"Health <color=green> {configData.Animals.PBearSpawns.Healthmin.ToString()}</color>/<color=red>{configData.Animals.PBearSpawns.Healthmax.ToString()}</color>")
                    + info($" Alive <color=green> {AnimalCount("Polarbear")}</color> ")
                    + info($"\nChange stats on spawns : <color=green>{configData.Animals.PBearSpawns.Change}</color>\n")
                    + info($"Droprate 0-100 : <color=green>{configData.Animals.PBearSpawns.ChanceOfCrate}</color>%\n")
                    + info($"Max items : <color=green>{configData.Animals.BearSpawns.Loots.MaxAmount}</color>\n")

                    //Wolf Info
                    + info("\n<color=orange>Wolf</color> : Pop <color=purple>") + Wolf.Population.ToString() + info("</color> ")
                    + info($"Health <color=green> {configData.Animals.WolfSpawns.Healthmin.ToString()}</color>/<color=red>{configData.Animals.WolfSpawns.Healthmax.ToString()}</color>")
                    + info($" Alive <color=green> {AnimalCount("Wolf")}</color> ")
                    + info($"\nChange stats on spawns : <color=green>{configData.Animals.WolfSpawns.Change}</color>\n")
                    + info($"Droprate 0-100 : <color=green>{configData.Animals.WolfSpawns.ChanceOfCrate}</color>%\n")
                    + info($"Max items : <color=green>{configData.Animals.WolfSpawns.Loots.MaxAmount}</color>\n")

                    //Boar info
                    + info("\n<color=orange>Boar</color> : Pop <color=purple>") + Boar.Population.ToString() + info("</color> ")
                    + info($"Health <color=green> {configData.Animals.BoarSpawns.Healthmin.ToString()}</color>/<color=red>{configData.Animals.BoarSpawns.Healthmax.ToString()}</color>")
                    + info($" Alive <color=green> {AnimalCount("Boar")}</color> ")
                    + info($"\nChange stats on spawns : <color=green>{configData.Animals.BoarSpawns.Change}</color>\n")
                    + info($"Droprate 0-100 : <color=green>{configData.Animals.BoarSpawns.ChanceOfCrate}</color>%\n")
                    + info($"Max items : <color=green>{configData.Animals.BoarSpawns.Loots.MaxAmount}</color>\n")

                    //Chicken info
                    + info("\n<color=orange>Chicken</color> : Pop <color=purple>") + Chicken.Population.ToString() + info("</color> ")
                    + info($"Health <color=green> {configData.Animals.ChickenSpawns.Healthmin.ToString()}</color>/<color=red>{configData.Animals.ChickenSpawns.Healthmax.ToString()}</color>")
                    + info($" Alive <color=green> {AnimalCount("Chicken")}</color> ")
                    + info($"\nChange stats on spawns : <color=green>{configData.Animals.ChickenSpawns.Change}</color>\n")
                    + info($"Droprate 0-100 : <color=green>{configData.Animals.ChickenSpawns.ChanceOfCrate}</color>%\n")
                    + info($"Max items : <color=green>{configData.Animals.ChickenSpawns.Loots.MaxAmount}</color>\n")

                    //Stag info
                    + info("\n<color=orange>Stag</color> : Pop <color=purple>") + Stag.Population.ToString() + info("</color> ")
                    + info($"Health <color=green> {configData.Animals.StagSpawns.Healthmin.ToString()}</color>/<color=red>{configData.Animals.StagSpawns.Healthmax.ToString()}</color>")
                    + info($" Alive <color=green> {AnimalCount("Stag")}</color> ")
                    + info($"\nChange stats on spawns : <color=green>{configData.Animals.StagSpawns.Change}</color>\n")
                    + info($"Droprate 0-100 : <color=green>{configData.Animals.StagSpawns.ChanceOfCrate}</color>%\n")
                    + info($"Max items : <color=green>{configData.Animals.StagSpawns.Loots.MaxAmount}</color>")
                    , chaticon);
                    return;
                }
                if (args[0].ToLower() == "animals")
                {
                    Player.Message(player, string.Format(msg("Info", player.UserIDString))
                    //Bear Info
                    + info("<color=orange>Bears</color>") + info($" : <color=green> {AnimalCount("Bear")}</color> ")
                    //Polarbear info
                    + info("\n<color=orange>Polarbears</color>") + info($" : <color=green> {AnimalCount("Polarbear")}</color> ")
                    //Wolf Info
                    + info("\n<color=orange>Wolves</color>") + info($" : <color=green> {AnimalCount("Wolf")}</color> ")
                    //Boar info
                    + info("\n<color=orange>Boars</color>") + info($" : <color=green> {AnimalCount("Boar")}</color> ")
                    //Chicken info
                    + info("\n<color=orange>Chickens</color>") + info($" : <color=green> {AnimalCount("Chicken")}</color> ")
                    //Stag info
                    + info("\n<color=orange>Stags</color>") + info($" : <color=green> {AnimalCount("Stag")}</color> ")
                    , chaticon);
                    return;
                }

                Player.Message(player, msg("InvalidInput", player.UserIDString), chaticon);
            }
        }
        #endregion

        #region Message helpers

        private string msg(string key, string id = null) => prefix + lang.GetMessage(key, this, id);

        private string info(string key, string id = null) => lang.GetMessage(key, this, id);

        void TIP(BasePlayer player, string message, float dur)
        {
            if (player == null) return;
            string msg = info(message);//takes the message from languagefile
            player.SendConsoleCommand("gametip.showgametip", msg);
            timer.Once(dur, () => player?.SendConsoleCommand("gametip.hidegametip"));
        }

        #endregion

        #region Oxide Hooks

        void OnEntityDeath(BaseNPC2 animal , HitInfo info)
        {
            if (animal == null || info == null) return;
            if ((animal.name.Contains("Alpha") && IgnoreAlpha) || (animal.name.Contains("Omega") && IgnoreOmega))
            {
                if (Debug) Puts($"Skipping triggers for {animal.name}");
                return;
            }
            BasePlayer attacker = info.InitiatorPlayer;
            if (attacker == null) return;
            var wolfrate = configData.Animals.WolfSpawns.ChanceOfCrate;

            if (animal is Wolf2 && (HasPerm(attacker , Loot_Perm)))
            {
                if (wolfrate <= 0f || UnityEngine.Random.value > wolfrate / 100)
                {
                    if (Debug) Puts("wolfrate was not the random value skipping loot");
                    return;
                }

                SpawnRadLoot(animal.transform.position + new Vector3(0f , 0.5f , 0f) , animal.transform.rotation , "Wolf");
                {
                    if (HasPerm(attacker , Chat_Perm)) Player.Message(attacker , string.Format(msg("RadTownLoot" , attacker.UserIDString) , "wolf") , chaticon);
                    LogToFile("RadTownKills" , $"{DateTime.Now:h:mm:ss tt}] {attacker} killed a {animal.name} and loot was dropped" , this);
                }
            }
        }

        void OnEntityDeath(BaseAnimalNPC animal, HitInfo info)
        {
            if (animal == null || info == null) return;
            if ((animal.name.Contains("Alpha") && IgnoreAlpha) || (animal.name.Contains("Omega") && IgnoreOmega))
            {
                if (Debug) Puts($"Skipping triggers for {animal.name}");
                return;
            }

            BasePlayer attacker = info.InitiatorPlayer;
            if (attacker == null) return;
            var wolfrate = configData.Animals.WolfSpawns.ChanceOfCrate;
            var bearrate = configData.Animals.BearSpawns.ChanceOfCrate;
            var boarrate = configData.Animals.BoarSpawns.ChanceOfCrate;
            var chickenrate = configData.Animals.ChickenSpawns.ChanceOfCrate;
            var stagrate = configData.Animals.StagSpawns.ChanceOfCrate;
            var pbearrate = configData.Animals.PBearSpawns.ChanceOfCrate;


            if (animal is Wolf && (HasPerm(attacker, Loot_Perm)))
            {
                if (wolfrate <= 0f || UnityEngine.Random.value > wolfrate / 100)
                {
                    if (Debug) Puts("wolfrate was not the random value skipping loot");
                    return;
                }

                SpawnRadLoot(animal.transform.position + new Vector3(0f, 0.5f, 0f), animal.transform.rotation, "Wolf");
                {
                    if (HasPerm(attacker, Chat_Perm)) Player.Message(attacker, string.Format(msg("RadTownLoot", attacker.UserIDString), animal.name), chaticon);
                    LogToFile("RadTownKills", $"{DateTime.Now:h:mm:ss tt}] {attacker} killed a {animal.name} and loot was dropped", this);
                }
            }
            if (animal is Bear && (HasPerm(attacker, Loot_Perm)))
            {
                if (bearrate <= 0f || UnityEngine.Random.value > bearrate / 100)
                {
                    if (Debug) Puts("bearrate was not the random value skipping loot");
                    return;
                }

                SpawnRadLoot(animal.transform.position + new Vector3(0f, 0.5f, 0f), animal.transform.rotation, "Bear");
                {
                    if (HasPerm(attacker, Chat_Perm)) Player.Message(attacker, string.Format(msg("RadTownLoot", attacker.UserIDString), animal.name), chaticon);
                    LogToFile("RadTownKills", $"{DateTime.Now:h:mm:ss tt}] {attacker} killed a {animal.name} and loot was dropped", this);
                }
            }
            if (animal is Boar && (HasPerm(attacker, Loot_Perm)))
            {
                if (boarrate <= 0f || UnityEngine.Random.value > boarrate / 100)
                {
                    if (Debug) Puts("boarrate was not the random value skipping loot");
                    return;
                }

                SpawnRadLoot(animal.transform.position + new Vector3(0f, 0.5f, 0f), animal.transform.rotation, "Boar");
                {
                    if (HasPerm(attacker, Chat_Perm)) Player.Message(attacker, string.Format(msg("RadTownLoot", attacker.UserIDString), "Boar"), chaticon);
                    LogToFile("RadTownKills", $"{DateTime.Now:h:mm:ss tt}] {attacker} killed a Boar and loot was dropped", this);
                }
            }
            if (animal is Chicken && (HasPerm(attacker, Loot_Perm)))
            {
                if (chickenrate <= 0f || UnityEngine.Random.value > chickenrate / 100)
                {
                    if (Debug) Puts("chickenrate was not the random value skipping loot");
                    return;
                }

                SpawnRadLoot(animal.transform.position + new Vector3(0f, 0.5f, 0f), animal.transform.rotation, "Chicken");
                {
                    if (HasPerm(attacker, Chat_Perm)) Player.Message(attacker, string.Format(msg("RadTownLoot", attacker.UserIDString), animal.name), chaticon);
                    LogToFile("RadTownKills", $"{DateTime.Now:h:mm:ss tt}] {attacker} killed a {animal.name} and loot was dropped", this);
                }
            }
            if (animal is Stag && (HasPerm(attacker, Loot_Perm)))
            {
                if (stagrate <= 0f || UnityEngine.Random.value > stagrate / 100)
                {
                    if (Debug) Puts("stagrate was not the random value skipping loot");
                    return;
                }

                SpawnRadLoot(animal.transform.position + new Vector3(0f, 0.5f, 0f), animal.transform.rotation, "Stag");
                {
                    if (HasPerm(attacker, Chat_Perm)) Player.Message(attacker, string.Format(msg("RadTownLoot", attacker.UserIDString), animal.name), chaticon);
                    LogToFile("RadTownKills", $"{DateTime.Now:h:mm:ss tt}] {attacker} killed a {animal.name} and loot was dropped", this);
                }
            }
            if (animal is Polarbear && (HasPerm(attacker, Loot_Perm)))
            {
                if (bearrate <= 0f || UnityEngine.Random.value > pbearrate / 100)
                {
                    if (Debug) Puts("polarbearrate was not the random value skipping loot");
                    return;
                }

                SpawnRadLoot(animal.transform.position + new Vector3(0f, 0.5f, 0f), animal.transform.rotation, "Polarbear");
                {
                    if (HasPerm(attacker, Chat_Perm)) Player.Message(attacker, string.Format(msg("RadTownLoot", attacker.UserIDString), animal.name), chaticon);
                    LogToFile("RadTownKills", $"{DateTime.Now:h:mm:ss tt}] {attacker} killed a {animal.name} and loot was dropped", this);
                }
            }
            return;
        }

        void OnEntitySpawned(BaseNPC2 animal)
        {
            if (animal == null) return;
            ShowConsole = false;
            ChangeValues = false;
            if ((animal.name.Contains("Alpha") && IgnoreAlpha) || (animal.name.Contains("Omega") && IgnoreOmega))
            {
                if (Debug) Puts($"Skipping spawn values for {animal.name}");
                return;
            }

            if (animal is Wolf2)
            {
                HealthMin = configData.Animals.WolfSpawns.Healthmin;
                HealthMax = configData.Animals.WolfSpawns.Healthmax;
                ShowConsole = configData.Animals.WolfSpawns.ShowConsole;
                ChangeValues = configData.Animals.WolfSpawns.Change;
            }

            if (!ChangeValues) return;

            RandomHealth = UnityEngine.Random.Range(HealthMin , HealthMax);
            RandomDamage = UnityEngine.Random.Range(DamageMin , DamageMax);

            animal.InitializeHealth(RandomHealth , RandomHealth);
            if (ShowConsole) Puts($"A {animal.name} spawned with {RandomHealth} HP and {RandomDamage} Strength");
        }

        void OnEntitySpawned(BaseAnimalNPC animal)
        {
            if (animal == null) return;
            ShowConsole = false;
            ChangeValues = false;
            if ((animal.name.Contains("Alpha") && IgnoreAlpha) || (animal.name.Contains("Omega") && IgnoreOmega))
            {
                if (Debug) Puts($"Skipping spawn values for {animal.name}");
                return;
            }

            if (animal is Bear)
            {
                HealthMin = configData.Animals.BearSpawns.Healthmin;
                HealthMax = configData.Animals.BearSpawns.Healthmax;
                DamageMin = configData.Animals.BearSpawns.Damage;
                DamageMax = configData.Animals.BearSpawns.DamageMax;
                Speed = configData.Animals.BearSpawns.Speed;
                ShowConsole = configData.Animals.BearSpawns.ShowConsole;
                ChangeValues = configData.Animals.BearSpawns.Change;
            }
            if (animal is Boar)
            {
                HealthMin = configData.Animals.BoarSpawns.Healthmin;
                HealthMax = configData.Animals.BoarSpawns.Healthmax;
                DamageMin = configData.Animals.BoarSpawns.Damage;
                DamageMax = configData.Animals.BoarSpawns.DamageMax;
                Speed = configData.Animals.BoarSpawns.Speed;
                ShowConsole = configData.Animals.BoarSpawns.ShowConsole;
                ChangeValues = configData.Animals.BoarSpawns.Change;
            }
            if (animal is Polarbear)
            {
                HealthMin = configData.Animals.PBearSpawns.Healthmin;
                HealthMax = configData.Animals.PBearSpawns.Healthmax;
                DamageMin = configData.Animals.PBearSpawns.Damage;
                DamageMax = configData.Animals.PBearSpawns.DamageMax;
                Speed = configData.Animals.PBearSpawns.Speed;
                ShowConsole = configData.Animals.PBearSpawns.ShowConsole;
                ChangeValues = configData.Animals.PBearSpawns.Change;
            }
            if (animal is Wolf)
            {
                HealthMin = configData.Animals.WolfSpawns.Healthmin;
                HealthMax = configData.Animals.WolfSpawns.Healthmax;
                DamageMin = configData.Animals.WolfSpawns.Damage;
                DamageMax = configData.Animals.WolfSpawns.DamageMax;
                Speed = configData.Animals.WolfSpawns.Speed;
                ShowConsole = configData.Animals.WolfSpawns.ShowConsole;
                ChangeValues = configData.Animals.WolfSpawns.Change;
            }
            if (animal is Boar)
            {
                HealthMin = configData.Animals.BoarSpawns.Healthmin;
                HealthMax = configData.Animals.BoarSpawns.Healthmax;
                DamageMin = configData.Animals.BoarSpawns.Damage;
                DamageMax = configData.Animals.BoarSpawns.DamageMax;
                Speed = configData.Animals.BoarSpawns.Speed;
                ShowConsole = configData.Animals.BoarSpawns.ShowConsole;
                ChangeValues = configData.Animals.BoarSpawns.Change;
            }
            if (animal is Chicken)
            {
                HealthMin = configData.Animals.ChickenSpawns.Healthmin;
                HealthMax = configData.Animals.ChickenSpawns.Healthmax;
                DamageMin = configData.Animals.ChickenSpawns.Damage;
                DamageMax = configData.Animals.ChickenSpawns.DamageMax;
                Speed = configData.Animals.ChickenSpawns.Speed;
                ShowConsole = configData.Animals.ChickenSpawns.ShowConsole;
                ChangeValues = configData.Animals.ChickenSpawns.Change;
            }
            if (animal is Stag)
            {
                HealthMin = configData.Animals.StagSpawns.Healthmin;
                HealthMax = configData.Animals.StagSpawns.Healthmax;
                DamageMin = configData.Animals.StagSpawns.Damage;
                DamageMax = configData.Animals.StagSpawns.DamageMax;
                Speed = configData.Animals.StagSpawns.Speed;
                ShowConsole = configData.Animals.StagSpawns.ShowConsole;
                ChangeValues = configData.Animals.StagSpawns.Change;
            }

            if (!ChangeValues) return;

            RandomHealth = UnityEngine.Random.Range(HealthMin,HealthMax);
            RandomDamage = UnityEngine.Random.Range(DamageMin, DamageMax);

            animal.InitializeHealth(RandomHealth, RandomHealth);
            animal.AttackDamage = RandomDamage;
            animal.Stats.Speed = Speed;
            animal.Stats.TurnSpeed = Speed;
            if (ShowConsole) Puts($"A {animal.name} spawned with {RandomHealth} HP and {RandomDamage} Strength");
        }

        #endregion

        #region Helpers

        object AnimalCount(string _animal)
        {
            if (_animal == "Wolf") return BaseNetworkable.serverEntities.OfType<Wolf>().Count().ToString();
            if (_animal == "Bear") return BaseNetworkable.serverEntities.OfType<Bear>().Count().ToString();
            if (_animal == "Polarbear") return BaseNetworkable.serverEntities.OfType<Polarbear>().Count().ToString();
            if (_animal == "Boar") return BaseNetworkable.serverEntities.OfType<Boar>().Count().ToString();
            if (_animal == "Chicken") return BaseNetworkable.serverEntities.OfType<Chicken>().Count().ToString();
            if (_animal == "Stag") return BaseNetworkable.serverEntities.OfType<Stag>().Count().ToString();
            else return "N/a";
        }

        bool HasPerm(BasePlayer player, string perm) { return (permission.UserHasPermission(player.UserIDString, perm));}

        #endregion

        #region Loot

        private Dictionary<string, List<ulong>> Skins { get; set; } = new Dictionary<string, List<ulong>>();

        private static List<LootItems> DefaultLoot
        {
            get
            {
                return new List<LootItems>
                {
                    new LootItems { shortname = "ammo.pistol", amount = 5, skin = 0, amountMin = 5 },
                    new LootItems { shortname = "ammo.pistol.fire", amount = 5, skin = 0, amountMin = 5 },
                    new LootItems { shortname = "ammo.pistol.hv", amount = 5, skin = 0, amountMin = 5 },
                    new LootItems { shortname = "ammo.rifle", amount = 5, skin = 0, amountMin = 5 },
                    new LootItems { shortname = "ammo.rifle.explosive", amount = 5, skin = 0, amountMin = 5 },
                    new LootItems { shortname = "ammo.rifle.hv", amount = 5, skin = 0, amountMin = 5 },
                    new LootItems { shortname = "ammo.rifle.incendiary", amount = 5, skin = 0, amountMin = 5 },
                    new LootItems { shortname = "ammo.rocket.basic.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "ammo.rocket.fire.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "ammo.rocket.hv.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "ammo.shotgun", amount = 12, skin = 0, amountMin = 8 },
                    new LootItems { shortname = "explosive.timed", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "explosives", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "pistol.m92", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "rifle.ak.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "rifle.bolt.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "shotgun.spas12", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "smg.2.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "smg.thompson.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "weapon.mod.8x.scope.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "weapon.mod.flashlight.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "weapon.mod.holosight.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "weapon.mod.lasersight.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "weapon.mod.silencer.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "weapon.mod.small.scope.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "grenade.f1.bp", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "pickaxe", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "hatchet", amount = 1, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "can.beans", amount = 3, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "can.tuna", amount = 3, skin = 0, amountMin = 1 },
                    new LootItems { shortname = "black.raspberries", amount = 5, skin = 0, amountMin = 3 },
                };
            }
        }

        public class LootItems
        {
            public string shortname { get; set; }
            public int amount { get; set; }
            public ulong skin { get; set; }
            public int amountMin { get; set; }
        }

        private void SpawnRadLoot(Vector3 pos, Quaternion rot, string AnimalType)
        {
            var backpack = GameManager.server.CreateEntity(StringPool.Get(1519640547), pos, rot, true) as DroppedItemContainer;

            if (backpack == null) return;

            backpack.inventory = new ItemContainer();
            backpack.inventory.ServerInitialize(null, 36);
            backpack.inventory.GiveUID();
            backpack.inventory.entityOwner = backpack;
            backpack.inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);
            backpack.playerName = animalprefix + AnimalType;
            backpack.Spawn();
            if (AnimalType == "Wolf")
            {
                if(Debug) Puts($"AnimalType is {AnimalType}");
                SpawnLoot(backpack.inventory, configData.Animals.WolfSpawns.Loots.Loot.ToList(), AnimalType);
            }
            if (AnimalType == "Bear")
            {
                if (Debug) Puts($"AnimalType is {AnimalType}");
                SpawnLoot(backpack.inventory, configData.Animals.BearSpawns.Loots.Loot.ToList(), AnimalType);
            }
            if (AnimalType == "Boar")
            {
                if (Debug) Puts($"AnimalType is {AnimalType}");
                SpawnLoot(backpack.inventory, configData.Animals.BoarSpawns.Loots.Loot.ToList(), AnimalType);
            }
            if (AnimalType == "Chicken")
            {
                if (Debug) Puts($"AnimalType is {AnimalType}");
                SpawnLoot(backpack.inventory, configData.Animals.ChickenSpawns.Loots.Loot.ToList(), AnimalType);
            }
            if (AnimalType == "Stag")
            {
                if (Debug) Puts($"AnimalType is {AnimalType}");
                SpawnLoot(backpack.inventory, configData.Animals.StagSpawns.Loots.Loot.ToList(), AnimalType);
            }
            if (AnimalType == "Polarbear")
            {
                if (Debug) Puts($"AnimalType is {AnimalType}");
                SpawnLoot(backpack.inventory, configData.Animals.PBearSpawns.Loots.Loot.ToList(), AnimalType);
            }
        }

        private void SpawnLoot(ItemContainer container, List<LootItems> loot, string AnimalType)
        {
            int total = 0;
            if (AnimalType == "Wolf") total = UnityEngine.Random.Range(Math.Min(loot.Count, configData.Animals.WolfSpawns.Loots.MinAmount), Math.Min(loot.Count, configData.Animals.WolfSpawns.Loots.MaxAmount));
            if (AnimalType == "Bear") total = UnityEngine.Random.Range(Math.Min(loot.Count, configData.Animals.BearSpawns.Loots.MinAmount), Math.Min(loot.Count, configData.Animals.BearSpawns.Loots.MaxAmount));
            if (AnimalType == "Boar") total = UnityEngine.Random.Range(Math.Min(loot.Count, configData.Animals.BoarSpawns.Loots.MinAmount), Math.Min(loot.Count, configData.Animals.BoarSpawns.Loots.MaxAmount));
            if (AnimalType == "Chicken") total = UnityEngine.Random.Range(Math.Min(loot.Count, configData.Animals.ChickenSpawns.Loots.MinAmount), Math.Min(loot.Count, configData.Animals.ChickenSpawns.Loots.MaxAmount));
            if (AnimalType == "Stag") total = UnityEngine.Random.Range(Math.Min(loot.Count, configData.Animals.StagSpawns.Loots.MinAmount), Math.Min(loot.Count, configData.Animals.StagSpawns.Loots.MaxAmount));
            if (AnimalType == "Polarbear") total = UnityEngine.Random.Range(Math.Min(loot.Count, configData.Animals.PBearSpawns.Loots.MinAmount), Math.Min(loot.Count, configData.Animals.PBearSpawns.Loots.MaxAmount));
            if (Debug) Puts($"{AnimalType} {total} items");
            if (total == 0 || loot.Count == 0) return;

            container.capacity = total;
            ItemDefinition def;
            List<ulong> skins;
            LootItems lootItem;

            for (int j = 0; j < total; j++)
            {
                if (loot.Count == 0) break;

                lootItem = loot.GetRandom();

                loot.Remove(lootItem);

                if (lootItem.amount <= 0) continue;

                string shortname = lootItem.shortname;
                bool isBlueprint = shortname.EndsWith(".bp");

                if (isBlueprint) shortname = shortname.Replace(".bp", string.Empty);

                def = ItemManager.FindItemDefinition(shortname);

                if (def == null)
                {
                    Puts("Invalid shortname: {0}", lootItem.shortname);
                    continue;
                }

                ulong skin = lootItem.skin;

                if (configData.PlugCFG.RandomSkins && skin == 0 || configData.PlugCFG.RandomSkins && skin == 0)
                {
                    skins = GetItemSkins(def);

                    if (skins.Count > 0) skin = skins.GetRandom();
                }

                int amount = lootItem.amount;

                if (amount <= 0) continue;

                if (lootItem.amountMin > 0 && lootItem.amountMin < lootItem.amount)
                {
                    amount = UnityEngine.Random.Range(lootItem.amountMin, lootItem.amount);
                }

                Item item;

                if (isBlueprint)
                {
                    item = ItemManager.CreateByItemID(-996920608, 1, 0);

                    if (item == null) continue;

                    item.blueprintTarget = def.itemid;
                    item.amount = amount;
                }
                else item = ItemManager.Create(def, amount, skin);

                if (!item.MoveToContainer(container, -1, false)) item.Remove();
            }
        }

        private List<ulong> GetItemSkins(ItemDefinition def)
        {
            List<ulong> skins;
            if (!Skins.TryGetValue(def.shortname, out skins))
            {
                Skins[def.shortname] = skins = ExtractItemSkins(def, skins);
            }

            return skins;
        }

        private List<ulong> ExtractItemSkins(ItemDefinition def, List<ulong> skins)
        {
            skins = new List<ulong>();

            foreach (var skin in def.skins)
            {
                skins.Add(Convert.ToUInt64(skin.id));
            }
            foreach (var asi in Rust.Workshop.Approved.All.Values)
            {
                if (!string.IsNullOrEmpty(asi.Skinnable.ItemName) && asi.Skinnable.ItemName == def.shortname)
                {
                    skins.Add(Convert.ToUInt64(asi.WorkshopdId));
                }
            }

            return skins;
        }

        #endregion
    }
}

// --- End of file: RadTownLoot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rad-pockets ---
// --- Original File Path: R/RadPockets/RadPockets.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using Rust;
using Oxide.Core;
using Oxide.Core.Configuration;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;

namespace Oxide.Plugins
{
    [Info("RadPockets", "k1lly0u", "2.0.4")]
    [Description("Turn your server into a irradiated wasteland")]
    class RadPockets : RustPlugin
    {
        #region Fields  
        private StoredData storedData;
        private DynamicConfigFile data;
                
        private List<RadiationZone> radiationZones = new List<RadiationZone>();

        private const int PLAYER_MASK = 131072;
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("radpockets_data");
            data.Settings.Converters = new JsonConverter[] { new StringEnumConverter(), new UnityVector3Converter() };

            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("radpockets.use", this);
        }

        private void OnServerInitialized()
        {
            LoadData();

            ConVar.Server.radiation = true;

            if (storedData.radData.Count == 0)
                CreateNewZones();
            else
            {
                foreach (var zone in storedData.radData)
                    CreateZone(zone);
                Puts($"Re-initalized {storedData.radData.Count} RadPockets");
            }
        }

        private void Unload()
        {
            DestroyAllZones();
        }
        #endregion

        #region Functions
        private void DestroyAllZones()
        {
            for (int i = 0; i < radiationZones.Count; i++)
                UnityEngine.Object.Destroy(radiationZones[i].gameObject);

            radiationZones.Clear();

            RadiationZone[] components = UnityEngine.Object.FindObjectsOfType<RadiationZone>();
            if (components != null)
            {
                for (int i = 0; i < components.Length; i++)
                {
                    UnityEngine.Object.Destroy(components[i].gameObject);
                }
            }
        }

        private void CreateNewZones()
        {
            int amountToCreate = UnityEngine.Random.Range(configData.Count_Min, configData.Count_Max);

            for (int i = 0; i < amountToCreate; i++)
            {
                CreateZone(new PocketData
                {
                    amount = UnityEngine.Random.Range(configData.Radiation_Min, configData.Radiation_Max),
                    position = GetRandomPos(),
                    radius = UnityEngine.Random.Range(configData.Radius_Min, configData.Radius_Max)
                }, true);
            }

            SaveData();
            Puts($"Successfully created {amountToCreate} radiation pockets");
        }

        private void CreateZone(PocketData zone, bool isNew = false, bool save = false)
        {
            RadiationZone radiationZone = new GameObject().AddComponent<RadiationZone>();
            radiationZone.Activate(zone);
            radiationZones.Add(radiationZone);

            if (isNew)
                storedData.radData.Add(zone);

            if (save)
                SaveData();            
        }

        private Vector3 GetRandomPos()
        {
            int mapSize = Convert.ToInt32((TerrainMeta.Size.x / 2) - 600);

            int X = UnityEngine.Random.Range(-mapSize, mapSize);
            int Y = UnityEngine.Random.Range(-mapSize, mapSize);

            return new Vector3(X, TerrainMeta.HeightMap.GetHeight(new Vector3(X, 0, Y)), Y);            
        }        
        #endregion

        #region Chat Commands
        [ChatCommand("rp")]
        private void cmdRP(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, "radpockets.use"))
            {
                if (args == null || args.Length == 0)
                {
                    SendReply(player, $"<color=#00CC00>{Title}  </color><color=#939393>v </color><color=#00CC00>{Version}</color>");
                    SendReply(player, $"<color=#00CC00>/rp showall</color> - {Msg("showallsyn", player.UserIDString, true)}");
                    SendReply(player, $"<color=#00CC00>/rp shownear <opt:radius></color> - {Msg("shownearsyn", player.UserIDString, true)}");
                    SendReply(player, $"<color=#00CC00>/rp removeall</color> - {Msg("removeallsyn", player.UserIDString, true)}");
                    SendReply(player, $"<color=#00CC00>/rp removenear <opt:radius></color> - {Msg("removenearsyn", player.UserIDString, true)}");
                    SendReply(player, $"<color=#00CC00>/rp tpnear</color> - {Msg("tpnearsyn", player.UserIDString, true)}");
                    SendReply(player, $"<color=#00CC00>/rp create <radius> <radiation></color> - {Msg("createsyn", player.UserIDString, true)}");
                    return;
                }

                switch (args[0].ToLower())
                {
                    case "showall":
                        for (int i = 0; i < radiationZones.Count; i++)                        
                            player.SendConsoleCommand("ddraw.box", 10f, Color.green, radiationZones[i].data.position, 1f);
                        return;

                    case "shownear":
                        {
                            float distance = 0;
                            if (args.Length >= 2 && !float.TryParse(args[1], out distance))
                                distance = 10f;

                            for (int i = 0; i < radiationZones.Count; i++)
                            {
                                RadiationZone radiationZone = radiationZones[i];

                                if (Vector3.Distance(radiationZone.data.position, player.transform.position) <= distance)
                                    player.SendConsoleCommand("ddraw.box", 10f, Color.green, radiationZone.data.position, 1f);
                            }
                        }
                        return;

                    case "removeall":
                        DestroyAllZones();
                        storedData.radData.Clear();
                        SaveData();
                        SendReply(player, Msg("removedall", player.UserIDString));
                        return;

                    case "removenear":
                        {
                            float distance = 0;
                            if (args.Length >= 2 && !float.TryParse(args[1], out distance))
                                distance = 10f;

                            int destCount = 0;

                            for (int i = 0; i < radiationZones.Count; i++)
                            {
                                RadiationZone radiationZone = radiationZones[i];

                                if (Vector3.Distance(radiationZone.data.position, player.transform.position) <= distance)
                                {       
                                    UnityEngine.Object.Destroy(radiationZone.gameObject);
                                    radiationZones.Remove(radiationZone);

                                    storedData.radData.Remove(radiationZone.data);

                                    destCount++;

                                }
                            }
                            SendReply(player, Msg("zonesdestroyed", player.UserIDString, true).Replace("{count}", $"</color><color=#00CC00>{destCount}</color><color=#939393>"));
                        }
                        return;

                    case "tpnear":
                        object closestPosition = null;
                        float closestDistance = 4000;

                        for (int i = 0; i < radiationZones.Count; i++)
                        {
                            RadiationZone radiationZone = radiationZones[i];
                            float distance = Vector3.Distance(radiationZone.data.position, player.transform.position);
                            if (distance < closestDistance)
                            {
                                closestDistance = distance;
                                closestPosition = radiationZone.data.position;
                            }
                        }

                        if (closestPosition is Vector3)
                            player.MovePosition((Vector3)closestPosition);
                        return;

                    case "create":
                        if (args.Length >= 3)
                        {
                            float distance = 0;
                            float radAmount = 0;
                            if (!float.TryParse(args[1], out distance))
                            {
                                SendReply(player, string.Format(Msg("notanumber", player.UserIDString, true), "distance"));
                                return;
                            }

                            if (!float.TryParse(args[2], out radAmount))
                            {
                                SendReply(player, string.Format(Msg("notanumber", player.UserIDString, true), "radiation amount"));
                                return;
                            }

                            CreateZone(new PocketData
                            {
                                amount = radAmount,
                                position = player.transform.position,
                                radius = distance
                            }, true, true);

                            SendReply(player, Msg("createsuccess", player.UserIDString, true)
                                .Replace("{radius}", $"</color><color=#00CC00>{distance}</color><color=#939393>")
                                .Replace("{radamount}", $"</color><color=#00CC00>{radAmount}</color><color=#939393>")
                                .Replace("{pos}", $"</color><color=#00CC00>{player.transform.position}</color>"));
                            return;
                        }
                        else SendReply(player, $"<color=#00CC00>/rp create <radius> <radiation></color> - {Msg("createsyn", player.UserIDString, true)}");
                        return;

                    default:
                        break;
                }
            }
        }
        #endregion

        #region Radiation Control
        private class PocketData
        {
            public Vector3 position;
            public float radius;
            public float amount;
        }

        private class RadiationZone : MonoBehaviour
        {
            public PocketData data;  

            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = $"radpocket_{UnityEngine.Random.Range(1, 9999)}";

                Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
            }

            public void Activate(PocketData data)
            {
                this.data = data;
                
                transform.position = data.position;

                SphereCollider sphereCollider = gameObject.GetComponent<SphereCollider>() ?? gameObject.AddComponent<SphereCollider>();
                sphereCollider.isTrigger = true;
                sphereCollider.radius = data.radius;

                TriggerRadiation triggerRadiation = gameObject.GetComponent<TriggerRadiation>() ?? gameObject.AddComponent<TriggerRadiation>();
                triggerRadiation.RadiationAmountOverride = data.amount;
                triggerRadiation.interestLayers = PLAYER_MASK;
                triggerRadiation.enabled = true;

                gameObject.SetActive(true);
                enabled = true;
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty("Minimum zone radius")]
            public int Radius_Min { get; set; }

            [JsonProperty("Maximum zone radius")]
            public int Radius_Max { get; set; }

            [JsonProperty("Minimum amount of zones to create")]
            public int Count_Min { get; set; }

            [JsonProperty("Maximum amount of zones to create")]
            public int Count_Max { get; set; }

            [JsonProperty("Minimum amount of radiation")]
            public int Radiation_Min { get; set; }

            [JsonProperty("Maximum amount of radiation")]
            public int Radiation_Max { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Count_Max = 30,
                Count_Min = 15,
                Radiation_Max = 25,
                Radiation_Min = 2,
                Radius_Max = 60,
                Radius_Min = 15,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Data Management
        private void SaveData() => data.WriteObject(storedData);

        private void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }
        }

        private class StoredData
        {
            public List<PocketData> radData = new List<PocketData>();
        }

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                Vector3 vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    string[] values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                JObject o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }
        #endregion

        #region Localization
        private string Msg(string key, string playerid = null, bool color = false)
        {
            if (color)
                return $"<color=#939393>{lang.GetMessage(key, this, playerid)}</color>";
            else return lang.GetMessage(key, this, playerid);
        }

        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"showallsyn", "Shows all RadPockets" },
            {"shownearsyn", "Shows nearby RadPockets within optional radius (default 10)" },
            {"removeallsyn", "Removes all RadPockets" },
            {"removenearsyn", "Removes RadPockets within optional radius (default 10)" },
            {"tpnearsyn", "Teleport to the closest RadPocket" },
            {"createsyn", "Create a new RadPocket on your location, requires a radius and radiation amount" },
            {"zonesdestroyed", "Destroyed {count} pockets" },
            {"notanumber", "You must enter a number value for {0}" },
            {"createsuccess", "You have successfully created a new RadPocket with a radius of {radius}, radiation amount of {radamount}, and position of {pos}" },
            {"removedall", "Successfully removed all Radiation Pockets" }
        };
        #endregion
    }
}


// --- End of file: RadPockets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/repair-blocker ---
// --- Original File Path: R/RepairBlocker/RepairBlocker.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;


namespace Oxide.Plugins
{
    [Info("Repair Blocker", "Camoec", 1.1)]
    [Description("Prevents certain objects from being repaired")]

    public class RepairBlocker : RustPlugin
    {  
        private const string BypassPerm = "repairblocker.bypass";
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "ChatPrefix")]
            public string ChatPrefix = "<color=#eb4213>Repair Blocker</color>:";
            [JsonProperty(PropertyName = "BlackList")]
            public List<string> BlackList = new List<string>();
        }

        private PluginConfig _config;

        protected override void SaveConfig() => Config.WriteObject(_config, true);
        protected override void LoadDefaultConfig()
        {
            //base.LoadDefaultConfig();
            _config = new PluginConfig();
            _config.BlackList.Add("rifle.lr300"); // rifle.lr300
            _config.BlackList.Add("rifle.ak"); // rifle.ak
            _config.BlackList.Add("repairbench_deployed"); // repair bench
            SaveConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                    throw new Exception();

                SaveConfig(); // override posible obsolet / outdated config
            }
            catch (Exception)
            {
                PrintError("Loaded default config.");

                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoRepair"] = "You are not allowed to repair that"
            }, this);
        }

        private string Lang(string key, string userid) => lang.GetMessage(key, this, userid);

        private void Init()
        {
            permission.RegisterPermission(BypassPerm, this);
        }
        object OnItemRepair(BasePlayer player, Item item)
        {
            if (_config.BlackList.Contains(item.info.shortname) && !permission.UserHasPermission(player.UserIDString, BypassPerm))
            {
                PrintToChat(player, $"{_config.ChatPrefix} {Lang("NoRepair", player.UserIDString)}");
                return false;
            }
            return null;
        }
        object OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (_config.BlackList.Contains(info.HitEntity.ShortPrefabName) && !permission.UserHasPermission(player.UserIDString, BypassPerm))
            {
                PrintToChat(player, $"{_config.ChatPrefix} {Lang("NoRepair", player.UserIDString)}");
                return false;
            }
            return null;
        }
    }
}

// --- End of file: RepairBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/recycler-block ---
// --- Original File Path: R/RecyclerBlock/RecyclerBlock.cs ---

using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Recycler Block", "Krungh Crow", "1.0.2")]
    [Description("Disables using the recycler")]

    class RecyclerBlock : RustPlugin
    {
        void Init() => permission.RegisterPermission("recyclerblock.bypass" , this);

        private object CanLootEntity(BasePlayer player, Recycler recycler)
        {

            if (player == null || recycler == null) return null;
            if (permission.UserHasPermission(player.UserIDString, "recyclerblock.bypass")) return null;
            return false;
        }
    }
}

// --- End of file: RecyclerBlock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/drone-settings ---
// --- Original File Path: R/RidableDrones_hVdQK/RidableDrones_hVdQK.cs ---

﻿using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Drone Settings", "WhiteThunder", "1.3.0")]
    [Description("Allows changing speed, toughness and other properties of RC drones.")]
    internal class DroneSettings : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin DroneScaleManager;

        private Configuration _config;

        private const string PermissionProfilePrefix = "dronesettings";

        private const string BaseDroneType = "BaseDrone";

        private DroneProperties _vanillaDroneProperties;
        private ProtectionProperties _vanillaDroneProtection;
        private readonly List<ProtectionProperties> _customProtectionProperties = new List<ProtectionProperties>();
        private readonly List<string> _reusableDroneTypeList = new List<string>();

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init(this);

            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null)
                    continue;

                OnEntitySpawned(drone);
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                var station = player.GetMounted() as ComputerStation;
                if (station == null)
                    continue;

                var drone = GetControlledDrone(station);
                if (drone == null)
                    continue;

                OnBookmarkControlStarted(station, player, drone.GetIdentifier(), drone);
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null || !IsDroneEligible(drone))
                    continue;

                DroneConnectionFixer.RemoveFromDrone(drone);

                if (!ApplySettingsWasBlocked(drone))
                {
                    RestoreVanillaSettings(drone);
                    Interface.CallHook("OnDroneSettingsChanged", drone);
                }
            }

            foreach (var protectionProperties in _customProtectionProperties)
            {
                UnityEngine.Object.Destroy(protectionProperties);
            }
        }

        private void OnEntitySpawned(Drone drone)
        {
            if (!IsDroneEligible(drone))
                return;

            if (_vanillaDroneProtection == null)
            {
                _vanillaDroneProtection = drone.baseProtection;
            }

            if (_vanillaDroneProperties == null)
            {
                _vanillaDroneProperties = DroneProperties.FromDrone(drone);
            }

            var drone2 = drone;

            // Delay to give other plugins a moment to cache the drone id so they can specify drone type or block this.
            NextTick(() =>
            {
                if (drone2 == null)
                    return;

                var profile = GetDroneProfile(drone2);
                if (profile == null)
                    return;

                TryApplyProfile(drone2, profile);
            });
        }

        private void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string bookmarkName, Drone drone)
        {
            DroneConnectionFixer.OnControlStarted(this, drone, player);
        }

        private void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, Drone drone)
        {
            if (drone == null)
                return;

            DroneConnectionFixer.OnControlEnded(drone, player);
        }

        private void OnDroneScaled(Drone drone, BaseEntity rootEntity, float scale, float previousScale)
        {
            if (scale == 1)
            {
                DroneConnectionFixer.OnRootEntityChanged(drone, drone);
            }
            else if (previousScale == 1)
            {
                DroneConnectionFixer.OnRootEntityChanged(drone, rootEntity);
            }
        }

        #endregion

        #region API

        private void API_RefreshDroneProfile(Drone drone)
        {
            var profile = GetDroneProfile(drone);
            if (profile == null)
                return;

            TryApplyProfile(drone, profile, restoreVanilla: true);
        }

        #endregion

        #region Helper Methods

        private static bool ApplySettingsWasBlocked(Drone drone)
        {
            var hookResult = Interface.CallHook("OnDroneSettingsChange", drone);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool IsDroneEligible(Drone drone)
        {
            return drone.skinID == 0 && !(drone is DeliveryDrone);
        }

        private static string GetProfilePermission(string droneType, string profileSuffix)
        {
            return $"{PermissionProfilePrefix}.{droneType}.{profileSuffix}";
        }

        private static Drone GetControlledDrone(ComputerStation station)
        {
            return station.currentlyControllingEnt.Get(serverside: true) as Drone;
        }

        private string DetermineBestDroneType(List<string> droneTypeList)
        {
            if (droneTypeList.Count == 0)
                return null;

            if (droneTypeList.Count == 1)
                return droneTypeList[0];

            string bestDroneType = null;
            var bestDroneTypePriorityIndex = int.MaxValue;

            // Sort by priority, else sort alphabetically.
            foreach (var droneType in droneTypeList)
            {
                var priorityIndex = Array.IndexOf(_config.DroneTypePriority, droneType);
                priorityIndex = priorityIndex >= 0 ? priorityIndex : int.MaxValue;

                if (bestDroneType == null)
                {
                    bestDroneType = droneType;
                    bestDroneTypePriorityIndex = priorityIndex;
                    continue;
                }

                if (priorityIndex < bestDroneTypePriorityIndex
                    || priorityIndex == bestDroneTypePriorityIndex && string.Compare(droneType, bestDroneType, StringComparison.InvariantCultureIgnoreCase) < 0)
                {
                    bestDroneType = droneType;
                    bestDroneTypePriorityIndex = priorityIndex;
                }
            }

            return bestDroneType;
        }

        private string DetermineDroneType(Drone drone)
        {
            _reusableDroneTypeList.Clear();
            var hookResult = Interface.CallHook("OnDroneTypeDetermine", drone, _reusableDroneTypeList);
            return _reusableDroneTypeList.Count > 0
                ? DetermineBestDroneType(_reusableDroneTypeList)
                : hookResult as string;
        }

        private DroneProfile GetDroneProfile(Drone drone)
        {
            var droneType = DetermineDroneType(drone) ?? BaseDroneType;
            return _config.FindProfile(this, droneType, drone.OwnerID);
        }

        private BaseEntity GetRootEntity(Drone drone)
        {
            return DroneScaleManager?.Call("API_GetRootEntity", drone) as BaseEntity;
        }

        private BaseEntity GetDroneOrRootEntity(Drone drone)
        {
            var rootEntity = GetRootEntity(drone);
            return rootEntity != null ? rootEntity : drone;
        }

        private void RestoreVanillaSettings(Drone drone)
        {
            if (_vanillaDroneProtection != null && _customProtectionProperties.Contains(drone.baseProtection))
            {
                drone.baseProtection = _vanillaDroneProtection;
            }

            _vanillaDroneProperties?.ApplyToDrone(drone);
        }

        private bool TryApplyProfile(Drone drone, DroneProfile profile, bool restoreVanilla = false)
        {
            if (ApplySettingsWasBlocked(drone))
                return false;

            if (restoreVanilla)
            {
                RestoreVanillaSettings(drone);
            }

            profile.ApplyToDrone(drone);
            Interface.CallHook("OnDroneSettingsChanged", drone);
            return true;
        }

        private ProtectionProperties CreateProtectionProperties(Dictionary<string, float> damageMap)
        {
            var protectionProperties = ScriptableObject.CreateInstance<ProtectionProperties>();
            _customProtectionProperties.Add(protectionProperties);

            foreach (var entry in damageMap)
            {
                DamageType damageType;
                if (!Enum.TryParse(entry.Key, true, out damageType))
                {
                    LogError($"Invalid damage type: {entry.Key}");
                    continue;
                }

                protectionProperties.Add(damageType, 1 - Mathf.Clamp(entry.Value, 0, 1));
            }

            return protectionProperties;
        }

        #endregion

        #region Drone Network Fixer

        // Fixes issue where fast moving drones temporarily disconnect and reconnect.
        // This issue occurs because the drone's network group and the client's secondary network group cannot be changed at the same time.
        private class DroneConnectionFixer : FacepunchBehaviour
        {
            public static void OnControlStarted(DroneSettings plugin, Drone drone, BasePlayer player)
            {
                var component = drone.GetOrAddComponent<DroneConnectionFixer>();
                component.SetRootEntity(plugin.GetDroneOrRootEntity(drone));
                component._viewers.Add(player);
            }

            public static void OnControlEnded(Drone drone, BasePlayer player)
            {
                var component = drone.GetComponent<DroneConnectionFixer>();
                if (component == null)
                    return;

                component.RemoveController(player);
            }

            public static void OnRootEntityChanged(Drone drone, BaseEntity rootEntity)
            {
                var component = drone.GetComponent<DroneConnectionFixer>();
                if (component == null)
                    return;

                component.SetRootEntity(rootEntity);
            }

            public static void RemoveFromDrone(Drone drone)
            {
                DestroyImmediate(drone.GetComponent<DroneConnectionFixer>());
            }

            private BaseEntity _rootEntity;
            private List<BasePlayer> _viewers = new List<BasePlayer>();
            private bool _isCallingCustomUpdateNetworkGroup;
            private Action _updateNetworkGroup;
            private Action _customUpdateNetworkGroup;

            private DroneConnectionFixer()
            {
                _customUpdateNetworkGroup = CustomUpdateNetworkGroup;
            }

            private void SetRootEntity(BaseEntity rootEntity)
            {
                _rootEntity = rootEntity;
                _updateNetworkGroup = _rootEntity.UpdateNetworkGroup;
            }

            private void RemoveController(BasePlayer player)
            {
                _viewers.Remove(player);
                if (_viewers.Count == 0)
                {
                    DestroyImmediate(this);
                }
            }

            // Using LateUpdate since that's the soonest we can learn about a pending Invoke.
            private void LateUpdate()
            {
                // Detect when UpdateNetworkGroup has been scheduled, in order to schedule a custom one in its place.
                if (_rootEntity.isCallingUpdateNetworkGroup && !_isCallingCustomUpdateNetworkGroup)
                {
                    _rootEntity.CancelInvoke(_updateNetworkGroup);
                    Invoke(_customUpdateNetworkGroup, 5);
                    _isCallingCustomUpdateNetworkGroup = true;
                }
            }

            private void SendFakeUpdateNetworkGroup(BaseEntity entity, BasePlayer player, uint groupId)
            {
                var write = Net.sv.StartWrite();
                write.PacketID(Message.Type.GroupChange);
                write.EntityID(entity.net.ID);
                write.GroupID(groupId);
                write.Send(new SendInfo(player.net.connection));
            }

            private void CustomUpdateNetworkGroup()
            {
                foreach (var player in _viewers)
                {
                    // Temporarily tell the client that the drone is in the global network group.
                    SendFakeUpdateNetworkGroup(_rootEntity, player, BaseNetworkable.GlobalNetworkGroup.ID);

                    // Update the client secondary network group to the one that the drone will change to.
                    player.net.SwitchSecondaryGroup(Net.sv.visibility.GetGroup(_rootEntity.transform.position));
                }

                // Update the drone's network group based on its current position.
                // This will update clients to be aware that the drone is now in the new network group.
                _rootEntity.UpdateNetworkGroup();
                _isCallingCustomUpdateNetworkGroup = false;
            }

            private void OnDestroy()
            {
                if (_rootEntity == null || _rootEntity.IsDestroyed)
                    return;

                if (_rootEntity.isCallingUpdateNetworkGroup && !_rootEntity.IsInvoking(_updateNetworkGroup))
                {
                    _rootEntity.Invoke(_updateNetworkGroup, 5);
                }
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class DroneProfile
        {
            [JsonProperty("PermissionSuffix", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string PermissionSuffix;

            [JsonProperty("DroneProperties")]
            public DroneProperties DroneProperties = new DroneProperties();

            [JsonProperty("DamageScale")]
            public Dictionary<string, float> DamageScale;

            [JsonIgnore]
            public ProtectionProperties ProtectionProperties;

            [JsonIgnore]
            public string Permission;

            public void Init(DroneSettings plugin, string droneType, bool requiresPermission)
            {
                if (requiresPermission && !string.IsNullOrWhiteSpace(PermissionSuffix))
                {
                    Permission = GetProfilePermission(droneType, PermissionSuffix);
                    plugin.permission.RegisterPermission(Permission, plugin);
                }

                if (DamageScale != null)
                {
                    ProtectionProperties = plugin.CreateProtectionProperties(DamageScale);
                }
            }

            public void ApplyToDrone(Drone drone)
            {
                if (ProtectionProperties != null)
                {
                    drone.baseProtection = ProtectionProperties;
                }

                DroneProperties?.ApplyToDrone(drone);
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class DroneProperties
        {
            public static DroneProperties FromDrone(Drone drone)
            {
                return new DroneProperties
                {
                    KillInWater = drone.killInWater,
                    MovementAcceleration = drone.movementAcceleration,
                    AltitudeAcceleration = drone.altitudeAcceleration,
                    LeanWeight = drone.leanWeight,
                };
            }

            [JsonProperty("KillInWater")]
            public bool KillInWater = true;

            [JsonProperty("DisableWhenHurtChance")]
            public float DisableWhenHurtChance = 25;

            [JsonProperty("MovementAcceleration")]
            public float MovementAcceleration = 10;

            [JsonProperty("AltitudeAcceleration")]
            public float AltitudeAcceleration = 10;

            [JsonProperty("LeanWeight")]
            public float LeanWeight = 0.025f;

            public void ApplyToDrone(Drone drone)
            {
                drone.killInWater = KillInWater;
                drone.disableWhenHurt = DisableWhenHurtChance > 0;
                drone.disableWhenHurtChance = DisableWhenHurtChance / 100f;
                drone.movementAcceleration = MovementAcceleration;
                drone.altitudeAcceleration = AltitudeAcceleration;
                drone.leanWeight = LeanWeight;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class DroneTypeConfig
        {
            [JsonProperty("DefaultProfile")]
            public DroneProfile DefaultProfile = new DroneProfile();

            [JsonProperty("ProfilesRequiringPermission")]
            public DroneProfile[] ProfilesRequiringPermission = Array.Empty<DroneProfile>();

            public void Init(DroneSettings plugin, string droneType)
            {
                DefaultProfile.Init(plugin, droneType, requiresPermission: false);

                foreach (var profile in ProfilesRequiringPermission)
                {
                    profile.Init(plugin, droneType, requiresPermission: true);
                }
            }

            public DroneProfile GetProfileForOwner(DroneSettings plugin, ulong ownerId)
            {
                if (ownerId == 0 || (ProfilesRequiringPermission?.Length ?? 0) == 0)
                    return DefaultProfile;

                var ownerIdString = ownerId.ToString();
                for (var i = ProfilesRequiringPermission.Length - 1; i >= 0; i--)
                {
                    var profile = ProfilesRequiringPermission[i];
                    if (profile.Permission != null && plugin.permission.UserHasPermission(ownerIdString, profile.Permission))
                        return profile;
                }

                return DefaultProfile;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            public override bool Migrate()
            {
                var changed = false;

                foreach (var entry in _droneTypeAliases)
                {
                    var oldName = entry.Key;
                    var newName = entry.Value;

                    DroneTypeConfig droneTypeConfig;
                    if (SettingsByDroneType.TryGetValue(oldName, out droneTypeConfig))
                    {
                        SettingsByDroneType[newName] = droneTypeConfig;
                        SettingsByDroneType.Remove(oldName);
                        changed = true;
                    }
                }

                return changed;
            }

            [JsonIgnore]
            private readonly Dictionary<string, string> _droneTypeAliases = new Dictionary<string, string>
            {
                ["RidableDrones"] = "DroneChair",
            };

            [JsonProperty("DroneTypePriority")]
            public string[] DroneTypePriority =
            {
                "DroneTurrets",
                "DroneChair",
                "DroneStorage",
            };

            [JsonProperty("SettingsByDroneType")]
            public Dictionary<string, DroneTypeConfig> SettingsByDroneType = new Dictionary<string, DroneTypeConfig>
            {
                [BaseDroneType] = new DroneTypeConfig
                {
                    DefaultProfile = new DroneProfile
                    {
                        DamageScale = new Dictionary<string, float>
                        {
                            [DamageType.Generic.ToString()] = 0.1f,
                            [DamageType.Heat.ToString()] = 0.2f,
                            [DamageType.Bullet.ToString()] = 0.2f,
                            [DamageType.AntiVehicle.ToString()] = 0.25f,
                        },
                    },
                    ProfilesRequiringPermission = new[]
                    {
                        new DroneProfile
                        {
                            PermissionSuffix = "god",
                            DroneProperties = new DroneProperties
                            {
                                KillInWater = false,
                                DisableWhenHurtChance = 0,
                                MovementAcceleration = 30,
                                AltitudeAcceleration = 20,
                                LeanWeight = 0,
                            },
                            DamageScale = new Dictionary<string, float>
                            {
                                [DamageType.AntiVehicle.ToString()] = 0,
                                [DamageType.Arrow.ToString()] = 0,
                                [DamageType.Bite.ToString()] = 0,
                                [DamageType.Bleeding.ToString()] = 0,
                                [DamageType.Blunt.ToString()] = 0,
                                [DamageType.Bullet.ToString()] = 0,
                                [DamageType.Cold.ToString()] = 0,
                                [DamageType.ColdExposure.ToString()] = 0,
                                [DamageType.Collision.ToString()] = 0,
                                [DamageType.Decay.ToString()] = 0,
                                [DamageType.Drowned.ToString()] = 0,
                                [DamageType.ElectricShock.ToString()] = 0,
                                [DamageType.Explosion.ToString()] = 0,
                                [DamageType.Fall.ToString()] = 0,
                                [DamageType.Fun_Water.ToString()] = 0,
                                [DamageType.Generic.ToString()] = 0,
                                [DamageType.Heat.ToString()] = 0,
                                [DamageType.Hunger.ToString()] = 0,
                                [DamageType.Poison.ToString()] = 0,
                                [DamageType.Radiation.ToString()] = 0,
                                [DamageType.RadiationExposure.ToString()] = 0,
                                [DamageType.Slash.ToString()] = 0,
                                [DamageType.Stab.ToString()] = 0,
                                [DamageType.Suicide.ToString()] = 0,
                                [DamageType.Thirst.ToString()] = 0,
                            },
                        },
                    },
                },
                ["DroneBoombox"] = new DroneTypeConfig
                {
                    DefaultProfile = new DroneProfile
                    {
                        DroneProperties = new DroneProperties
                        {
                            MovementAcceleration = 7.5f,
                            AltitudeAcceleration = 7.5f,
                        },
                        DamageScale = new Dictionary<string, float>
                        {
                            [DamageType.Generic.ToString()] = 0.1f,
                            [DamageType.Heat.ToString()] = 0.1f,
                            [DamageType.Bullet.ToString()] = 0.1f,
                            [DamageType.AntiVehicle.ToString()] = 0.1f,
                        },
                    },
                },
                ["DroneChair"] = new DroneTypeConfig
                {
                    DefaultProfile = new DroneProfile
                    {
                        DroneProperties = new DroneProperties
                        {
                            MovementAcceleration = 7.5f,
                            AltitudeAcceleration = 7.5f,
                        },
                        DamageScale = new Dictionary<string, float>
                        {
                            [DamageType.Generic.ToString()] = 0.1f,
                            [DamageType.Heat.ToString()] = 0.1f,
                            [DamageType.Bullet.ToString()] = 0.1f,
                            [DamageType.AntiVehicle.ToString()] = 0.1f,
                        },
                    },
                },
                ["DroneSign"] = new DroneTypeConfig
                {
                    DefaultProfile = new DroneProfile
                    {
                        DroneProperties = new DroneProperties
                        {
                            MovementAcceleration = 7.5f,
                            AltitudeAcceleration = 7.5f,
                        },
                        DamageScale = new Dictionary<string, float>
                        {
                            [DamageType.Generic.ToString()] = 0.1f,
                            [DamageType.Heat.ToString()] = 0.1f,
                            [DamageType.Bullet.ToString()] = 0.1f,
                            [DamageType.AntiVehicle.ToString()] = 0.1f,
                        },
                    },
                },
                ["DroneStorage"] = new DroneTypeConfig
                {
                    DefaultProfile = new DroneProfile
                    {
                        DroneProperties = new DroneProperties
                        {
                            MovementAcceleration = 7.5f,
                            AltitudeAcceleration = 7.5f,
                        },
                        DamageScale = new Dictionary<string, float>
                        {
                            [DamageType.Generic.ToString()] = 0.1f,
                            [DamageType.Heat.ToString()] = 0.1f,
                            [DamageType.Bullet.ToString()] = 0.1f,
                            [DamageType.AntiVehicle.ToString()] = 0.1f,
                        },
                    },
                },
                ["DroneTurrets"] = new DroneTypeConfig
                {
                    DefaultProfile = new DroneProfile
                    {
                        DroneProperties = new DroneProperties
                        {
                            MovementAcceleration = 5,
                            AltitudeAcceleration = 5,
                        },
                        DamageScale = new Dictionary<string, float>
                        {
                            [DamageType.Generic.ToString()] = 0.1f,
                            [DamageType.Heat.ToString()] = 0.1f,
                            [DamageType.Bullet.ToString()] = 0.1f,
                            [DamageType.AntiVehicle.ToString()] = 0.1f,
                            [DamageType.Explosion.ToString()] = 0.75f,
                            [DamageType.Blunt.ToString()] = 0.75f,
                        },
                    },
                },
                ["MegaDrones"] = new DroneTypeConfig
                {
                    DefaultProfile = new DroneProfile
                    {
                        DroneProperties = new DroneProperties
                        {
                            DisableWhenHurtChance = 0,
                            MovementAcceleration = 20,
                            AltitudeAcceleration = 20,
                            KillInWater = false,
                            LeanWeight = 0.1f,
                        },
                        DamageScale = new Dictionary<string, float>
                        {
                            [DamageType.Generic.ToString()] = 0.1f,
                            [DamageType.Heat.ToString()] = 0.05f,
                            [DamageType.Bullet.ToString()] = 0.05f,
                            [DamageType.AntiVehicle.ToString()] = 0.1f,
                            [DamageType.Explosion.ToString()] = 0.1f,
                            [DamageType.Blunt.ToString()] = 0.25f,
                        },
                    },
                },
            };

            public void Init(DroneSettings plugin)
            {
                foreach (var entry in SettingsByDroneType)
                {
                    entry.Value.Init(plugin, entry.Key);
                }
            }

            public DroneProfile FindProfile(DroneSettings plugin, string droneType, ulong ownerId)
            {
                string alias;
                if (_droneTypeAliases.TryGetValue(droneType, out alias))
                {
                    droneType = alias;
                }

                DroneTypeConfig droneTypeConfig;
                return SettingsByDroneType.TryGetValue(droneType, out droneTypeConfig)
                    ? droneTypeConfig.GetProfileForOwner(plugin, ownerId)
                    : null;
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public virtual bool Migrate() => false;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw) | config.Migrate();
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion
    }
}


// --- End of file: RidableDrones_hVdQK.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/respawn-balance ---
// --- Original File Path: R/RespawnBalance/RespawnBalance.cs ---

﻿using System.Collections.Generic;
using UnityEngine;
using System.Reflection;
using System;
using System.IO;
using Newtonsoft.Json;
using System.Text;
using System.IO.Compression;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
    [Info("RespawnBalance", "Jake_Rich", "1.0.1")]
    [Description("Reset bed cooldown on death and configure metabolism when spawning.")]

    public partial class RespawnBalance : RustPlugin
    {
        public static RespawnBalance _plugin;
        public static FieldInfo BagField;
        public JSONFile<ConfigData> _settingsFile;
        public ConfigData Settings { get { return _settingsFile.Instance; } }
        public RespawnTypeEnum RespawnType = RespawnTypeEnum.Default;

        void Init()
        {
            _plugin = this;
            _settingsFile = new JSONFile<ConfigData>("RespawnBalance", ConfigLocation.Config);
            BagField = typeof(SleepingBag).GetField("unlockTime", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
            if (BagField == null)
            {
                PrintError("Warning! Didnt find bag field!");
            }
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!(entity is BasePlayer))
            {
                return;
            }
            SetCooldowns(entity as BasePlayer, entity.transform.position);
        }

        void OnServerCommand(ConsoleSystem.Arg args)
        {
            switch(args.cmd.FullName)
            {
                case "global.respawn":
                    {
                        RespawnType = RespawnTypeEnum.Default;
                        break;
                    }
                case "global.respawn_sleepingbag":
                    {
                        uint uInt = args.GetUInt(0, 0u);
                        if (uInt == 0u)
                        {
                            RespawnType = RespawnTypeEnum.Default;
                            return;
                        }
                        var bed = BaseNetworkable.serverEntities.Find(uInt);
                        if (bed == null)
                        {
                            RespawnType = RespawnTypeEnum.Default;
                            return;
                        }
                        if (!(bed is SleepingBag))
                        {
                            RespawnType = RespawnTypeEnum.Default;
                            return;
                        }
                        if (bed.ShortPrefabName == "sleepingbag_leather_deployed")
                        {
                            RespawnType = RespawnTypeEnum.SleepingBag;
                        }
                        else if (bed.ShortPrefabName == "bed_deployed")
                        {
                            RespawnType = RespawnTypeEnum.Bed;
                        }
                        else
                        {
                            RespawnType = RespawnTypeEnum.Default;
                        }
                        break;
                    }
            }
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            switch (RespawnType)
            {
                case RespawnTypeEnum.Default:
                    {
                        Settings.DefaultSpawnSettings.Apply(player);
                        break;
                    }
                case RespawnTypeEnum.SleepingBag:
                    {
                        Settings.SleepingBagSettings.Apply(player);
                        break;
                    }
                case RespawnTypeEnum.Bed:
                    {
                        Settings.BedSettings.Apply(player);
                        break;
                    }
            }
        }

        public class ConfigData
        {
            public int MaxCooldown = 300;
            public float CooldownPerDistance = 3f;

            public RespawnSettings DefaultSpawnSettings = new RespawnSettings(60f,100f,100f);
            public RespawnSettings SleepingBagSettings = new RespawnSettings(20f, 40f, 40f);
            public RespawnSettings BedSettings = new RespawnSettings(60f, 100f, 100f);
        }

        public class RespawnSettings
        {
            public float Health = 100f;
            public float Hunger;
            public float Water;

            public void Apply(BasePlayer player)
            {
                player.health = Health;
                player.metabolism.calories.value = Hunger;
                player.metabolism.hydration.value = Water;
            }

            public RespawnSettings()
            {

            }

            public RespawnSettings(float hp, float hunger, float water)
            {
                Health = hp;
                Hunger = hunger;
                Water = water;
            }
        }

        public enum RespawnTypeEnum
        {
            Default = 0,
            SleepingBag = 1,
            Bed = 2,
        }

        public void SetCooldowns(BasePlayer player, Vector3 deathPosition)
        {
            foreach (var bag in SleepingBag.FindForPlayer(player.userID, true))
            {
                float distance = bag.Distance2D(player);
                float targetCooldown = Mathf.Clamp(Settings.MaxCooldown - distance / Settings.CooldownPerDistance, 0, Settings.MaxCooldown);
                //Puts($"Target cooldown for distance {distance} is {targetCooldown}");
                if (bag.unlockSeconds < targetCooldown)
                {
                    SetBagCooldown(bag, targetCooldown);
                }
            }
        }

        public static void SetBagCooldown(SleepingBag bag, float cooldown)
        {
            BagField.SetValue(bag, UnityEngine.Time.realtimeSinceStartup + cooldown);
        }

        #region PlayerData

        public class BasePlayerData
        {
            [JsonIgnore]
            public BasePlayer Player { get; set; }

            public string userID { get; set; } = "";

            public BasePlayerData()
            {

            }
            public BasePlayerData(BasePlayer player) : base()
            {
                userID = player.UserIDString;
                Player = player;
            }
        }

        public class PlayerDataController<T> where T : BasePlayerData
        {
            [JsonPropertyAttribute(Required = Required.Always)]
            private Dictionary<string, T> playerData { get; set; } = new Dictionary<string, T>();
            private JSONFile<Dictionary<string, T>> _file;
            private Timer _timer;
            public IEnumerable<T> All { get { return playerData.Values; } }

            public PlayerDataController()
            {

            }

            public PlayerDataController(string filename = null)
            {
                if (filename == null)
                {
                    return;
                }
                _file = new JSONFile<Dictionary<string, T>>(filename);
                _timer = _plugin.timer.Every(120f, () =>
                {
                    _file.Save();
                });
            }

            public void Unload()
            {
                if (_file == null)
                {
                    return;
                }
                _file.Save();
            }

            public T Get(string identifer)
            {
                T data;
                if (!playerData.TryGetValue(identifer, out data))
                {
                    data = Activator.CreateInstance<T>();
                    playerData[identifer] = data;
                }
                return data;
            }

            public T Get(ulong userID)
            {
                return Get(userID.ToString());
            }

            public T Get(BasePlayer player)
            {
                var data = Get(player.UserIDString);
                data.Player = player;
                return data;
            }

            public bool Has(ulong userID)
            {
                return playerData.ContainsKey(userID.ToString());
            }

            public void Set(string userID, T data)
            {
                playerData[userID] = data;
            }

            public bool Remove(string userID)
            {
                return playerData.Remove(userID);
            }

            public void Update(T data)
            {
                playerData[data.userID] = data;
            }
        }

        #endregion

        #region Configuration Files

        public enum ConfigLocation
        {
            Data = 0,
            Config = 1,
            Logs = 2,
            Plugins = 3,
            Lang = 4,
            Custom = 5,
        }

        public class JSONFile<Type> where Type : class
        {
            private DynamicConfigFile _file;
            public string _name { get; set; }
            public Type Instance { get; set; }
            private ConfigLocation _location { get; set; }
            private string _path { get; set; }
            public bool SaveOnUnload = false;
            public bool Compressed = false;

            public JSONFile(string name, ConfigLocation location = ConfigLocation.Data, string path = null, string extension = ".json", bool saveOnUnload = false)
            {
                SaveOnUnload = saveOnUnload;
                _name = name.Replace(".json", "");
                _location = location;
                switch (location)
                {
                    case ConfigLocation.Data:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.DataDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Config:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.ConfigDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Logs:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.LogDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Lang:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.LangDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Custom:
                        {
                            _path = $"{path}/{name}{extension}";
                            break;
                        }
                }
                _file = new DynamicConfigFile(_path);
                _file.Settings = new JsonSerializerSettings() { ReferenceLoopHandling = ReferenceLoopHandling.Ignore };
                Init();
            }

            public virtual void Init()
            {
                _plugin.OnRemovedFromManager.Add(new Action<Plugin, PluginManager>(Unload));
                Load();
                Save();
                Load();
            }

            public virtual void Load()
            {
                if (Compressed)
                {
                    LoadCompressed();
                    return;
                }

                if (!_file.Exists())
                {
                    Save();
                }
                Instance = _file.ReadObject<Type>();
                if (Instance == null)
                {
                    Instance = Activator.CreateInstance<Type>();
                    Save();
                }
                return;
            }

            private void LoadCompressed()
            {
                string str = _file.ReadObject<string>();
                if (str == null || str == "")
                {
                    Instance = Activator.CreateInstance<Type>();
                    return;
                }
                using (var compressedStream = new MemoryStream(Convert.FromBase64String(str)))
                using (var zipStream = new GZipStream(compressedStream, CompressionMode.Decompress))
                using (var resultStream = new MemoryStream())
                {
                    var buffer = new byte[4096];
                    int read;

                    while ((read = zipStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        resultStream.Write(buffer, 0, read);
                    }

                    Instance = JsonConvert.DeserializeObject<Type>(Encoding.UTF8.GetString(resultStream.ToArray()));
                }
            }

            public virtual void Save()
            {
                if (Compressed)
                {
                    SaveCompressed();
                    return;
                }

                _file.WriteObject(Instance);
                return;
            }

            private void SaveCompressed()
            {
                using (var stream = new MemoryStream())
                {
                    using (GZipStream zipStream = new GZipStream(stream, CompressionMode.Compress))
                    {
                        byte[] bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(Instance));
                        zipStream.Write(bytes, 0, bytes.Length);
                        zipStream.Close();
                        _file.WriteObject(Convert.ToBase64String(stream.ToArray()));
                    }
                }
            }

            public virtual void Reload()
            {
                Load();
            }

            private void Unload(Plugin sender, PluginManager manager)
            {
                if (SaveOnUnload)
                {
                    Save();
                }
            }
        }

        #endregion

    }
}

// --- End of file: RespawnBalance.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/recycler-teleport ---
// --- Original File Path: R/RecyclerTeleport/RecyclerTeleport.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Recycler Teleport", "Norn/Arainrr", "1.1.1")]
    [Description("Teleport to recyclers via command.")]
    public class RecyclerTeleport : RustPlugin
    {
        private const string PERMISSION_USE = "recyclerteleport.use";
        private readonly List<Vector3> recyclerPositions = new List<Vector3>();

        private void Init()
        {
            permission.RegisterPermission(PERMISSION_USE, this);
            cmd.AddChatCommand(configData.command, this, nameof(RecyclerCommand));
        }

        private void OnServerInitialized() => Findrecycler();

        private void Findrecycler()
        {
            var monumentRecyclers = new Hash<string, List<Vector3>>();
            var monumentInfos = TerrainMeta.Path.Monuments.Where(x => !x.name.Contains("power substations") && !x.name.Contains("cave") && !x.name.Contains("tiny")).GroupBy(x => x.name).ToDictionary(x => x.Key, y => y.ToList());
            foreach (var entry in monumentInfos)
            {
                var monument = GameManager.server.FindPrefab(entry.Key);
                if (monument == null) continue;
                var monumentName = string.Empty;
                List<Vector3> recyclers = new List<Vector3>();
                foreach (var monumentInfo in entry.Value)
                {
                    monumentName = monumentInfo.displayPhrase.english.Replace("\n", "");
                    recyclers.AddRange(monument.gameObject.GetComponentsInChildren<Recycler>()?.Select(x => monumentInfo.transform.TransformPoint(x.transform.position)));
                }
                if (!string.IsNullOrEmpty(monumentName) && recyclers.Count > 0)
                {
                    if (!monumentRecyclers.ContainsKey(monumentName))
                        monumentRecyclers.Add(monumentName, recyclers);
                    else monumentRecyclers[monumentName].AddRange(recyclers);
                }
            }
            foreach (var entry in monumentRecyclers)
            {
                if (!configData.monumentBlockList.ContainsKey(entry.Key))
                    configData.monumentBlockList.Add(entry.Key, false);
                else if (configData.monumentBlockList[entry.Key]) continue;
                recyclerPositions.AddRange(entry.Value);
            }
            SaveConfig();
            Puts($"{recyclerPositions.Count} recyclers found.");
        }

        private void TeleportToRecycler(BasePlayer player)
        {
            Vector3 position = recyclerPositions.GetRandom() + new Vector3(0f, 1.5f, 0f);
            timer.Once(configData.teleportSeconds, () =>
            {
                if (!player.IsConnected) return;
                player.EnsureDismounted();
                player.SetParent(null, true, true);
                player.ClientRPCPlayer(null, player, "StartLoading");
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
                player.Teleport(position);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
                player.UpdateNetworkGroup();
                player.SendNetworkUpdateImmediate();
                player.SendFullSnapshot();
            });
            Print(player, Lang("Teleporting", player.UserIDString, configData.teleportSeconds.ToString()));
        }

        private void RecyclerCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NoPermission", player.UserIDString));
                return;
            }
            if (recyclerPositions.Count == 0)
            {
                Print(player, Lang("NoRecyclers", player.UserIDString));
                return;
            }
            object canTeleport = Interface.CallHook("CanTeleport", player);
            if (canTeleport is string)
            {
                Print(player, (string)canTeleport);
                return;
            }
            TeleportToRecycler(player);
        }

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Chat command")]
            public string command = "recycler";

            [JsonProperty(PropertyName = "Chat prefix")]
            public string prefix = "[RecyclerTeleport]:";

            [JsonProperty(PropertyName = "Chat prefix color")]
            public string prefixColor = "#00FFFF";

            [JsonProperty(PropertyName = "Chat steamID icon")]
            public ulong steamIDIcon = 0;

            [JsonProperty(PropertyName = "Teleport seconds")]
            public float teleportSeconds = 10f;

            [JsonProperty(PropertyName = "Block list")]
            public Dictionary<string, bool> monumentBlockList = new Dictionary<string, bool>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile

        #region LanguageFile

        private void Print(BasePlayer player, string message) => Player.Message(player, message, $"<color={configData.prefixColor}>{configData.prefix}</color>", configData.steamIDIcon);

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "<color=#FFFF00>You don't have permission to use this command.</color>",
                ["Teleporting"] = "Teleporting to recycler in <color=#FFFF00>{0}</color> seconds.",
                ["NoRecyclers"] = "No recyclers found."
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "<color=#FFFF00>您没有使用该命令的权限</color>",
                ["Teleporting"] = "<color=#FFFF00>{0}</color> 秒后，您将传送到分解机",
                ["NoRecyclers"] = "服务器上没有找到任何分解机"
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: RecyclerTeleport.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/referral ---
// --- Original File Path: R/Referral/Referral.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{

    [Info("Referral", "birthdates", "0.1", ResourceId = 0)]
    public class Referral : RustPlugin
    {

        private new void LoadDefaultConfig()
        {
            PrintWarning("Loading the dafault config file! ../oxide/config/Referral");
            Config["GrantedPermission"] = "referral.use";
            
            
        }

        void Loaded()
        {
            permission.RegisterPermission("referral.use", this);
            if (!permission.PermissionExists(Config["GrantedPermission"].ToString()))
            {
                PrintWarning("ERROR: The permission you are trying to use for the referral command doesn't exist! So we have set it to referral.use");
                Config["GrantedPermission"] = "referral.use";
                SaveConfig();

            }

        }


        private new void LoadDefaultMessages()
        {
            PrintWarning("Loading the language file! ../oxide/lang/en");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoPermission", "You don't have permission."},
                {"ThankYouMessage", "Thank you for inviting {0} to the server! For this we have granted you a special permission."},
                {"SuccessMessage", "Thanks for joining the server! {0} will now get their reward" },
                {"SuccessMessage_2", "You have successfuly used the code {0}."},
                {"ValidArgs", "ERROR: Please specify a valid player/code to refer/use. Make sure they are online!" },
                {"ValidArgsConsole", "ERROR: Please specify valid arguments! Usage: refercode.add <code> <permission>"},
                {"AlreadyReferred","ERROR: You have already referred a user."},
                {"CodeAlreadyUsed", "ERROR: You have already used this code." },
                {"ValidCode", "ERROR: Please use a valid code." },
                {"PermDoesNotExist", "ERROR: That permission doesn't exist!"},
                {"LongerCode", "ERROR: Due to security reasons you need to have a code that has nine or more numbers."}

            }, this);
        }


        [ConsoleCommand("refercodes")]
        void codeList(ConsoleSystem.Arg arg)
        {
            if (Config["codes"] != null)
            {
                arg.ReplyWith(Config["codes"].ToString());
            } else
            {
                arg.ReplyWith("There are no codes yet.");
            }
        }


        [ConsoleCommand("refercode.add")]
        void addReferralCode(ConsoleSystem.Arg arg)
        {
            if (arg.HasArgs(2))
            {
                long code = 0;
                if(arg.GetString(0) == "random")
                {
                    System.Random r = new System.Random();


                    int num1 = r.Next(1,11);
                    int num2 = r.Next(1, 11);
                    int num3 = r.Next(1, 11);
                    int num4 = r.Next(1, 11);
                    int num5 = r.Next(1, 11);
                    int num6 = r.Next(1, 11);
                    int num7 = r.Next(1, 11);
                    int num8 = r.Next(1, 11);
                    int num9 = r.Next(1, 11);
                    code = Convert.ToInt64(num1.ToString() + num2.ToString() + num3.ToString() + num4.ToString() + num5.ToString() + num6.ToString() + num7.ToString() + num8.ToString() + num9.ToString());
                } else
                {
                    code = arg.GetInt(0);
                }
                 
                string cPermission = arg.GetString(1);
                if (Config[code.ToString()] != null)
                {
                    arg.ReplyWith("ERROR: The code already exists.");
                }
                else if(code.ToString().Length < 9)
                {
                    arg.ReplyWith(lang.GetMessage("LongerCode", this));
                }
                else if (!permission.PermissionExists(cPermission))
                {
                    arg.ReplyWith(lang.GetMessage("PermDoesNotExist", this));
                }
                
                else
                {
                    arg.ReplyWith("Success! We have made " + code + " a new code players can use to get the permission: " + cPermission + "!");
                    if (Config["codes"] == null)
                    {
                        Config["codes"] = code.ToString();

                    } else
                    {
                        Config["codes"] = Config["codes"] + ", " + code;
                    }
                       
                    Config[code.ToString()] = cPermission;
                    Config[code.ToString() + "_USES"] = 0;
                    SaveConfig();
                }
            } else
            {
                arg.ReplyWith(lang.GetMessage("ValidArgsConsole",this));
            }

        }

        [ChatCommand("refer")]
        void referCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "referral.use"))
            {
                SendReply(player, lang.GetMessage("NoPermission", this));
            }
            else
            {

                 if (args.Length == 1)
                {
                    BasePlayer p = BasePlayer.Find(args[0]);
                    if (p != null) //&& args[0] != player.displayName)
                    {
                        if (Config[player.UserIDString] != null)
                        {
                            SendReply(player, lang.GetMessage("AlreadyReferred", this));
                        } else
                        {
                            permission.GrantUserPermission(p.UserIDString, Config["GrantedPermission"].ToString(), this);
                            SendReply(player, lang.GetMessage("SuccessMessage", this), p.displayName);
                            SendReply(p, lang.GetMessage("ThankYouMessage", this), player.displayName);
                            Config[player.UserIDString] = "USED_THEIR_REFERRAL";
                            SaveConfig();
                        }
                       
                        
                    }
                    else
                    {
                        long code;
                        if (long.TryParse(args[0], out code))
                        {
                            if(Config[player.UserIDString + code.ToString()] != null)
                            {
                                SendReply(player, lang.GetMessage("CodeAlreadyUsed", this));
                            }
                            else if(Config[code.ToString()] != null)
                            {
                                permission.GrantUserPermission(player.UserIDString, Config[code.ToString()].ToString(), this);
                                SendReply(player, lang.GetMessage("SuccessMessage_2", this), code.ToString());
                                Config[player.UserIDString + code.ToString()] = true;
                                int currentUses = Convert.ToInt32(Config[code.ToString() + "_USES"]);
                                currentUses++;
                                Config[code.ToString() + "_USES"] = currentUses.ToString();
                                SaveConfig();
                            } else
                            {
                                SendReply(player, lang.GetMessage("ValidCode", this));
                            }
                        }
                        else
                        {
                         