   SendReply(player, lang.GetMessage("ValidArgs", this));
                        }
                    }
                }
                else
                {
                    SendReply(player, lang.GetMessage("ValidArgs", this));
                }
            }
        }

    }
}

// --- End of file: Referral.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rocket-fire ---
// --- Original File Path: R/RocketFire/RocketFire.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Rocket Fire", "birthdates", "1.0.4")]
    [Description("Ability to fire x amount of rockets at once")]
    public class RocketFire : RustPlugin
    {
        #region Variables
        private const string Perm = "rocketfire.use";
        #endregion

        #region Hooks
        private void Init()
        {
            permission.RegisterPermission(Perm, this);
            LoadConfig();
        }

        [ConsoleCommand("fr")]
        private void FireRocketsConsoleCMD(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null)
            {
                player.ChatMessage(lang.GetMessage("PlayerOnlyCommand", this, player.UserIDString));
                return;
            }
            FRCommand(player, arg.Args);
        }

        [ChatCommand("fr")]
        private void FireRocketsCMD(BasePlayer player, string command, string[] args) => FRCommand(player, args);

        private void FRCommand(BasePlayer player, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, Perm) && !player.IsAdmin)
            {
                SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }

            if (args.Length < 1)
            {
                SendReply(player, lang.GetMessage("InvalidArgs", this, player.UserIDString));
            }
            else
            {
                int amount;
                if (!int.TryParse(args[0], out amount))
                {
                    SendReply(player, lang.GetMessage("InvalidNumber", this, player.UserIDString));
                }
                else
                {
                    
                    if (amount > _config.maxRockets)
                    {
                        SendReply(player, string.Format(lang.GetMessage("TooManyRockets", this, player.UserIDString), _config.maxRockets));
                        return;
                    }
                    if (!StringPool.toString.ContainsValue(
                        $"assets/prefabs/ammo/rocket/{_config.rocketType}.prefab"))
                    {
                        SendReply(player, lang.GetMessage("InvalidPrefab", this, player.UserIDString));
                        return;
                    }
                    
                    var pos = player.eyes.position;
                    var forward = player.eyes.HeadForward();
                    var rot = player.transform.rotation;
                    var aim = player.serverInput.current.aimAngles;
                    var staticPos = _config.staticRockets ? pos + forward : default(Vector3);
                    timer.Repeat(_config.delay, amount, delegate
                    {
                        
                        var rocket = GameManager.server.CreateEntity($"assets/prefabs/ammo/rocket/{_config.rocketType}.prefab",
                           _config.staticRockets ? staticPos : player.eyes.position + player.eyes.HeadForward(), _config.staticRockets ? rot : player.transform.rotation);
                        if (rocket == null) return;
                        var proj = rocket.GetComponent<ServerProjectile>();
                        if (proj == null) return;
                        proj.InitializeVelocity(Quaternion.Euler(_config.staticRockets ? aim : player.serverInput.current.aimAngles) * rocket.transform.forward * _config.velocity);

                        rocket.Spawn();
                    });
                    SendReply(player, string.Format(lang.GetMessage("RocketsFired", this, player.UserIDString), amount));
                }
            }
        }

        #endregion
    
        #region Configuration & Language
        public ConfigFile _config;

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string,string>
            {
                {"TooManyRockets", "You have attempted to fire too many rockets, you can only fire {0} at once!"},
                {"RocketsFired", "You have launched {0} rockets"},
                {"NoPermission", "You have no permission!"},
                {"InvalidArgs", "/fr <amount of rockets to fire>"},
                {"InvalidNumber", "That is not a valid number!"},
                {"InvalidPrefab", "Please fix the rocket type in the configuration file, that is not a valid rocket type!"},
                {"PlayerOnlyCommand", "This player is only accesible by players."}
            }, this);
        }

        public class ConfigFile
        {
            [JsonProperty("Max amount of rockets to fire at once")]
            public int maxRockets;
            [JsonProperty("Delay in between multiple rocket shots (e.g /fr 10)")]
            public float delay;
            [JsonProperty("Rockets fire at the same position if you move when you shoot multiple (e.g /fr 10)")]
            public bool staticRockets;
            [JsonProperty("The rocket velocity")]
            public float velocity;
            [JsonProperty("The rocket type")]
            public string rocketType;
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                    maxRockets = 100,
                    delay = 0.2f,
                    staticRockets = false,
                    velocity = 22,
                    rocketType = "rocket_basic"
                };
            }
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if(_config == null)
            {
                LoadDefaultConfig();
            }
        }
    
        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion
    }
}
//Generated with birthdates' Plugin Maker


// --- End of file: RocketFire.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ridable-drones ---
// --- Original File Path: R/RidableDrones/RidableDrones.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Ridable Drones", "WhiteThunder", "2.0.3")]
    [Description("Allows players to deploy signs and chairs onto RC drones to allow riding them.")]
    internal class RidableDrones : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin DroneSettings;

        private Configuration _config;

        private const string PermissionSignDeploy = "ridabledrones.sign.deploy";
        private const string PermissionSignDeployFree = "ridabledrones.sign.deploy.free";

        private const string PermissionChairDeploy = "ridabledrones.chair.deploy";
        private const string PermissionChairDeployFree = "ridabledrones.chair.deploy.free";
        private const string PermissionChairAutoDeploy = "ridabledrones.chair.autodeploy";
        private const string PermissionChairPilot = "ridabledrones.chair.pilot";

        private const string SmallWoodenSignPrefab = "assets/prefabs/deployable/signs/sign.small.wood.prefab";
        private const string DeploySignEffectPrefab = "assets/prefabs/deployable/signs/effects/wood-sign-deploy.prefab";

        private const string PilotChairPrefab = "assets/prefabs/vehicle/seats/miniheliseat.prefab";
        private const string PassengerChairPrefab = "assets/prefabs/deployable/chair/chair.deployed.prefab";
        private const string VisibleChairPrefab = "assets/prefabs/vehicle/seats/passengerchair.prefab";
        private const string ChairDeployEffectPrefab = "assets/prefabs/deployable/chair/effects/chair-deploy.prefab";

        private const int SignItemId = -1138208076;
        private const int ChairItemId = 1534542921;

        private static SlotConfig ChairSlots = new(BaseEntity.Slot.UpperModifier);
        private static SlotConfig SignSlots = new(BaseEntity.Slot.MiddleModifier, BaseEntity.Slot.UpperModifier);

        private readonly object True = true;
        private readonly object False = false;

        private static readonly Vector3 SignLocalPosition = new(0, 0.114f, 0.265f);
        private static readonly Vector3 SignLocalRotationAngles = new(270, 0, 0);
        private static readonly Vector3 PassengerChairLocalPosition = new(0, 0.081f, 0);
        private static readonly Vector3 PilotChairLocalPosition = new(-0.006f, 0.027f, 0.526f);

        private readonly Dictionary<string, object> _signRemoveInfo = new();
        private readonly Dictionary<string, object> _refundInfo = new()
        {
            ["sign.wooden.small"] = new Dictionary<string, object>
            {
                ["Amount"] = 1,
            },
        };

        private readonly Dictionary<string, object> _chairRemoveInfo = new();
        private readonly Dictionary<string, object> _chairRefundInfo = new()
        {
            ["chair"] = new Dictionary<string, object>
            {
                ["Amount"] = 1,
            },
        };

        private readonly ObservableHashSet<BaseEntity> _chairDrones = new();
        private readonly ObservableHashSet<BaseEntity> _mountedChairDrones = new();
        private readonly ObservableHashSet<BaseEntity> _signDrones = new();

        private readonly GatedHookCollection[] _hookCollections;

        public RidableDrones()
        {
            var anySignDrones = new ObservableGate(_chairDrones, () => _chairDrones.Count > 0);
            var anyChairDrones = new ObservableGate(_chairDrones, () => _chairDrones.Count > 0);
            var anyChairDronesMounted = new ObservableGate(_mountedChairDrones, () => _mountedChairDrones.Count > 0);

            _hookCollections = new[]
            {
                new GatedHookCollection(
                    this,
                    anyChairDrones,
                    nameof(OnEntityMounted),
                    nameof(OnEntityDismounted),
                    nameof(OnPlayerDismountFailed)
                ),
                new GatedHookCollection(
                    this,
                    anyChairDronesMounted,
                    nameof(OnServerCommand)
                ),
                new GatedHookCollection(
                    this,
                    new MultiObservableGate(anySignDrones, anyChairDrones),
                    nameof(OnEntityTakeDamage),
                    nameof(CanPickupEntity),
                    nameof(OnRemovableEntityInfo),
                    nameof(canRemove)
                ),
            };
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionSignDeploy, this);
            permission.RegisterPermission(PermissionSignDeployFree, this);

            permission.RegisterPermission(PermissionChairDeploy, this);
            permission.RegisterPermission(PermissionChairDeployFree, this);
            permission.RegisterPermission(PermissionChairAutoDeploy, this);
            permission.RegisterPermission(PermissionChairPilot, this);

            Unsubscribe(nameof(OnEntitySpawned));

            foreach (var hookCollection in _hookCollections)
            {
                hookCollection.Unsubscribe();
            }
        }

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null || !IsDroneEligible(drone))
                    continue;

                MaybeRefreshDroneSign(drone);
                MaybeAddOrRefreshChairs(drone);
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                var drone = GetMountedDrone(player, out var currentChair);
                if (drone == null)
                    continue;

                if (!TryGetChairs(drone, out var pilotChair, out _))
                    continue;

                if (!permission.UserHasPermission(player.UserIDString, PermissionChairPilot))
                    continue;

                var isPilotChair = currentChair == pilotChair;
                DroneController.Mount(this, player, drone, isPilotChair);
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null)
                    continue;

                var sign = GetDroneSign(drone);
                if (sign != null)
                {
                    SignComponent.RemoveFromSign(sign);
                }

                if (TryGetPassengerChair(drone, out var passengerChair))
                {
                    ChairComponent.RemoveFromChair(passengerChair);
                }
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                DroneController.RemoveFromPlayer(player);
            }
        }

        private void OnEntitySpawned(Drone drone)
        {
            if (!IsDroneEligible(drone))
                return;

            var drone2 = drone;

            // Delay to give other plugins a moment to cache the drone id so they can block this.
            NextTick(() =>
            {
                if (drone2 == null || drone2.IsDestroyed)
                    return;

                MaybeAutoDeployChair(drone2);
            });
        }

        private void OnEntityBuilt(Planner planner, GameObject go)
        {
            if (planner == null || go == null)
                return;

            var drone = go.ToBaseEntity() as Drone;
            if (drone == null)
                return;

            var player = planner.GetOwnerPlayer();
            if (player == null)
                return;

            var drone2 = drone;

            NextTick(() =>
            {
                // Delay this check to allow time for other plugins to deploy an entity to this slot.
                if (drone2 == null || player == null)
                    return;

                if (SignSlots.IsCompatibleWithHost(drone2)
                    && permission.UserHasPermission(player.UserIDString, PermissionSignDeploy)
                    && UnityEngine.Random.Range(0, 100) < _config.SignTipChance)
                {
                    ChatMessage(player, Lang.TipDeploySignCommand);
                }

                if (ChairSlots.IsCompatibleWithHost(drone2)
                    && permission.UserHasPermission(player.UserIDString, PermissionChairDeploy)
                    && !permission.UserHasPermission(player.UserIDString, PermissionChairAutoDeploy)
                    && UnityEngine.Random.Range(0, 100) < _config.ChairTipChance)
                {
                    ChatMessage(player, Lang.TipDeployChairCommand);
                }
            });
        }

        private object OnEntityTakeDamage(BaseChair mountable, HitInfo info)
        {
            if (mountable.PrefabName != PassengerChairPrefab)
                return null;

            var drone = GetParentDrone(mountable);
            if (drone == null)
                return null;

            drone.Hurt(info);
            HitNotify(drone, info);

            return True;
        }

        private object OnEntityTakeDamage(Signage sign, HitInfo info)
        {
            var drone = GetParentDrone(sign);
            if (drone == null)
                return null;

            drone.Hurt(info);
            HitNotify(drone, info);

            return True;
        }

        // Allow swapping between between the seating modes
        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.cmd.FullName != "vehicle.swapseats")
                return;

            var player = arg.Player();
            if (player == null)
                return;

            var drone = GetMountedDrone(player, out var currentChair);
            if (drone == null)
                return;

            // Only players with the pilot permission may switch chairs.
            if (!permission.UserHasPermission(player.UserIDString, PermissionChairPilot))
                return;

            if (!TryGetChairs(drone, out var pilotChair, out var passengerChair))
                return;

            var desiredChair = currentChair == passengerChair
                ? pilotChair
                : passengerChair;

            SwitchToChair(player, currentChair, desiredChair);
        }

        private void OnEntityMounted(BaseMountable currentChair, BasePlayer player)
        {
            var drone = GetParentDrone(currentChair);
            if (drone == null)
                return;

            if (!TryGetChairs(drone, out var pilotChair, out var passengerChair))
                return;

            // The rest of the logic is only for pilots.
            if (!permission.UserHasPermission(player.UserIDString, PermissionChairPilot))
                return;

            var isPilotChair = currentChair == pilotChair;
            if (isPilotChair)
            {
                // Since the passenger chair is the mount ingress, prevent it from being mounted while the pilot chair is mounted.
                passengerChair.SetFlag(BaseEntity.Flags.Busy, true);
            }
            else if (!DroneController.Exists(player))
            {
                // The player is mounting the drone fresh (not switching chairs), so automatically switch to the pilot chair.
                SwitchToChair(player, currentChair, pilotChair);
                return;
            }

            DroneController.Mount(this, player, drone, isPilotChair);
        }

        private void OnEntityDismounted(BaseMountable previousChair, BasePlayer player)
        {
            var drone = GetParentDrone(previousChair);
            if (drone == null)
                return;

            if (!TryGetChairs(drone, out var pilotChair, out var passengerChair))
                return;

            if (previousChair == pilotChair)
            {
                // Since the passenger chair is the mount ingress, re-enable it when the pilot chair is dismounted.
                passengerChair.SetFlag(BaseEntity.Flags.Busy, false);
            }

            DroneController.Dismount(this, player, drone);
        }

        private void OnPlayerDismountFailed(BasePlayer player, BaseMountable mountable)
        {
            var drone = GetMountedDrone(player);
            if (drone == null)
                return;

            var droneTransform = drone.transform;
            droneTransform.rotation = Quaternion.Euler(0, droneTransform.rotation.eulerAngles.y, 0);
        }

        private object CanPickupEntity(BasePlayer player, Drone drone)
        {
            if (CanPickupInternal(drone, out var errorLangKey))
                return null;

            ChatMessage(player, errorLangKey);
            return False;
        }

        private object CanPickupEntity(BasePlayer player, Signage sign)
        {
            if (CanPickupInternal(sign, out var errorLangKey))
                return null;

            ChatMessage(player, errorLangKey);
            return False;
        }

        private object CanPickupEntity(BasePlayer player, BaseChair chair)
        {
            if (CanPickupInternal(chair, out var errorLangKey))
                return null;

            ChatMessage(player, errorLangKey);
            return False;
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        private Dictionary<string, object> OnRemovableEntityInfo(Signage sign, BasePlayer player)
        {
            if (!IsDroneSign(sign))
                return null;

            _signRemoveInfo["DisplayName"] = GetMessage(player.UserIDString, Lang.InfoSignName);

            if (sign.pickup.enabled)
            {
                _signRemoveInfo["Refund"] = _refundInfo;
            }
            else
            {
                _signRemoveInfo.Remove("Refund");
            }

            return _signRemoveInfo;
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        private Dictionary<string, object> OnRemovableEntityInfo(BaseChair chair, BasePlayer player)
        {
            if (!IsDroneChair(chair))
                return null;

            _chairRemoveInfo["DisplayName"] = GetMessage(player.UserIDString, Lang.InfoChairName);

            if (chair.pickup.enabled)
            {
                _chairRemoveInfo["Refund"] = _chairRefundInfo;
            }
            else
            {
                _chairRemoveInfo.Remove("Refund");
            }

            return _chairRemoveInfo;
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        private string canRemove(BasePlayer player, Drone drone)
        {
            if (CanPickupInternal(drone, out var errorLangKey))
                return null;

            return GetMessage(player.UserIDString, errorLangKey);
        }

        // This hook is exposed by plugin: Drone Settings (DroneSettings).
        private string OnDroneTypeDetermine(Drone drone, List<string> droneTypeList)
        {
            var droneType = DetermineDroneType(drone);
            if (droneType == null)
                return null;

            if (droneTypeList == null)
                return droneType;

            droneTypeList.Add(droneType);
            return null;
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnDroneSignDeploy(Drone drone, BasePlayer deployer)
            {
                return Interface.CallHook("OnDroneSignDeploy", drone, deployer);
            }

            public static void OnDroneSignDeployed(Drone drone, BasePlayer deployer)
            {
                Interface.CallHook("OnDroneSignDeployed", drone, deployer);
            }

            public static object OnDroneChairDeploy(Drone drone, BasePlayer deployer)
            {
                return Interface.CallHook("OnDroneChairDeploy", drone, deployer);
            }

            public static void OnDroneChairDeployed(Drone drone, BasePlayer deployer)
            {
                Interface.CallHook("OnDroneChairDeployed", drone, deployer);
            }

            public static void OnDroneControlStarted(Drone drone, BasePlayer player)
            {
                Interface.CallHook("OnDroneControlStarted", drone, player);
            }

            public static void OnDroneControlEnded(Drone drone, BasePlayer player)
            {
                Interface.CallHook("OnDroneControlEnded", drone, player);
            }
        }

        #endregion

        #region Commands

        [Command("dronesign")]
        private void DroneSignCommand(IPlayer player)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyPermission(player, PermissionSignDeploy)
                || !VerifyDroneFound(player, out var drone))
                return;

            if (GetDroneSign(drone) != null)
            {
                ReplyToPlayer(player, Lang.ErrorAlreadyHasSign);
                return;
            }

            if (!VerifyDroneHasSlotVacant(player, drone, SignSlots))
                return;

            var isFree = player.HasPermission(PermissionSignDeployFree);
            if (!isFree && basePlayer.inventory.FindItemByItemID(SignItemId) == null)
            {
                ReplyToPlayer(player, Lang.ErrorNoSignItem);
                return;
            }

            if (TryDeploySign(drone, basePlayer, allowRefund: !isFree) == null)
            {
                ReplyToPlayer(player, Lang.ErrorDeploySignFailed);
            }
            else if (!isFree)
            {
                basePlayer.inventory.Take(null, SignItemId, 1);
                basePlayer.Command("note.inv", SignItemId, -1);
            }
        }

        [Command("dronechair", "droneseat")]
        private void DroneChairCommand(IPlayer player)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyPermission(player, PermissionChairDeploy)
                || !VerifyDroneFound(player, out var drone))
                return;

            if (HasChair(drone))
            {
                ReplyToPlayer(player, Lang.ErrorAlreadyHasChair);
                return;
            }

            if (!VerifyDroneHasSlotVacant(player, drone, ChairSlots))
                return;

            var isFree = player.HasPermission(PermissionChairDeployFree);
            if (!isFree && basePlayer.inventory.FindItemByItemID(ChairItemId) == null)
            {
                ReplyToPlayer(player, Lang.ErrorNoChairItem);
                return;
            }

            if (TryDeployChairs(drone, basePlayer, allowRefund: !isFree) == null)
            {
                ReplyToPlayer(player, Lang.ErrorDeployChairFailed);
            }
            else if (!isFree)
            {
                basePlayer.inventory.Take(null, ChairItemId, 1);
                basePlayer.Command("note.inv", ChairItemId, -1);
            }
        }

        #endregion

        #region Helper Methods - Command Checks

        private bool VerifyPlayer(IPlayer player, out BasePlayer basePlayer)
        {
            basePlayer = player.Object as BasePlayer;
            return !player.IsServer && basePlayer != null;
        }

        private bool VerifyPermission(IPlayer player, string perm)
        {
            if (player.HasPermission(perm))
                return true;

            ReplyToPlayer(player, Lang.ErrorNoPermission);
            return false;
        }

        private bool VerifyDroneFound(IPlayer player, out Drone drone)
        {
            var basePlayer = player.Object as BasePlayer;
            drone = GetLookEntity(basePlayer, 3) as Drone;
            if (drone != null && IsDroneEligible(drone))
                return true;

            ReplyToPlayer(player, Lang.ErrorNoDroneFound);
            return false;
        }

        private bool VerifyDroneHasSlotVacant(IPlayer player, Drone drone, SlotConfig slotConfig)
        {
            if (slotConfig.IsCompatibleWithHost(drone))
                return true;

            ReplyToPlayer(player, Lang.ErrorIncompatibleAttachment);
            return false;
        }

        #endregion

        #region Helpers

        private static class RCUtils
        {
            public static bool IsRCDrone(Drone drone)
            {
                return drone is not DeliveryDrone;
            }
        }

        private static bool IsDroneEligible(Drone drone)
        {
            return drone.skinID == 0 && RCUtils.IsRCDrone(drone);
        }

        private static Drone GetParentDrone(BaseEntity entity)
        {
            return entity.GetParentEntity() as Drone;
        }

        private static Drone GetMountedDrone(BasePlayer player, out BaseMountable currentChair)
        {
            currentChair = player.GetMounted();
            if (currentChair == null)
                return null;

            return currentChair.PrefabName == PilotChairPrefab || currentChair.PrefabName == PassengerChairPrefab
                ? GetParentDrone(currentChair)
                : null;
        }

        private static Drone GetMountedDrone(BasePlayer player)
        {
            return GetMountedDrone(player, out _);
        }

        private static Signage GetDroneSign(Drone drone)
        {
            return SignSlots.GetOccupant(drone) as Signage;
        }

        private static bool IsDroneSign(Signage sign)
        {
            return GetParentDrone(sign) != null;
        }

        private static bool TryGetChairs(Drone drone, out BaseMountable pilotChair, out BaseMountable passengerChair, out BaseMountable visibleChair)
        {
            pilotChair = null;
            passengerChair = null;
            visibleChair = null;

            foreach (var child in drone.children)
            {
                var mountable = child as BaseMountable;
                if (mountable == null)
                    continue;

                if (mountable.PrefabName == PilotChairPrefab)
                {
                    pilotChair = mountable;
                }

                if (mountable.PrefabName == PassengerChairPrefab)
                {
                    passengerChair = mountable;
                }

                if (mountable.PrefabName == VisibleChairPrefab)
                {
                    visibleChair = mountable;
                }
            }

            return pilotChair != null && passengerChair != null && visibleChair != null;
        }

        private static bool TryGetChairs(Drone drone, out BaseMountable pilotChair, out BaseMountable passengerChair)
        {
            return TryGetChairs(drone, out pilotChair, out passengerChair, out _);
        }

        private static bool TryGetPassengerChair(Drone drone, out BaseMountable passengerChair)
        {
            return TryGetChairs(drone, out _, out passengerChair, out _);
        }

        private static bool HasChair(Drone drone)
        {
            return TryGetPassengerChair(drone, out _);
        }

        private static bool IsDroneChair(BaseChair chair)
        {
            return GetParentDrone(chair) != null;
        }

        private static void HitNotify(BaseEntity entity, HitInfo info)
        {
            var player = info.Initiator as BasePlayer;
            if (player == null)
                return;

            entity.ClientRPCPlayer(null, player, "HitNotify");
        }

        private static void RemoveProblemComponents(BaseEntity entity)
        {
            foreach (var collider in entity.GetComponentsInChildren<MeshCollider>())
            {
                UnityEngine.Object.DestroyImmediate(collider);
            }
        }

        private static void SetupChair(BaseMountable mountable)
        {
            if (!BaseMountable.AllMountables.Contains(mountable))
            {
                BaseMountable.AllMountables.Add(mountable);
            }

            mountable.isMobile = true;
            mountable.EnableSaving(true);
            RemoveProblemComponents(mountable);
        }

        private static BaseEntity GetLookEntity(BasePlayer basePlayer, float maxDistance = 3)
        {
            return Physics.Raycast(basePlayer.eyes.HeadRay(), out var hit, maxDistance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore)
                ? hit.GetEntity()
                : null;
        }

        private static void SwitchToChair(BasePlayer player, BaseMountable currentChair, BaseMountable desiredChair)
        {
            currentChair.DismountPlayer(player, lite: true);
            desiredChair.MountPlayer(player);
        }

        private static string DetermineDroneType(Drone drone)
        {
            if (GetDroneSign(drone) != null)
                return "DroneSign";

            if (HasChair(drone))
                return "DroneChair";

            return null;
        }

        private static bool CanPickupInternal(Drone drone, out string errorLangKey)
        {
            errorLangKey = null;

            if (!RCUtils.IsRCDrone(drone))
                return true;

            // Prevent drone pickup while there is a sign attached that can be picked up.
            var sign = GetDroneSign(drone);
            if (sign != null)
            {
                errorLangKey = Lang.ErrorCannotPickupWithSign;
                return !sign.pickup.enabled;
            }

            // Prevent drone pickup while there is a chair attached that can be picked up.
            if (TryGetPassengerChair(drone, out var passengerChair))
            {
                errorLangKey = Lang.ErrorCannotPickupWithChair;
                return !passengerChair.pickup.enabled;
            }

            return true;
        }

        private static bool CanPickupInternal(Signage sign, out string errorLangKey)
        {
            errorLangKey = null;

            if (!IsDroneSign(sign))
                return true;

            errorLangKey = Lang.ErrorCannotPickupAttachment;
            return sign.pickup.enabled;
        }

        private static bool CanPickupInternal(BaseChair chair, out string errorLangKey)
        {
            errorLangKey = null;

            if (!IsDroneChair(chair))
                return true;

            errorLangKey = Lang.ErrorCannotPickupAttachment;
            return chair.pickup.enabled;
        }

        private void RefreshDroneSettingsProfile(Drone drone)
        {
            DroneSettings?.Call("API_RefreshDroneProfile", drone);
        }

        private void SetupSign(Drone drone, Signage sign)
        {
            drone.playerCheckRadius = 0;

            // Damage will be processed by the drone.
            sign.baseProtection = null;

            UnityEngine.Object.DestroyImmediate(sign.GetComponent<GroundWatch>());
            UnityEngine.Object.DestroyImmediate(sign.GetComponent<DestroyOnGroundMissing>());

            SignComponent.AddToDrone(this, drone, sign);
        }

        private Signage TryDeploySign(Drone drone, BasePlayer deployer = null, bool allowRefund = false)
        {
            if (ExposedHooks.OnDroneSignDeploy(drone, deployer) is false)
                return null;

            var sign = GameManager.server.CreateEntity(SmallWoodenSignPrefab, SignLocalPosition, Quaternion.Euler(SignLocalRotationAngles)) as Signage;
            if (sign == null)
                return null;

            SetupSign(drone, sign);

            if (deployer != null)
            {
                sign.OwnerID = deployer.userID;
            }

            sign.SetParent(drone);
            sign.Spawn();

            // Claim slots to prevent deploying incompatible attachments.
            SignSlots.OccupyHost(drone, sign);

            // This flag is used to remember whether the sign should be refundable.
            // This information is lost on restart but that's a minor concern.
            sign.pickup.enabled = allowRefund;

            Effect.server.Run(DeploySignEffectPrefab, sign.transform.position);
            ExposedHooks.OnDroneSignDeployed(drone, deployer);
            RefreshDroneSettingsProfile(drone);

            return sign;
        }

        private void SetupAllChairs(Drone drone, BaseMountable pilotChair, BaseMountable passengerChair, BaseMountable visibleChair)
        {
            SetupChair(pilotChair);
            SetupChair(passengerChair);
            SetupChair(visibleChair);

            pilotChair.dismountPositions = passengerChair.dismountPositions;

            // Damage will be processed by the drone.
            passengerChair.baseProtection = null;

            UnityEngine.Object.DestroyImmediate(passengerChair.GetComponent<GroundWatch>());
            UnityEngine.Object.DestroyImmediate(passengerChair.GetComponent<DestroyOnGroundMissing>());

            // Box colliders on the deployable chair block dismount from the pilot chair.
            foreach (var collider in passengerChair.GetComponentsInChildren<BoxCollider>())
            {
                UnityEngine.Object.DestroyImmediate(collider);
            }

            ChairComponent.AddToDrone(this, drone, pilotChair, passengerChair, visibleChair);
        }

        private BaseMountable TryDeployChairs(Drone drone, BasePlayer deployer = null, bool allowRefund = false)
        {
            var hookResult = ExposedHooks.OnDroneChairDeploy(drone, deployer);
            if (hookResult is false)
                return null;

            // The driver chair is ideal for mouse movement since it locks the player view angles.
            var pilotChair = GameManager.server.CreateEntity(PilotChairPrefab, PilotChairLocalPosition) as BaseMountable;
            if (pilotChair == null)
                return null;

            pilotChair.SetParent(drone);
            pilotChair.Spawn();

            // The passenger chair shows the "mount" prompt and allows for unlocking view angles.
            var passengerChair = GameManager.server.CreateEntity(PassengerChairPrefab, PassengerChairLocalPosition) as BaseMountable;
            if (passengerChair == null)
            {
                pilotChair.Kill();
                return null;
            }

            passengerChair.pickup.enabled = allowRefund;

            if (deployer != null)
            {
                passengerChair.OwnerID = deployer.userID;
            }

            passengerChair.SetParent(drone);
            passengerChair.Spawn();

            // This chair is visible, even as the drone moves, but doesn't show a mount prompt.
            var visibleChair = GameManager.server.CreateEntity(VisibleChairPrefab, PassengerChairLocalPosition) as BaseMountable;
            if (visibleChair == null)
            {
                pilotChair.Kill();
                passengerChair.Kill();
                return null;
            }

            visibleChair.SetParent(drone);
            visibleChair.Spawn();

            SetupAllChairs(drone, pilotChair, passengerChair, visibleChair);

            // Claim slots to prevent deploying incompatible attachments.
            ChairSlots.OccupyHost(drone, passengerChair);

            Effect.server.Run(ChairDeployEffectPrefab, passengerChair.transform.position);
            ExposedHooks.OnDroneChairDeployed(drone, deployer);
            RefreshDroneSettingsProfile(drone);
            _chairDrones.Add(drone);

            return passengerChair;
        }

        private void MaybeRefreshDroneSign(Drone drone)
        {
            var sign = GetDroneSign(drone);
            if (sign == null)
                return;

            SetupSign(drone, sign);
        }

        private void MaybeAutoDeployChair(Drone drone)
        {
            if (drone.OwnerID == 0
                || !ChairSlots.IsCompatibleWithHost(drone)
                || !permission.UserHasPermission(drone.OwnerID.ToString(), PermissionChairAutoDeploy))
                return;

            TryDeployChairs(drone);
        }

        private void MaybeAddOrRefreshChairs(Drone drone)
        {
            if (!TryGetChairs(drone, out var pilotChair, out var passengerChair, out var visibleChair))
            {
                MaybeAutoDeployChair(drone);
                return;
            }

            SetupAllChairs(drone, pilotChair, passengerChair, visibleChair);
            RefreshDroneSettingsProfile(drone);
            _chairDrones.Add(drone);
        }

        private class ChairComponent : FacepunchBehaviour
        {
            public static void AddToDrone(RidableDrones plugin, Drone drone, BaseMountable pilotChair, BaseMountable passengerChair, BaseMountable visibleChair)
            {
                var component = passengerChair.gameObject.AddComponent<ChairComponent>();
                component._plugin = plugin;
                component._drone = drone;
                component._chairs = new[] { pilotChair, passengerChair, visibleChair };
                component.CreateCollider(drone, passengerChair);
            }

            public static void RemoveFromChair(BaseMountable chair)
            {
                var component = chair.gameObject.GetComponent<ChairComponent>();
                if (component == null)
                    return;

                component._isUnloading = true;
                DestroyImmediate(component);
            }

            private const float ColliderHeight = 3;

            private RidableDrones _plugin;
            private BaseMountable[] _chairs;
            private BaseEntity _drone;
            private GameObject _child;
            private bool _isUnloading;

            private void CreateCollider(Drone drone, BaseMountable passengerChair)
            {
                var centerOfMass = drone.body.centerOfMass;

                _child = passengerChair.gameObject.CreateChild();
                // Layers that seem to work as desired (no player collision): 9, 12, 15, 20, 22, 26.
                _child.gameObject.layer = (int)Rust.Layer.Vehicle_World;
                _child.transform.localPosition = new Vector3(0, ColliderHeight / 4, 0);

                var collider = _child.AddComponent<BoxCollider>();
                var droneExtents = drone.bounds.extents;
                collider.size = droneExtents.WithY(ColliderHeight / 2);

                drone.body.centerOfMass = centerOfMass;
            }

            private void OnDestroy()
            {
                if (_child != null)
                {
                    Destroy(_child);
                }

                if (!_isUnloading)
                {
                    foreach (var chair in _chairs)
                    {
                        if (chair == null || chair.IsDestroyed)
                            continue;

                        chair.Kill();
                    }
                }

                _plugin._chairDrones.Remove(_drone);
                _plugin._mountedChairDrones.Remove(_drone);
            }
        }

        #endregion

        #region Dynamic Hooks

        private interface IGate
        {
            bool Enabled { get; }
        }

        private interface IObservable
        {
            event Action OnChange;
        }

        private interface IObservableGate : IGate, IObservable {}

        private class ObservableHashSet<T> : HashSet<T>, IObservable
        {
            public event Action OnChange;

            public new bool Add(T item)
            {
                var added = base.Add(item);

                if (added)
                {
                    OnChange?.Invoke();
                }

                return added;
            }

            public new bool Remove(T item)
            {
                var removed = base.Remove(item);

                if (removed)
                {
                    OnChange?.Invoke();
                }

                return removed;
            }

            public new void Clear()
            {
                if (Count > 0)
                    return;

                base.Clear();
                OnChange?.Invoke();
            }
        }

        private class ObservableGate : IObservableGate
        {
            public event Action OnChange;
            private readonly Func<bool> _enableWhen;

            public bool Enabled => _enableWhen();

            public ObservableGate(IObservable observable, Func<bool> enableWhen)
            {
                _enableWhen = enableWhen;

                observable.OnChange += HandleChange;
            }

            private void HandleChange()
            {
                OnChange?.Invoke();
            }
        }

        private class MultiObservableGate : IObservableGate
        {
            public event Action OnChange;

            private readonly IObservableGate[] _gates;

            public bool Enabled
            {
                get
                {
                    foreach (var gate in _gates)
                    {
                        if (gate.Enabled)
                            return true;
                    }

                    return false;
                }
            }

            public MultiObservableGate(params IObservableGate[] gates)
            {
                _gates = gates;

                var handleChange = new Action(HandleChange);

                foreach (var gate in gates)
                {
                    gate.OnChange += handleChange;
                }
            }

            private void HandleChange()
            {
                OnChange?.Invoke();
            }
        }

        private class GatedHookCollection
        {
            public bool IsSubscribed { get; private set; } = true;
            private readonly RidableDrones _plugin;
            private readonly IObservableGate _gate;
            private readonly string[] _hookNames;

            public GatedHookCollection(RidableDrones plugin, IObservableGate gate, params string[] hookNames)
            {
                _plugin = plugin;
                _gate = gate;
                _hookNames = hookNames;

                gate.OnChange += Refresh;
            }

            public void Subscribe()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Subscribe(hookName);
                }

                IsSubscribed = true;
            }

            public void Unsubscribe()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Unsubscribe(hookName);
                }

                IsSubscribed = false;
            }

            public void Refresh(bool shouldSubscribe)
            {
                if (shouldSubscribe)
                {
                    if (!IsSubscribed)
                    {
                        Subscribe();
                    }
                }
                else if (IsSubscribed)
                {
                    Unsubscribe();
                }
            }

            public void Refresh()
            {
                Refresh(_gate.Enabled);
            }
        }

        #endregion

        #region Slot Config

        private class SlotConfig
        {
            public readonly BaseEntity.Slot[] Slots;

            public SlotConfig(params BaseEntity.Slot[] slots)
            {
                if (slots.Length == 0)
                    throw new ArgumentOutOfRangeException(nameof(slots), "Must not be empty");

                Slots = slots;
            }

            public BaseEntity GetOccupant(BaseEntity host)
            {
                return host.GetSlot(Slots[0]);
            }

            public bool IsCompatibleWithHost(BaseEntity host)
            {
                foreach (var slot in Slots)
                {
                    if (host.GetSlot(slot) != null)
                        return false;
                }

                return true;
            }

            public void OccupyHost(BaseEntity host, BaseEntity occupant)
            {
                foreach (var slot in Slots)
                {
                    host.SetSlot(slot, occupant);
                }
            }
        }

        #endregion

        #region Parent Trigger

        private class SignTriggerParentEnclosed : TriggerParentEnclosed
        {
            public static SignTriggerParentEnclosed AddToDrone(Drone drone, GameObject host)
            {
                var component = host.gameObject.AddComponent<SignTriggerParentEnclosed>();
                component._drone = drone;
                return component;
            }

            private Drone _drone;

            public override bool ShouldParent(BaseEntity entity, bool bypassOtherTriggerCheck = false)
            {
                // This avoids the drone trying to parent itself when using the Targetable Drones plugin.
                // Targetable Drones uses a child object with the player layer, which the parent trigger is interested in.
                // This also avoids other drones being parented which can create some problems such as recursive parenting.
                if (entity is Drone)
                    return false;

                var player = entity as BasePlayer;
                if ((object)player != null && Vector3.Dot(Vector3.up, _drone.transform.up) < 0.8f)
                    return false;

                return base.ShouldParent(entity, bypassOtherTriggerCheck);
            }
        }

        private class SignComponent : EntityComponent<BaseEntity>
        {
            public static void AddToDrone(RidableDrones plugin, Drone drone, Signage sign)
            {
                var component = sign.gameObject.AddComponent<SignComponent>();
                component._plugin = plugin;
                component._drone = drone;
                component.CreateParentTrigger(drone, sign);
                plugin._signDrones.Add(drone);
            }

            public static void RemoveFromSign(Signage sign)
            {
                DestroyImmediate(sign.gameObject.GetComponent<SignComponent>());
            }

            private const float ColliderHeight = 1.8f;

            private RidableDrones _plugin;
            private Drone _drone;
            private GameObject _triggerHost;

            private void CreateParentTrigger(Drone drone, Signage sign)
            {
                var signExtents = sign.bounds.extents;
                var colliderExtents = new Vector3(signExtents.x, ColliderHeight / 2f, signExtents.y);

                _triggerHost = drone.gameObject.CreateChild();
                _triggerHost.transform.localPosition += new Vector3(0, colliderExtents.y, 0);

                // Without this hack, the drone's sweep test can collide with other entities using the
                // parent trigger collider, causing the drone to occasionally reduce altitude.
                _triggerHost.GetOrAddComponent<Rigidbody>().isKinematic = true;

                var triggerCollider = _triggerHost.gameObject.AddComponent<BoxCollider>();
                triggerCollider.isTrigger = true;
                triggerCollider.gameObject.layer = (int)Rust.Layer.Trigger;
                triggerCollider.size = 2 * colliderExtents;

                var triggerParent = SignTriggerParentEnclosed.AddToDrone(drone, _triggerHost);
                triggerParent.intersectionMode = TriggerParentEnclosed.TriggerMode.PivotPoint;
                triggerParent.interestLayers = Rust.Layers.Mask.Player_Server;
            }

            private void OnDestroy()
            {
                if (_triggerHost != null)
                {
                    Destroy(_triggerHost);
                }

                _plugin._signDrones.Remove(_drone);
            }
        }

        #endregion

        #region DroneController

        private class DroneController : FacepunchBehaviour
        {
            public static bool Exists(BasePlayer player)
            {
                return player.GetComponent<DroneController>() != null;
            }

            public static void Mount(RidableDrones plugin, BasePlayer player, Drone drone, bool isPilotChair)
            {
                var component = player.GetComponent<DroneController>();
                var alreadyExists = component != null;

                if (!alreadyExists)
                {
                    component = player.gameObject.AddComponent<DroneController>();
                }

                component.OnMount(player, drone, isPilotChair);

                if (!alreadyExists)
                {
                    ExposedHooks.OnDroneControlStarted(drone, player);
                }

                plugin._mountedChairDrones.Add(drone);
            }

            public static void Dismount(RidableDrones plugin, BasePlayer player, Drone drone)
            {
                player.GetComponent<DroneController>()?.OnDismount();
                plugin._mountedChairDrones.Remove(drone);
            }

            public static void RemoveFromPlayer(BasePlayer player)
            {
                DestroyImmediate(player.GetComponent<DroneController>());
            }

            private Drone _drone;
            private BasePlayer _controller;
            private CameraViewerId _viewerId;
            private bool _isPilotChair;

            private void DelayedDestroy() => DestroyImmediate(this);

            private void OnMount(BasePlayer controller, Drone drone, bool isPilotChair)
            {
                // If they were swapping chairs, cancel destroying this component.
                CancelInvoke(DelayedDestroy);

                _drone = drone;
                _controller = controller;
                _viewerId = new CameraViewerId(controller.userID, 0);
                _isPilotChair = isPilotChair;

                if (isPilotChair && drone.ControllingViewerId.HasValue)
                {
                    drone.StopControl(drone.ControllingViewerId.Value);
                }

                drone.InitializeControl(_viewerId);

                drone.playerCheckRadius = 0;
            }

            // Don't destroy the component immediately, in case the player is swapping chairs.
            private void OnDismount() => Invoke(DelayedDestroy, 0);

            private void Update()
            {
                if (_drone == null || _drone.IsDestroyed)
                {
                    DestroyImmediate(this);
                    return;
                }

                // Optimization: Skip if there was no user input this frame.
                if (_controller.lastTickTime < Time.time)
                    return;

                _drone.UserInput(_controller.serverInput, _viewerId);

                if (!_isPilotChair)
                {
                    // In hybrid mode, move relative to the direction the player is facing, instead of relative to the direction the drone is facing.
                    var worldDirection = _drone.transform.InverseTransformVector(_drone.currentInput.movement);
                    var playerRotation = Quaternion.Euler(0, _controller.viewAngles.y, 0);

                    _drone.currentInput.movement = playerRotation * worldDirection;
                }
            }

            private void OnDestroy()
            {
                if (_drone != null && !_drone.IsDestroyed)
                {
                    if (_drone.ControllingViewerId.HasValue)
                    {
                        _drone.StopControl(_viewerId);
                    }

                    ExposedHooks.OnDroneControlEnded(_drone, _controller);
                }
            }
        }

        #endregion

        #region Configuration

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Chair tip chance")]
            public int ChairTipChance = 25;

            [JsonProperty("Sign tip chance")]
            public int SignTipChance = 25;

            [JsonProperty("TipChance")]
            private int DeprecatedTipChance { set { ChairTipChance = SignTipChance = value; } }
        }

        private Configuration GetDefaultConfig() => new();

        #endregion

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Localization

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args)
        {
            player.Reply(string.Format(GetMessage(player.Id, messageName), args));
        }

        private void ChatMessage(BasePlayer player, string messageName, params object[] args)
        {
            player.ChatMessage(string.Format(GetMessage(player.UserIDString, messageName), args));
        }

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private static class Lang
        {
            public const string TipDeployChairCommand = "Tip.DeployChairCommand";
            public const string TipDeploySignCommand = "Tip.DeploySignCommand";
            public const string InfoSignName = "Info.SignName";
            public const string InfoChairName = "Info.ChairName";
            public const string ErrorNoPermission = "Error.NoPermission";
            public const string ErrorNoDroneFound = "Error.NoDroneFound";
            public const string ErrorNoSignItem = "Error.NoSignItem";
            public const string ErrorNoChairItem = "Error.NoChairItem";
            public const string ErrorAlreadyHasChair = "Error.AlreadyHasChair";
            public const string ErrorAlreadyHasSign = "Error.AlreadyHasSign";
            public const string ErrorIncompatibleAttachment = "Error.IncompatibleAttachment";
            public const string ErrorDeploySignFailed = "Error.DeploySignFailed";
            public const string ErrorDeployChairFailed = "Error.DeployChairFailed";
            public const string ErrorCannotPickupWithSign = "Error.CannotPickupWithSign";
            public const string ErrorCannotPickupWithChair = "Error.CannotPickupWithChair";
            public const string ErrorCannotPickupAttachment = "Error.CannotPickupAttachment";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.TipDeployChairCommand] = "Tip: Look at the drone and run <color=yellow>/dronechair</color> to deploy a chair.",
                [Lang.TipDeploySignCommand] = "Tip: Look at the drone and run <color=yellow>/dronesign</color> to deploy a sign.",
                [Lang.InfoSignName] = "Drone Sign",
                [Lang.InfoChairName] = "Drone Chair",
                [Lang.ErrorNoPermission] = "You don't have permission to do that.",
                [Lang.ErrorNoDroneFound] = "Error: No drone found.",
                [Lang.ErrorNoSignItem] = "Error: You need a small wooden sign to do that.",
                [Lang.ErrorNoChairItem] = "Error: You need a chair to do that.",
                [Lang.ErrorAlreadyHasChair] = "Error: That drone already has a chair.",
                [Lang.ErrorAlreadyHasSign] = "Error: That drone already has a sign.",
                [Lang.ErrorIncompatibleAttachment] = "Error: That drone has an incompatible attachment.",
                [Lang.ErrorDeploySignFailed] = "Error: Failed to deploy sign.",
                [Lang.ErrorDeployChairFailed] = "Error: Failed to deploy chair.",
                [Lang.ErrorCannotPickupWithSign] = "Error: Cannot pick up that drone while it has a sign.",
                [Lang.ErrorCannotPickupWithChair] = "Error: Cannot pick up that drone while it has a chair.",
                [Lang.ErrorCannotPickupAttachment] = "Error: Cannot pick up that attachment. Pick up the drone instead.",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: RidableDrones.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rustio-clans ---
// --- Original File Path: R/RustIOClans/RustIOClans.cs ---

﻿using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;

namespace Oxide.Plugins {
    [Info("Rust:IO Clans", "playrust.io / dcode", "1.7.6")]
    [Description("Allows your players to form and manage clans with Rust:IO")]
    public class Clans : RustPlugin
    {
        #region Rust:IO Bindings

        private Library lib;
        private MethodInfo isInstalled;
        private MethodInfo hasFriend;
        private MethodInfo addFriend;
        private MethodInfo deleteFriend;

        private void ioInitialize()
        {
            lib = Interface.Oxide.GetLibrary<Library>("RustIO");
            if (lib == null || (isInstalled = lib.GetFunction("IsInstalled")) == null || (hasFriend = lib.GetFunction("HasFriend")) == null || (addFriend = lib.GetFunction("AddFriend")) == null || (deleteFriend = lib.GetFunction("DeleteFriend")) == null)
            {
                lib = null;
                Puts("Rust:IO is not present. You need to install Rust:IO first in order to use this plugin!");
            }
        }

        private bool ioIsInstalled()
        {
            if (lib == null) return false;
            return (bool)isInstalled.Invoke(lib, new object[] { });
        }

        private bool ioHasFriend(string playerId, string friendId)
        {
            if (lib == null) return false;
            return (bool)hasFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        private bool ioAddFriend(string playerId, string friendId)
        {
            if (lib == null) return false;
            return (bool)addFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        private bool ioDeleteFriend(string playerId, string friendId)
        {
            if (lib == null) return false;
            return (bool)deleteFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        #endregion

        private Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
        private Dictionary<string, string> originalNames = new Dictionary<string, string>();
        private Regex tagRe = new Regex("^[a-zA-Z0-9]{2,6}$");
        private Dictionary<string, string> messages = new Dictionary<string, string>();
        private Dictionary<string, Clan> lookup = new Dictionary<string, Clan>();
        private bool addClanMatesAsFriends = true;
        private int limitMembers = -1;
        private int limitModerators = -1;

        private void loadData()
        {
            clans.Clear();
            var data = Interface.Oxide.DataFileSystem.GetDatafile("rustio_clans");
            if (data["clans"] != null) {
                var clansData = (Dictionary<string, object>)Convert.ChangeType(data["clans"], typeof(Dictionary<string, object>));
                foreach (var iclan in clansData) {
                    string tag = iclan.Key;
                    var clanData = iclan.Value as Dictionary<string, object>;
                    string description = (string)clanData["description"];
                    string owner = (string)clanData["owner"];
                    List<string> moderators = new List<string>();
                    foreach (var imoderator in clanData["moderators"] as List<object>) {
                        moderators.Add((string)imoderator);
                    }
                    List<string> members = new List<string>();
                    foreach (var imember in clanData["members"] as List<object>) {
                        members.Add((string)imember);
                    }
                    List<string> invited = new List<string>();
                    foreach (var iinvited in clanData["invited"] as List<object>) {
                        invited.Add((string)iinvited);
                    }
                    Clan clan;
                    clans.Add(tag, clan = new Clan() {
                        tag = tag,
                        description = description,
                        owner = owner,
                        moderators = moderators,
                        members = members,
                        invited = invited
                    });
                    lookup[owner] = clan;
                    foreach (var member in members)
                        lookup[member] = clan;
                }
            }
        }

        private void saveData()
        {
            var data = Interface.Oxide.DataFileSystem.GetDatafile("rustio_clans");
            var clansData = new Dictionary<string, object>();
            foreach (var clan in clans) {
                var clanData = new Dictionary<string, object>();
                clanData.Add("tag", clan.Value.tag);
                clanData.Add("description", clan.Value.description);
                clanData.Add("owner", clan.Value.owner);
                var moderators = new List<object>();
                foreach (var imoderator in clan.Value.moderators)
                    moderators.Add(imoderator);
                var members = new List<object>();
                foreach (var imember in clan.Value.members)
                    members.Add(imember);
                var invited = new List<object>();
                foreach (var iinvited in clan.Value.invited)
                    invited.Add(iinvited);
                clanData.Add("moderators", moderators);
                clanData.Add("members", members);
                clanData.Add("invited", invited);
                clansData.Add(clan.Value.tag, clanData);
            }
            data["clans"] = clansData;
            Interface.Oxide.DataFileSystem.SaveDatafile("rustio_clans");
        }

        private List<string> texts = new List<string>() {
            "%NAME% has come online!",
            "%NAME% has gone offline.",

            "You are currently not a member of a clan.",
            "You are the owner of:",
            "You are a moderator of:",
            "You are a member of:",
            "Members online:",
            "Pending invites:",
            "To learn more about clans, type: <color=#ffd479>/clan help</color>",

            "Usage: <color=#ffd479>/clan create \"TAG\" \"Description\"</color>",
            "You are already a member of a clan.",
            "Clan tags must be 2 to 6 characters long and may contain standard letters and numbers only",
            "Please provide a short description of your clan.",
            "There is already a clan with this tag.",
            "You are now the owner of your new clan:",
            "To invite new members, type: <color=#ffd479>/clan invite \"Player name\"</color>",

            "Usage: <color=#ffd479>/clan invite \"Player name\"</color>",
            "You need to be a moderator of your clan to use this command.",
            "No such player or player name not unique:",
            "This player is already a member of your clan:",
            "This player is not a member of your clan:",
            "This player has already been invited to your clan:",
            "This player is already a moderator of your clan:",
            "This player is not a moderator of your clan:",
            "%MEMBER% invited %PLAYER% to the clan.",
            "Usage: <color=#ffd479>/clan join \"TAG\"</color>",
            "You have not been invited to join this clan.",
            "%NAME% has joined the clan!",
            "You have been invited to join the clan:",
            "To join, type: <color=#ffd479>/clan join \"%TAG%\"</color>",
            "This clan has already reached the maximum number of members.",
            "This clan has already reached the maximum number of moderators.",

            "Usage: <color=#ffd479>/clan promote \"Player name\"</color>",
            "You need to be the owner of your clan to use this command.",
            "%OWNER% promoted %MEMBER% to moderator.",

            "Usage: <color=#ffd479>/clan demote \"Player name\"</color>",

            "Usage: <color=#ffd479>/clan leave</color>",
            "You have left your current clan.",
            "%NAME% has left the clan.",

            "Usage: <color=#ffd479>/clan kick \"Player name\"</color>",
            "This player is an owner or moderator and cannot be kicked:",
            "%NAME% kicked %MEMBER% from the clan.",

            "Usage: <color=#ffd479>/clan disband forever</color>",
            "Your current clan has been disbanded forever.",

            "Usage: <color=#ffd479>/clan delete \"TAG\"</color>",
            "You need to be a server owner to delete clans.",
            "There is no clan with that tag:",
            "Your clan has been deleted by the server owner.",
            "You have deleted the clan:",

            "Available commands:",
            "<color=#ffd479>/clan</color> - Displays relevant information about your current clan",
            "<color=#ffd479>/c Message...</color> - Sends a message to all online clan members",
            "<color=#ffd479>/clan create \"TAG\" \"Description\"</color> - Creates a new clan you own",
            "<color=#ffd479>/clan join \"TAG\"</color> - Joins a clan you have been invited to",
            "<color=#ffd479>/clan leave</color> - Leaves your current clan",
            "<color=#74c6ff>Moderator</color> commands:",
            "<color=#ffd479>/clan invite \"Player name\"</color> - Invites a player to your clan",
            "<color=#ffd479>/clan kick \"Player name\"</color> - Kicks a member from your clan",
            "<color=#a1ff46>Owner</color> commands:",
            "<color=#ffd479>/clan promote \"Name\"</color> - Promotes a member to moderator",
            "<color=#ffd479>/clan demote \"Name\"</color> - Demotes a moderator to member",
            "<color=#ffd479>/clan disband forever</color> - Disbands your clan (no undo)",
            "<color=#cd422b>Server owner</color> commands:",
            "<color=#ffd479>/clan delete \"TAG\"</color> - Deletes a clan (no undo)",

            "<color=#ffd479>/clan</color> - Displays your current clan status",
            "<color=#ffd479>/clan help</color> - Learn how to create or join a clan"
        };

        protected override void LoadDefaultConfig() {
            var messages = new Dictionary<string, object>();
            foreach (var text in texts) {
                if (messages.ContainsKey(text))
                    Puts("Duplicate translation string: " + text);
                else
                    messages.Add(text, text);
            }
            Config["messages"] = messages;
            Config.Set("addClanMatesAsFriends", true);
            Config.Set("limit", "members", -1);
            Config.Set("limit", "moderators", -1);
        }

        private string _(string text, Dictionary<string, string> replacements = null)
        {
            if (messages.ContainsKey(text) && messages[text] != null)
                text = messages[text];
            if (replacements != null)
                foreach (var replacement in replacements)
                    text = text.Replace("%" + replacement.Key + "%", replacement.Value);
            return text;
        }

        private Clan findClan(string tag)
        {
            Clan clan;
            if (clans.TryGetValue(tag, out clan))
                return clan;
            return null;
        }

        private Clan findClanByUser(string userId)
        {
            Clan clan;
            if (lookup.TryGetValue(userId, out clan))
                return clan;
            return null;
        }

        private BasePlayer findPlayerByPartialName(string name)
        {
            if (string.IsNullOrEmpty(name))
                return null;
            BasePlayer player = null;
            name = name.ToLower();
            var allPlayers = BasePlayer.activePlayerList.ToArray();

            foreach (var p in allPlayers) {
                if (p.displayName == name) {
                    if (player != null)
                        return null; // Not unique
                    player = p;
                }
            }
            if (player != null)
                return player;

            foreach (var p in allPlayers) {
                if (p.displayName.ToLower().IndexOf(name) >= 0) {
                    if (player != null)
                        return null; // Not unique
                    player = p;
                }
            }
            return player;
        }

        private string stripTag(string name, Clan clan)
        {
            if (clan == null)
                return name;
            var re = new Regex(@"^\[" + clan.tag + @"\]\s");
            while (re.IsMatch(name))
                name = name.Substring(clan.tag.Length + 3);
            return name;
        }

        private void setupPlayer(BasePlayer player)
        {
            var prevName = player.displayName;
            var playerId = player.UserIDString;
            var clan = findClanByUser(playerId);
            player.displayName = stripTag(player.displayName, clan);
            string originalName = null;
            if (!originalNames.ContainsKey(playerId)) {
                originalNames.Add(playerId, originalName = player.displayName);
            } else {
                originalName = originalNames[playerId];
            }
            if (clan == null) {
                player.displayName = originalName;
            } else {
                var tag = "[" + clan.tag + "]" + " ";
                if (!player.displayName.StartsWith(tag))
                    player.displayName = tag + originalName;
            }
            if (player.displayName != prevName)
                player.SendNetworkUpdate();
        }

        private void setupPlayers(List<string> playerIds)
        {
            foreach (var playerId in playerIds) {
                var uid = Convert.ToUInt64(playerId);
                var player = BasePlayer.FindByID(uid);
                if (player != null)
                    setupPlayer(player);
                else {
                    player = BasePlayer.FindSleeping(uid);
                    if (player != null)
                        setupPlayer(player);
                }
            }
        }

        private void OnServerInitialized()
        {
            try {
                ioInitialize();
                LoadConfig();
                try {
                    var customMessages = Config.Get<Dictionary<string, object>>("messages");
                    if (customMessages != null)
                        foreach (var pair in customMessages)
                            messages[pair.Key] = (string)pair.Value;
                    loadData();
                } catch (Exception ex2) {
                    PrintWarning("oxide/config/Clans.json seems to contain an invalid 'messages' structure. Please delete the config file once and reload the plugin.");
                }
                foreach (var player in BasePlayer.activePlayerList)
                    setupPlayer(player);
                foreach (var player in BasePlayer.sleepingPlayerList)
                    setupPlayer(player);
                try { addClanMatesAsFriends = Config.Get<bool>("addClanMatesAsFriends"); } catch { }
                try { limitMembers = Config.Get<int>("limit", "members"); } catch { }
                try { limitModerators = Config.Get<int>("limit", "moderators"); } catch { }
            } catch (Exception ex) {
                PrintError("OnServerInitialized failed", ex);
            }
        }

        private void OnUserApprove(Network.Connection connection)
        {
            originalNames[connection.userid.ToString()] = connection.username;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            string originalName;
            if (originalNames.TryGetValue(player.UserIDString, out originalName))
                player.displayName = originalName;
            try {
                setupPlayer(player);
                var clan = findClanByUser(player.UserIDString);
                if (clan != null)
                    clan.Broadcast(_("%NAME% has come online!", new Dictionary<string, string>() { { "NAME", stripTag(player.displayName, clan) } }));
            } catch (Exception ex) {
                PrintError("OnPlayerConnected failed", ex);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            try {
                var clan = findClanByUser(player.UserIDString);
                if (clan != null)
                    clan.Broadcast(_("%NAME% has gone offline.", new Dictionary<string, string>() { { "NAME", stripTag(player.displayName, clan) } }));
            } catch (Exception ex) {
                PrintError("OnPlayerDisconnected failed", ex);
            }
        }

        private void Unload()
        {
            try {
                foreach (var pair in originalNames) {
                    var playerId = Convert.ToUInt64(pair.Key);
                    var player = BasePlayer.FindByID(playerId);
                    if (player != null)
                        player.displayName = pair.Value;
                    else {
                        player = BasePlayer.FindSleeping(playerId);
                        if (player != null)
                            player.displayName = pair.Value;
                    }
                }
            } catch (Exception ex) {
                PrintError("Unload failed", ex);
            }
        }

        private void SendHelpText(BasePlayer player)
        {
            var sb = new StringBuilder()
               .Append("<size=18>Clans</size> by <color=#ce422b>http://playrust.io</color>\n")
               .Append("  ").Append(_("<color=#ffd479>/clan</color> - Displays your current clan status")).Append("\n")
               .Append("  ").Append(_("<color=#ffd479>/clan help</color> - Learn how to create or join a clan"));
            player.ChatMessage(sb.ToString());
        }

        [ChatCommand("clan")]
        private void ClanCommand(BasePlayer player, string command, string[] args)
        {
            var userId = player.UserIDString;
            var myClan = findClanByUser(userId);
            var sb = new StringBuilder();

            if (args.Length == 0) {
                sb.Append("<size=22>Clans</size> " + Version + " by <color=#ce422b>http://playrust.io</color>\n");
                if (myClan == null) {
                    sb.Append(_("You are currently not a member of a clan.")).Append("\n");
                } else {
                    if (myClan.IsOwner(userId)) {
                        sb.Append(_("You are the owner of:"));
                    } else if (myClan.IsModerator(userId))
                        sb.Append(_("You are a moderator of:"));
                    else
                        sb.Append(_("You are a member of:"));
                    sb.Append(" [").Append(myClan.tag).Append("] ").Append(myClan.description).Append("\n");
                    sb.Append(_("Members online:")).Append(" ");
                    List<string> onlineMembers = new List<string>();
                    int n = 0;
                    foreach (var memberId in myClan.members) {
                        var p = BasePlayer.FindByID(Convert.ToUInt64(memberId));
                        if (p != null) {
                            if (n > 0) sb.Append(", ");
                            if (myClan.IsOwner(memberId)) {
                                sb.Append("<color=#a1ff46>").Append(stripTag(p.displayName, myClan)).Append("</color>");
                            } else if (myClan.IsModerator(memberId)) {
                                sb.Append("<color=#74c6ff>").Append(stripTag(p.displayName, myClan)).Append("</color>");
                            } else {
                                sb.Append(p.displayName);
                            }
                            ++n;
                        }
                    }
                    sb.Append("\n");
                    if ((myClan.IsOwner(userId) || myClan.IsModerator(userId)) && myClan.invited.Count > 0) {
                        sb.Append(_("Pending invites:")).Append(" ");
                        int m = 0;
                        foreach (var inviteId in myClan.invited) {
                            var p = BasePlayer.FindByID(Convert.ToUInt64(inviteId));
                            if (p != null) {
                                if (m > 0) sb.Append(", ");
                                sb.Append(p.displayName);
                                ++m;
                            }
                        }
                        sb.Append("\n");
                    }
                }
                sb.Append(_("To learn more about clans, type: <color=#ffd479>/clan help</color>"));
                SendReply(player, "{0}", sb.ToString());
                return;
            }
            switch (args[0]) {
                case "create":
                    if (args.Length != 3) {
                        sb.Append(_("Usage: <color=#ffd479>/clan create \"TAG\" \"Description\"</color>"));
                        break;
                    }
                    if (myClan != null) {
                        sb.Append(_("You are already a member of a clan."));
                        break;
                    }
                    if (!tagRe.IsMatch(args[1])) {
                        sb.Append(_("Clan tags must be 2 to 6 characters long and may contain standard letters and numbers only"));
                        break;
                    }
                    args[2] = args[2].Trim();
                    if (args[2].Length < 2 || args[2].Length > 30) {
                        sb.Append(_("Please provide a short description of your clan."));
                        break;
                    }
                    if (clans.ContainsKey(args[1])) {
                        sb.Append(_("There is already a clan with this tag."));
                        break;
                    }
                    myClan = Clan.Create(args[1], args[2], userId);
                    clans.Add(myClan.tag, myClan);
                    saveData();
                    lookup[userId] = myClan;
                    setupPlayer(player); // Add clan tag
                    sb.Append(_("You are now the owner of your new clan:")).Append(" ");
                    sb.Append("[").Append(myClan.tag).Append("] ").Append(myClan.description).Append("\n");
                    sb.Append(_("To invite new members, type: <color=#ffd479>/clan invite \"Player name\"</color>"));
                    myClan.onCreate();
                    break;
                case "invite":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=#ffd479>/clan invite \"Player name\"</color>"));
                        break;
                    }
                    if (myClan == null) {
                        sb.Append(_("You are currently not a member of a clan."));
                        break;
                    }
                    if (!myClan.IsOwner(userId) && !myClan.IsModerator(userId)) {
                        sb.Append(_("You need to be a moderator of your clan to use this command."));
                        break;
                    }
                    var invPlayer = findPlayerByPartialName(args[1]);
                    if (invPlayer == null) {
                        sb.Append(_("No such player or player name not unique:")).Append(" ").Append(args[1]);
                        break;
                    }
                    var invUserId = invPlayer.UserIDString;
                    if (myClan.members.Contains(invUserId)) {
                        sb.Append(_("This player is already a member of your clan:")).Append(" ").Append(invPlayer.displayName);
                        break;
                    }
                    if (myClan.invited.Contains(invUserId)) {
                        sb.Append(_("This player has already been invited to your clan:")).Append(" ").Append(invPlayer.displayName);
                        break;
                    }
                    myClan.invited.Add(invUserId);
                    saveData();
                    myClan.Broadcast(_("%MEMBER% invited %PLAYER% to the clan.", new Dictionary<string, string>() { { "MEMBER", stripTag(player.displayName, myClan) }, { "PLAYER", invPlayer.displayName } }));
                    invPlayer.SendConsoleCommand("chat.add", "", "",
                        _("You have been invited to join the clan:") + " [" + myClan.tag + "] " + myClan.description + "\n" +
                        _("To join, type: <color=#ffd479>/clan join \"%TAG%\"</color>", new Dictionary<string, string>() { { "TAG", myClan.tag } }));
                    myClan.onUpdate();
                    break;
                case "join":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=#ffd479>/clan join \"TAG\"</color>"));
                        break;
                    }
                    if (myClan != null) {
                        sb.Append(_("You are already a member of a clan."));
                        break;
                    }
                    myClan = findClan(args[1]);
                    if (myClan == null || !myClan.IsInvited(userId)) {
                        sb.Append(_("You have not been invited to join this clan."));
                        break;
                    }
                    if (limitMembers >= 0 && myClan.members.Count >= limitMembers) {
                        sb.Append(_("This clan has already reached the maximum number of members."));
                        break;
                    }
                    myClan.invited.Remove(userId);
                    myClan.members.Add(userId);
                    saveData();
                    lookup[userId] = myClan;
                    setupPlayer(player);
                    myClan.Broadcast(_("%NAME% has joined the clan!", new Dictionary<string, string>() { { "NAME", stripTag(player.displayName, myClan) } }));
                    foreach (var memberId in myClan.members) {
                        if (memberId != userId && ioIsInstalled() && addClanMatesAsFriends) {
                            ioAddFriend(memberId, userId);
                            ioAddFriend(userId, memberId);
                        }
                    }
                    myClan.onUpdate();
                    break;
                case "promote":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=#ffd479>/clan promote \"Player name\"</color>"));
                        break;
                    }
                    if (myClan == null) {
                        sb.Append(_("You are currently not a member of a clan."));
                        break;
                    }
                    if (!myClan.IsOwner(userId)) {
                        sb.Append(_("You need to be the owner of your clan to use this command."));
                        break;
                    }
                    var promotePlayer = findPlayerByPartialName(args[1]);
                    if (promotePlayer == null) {
                        sb.Append(_("No such player or player name not unique:") + " " + args[1]);
                        break;
                    }
                    var promotePlayerUserId = promotePlayer.UserIDString;
                    if (!myClan.IsMember(promotePlayerUserId)) {
                        sb.Append(_("This player is not a member of your clan:") + " " + promotePlayer.displayName);
                        break;
                    }
                    if (myClan.IsModerator(promotePlayerUserId)) {
                        sb.Append(_("This player is already a moderator of your clan:") + " " + promotePlayer.displayName);
                        break;
                    }
                    if (limitModerators >= 0 && myClan.moderators.Count >= limitModerators) {
                        sb.Append(_("This clan has already reached the maximum number of moderators."));
                        break;
                    }
                    myClan.moderators.Add(promotePlayerUserId);
                    saveData();
                    myClan.Broadcast(_("%OWNER% promoted %MEMBER% to moderator.", new Dictionary<string, string>() { { "OWNER", stripTag(player.displayName, myClan) }, { "MEMBER", stripTag(promotePlayer.displayName, myClan) } }));
                    myClan.onUpdate();
                    break;
                case "demote":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=#ffd479>/clan demote \"Player name\"</color>"));
                        break;
                    }
                    if (myClan == null) {
                        sb.Append(_("You are currently not a member of a clan."));
                        break;
                    }
                    if (!myClan.IsOwner(userId)) {
                        sb.Append(_("You need to be the owner of your clan to use this command."));
                        break;
                    }
                    var demotePlayer = findPlayerByPartialName(args[1]);
                    if (demotePlayer == null) {
                        sb.Append(_("No such player or player name not unique:") + " " + args[1]);
                        break;
                    }
                    var demotePlayerUserId = demotePlayer.UserIDString;
                    if (!myClan.IsMember(demotePlayerUserId)) {
                        sb.Append(_("This player is not a member of your clan:") + " " + demotePlayer.displayName);
                        break;
                    }
                    if (!myClan.IsModerator(demotePlayerUserId)) {
                        sb.Append(_("This player is not a moderator of your clan:") + " " + demotePlayer.displayName);
                        break;
                    }
                    myClan.moderators.Remove(demotePlayerUserId);
                    saveData();
                    myClan.Broadcast(player.displayName + " demoted " + demotePlayer.displayName + " to a member");
                    myClan.onUpdate();
                    break;
                case "leave":
                    if (args.Length != 1) {
                        sb.Append(_("Usage: <color=#ffd479>/clan leave</color>"));
                        break;
                    }
                    if (myClan == null) {
                        sb.Append(_("You are currently not a member of a clan."));
                        break;
                    }
                    if (myClan.members.Count == 1) { // Remove the clan once the last member leaves
                        clans.Remove(myClan.tag);
                    } else {
                        myClan.moderators.Remove(userId);
                        myClan.members.Remove(userId);
                        myClan.invited.Remove(userId);
                        if (myClan.IsOwner(userId) && myClan.members.Count > 0) { // Make the first member the new owner
                            myClan.owner = myClan.members[0];
                        }
                    }
                    saveData();
                    lookup.Remove(userId);
                    setupPlayer(player); // Remove clan tag
                    sb.Append(_("You have left your current clan."));
                    myClan.Broadcast(_("%NAME% has left the clan.", new Dictionary<string, string>() { { "NAME", player.displayName } }));
                    myClan.onUpdate();
                    break;
                case "kick":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=#ffd479>/clan kick \"Player name\"</color>"));
                        break;
                    }
                    if (myClan == null) {
                        sb.Append(_("You are currently not a member of a clan."));
                        break;
                    }
                    if (!myClan.IsOwner(userId) && !myClan.IsModerator(userId)) {
                        sb.Append(_("You need to be a moderator of your clan to use this command."));
                        break;
                    }
                    var kickPlayer = findPlayerByPartialName(args[1]);
                    if (kickPlayer == null) {
                        sb.Append(_("No such player or player name not unique:") + " " + args[1]);
                        break;
                    }
                    var kickPlayerUserId = kickPlayer.UserIDString;
                    if (!myClan.IsMember(kickPlayerUserId) && !myClan.IsInvited(kickPlayerUserId)) {
                        sb.Append(_("This player is not a member of your clan:") + " " + kickPlayer.displayName);
                        break;
                    }
                    if (myClan.IsOwner(kickPlayerUserId) || myClan.IsModerator(kickPlayerUserId)) {
                        sb.Append(_("This player is an owner or moderator and cannot be kicked:") + " " + kickPlayer.displayName);
                        break;
                    }
                    myClan.members.Remove(kickPlayerUserId);
                    myClan.invited.Remove(kickPlayerUserId);
                    saveData();
                    lookup.Remove(kickPlayerUserId);
                    setupPlayer(kickPlayer); // Remove clan tag
                    myClan.Broadcast(_("%NAME% kicked %MEMBER% from the clan.", new Dictionary<string, string>() { { "NAME", stripTag(player.displayName, myClan) }, { "MEMBER", kickPlayer.displayName } }));
                    myClan.onUpdate();
                    break;
                case "disband":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=#ffd479>/clan disband forever</color>"));
                        break;
                    }
                    if (myClan == null) {
                        sb.Append(_("You are currently not a member of a clan."));
                        break;
                    }
                    if (!myClan.IsOwner(userId)) {
                        sb.Append(_("You need to be the owner of your clan to use this command."));
                        break;
                    }
                    clans.Remove(myClan.tag);
                    saveData();
                    foreach (var member in myClan.members)
                        lookup.Remove(member);
                    myClan.Broadcast(_("Your current clan has been disbanded forever."));
                    setupPlayers(myClan.members); // Remove clan tags
                    myClan.onDestroy();
                    break;
                case "delete":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=#ffd479>/clan delete \"TAG\"</color>"));
                        break;
                    }
                    if (player.net.connection.authLevel < 2) {
                        sb.Append(_("You need to be a server owner to delete clans."));
                        break;
                    }
                    Clan clan;
                    if (!clans.TryGetValue(args[1], out clan)) {
                        sb.Append(_("There is no clan with that tag:")).Append(" ").Append(args[1]);
                        break;
                    }
                    clan.Broadcast(_("Your clan has been deleted by the server owner."));
                    clans.Remove(args[1]);
                    saveData();
                    foreach (var member in clan.members)
                        lookup.Remove(member);
                    setupPlayers(clan.members);
                    sb.Append(_("You have deleted the clan:")).Append(" [").Append(clan.tag).Append("] ").Append(clan.description);
                    myClan.onDestroy();
                    break;
                default:
                    sb.Append(_("Available commands:")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan</color> - Displays relevant information about your current clan")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/c Message...</color> - Sends a message to all online clan members")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan create \"TAG\" \"Description\"</color> - Creates a new clan you own")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan join \"TAG\"</color> - Joins a clan you have been invited to")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan leave</color> - Leaves your current clan")).Append("\n");
                    sb.Append(_("<color=#74c6ff>Moderator</color> commands:")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan invite \"Player name\"</color> - Invites a player to your clan")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan kick \"Player name\"</color> - Kicks a member from your clan")).Append("\n");
                    sb.Append(_("<color=#a1ff46>Owner</color> commands:")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan promote \"Name\"</color> - Promotes a member to moderator")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan demote \"Name\"</color> - Demotes a moderator to member")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan disband forever</color> - Disbands your clan (no undo)")).Append("\n");
                    if (player.net.connection.authLevel >= 2) {
                        sb.Append(_("<color=#cd422b>Server owner</color> commands:")).Append("\n");
                        sb.Append("  ").Append(_("<color=#ffd479>/clan delete \"TAG\"</color> - Deletes a clan (no undo)")).Append("\n");
                    }
                    break;
            }
            SendReply(player, "{0}", sb.ToString().TrimEnd());
        }

        [ChatCommand("c")]
        private void ClanChatCommand(BasePlayer player, string command, string[] args)
        {
            var playerId = player.UserIDString;
            var myClan = findClanByUser(playerId);
            if (myClan == null) {
                SendReply(player, "{0}", _("You are currently not a member of a clan."));
                return;
            }
            var message = string.Join(" ", args);
            if (string.IsNullOrEmpty(message))
                return;
            myClan.Broadcast(stripTag(player.displayName, myClan) + ": " + message, player.userID);
            var playerName = originalNames.ContainsKey(playerId) ? originalNames[playerId] : player.displayName;
            Puts("[CLANCHAT] {0} - {1}: {2}", myClan.tag, playerName, message);
        }

        public class Clan
        {
            public string tag;
            public string description;
            public string owner;
            public List<string> moderators = new List<string>();
            public List<string> members = new List<string>();
            public List<string> invited = new List<string>();

            public static Clan Create(string tag, string description, string ownerId) {
                var clan = new Clan() { tag = tag, description = description, owner = ownerId };
                clan.members.Add(ownerId);
                return clan;
            }

            public bool IsOwner(string userId) {
                return userId == owner;
            }

            public bool IsModerator(string userId) {
                return moderators.Contains(userId);
            }

            public bool IsMember(string userId) {
                return members.Contains(userId);
            }

            public bool IsInvited(string userId) {
                return invited.Contains(userId);
            }

            public void Broadcast(string message, ulong senderId = 0) {
                foreach (var memberId in members) {
                    var player = BasePlayer.FindByID(Convert.ToUInt64(memberId));
                    if (player == null)
                        continue;
                    player.SendConsoleCommand("chat.add", "", senderId.ToString(), "<color=#a1ff46>(CLAN)</color> " + message);
                }
            }

            internal JObject ToJObject() {
                var obj = new JObject();
                obj["tag"] = tag;
                obj["description"] = description;
                obj["owner"] = owner;
                var jmoderators = new JArray();
                foreach (var moderator in moderators)
                    jmoderators.Add(moderator);
                obj["moderators"] = jmoderators;
                var jmembers = new JArray();
                foreach (var member in members)
                    jmembers.Add(member);
                obj["members"] = jmembers;
                var jinvited = new JArray();
                foreach (var invite in invited)
                    jinvited.Add(invite);
                obj["invited"] = jinvited;
                return obj;
            }

            internal void onCreate() => Interface.Call("OnClanCreate", tag);
            internal void onUpdate() => Interface.Call("OnClanUpdate", tag);
            internal void onDestroy() => Interface.Call("OnClanDestroy", tag);
        }

        #region Plugin API

        [HookMethod("GetClan")]
        private JObject GetClan(string tag)
        {
            var clan = findClan(tag);
            if (clan == null)
                return null;
            return clan.ToJObject();
        }

        [HookMethod("GetAllClans")]
        private JArray GetAllClans()
        {
            return new JArray(clans.Keys);
        }

        [HookMethod("GetClanOf")]
        private string GetClanOf(object player)
        {
            if (player == null)
                throw new ArgumentException("player");
            if (player is ulong)
                player = ((ulong)player).ToString();
            else if (player is BasePlayer)
                player = (player as BasePlayer).userID.ToString();
            if (!(player is string))
                throw new ArgumentException("player");
            var clan = findClanByUser((string)player);
            if (clan == null)
                return null;
            return clan.tag;
        }

        #endregion
    }
}

// --- End of file: RustIOClans.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/inventory-guardian ---
// --- Original File Path: I/InventoryGuardian/InventoryGuardian.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
    [Info("InventoryGuardian", "k1lly0u", "0.2.7"), Description("Restore players inventory even after server wipe")]
    class InventoryGuardian : RustPlugin
    {
        #region Fields
        private IGData igData;
        private DynamicConfigFile Inventory_Data;

        private Dictionary<ulong, PlayerInfo> cachedInventories = new Dictionary<ulong, PlayerInfo>();
        private bool isNewSave;
        #endregion

        #region Oxide Hooks
        private void Loaded() => Inventory_Data = Interface.Oxide.DataFileSystem.GetFile("Inventory-Guardian");

        private void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            RegisterPermisions();
            CheckProtocol();
            SaveLoop();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void OnNewSave(string filename) => isNewSave = true;

        private void OnPlayerConnected(BasePlayer player)
        {
            if (igData.IsActivated)
                if (cachedInventories.ContainsKey(player.userID))
                    if (cachedInventories[player.userID].RestoreOnce)
                    {
                        RestoreInventory(player);
                        RemoveInventory(player);
                    }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (igData.IsActivated)
                SaveInventory(player);
        }

        private void Unload() => SaveData();
        #endregion

        #region Functions
        private void CheckProtocol()
        {
            if (igData.AutoRestore && isNewSave)
            {
                foreach (KeyValuePair<ulong, PlayerInfo> entry in cachedInventories)
                    entry.Value.RestoreOnce = true;
                Puts("Map wipe detected! Activating Auto Restore for all saved inventories");
            }
        }

        private void RestoreAll()
        {
            foreach (BasePlayer player in BasePlayer.allPlayerList)
                RestoreInventory(player);            
            SaveData();
        }

        private void SaveAll()
        {
            foreach (var player in BasePlayer.activePlayerList)
                SaveInventory(player);
            foreach (var player in BasePlayer.sleepingPlayerList)
                SaveInventory(player);
            SaveData();
        }

        private void RemoveAll()
        {
            cachedInventories.Clear();
            SaveData();
        }

        private BasePlayer FindPlayer(BasePlayer player, string arg)
        {
            List<BasePlayer> foundPlayers = new List<BasePlayer>();
            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                if (p != null)
                {
                    if (steamid != 0L)
                        if (p.userID == steamid) return p;
                    string lowername = p.displayName.ToLower();
                    if (lowername.Contains(lowerarg))
                    {
                        foundPlayers.Add(p);
                    }
                }
            }

            if (foundPlayers.Count == 0)
            {
                foreach (BasePlayer sleeper in BasePlayer.sleepingPlayerList)
                {
                    if (sleeper != null)
                    {
                        if (steamid != 0L)
                            if (sleeper.userID == steamid)
                            {
                                foundPlayers.Clear();
                                foundPlayers.Add(sleeper);
                                return foundPlayers[0];
                            }
                        string lowername = player.displayName.ToLower();
                        if (lowername.Contains(lowerarg))
                        {
                            foundPlayers.Add(sleeper);
                        }
                    }
                }
            }

            if (foundPlayers.Count == 0)
            {
                if (player != null)
                    SendReply(player, configData.Messages_MainColor + "No players found.</color>");
                return null;
            }

            if (foundPlayers.Count > 1)
            {
                if (player != null)
                    SendReply(player, configData.Messages_MainColor + "Multiple players found with that name.</color>");
                return null;
            }

            return foundPlayers[0];
        }
        #endregion

        #region Messaging
        private void MSG(BasePlayer player, string message, string key = "", bool title = false)
        {
            message = configData.Messages_MainColor + key + "</color>" + configData.Messages_MsgColor + message + "</color>";
            if (title)
                message = configData.Messages_MainColor + Title + ": </color>" + message;
            SendReply(player, message);
        }
        #endregion

        #region Class Saving
        private bool SaveInventory(BasePlayer player)
        {
            List<SavedItem> items = GetPlayerItems(player);
            if (!cachedInventories.ContainsKey(player.userID))
                cachedInventories.Add(player.userID, new PlayerInfo {  });
            cachedInventories[player.userID].Items = items;
            return true;  
        }

        private List<SavedItem> GetPlayerItems(BasePlayer player)
        {
            List<SavedItem> kititems = new List<SavedItem>();
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    kititems.Add(ProcessItem(item, "belt"));
                }
            }
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    kititems.Add(ProcessItem(item, "wear"));
                }
            }
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    kititems.Add(ProcessItem(item, "main"));
                }
            }
            return kititems;
        }

        private SavedItem ProcessItem(Item item, string container)
        {
            SavedItem iItem = new SavedItem()
            {
                container = container,
                itemid = item.info.itemid,
                amount = item.amount,
                ammo = item.GetHeldEntity() is BaseProjectile ? (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents : item.GetHeldEntity() is FlameThrower ? (item.GetHeldEntity() as FlameThrower).ammo : 0,
                ammotype = (item.GetHeldEntity() as BaseProjectile)?.primaryMagazine.ammoType.shortname ?? null,
                position = item.position,
                skin = item.skin,
                condition = item.condition,
                maxCondition = item.maxCondition,
                frequency = ItemModAssociatedEntity<PagerEntity>.GetAssociatedEntity(item)?.GetFrequency() ?? -1,
                instanceData = new SavedItem.InstanceData(item),
                contents = item.contents?.itemList.Select(item1 => new SavedItem
                {
                    itemid = item1.info.itemid,
                    amount = item1.amount,
                    condition = item1.condition
                }).ToArray()
            };
            return iItem;
        }

        private bool RemoveInventory(BasePlayer player)
        {
            if (cachedInventories.ContainsKey(player.userID))
            {
                cachedInventories.Remove(player.userID);
                return true;
            }
            return false;
        }
        #endregion        

        #region Give
        private bool RestoreInventory(BasePlayer player)
        {
            if (!cachedInventories.ContainsKey(player.userID))
                return false;
            
            player.inventory.Strip();
            foreach (SavedItem kitem in cachedInventories[player.userID].Items)
            {
                GiveItem(player, BuildItem(kitem), kitem.container);
            }
            return true;
        }

        private void GiveItem(BasePlayer player, Item item, string container)
        {
            if (item == null) return;
            ItemContainer cont;
            switch (container)
            {
                case "wear":
                    cont = player.inventory.containerWear;
                    break;
                case "belt":
                    cont = player.inventory.containerBelt;
                    break;
                default:
                    cont = player.inventory.containerMain;
                    break;
            }
            player.inventory.GiveItem(item, cont);
        }

        private Item BuildItem(SavedItem itemData)
        {
            Item item = ItemManager.CreateByItemID(itemData.itemid, itemData.amount, itemData.skin);
            item.condition = itemData.condition;
            item.maxCondition = itemData.maxCondition;

            if (itemData.frequency > 0)
            {
                ItemModRFListener rfListener = item.info.GetComponentInChildren<ItemModRFListener>();
                if (rfListener != null)
                {
                    PagerEntity pagerEntity = BaseNetworkable.serverEntities.Find(item.instanceData.subEntity) as PagerEntity;
                    if (pagerEntity != null)
                    {
                        pagerEntity.ChangeFrequency(itemData.frequency);
                        item.MarkDirty();
                    }
                }
            }

            if (itemData.instanceData?.IsValid() ?? false)
                itemData.instanceData.Restore(item);

            BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                if (!string.IsNullOrEmpty(itemData.ammotype))
                    weapon.primaryMagazine.ammoType = ItemManager.FindItemDefinition(itemData.ammotype);
                weapon.primaryMagazine.contents = itemData.ammo;
            }

            FlameThrower flameThrower = item.GetHeldEntity() as FlameThrower;
            if (flameThrower != null)
                flameThrower.ammo = itemData.ammo;

            if (itemData.contents != null)
            {
                foreach (SavedItem contentData in itemData.contents)
                {
                    Item newContent = ItemManager.CreateByItemID(contentData.itemid, contentData.amount);
                    if (newContent != null)
                    {
                        newContent.condition = contentData.condition;
                        newContent.MoveToContainer(item.contents);
                    }
                }
            }
            return item;
        }
        #endregion

        #region Permissions
        private void RegisterPermisions()
        {
            permission.RegisterPermission("inventoryguardian.admin", this);
            permission.RegisterPermission("inventoryguardian.use", this);
        }

        private bool IsAdmin(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "inventoryguardian.admin") || player.net.connection.authLevel >= igData.AuthLevel)
                return true;            
            return false;
        }

        private bool IsUser(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "inventoryguardian.use") || IsAdmin(player))
                return true;
            return false;
        }
        #endregion

        #region Chat Commands
        [ChatCommand("ig")]
        private void cmdInvGuard(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length == 0)
            {
                if (IsUser(player))
                {
                    MSG(player, " - Save your inventory", "/ig save");
                    MSG(player, " - Restore your inventory", "/ig restore");
                    MSG(player, " - Delete your saved inventory", "/ig delsaved");
                    MSG(player, " - Strip your current inventory", "/ig strip");
                }
                if (IsAdmin(player))
                {
                    MSG(player, " - Save <playername>'s inventory", "/ig save <playername>");
                    MSG(player, " - Restore <playername>'s inventory", "/ig restore <playername>");
                    MSG(player, " - Delete <playername>'s saved inventory", "/ig delsaved <playername>");
                    MSG(player, " - Strip <playername>'s current inventory", "/ig strip <playername>");
                    MSG(player, " - Change the minimum authlevel required to use admin commands", "/ig authlevel <1/2>");                    
                    MSG(player, " - Toggles InventoryGuardian on/off", "/ig toggle");
                    MSG(player, " - Toggles the auto restore funtion", "/ig autorestore");                    
                    MSG(player, " - Toggles the restoration of item condition", "/ig keepcondition");
                }
                return;
            }
            if (args.Length >= 1)
            { 
                if (!igData.IsActivated)
                {
                    if (args[0].ToLower() == "toggle")
                        if (IsAdmin(player))
                        {
                            igData.IsActivated = true;
                            SaveData();
                            MSG(player, "", "You have enabled Inventory Guardian");
                            return;
                        }
                    MSG(player, "", "Inventory Guardian is currently disabled");
                    return;
                }
            else if (igData.IsActivated)
                    switch (args[0].ToLower())
                    {
                        case "save":
                            if (IsAdmin(player))
                            {
                                if (args.Length == 2)
                                {
                                    BasePlayer target = FindPlayer(player, args[1]);
                                    if (target != null)
                                    {
                                        if (SaveInventory(target))
                                        {
                                            MSG(player, "", $"You have successfully saved {target.displayName}'s inventory");
                                            return;
                                        }
                                        MSG(player, "", $"The was a error saving {target.displayName}'s inventory");
                                    }
                                    return;
                                }
                            }
                            else if (IsUser(player))
                            {
                                if (SaveInventory(player))
                                {
                                    MSG(player, "", "You have successfully saved your inventory");
                                    return;
                                }
                                MSG(player, "", "The was a error saving your inventory");
                            }
                            else MSG(player, "You do not have permission to use this command", "", true);
                            return;
                        case "restore":
                            if (IsAdmin(player))
                            {
                                if (args.Length == 2)
                                {
                                    BasePlayer target = FindPlayer(player, args[1]);
                                    if (target != null)
                                    {
                                        if (RestoreInventory(target))
                                        {
                                            MSG(player, "", $"You have successfully restored {target.displayName}'s inventory");
                                            return;
                                        }
                                        MSG(player, "", $"{target.displayName} does not have a saved inventory");
                                    }
                                    return;
                                }
                            }
                            else if (IsUser(player))
                            {
                                if (RestoreInventory(player))
                                {
                                    MSG(player, "", "You have successfully restored your inventory");
                                    return;
                                }
                                MSG(player, "", "You do not have a saved inventory");
                            }
                            else MSG(player, "You do not have permission to use this command", "", true);
                            return;
                        case "delsaved":
                            if (IsAdmin(player))
                            {
                                if (args.Length == 2)
                                {
                                    BasePlayer target = FindPlayer(player, args[1]);
                                    if (target != null)
                                    {
                                        if (RemoveInventory(target))
                                        {
                                            MSG(player, "", $"You have successfully removed {target.displayName}'s inventory");
                                            return;
                                        }
                                        MSG(player, "", $"{target.displayName} does not have a saved inventory");
                                    }
                                    return;
                                }
                            }
                            else if (IsUser(player))
                            {
                                if (RemoveInventory(player))
                                {
                                    MSG(player, "", "You have successfully removed your saved inventory");
                                    return;
                                }
                                MSG(player, "", "You do not have a saved inventory");
                            }
                            else MSG(player, "You do not have permission to use this command", "", true);
                            return;                       
                        case "toggle":
                            if (IsAdmin(player))
                            {
                                if (igData.IsActivated)
                                {
                                    igData.IsActivated = false;
                                    SaveData();
                                    MSG(player, "", "You have disabled Inventory Guardian");
                                    return;
                                }
                            }
                            return;
                        case "autorestore":
                            if (IsAdmin(player))
                            {
                                if (igData.AutoRestore)
                                {
                                    igData.AutoRestore = false;
                                    SaveData();
                                    MSG(player, "You have disabled Auto-Restore", "", true);
                                    return;
                                }
                                else
                                {
                                    igData.AutoRestore = true;
                                    SaveData();
                                    MSG(player, "You have enabled Auto-Restore", "", true);
                                    return;
                                }
                            }
                            return;
                        case "authlevel":
                            if (IsAdmin(player))
                                if (args.Length == 2)
                                {
                                    int i;
                                    if (!int.TryParse(args[1], out i))
                                    {
                                        MSG(player, "", "To set the auth level you must enter either 1/2");
                                        return;
                                    }
                                    igData.AuthLevel = i;
                                    SaveData();
                                    MSG(player, "", $"You have successfully set the required auth level to {i}");
                                }
                            return;
                        case "strip":
                            if (IsAdmin(player))
                            {
                                if (args.Length == 2)
                                {
                                    BasePlayer target = FindPlayer(player, args[1]);
                                    if (target != null)
                                    {
                                        target.inventory.Strip();
                                        MSG(player, "", $"You have successfully stripped {target.displayName}'s inventory");
                                    }
                                    return;
                                }
                            }
                            else if (IsUser(player))
                            {
                                player.inventory.Strip();
                                MSG(player, "", $"You have successfully stripped your inventory");
                            }
                            else MSG(player, "You do not have permission to use this command", "", true);
                            return;
                        case "keepcondition":
                            if (IsAdmin(player))
                            {
                                if (igData.KeepCondition)
                                {
                                    igData.KeepCondition = false;
                                    SaveData();
                                    MSG(player, "You have disabled condition restoration", "", true);
                                    return;
                                }
                                else
                                {
                                    igData.KeepCondition = true;
                                    SaveData();
                                    MSG(player, "You have enabled condition restoration", "", true);
                                    return;
                                }
                            }
                            return;
                    }                    
                }
        }
        #endregion

        #region Console Commands
        [ConsoleCommand("ig")]
        private void ccmdInvGuard(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            { 
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "ig save <playername> - Save <playername>'s inventory");
                SendReply(arg, "ig restore <playername> - Restore <playername>'s inventory");
                SendReply(arg, "ig delsaved <playername> - Delete <playername>'s saved inventory");
                SendReply(arg, "ig strip <playername> - Strip <playername>'s current inventory");
                SendReply(arg, "ig save all - Save all inventories");
                SendReply(arg, "ig restore all - Restore all inventories");
                SendReply(arg, "ig delete all - Delete all saved inventories");
                SendReply(arg, "ig strip all - Strip all player inventories");
                SendReply(arg, "ig authlevel <1/2> - Change the minimum authlevel required to use admin commands");
                SendReply(arg, "ig toggle - Toggles InventoryGuardian on/off");
                SendReply(arg, "ig autorestore - Toggles the auto restore funtion");
                SendReply(arg, "ig keepcondition - Toggles the restoration of item condition");
                return;
            }
            if (arg.Args.Length >= 1)
                switch (arg.Args[0].ToLower())
                {
                    case "save":
                        if (arg.Args.Length == 2)
                        {
                            if (arg.Args[1].ToLower() == "all")
                            {
                                SaveAll();
                                SendReply(arg, "You have successfully saved all player inventories");
                                return;
                            }
                            BasePlayer target = FindPlayer(null, arg.Args[1]);
                            if (target != null)
                            {
                                if (SaveInventory(target))
                                {
                                    SendReply(arg, $"You have successfully saved {target.displayName}'s inventory");
                                    return;
                                }
                                SendReply(arg, $"The was a error saving {target.displayName}'s inventory");
                            }
                        }
                        return;
                    case "restore":
                        if (arg.Args.Length == 2)
                        {
                            if (arg.Args[1].ToLower() == "all")
                            {
                                RestoreAll();
                                SendReply(arg, "You have successfully restored all player inventories");
                                return;
                            }
                            BasePlayer target = FindPlayer(null, arg.Args[1]);
                            if (target != null)
                            {
                                if (RestoreInventory(target))
                                {
                                    SendReply(arg, $"You have successfully restored {target.displayName}'s inventory");
                                    return;
                                }
                                SendReply(arg, $"{target.displayName} does not have a saved inventory");
                            }
                            return;
                        }
                        return;
                    case "delsaved":
                        if (arg.Args.Length == 2)
                        {
                            BasePlayer target = FindPlayer(null, arg.Args[1]);
                            if (target != null)
                            {
                                if (RemoveInventory(target))
                                {
                                    SendReply(arg, $"You have successfully removed {target.displayName}'s inventory");
                                    return;
                                }
                                SendReply(arg, $"{target.displayName} does not have a saved inventory");
                            }
                            return;
                        }
                        return;
                    case "delete":
                        if (arg.Args.Length == 2)
                            if (arg.Args[1].ToLower() == "all")
                            {
                                RemoveAll();
                                SendReply(arg, "You have successfully removed all player inventories");
                            }
                        return;                    
                    case "toggle":
                        if (igData.IsActivated)
                        {
                            igData.IsActivated = false;
                            SaveData();
                            SendReply(arg, "You have disabled Inventory Guardian", true);
                            return;
                        }
                        else
                        {
                            igData.IsActivated = true;
                            SaveData();
                            SendReply(arg, "You have enabled Inventory Guardian", true);
                        }
                        return;
                    case "autorestore":
                        if (igData.AutoRestore)
                        {
                            igData.AutoRestore = false;
                            SaveData();
                            SendReply(arg, "You have disabled Auto-Restore", true);
                            return;
                        }
                        else
                        {
                            igData.AutoRestore = true;
                            SaveData();
                            SendReply(arg, "You have enabled Auto-Restore", true);
                            return;
                        }
                    case "authlevel":
                        if (arg.Args.Length == 2)
                        {
                            int i;
                            if (!int.TryParse(arg.Args[1], out i))
                            {
                                SendReply(arg, "", "To set the auth level you must enter either 1/2");
                                return;
                            }
                            igData.AuthLevel = i;
                            SaveData();
                            SendReply(arg, "", $"You have successfully set the required auth level to {i}");
                        }
                        return;
                    case "strip":
                        if (arg.Args.Length == 2)
                        {
                            if (arg.Args[1].ToLower() == "all")
                            {
                                foreach (var player in BasePlayer.activePlayerList)
                                    player.inventory.Strip();
                                foreach (var player in BasePlayer.sleepingPlayerList)
                                    player.inventory.Strip();
                                SendReply(arg, "You have successfully stripped all player inventories");
                                return;
                            }
                            BasePlayer target = FindPlayer(null, arg.Args[1]);
                            if (target != null)
                            {
                                target.inventory.Strip();
                                SendReply(arg, "", $"You have successfully stripped {target.displayName}'s inventory");
                            }
                        }
                        return;
                    case "keepcondition":
                        if (igData.KeepCondition)
                        {
                            igData.KeepCondition = false;
                            SaveData();
                            SendReply(arg, "", "You have disabled condition restoration", true);
                            return;
                        }
                        else
                        {
                            igData.KeepCondition = true;
                            SaveData();
                            SendReply(arg, "", "You have enabled condition restoration", true);
                            return;
                        }
                }
            }
        }
        #endregion

        #region Classes
        private class IGData
        {
            public bool IsActivated = true;
            public bool AutoRestore = true;
            public bool KeepCondition = true;
            public int AuthLevel = 2;
            public Dictionary<ulong, PlayerInfo> Inventories = new Dictionary<ulong, PlayerInfo>();
        }

        private class PlayerInfo
        {
            public bool RestoreOnce = false;
            public List<SavedItem> Items;
        }

        private class SavedItem
        {
            public string container;
            public int itemid;
            public ulong skin;
            public int amount;
            public float condition;
            public float maxCondition;
            public int ammo;
            public string ammotype;
            public int position;
            public int frequency;
            public InstanceData instanceData;
            public SavedItem[] contents;

            public class InstanceData
            {
                public int dataInt;
                public int blueprintTarget;
                public int blueprintAmount;
                public uint subEntity;

                public InstanceData() { }
                public InstanceData(Item item)
                {
                    if (item.instanceData == null)
                        return;

                    dataInt = item.instanceData.dataInt;
                    blueprintAmount = item.instanceData.blueprintAmount;
                    blueprintTarget = item.instanceData.blueprintTarget;
                }

                public void Restore(Item item)
                {
                    if (item.instanceData == null)
                        item.instanceData = new ProtoBuf.Item.InstanceData();

                    item.instanceData.ShouldPool = false;

                    item.instanceData.blueprintAmount = blueprintAmount;
                    item.instanceData.blueprintTarget = blueprintTarget;
                    item.instanceData.dataInt = dataInt;

                    item.MarkDirty();
                }

                public bool IsValid()
                {
                    return dataInt != 0 || blueprintAmount != 0 || blueprintTarget != 0;
                }
            }
        }
        #endregion

        #region Data Management
        private void SaveData()
        {
            igData.Inventories = cachedInventories;
            Inventory_Data.WriteObject(igData);
            Puts("Saved data");
        }

        private void SaveLoop() => timer.Once(900, () => { SaveData(); SaveLoop(); });

        private void LoadData()
        {
            try
            {
                igData = Inventory_Data.ReadObject<IGData>();
                cachedInventories = igData.Inventories;
            }
            catch
            {
                Puts("Couldn't load player data, creating new datafile");
                igData = new IGData();
            }           
        }
        #endregion

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {
            public string Messages_MainColor { get; set; }
            public string Messages_MsgColor { get; set; }           
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Messages_MainColor = "<color=#FF8C00>",
                Messages_MsgColor = "<color=#939393>"
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

    }
}


// --- End of file: InventoryGuardian.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ip-blacklist ---
// --- Original File Path: I/IPBlacklist/IPBlacklist.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("IPBlacklist", "Ankawi", "1.0.1")]
    [Description("Blacklist IP addresses from joining your server")]
    class IPBlacklist : CovalencePlugin
    {
        private const string IPPerm = "ipblacklist.admin";
        private static HashSet<PlayerData> LoadedPlayerData = new HashSet<PlayerData>();

        #region Data
        class PlayerData
        {
            public string PlayerName;
            public string SteamID;
            public string IP;
        }
        private void LoadData() => LoadedPlayerData = Interface.Oxide.DataFileSystem.ReadObject<HashSet<PlayerData>>("IPBlacklist");
        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("IPBlacklist", LoadedPlayerData);
        #endregion

        #region Comands

        [Command("banip")]
        private void BanipCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(IPPerm) || !player.IsAdmin)
            {
                player.Reply(GetMsg("NoPermission", player.Id));
                return;
            }
            if (args.Length != 1)
            {
                player.Reply(GetMsg("BanSyntax", player.Id));
                return;
            }
            var target = players.FindPlayer(args[0]);

            if (target == null)
            {
                player.Reply(GetMsg("PlayerNotFound", player.Id, args[0].Sanitize()));
                return;
            }

            LoadedPlayerData.Add(new PlayerData
            {
                PlayerName = target.Name,
                SteamID = target.Id,
                IP = target.Address,
            });
            SaveData();
            target.Kick(GetMsg("IPBlacklisted", target.Id));
            player.Reply("{0} was blacklisted", target.Name);
        }

        [Command("unbanip")]
        private void UnbanipCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(IPPerm) || !player.IsAdmin)
            {
                player.Reply(GetMsg("NoPermission", player.Id));
                return;
            }
            if (args.Length != 1)
            {
                player.Reply(GetMsg("UnbanSyntax", player.Id));
                return;
            }
            var target = players.FindPlayer(args[0]);

            if (target == null)
            {
                player.Reply(GetMsg("PlayerNotFound", player.Id, args[0].Sanitize()));
                return;
            }

            LoadedPlayerData.RemoveWhere(p => p.SteamID == target.Id);
            SaveData();
            player.Reply("{0} was unblacklisted", target.Name);
        }
        #endregion

        #region Functions
        private void Init()
        {
            permission.RegisterPermission(IPPerm, this);
            LoadData();
            LoadDefaultMessages();
        }
        private object CanUserLogin(string name, string id, string ip) => !LoadedPlayerData.Any(p => p.IP == ip || p.SteamID == id);
        //private object CanUserLogin(string name, string id, string ip)
        //{
        //    foreach (var data in LoadedPlayerData)
        //    {
        //        if (data.IP.Contains(ip) || data.SteamID.Contains(id))
        //        {
        //            return GetMsg("IPBlacklisted", id);
        //        }
        //    }
        //    return null;
        //}
        #endregion

        #region Lang
        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["IPBlacklisted"] = "You are not allowed to play on this server",
                ["BanSyntax"] = "ipban <target>",
                ["UnbanSyntax"] = "unbanip <target>",
                ["NoPermission"] = "You do not have permission to use this command",
                ["PlayerNotFound"] = "{0} was not found"
            }, this, "en");
        }
        #endregion

        #region Helpers
        private string GetMsg(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        #endregion
    }
}

// --- End of file: IPBlacklist.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ip-logger ---
// --- Original File Path: I/IPLogger/IPLogger.cs ---

﻿using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("IP Logger", "redBDGR", "1.0.1")]
    [Description("Logs all player IP addresses for easy comparison")]
    class IPLogger : CovalencePlugin
    {
        bool Changed = false;

        #region Data

        DynamicConfigFile IPInfo;
        StoredData storedData;

        Dictionary<string, List<string>> PlayerInfo = new Dictionary<string, List<string>>();

        class StoredData
        {
            public Dictionary<string, List<string>> IPLog = new Dictionary<string, List<string>>();
        }

        void Init()
        {
            IPInfo = Interface.Oxide.DataFileSystem.GetFile(Name);
            LoadData();
        }

        void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(this.Title);
                PlayerInfo = storedData.IPLog;
            }
            catch
            {
                Puts("Failed to load data, creating new file");
                storedData = new StoredData();
            }
        }

        void SaveData()
        {
            storedData.IPLog = PlayerInfo;
            IPInfo.WriteObject(storedData);
        }

        #endregion

        #region Loading / Saving

        void Unload() => SaveData();
        void OnServerSave() => SaveData();

        #endregion

        void OnUserConnected(IPlayer player)
        {
            string IP = player.Address;
            int index = IP.IndexOf(":");
            if (index > 0)
                    IP = IP.Substring(0, index);
            if (PlayerInfo.ContainsKey(player.Id))
            {
                if (PlayerInfo[player.Id].Contains(IP))
                    return;
                else
                    PlayerInfo[player.Id].Add(IP);
            }
            else
            {
                PlayerInfo.Add(player.Id, new List<string>());
                PlayerInfo[player.Id].Add(IP);
            }
        }

        private List<string> RetrieveIPs (string userID)
        {
            List<string> x;
            if (PlayerInfo.TryGetValue(userID, out x))
                return x;
            return null;
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
    }
}


// --- End of file: IPLogger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/info-menu ---
// --- Original File Path: I/InfoMenu/InfoMenu.cs ---

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Info Menu", "Iv Misticos", "1.0.3")]
    [Description("Show server info and help with the ability to run popular commands")]
    class InfoMenu : RustPlugin
    {
        #region Variables

        private const float InitialLoadDelay = 10f;

        private bool _firstCached = false;
        private bool _firstCaching = false;

        private const string PermissionRecacheUI = "infomenu.recacheui";

        private const string CommandRecacheUI = "infomenu.recacheui";

        private static InfoMenu _ins;

        [PluginReference]
        // ReSharper disable once InconsistentNaming
        private Plugin ImageLibrary = null;

        [PluginReference]
        // ReSharper disable once InconsistentNaming
        private Plugin PlaceholderAPI = null;

        #endregion

        #region Configuration

        private static Configuration _config;

        internal class Configuration
        {
            [JsonProperty(PropertyName = "Tabs", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Tab> Tabs = new List<Tab> {new Tab()};

            [JsonProperty(PropertyName = "Static Elements", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Button> Buttons = new List<Button> {new Button()};

            [JsonProperty(PropertyName = "Default Tab")]
            public string DefaultTab = "tab1";

            [JsonProperty(PropertyName = "Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Commands = new List<string> {"menu", "info", "help"};

            [JsonProperty(PropertyName = "Menu UI")]
            public UISettings UI = new UISettings();

            // ReSharper disable MemberCanBePrivate.Global
            public class UISettings
            {
                [JsonProperty(PropertyName = "Menu Position")]
                public UIData.Position MenuPosition = new UIData.Position
                {
                    Anchors = new UIData.Anchors
                    {
                        AnchorMinX = 0.5f,
                        AnchorMinY = 0.5f,
                        AnchorMaxX = 0.5f,
                        AnchorMaxY = 0.5f
                    },
                    Offsets = new UIData.Offsets
                    {
                        OffsetMinX = -400,
                        OffsetMinY = -300,
                        OffsetMaxX = 400,
                        OffsetMaxY = 300
                    }
                };

                [JsonProperty(PropertyName = "Menu Background Color")]
                public UIData.Colors MenuBackgroundColor = new UIData.Colors();

                [JsonProperty(PropertyName = "Menu Color")]
                public UIData.Colors MenuColor = new UIData.Colors();

                [JsonProperty(PropertyName = "Menu Title Background Position")]
                public UIData.Position MenuTitleBackgroundPosition = new UIData.Position();

                [JsonProperty(PropertyName = "Menu Title Background Color")]
                public UIData.Colors MenuTitleBackgroundColor = new UIData.Colors();

                [JsonProperty(PropertyName = "Menu Title Text")]
                public string MenuTitleText = "<size=3em>Info Menu</size>";

                [JsonProperty(PropertyName = "Menu Title Text Anchor")]
                [JsonConverter(typeof(StringEnumConverter))]
                public TextAnchor MenuTitleTextAnchor = TextAnchor.MiddleCenter;

                [JsonProperty(PropertyName = "Menu Title Placeholder API")]
                public bool MenuTitlePlaceholder = false;

                [JsonIgnore]
                public CuiElement ParsedMenuBackground;

                [JsonIgnore]
                public CuiElement ParsedMenuBackgroundButton;

                [JsonIgnore]
                public CuiElement ParsedMenu;

                [JsonIgnore]
                public CuiElement ParsedMenuTitleBackground;

                [JsonIgnore]
                public CuiElement ParsedMenuTitle;

                [JsonIgnore]
                public readonly string MenuName = "InfoMenu";

                [JsonIgnore]
                public readonly string MenuBackgroundName = "InfoMenu.Background";

                [JsonIgnore]
                public readonly string MenuBackgroundButtonName = "InfoMenu.Background.Button";

                [JsonIgnore]
                public readonly string MenuTitleBackgroundName = "InfoMenu.Title.Background";

                [JsonIgnore]
                public readonly string MenuTitleName = "InfoMenu.Title";

                #region Generation

                public CuiElement GetMenuBackground()
                {
                    var imageComponent = new CuiRawImageComponent();
                    if (MenuBackgroundColor.IsLink)
                    {
                        imageComponent.Png = ImageLibraryGet(MenuBackgroundName);
                    }
                    else
                    {
                        imageComponent.Color = MenuBackgroundColor.GetColor;
                        imageComponent.Sprite = MenuBackgroundColor.Sprite;
                        imageComponent.Material = MenuBackgroundColor.Material;
                    }

                    return new CuiElement
                    {
                        Name = MenuBackgroundName,
                        Parent = "Overlay",
                        Components =
                        {
                            imageComponent,
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.0 0.0",
                                AnchorMax = "1.0 1.0"
                            },
                            new CuiNeedsCursorComponent()
                        }
                    };
                }

                public CuiElement GetMenuBackgroundButton()
                {
                    return new CuiElement
                    {
                        Name = MenuBackgroundButtonName,
                        Parent = MenuBackgroundName,
                        Components =
                        {
                            new CuiButtonComponent
                            {
                                Color = "0.0 0.0 0.0 0.0",
                                Close = MenuBackgroundName
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.0 0.0",
                                AnchorMax = "1.0 1.0"
                            }
                        }
                    };
                }

                public CuiElement GetMenu()
                {
                    var imageComponent = new CuiRawImageComponent();
                    if (MenuColor.IsLink)
                    {
                        imageComponent.Png = ImageLibraryGet(MenuName);
                    }
                    else
                    {
                        imageComponent.Color = MenuColor.GetColor;
                        imageComponent.Sprite = MenuColor.Sprite;
                        imageComponent.Material = MenuColor.Material;
                    }

                    return new CuiElement
                    {
                        Name = MenuName,
                        Parent = MenuBackgroundButtonName,
                        Components =
                        {
                            imageComponent,
                            new CuiRectTransformComponent
                            {
                                AnchorMin = MenuPosition.Anchors.AnchorsMin,
                                AnchorMax = MenuPosition.Anchors.AnchorsMax,
                                OffsetMin = MenuPosition.Offsets.OffsetsMin,
                                OffsetMax = MenuPosition.Offsets.OffsetsMax
                            },
                            new CuiNeedsCursorComponent()
                        }
                    };
                }

                public CuiElement GetMenuTitleBackground()
                {
                    var imageComponent = new CuiRawImageComponent();
                    if (MenuTitleBackgroundColor.IsLink)
                    {
                        imageComponent.Png = ImageLibraryGet(MenuTitleBackgroundName);
                    }
                    else
                    {
                        imageComponent.Color =
                            MenuTitleBackgroundColor.GetColor;
                        imageComponent.Sprite = MenuTitleBackgroundColor.Sprite;
                        imageComponent.Material = MenuTitleBackgroundColor.Material;
                    }

                    return new CuiElement
                    {
                        Name = MenuTitleBackgroundName,
                        Parent = MenuName,
                        Components =
                        {
                            imageComponent,
                            new CuiRectTransformComponent
                            {
                                AnchorMin = _config.UI.MenuTitleBackgroundPosition.Anchors.AnchorsMin,
                                AnchorMax = _config.UI.MenuTitleBackgroundPosition.Anchors.AnchorsMax,
                                OffsetMin = _config.UI.MenuTitleBackgroundPosition.Offsets.OffsetsMin,
                                OffsetMax = _config.UI.MenuTitleBackgroundPosition.Offsets.OffsetsMax
                            },
                            new CuiNeedsCursorComponent()
                        }
                    };
                }

                public CuiElement GetMenuTitle(IPlayer player = null)
                {
                    return new CuiElement
                    {
                        Name = MenuTitleName,
                        Parent = MenuTitleBackgroundName,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Align = MenuTitleTextAnchor,
                                Text = MenuTitlePlaceholder ? ProcessPlaceholders(player, MenuTitleText) : MenuTitleText
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.0 0.0",
                                AnchorMax = "1.0 1.0"
                            }
                        }
                    };
                }

                #endregion
            }
            // ReSharper restore MemberCanBePrivate.Global

            public class Button
            {
                [JsonProperty(PropertyName = "Permission")]
                public string Permission = "infomenu.view";

                [JsonProperty(PropertyName = "Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<CommandData> Commands = new List<CommandData>
                {
                    new CommandData
                    {
                        Command = "menu",
                        Arguments = new object[] {"open", "tab1"}
                    }
                };

                [JsonProperty(PropertyName = "UI")]
                public ButtonUI UI = new ButtonUI();

                // ReSharper disable MemberCanBePrivate.Global
                public class ButtonUI
                {
                    [JsonProperty(PropertyName = "Background Color")]
                    public UIData.Colors Color = new UIData.Colors();

                    [JsonProperty(PropertyName = "Background Position")]
                    public UIData.Position Position = new UIData.Position();

                    [JsonProperty(PropertyName = "Text")]
                    public string Text = "Text";

                    [JsonProperty(PropertyName = "Text Anchor")]
                    [JsonConverter(typeof(StringEnumConverter))]
                    public TextAnchor TextAnchor = TextAnchor.MiddleCenter;

                    [JsonProperty(PropertyName = "Text Placeholder API")]
                    public bool TextPlaceholder = false;

                    [JsonIgnore]
                    public CuiElement ParsedButtonBackground;

                    [JsonIgnore]
                    public CuiElement ParsedButton;

                    [JsonIgnore]
                    public CuiElement ParsedButtonText;

                    [JsonIgnore]
                    public string CommandName = "infomenu." + Guid.NewGuid();

                    [JsonIgnore]
                    public string ButtonBackgroundName = "InfoMenu.Button.Background." + Guid.NewGuid();

                    [JsonIgnore]
                    public string ButtonName = "InfoMenu.Button." + Guid.NewGuid();

                    [JsonIgnore]
                    public string ButtonTextName = "InfoMenu.Button.Text." + Guid.NewGuid();

                    #region Generation

                    public CuiElement GetButtonBackground()
                    {
                        var imageComponent = new CuiRawImageComponent();
                        if (Color.IsLink)
                        {
                            imageComponent.Png = ImageLibraryGet(ButtonBackgroundName);
                        }
                        else
                        {
                            imageComponent.Color = Color.GetColor;
                            imageComponent.Sprite = Color.Sprite;
                            imageComponent.Material = Color.Material;
                        }

                        return new CuiElement
                        {
                            Name = ButtonBackgroundName,
                            Parent = _config.UI.MenuName,
                            Components =
                            {
                                imageComponent,
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = Position.Anchors.AnchorsMin,
                                    AnchorMax = Position.Anchors.AnchorsMax,
                                    OffsetMin = Position.Offsets.OffsetsMin,
                                    OffsetMax = Position.Offsets.OffsetsMax
                                },
                                new CuiNeedsCursorComponent()
                            }
                        };
                    }

                    public CuiElement GetButton()
                    {
                        return new CuiElement
                        {
                            Name = ButtonName,
                            Parent = ButtonBackgroundName,
                            Components =
                            {
                                new CuiButtonComponent
                                {
                                    Color = "0.0 0.0 0.0 0.0",
                                    Command = CommandName
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.0 0.0",
                                    AnchorMax = "1.0 1.0"
                                }
                            }
                        };
                    }

                    public CuiElement GetButtonText(IPlayer player = null)
                    {
                        return new CuiElement
                        {
                            Name = ButtonTextName,
                            Parent = ButtonName,
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Align = TextAnchor,
                                    Text = TextPlaceholder ? ProcessPlaceholders(player, Text) : Text
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.0 0.0",
                                    AnchorMax = "1.0 1.0"
                                }
                            }
                        };
                    }

                    #endregion
                }
                // ReSharper restore MemberCanBePrivate.Global
            }

            public class Tab
            {
                [JsonProperty(PropertyName = "Technical Name")]
                public string Name = "tab1";

                [JsonProperty(PropertyName = "Permission")]
                public string Permission = "infomenu.view";
                
                [JsonProperty(PropertyName = "Elements", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<Button> Buttons = new List<Button> {new Button()};
            }

            public class CommandData
            {
                [JsonProperty(PropertyName = "Command")]
                public string Command = string.Empty;

                [JsonProperty(PropertyName = "Arguments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public object[] Arguments = {"argument"};
            }
        }

        // ReSharper disable MemberCanBePrivate.Global
        internal class UIData
        {
            public class Colors
            {
                [JsonProperty(PropertyName = "Transparency")]
                public float Transparency = 1.0f;

                [JsonProperty(PropertyName = "Color")]
                public string Color = "#aaaaaa";

                [JsonProperty(PropertyName = "Link")]
                public string Link = string.Empty;

                [JsonProperty(PropertyName = "Sprite")]
                public string Sprite = "Assets/Content/UI/UI.Background.Tile.psd";

                [JsonProperty(PropertyName = "Material")]
                public string Material = "Assets/Icons/IconMaterial.mat";

                [JsonIgnore]
                public string GetColor => GetColor(Color, Transparency);

                [JsonIgnore]
                public bool IsLink => !string.IsNullOrEmpty(Link);
            }

            public class Position
            {
                [JsonProperty(PropertyName = "Anchors")]
                public Anchors Anchors = new Anchors();

                [JsonProperty(PropertyName = "Offsets")]
                public Offsets Offsets = new Offsets();
            }

            public class Anchors
            {
                [JsonProperty(PropertyName = "Anchor Min X")]
                public float AnchorMinX = 0.0f;

                [JsonProperty(PropertyName = "Anchor Min Y")]
                public float AnchorMinY = 0.0f;

                [JsonProperty(PropertyName = "Anchor Max X")]
                public float AnchorMaxX = 1.0f;

                [JsonProperty(PropertyName = "Anchor Max Y")]
                public float AnchorMaxY = 1.0f;

                [JsonIgnore]
                public string AnchorsMin => $"{AnchorMinX} {AnchorMinY}";

                [JsonIgnore]
                public string AnchorsMax => $"{AnchorMaxX} {AnchorMaxY}";
            }

            public class Offsets
            {
                [JsonProperty(PropertyName = "Offset Min X")]
                public int OffsetMinX = -50;

                [JsonProperty(PropertyName = "Offset Min Y")]
                public int OffsetMinY = -50;

                [JsonProperty(PropertyName = "Offset Max X")]
                public int OffsetMaxX = 50;

                [JsonProperty(PropertyName = "Offset Max Y")]
                public int OffsetMaxY = 50;

                [JsonIgnore]
                public string OffsetsMin => $"{OffsetMinX} {OffsetMinY}";

                [JsonIgnore]
                public string OffsetsMax => $"{OffsetMaxX} {OffsetMaxY}";
            }
        }
        // ReSharper restore MemberCanBePrivate.Global

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {
                    "Invalid Syntax", "Invalid command syntax. Usage:\n" +
                                      "open <Tab> - Open a tab\n" +
                                      "close - Close UI"
                },
                {"Only Players", "This command is available only for players."},
                {"No Tab", "Sorry, we couldn't find this tab (or you don't have enough permissions)."},
                {"No Recache Permission", "You don't have enough permissions (infomenu.recacheui)."},
                {"Recached", "All UI was successfully recached."},
                {"Initial Caching", "Please, wait. UI is caching. It can take up to 10 seconds and it will be opened automatically."}
            }, this);
        }

        private void Init()
        {
            _ins = this;
            
            permission.RegisterPermission(PermissionRecacheUI, this);

            foreach (var command in _config.Commands)
            {
                AddCovalenceCommand(command, nameof(CommandInfoMenu));
            }
            
            AddCovalenceCommand(CommandRecacheUI, nameof(CommandInfoMenuRecacheUI));
        }

        private void OnServerInitialized()
        {
            if (_config.UI.MenuBackgroundColor.IsLink)
            {
                ImageLibraryLoad(_config.UI.MenuBackgroundName, _config.UI.MenuBackgroundColor.Link);
            }

            if (_config.UI.MenuColor.IsLink)
            {
                ImageLibraryLoad(_config.UI.MenuName, _config.UI.MenuColor.Link);
            }

            if (_config.UI.MenuTitleBackgroundColor.IsLink)
            {
                ImageLibraryLoad(_config.UI.MenuTitleBackgroundName, _config.UI.MenuTitleBackgroundColor.Link);
            }

            foreach (var button in _config.Buttons)
            {
                SetupButton(button);
            }

            foreach (var tab in _config.Tabs)
            {
                // Check for existance to prevent load spam if same permissions used
                if (!string.IsNullOrEmpty(tab.Permission) && !permission.PermissionExists(tab.Permission))
                    permission.RegisterPermission(tab.Permission, this);

                foreach (var button in tab.Buttons)
                {
                    SetupButton(button);
                }
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                InterfaceClose(player);
            }

            _ins = null;
            _config = null;
        }

        #endregion

        #region Commands

        private void CommandInfoMenuRecacheUI(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionRecacheUI))
            {
                player.Reply(GetMsg("No Recache Permission", player.Id));
                return;
            }
            
            CacheUI();
            player.Reply(GetMsg("Recached", player.Id));
        }

        private void CommandInfoMenu(IPlayer player, string command, string[] args)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
            {
                player.Reply(GetMsg("Only Players", player.Id));
                return;
            }

            if (args == null || args.Length == 0)
                args = new[] {"open"};

            switch (args[0].ToLower())
            {
                case "open":
                {
                    var tab = args.Length < 2 ? _config.DefaultTab : args[1];

                    InterfaceClose(basePlayer);
                    InterfaceShow(player, tab);
                    return;
                }

                case "close":
                {
                    InterfaceClose(basePlayer);
                    return;
                }

                default:
                {
                    goto invalidSyntax;
                }
            }

            invalidSyntax:
            player.Reply(GetMsg("Invalid Syntax", player.Id));
        }

        #endregion

        #region UI

        private void CacheUI()
        {
            _config.UI.ParsedMenuBackground = _config.UI.GetMenuBackground();
            _config.UI.ParsedMenuBackgroundButton = _config.UI.GetMenuBackgroundButton();
            
            _config.UI.ParsedMenu = _config.UI.GetMenu();
            _config.UI.ParsedMenuTitleBackground = _config.UI.GetMenuTitleBackground();

            if (!_config.UI.MenuTitlePlaceholder)
            {
                _config.UI.ParsedMenuTitle = _config.UI.GetMenuTitle();
            }

            foreach (var button in _config.Buttons)
            {
                CacheButton(button);
            }

            foreach (var tab in _config.Tabs)
            {
                foreach (var button in tab.Buttons)
                {
                    CacheButton(button);
                }
            }
            
            _firstCached = true;
        }

        private void InterfaceShow(IPlayer player, string tabName)
        {
            if (!_firstCached)
            {
                player.Reply(GetMsg("Initial Caching", player.Id));
                
                if (_firstCaching)
                    return;

                _firstCaching = true;
                
                timer.Once(InitialLoadDelay, () =>
                {
                    CacheUI();
                    InterfaceShow(player, tabName);
                });

                return;
            }

            Configuration.Tab selectedTab = null;
            foreach (var tab in _config.Tabs)
            {
                if (tab.Name != tabName || !string.IsNullOrEmpty(tab.Permission) &&
                    !player.HasPermission(tab.Permission))
                    continue;

                selectedTab = tab;
                break;
            }

            if (selectedTab == null)
            {
                player.Reply(GetMsg("No Tab", player.Id));
                return;
            }

            var container = new CuiElementContainer
            {
                // Menu background
                _config.UI.ParsedMenuBackground,

                // Menu background button
                _config.UI.ParsedMenuBackgroundButton,

                // Menu itself
                _config.UI.ParsedMenu,

                // Title background
                _config.UI.ParsedMenuTitleBackground,

                // Title text
                _config.UI.MenuTitlePlaceholder
                    ? _config.UI.GetMenuTitle(player)
                    : _config.UI.ParsedMenuTitle
            };

            foreach (var button in _config.Buttons)
            {
                InterfaceAddButton(player, container, button);
            }

            foreach (var button in selectedTab.Buttons)
            {
                InterfaceAddButton(player, container, button);
            }

            CuiHelper.AddUi(player.Object as BasePlayer, container);
        }

        private void InterfaceAddButton(IPlayer player, CuiElementContainer container, Configuration.Button button)
        {
            if (!string.IsNullOrEmpty(button.Permission) && !player.HasPermission(button.Permission))
                return;

            container.Add(button.UI.ParsedButtonBackground);
            container.Add(button.UI.ParsedButton);
            container.Add(button.UI.TextPlaceholder ? button.UI.GetButtonText(player) : button.UI.ParsedButtonText);
        }

        private void InterfaceClose(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, _config.UI.MenuBackgroundName);
        }

        private void SetupButton(Configuration.Button button)
        {
            // Check for existance to prevent load spam if same permissions used
            if (!string.IsNullOrEmpty(button.Permission) && !permission.PermissionExists(button.Permission))
                permission.RegisterPermission(button.Permission, this);

            cmd.AddConsoleCommand(button.UI.CommandName, this, arg =>
            {
                var basePlayer = arg.Player();
                if (basePlayer == null)
                    return false;

                foreach (var commandData in button.Commands)
                {
                    basePlayer.SendConsoleCommand(commandData.Command, commandData.Arguments);
                }

                return false;
            });
            
            if (button.UI.Color.IsLink)
            {
                ImageLibraryLoad(button.UI.ButtonBackgroundName, button.UI.Color.Link);
            }
        }

        private void CacheButton(Configuration.Button button)
        {
            button.UI.ParsedButtonBackground = button.UI.GetButtonBackground();
            button.UI.ParsedButton = button.UI.GetButton();

            if (!button.UI.TextPlaceholder)
            {
                button.UI.ParsedButtonText = button.UI.GetButtonText();
            }
        }

        #endregion

        #region Helpers

        private static string ProcessPlaceholders(IPlayer player, string text)
        {
            if (!_ins.PlaceholderAPILoaded())
            {
                Interface.Oxide.LogWarning("Info Menu requires Image Library for links support.");
                return text;
            }
            
            var builder = new StringBuilder(text);
            _ins.PlaceholderAPI?.CallHook("ProcessPlaceholders", player, builder);

            return builder.ToString();
        }

        private static string ImageLibraryGet(string name)
        {
            if (_ins.ImageLibraryLoaded())
            {
                return _ins.ImageLibrary.Call<string>("GetImage", name);
            }

            Interface.Oxide.LogWarning("Unable to get link for menu. Please, check whether Image Library is loaded.");
            return string.Empty;

        }

        private static void ImageLibraryLoad(string name, string link)
        {
            if (!_ins.ImageLibraryLoaded())
            {
                Interface.Oxide.LogWarning("Info Menu requires Image Library for links support.");
                return;
            }

            _ins.ImageLibrary.Call("AddImage", link, name, 0UL);
        }

        private bool ImageLibraryLoaded() => _ins.ImageLibrary != null && _ins.ImageLibrary.IsLoaded;
        
        private bool PlaceholderAPILoaded() => _ins.PlaceholderAPI != null && _ins.PlaceholderAPI.IsLoaded;

        private static string GetColor(string hex, float alpha)
        {
            var color = ColorTranslator.FromHtml(hex);
            var r = Convert.ToInt16(color.R) / 255f;
            var g = Convert.ToInt16(color.G) / 255f;
            var b = Convert.ToInt16(color.B) / 255f;

            return $"{r} {g} {b} {alpha}";
        }

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion
    }
}

// --- End of file: InfoMenu.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-untie ---
// --- Original File Path: I/InstantUntie/InstantUntie.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins;

[Info("Instant Untie", "MJSU", "1.0.13")]
[Description("Instantly untie underwater boxes")]
internal class InstantUntie : RustPlugin
{
    #region Class Fields
    private PluginConfig _pluginConfig; //Plugin Config

    private const string UsePermission = "instantuntie.use";

    private static InstantUntie _ins;
        
    private const string AccentColor = "#de8732";
        
    #endregion

    #region Setup & Loading
    private void Init()
    {
        _ins = this;
        permission.RegisterPermission(UsePermission, this);
    }

    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            [LangKeys.Chat] = $"<color=#bebebe>[<color={AccentColor}>{Title}</color>] {{0}}</color>",
            [LangKeys.Untie] = "The box will untie in {0} seconds. Please hold the use key down until this is completed.",
            [LangKeys.Canceled] = "You have canceled untying the box. Please hold the use key down to untie."
        }, this);
    }
        
    protected override void LoadDefaultConfig()
    {
        PrintWarning("Loading Default Config");
    }

    protected override void LoadConfig()
    {
        base.LoadConfig();
        Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
        _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
        Config.WriteObject(_pluginConfig);
    }

    private PluginConfig AdditionalConfig(PluginConfig config)
    {
        return config;
    }

    private void OnServerInitialized()
    {
        foreach (BasePlayer player in BasePlayer.activePlayerList)
        {
            AddBehavior(player);
        }
    }

    private void OnPlayerConnected(BasePlayer player)
    {
        AddBehavior(player);
    }

    private void OnPlayerDisconnected(BasePlayer player, string reason)
    {
        DestroyBehavior(player);
    }

    private void Unload()
    {
        foreach (UnderwaterBehavior water in GameObject.FindObjectsOfType<UnderwaterBehavior>())
        {
            water.DoDestroy();
        }

        _ins = null;
    }
    #endregion

    #region uMod Hooks
    private void OnUserPermissionGranted(string playerId, string permName)
    {
        if (permName != UsePermission)
        {
            return;
        }
            
        HandleUserChanges(playerId);
    }
        
    private void OnUserPermissionRevoked(string playerId, string permName)
    {
        if (permName != UsePermission)
        {
            return;
        }
            
        HandleUserChanges(playerId);
    }
        
    private void OnUserGroupAdded(string playerId, string groupName)
    {
        HandleUserChanges(playerId);
    }
        
    private void OnUserGroupRemoved(string playerId, string groupName)
    {
        HandleUserChanges(playerId);
    }

    private void OnGroupPermissionGranted(string groupName, string permName)
    {
        if (permName != UsePermission)
        {
            return;
        }

        NextTick(() =>
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                HandleUserChanges(player);
            }
        });
    }
        
    private void OnGroupPermissionRevoked(string groupName, string permName)
    {
        if (permName != UsePermission)
        {
            return;
        }
            
        NextTick(() =>
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                HandleUserChanges(player);
            }
        });
    }

    private void HandleUserChanges(string id)
    {
        NextTick(() =>
        {
            BasePlayer player = BasePlayer.Find(id);
            if (player == null)
            {
                return;
            }

            HandleUserChanges(player);
        });
    }

    private void HandleUserChanges(BasePlayer player)
    {
        bool hasPerm = HasPermission(player, UsePermission);
        bool hasBehavior = player.GetComponent<UnderwaterBehavior>() != null;
        if (hasPerm == hasBehavior)
        {
            return;
        }

        if (hasBehavior)
        {
            DestroyBehavior(player);
        }
        else
        {
            AddBehavior(player);
        }
    }
    #endregion

    #region Helper Methods
    private T Raycast<T>(Ray ray, float distance) where T : BaseEntity
    {
        RaycastHit hit;
        if (!Physics.Raycast(ray, out hit, distance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore))
        {
            return null;
        }

        return hit.GetEntity() as T;
    }

    private void AddBehavior(BasePlayer player)
    {
        if (!HasPermission(player, UsePermission))
        {
            return;
        }

        if (player.GetComponent<UnderwaterBehavior>() == null)
        {
            player.gameObject.AddComponent<UnderwaterBehavior>();
        }
    }

    private void DestroyBehavior(BasePlayer player)
    {
        player.GetComponent<UnderwaterBehavior>()?.DoDestroy();
    }

    private void Chat(BasePlayer player, string format) => PrintToChat(player, Lang(LangKeys.Chat, player, format));
        
    private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

    private string Lang(string key, BasePlayer player = null)
    {
        return lang.GetMessage(key, this, player ? player.UserIDString : null);
    }
        
    private string Lang(string key, BasePlayer player = null, params object[] args)
    {
        try
        {
            return string.Format(Lang(key, player), args);
        }
        catch(Exception ex)
        {
            PrintError($"Lang Key '{key}' threw exception\n:{ex}");
            throw;
        }
    }
    #endregion

    #region Behavior
    private class UnderwaterBehavior : FacepunchBehaviour
    {
        private BasePlayer _player;
        private FreeableLootContainer _box;
        private float _nextRaycastTime;

        private void Awake()
        {
            enabled = false;
            _player = GetComponent<BasePlayer>();
            InvokeRandomized(UpdateUnderwater, 0f, _ins._pluginConfig.UnderWaterUpdateRate, 0.1f);
        }

        private void UpdateUnderwater()
        {
            bool isUnderwater = _player.WaterFactor() == 1f;
            if (isUnderwater && !enabled)
            {
                enabled = true;
            }
            else if (!isUnderwater && enabled)
            {
                enabled = false;
            }
        }

        private void FixedUpdate()
        {
            if (!_box)
            {
                if (_nextRaycastTime < Time.realtimeSinceStartup && _player.serverInput.IsDown(BUTTON.USE))
                {
                    _box = _ins.Raycast<FreeableLootContainer>(_player.eyes.HeadRay(), 3f);
                    if (!_box || !_box.IsTiedDown())
                    {
                        return;
                    }

                    _nextRaycastTime = Time.realtimeSinceStartup + _ins._pluginConfig.HeldKeyUpdateRate;
                    CancelInvoke(Untie);
                    Invoke(Untie, _ins._pluginConfig.UntieDuration);
                    if (_ins._pluginConfig.ShowUntieMessage)
                    {
                        _ins.Chat(_player, _ins.Lang(LangKeys.Untie, _player, _ins._pluginConfig.UntieDuration));
                    }
                }
            }
            else if (!_player.serverInput.IsDown(BUTTON.USE))
            {
                _box = null;
                CancelInvoke(Untie);

                if (_ins._pluginConfig.ShowCanceledMessage)
                {
                    _ins.Chat(_player, _ins.Lang(LangKeys.Canceled));
                }
            }
        }

        private void Untie()
        {
            if (!_box || !_box.IsTiedDown())
            {
                return;
            }

            _box.buoyancy.buoyancyScale = _ins._pluginConfig.BuoyancyScale;
            _box.GetRB().isKinematic = false;
            _box.buoyancy.enabled = true;
            _box.SetFlag(BaseEntity.Flags.Reserved8, false);
            _box.SendNetworkUpdate();
            if (_ins._pluginConfig.SetOwnerId)
            {
                _box.OwnerID = _player.userID;
            }
            if (_box.freedEffect.isValid)
            {
                Effect.server.Run(_box.freedEffect.resourcePath, _box.transform.position, Vector3.up);
            }

            _player.ProcessMissionEvent(BaseMission.MissionEventType.FREE_CRATE, _box.net.ID, 1f);
                
            _box = null;
        }

        public void DoDestroy()
        {
            Destroy(this);
        }
    }
    #endregion

    #region Classes

    private class LangKeys
    {
        public const string Chat = "Chat";
        public const string Untie = "Untie";
        public const string Canceled = "UntieCanceled";
    }

    private class PluginConfig
    {
        [DefaultValue(0f)]
        [JsonProperty(PropertyName = "Untie Duration (Seconds)")]
        public float UntieDuration { get; set; }

        [DefaultValue(5f)]
        [JsonProperty(PropertyName = "How often to check if player is underwater (Seconds)")]
        public float UnderWaterUpdateRate { get; set; }
            
        [DefaultValue(1f)]
        [JsonProperty(PropertyName = "How often to check if a player is holding the use button (Seconds)")]
        public float HeldKeyUpdateRate { get; set; }
            
        [DefaultValue(true)]
        [JsonProperty(PropertyName = "Show Untie Message")]
        public bool ShowUntieMessage { get; set; }
            
        [DefaultValue(true)]
        [JsonProperty(PropertyName = "Show canceled message")]
        public bool ShowCanceledMessage { get; set; }
            
        [DefaultValue(1)]
        [JsonProperty(PropertyName = "Buoyancy Scale")]
        public float BuoyancyScale { get; set; }
            
        [DefaultValue(false)]
        [JsonProperty(PropertyName = "Set box owner as untie player")]
        public bool SetOwnerId { get; set; }
    }
    #endregion
}

// --- End of file: InstantUntie.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-mixing-table ---
// --- Original File Path: I/InstantMixingTable/InstantMixingTable.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Instant Mixing Table", "MJSU", "1.0.0")]
    [Description("Allows players to instantly mix teas")]
    internal class InstantMixingTable : RustPlugin
    {
        #region Class Fields
        private PluginConfig _pluginConfig; //Plugin Config

        private const string PermBase = "instantmixingtable.";
        private const string UsePermission = PermBase + "use";
        #endregion

        #region Setup & Loading
        private void Init()
        {
            foreach (string perm in _pluginConfig.PlayerDurationMultiplier.Keys)
            {
                if (!perm.StartsWith(PermBase))
                {
                    PrintWarning($"Permissions {perm} was skipped. Permissions must start with ${PermBase}");
                    continue;
                }
                
                permission.RegisterPermission(perm, this);
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.PlayerDurationMultiplier = config.PlayerDurationMultiplier ?? new Hash<string, float>
            {
                [UsePermission] = 0f,
            };
            return config;
        }
        #endregion

        #region Hooks

        private void OnMixingTableToggle(MixingTable table, BasePlayer player)
        {
            if (table.IsOn())
            {
                return;
            }

            NextTick(() =>
            {
                foreach (KeyValuePair<string,float> permSpeed in _pluginConfig.PlayerDurationMultiplier.OrderBy(p => p.Value))
                {
                    if (HasPermission(player, permSpeed.Key))
                    {
                        table.RemainingMixTime *= permSpeed.Value;
                        table.TotalMixTime *= permSpeed.Value;
                        table.SendNetworkUpdateImmediate();
                        
                        if (table.RemainingMixTime < 1f)
                        {
                            table.CancelInvoke(table.TickMix);
                            table.Invoke(table.TickMix, table.RemainingMixTime);
                        }
                        
                        return;
                    }
                }
            });
        }
        #endregion

        #region Helper Methods
        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Player Duration Multiplier (0 = instant, 1 = normal speed)")]
            public Hash<string, float> PlayerDurationMultiplier { get; set; }
        }
        #endregion
    }
}


// --- End of file: InstantMixingTable.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/inventory-backup ---
// --- Original File Path: I/InventoryBackup/InventoryBackup.cs ---

﻿using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Linq;

using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Inventory Backup", "MON@H", "1.0.6")]
    [Description("Allows to save and restore players inventories​")]

    public class InventoryBackup : RustPlugin
    {
        #region Variables

        private const string PermissionUse = "inventorybackup.use";
        private static readonly Regex _regexStripTags = new Regex("<color=.+?>|</color>|<size=.+?>|</size>|<i>|</i>|<b>|</b>", RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled);

        #endregion Variables

        #region Initialization

        private void Init()
        {
            if (!_configData.ClearOnWipe)
            {
                Unsubscribe(nameof(OnNewSave));
            }

            RegisterPermissions();
            AddCommands();
            LoadData();
        }

        private void OnNewSave(string filename) => ClearData();

        #endregion Initialization

        #region Configuration

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Storage duration (days)")]
            public double StorageDuration = -1d;

            [JsonProperty(PropertyName = "Clear inventories data on wipe")]
            public bool ClearOnWipe = false;

            [JsonProperty(PropertyName = "Logging enabled")]
            public bool LoggingEnabled = false;

            [JsonProperty(PropertyName = "Chat steamID icon")]
            public ulong SteamIDIcon = 0;

            [JsonProperty(PropertyName = "Commands list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Commands = new List<string>()
            {
                "invbackup"
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    throw new Exception();
                }
                SaveConfig();
            }
            catch (Exception exception)
            {
                PrintError($"Loading config file threw exception:\n{exception}");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration

        #region DataFile

        private StoredData _storedData;

        private class StoredData
        {
            public readonly Hash<ulong, Hash<string, PlayerInventoryData>> Inventories = new Hash<ulong, Hash<string, PlayerInventoryData>>();
        }

        public class PlayerInventoryData
        {
            public DateTime SaveDate = DateTime.Now;
            public List<ItemData> ItemsBelt;
            public List<ItemData> ItemsMain;
            public List<ItemData> ItemsWear;
        }

        public class ItemData
        {
            public bool IsBlueprint;
            public float Condition;
            public float Fuel;
            public float MaxCondition = -1;
            public int Ammo;
            public int AmmoType;
            public int Amount;
            public int BlueprintTarget;
            public int DataInt;
            public int FlameFuel;
            public int ID;
            public int Position = -1;
            public string Name;
            public string Text;
            public ulong Skin;

            public List<ItemData> Contents = new List<ItemData>();

            public Item ToItem()
            {
                if (Amount == 0)
                {
                    return null;
                }

                Item item = ItemManager.CreateByItemID(ID, Amount, Skin);

                item.position = Position;

                if (IsBlueprint)
                {
                    item.blueprintTarget = BlueprintTarget;
                    return item;
                }

                item.fuel = Fuel;
                item.condition = Condition;

                if (MaxCondition != -1)
                {
                    item.maxCondition = MaxCondition;
                }

                if (Contents != null)
                {
                    if (Contents.Count > 0)
                    {
                        if (item.contents == null)
                        {
                            item.contents = new ItemContainer();
                            item.contents.ServerInitialize(null, Contents.Count);
                            item.contents.GiveUID();
                            item.contents.parent = item;
                        }

                        foreach (var contentItem in Contents)
                        {
                            contentItem.ToItem().MoveToContainer(item.contents);
                        }
                    }
                }
                else
                {
                    item.contents = null;
                }

                BaseProjectile.Magazine magazine = item.GetHeldEntity()?.GetComponent<BaseProjectile>()?.primaryMagazine;
                FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();

                if (magazine != null)
                {
                    magazine.contents = Ammo;
                    magazine.ammoType = ItemManager.FindItemDefinition(AmmoType);
                }

                if (flameThrower != null)
                {
                    flameThrower.ammo = FlameFuel;
                }

                if (DataInt > 0)
                {
                    item.instanceData = new ProtoBuf.Item.InstanceData() {
                        ShouldPool = false,
                        dataInt = DataInt
                    };
                }

                item.text = Text;

                if (Name != null)
                {
                    item.name = Name;
                }

                return item;
            }

            public static ItemData FromItem(Item item) => new ItemData() {
                ID = item.info.itemid,
                Position = item.position,
                Ammo = item.GetHeldEntity()?.GetComponent<BaseProjectile>()?.primaryMagazine?.contents ?? 0,
                AmmoType = item.GetHeldEntity()?.GetComponent<BaseProjectile>()?.primaryMagazine?.ammoType?.itemid ?? 0,
                Amount = item.amount,
                Condition = item.condition,
                MaxCondition = item.maxCondition,
                Fuel = item.fuel,
                Skin = item.skin,
                Contents = item.contents?.itemList?.Select(FromItem).ToList(),
                FlameFuel = item.GetHeldEntity()?.GetComponent<FlameThrower>()?.ammo ?? 0,
                IsBlueprint = item.IsBlueprint(),
                BlueprintTarget = item.blueprintTarget,
                DataInt = item.instanceData?.dataInt ?? 0,
                Name = item.name,
                Text = item.text
            };
        }

        public void LoadData()
        {
            try
            {
                _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch (Exception exception)
            {
                PrintError($"Loading data file threw exception:\n{exception}");
                ClearData();
            }

            if (_configData.StorageDuration > -1)
            {
                Dictionary<ulong, string> inventoriesToRemove = new Dictionary<ulong, string>();

                foreach (KeyValuePair<ulong, Hash<string, PlayerInventoryData>> inventories in _storedData.Inventories)
                {
                    foreach (KeyValuePair<string, PlayerInventoryData> playerInventory in inventories.Value)
                    {
                        if ((DateTime.Now - playerInventory.Value.SaveDate).TotalDays > _configData.StorageDuration)
                        {
                            inventoriesToRemove.Add(inventories.Key, playerInventory.Key);
                        }
                    }
                }

                Hash<string, PlayerInventoryData> playerInventories;

                foreach (KeyValuePair<ulong, string> inventory in inventoriesToRemove)
                {
                    playerInventories = _storedData.Inventories[inventory.Key];

                    playerInventories.Remove(inventory.Value);

                    if (playerInventories.Count == 0)
                    {
                        _storedData.Inventories.Remove(inventory.Key);
                    }
                }

                SaveData();
            }
        }

        public void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);

        public void ClearData()
        {
            PrintWarning("Creating a new data file");

            _storedData = new StoredData();

            SaveData();
        }

        #endregion DataFile

        #region Localization

        public string Lang(string key, string userIDString = null, params object[] args)
        {
            try
            {
                string message = string.Format(lang.GetMessage(key, this, userIDString), args);

                return string.IsNullOrEmpty(userIDString) ? StripRustTags(message) : message;
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception:\n{ex}");
                throw;
            }
        }

        private static class LangKeys
        {
            public static class Error
            {
                private const string Base = nameof(Error) + ".";
                public const string Failed = Base + nameof(Failed);
                public const string NoPermission = Base + nameof(NoPermission);
                public const string Syntax = Base + nameof(Syntax);
            }

            public static class Info
            {
                private const string Base = nameof(Info) + ".";
                public const string Success = Base + nameof(Success);
            }

            public static class Format
            {
                private const string Base = nameof(Format) + ".";
                public const string Prefix = Base + nameof(Prefix);
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Error.Failed] = "Operation failed!",
                [LangKeys.Error.NoPermission] = "You do not have permission to use this command!",
                [LangKeys.Format.Prefix] = "<color=#00FF00>[Inventory Backup]</color>: ",
                [LangKeys.Info.Success] = "Operation completed successfully!",

                [LangKeys.Error.Syntax] = "Syntax error occured!\n"
                + "<color=#FFFF00>/{0} save <SteamID> <inventory name></color> - Save player inventory\n"
                + "<color=#FFFF00>/{0} restore <SteamID> <inventory name></color> - Restore saved player inventory\n"
                + "<color=#FFFF00>/{0} remove <SteamID> <inventory name></color> - Remove saved player inventory\n",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Error.Failed] = "Операция не удалась!",
                [LangKeys.Error.NoPermission] = "У вас нет разрешения на использование этой команды!",
                [LangKeys.Format.Prefix] = "<color=#00FF00>[Резервная копия инвентаря]</color>: ",
                [LangKeys.Info.Success] = "Операция успешно завершена!",

                [LangKeys.Error.Syntax] = "Синтаксическая ошибка!\n"
                + "<color=#FFFF00>/{0} save <SteamID> <inventory name></color> - Сохранить инвентарь игрока\n"
                + "<color=#FFFF00>/{0} restore <SteamID> <inventory name></color> - Восстановить сохранённый инвентарь игрока\n"
                + "<color=#FFFF00>/{0} remove <SteamID> <inventory name></color> - Удалить сохранённый инвентарь игрока\n",
            }, this, "ru");
        }

        #endregion Localization

        #region Commands

        [ConsoleCommand("invbackup")]
        private void ConsoleCmdInventoryBackup(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (player.IsValid() && !permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                SendReply(arg, Lang(LangKeys.Error.NoPermission, player.UserIDString));
                return;
            }

            ulong userID;
            if (!arg.HasArgs()
            || arg.Args.Length < 3
            || !ulong.TryParse(arg.Args[1], out userID)
            || !userID.IsSteamId())
            {
                SendReply(arg, Lang(LangKeys.Error.Syntax, player.UserIDString));
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "save":
                    if (InventorySave(userID, arg.Args[2]))
                    {
                        SendReply(arg, Lang(LangKeys.Info.Success, player.UserIDString));
                        return;
                    }
                    SendReply(arg, Lang(LangKeys.Error.Failed, player.UserIDString));
                    return;
                case "restore":
                    if (InventoryRestore(userID, arg.Args[2]))
                    {
                        SendReply(arg, Lang(LangKeys.Info.Success, player.UserIDString));
                        return;
                    }
                    SendReply(arg, Lang(LangKeys.Error.Failed, player.UserIDString));
                    return;
                case "remove":
                    if (InventoryRemove(userID, arg.Args[2]))
                    {
                        SendReply(arg, Lang(LangKeys.Info.Success, player.UserIDString));
                        return;
                    }
                    SendReply(arg, Lang(LangKeys.Error.Failed, player.UserIDString));
                    return;
            }

            SendReply(arg, Lang(LangKeys.Error.Syntax, player.UserIDString, _configData.Commands[0]));
        }

        private void CmdInventoryBackup(BasePlayer player, string cmd, string[] args)
        {
            if (!player.IsValid() || !player.userID.IsSteamId())
            {
                return;
            }

            if (!permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                PlayerSendMessage(player, Lang(LangKeys.Error.NoPermission, player.UserIDString));
                return;
            }

            ulong userID;
            if (args == null || args.Length < 3 || !ulong.TryParse(args[1], out userID) || !userID.IsSteamId())
            {
                PlayerSendMessage(player, Lang(LangKeys.Error.Syntax, player.UserIDString, _configData.Commands[0]));
                return;
            }

            switch (args[0].ToLower())
            {
                case "save":
                    if (InventorySave(userID, args[2]))
                    {
                        PlayerSendMessage(player, Lang(LangKeys.Info.Success, player.UserIDString));
                        return;
                    }
                    PlayerSendMessage(player, Lang(LangKeys.Error.Failed, player.UserIDString));
                    return;
                case "restore":
                    if (InventoryRestore(userID, args[2]))
                    {
                        PlayerSendMessage(player, Lang(LangKeys.Info.Success, player.UserIDString));
                        return;
                    }
                    PlayerSendMessage(player, Lang(LangKeys.Error.Failed, player.UserIDString));
                    return;
                case "remove":
                    if (InventoryRemove(userID, args[2]))
                    {
                        PlayerSendMessage(player, Lang(LangKeys.Info.Success, player.UserIDString));
                        return;
                    }
                    PlayerSendMessage(player, Lang(LangKeys.Error.Failed, player.UserIDString));
                    return;
            }

            PlayerSendMessage(player, Lang(LangKeys.Error.Syntax, player.UserIDString, _configData.Commands[0]));
        }

        #endregion Commands

        #region API

        private bool InventorySave(ulong userID, string inventoryName)
        {
            if (!userID.IsSteamId() || string.IsNullOrEmpty(inventoryName))
            {
                return false;
            }

            BasePlayer player = FindPlayer(userID);

            if (!player.IsValid() || player.inventory.AllItems().Length < 1)
            {
                return false;
            }

            Hash<string, PlayerInventoryData> playerInventories = _storedData.Inventories[userID];

            if (playerInventories == null)
            {
                playerInventories = new Hash<string, PlayerInventoryData>();
                _storedData.Inventories[userID] = playerInventories;
            }

            playerInventories[inventoryName] = new PlayerInventoryData() {
                ItemsBelt = player.inventory.containerBelt.itemList.Select(ItemData.FromItem).ToList(),
                ItemsMain = player.inventory.containerMain.itemList.Select(ItemData.FromItem).ToList(),
                ItemsWear = player.inventory.containerWear.itemList.Select(ItemData.FromItem).ToList()
            };

            SaveData();
            Log($"inventory saved {userID} {inventoryName}");
            return true;
        }

        private bool InventoryRestore(ulong userID, string inventoryName, bool remove = false)
        {
            if (!userID.IsSteamId() || string.IsNullOrEmpty(inventoryName))
            {
                return false;
            }

            BasePlayer player = FindPlayer(userID);

            if (!player.IsValid())
            {
                return false;
            }

            player.inventory.Strip();

            Hash<string, PlayerInventoryData> playerInventories = _storedData.Inventories[userID];
            PlayerInventoryData inventoryData = playerInventories[inventoryName];

            if (inventoryData == null)
            {
                Log($"inventory not found {userID} {inventoryName}");
                return false;
            }

            foreach (ItemData inventoryItem in inventoryData.ItemsBelt)
            {
                Item item = inventoryItem.ToItem();

                item?.MoveToContainer(player.inventory.containerBelt, item.position);
            }

            foreach (ItemData inventoryItem in inventoryData.ItemsMain)
            {
                Item item = inventoryItem.ToItem();

                item?.MoveToContainer(player.inventory.containerMain, item.position);
            }

            foreach (ItemData inventoryItem in inventoryData.ItemsWear)
            {
                Item item = inventoryItem.ToItem();

                item?.MoveToContainer(player.inventory.containerWear, item.position);
            }

            Log($"inventory restored {userID} {inventoryName}");

            if (remove)
            {
                playerInventories.Remove(inventoryName);
                
                if (playerInventories.Count == 0)
                {
                    _storedData.Inventories.Remove(userID);
                }

                SaveData();
                Log($"inventory removed {userID} {inventoryName}");
            }

            return true;
        }

        private bool InventoryRemove(ulong userID, string inventoryName)
        {
            if (!userID.IsSteamId() || string.IsNullOrEmpty(inventoryName))
            {
                return false;
            }

            Hash<string, PlayerInventoryData> playerInventories = _storedData.Inventories[userID];

            if (playerInventories != null)
            {
                playerInventories.Remove(inventoryName);
                
                if (playerInventories.Count == 0)
                {
                    _storedData.Inventories.Remove(userID);
                }

                SaveData();
                Log($"inventory removed {userID} {inventoryName}");
            }

            return true;
        }

        #endregion API

        #region Helpers

        public void RegisterPermissions()
        {
            permission.RegisterPermission(PermissionUse, this);
        }

        public void AddCommands()
        {
            if (_configData.Commands.Count == 0)
            {
                _configData.Commands = new List<string>() { "invbackup" };
                SaveConfig();
            }

            foreach (string command in _configData.Commands)
            {
                cmd.AddChatCommand(command, this, nameof(CmdInventoryBackup));
            }
        }

        public string StripRustTags(string text)
        {
            if (string.IsNullOrWhiteSpace(text))
            {
                return string.Empty;
            }

            return _regexStripTags.Replace(text, string.Empty);
        }

        public BasePlayer FindPlayer(ulong userID)
        {
            BasePlayer player = BasePlayer.FindByID(userID);

            if (!player.IsValid())
            {
                return FindPlayer(userID.ToString());
            }

            return player;
        }

        public BasePlayer FindPlayer(string userIDString) => BasePlayer.FindAwakeOrSleeping(userIDString);

        public void Log(string text)
        {
            if (_configData.LoggingEnabled)
            {
                LogToFile("log", $"{DateTime.Now.ToString("HH:mm:ss")} {text}", this);
            }
        }

        public void PlayerSendMessage(BasePlayer player, string message)
        {
            string prefix = Lang(LangKeys.Format.Prefix, player.UserIDString);
            player.SendConsoleCommand("chat.add", 2, _configData.SteamIDIcon, string.IsNullOrEmpty(prefix) ? message : prefix + message);
        }

        #endregion Helpers
    }
}

// --- End of file: InventoryBackup.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-renamer ---
// --- Original File Path: I/ItemRenamer/ItemRenamer.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Item Renamer", "birthdates", "1.1.1")]
    [Description("Rename items with style")]
    public class ItemRenamer : RustPlugin
    {

        public const string Permission = "itemrenamer.use";

        private void Init()
        {
            LoadConfig();
            permission.RegisterPermission(Permission, this);
            cmd.AddChatCommand("itemrename", this, ItemRenameCommand);
            if(_config.items == null) PrintError("Blacklisted items is not setup correctly, please set it up correctly or reset the config");
            if (_config.bw == null) PrintError("Blacklisted words is not setup correctly, please set it up correctly or reset the config");
            
        }

        private void ItemRenameCommand(BasePlayer player, string arg2, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, Permission) && !player.IsAdmin)
            {
                SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
            }
            else
            {
                if (args.Length < 1)
                {
                    SendReply(player, lang.GetMessage("InvalidArgs", this, player.UserIDString));
                }
                else
                {
                    if (player.GetActiveItem() == null)
                    {
                         SendReply(player, lang.GetMessage("PleaseHoldAnItemThatCanBeRenamed", this,player.UserIDString));
                    }
                    else
                    {
                        if (_config.items == null)
                        {
                            SendReply(player, lang.GetMessage("CannotDoThisRightNow", this, player.UserIDString));
                            return;
                        }
                        if (_config.bw == null)
                        {
                            SendReply(player, lang.GetMessage("CannotDoThisRightNow", this, player.UserIDString));
                            return;
                        }
                        foreach (var f in _config.items)
                        {
                            if (!player.GetActiveItem().info.shortname.Equals(f.ToLower())) continue;
                            SendReply(player, lang.GetMessage("PleaseHoldAnItemThatCanBeRenamed", this, player.UserIDString));
                            return;
                        }
                       
                        var name = args[0];
                        if (name.Length > _config.chars)
                        {
                            SendReply(player, lang.GetMessage("ItemNameTooLong", this,player.UserIDString));
                            return;
                        }
                        if (!_config.color && name.ToLower().Contains("color="))
                        {
                            SendReply(player, lang.GetMessage("YouCannotUseColor", this, player.UserIDString));
                            return;
                        }

                        foreach (var block in _config.bw)
                        {
                            if (!name.ToLower().Contains(block.ToLower())) continue;
                            SendReply(player, lang.GetMessage("BlacklistedWordsUsed", this, player.UserIDString));
                            return;
                        }
                        SendReply(player, string.Format(lang.GetMessage("ItemRenameSuccess", this, player.UserIDString), name));
                        var item = player.GetActiveItem();
                        player.inventory.containerBelt.Remove(item);
                        item.name = name;
                        player.inventory.GiveItem(item);
                    }

                }
            }
        }


        private ConfigFile _config;


        public class ConfigFile
        {
            [JsonProperty(PropertyName = "Max characters in a rename including color")]
            public int chars;

            [JsonProperty(PropertyName = "Blacklisted words")]
            public List<string> bw;

            [JsonProperty(PropertyName = "Blacklisted items")]
            public List<string> items;
            [JsonProperty(PropertyName = "Ability to use color")]
            public bool color;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                    color = true,
                    chars = 25,
                    bw = new List<string>
                    {
                        "fuck",
                        "bitch"
                    },
                    items = new List<string>
                    {
                        "rifle.ak",
                        "rifle.bolt"
                    }
                };
            }

        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoPermission", "You don't have permission to do this!"},
                {"BlacklistedWordsUsed", "You cannot use those words in your item name"},
                {"ItemNameTooLong", "Your item name is too long. (max is {0} characters)"},
                {"PleaseHoldAnItemThatCanBeRenamed", "You cannot rename the item you're holding."},
                {"InvalidArgs", "Invalid Usage! Usage: /itemrename <name>"},
                {"ItemRenameSuccess", "We have renamed your item to {0}"},
                {"YouCannotUseColor", "You may not use color!"},
                {"CannotDoThisRightNow", "You cannot perform this command as of now, please contact an administrator about this."}
            }, this);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

    }
}

// --- End of file: ItemRenamer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-skin-setter ---
// --- Original File Path: I/ItemSkinSetter/ItemSkinSetter.cs ---

/* --- Contributor information ---
 * Please follow the following set of guidelines when working on this plugin,
 * this to help others understand this file more easily.
 *
 * NOTE: On Authors, new entries go BELOW the existing entries. As with any other software header comment.
 *
 * -- Authors --
 * Thimo (ThibmoRozier) <thibmorozier@live.nl> 2021-04-24 +
 *
 * -- Naming --
 * Avoid using non-alphabetic characters, eg: _
 * Avoid using numbers in method and class names (Upgrade methods are allowed to have these, for readability)
 * Private constants -------------------- SHOULD start with a uppercase "C" (PascalCase)
 * Private readonly fields -------------- SHOULD start with a uppercase "C" (PascalCase)
 * Private fields ----------------------- SHOULD start with a uppercase "F" (PascalCase)
 * Arguments/Parameters ----------------- SHOULD start with a lowercase "a" (camelCase)
 * Classes ------------------------------ SHOULD start with a uppercase character (PascalCase)
 * Methods ------------------------------ SHOULD start with a uppercase character (PascalCase)
 * Public properties (constants/fields) - SHOULD start with a uppercase character (PascalCase)
 * Variables ---------------------------- SHOULD start with a lowercase character (camelCase)
 *
 * -- Style --
 * Max-line-width ------- 160
 * Single-line comments - // Single-line comment
 * Multi-line comments -- Just like this comment block!
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Item Skin Setter", "ThibmoRozier", "1.1.6")]
    [Description("Sets the default skin ID for newly crafted items.")]
    public class ItemSkinSetter : RustPlugin
    {
        #region Types
        private struct ShortnameToWorkshopId
        {
            [JsonProperty("Item Shortname")]
            public string ItemShortname;
            [JsonProperty("Skin Id")]
            public ulong SkinId;
        }

        /// <summary>
        /// The config type class
        /// </summary>
        private class ConfigData
        {
            [JsonProperty("Bindings")]
            public List<ShortnameToWorkshopId> Bindings = new List<ShortnameToWorkshopId>();
        }
        #endregion Types

        #region Variables
        private ConfigData FConfigData;
        private Dictionary<int, ulong> FItemSkinBindings;
        #endregion Variables

        #region Script Methods
        private string _(string aKey, string aPlayerId = null) => lang.GetMessage(aKey, this, aPlayerId);

        /// <summary>
        /// Determine whether or not a given string is a number
        /// </summary>
        /// <param name="aStr"></param>
        /// <returns></returns>
        private bool IsNumber(string aStr)
        {
            if (String.IsNullOrEmpty(aStr))
                return false;

            char cur;

            for (int i = 0; i < aStr.Length; i++)
            {
                cur = aStr[i];

                if (cur.Equals('-') || cur.Equals('+'))
                    continue;

                if (Char.IsDigit(cur) == false)
                    return false;
            }

            return true;
        }

        private void PerformStartupConfigCheck()
        {
            // We need the SteamPlatform ItemDefinitions to be there, if it's not we get a null-ref exception
            if ((!PlatformService.Instance.IsValid) || PlatformService.Instance.ItemDefinitions == null)
            {
                // Retry in one second
                timer.Once(1f, PerformStartupConfigCheck);
                return;
            }

            ShortnameToWorkshopId confItem;
            ItemDefinition itemDef;
            StringBuilder sb = new StringBuilder("Config parsing errors:\n");
            int errCount = 0;

            for (int i = 0; i < FConfigData.Bindings.Count; i++)
            {
                confItem = FConfigData.Bindings[i];

                if (confItem.SkinId == 0)
                    continue;

                itemDef = ItemManager.FindItemDefinition(confItem.ItemShortname);

                if (itemDef == null)
                {
                    sb.Append("  - " + String.Format(_("Err Item Does Not Exist"), confItem.ItemShortname) + "\n");
                    errCount++;
                    continue;
                }

                if (!itemDef.HasSkins)
                {
                    sb.Append("  - " + String.Format(_("Err Skin Does Not Exist"), confItem.ItemShortname) + "\n");
                    errCount++;
                    continue;
                }

                FItemSkinBindings[itemDef.itemid] = confItem.SkinId;
                Puts($"Item {itemDef.shortname} skin set to {FItemSkinBindings[itemDef.itemid]}");
            }

            if (errCount > 0)
                Puts(sb.Append($"\nTotal error count: {errCount}\n").ToString());
        }
        #endregion Script Methods

        #region Hooks
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string> {
                    { "Err Invalid Args", "Invalid argument (count), please try again." },
                    { "Err Invalid Permission", "You do not have permission to use this command." },
                    { "Err Item Does Not Exist", "Item \"{0}\" does not exist." },
                    { "Err Skin Does Not Exist", "Skin with ID \"{0}\" does not exist." },

                    { "Msg Item Skin Default", "The skin of item \"{0}\" ({1}) is default." },
                    { "Msg Item Skin", "The skin of item \"{0}\" ({1}) is \"{2}\" ( Name = \"{3}\" )." }
                }, this, "en"
            );
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            FConfigData = Config.ReadObject<ConfigData>();

            if (FConfigData == null)
                LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            FConfigData = new ConfigData();
            List<ItemDefinition> itemlist = ItemManager.GetItemDefinitions();
            ItemDefinition curItem;

            for (int i = 0; i < itemlist.Count; i++)
            {
                curItem = itemlist[i];

                if (curItem.HasSkins)
                    FConfigData.Bindings.Add(new ShortnameToWorkshopId { ItemShortname = curItem.shortname, SkinId = 0 });
            }

            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(FConfigData);

        void OnServerInitialized()
        {
            FItemSkinBindings = new Dictionary<int, ulong>();
            PerformStartupConfigCheck();
        }

        void OnItemCraftFinished(ItemCraftTask aTask, Item aItem)
        {
            if (aTask?.skinID == 0 && FItemSkinBindings.ContainsKey(aTask.blueprint.targetItem.itemid))
            {
                aItem.skin = FItemSkinBindings[aTask.blueprint.targetItem.itemid];
                aItem.MarkDirty();
            }
        }
        #endregion Hooks

        #region Commands
        [ConsoleCommand("iss_get")]
        private void ItemSkinSetterGetCmd(ConsoleSystem.Arg aArg)
        {
            if (aArg.IsClientside)
            {
                aArg.ReplyWith(_("Err Invalid Permission", aArg.Connection.userid.ToString()));
                return;
            }

            if (aArg.Args.Length < 1)
            {
                Puts(_("Err Invalid Args"));
                return;
            }

            string itemArg = aArg.Args[0];
            ItemDefinition itemDef = null;

            if (!IsNumber(itemArg))
            {
                itemDef = ItemManager.FindItemDefinition(itemArg);
            }
            else
            {
                int itemId;

                if (int.TryParse(itemArg, out itemId))
                    itemDef = ItemManager.FindItemDefinition(itemId);
            }

            if (itemDef == null)
                Puts(_("Err Item Does Not Exist"), itemArg);

            if (FItemSkinBindings.ContainsKey(itemDef.itemid))
            {
                ulong skinId = FItemSkinBindings[itemDef.itemid];
                IPlayerItemDefinition skinDef = itemDef.skins2.First(x => x.WorkshopId == skinId);
                Puts(_("Msg Item Skin"), itemDef.shortname, itemDef.itemid, skinDef.WorkshopId, skinDef.Name);
            }
            else
            {
                Puts(_("Msg Item Skin Default"), itemDef.shortname, itemDef.itemid);
            }
        }

        [ConsoleCommand("iss_getskins")]
        private void ItemSkinSetterGetSkinsCmd(ConsoleSystem.Arg aArg)
        {
            if (aArg.IsClientside)
            {
                aArg.ReplyWith(_("Err Invalid Permission", aArg.Connection.userid.ToString()));
                return;
            }

            if (aArg.Args.Length < 1)
            {
                Puts(_("Err Invalid Args"));
                return;
            }

            string itemArg = aArg.Args[0];
            ItemDefinition itemDef = null;

            if (!IsNumber(itemArg))
            {
                itemDef = ItemManager.FindItemDefinition(itemArg);
            }
            else
            {
                int itemId;

                if (int.TryParse(itemArg, out itemId))
                    itemDef = ItemManager.FindItemDefinition(itemId);
            }

            if (itemDef == null)
                Puts(_("Err Item Does Not Exist"), itemArg);

            IPlayerItemDefinition[] skinDefs = itemDef.skins2;
            StringBuilder sb = new StringBuilder($"Skins for item \"{itemDef.shortname}\" ({itemDef.itemid})\n");

            for (int i = 0; i < skinDefs.Length; i++)
                sb.Append($"  - {skinDefs[i].Name} ({skinDefs[i].WorkshopId})\n");

            Puts(sb.ToString());
        }
        #endregion Commands
    }
}


// --- End of file: ItemSkinSetter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-printer ---
// --- Original File Path: I/ItemPrinter/ItemPrinter.cs ---

// © 2019 Ts3Hosting All Rights Reserved
using System;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Core;

using System.Globalization;

namespace Oxide.Plugins
{
    [Info("Item Printer", "Ts3Hosting", "1.1.19")]
    [Description("Craft set items in a large wooden box with power hookups and box decay")]
    public class ItemPrinter : RustPlugin
    {
        itemEntity npcData;
        playerEntity playerData;
        IEntity iData;

        boxEntity pcdData;
        private DynamicConfigFile PCDDATA;
        private DynamicConfigFile NPCDATA;
        private DynamicConfigFile PLAYERDATA;
        private DynamicConfigFile I;
        private const string adminAllow = "itemprinter.admin";
        private const string printerAllow = "itemprinter.printer";
        private const string useAllow = "itemprinter.use";
        public ulong CardskinID;
        private int damage;
        private int itemamounts;
        private bool Changed;
        public int itemID;
        public ulong skinID;
        public string itemname;
        public string printername;
        public bool craftmode;
        public int seconds;

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["nope"] = "You do not have perms to use this command.",
                ["copy"] = "All items, item skins, and stack size in your inventory main now required to run printer..",
                ["copymode2"] = "All items, item skins, and stack size in your inventory main now required to run printer and print {0}.",
                ["missingitems"] = "You are missing items to print.",
                ["nogroup"] = "There is no items set for this group so you can not print.",
                ["help"] = "/printer printer =  Give your self a printer.",
                ["help1"] = "/printer items <group> = Copy all items in your inventory main to items needed by the printers to print.",
                ["mode2help1"] = "/printer items <ShortName/ItemID> <ammountTogive> = Copy all items in your inventory main to items needed by the printers to print.",
                ["noitem"] = "Sorry you can not print this item in slot 1 of the box",
                ["help3"] = "/printer setgroup <steamid> <group>",
                ["nobp"] = "You do not have the bp to print this item",
                ["noitemdef"] = "Could not find that item def",
                ["groupupdate"] = "Player group updated",
				["WrongCommand"] = "Wrong command usage",
				["noplayer"] = "player not found",
            }, this);
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file!");
            LoadVariables();
        }

        void LoadVariables()
        {
            craftmode = Convert.ToBoolean(GetConfig("Printer Mode", "Mode two", false));
            CardskinID = Convert.ToUInt64(GetConfig("Box", "The Box SkinID", 1722250254));
            seconds = Convert.ToInt32(GetConfig("Box", "tprinter tick no less then 1", 4));
            printername = Convert.ToString(GetConfig("Box", "Printer Name", "Printer"));
            damage = Convert.ToInt32(GetConfig("Box", "Damage Amount Per Tick", 1));

            itemID = Convert.ToInt32(GetConfig("ItemsAsCash", "itemID", -1779183908));
            skinID = Convert.ToUInt64(GetConfig("ItemsAsCash", "skinID", 916068443));
            itemname = Convert.ToString(GetConfig("ItemsAsCash", "ItemName", "Money"));
            itemamounts = Convert.ToInt32(GetConfig("ItemsAsCash", "Item Amount to create Per Tick", 1));

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        void Init()
        {
            PCDDATA = Interface.Oxide.DataFileSystem.GetFile(Name + "/printer");
            NPCDATA = Interface.Oxide.DataFileSystem.GetFile(Name + "/item");
            PLAYERDATA = Interface.Oxide.DataFileSystem.GetFile(Name + "/player");
            I = Interface.Oxide.DataFileSystem.GetFile(Name + "/Data");

            RegisterPermissions();
            LoadData();
            LoadVariables();
        }

        private void OnServerInitialized()
        {
            checkbox();
        }

        private void RegisterPermissions()
        {
            permission.RegisterPermission(adminAllow, this);
            permission.RegisterPermission(printerAllow, this);
            permission.RegisterPermission(useAllow, this);
        }

        void LoadData()
        {
            try
            {
                pcdData = Interface.Oxide.DataFileSystem.ReadObject<boxEntity>(Name + "/printer");
            }
            catch
            {
                PrintWarning("Couldn't load entity data, creating new entity");
                pcdData = new boxEntity();
            }
            try
            {
                npcData = Interface.Oxide.DataFileSystem.ReadObject<itemEntity>(Name + "/item");
            }
            catch
            {
                PrintWarning("Couldn't load Item data, creating new item file");
                npcData = new itemEntity();
            }
            try
            {
                playerData = Interface.Oxide.DataFileSystem.ReadObject<playerEntity>(Name + "/player");
            }
            catch
            {
                PrintWarning("Couldn't load player data, creating new player file");
                playerData = new playerEntity();
            }
            try
            {
                iData = Interface.Oxide.DataFileSystem.ReadObject<IEntity>(Name + "/Data");
            }
            catch
            {
                PrintWarning("Couldn't load craftmode data, creating new craftmode file");
                iData = new IEntity();
            }
        }

        void checkbox()
        {
            PrintWarning("Checking and removing unused printers in datafile.");
            foreach (var printer in pcdData.pEntity.Values.ToList())
            {
                if (pcdData.pEntity.ContainsKey(printer.batt))
                {
                    var find = BaseNetworkable.serverEntities.Find(printer.batt);
                    if (find == null)
                    {
                        pcdData.pEntity.Remove(printer.batt);
                    }
                    else if (find != null)
                    {
                        SpawnRefresh(find);
                        var printer1 = BaseNetworkable.serverEntities.Find(printer.printer);
                        if (printer1 != null) SpawnRefresh(printer1);
                        var counter = BaseNetworkable.serverEntities.Find(printer.counter);
                        if (counter != null) SpawnRefresh(counter);
                        var light = BaseNetworkable.serverEntities.Find(printer.light);
                        if (light != null) SpawnRefresh(light);
                    }
                }
            }
            SaveData();
        }

        public class vipData1
        {
            public int item;
            public ulong skinid;
            public int amount;
            public string name;
            public string displayName;
            public string Permission;
            public string totalGive;
        }

        public class vipData
        {
            public int item;
            public ulong skinid;
            public int amount;
            public string name;
            public string displayName;
            public string Permission;
            public string totalGive;
        }
        class itemEntity
        {
            public Dictionary<string, NPCInfo> iEntity = new Dictionary<string, NPCInfo>();

            public itemEntity() { }
        }
        class NPCInfo
        {
            public int item;
            public ulong skinid;
            public int amount;
            public string name;
            public string displayName;
            public string Permission;
        }

        void SaveitemData()
        {
            NPCDATA.WriteObject(npcData);
        }

        class boxEntity
        {
            public Dictionary<ulong, PCDInfo> pEntity = new Dictionary<ulong, PCDInfo>();
            public boxEntity() { }
        }

        class PCDInfo
        {
            public uint batt;
            public uint printer;
            public uint light;
            public uint counter;
        }

        void SaveData()
        {
            PCDDATA.WriteObject(pcdData);
        }

        class playerEntity
        {
            public Dictionary<ulong, PInfo> playerpEntity = new Dictionary<ulong, PInfo>();
            public playerEntity() { }
        }

        class PInfo
        {
            public string displayName;
            public string Permission;
        }
        void SavePlayerData()
        {
            PLAYERDATA.WriteObject(playerData);
        }

        class IEntity
        {
            public Dictionary<string, IInfo> iEntity = new Dictionary<string, IInfo>();
        }

        class IInfo
        {
            public int totalGive;
            public Dictionary<string, vipData> items = new Dictionary<string, vipData>();
        }
        void SaveIData()
        {
            I.WriteObject(iData);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (!playerData.playerpEntity.ContainsKey(player.userID))
            {
                playerData.playerpEntity.Add(player.userID, new PInfo());
                playerData.playerpEntity[player.userID].displayName = player.displayName;
                playerData.playerpEntity[player.userID].Permission = "null";
                SavePlayerData();
            }
        }

        [ConsoleCommand("printer")]
        private void CmdConsolePage(ConsoleSystem.Arg args)
        {
            if (args == null || args.Args.Length == 0) return;

            BasePlayer player = args.Player();
            if (player != null) return;
            if (args.Args.Length == 3 && args.Args[0].ToLower() == "setgroup") updategroup(null, args.Args[1].ToLower(), args.Args[2].ToLower(), args);

            if (args.Args.Length == 2 && args.Args[0].ToLower() == "printer")
            {
                var ids = default(ulong);
                if (!ulong.TryParse(args.Args[1], out ids))
                {
					SendReply(args, string.Format(lang.GetMessage("WrongCommand", this, player.UserIDString)));
                    return;
                }
                var playernull = BasePlayer.FindByID(ids);
                if (playernull == null)
                {
					SendReply(args, string.Format(lang.GetMessage("noplayer", this, player.UserIDString)));
                    return;
                }
                var card = ItemManager.CreateByItemID(833533164, 1, CardskinID);
                if (card == null) return;
                card.name = printername;
                playernull.GiveItem(card);
            }
        }

        private void updategroup(BasePlayer player, string id, string perm, ConsoleSystem.Arg args)
        {
            if (player.net?.connection != null && !permission.UserHasPermission(player.UserIDString, adminAllow))
            {
                SendReply(player, string.Format(lang.GetMessage("nope", this, player.UserIDString)));
                return;
            }

            if (id == null || perm == null)
            {
                if (player.net?.connection != null) SendReply(player, string.Format(lang.GetMessage("help3", this, player.UserIDString)));
                else SendReply(args, string.Format(lang.GetMessage("WrongCommand", this, player.UserIDString)));
                return;
            }

            var ids = default(uint);
            if (!uint.TryParse(id, out ids))
            {
                return;
            }

            if (playerData.playerpEntity.ContainsKey(ids))
            {
                playerData.playerpEntity[ids].Permission = perm;
                SavePlayerData();
                if (player.net?.connection != null) SendReply(player, string.Format(lang.GetMessage("groupupdate", this, player.UserIDString)));
                else SendReply(args, string.Format(lang.GetMessage("groupupdate", this, player.UserIDString)));
            }
        }

        object CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
        {
            StorageContainer thebox = entity?.GetComponentInParent<StorageContainer>();
            if (thebox != null && entity.net.ID != thebox.net.ID)
            {
                if (thebox.skinID == CardskinID)
                    return false;
            }
            if (entity.name == printername)
            {
                var health = entity.health;
                var maxh = entity.MaxHealth();
                var ids = entity.net.ID.ToString();

                foreach (var printer in pcdData.pEntity.Values.ToList())
                {
                    if (printer.printer.ToString() == ids)
                    {
                        entity.Kill();
                        var card = ItemManager.CreateByItemID(833533164, 1, CardskinID);
                        if (card == null) return null;
                        card.name = printername;
                        var total = maxh - health;
                        card.condition = card.condition - total - 5;
                        player.GiveItem(card);
                        Effect.server.Run("assets/prefabs/deployable/recycler/effects/start.prefab", player.transform.position);
                        pcdData.pEntity.Remove(printer.batt);
                        SaveData();
                        break;
                    }
                }
                return false;
            }
            return null;
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (item.skin == skinID)
            {
                if (item.name != itemname)
                {
                    item.name = itemname;
                }
            }
        }

        object OnSwitchToggle(ElectricSwitch sw, BasePlayer player)
        {
            bool onOff = sw.IsOn();

            var oSlotArray = sw.outputs;
            if (oSlotArray == null || oSlotArray.Length <= 0) return null;
            IOEntity.IOSlot oSlot3 = oSlotArray[0];
            if (oSlot3 == null) return null;
            var oEntity = oSlot3.connectedTo.Get(true);
            if (oEntity == null) return null;
            if (!pcdData.pEntity.ContainsKey(oEntity.net.ID))
            {
                return null;
            }
            if (!onOff && sw.IsPowered())
            {
                var box = pcdData.pEntity[oEntity.net.ID].printer;
                var boxlight = pcdData.pEntity[oEntity.net.ID].light;
                var counterID = pcdData.pEntity[oEntity.net.ID].counter;
                DoPrinterThings(player, sw, box, boxlight, counterID);
                FlasherLight lights = BaseNetworkable.serverEntities.Find(boxlight) as FlasherLight;
                if (lights != null)
                {
                    lights.SetFlag(BaseEntity.Flags.Reserved8, true, false, true);
                    lights.SetFlag(BaseEntity.Flags.On, true);
                }
            }
            if (onOff)
            {
                var boxx = pcdData.pEntity[oEntity.net.ID].printer;
                if (timers.ContainsKey(boxx)) timers[boxx].Destroy();
                StorageContainer box6 = BaseNetworkable.serverEntities.Find(boxx) as StorageContainer;
                if (box6 == null) return null;
                box6.inventory.SetLocked(false);
                var boxlight = pcdData.pEntity[oEntity.net.ID].light;
                FlasherLight lights = BaseNetworkable.serverEntities.Find(boxlight) as FlasherLight;
                if (lights != null)
                {
                    lights.SetFlag(BaseEntity.Flags.Reserved8, false, false, false);
                    lights.SetFlag(BaseEntity.Flags.On, false);
                }
            }
            return null;
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity != null && pcdData.pEntity.ContainsKey(entity.net.ID))
            {
                pcdData.pEntity.Remove(entity.net.ID);
                SaveData();
            }
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            var item1 = go?.ToBaseEntity() as BoxStorage ?? null;
            if (item1 != null && item1 is BoxStorage)
            {
                if (item1.skinID == CardskinID)
                {
                    item1.name = printername;
                    additem(null, item1);
                    item1.SendNetworkUpdateImmediate();
                }
            }
        }

        void SpawnRefresh(BaseNetworkable entity1)
        {
            UnityEngine.Object.Destroy(entity1.GetComponent<Collider>());
        }

        private void additem(BasePlayer player, BoxStorage box1)
        {
            SpawnRefresh(box1);
            ElectricBattery batt;

            batt = GameManager.server.CreateEntity("assets/prefabs/deployable/playerioents/batteries/smallrechargablebattery.deployed.prefab") as ElectricBattery;
            if (batt == null) return;
            batt.SetParent(box1, box1.GetSlotAnchorName(BaseEntity.Slot.Lock));
            batt.transform.localPosition = new Vector3(0.28f, -0.05f, 0f);
            batt.transform.localRotation = Quaternion.Euler(Vector3.zero);
            batt.Spawn();
            SpawnRefresh(batt);
            batt.SendNetworkUpdateImmediate();

            FlasherLight light;

            light = GameManager.server.CreateEntity("assets/prefabs/deployable/playerioents/lights/flasherlight/electric.flasherlight.deployed.prefab") as FlasherLight;
            if (light == null) return;
            light.SetParent(box1, box1.GetSlotAnchorName(BaseEntity.Slot.Lock));
            light.transform.localPosition = new Vector3(0.28f, 0f, 0f);
            light.transform.localRotation = Quaternion.Euler(Vector3.zero);
            light.Spawn();
            SpawnRefresh(light);
            light.SendNetworkUpdateImmediate();

            PowerCounter counter;

            counter = GameManager.server.CreateEntity("assets/prefabs/deployable/playerioents/counter/counter.prefab") as PowerCounter;
            if (counter == null) return;
            counter.SetParent(box1, box1.GetSlotAnchorName(BaseEntity.Slot.Lock));
            counter.transform.localPosition = new Vector3(0.038f, -0.10f, -0.50f);
            counter.transform.localRotation = Quaternion.Euler(new Vector3(0, 270, 0));
            counter.Spawn();
            SpawnRefresh(counter);
            IOEntity.IOSlot ioOutput = batt.outputs[0];
            if (ioOutput != null)
            {
                ioOutput.connectedTo = new IOEntity.IORef();
                ioOutput.connectedTo.Set(counter);
                ioOutput.connectedToSlot = 0;
                ioOutput.connectedTo.Init();

                counter.inputs[0].connectedTo = new IOEntity.IORef();
                counter.inputs[0].connectedTo.Set(batt);
                counter.inputs[0].connectedToSlot = 0;
                counter.inputs[0].connectedTo.Init();
            }

            if (!pcdData.pEntity.ContainsKey(batt.net.ID))
            {
                pcdData.pEntity.Add(batt.net.ID, new PCDInfo());
                //SaveData();
            }
            pcdData.pEntity[batt.net.ID].printer = box1.net.ID;
            pcdData.pEntity[batt.net.ID].batt = batt.net.ID;
            pcdData.pEntity[batt.net.ID].light = light.net.ID;
            pcdData.pEntity[batt.net.ID].counter = counter.net.ID;
            SaveData();
        }

        [ChatCommand("printer")]
        void GetPrinter(BasePlayer player, string command, string[] args)
        {
            if (args.Length <= 0)
            {
                if (permission.UserHasPermission(player.UserIDString, printerAllow) && permission.UserHasPermission(player.UserIDString, adminAllow))
                {
                    SendReply(player, string.Format(lang.GetMessage("help", this, player.UserIDString)));
                }
                if (permission.UserHasPermission(player.UserIDString, adminAllow))
                {
                    if (!craftmode) SendReply(player, string.Format(lang.GetMessage("help1", this, player.UserIDString)));
                    if (craftmode) SendReply(player, string.Format(lang.GetMessage("mode2help1", this, player.UserIDString)));
                    SendReply(player, string.Format(lang.GetMessage("help3", this, player.UserIDString)));
                }
                return;
            }

            switch (args[0].ToLower())
            {
                case "printer":
                    GetPrint(player);
                    return;

                case "items":
                    if (args.Length == 1)
                        GetPrinte1r(player, "null", "1");
                    else if (args.Length == 3)
                        GetPrinte1r(player, args[1].ToLower(), args[2].ToLower());
                    return;

                case "setgroup":
                    if (args.Length == 3)
                        updategroup(player, args[1].ToLower(), args[2].ToLower(), null);
                    return;

                default:
                    break;
            }

            if (permission.UserHasPermission(player.UserIDString, printerAllow) || permission.UserHasPermission(player.UserIDString, adminAllow))
            {
                SendReply(player, string.Format(lang.GetMessage("help", this, player.UserIDString)));
            }
            if (permission.UserHasPermission(player.UserIDString, adminAllow))
            {
                if (!craftmode)
                {
                    SendReply(player, string.Format(lang.GetMessage("help1", this, player.UserIDString)));
                    SendReply(player, string.Format(lang.GetMessage("help3", this, player.UserIDString)));
                }
                if (craftmode) SendReply(player, string.Format(lang.GetMessage("mode2help1", this, player.UserIDString)));
            }
            return;
        }

        void GetPrint(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, adminAllow) || permission.UserHasPermission(player.UserIDString, printerAllow))
            {
                var card = ItemManager.CreateByItemID(833533164, 1, CardskinID);
                if (card == null) return;
                card.name = printername;
                player.GiveItem(card);
                return;
            }
            SendReply(player, string.Format(lang.GetMessage("nope", this, player.UserIDString)));
            return;
        }

        void GetPrinte1r(BasePlayer player, string perm, string amount)
        {
            if (!permission.UserHasPermission(player.UserIDString, adminAllow))
            {
                SendReply(player, string.Format(lang.GetMessage("nope", this, player.UserIDString)));
                return;
            }

            if (!craftmode)
            {
                GetPlayerItems(player, perm);
                SendReply(player, string.Format(lang.GetMessage("copy", this, player.UserIDString)));
                return;
            }
            var pM = default(int);
            if (!int.TryParse((perm), out pM))
            {
                SendReply(player, string.Format(lang.GetMessage("noitemdef", this, player.UserIDString)));
                return;
            }
            ItemDefinition itemdef = ItemManager.FindItemDefinition(pM);
            if (itemdef != null)
            {
                string permID = itemdef.itemid.ToString();
                GetPlayerItemsvip(player, permID, amount);
                SendReply(player, string.Format(lang.GetMessage("copymode2", this, player.UserIDString), itemdef.displayName.english));
            }
            else
            {
                SendReply(player, "Could not find item: " + perm, player);
                return;
            }
        }

        private void GetPlayerItems(BasePlayer player, string perm)
        {
            foreach (var i in npcData.iEntity.Values.ToList())
            {
                if (i.Permission == perm)
                {
                    string itemids = i.item.ToString() + perm;
                    npcData.iEntity.Remove(itemids);
                    SaveitemData();
                }
            }

            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    ProcessItem(item, "main", perm);
                }
            }
        }

        private void ProcessItem(Item item, string container, string perm)
        {
            string itemids = item.info.itemid.ToString() + perm;
            if (!npcData.iEntity.ContainsKey(itemids))
            {
                npcData.iEntity.Add(itemids, new NPCInfo());
                //SaveData();
            }

            npcData.iEntity[itemids].amount = item.amount;
            npcData.iEntity[itemids].skinid = item.skin;
            npcData.iEntity[itemids].item = item.info.itemid;
            npcData.iEntity[itemids].displayName = item.info.displayName.english.ToString();
            npcData.iEntity[itemids].name = item.name;
            npcData.iEntity[itemids].Permission = perm;
            SaveitemData();
        }

        private void GetPlayerItemsvip(BasePlayer player, string perm, string amount)
        {
            if (iData.iEntity.ContainsKey(perm))
            {
                iData.iEntity.Remove(perm);
            }

            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    ProcessItemvip(item, "main", perm, amount);
                }
            }
        }

        private void ProcessItemvip(Item item, string container, string perm, string amount)
        {
            string itemids = perm;
            if (!iData.iEntity.ContainsKey(itemids))
            {
                iData.iEntity.Add(itemids, new IInfo());
                //SaveData();
            }
            var amount1 = default(int);

            if (!int.TryParse(amount, out amount1))
            {
                return;
            }
            iData.iEntity[itemids].totalGive = amount1;
            iData.iEntity[itemids].items.Add(item.info.itemid.ToString(), new vipData());
            iData.iEntity[itemids].items[item.info.itemid.ToString()].amount = item.amount;
            iData.iEntity[itemids].items[item.info.itemid.ToString()].skinid = item.skin;
            iData.iEntity[itemids].items[item.info.itemid.ToString()].item = item.info.itemid;
            iData.iEntity[itemids].items[item.info.itemid.ToString()].displayName = item.info.displayName.english.ToString();
            iData.iEntity[itemids].items[item.info.itemid.ToString()].name = item.name;
            iData.iEntity[itemids].items[item.info.itemid.ToString()].Permission = perm;
            iData.iEntity[itemids].items[item.info.itemid.ToString()].totalGive = amount;

            SaveIData();
        }

        public bool giveitem(StorageContainer box, int number1, string item)
        {
            Item itemc = null;
            if (!craftmode)
            {
                itemc = ItemManager.CreateByItemID(itemID, number1, skinID);
                if (itemc == null) return false;
                itemc.name = itemname;
            }

            if (craftmode)
            {
                var ids = default(int);
                if (int.TryParse(item, out ids))
                {
                    itemc = ItemManager.CreateByItemID(ids, number1);
                }
            }

            if (itemc == null) return false;
            if (itemc.MoveToContainer(box.inventory, -1, true))
            {
                return true;
            }
            Vector3 velocity = Vector3.zero;
            itemc.Drop(box.transform.position + new Vector3(0.5f, 1f, 0), velocity);
            return false;
        }

        public bool hasbp(BasePlayer player, string itemboxid)
        {
			if (itemID == 1540934679 || itemID == -946369541) return true;
			var persistantPlayer = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
            if (persistantPlayer != null)
            {
				
                foreach (var itemId in persistantPlayer.unlockedItems)
                {
                    if (itemboxid == itemId.ToString())
                        return true;
                }
            }
            return false;
        }

        private void stopbox(BasePlayer player, ElectricSwitch sw, StorageContainer box, FlasherLight light, uint box1)
        {
            NextTick(() =>
              {
                  if (sw != null)
                  {
                      sw.SetFlag(BaseEntity.Flags.On, false);
                      sw.SendNetworkUpdate();
                  }

                  if (timers.ContainsKey(box1)) timers[box1].Destroy();
                  if (box != null) box.inventory.SetLocked(false);
                  if (light != null)
                  {
                      light.SetFlag(BaseEntity.Flags.Reserved8, false, false, false);
                      light.SetFlag(BaseEntity.Flags.On, false);
                  }
              });
        }

        readonly Dictionary<ulong, Timer> timers = new Dictionary<ulong, Timer>();

        void DoPrinterThings(BasePlayer player, ElectricSwitch sw, uint box1, uint light, uint counterID)
        {
            var totalGive = 1;
            StorageContainer box = BaseNetworkable.serverEntities.Find(box1) as StorageContainer;
            PowerCounter counter = BaseNetworkable.serverEntities.Find(counterID) as PowerCounter;
            FlasherLight lights = BaseNetworkable.serverEntities.Find(light) as FlasherLight;

            if (!playerData.playerpEntity.ContainsKey(player.userID))
            {
                playerData.playerpEntity.Add(player.userID, new PInfo());
                playerData.playerpEntity[player.userID].displayName = player.displayName;
                playerData.playerpEntity[player.userID].Permission = "null";
                SavePlayerData();
            }
            if (counter != null)
            {
                counter.SetFlag(BaseEntity.Flags.On, true);
                counter.UpdateFromInput(400, 3);
                counter.SendNetworkUpdateImmediate();
            }

            if (box == null)
            {
                return;
            }
            List<vipData1> saveditems = new List<vipData1>();
            int t = 0;
            string itemboxid = "";
            if (craftmode)
            {
                Item itemtype = box.inventory.GetSlot(0);
                if (itemtype == null)
                {
                    if (player.net?.connection != null) SendReply(player, string.Format(lang.GetMessage("noitem", this, player.UserIDString)));
                    stopbox(player, sw, box, lights, box1);
                    return;
                }

                itemboxid = itemtype.info.itemid.ToString();

                if (!iData.iEntity.ContainsKey(itemboxid))
                {
                    if (player.net?.connection != null && craftmode) SendReply(player, string.Format(lang.GetMessage("noitem", this, player.UserIDString)));
                    stopbox(player, sw, box, lights, box1);
                    return;
                }

                bool checkbp = hasbp(player, itemboxid);
                if (!checkbp && itemboxid != "-265876753")
                {
                    if (player.net?.connection != null) SendReply(player, string.Format(lang.GetMessage("nobp", this, player.UserIDString)));
                    stopbox(player, sw, box, lights, box1);
                }

                totalGive = iData.iEntity[itemboxid].totalGive;
                foreach (var k in iData.iEntity[itemboxid].items.Values.ToList())
                {
                    saveditems.Add(new vipData1
                    {
                        item = k.item,
                        skinid = k.skinid,
                        amount = k.amount,
                        name = k.name,
                        totalGive = k.totalGive,
                        displayName = k.displayName,
                        Permission = k.Permission
                    });
                    t++;
                }
            }

            if (!craftmode)
            {
                if (playerData.playerpEntity.ContainsKey(player.userID))
                {
                    var p = playerData.playerpEntity[player.userID].Permission;
                    foreach (var h in npcData.iEntity.Values.ToList())
                    {
                        if (h.Permission == p)
                        {
                            saveditems.Add(new vipData1
                            {
                                item = h.item,
                                skinid = h.skinid,
                                amount = h.amount,
                                name = h.name,
                                displayName = h.displayName,
                                Permission = h.Permission
                            });
                            t++;
                        }
                    }
                }

                if (t <= 0)
                {
                    stopbox(player, sw, box, lights, box1);
                    return;
                }
            }

            if (timers.ContainsKey(box1))
                timers[box1].Destroy();
            box.inventory.SetLocked(true);
            Effect.server.Run("assets/prefabs/npc/autoturret/effects/online.prefab", box.transform.position);
            timers[box1] = timer.Every(seconds, () =>
            {
                foreach (var i in saveditems)
                {
                    int totals = 0;
                    if (box == null)
                    {
                        return;
                    }

                    var items = box.inventory.FindItemByItemID(i.item);
                    if (items == null || items.skin != i.skinid || box == null)
                    {
                        if (counter != null) counter.SetFlag(BaseEntity.Flags.Reserved8, false, false, false);
                        if (player.net?.connection != null) SendReply(player, string.Format(lang.GetMessage("missingitems", this, player.UserIDString)));
                        Effect.server.Run("assets/prefabs/npc/autoturret/effects/offline.prefab", box.transform.position);
                        stopbox(player, sw, box, lights, box1);
                        return;
                    }

                    totals = box.inventory.GetAmount(i.item, true);
                    if (totals <= 0 || totals < i.amount || !sw.IsPowered() || !sw.IsOn())
                    {
                        Effect.server.Run("assets/prefabs/npc/autoturret/effects/offline.prefab", box.transform.position);
                        stopbox(player, sw, box, lights, box1);
                        if (player.net?.connection != null) SendReply(player, string.Format(lang.GetMessage("missingitems", this, player.UserIDString)));
                        return;
                    }
                }

                foreach (var j in saveditems)
                {
                    box.inventory.Take(null, j.item, j.amount);
                }
                bool giveitems = false;

                if (!craftmode) giveitems = giveitem(box, itemamounts, itemID.ToString());
                if (craftmode) giveitems = giveitem(box, totalGive, itemboxid);
                box.health = box.health - damage;
                if (counter != null) counter.UpdateFromInput(400, 1);
                Effect.server.Run("assets/prefabs/npc/autoturret/effects/online.prefab", box.transform.position);
                if (!giveitems)
                {
                    stopbox(player, sw, box, lights, box1);
                }
            });
        }
    }
}

// --- End of file: ItemPrinter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-void ---
// --- Original File Path: I/ItemVoid/ItemVoid.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Item Void", "Default", "1.0.3")] 
    [Description("Transport items to a chest via the void")]

    class ItemVoid : RustPlugin
    {
        #region Declarations
        private static ItemVoid instance;
        private const string permissionName = "itemvoid.use";
        private Dictionary<string, ItemContainer> voidList = new Dictionary<string, ItemContainer>();
        //private static Dictionary<ulong, ItemVoid> _itemVoid = new Dictionary<ulong, ItemVoid>();
        private bool pluginready = false;

        [PluginReference] private Plugin Economics;

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            instance = this;
            permission.RegisterPermission(permissionName, this);
            cmd.AddChatCommand(_config.linkCommand, this, nameof(LinkChestCMD));
            cmd.AddChatCommand(_config.voidCommand, this, nameof(CreateVoidTeleportCMD));
        }

        void OnServerInitialized()
        {
            if (_config.eco.economicsSupport && Economics == null)
            {
                PrintWarning("You have Economics enabled in the configuration but Economics plugin is missing. Please load Economics and reload this plugin.");
                return;
            }
            if (_config.eco.economicsSupport && Economics.IsLoaded && Economics != null)
            {
                PrintWarning("Economic support loaded.");
                pluginready = true;
                return;
            }
            pluginready = true;
        }

        void Unload()
        {
            instance = null;
            var gameObjects = UnityEngine.Object.FindObjectsOfType<TeleportVoid>();
            if (gameObjects.Length > 0)
            {
                foreach (var objects in gameObjects)
                {
                    objects.entity.Kill(BaseNetworkable.DestroyMode.None);
                    UnityEngine.Object.Destroy(objects);
                }
            }
        }

        void OnEntityKill(StorageContainer container)
        {
            BasePlayer owner = FindPlayer(container.OwnerID);
            if (owner != null && voidList.ContainsKey(owner.UserIDString)) 
            {
                voidList.Remove(owner.UserIDString);
                PrintToChat(owner, lang.GetMessage("Destroyed", this, owner.UserIDString));
                return;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You don't have permission to use this command.",
                ["Linked"] = "This chest has been linked",
                ["Invalid"] = "This is either not a box, or a box not owned by you!",
                ["NotFound"] = "No box was found, please look at a box.",
                ["Created"] = "You have created a void!",
                ["NotReady"] = "The plugin is not currently fully loaded. Please check your console for more information.",
                ["Destroyed"] = "Your linked chest has been destroyed!",
                ["NoVoid"] = "You currently do not have a linked chest. Use {0} to link one."
                //["PaidTransport"] = "You have teleported {0}x {1} for a cost of ${2}",
                //["NoMoney"] = "You lack the required money to transport {0}\nYou Require ${1}"
            }, this);
        }

        #endregion

        #region Chat commands

        //[ChatCommand("void")]
        private void CreateVoidTeleportCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
            {
                PrintToChat(player, lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }
            if (!voidList.ContainsKey(player.UserIDString)) 
            {
                PrintToChat(player, string.Format(lang.GetMessage("NoVoid", this, player.UserIDString), _config.linkCommand));
                return;
            }

            /*if (!pluginready) 
            {
                PrintToChat(player, lang.GetMessage("NotReady", this, player.UserIDString));
                return;
            }*/
            CreateVoid(player);
            PrintToChat(player, lang.GetMessage("Created", this, player.UserIDString));

        }

        //[ChatCommand("linkchest")]
        private void LinkChestCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
            {
                PrintToChat(player, lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }
            /*if (!pluginready)
            {
                PrintToChat(player, lang.GetMessage("NotReady", this, player.UserIDString));
                return;
            }*/
            RaycastHit RayHit;
            var flag1 = Physics.Raycast(player.eyes.HeadRay(), out RayHit, 20f);
            BaseEntity hitEntity = flag1 ? RayHit.GetEntity() : null;
            if (hitEntity == null)
            {
                PrintToChat(player, lang.GetMessage("NotFound", this, player.UserIDString));
                return;
            }
            StorageContainer storageContainer = hitEntity.GetComponent<StorageContainer>();
            if (storageContainer == null || hitEntity.OwnerID != player.userID)
            {
                PrintToChat(player, lang.GetMessage("Invalid", this, player.UserIDString));
                return;
            }
            ItemContainer container = storageContainer.inventory;
            if (voidList.ContainsKey(player.UserIDString))
                voidList[player.UserIDString] = container;
            else
                voidList.Add(player.UserIDString, container);
            PrintToChat(player, lang.GetMessage("Linked", this, player.UserIDString));

        }

        #endregion

        #region Void handling

        private BaseEntity CreateVoid(BasePlayer player)
        {
            BaseEntity ent = GameManager.server.CreateEntity("assets/prefabs/deployable/rug/rug.deployed.prefab", player.transform.position);
            if (ent == null) 
            {
                PrintWarning("Error when creating a void. Please contact the plugin author.");
                return null;
            }
            ent.skinID = _config.skin;    // 1277571149   my portal - 1277211259
            ent.Spawn();
            ent.gameObject.AddComponent<TeleportVoid>().ownerPlayer = player;
            return ent;
        }

        public class TeleportVoid : MonoBehaviour
        {
            private ItemContainer linkedContainer;
            public BaseEntity entity;
            private BoxCollider collider;
            public BasePlayer ownerPlayer;

            private float initTime;
            private float destroyTime;
            private string t;

            private void Awake()
            {
                entity = GetComponent<BaseEntity>();
                collider = entity.GetComponent<BoxCollider>();
                collider.isTrigger = true;
                initTime = Time.time;
                destroyTime = initTime + instance._config.voidLifeLength;
                instance.NextTick(() =>
                {
                    linkedContainer = instance.voidList[ownerPlayer.UserIDString];
                });
            }

            private void Update()
            {
                if (Time.time >= destroyTime)
                {
                    entity.Kill(BaseNetworkable.DestroyMode.None);
                    Destroy(this);
                }
                transform.Rotate(0, 0.2f, 0);
                entity.SendNetworkUpdateImmediate();
            }

            private void OnTriggerEnter(Collider col)
            {
                DroppedItem droppedItem = col.GetComponentInParent<DroppedItem>();
                if (droppedItem == null)
                    return;
                if (linkedContainer != null)
                    if (ContainerHasSpace(linkedContainer))
                        TransportThroughVoid(droppedItem);
            }

            private void TransportThroughVoid(DroppedItem droppedItem)
            {
                int itemamount = droppedItem.item.amount;
                string itemname = droppedItem.item.info.shortname;
                if (instance._config.eco.economicsSupport && instance._config.eco.itemTable.ContainsKey(itemname)) 
                {
                    double itemcost = instance._config.eco.itemTable[itemname] * itemamount;
                    if (instance.EnoughMoney(droppedItem.OwnerID.ToString(), itemcost)) 
                    {
                        instance.Withdraw(droppedItem.OwnerID.ToString(), itemcost);
                        droppedItem.item.MoveToContainer(linkedContainer);
                        DoVanishEffect(droppedItem.transform.position);
                        return;
                    }
                }
                droppedItem.item.MoveToContainer(linkedContainer);
                DoVanishEffect(droppedItem.transform.position);
                //removalItems.Add(droppedItem);
            }

            private void DoVanishEffect(Vector3 pos)
            {
                t = instance._config.effectUsed;
                Effect.server.Run(t, pos, gameObject.transform.position.normalized);
            }

            private bool ContainerHasSpace(ItemContainer container)
            {
                if (container.itemList.Count < container.capacity)
                    return true;
                return false;
            }
        }

        #endregion

        #region Config handling

        public ConfigFile _config;

        public class ConfigFile
        {
            [JsonProperty("Time until the void despawns")]
            public float voidLifeLength = 300.0f;
            [JsonProperty("Skin to use for the void (Default skin is: 1277211259")]
            public ulong skin = 1277211259;
            [JsonProperty("Effect to use when an item is transferred to a linked container")]
            public string effectUsed = "assets/bundled/prefabs/fx/water/playerjumpinwater.prefab";
            [JsonProperty("Command to create a void")]
            public string voidCommand = "void";
            [JsonProperty("Command to link a chest")]
            public string linkCommand = "linkchest";
            [JsonProperty("Economics")]
            public ItemVoidEconomics eco = new ItemVoidEconomics();

        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = new ConfigFile();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion

        #region Economics handling

        public class ItemVoidEconomics
        {
            [JsonProperty("Enable economics support?")]
            public bool economicsSupport = false;
            [JsonProperty("Cost to link a container")]
            public double linkCost = 500;
            [JsonProperty("Cost to create a void")]
            public double voidCost = 1000;
            [JsonProperty("Item ID and costs")]
            public Dictionary<string, double> itemTable = new Dictionary<string, double>
            {
                {"stones", 100 },
                {"wood", 50 }
            };
        }

        #endregion

        #region Helpers

        private void Withdraw(string playerId, double amount) 
        {
            Economics?.Call("Withdraw", playerId, amount);
        }

        private bool EnoughMoney(string playerId, double requiredAmount) 
        {
            double playerBalance = (double)(Economics?.Call("Balance", playerId));
            if (playerBalance >= requiredAmount)
                return true;
            return false;
        }

        public static BasePlayer FindPlayer(ulong userId)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.userID == userId)
                    return activePlayer;
            }
            foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.userID == userId)
                    return sleepingPlayer;
            }
            return null;
        }

        #endregion
    }

}


// --- End of file: ItemVoid.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/distance-detector ---
// --- Original File Path: I/InvalidDistanceDetector/InvalidDistanceDetector.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Invalid Distance Detector", "HiTTA", "1.3.0")]
    [Description("Bans suspicious players based on weapon distances")]
    class InvalidDistanceDetector : CovalencePlugin
    {
        #region Configuration

        private Configuration _config;

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        private class Configuration
        {
            [JsonProperty("Compound Bow Distance")]
            public float CompoundBow = 100;

            [JsonProperty("Bow Distance")]
            public float Bow = 100;

            [JsonProperty("Crossbow Distance")]
            public float Crossbow = 100;

            [JsonProperty("M249 Distance")]
            public float M249 = 350;

            [JsonProperty("Eoka Pistol Distance")]
            public float EokaPistol = 50;

            [JsonProperty("M92 Pistol Distance")]
            public float M92Pistol = 150;

            [JsonProperty("Nailgun Distance")]
            public float Nailgun = 75;

            [JsonProperty("Python Revolver Distance")]
            public float PythonRevolver = 150;

            [JsonProperty("Revolver Distance")]
            public float Revolver = 125;

            [JsonProperty("Semi-Automatic Pistol Distance")]
            public float SemiAutoPistol = 125;

            [JsonProperty("Assault Rifle Distance")]
            public float AssaultRifle = 300;

            [JsonProperty("Bolt Action Rifle Distance")]
            public float BoltActionRifle = 450;

            [JsonProperty("L96 Distance")]
            public float L96Rifle = 450;

            [JsonProperty("LR-300 Assault Rifle distance")]
            public float LR300AssaultRifle = 300;

            [JsonProperty("M39 Rifle distance")]
            public float M39Rifle = 350;

            [JsonProperty("Semi-Automatic Rifle distance")]
            public float SemiAutomaticRifle = 250;

            [JsonProperty("MP5A4 distance")]
            public float MP5A4 = 300;

            [JsonProperty("Thompson distance")]
            public float Thompson = 300;
        }

        #endregion Configuration

        private void OnEntityTakeDamage(BasePlayer victim, HitInfo hitInfo)
        {
            if (hitInfo.IsProjectile() && victim.userID.IsSteamId())
            {
                BasePlayer attacker = hitInfo.Initiator as BasePlayer;
                HeldEntity heldEntity = attacker.GetHeldEntity();
                Item heldItem = heldEntity.GetItem();
                float distance = hitInfo.ProjectileDistance;
                bool bannableDistance = false;

                switch (heldEntity.ShortPrefabName)
                {
                    case "bow.compound":
                        if (distance > _config.CompoundBow) bannableDistance = true;
                        break;

                    case "bow.hunting":
                        if (distance > _config.Bow) bannableDistance = true;
                        break;

                    case "crossbow":
                        if (distance > _config.Crossbow) bannableDistance = true;
                        break;

                    case "lmg.m249":
                        if (distance > _config.M249) bannableDistance = true;
                        break;

                    case "pistol.eoka":
                        if (distance > _config.EokaPistol) bannableDistance = true;
                        break;

                    case "pistol.m92":
                        if (distance > _config.M92Pistol) bannableDistance = true;
                        break;

                    case "pistol.nailgun":
                        if (distance > _config.Nailgun) bannableDistance = true;
                        break;

                    case "pistol.python":
                        if (distance > _config.PythonRevolver) bannableDistance = true;
                        break;

                    case "pistol.revolver":
                        if (distance > _config.Revolver) bannableDistance = true;
                        break;

                    case "pistol.semiauto":
                        if (distance > _config.SemiAutoPistol) bannableDistance = true;
                        break;

                    case "rifle.ak":
                        if (distance > _config.AssaultRifle) bannableDistance = true;
                        break;

                    case "rifle.bolt":
                        if (distance > _config.BoltActionRifle) bannableDistance = true;
                        break;

                    case "rifle.l96":
                        if (distance > _config.L96Rifle) bannableDistance = true;
                        break;

                    case "rifle.lr300":
                        if (distance > _config.LR300AssaultRifle) bannableDistance = true;
                        break;

                    case "rifle.m39":
                        if (distance > _config.M39Rifle) bannableDistance = true;
                        break;

                    case "rifle.semiauto":
                        if (distance > _config.SemiAutomaticRifle) bannableDistance = true;
                        break;

                    case "smg.mp5":
                        if (distance > _config.MP5A4) bannableDistance = true;
                        break;

                    case "smg.thompson":
                        if (distance > _config.Thompson) bannableDistance = true;
                        break;
                }

                if (bannableDistance)
                {
                    server.Ban(attacker.UserIDString, $"Anti Cheat: (Invalid Distance! - {heldItem.info.displayName.english})");
                    Log($"Attacker: {attacker.displayName} ({attacker.userID}) | Hit distance: {distance} | Weapon: {heldItem} | Victim: {victim.displayName} ({victim.userID})");
                }
            }
        }
    }
}

// --- End of file: InvalidDistanceDetector.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/image-library ---
// --- Original File Path: I/ImageLibrary/ImageLibrary.cs ---

//Reference: Facepunch.Sqlite
//Reference: UnityEngine.UnityWebRequestModule
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Steamworks;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info("Image Library", "Absolut & K1lly0u", "2.0.62")]
    [Description("Plugin API for downloading and managing images")]
    class ImageLibrary : RustPlugin
    {
        #region Fields

        private ImageIdentifiers imageIdentifiers;
        private ImageURLs imageUrls;
        private SkinInformation skinInformation;
        private DynamicConfigFile identifiers;
        private DynamicConfigFile urls;
        private DynamicConfigFile skininfo;

        private static ImageLibrary il;
        private ImageAssets assets;

        private Queue<LoadOrder> loadOrders = new Queue<LoadOrder>();
        private bool orderPending;
        private bool isInitialized;

        private JsonSerializerSettings errorHandling = new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } };

        private const string STEAM_API_URL = "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/";
        private const string STEAM_AVATAR_URL = "https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key={0}&steamids={1}";

        private string[] itemShortNames;

        #endregion Fields

        #region Oxide Hooks

        private void Loaded()
        {
            identifiers = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/image_data");
            
            urls = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/image_urls");
            skininfo = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/skin_data");

            il = this;
            LoadData();
        }

        private void OnServerInitialized()
        {
            itemShortNames = ItemManager.itemList.Select(x => x.shortname).ToArray();

            foreach (ItemDefinition item in ItemManager.itemList)
            {
                string workshopName = item.displayName.english.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "");
                if (!workshopNameToShortname.ContainsKey(workshopName))
                    workshopNameToShortname.Add(workshopName, item.shortname);
            }

            AddDefaultUrls();

            CheckForRefresh();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }
    
        private void OnPlayerConnected(BasePlayer player) => GetPlayerAvatar(player?.UserIDString);

        private void Unload()
        {
            SaveData();
            UnityEngine.Object.Destroy(assets);
            il = null;
        }

        #endregion Oxide Hooks

        #region Functions
        private IEnumerator ProcessLoadOrders()
        {
            yield return new WaitWhile(() => !isInitialized);

            if (loadOrders.Count > 0)
            {
                if (orderPending)
                    yield break;

                LoadOrder nextLoad = loadOrders.Dequeue();
                if (!nextLoad.loadSilent)
                    Puts("Starting order " + nextLoad.loadName);

                if (nextLoad.imageList != null && nextLoad.imageList.Count > 0)
                {
                    foreach (KeyValuePair<string, string> item in nextLoad.imageList)
                        assets.Add(item.Key, item.Value);
                }
                if (nextLoad.imageData != null && nextLoad.imageData.Count > 0)
                {
                    foreach (KeyValuePair<string, byte[]> item in nextLoad.imageData)
                        assets.Add(item.Key, null, item.Value);
                }

                orderPending = true;

                assets.RegisterCallback(nextLoad.callback);

                assets.BeginLoad(nextLoad.loadSilent ? string.Empty : nextLoad.loadName);
            }
        }

        private void GetPlayerAvatar(string userId)
        {
            if (!configData.StoreAvatars || string.IsNullOrEmpty(userId) || string.IsNullOrEmpty(configData.SteamAPIKey) || HasImage(userId, 0))
                return;

            webrequest.Enqueue(string.Format(STEAM_AVATAR_URL, configData.SteamAPIKey, userId), null, (code, response) =>
            {
                if (response != null && code == 200)
                {
                    try
                    {
                        AvatarRoot rootObject = JsonConvert.DeserializeObject<AvatarRoot>(response, errorHandling);
                        if (rootObject?.response?.players?.Length > 0)
                        {
                            string avatarUrl = rootObject.response.players[0].avatarmedium;
                            if (!string.IsNullOrEmpty(avatarUrl))                            
                                AddImage(avatarUrl, userId, 0);                               
                        }                        
                    }
                    catch { }
                }
            }, this);
        }

        private void RefreshImagery()
        {
            imageIdentifiers.imageIds.Clear();
            imageIdentifiers.lastCEID = CommunityEntity.ServerInstance.net.ID.Value;

            AddImage("http://i.imgur.com/sZepiWv.png", "NONE", 0);
            AddImage("http://i.imgur.com/lydxb0u.png", "LOADING", 0);
            foreach (KeyValuePair<string, string> image in configData.UserImages)
            {
                if (!string.IsNullOrEmpty(image.Value))
                    AddImage(image.Value, image.Key, 0);
            }

            if ((Steamworks.SteamInventory.Definitions?.Length ?? 0) == 0)
            {
                PrintWarning("Waiting for Steamworks to update item definitions....");
                Steamworks.SteamInventory.OnDefinitionsUpdated += GetItemSkins;
            }
            else GetItemSkins();
        }

        private void CheckForRefresh()
        {
            if (assets == null)
                assets = new GameObject("WebObject").AddComponent<ImageAssets>();

            isInitialized = true;

            if (imageIdentifiers.lastCEID != CommunityEntity.ServerInstance.net.ID.Value)
            {
                if (imageIdentifiers.imageIds.Count < 2)
                {
                    RefreshImagery();
                }
                else
                {
                    PrintWarning("The CommunityEntity instance ID has changed! Due to the way CUI works in Rust all previously stored images must be removed and re-stored using the new ID as reference so clients can find the images. These images will be added to a new load order. Interupting this process will result in being required to re-download these images from the web");
                    RestoreLoadedImages();
                }
            }
        }

        private void RestoreLoadedImages()
        {
            orderPending = true;

            try
            {
                Facepunch.Sqlite.Database db = new Facepunch.Sqlite.Database();
                db.Open(string.Concat(ConVar.Server.rootFolder, "/", "sv.files.", Rust.Protocol.save - 1, ".db"));                
                if (db.TableExists("data"))
                {
                    Dictionary<string, byte[]> oldFiles = new Dictionary<string, byte[]>();
                    int failed = 0;

                    for (int i = imageIdentifiers.imageIds.Count - 1; i >= 0; i--)
                    {
                        KeyValuePair<string, string> image = imageIdentifiers.imageIds.ElementAt(i);

                        uint imageId;
                        if (!uint.TryParse(image.Value, out imageId))
                            continue;

                        byte[] bytes = db.Query<byte[], int, int, int>("SELECT data FROM data WHERE crc = ? AND filetype = ? AND entid = ? LIMIT 1", (int)imageId, 0, (int)imageIdentifiers.lastCEID );
                        if (bytes != null)
                            oldFiles.Add(image.Key, bytes);
                        else
                        {
                            failed++;
                            imageIdentifiers.imageIds.Remove(image.Key);
                        }
                    }

                    if (oldFiles.Count > 0)
                    {
                        loadOrders.Enqueue(new LoadOrder("Image restoration from previous database", oldFiles));
                        PrintWarning($"{imageIdentifiers.imageIds.Count - failed} images queued for restoration from previous image db, {failed} images failed");
                    }

                }
                db.Close();
            }
            catch
            {
                PrintError("Failed to open previous image database. Unable to clone previous image data");
            }
            //Facepunch.Sqlite.Database db = new Facepunch.Sqlite.Database();
            //try
            //{
            //    db.Open($"{ConVar.Server.rootFolder}/sv.files.0.db");
            //    db.Execute("DELETE FROM data WHERE entid = ?", imageIdentifiers.lastCEID);
            //    db.Close();
            //}
            //catch { }

            //loadOrders.Enqueue(new LoadOrder("Image restoration from previous database", oldFiles));
            //PrintWarning($"{imageIdentifiers.imageIds.Count - failed} images queued for restoration, {failed} images failed");
            imageIdentifiers.lastCEID = CommunityEntity.ServerInstance.net.ID.Value;
            SaveData();

            orderPending = false;
            ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
        }

        #endregion Functions

        #region Workshop Names and Image URLs
        private void AddDefaultUrls()
        {
            foreach (ItemDefinition itemDefinition in ItemManager.itemList)
            {
                string identifier = $"{itemDefinition.shortname}_0";
                if (!imageUrls.URLs.ContainsKey(identifier))
                    imageUrls.URLs.Add(identifier, $"{configData.ImageURL}{itemDefinition.shortname}.png");
                else imageUrls.URLs[identifier] = $"{configData.ImageURL}{itemDefinition.shortname}.png";
            }
            
            SaveUrls();

            LoadInbuiltSkinLookup();
        }

        private void LoadInbuiltSkinLookup()
        {
            const string LOOKUP_TABLE = "https://raw.githubusercontent.com/k1lly0u/Oxide/master/il_inbuilt_skins.json";

            try
            {
                Debug.Log("Loading inbuilt skin manifest from GitHub...");
                webrequest.Enqueue(LOOKUP_TABLE, string.Empty, (int code, string response) =>
                {
                    Dictionary<string, string> collection = JsonConvert.DeserializeObject<Dictionary<string, string>>(response);

                    foreach (ItemSkinDirectory.Skin skin in ItemSkinDirectory.Instance.skins)
                    {
                        if (skin.invItem == null || string.IsNullOrEmpty(skin.invItem.itemname))
                            continue;

                        string filename;
                        if (collection.TryGetValue(skin.name, out filename))
                        {
                            string identifier = $"{skin.invItem.itemname}_{skin.id}";

                            if (!imageUrls.URLs.ContainsKey(identifier))
                                imageUrls.URLs.Add(identifier, $"{configData.ImageURL}{filename}.png");
                            else imageUrls.URLs[identifier] = $"{configData.ImageURL}{filename}.png";
                        }
                    }

                    Debug.Log("Skin manifest imported successfully");
                    SaveUrls();
                }, this);
            }
            catch
            {
                Debug.LogError("Failed to download inbuilt skin manifest from GitHub. Unable to gather inbuilt skin list");
            }
        }

        private readonly Dictionary<string, string> workshopNameToShortname = new Dictionary<string, string>
        {
            {"longtshirt", "tshirt.long" },
            {"cap", "hat.cap" },
            {"beenie", "hat.beenie" },
            {"boonie", "hat.boonie" },
            {"balaclava", "mask.balaclava" },
            {"pipeshotgun", "shotgun.waterpipe" },
            {"woodstorage", "box.wooden" },
            {"ak47", "rifle.ak" },
            {"bearrug", "rug.bear" },
            {"boltrifle", "rifle.bolt" },
            {"bandana", "mask.bandana" },
            {"hideshirt", "attire.hide.vest" },
            {"snowjacket", "jacket.snow" },
            {"buckethat", "bucket.helmet" },
            {"semiautopistol", "pistol.semiauto" },
            {"burlapgloves", "burlap.gloves" },
            {"roadsignvest", "roadsign.jacket" },
            {"roadsignpants", "roadsign.kilt" },
            {"burlappants", "burlap.trousers" },
            {"collaredshirt", "shirt.collared" },
            {"mp5", "smg.mp5" },
            {"sword", "salvaged.sword" },
            {"workboots", "shoes.boots" },
            {"vagabondjacket", "jacket" },
            {"hideshoes", "attire.hide.boots" },
            {"deerskullmask", "deer.skull.mask" },
            {"minerhat", "hat.miner" },
            {"lr300", "rifle.lr300" },
            {"lr300.item", "rifle.lr300" },
            {"burlap.gloves", "burlap.gloves.new"},
            {"leather.gloves", "burlap.gloves"},
            {"python", "pistol.python" },
            {"m39", "rifle.m39"},
            {"woodendoubledoor", "door.double.hinged.wood"}
        };

        #endregion Workshop Names and Image URLs

        #region API

        [HookMethod("AddImage")]
        public bool AddImage(string url, string imageName, ulong imageId, Action callback = null)
        {
            loadOrders.Enqueue(new LoadOrder(imageName, new Dictionary<string, string> { { $"{imageName}_{imageId}", url } }, true, callback));
            if (!orderPending)
                ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            return true;
        }

        [HookMethod("AddImageData")]
        public bool AddImageData(string imageName, byte[] array, ulong imageId, Action callback = null)
        {
            loadOrders.Enqueue(new LoadOrder(imageName, new Dictionary<string, byte[]> { { $"{imageName}_{imageId}", array } }, true, callback));
            if (!orderPending)
                ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            return true;
        }

        [HookMethod("GetImageURL")]
        public string GetImageURL(string imageName, ulong imageId = 0)
        {
            string identifier = $"{imageName}_{imageId}";
            string value;
            if (imageUrls.URLs.TryGetValue(identifier, out value))
                return value;
            return string.Empty;
        }

        [HookMethod("GetImage")]
        public string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false)
        {
            string identifier = $"{imageName}_{imageId}";
            string value;
            if (imageIdentifiers.imageIds.TryGetValue(identifier, out value))
                return value;
            else
            {                
                if (imageUrls.URLs.TryGetValue(identifier, out value))
                {
                    AddImage(value, imageName, imageId);
                    return imageIdentifiers.imageIds["LOADING_0"];
                }
            }

            if (returnUrl && !string.IsNullOrEmpty(value))
                return value;

            return imageIdentifiers.imageIds["NONE_0"];
        }

        [HookMethod("GetImageList")]
        public List<ulong> GetImageList(string name)
        {
            List<ulong> skinIds = new List<ulong>();
            string[] matches = imageUrls.URLs.Keys.Where(x => x.StartsWith(name)).ToArray();
            for (int i = 0; i < matches.Length; i++)
            {
                int index = matches[i].IndexOf("_");
                if (matches[i].Substring(0, index) == name)
                {
                    ulong skinID;
                    if (ulong.TryParse(matches[i].Substring(index + 1), out skinID))
                        skinIds.Add(ulong.Parse(matches[i].Substring(index + 1)));
                }
            }
            return skinIds;
        }

        [HookMethod("GetSkinInfo")]
        public Dictionary<string, object> GetSkinInfo(string name, ulong id)
        {
            Dictionary<string, object> skinInfo;
            if (skinInformation.skinData.TryGetValue($"{name}_{id}", out skinInfo))
                return skinInfo;
            return null;
        }

        [HookMethod("HasImage")]
        public bool HasImage(string imageName, ulong imageId)
        {
            string key = $"{imageName}_{imageId}";
            string value;

            if (imageIdentifiers.imageIds.TryGetValue(key, out value) && IsInStorage(uint.Parse(value)))            
                return true;            

            return false;
        }

        public bool IsInStorage(uint crc) => FileStorage.server.Get(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID) != null;

        [HookMethod("IsReady")]
        public bool IsReady() => loadOrders.Count == 0 && !orderPending;

        [HookMethod("ImportImageList")]
        public void ImportImageList(string title, Dictionary<string, string> imageList, ulong imageId = 0, bool replace = false, Action callback = null)
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            foreach (KeyValuePair<string, string> image in imageList)
            {
                if (!replace && HasImage(image.Key, imageId))
                    continue;
                newLoadOrder[$"{image.Key}_{imageId}"] = image.Value;
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("ImportItemList")]
        public void ImportItemList(string title, Dictionary<string, Dictionary<ulong, string>> itemList, bool replace = false, Action callback = null)
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            foreach (KeyValuePair<string, Dictionary<ulong, string>> image in itemList)
            {
                foreach (KeyValuePair<ulong, string> skin in image.Value)
                {
                    if (!replace && HasImage(image.Key, skin.Key))
                        continue;
                    newLoadOrder[$"{image.Key}_{skin.Key}"] = skin.Value;
                }
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("ImportImageData")]
        public void ImportImageData(string title, Dictionary<string, byte[]> imageList, ulong imageId = 0, bool replace = false, Action callback = null)
        {
            Dictionary<string, byte[]> newLoadOrder = new Dictionary<string, byte[]>();
            foreach (KeyValuePair<string, byte[]> image in imageList)
            {
                if (!replace && HasImage(image.Key, imageId))
                    continue;
                newLoadOrder[$"{image.Key}_{imageId}"] = image.Value;
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("LoadImageList")]
        public void LoadImageList(string title, List<KeyValuePair<string, ulong>> imageList, Action callback = null)
        {
            Dictionary<string, string> newLoadOrderURL = new Dictionary<string, string>();
            List<KeyValuePair<string, ulong>> workshopDownloads = new List<KeyValuePair<string, ulong>>();

            foreach (KeyValuePair<string, ulong> image in imageList)
            {
                if (HasImage(image.Key, image.Value))                
                    continue;

                string identifier = $"{image.Key}_{image.Value}";

                if (imageUrls.URLs.ContainsKey(identifier) && !newLoadOrderURL.ContainsKey(identifier))
                {
                    newLoadOrderURL.Add(identifier, imageUrls.URLs[identifier]);
                }
                else
                {
                    workshopDownloads.Add(new KeyValuePair<string, ulong>(image.Key, image.Value));
                }
            }

            if (workshopDownloads.Count > 0)
            {
                QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, 0, callback);
                return;
            }

            if (newLoadOrderURL.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("RemoveImage")]
        public void RemoveImage(string imageName, ulong imageId)
        {
            if (!HasImage(imageName, imageId))
                return;

            uint crc = uint.Parse(GetImage(imageName, imageId));
            FileStorage.server.Remove(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);
        }

        [HookMethod("SendImage")]
        public void SendImage(BasePlayer player, string imageName, ulong imageId = 0)
        {
            if (!HasImage(imageName, imageId) || player?.net?.connection == null)
                return;

            uint crc = uint.Parse(GetImage(imageName, imageId));
            byte[] array = FileStorage.server.Get(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);

            if (array == null)
                return;

            CommunityEntity.ServerInstance.ClientRPCEx<uint, uint, byte[]>(new Network.SendInfo(player.net.connection)
            {
                channel = 2,
                method = Network.SendMethod.Reliable
            }, null, "CL_ReceiveFilePng", crc, (uint)array.Length, array);
        }
        #endregion API

        #region Steam API
        private List<ulong> BuildApprovedItemList()
        {
            List<ulong> list = new List<ulong>();

            foreach (InventoryDef item in Steamworks.SteamInventory.Definitions)
            {
                string shortname = item.GetProperty("itemshortname");
                ulong workshopid;

                if (item == null || string.IsNullOrEmpty(shortname))
                    continue;

                if (workshopNameToShortname.ContainsKey(shortname))
                    shortname = workshopNameToShortname[shortname];

                if (item.Id < 100)
                    continue;

                if (!ulong.TryParse(item.GetProperty("workshopid"), out workshopid))
                    continue;

                if (HasImage(shortname, workshopid))
                    continue;

                list.Add(workshopid);
            }

            return list;
        }

        private string BuildDetailsString(List<ulong> list, int page)
        {            
            int totalPages = Mathf.CeilToInt((float)list.Count / 100f);
            int index = page * 100;
            int limit = Mathf.Min((page + 1) * 100, list.Count);
            string details = string.Format("?key={0}&itemcount={1}", configData.SteamAPIKey, (limit - index));

            for (int i = index; i < limit; i++)            
                details += string.Format("&publishedfileids[{0}]={1}", i - index, list[i]);
            
            return details;
        }

        private string BuildDetailsString(List<ulong> list)
        {            
            string details = string.Format("?key={0}&itemcount={1}", configData.SteamAPIKey, list.Count);

            for (int i = 0; i < list.Count; i++)
                details += string.Format("&publishedfileids[{0}]={1}", i, list[i]);

            return details;
        }

        private bool IsValid(PublishedFileDetails item)
        {
            if (string.IsNullOrEmpty(item.preview_url))
                return false;

            if (item.tags == null)
                return false;

            return true;
        }

        private void GetItemSkins()
        {
            Steamworks.SteamInventory.OnDefinitionsUpdated -= GetItemSkins;

            PrintWarning("Retrieving item skin lists...");

            GetApprovedItemSkins(BuildApprovedItemList(), 0);
        }

        private void QueueFileQueryRequest(string details, Action<PublishedFileDetails[]> callback)
        {
            webrequest.Enqueue(STEAM_API_URL, details, (code, response) =>
            {
                try
                {
                    QueryResponse query = JsonConvert.DeserializeObject<QueryResponse>(response, errorHandling);
                    if (query == null || query.response == null || query.response.publishedfiledetails.Length == 0)
                    {
                        if (code != 200)
                            PrintError($"There was a error querying Steam for workshop item data : Code ({code})\n{details}");
                        return;
                    }
                    else
                    {
                        if (query?.response?.publishedfiledetails?.Length > 0)
                            callback.Invoke(query.response.publishedfiledetails);
                    }
                }
                catch { }
            }, this, Core.Libraries.RequestMethod.POST);
        }

        private void GetApprovedItemSkins(List<ulong> itemsToDownload, int page)
        {
            if (itemsToDownload.Count < 1)
            {
                Puts("Approved skins loaded");

                SaveUrls();
                SaveSkinInfo();

                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                return;
            }

            int totalPages = Mathf.CeilToInt((float)itemsToDownload.Count / 100f) - 1;

            string details = BuildDetailsString(itemsToDownload, page);

            QueueFileQueryRequest(details, (PublishedFileDetails[] items) =>
            {
                ServerMgr.Instance.StartCoroutine(ProcessApprovedBlock(itemsToDownload, items, page, totalPages));
            });
        }

        private IEnumerator ProcessApprovedBlock(List<ulong> itemsToDownload, PublishedFileDetails[] items, int page, int totalPages)
        {
            PrintWarning($"Processing approved skins; Page {page + 1}/{totalPages + 1}");

            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

            foreach (PublishedFileDetails item in items)
            {
                if (!IsValid(item))
                    continue;

                foreach (PublishedFileDetails.Tag tag in item.tags)
                {
                    if (string.IsNullOrEmpty(tag.tag))
                        continue;

                    ulong workshopid = Convert.ToUInt64(item.publishedfileid);

                    string adjTag = tag.tag.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "").Replace(".item", "");
                    if (workshopNameToShortname.ContainsKey(adjTag))
                    {
                        string shortname = workshopNameToShortname[adjTag];

                        string identifier = $"{shortname}_{workshopid}";

                        if (!imageUrls.URLs.ContainsKey(identifier))
                            imageUrls.URLs.Add(identifier, item.preview_url.Replace("https", "http"));

                        skinInformation.skinData[identifier] = new Dictionary<string, object>
                                {
                                    {"title", item.title },
                                    {"votesup", 0 },
                                    {"votesdown", 0 },
                                    {"description", item.file_description },
                                    {"score", 0 },
                                    {"views", 0 },
                                    {"created", new DateTime() },
                                };
                    }
                }
            }

            yield return CoroutineEx.waitForEndOfFrame;
            yield return CoroutineEx.waitForEndOfFrame;

            if (page < totalPages)
                GetApprovedItemSkins(itemsToDownload, page + 1);
            else
            {
                itemsToDownload.Clear();

                Puts("Approved skins loaded");

                SaveUrls();
                SaveSkinInfo();

                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
        }

        private void QueueWorkshopDownload(string title, Dictionary<string, string> newLoadOrderURL, List<KeyValuePair<string, ulong>> workshopDownloads, int page = 0, Action callback = null)
        {
            int rangeMin = page * 100;
            int rangeMax = (page + 1) * 100;

            if (rangeMax > workshopDownloads.Count)
                rangeMax = workshopDownloads.Count;

            List<ulong> requestedSkins = workshopDownloads.GetRange(rangeMin, rangeMax - rangeMin).Select(x => x.Value).ToList();

            int totalPages = Mathf.CeilToInt((float)workshopDownloads.Count / 100f) - 1;

            string details = BuildDetailsString(requestedSkins);

            try
            {
                webrequest.Enqueue(STEAM_API_URL, details, (code, response) =>
                {
                    QueryResponse query = JsonConvert.DeserializeObject<QueryResponse>(response, errorHandling);
                    if (query == null || query.response == null || query.response.publishedfiledetails.Length == 0)
                    {
                        if (code != 200)
                            PrintError($"There was a error querying Steam for workshop item data : Code ({code})");

                        if (page < totalPages)
                            QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, page + 1, callback);
                        else
                        {
                            if (newLoadOrderURL.Count > 0)
                            {
                                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, page < totalPages ? null : callback));
                                if (!orderPending)
                                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                            }
                            else
                            {
                                if (callback != null)
                                    callback.Invoke();
                            }
                        }
                        return;
                    }
                    else
                    {
                        if (query.response.publishedfiledetails.Length > 0)
                        {
                            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

                            foreach (PublishedFileDetails item in query.response.publishedfiledetails)
                            {
                                if (!string.IsNullOrEmpty(item.preview_url))
                                {
                                    ulong skinId = Convert.ToUInt64(item.publishedfileid);

                                    KeyValuePair<string, ulong>? kvp = workshopDownloads.Find(x => x.Value == skinId);

                                    if (kvp.HasValue)
                                    {
                                        string identifier = $"{kvp.Value.Key}_{kvp.Value.Value}";

                                        if (!newLoadOrderURL.ContainsKey(identifier))
                                            newLoadOrderURL.Add(identifier, item.preview_url);

                                        if (!imageUrls.URLs.ContainsKey(identifier))
                                            imageUrls.URLs.Add(identifier, item.preview_url);

                                        skinInformation.skinData[identifier] = new Dictionary<string, object>
                                        {
                                            {"title", item.title },
                                            {"votesup",  0 },
                                            {"votesdown", 0 },
                                            {"description", item.file_description },
                                            {"score", 0 },
                                            {"views", item.views },
                                            {"created", new DateTime(item.time_created) },
                                        };

                                        requestedSkins.Remove(skinId);
                                    }
                                }
                            }

                            SaveUrls();
                            SaveSkinInfo();

                            if (requestedSkins.Count != 0)
                            {
                                Puts($"{requestedSkins.Count} workshop skin ID's for image batch ({title}) are invalid! They may have been removed from the workshop\nIDs: {requestedSkins.ToSentence()}");
                            }
                        }

                        if (page < totalPages)
                            QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, page + 1, callback);
                        else
                        {
                            if (newLoadOrderURL.Count > 0)
                            {
                                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, page < totalPages ? null : callback));
                                if (!orderPending)
                                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                            }
                            else
                            {
                                if (callback != null)
                                    callback.Invoke();
                            }
                        }
                    }
                },
                this,
                Core.Libraries.RequestMethod.POST);
            }
            catch { }
        }

        #region JSON Response Classes
        public class QueryResponse
        {
            public Response response;
        }

        public class Response
        {
            public int total;
            public PublishedFileDetails[] publishedfiledetails;
        }

        public class PublishedFileDetails
        {
            public int result;
            public string publishedfileid;
            public string creator;
            public int creator_appid;
            public int consumer_appid;
            public int consumer_shortcutid;
            public string filename;
            public string file_size;
            public string preview_file_size;
            public string file_url;
            public string preview_url;
            public string url;
            public string hcontent_file;
            public string hcontent_preview;
            public string title;
            public string file_description;
            public int time_created;
            public int time_updated;
            public int visibility;
            public int flags;
            public bool workshop_file;
            public bool workshop_accepted;
            public bool show_subscribe_all;
            public int num_comments_public;
            public bool banned;
            public string ban_reason;
            public string banner;
            public bool can_be_deleted;
            public string app_name;
            public int file_type;
            public bool can_subscribe;
            public int subscriptions;
            public int favorited;
            public int followers;
            public int lifetime_subscriptions;
            public int lifetime_favorited;
            public int lifetime_followers;
            public string lifetime_playtime;
            public string lifetime_playtime_sessions;
            public int views;
            public int num_children;
            public int num_reports;
            public Preview[] previews;
            public Tag[] tags;
            public int language;
            public bool maybe_inappropriate_sex;
            public bool maybe_inappropriate_violence;

            public class Tag
            {
                public string tag;
                public bool adminonly;
            }

        }

        public class Preview
        {
            public string previewid;
            public int sortorder;
            public string url;
            public int size;
            public string filename;
            public int preview_type;
            public string youtubevideoid;
            public string external_reference;
        }
        #endregion
        #endregion

        #region Commands

        [ConsoleCommand("cancelstorage")]
        private void cmdCancelStorage(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                if (!orderPending)
                    PrintWarning("No images are currently being downloaded");
                else
                {
                    assets.ClearList();
                    loadOrders.Clear();
                    PrintWarning("Pending image downloads have been cancelled!");
                }
            }
        }

        private List<ulong> pendingAnswers = new List<ulong>();

        [ConsoleCommand("refreshallimages")]
        private void cmdRefreshAllImages(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                SendReply(arg, "Running this command will wipe all of your ImageLibrary data, meaning every registered image will need to be re-downloaded. Are you sure you wish to continue? (type yes or no)");

                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;
                if (!pendingAnswers.Contains(userId))
                {
                    pendingAnswers.Add(userId);
                    timer.In(5, () =>
                    {
                        if (pendingAnswers.Contains(userId))
                            pendingAnswers.Remove(userId);
                    });
                }
            }
        }

        [ConsoleCommand("yes")]
        private void cmdRefreshAllImagesYes(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;
                if (pendingAnswers.Contains(userId))
                {
                    PrintWarning("Wiping ImageLibrary data and redownloading ImageLibrary specific images. All plugins that have registered images via ImageLibrary will need to be re-loaded!");
                    RefreshImagery();

                    pendingAnswers.Remove(userId);
                }
            }
        }

        [ConsoleCommand("no")]
        private void cmdRefreshAllImagesNo(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;

                if (pendingAnswers.Contains(userId))
                {
                    SendReply(arg, "ImageLibrary data wipe aborted!");
                    pendingAnswers.Remove(userId);
                }
            }
        }

        #endregion Commands

        #region Image Storage

        private struct LoadOrder
        {
            public string loadName;
            public bool loadSilent;

            public Dictionary<string, string> imageList;
            public Dictionary<string, byte[]> imageData;

            public Action callback;

            public LoadOrder(string loadName, Dictionary<string, string> imageList, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = imageList;
                this.imageData = null;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
            public LoadOrder(string loadName, Dictionary<string, byte[]> imageData, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = null;
                this.imageData = imageData;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
            public LoadOrder(string loadName, Dictionary<string, string> imageList, Dictionary<string, byte[]> imageData, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = imageList;
                this.imageData = imageData;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
        }

        private class ImageAssets : MonoBehaviour
        {
            private Queue<QueueItem> queueList = new Queue<QueueItem>();
            private bool isLoading;
            private double nextUpdate;
            private int listCount;
            private string request;

            private Action callback;

            private void OnDestroy()
            {
                queueList.Clear();
            }

            public void Add(string name, string url = null, byte[] bytes = null)
            {
                queueList.Enqueue(new QueueItem(name, url, bytes));
            }

            public void RegisterCallback(Action callback) => this.callback = callback;

            public void BeginLoad(string request)
            {
                this.request = request;
                nextUpdate = UnityEngine.Time.time + il.configData.UpdateInterval;
                listCount = queueList.Count;
                Next();
            }

            public void ClearList()
            {
                queueList.Clear();
                il.orderPending = false;
            }

            private void Next()
            {
                if (queueList.Count == 0)
                {
                    il.orderPending = false;
                    il.SaveData();
                    if (!string.IsNullOrEmpty(request))
                        print($"Image batch ({request}) has been stored successfully");

                    request = string.Empty;
                    listCount = 0;

                    if (callback != null)
                        callback.Invoke();

                    StartCoroutine(il.ProcessLoadOrders());
                    return;
                }
                if (il.configData.ShowProgress && listCount > 1)
                {
                    float time = UnityEngine.Time.time;
                    if (time > nextUpdate)
                    {
                        int amountDone = listCount - queueList.Count;
                        print($"{request} storage process at {Math.Round((amountDone / (float)listCount) * 100, 0)}% ({amountDone}/{listCount})");
                        nextUpdate = time + il.configData.UpdateInterval;
                    }
                }
                isLoading = true;

                QueueItem queueItem = queueList.Dequeue();
                if (!string.IsNullOrEmpty(queueItem.url))
                    StartCoroutine(DownloadImage(queueItem));
                else StoreByteArray(queueItem.bytes, queueItem.name);
            }

            private IEnumerator DownloadImage(QueueItem info)
            {
                UnityWebRequest www = UnityWebRequest.Get(info.url);

                yield return www.SendWebRequest();
                if (il == null) yield break;
                if (www.isNetworkError || www.isHttpError)
                {
                    print(string.Format("Image failed to download! Error: {0} - Image Name: {1} - Image URL: {2}", www.error, info.name, info.url));
                    www.Dispose();
                    isLoading = false;
                    Next();
                    yield break;
                }

                if (www?.downloadHandler?.data != null)
                {
                    Texture2D texture = new Texture2D(2, 2);
                    texture.LoadImage(www.downloadHandler.data);
                    if (texture != null)
                    {
                        bool shouldStore = true;
                        byte[] bytes = texture.EncodeToPNG();

                        if (bytes.Length > 3145728)
                        {
                            Debug.Log($"[ImageLibrary] Failed to store image data for image : {info.name} for equest {request}\nURL: {info.url}\n{bytes.Length} bytes is larger then the allowed transferable size of 3145728 bytes");
                            shouldStore = false;
                        }

                        DestroyImmediate(texture);

                        if (shouldStore)
                            StoreByteArray(bytes, info.name);
                    }
                }
                www.Dispose();
            }

            private void StoreByteArray(byte[] bytes, string name)
            {
                if (bytes != null)
                    il.imageIdentifiers.imageIds[name] = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                isLoading = false;
                Next();
            }

            private class QueueItem
            {
                public byte[] bytes;
                public string url;
                public string name;
                public QueueItem(string name, string url = null, byte[] bytes = null)
                {
                    this.bytes = bytes;
                    this.url = url;
                    this.name = name;
                }
            }
        }

        #endregion Image Storage

        #region Config

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Avatars - Store player avatars")]
            public bool StoreAvatars { get; set; }

            [JsonProperty(PropertyName = "Steam API key (get one here https://steamcommunity.com/dev/apikey)")]
            public string SteamAPIKey { get; set; }

            [JsonProperty(PropertyName = "URL to web folder containing all item icons")]
            public string ImageURL { get; set; }

            [JsonProperty(PropertyName = "Progress - Show download progress in console")]
            public bool ShowProgress { get; set; }

            [JsonProperty(PropertyName = "Progress - Time between update notifications")]
            public int UpdateInterval { get; set; }
            
            [JsonProperty(PropertyName = "User Images - Manually define images to be loaded")]
            public Dictionary<string, string> UserImages { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ShowProgress = true,
                SteamAPIKey = string.Empty,
                StoreAvatars = false,
                UpdateInterval = 20,
                ImageURL = "https://www.rustedit.io/images/imagelibrary/",
                UserImages = new Dictionary<string, string>(),
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(2, 0, 47))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(2, 0, 53))
                configData.StoreAvatars = false;

            if (configData.Version < new VersionNumber(2, 0, 55))
                configData.ImageURL = baseConfig.ImageURL;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion Config

        #region Data Management

        private void SaveData() => identifiers.WriteObject(imageIdentifiers);

        private void SaveSkinInfo() => skininfo.WriteObject(skinInformation);

        private void SaveUrls() => urls.WriteObject(imageUrls);

        private void LoadData()
        {
            try
            {
                imageIdentifiers = identifiers.ReadObject<ImageIdentifiers>();
            }
            catch
            {
                imageIdentifiers = new ImageIdentifiers();
            }
            try
            {
                skinInformation = skininfo.ReadObject<SkinInformation>();
            }
            catch
            {
                skinInformation = new SkinInformation();
            }
            try
            {
                imageUrls = urls.ReadObject<ImageURLs>();
            }
            catch
            {
                imageUrls = new ImageURLs();
            }
            if (skinInformation == null)
                skinInformation = new SkinInformation();
            if (imageIdentifiers == null)
                imageIdentifiers = new ImageIdentifiers();
            if (imageUrls == null)
                imageUrls = new ImageURLs();
        }

        private class ImageIdentifiers
        {
            public ulong lastCEID;
            public Hash<string, string> imageIds = new Hash<string, string>();
        }

        private class SkinInformation
        {
            public Hash<string, Dictionary<string, object>> skinData = new Hash<string, Dictionary<string, object>>();
        }

        private class ImageURLs
        {
            public Hash<string, string> URLs = new Hash<string, string>();
        }


        public class AvatarRoot
        {
            public Response response { get; set; }

            public class Response
            {
                public Player[] players { get; set; }

                public class Player
                {
                    public string steamid { get; set; }
                    public int communityvisibilitystate { get; set; }
                    public int profilestate { get; set; }
                    public string personaname { get; set; }
                    public int lastlogoff { get; set; }
                    public string profileurl { get; set; }
                    public string avatar { get; set; }
                    public string avatarmedium { get; set; }
                    public string avatarfull { get; set; }
                    public int personastate { get; set; }
                    public string realname { get; set; }
                    public string primaryclanid { get; set; }
                    public int timecreated { get; set; }
                    public int personastateflags { get; set; }
                }
            }
        }
        #endregion Data Management
    }
}


// --- End of file: ImageLibrary.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/imgur-api ---
// --- Original File Path: I/ImgurApi/ImgurApi.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info("Imgur API", "MJSU", "1.0.2")]
    [Description("Allows plugins to upload images to imgur")]
    internal class ImgurApi : CovalencePlugin
    {
        #region Class Fields
        private PluginConfig _pluginConfig; //Plugin Config
        
        private const string ClientIdUrl = "https://api.imgur.com/oauth2/addclient";
        private const string UploadImageUrl = "https://api.imgur.com/3/upload";
        private const string DeleteImageUrl = "https://api.imgur.com/3/image/{0}";
        private const string CreateAlbumUrl = "https://api.imgur.com/3/album";
        private const string DeleteAlbumUrl = "https://api.imgur.com/3/album/{0}";
        private const string AlbumLink = "https://imgur.com/a/{0}";

        private GameObject _go;
        private ImgurBehavior _behavior;
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            return config;
        }

        private void OnServerInitialized()
        {
            _go = new GameObject();
            _behavior = _go.AddComponent<ImgurBehavior>();
        }

        private void Unload()
        {
            _behavior.StopAllCoroutines();
            GameObject.Destroy(_go);
        }
        #endregion

        #region API
        private void UploadImage(byte[] image, Action<Hash<string, object>> callback, string title = null, string description = null)
        {
            if (_pluginConfig.ClientId == ClientIdUrl)
            {
                PrintError($"Please set your Imgur Client Id in the config!");
                return;
            }
            
            _behavior.StartCoroutine(HandleUploadImage(image, response =>
            {
                callback(response.ToHash());
            }, title, description));
        }

        private void DeleteSingleImage(string deleteHash, Action<Hash<string, object>> callback)
        {
            if (_pluginConfig.ClientId == ClientIdUrl)
            {
                PrintError($"Please set your Imgur Client Id in the config!");
                return;
            }
            
            _behavior.StartCoroutine(HandleDeleteSingleImage(deleteHash, callback));
        }

        private void UploadAlbum(List<Hash<string, object>> images, Action<Hash<string, Hash<string, object>>> callback, string title = null, string description = null)
        {
            if (_pluginConfig.ClientId == ClientIdUrl)
            {
                PrintError($"Please set your Imgur Client Id in the config!");
                return;
            }
            
            _behavior.StartCoroutine(HandleUploadAlbum(images, callback, title, description));
        }
        
        private void DeleteAlbum(string deleteHash, Action<Hash<string, object>> callback)
        {
            if (_pluginConfig.ClientId == ClientIdUrl)
            {
                PrintError($"Please set your Imgur Client Id in the config!");
                return;
            }
            
            _behavior.StartCoroutine(HandleDeleteAlbum(deleteHash, callback));
        }
        #endregion

        #region Handlers
        private IEnumerator HandleUploadImage(byte[] image, Action<ApiResponse<UploadResponse>> callback, string title, string description)
        {
            List<IMultipartFormSection> data = new List<IMultipartFormSection>
            {
                new MultipartFormDataSection("image", Convert.ToBase64String(image)),
                new MultipartFormDataSection("type", "base64")
            };
            
            if (!string.IsNullOrEmpty(title))
            {
                data.Add(new MultipartFormDataSection("title", title));
            }

            if (!string.IsNullOrEmpty(description))
            {
                data.Add(new MultipartFormDataSection("description", description));
            }

            yield return HandleImgurRequest(UploadImageUrl, data, callback);
        }
        
        private IEnumerator HandleDeleteSingleImage(string deleteHash, Action<Hash<string, object>> callback)
        {
            yield return HandleImgurRequest<bool>(string.Format(DeleteImageUrl, deleteHash), new List<IMultipartFormSection>(), response =>
            {
                callback(response.ToHash());
            });
        }
        
        private IEnumerator HandleUploadAlbum(List<Hash<string, object>> images, Action<Hash<string, Hash<string, object>>> callback, string title = null, string description = null)
        {
            List<ApiResponse<UploadResponse>> albumImages = new List<ApiResponse<UploadResponse>>();

            foreach (Hash<string, object> uploadData in images)
            {
                byte[] image = uploadData["Image"] as byte[];
                string imageTitle = uploadData["Title"] as string;
                string imageDescription = uploadData["Description"] as string;
                
                yield return HandleUploadImage(image, img =>
                {
                    albumImages.Add(img);
                }, imageTitle, imageDescription);
                
                yield return new WaitForSeconds(1);
            }

            List<IMultipartFormSection> data = albumImages
                .Where(a => a.Success)
                .Select(response => new MultipartFormDataSection("deletehashes[]", response.Data.DeleteHash))
                .Cast<IMultipartFormSection>()
                .ToList();
            
            if (!string.IsNullOrEmpty(title))
            {
                data.Add(new MultipartFormDataSection("title", title));
            }

            if (!string.IsNullOrEmpty(description))
            {
                data.Add(new MultipartFormDataSection("description", description));
            }

            data.Add(new MultipartFormDataSection("type", "base64"));

            yield return HandleImgurRequest<AlbumResponse>(CreateAlbumUrl, data, response =>
            {
                Hash<string, Hash<string, object>> album = new Hash<string, Hash<string, object>>
                {
                    ["Album"] = response.ToHash()
                };

                for (int index = 0; index < albumImages.Count; index++)
                {
                    ApiResponse<UploadResponse> image = albumImages[index];
                    album[$"Image{index}"] = image.ToHash();
                }

                callback(album);
            });
        }
        
        private IEnumerator HandleDeleteAlbum(string deleteHash, Action<Hash<string, object>> callback)
        {
            yield return HandleImgurRequest<bool>(string.Format(DeleteAlbumUrl, deleteHash), new List<IMultipartFormSection>(), response =>
            {
                callback(response.ToHash());
            });
        }
        #endregion

        #region Send Methods
        private IEnumerator HandleImgurRequest<T>(string url, List<IMultipartFormSection> data, Action<ApiResponse<T>> action) 
        {
            UnityWebRequest www = UnityWebRequest.Post(url, data);
            www.SetRequestHeader("Authorization", $"Client-ID {_pluginConfig.ClientId}");
            yield return www.SendWebRequest();

            ApiResponse<T> response;
            if (www.isNetworkError || www.isHttpError)
            {
                response = new ApiResponse<T>
                {
                    Success = false,
                    Status = (int) www.responseCode,
                    Errors = new[] {new ErrorMessage {Detail = www.error}}
                };
            }
            else
            {
                response = JsonConvert.DeserializeObject<ApiResponse<T>>(www.downloadHandler.text);
            }

            action(response);
        }
        #endregion

        #region Behavior
        private class ImgurBehavior : MonoBehaviour
        {
            
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(ClientIdUrl)]
            [JsonProperty(PropertyName = "Imgur Client ID")]
            public string ClientId { get; set; }
        }

        private class ApiResponse<T>
        {
            [JsonProperty(PropertyName = "status")]
            public int Status { get; set; }
            
            [JsonProperty(PropertyName = "success")]
            public bool Success { get; set; }
            
            [JsonProperty(PropertyName = "data")]
            public T Data { get; set; }
            
            [JsonProperty(PropertyName = "errors")]
            public ErrorMessage[] Errors { get; set; }

            public Hash<string, object> ToHash()
            {
                object data;
                BaseDataResponse response = Data as BaseDataResponse;
                if (response != null)
                {
                    data = response.ToHash();
                }
                else
                {
                    data = Data;
                }
                
                return new Hash<string, object>
                {
                    [nameof(Status)] = Status,
                    [nameof(Success)] = Success,
                    [nameof(Data)] = data,
                    [nameof(Errors)] = Errors?.Select(e => e.ToHash()).ToList()
                };
            }
        }

        private class ErrorMessage
        {
            [JsonProperty(PropertyName = "id")]
            public string Id { get; set; }
            
            [JsonProperty(PropertyName = "code")]
            public string Code { get; set; }
            
            [JsonProperty(PropertyName = "status")]
            public string Status { get; set; }
            
            [JsonProperty(PropertyName = "detail")]
            public string Detail { get; set; }

            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Id)] = Id,
                    [nameof(Code)] = Code,
                    [nameof(Status)] = Status,
                    [nameof(Detail)] = Detail
                };
            }
        }

        private abstract class BaseDataResponse
        {
            public abstract Hash<string, object> ToHash();
        }

        private class UploadResponse : BaseDataResponse
        {
            [JsonProperty(PropertyName = "id")]
            public string Id { get; set; }
            
            [JsonProperty(PropertyName = "deletehash")]
            public string DeleteHash { get; set; }
            
            [JsonProperty(PropertyName = "link")]
            public string Link { get; set; }

            public override Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Id)] = Id,
                    [nameof(DeleteHash)] = DeleteHash,
                    [nameof(Link)] = Link
                };
            }
        }
        
        private class AlbumResponse : BaseDataResponse
        {
            [JsonProperty(PropertyName = "id")]
            public string Id { get; set; }
            
            [JsonProperty(PropertyName = "deletehash")]
            public string DeleteHash { get; set; }

            public string Link => string.Format(AlbumLink, Id);

            public override Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Id)] = Id,
                    [nameof(DeleteHash)] = DeleteHash,
                    [nameof(Link)] = Link
                };
            }
        }
        #endregion
    }
}


// --- End of file: ImgurApi.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/inv-foundation ---
// --- Original File Path: I/InvFoundation/InvFoundation.cs ---

﻿using System;
using Rust;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("InvFoundation", "sami37", "1.2.6", ResourceId = 2096)]
    [Description("Invulnerable foundation")]
    public class InvFoundation : RustPlugin
    {
        #region Building Owners Support
        [PluginReference("BuildingOwners")]
        Plugin BuildingOwners;
        #endregion

        #region Entity Owners Support
        [PluginReference("EntityOwner")]
        Plugin EntityOwner;
        #endregion

        private Dictionary<string, object> damageList => GetConfig("DamageList", defaultDamageScale());
        private Dictionary<string, object> damageGradeScaling => GetConfig("TierScalingDamage", defaultDamageTierScaling());
        private bool UseEntityOwner => GetConfig("UseEntityOwner", false);
        private bool UseBuildOwners => GetConfig("UseBuildingOwner", false);
        private bool UseDamageScaling => GetConfig("UseDamageScaling", false);
        private bool ExcludeCave => GetConfig("Exclude cave", false);
        private bool allowdecay => GetConfig("Allow Decay", true);
        private static readonly int colisionentity = LayerMask.GetMask("Construction");
        private readonly int cupboardMask = LayerMask.GetMask("Trigger");
        private readonly int groundLayer = LayerMask.GetMask("Terrain", "World");

        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

		static Dictionary<string,object> defaultDamageScale()
		{
		    var dp = new Dictionary<string, object>
		    {
		        {"Bullet", 0.0},
		        {"Blunt", 0.0},
		        {"Stab", 0.0},
		        {"Slash", 0.0},
		        {"Explosion", 0.0}
		    };

		    return dp;
		}

        static Dictionary<string, object> defaultDamageTierScaling()
        {
            var dp = new Dictionary<string, object>();
            dp.Add("Twigs", 0.0);
            dp.Add("Wood", 0.0);
            dp.Add("Stone", 0.0);
            dp.Add("Metal", 0.0);
            dp.Add("TopTier", 0.0);
            return dp;
        }


        void Loaded()
        {
            Config["UseBuildingOwner"] = UseBuildOwners;
            Config["UseEntityOwner"] = UseEntityOwner;
            Config["UseDamageScaling"] = UseDamageScaling;
            Config["Exclude cave"] = ExcludeCave;
            Config["DamageList"] = damageList;
            Config["TierScalingDamage"] = damageGradeScaling;
            Config["Allow Decay"] = allowdecay;
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new config file...");
            SaveConfig();
        }

        private void OnServerInitialized()
        {
            Config["UseBuildingOwner"] = UseBuildOwners;
            Config["UseEntityOwner"] = UseEntityOwner;
            Config["UseDamageScaling"] = UseDamageScaling;
            Config["Exclude cave"] = ExcludeCave;
            Config["DamageList"] = damageList;
            Config["TierScalingDamage"] = damageGradeScaling;
            Config["Allow Decay"] = allowdecay;
            SaveConfig();
            var messages = new Dictionary<string, string>
            {
				{"NoPerm", "You don't have permission to do this."}
            };
            lang.RegisterMessages(messages, this);
        }
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null)
                return;

            var buildingBlock = entity as BuildingBlock;
            if (buildingBlock != null)
            {
                if(!allowdecay)
                    if (hitInfo.damageTypes.Has(DamageType.Decay))
                    {
                        hitInfo.damageTypes = new DamageTypeList();
                        hitInfo.DoHitEffects = false;
                        hitInfo.HitMaterial = 0;
                        return;
                    }
                else
                    if(hitInfo.damageTypes.Has(DamageType.Decay)) return;

                BuildingBlock block = buildingBlock;
                BasePlayer attacker = hitInfo.Initiator?.ToPlayer();
                if (attacker == null) return;

                object modifier;
                if (block.LookupPrefab().name.ToLower().Contains("foundation") && !CupboardPrivlidge(attacker, block.transform.position))
                {
                    if (IsOwner(attacker, block))
                        return;
                    RaycastHit hit;
                    if (ExcludeCave && Physics.SphereCast(block.transform.position, .1f, Vector3.down, out hit, 250, groundLayer) && hit.collider.name.Contains("cave_")) return;
                    if (!UseDamageScaling)
                    {
                        hitInfo.damageTypes = new DamageTypeList();
                        hitInfo.DoHitEffects = false;
                        hitInfo.HitMaterial = 0;
                        SendReply(attacker, lang.GetMessage("NoPerm", this, attacker.UserIDString));
                        return;
                    }
                    DamageType type = hitInfo.damageTypes.GetMajorityDamageType();
                    if (damageList.TryGetValue(type.ToString(), out modifier))
                    {
                        float mod = Convert.ToSingle(modifier);
                        if (mod > 0.0f)
                        {
                            hitInfo.damageTypes.Scale(type, mod);
                            damageGradeScaling.TryGetValue(block.grade.ToString(), out modifier);
                            mod = Convert.ToSingle(modifier);
                            if (Math.Abs(mod) > 0)
                            {
                                hitInfo.damageTypes.Scale(type, mod);
                                return;
                            }
                            hitInfo.damageTypes = new DamageTypeList();
                            hitInfo.DoHitEffects = false;
                            hitInfo.HitMaterial = 0;
                            SendReply(attacker, lang.GetMessage("NoPerm", this, attacker.UserIDString));
                        }
                        else
                        {
                            hitInfo.damageTypes = new DamageTypeList();
                            hitInfo.DoHitEffects = false;
                            hitInfo.HitMaterial = 0;
                            SendReply(attacker, lang.GetMessage("NoPerm", this, attacker.UserIDString));
                        }
                    }
                }
                else if(block.LookupPrefab().name.ToLower().Contains("foundation") && CupboardPrivlidge(attacker, block.transform.position))
                {
                    if (IsOwner(attacker, block))
                        return;
                    if (!UseDamageScaling)
                    {
                        hitInfo.damageTypes = new DamageTypeList();
                        hitInfo.DoHitEffects = false;
                        hitInfo.HitMaterial = 0;
                        SendReply(attacker, lang.GetMessage("NoPerm", this, attacker.UserIDString));
                        return;
                    }
                    DamageType type = hitInfo.damageTypes.GetMajorityDamageType();
                    if (damageList.TryGetValue(type.ToString(), out modifier))
                    {
                        var mod = Convert.ToSingle(modifier);
                        if (Math.Abs(mod) > 0)
                        {
                            hitInfo.damageTypes.Scale(type, mod);
                            damageGradeScaling.TryGetValue(block.grade.ToString(), out modifier);
                            mod = Convert.ToSingle(modifier);
                            if (Math.Abs(mod) > 0)
                            {
                                hitInfo.damageTypes.Scale(type, mod);
                                return;
                            }
                            hitInfo.damageTypes = new DamageTypeList();
                            hitInfo.DoHitEffects = false;
                            hitInfo.HitMaterial = 0;
                            SendReply(attacker, lang.GetMessage("NoPerm", this, attacker.UserIDString));
                        }
                        else
                        {
                            hitInfo.damageTypes = new DamageTypeList();
                            hitInfo.DoHitEffects = false;
                            hitInfo.HitMaterial = 0;
                            SendReply(attacker, lang.GetMessage("NoPerm", this, attacker.UserIDString));
                        }
                    }
                }
            }
        }

        bool IsOwner(BasePlayer player, BaseEntity targetEntity)
        {
            if (targetEntity == null) return false;
            BuildingBlock block = targetEntity.GetComponent<BuildingBlock>();
            if (block == null)
            {
                RaycastHit supportHit;
                if (Physics.Raycast(targetEntity.transform.position + new Vector3(0f, 0.1f, 0f), new Vector3(0f, -1f, 0f), out supportHit, 3f, colisionentity))
                {
                    BaseEntity supportEnt = supportHit.GetEntity();
                    if (supportEnt != null)
                    {
                        block = supportEnt.GetComponent<BuildingBlock>();
                    }
                }
            }
            if (block != null)
            {
				if (UseBuildOwners)
				{
					if (BuildingOwners != null && BuildingOwners.IsLoaded)
					{
                        var returnhook = Interface.GetMod().CallHook("FindBlockData", new object[] {block});
                        if (returnhook is string)
                        {
                            string ownerid = (string) returnhook;
                            if (player.UserIDString == ownerid) return true;
                        }
                    }
                }
				if (UseEntityOwner)
				{
					if (EntityOwner != null && EntityOwner.IsLoaded)
					{
                        var returnhook = Interface.GetMod().CallHook("FindEntityData", new object[] {targetEntity});
                        if (returnhook is string)
                        {
                            string ownerid = (string) returnhook;
                            if (player.UserIDString == ownerid) return true;
                        }
                    }
                }
            }
            return false;
        }

        private bool CupboardPrivlidge(BasePlayer player, Vector3 position)
        {
            var hits = Physics.OverlapSphere(position, 2f, cupboardMask);
            foreach (var collider in hits)
            {
                var buildingPrivlidge = collider.GetComponentInParent<BuildingPrivlidge>();
                if (buildingPrivlidge == null) continue;

                List<string> ids = (from id in buildingPrivlidge.authorizedPlayers select id.userid.ToString()).ToList();
                foreach (string priv in ids)
                {
                    if (priv == player.UserIDString)
                    {
                        return true;
                    }
                }        
            }
            return false;
        }

    }
}

// --- End of file: InvFoundation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-history ---
// --- Original File Path: I/ItemHistory/ItemHistory.cs ---

﻿using System;
using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Item History", "birthdates", "1.2.1")]
    [Description("Keep history of an item")]
    public class ItemHistory : RustPlugin
    {
        #region Variables
        private const string Permission = "ItemHistory.use";
        #endregion

        #region Hooks
        private void Init() => permission.RegisterPermission(Permission, this);

        private void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (item == null || _config.Blacklist?.Contains(item.info.shortname) == true) return;
            var player = item.GetOwnerPlayer() ?? container.GetOwnerPlayer();
            if (player == null || !permission.UserHasPermission(player.UserIDString, Permission) || string.IsNullOrEmpty(item.info.displayName.english) || player.inventory.FindContainer(container.uid) == null) return;
            item.name = player.displayName + "'" + (player.displayName.EndsWith("s", StringComparison.InvariantCultureIgnoreCase) ? "" : "s") + " " + item.info.displayName.english;
        }

        private ConfigFile _config;

        public class ConfigFile
        {
            [JsonProperty("Blacklisted Items (Won't get any history)")]
            public List<string> Blacklist { get; set; }
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    Blacklist = new List<string>
                    {
                        "shotgun.spas12"
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}

// --- End of file: ItemHistory.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-experiment ---
// --- Original File Path: I/InstantExperiment/InstantExperiment.cs ---

﻿using System.ComponentModel;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Instant Experiment", "MJSU", "1.0.2")]
    [Description("Allows players to instantly experiment")]
    internal class InstantExperiment : RustPlugin
    {
        #region Class Fields
        private PluginConfig _pluginConfig; //Plugin Config

        private const string UsePermission = "instantexperiment.use";
        #endregion

        #region Setup & Loading
        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = Config.ReadObject<PluginConfig>();
            Config.WriteObject(_pluginConfig);
        }
        #endregion

        #region Oxide Hook
        private void OnExperimentStarted(Workbench workbench, BasePlayer player)
        {
            if (!HasPermission(player, UsePermission))
            {
                return;
            }
            
            workbench.CancelInvoke(workbench.ExperimentComplete);
            workbench.Invoke(workbench.ExperimentComplete, _pluginConfig.ExperimentTime);
            workbench.SendNetworkUpdate();
        }
        #endregion

        #region Helper Methods
        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(0f)]
            [JsonProperty(PropertyName = "Experiment Time (Seconds)")]
            public float ExperimentTime { get; set; }
        }
        #endregion
    }
}


// --- End of file: InstantExperiment.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-gather ---
// --- Original File Path: I/InstantGather/InstantGather.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Instant Gather", "supreme", "1.0.9")]
    [Description("Enhances the tools used for mining in order to gather instantly")]
    public class InstantGather : RustPlugin
    {
        #region Class Fields

        private Configuration _pluginConfig;
        private const string UsePermission = "instantgather.use";
        private const string SalvagedAxeShortname = "axe.salvaged";
        private const string ChainsawShortname = "chainsaw";
        private const string JackhammerShortname = "jackhammer";

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
        }
        
        private void OnMeleeAttack(BasePlayer player, HitInfo hitInfo)
        {
            if (!permission.UserHasPermission(player.UserIDString, UsePermission) || !hitInfo.HitEntity)
            {
                return;
            }

            Item activeItem = player.GetActiveItem();
            if (activeItem == null)
            {
                return;
            }

            if (!_pluginConfig.Tools.Contains(activeItem.info.shortname))
            {
                return;
            }

            BaseEntity entity = hitInfo.HitEntity;
            if (!entity)
            {
                return;
            }
            
            OreResourceEntity ore = entity as OreResourceEntity;
            if (ore)
            {
                MineOre(ore, player, hitInfo, activeItem);
                return;
            }
    
            TreeEntity tree = entity as TreeEntity;
            if (tree)
            {
                ChopTree(tree, player, hitInfo, activeItem);
            }
        }

        #endregion

        #region Core Methods

        private void ChopTree(TreeEntity tree, BasePlayer player, HitInfo hitInfo, Item activeItem)
        {
            BaseMelee baseMelee = player.GetHeldEntity() as BaseMelee;
            if (!baseMelee)
            {
                return;
            }

            hitInfo.gatherScale = 100f;
            if (activeItem.info.shortname != SalvagedAxeShortname && activeItem.info.shortname != ChainsawShortname)
            {
                tree.resourceDispenser.finishBonus[0].amount += 3;
                tree.resourceDispenser.AssignFinishBonus(player, 1f - baseMelee.GetGatherInfoFromIndex(tree.resourceDispenser.gatherType).destroyFraction, hitInfo.Weapon);
            }

            NextFrame(() =>
            {
                if (!tree)
                {
                    return;
                }
                
                tree.OnKilled(hitInfo);
            });
        }

        private void MineOre(OreResourceEntity ore, BasePlayer player, HitInfo hitInfo, Item activeItem)
        {
            BaseMelee baseMelee = player.GetHeldEntity() as BaseMelee;
            if (!baseMelee)
            {
                return;
            }
            
            hitInfo.gatherScale = 100f;
            if (activeItem.info.shortname == JackhammerShortname)
            {
                for (int i = 0; i < 37; i++)
                {
                    ore.OnAttacked(hitInfo);
                }
            }

            NextFrame(() =>
            {
                if (!ore)
                {
                    return;
                }
                
                ore.resourceDispenser.finishBonus[0].amount += 6;
                ore.resourceDispenser.AssignFinishBonus(player, 1f - baseMelee.GetGatherInfoFromIndex(ore.resourceDispenser.gatherType).destroyFraction, hitInfo.Weapon);
                ore.OnKilled(hitInfo);
            });
        }

        #endregion

        #region Configuration

        private class Configuration
        {
            [JsonProperty(PropertyName = "Tools")]
            public List<string> Tools { get; set; }
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new Exception();
                }
                
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_pluginConfig);

        protected override void LoadDefaultConfig()
        {
            _pluginConfig = new Configuration
            {
                Tools = new List<string>
                {
                    "pickaxe",
                    "jackhammer",
                    "rock",
                    "hammer.salvaged",
                    "icepick.salvaged",
                    "stone.pickaxe",
                    "axe.salvaged",
                    "boneclub",
                    "hatchet",
                    "stonehatchet",
                    "chainsaw"
                }
            };
        }

        #endregion
    }
}

// --- End of file: InstantGather.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/inventory-cleaner ---
// --- Original File Path: I/InventoryCleaner_wLgAO/InventoryCleaner_wLgAO.cs ---

﻿using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Inventory Cleaner", "Iv Misticos", "2.0.0")]
    [Description("This plugin allows players with permission to clean inventories.")]
    class InventoryCleaner : CovalencePlugin
    {
        #region Variables

        private const string PermissionSelf = "inventorycleaner.self";
        private const string PermissionTarget = "inventorycleaner.target";
        private const string PermissionAll = "inventorycleaner.all";

        private const string CommandName = "inventorycleaner.clean";

        #endregion
        
        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "No Permission", "You don't have enough permissions (inventorycleaner.*)." },
                { "Syntax", "Command Syntax:\n" +
                            "self - Clean your own inventory\n" +
                            "all - Clean all players' inventories\n" +
                            "(name or ID) - Clean specific player's inventory" },
                { "Players Only", "This command is available only for players." },
                { "Cleaned", "This inventory was successfully cleaned." },
                { "Not Found", "This player was not found." }
            }, this);
        }

        private void Init()
        {
            permission.RegisterPermission(PermissionAll, this);
            permission.RegisterPermission(PermissionSelf, this);
            permission.RegisterPermission(PermissionTarget, this);
            
            AddCovalenceCommand(CommandName, nameof(CommandUse));
        }

        #endregion

        #region Commands

        private void CommandUse(IPlayer player, string command, string[] args)
        {
            if (args == null || args.Length == 0)
            {
                goto syntax;
            }

            switch (args[0].ToLower())
            {
                case "self":
                {
                    if (!player.HasPermission(PermissionSelf))
                        goto noPermissions;

                    if (!(player.Object is BasePlayer))
                    {
                        player.Reply(GetMsg("Players Only", player.Id));
                        return;
                    }
                    
                    ((BasePlayer) player.Object).inventory.Strip();
                    goto cleaned;
                }

                case "all":
                {
                    if (!player.HasPermission(PermissionAll))
                        goto noPermissions;

                    foreach (var user in players.Connected)
                    {
                        (user.Object as BasePlayer)?.inventory.Strip();
                    }
                    
                    goto cleaned;
                }

                default:
                {
                    if (!player.HasPermission(PermissionTarget))
                        goto noPermissions;
                    
                    var users = players.FindPlayers(args[0]);
                    using (var enumerator = users.GetEnumerator())
                    {
                        var firstDone = false;
                        while (enumerator.MoveNext())
                        {
                            if (!(enumerator.Current?.Object is BasePlayer))
                                continue;
                            
                            firstDone = true;
                            ((BasePlayer) enumerator.Current.Object).inventory.Strip();
                        }

                        if (!firstDone)
                        {
                            player.Reply(GetMsg("Not Found", player.Id));
                            return;
                        }
                    }

                    goto cleaned;
                }
            }
            
            syntax:
            player.Reply(GetMsg("Syntax", player.Id));
            return;
            
            cleaned:
            player.Reply(GetMsg("Cleaned", player.Id));
            return;
            
            noPermissions:
            player.Reply(GetMsg("No Permission", player.Id));
        }

        #endregion
        
        #region Helpers

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion
    }
}

// --- End of file: InventoryCleaner_wLgAO.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-buy ---
// --- Original File Path: I/InstantBuy/InstantBuy.cs ---

﻿
namespace Oxide.Plugins
{
    [Info("Instant Buy", "Jake_Rich/collect_vood/Bushhy", "1.0.3")]
    [Description("Vending Machine has no delay")]

    public class InstantBuy : CovalencePlugin
    {
        #region Constants

        private const string permUse = "instantbuy.use";

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }

        private object OnBuyVendingItem(VendingMachine machine, BasePlayer player, int sellOrderID, int amount)
        {
            if (machine == null || player == null) return null;

            if (!permission.UserHasPermission(player.UserIDString, permUse)) return null;
			
			if (player.inventory.containerMain.IsFull() && player.inventory.containerBelt.IsFull()) return null;

            machine.ClientRPC<int>(null, "CLIENT_StartVendingSounds", sellOrderID);
            machine.DoTransaction(player, sellOrderID, amount);
            return false;
        }

        #endregion
    }
}

// --- End of file: InstantBuy.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-repair ---
// --- Original File Path: I/ItemRepair/ItemRepair.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Item Repair", "birthdates", "1.1.0")]
    [Description("Repair your active item to full health")]
    public class ItemRepair : RustPlugin
    {
        private const string UsePermission = "itemrepair.use";

        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
        }

        [ChatCommand("repair")]
        private void ChatCommand(BasePlayer player)
        {
            if (!player.IPlayer.HasPermission(UsePermission))
            {
                player.ChatMessage(lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }
            var item = player.GetActiveItem();
            if (item == null)
            {
                player.ChatMessage(lang.GetMessage("NoActiveItem", this, player.UserIDString));
                return;
            }

            if (_config.Blacklist.Contains(item.info.shortname))
            {
                player.ChatMessage(lang.GetMessage("BlacklistedItem", this, player.UserIDString));
                return;
            }
            
            item.condition = player.GetActiveItem().maxCondition;
            player.ChatMessage(lang.GetMessage("Repaired", this, player.UserIDString));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoPermission", "You don't have permission to execute this command."},
                {"NoActiveItem", "You don't have an item in your hand."},
                {"Repaired", "You have repaired your active item."},
                {"BlacklistedItem", "You cannot repair this item!"}
            }, this);
        }
        
        private ConfigFile _config;

        public class ConfigFile
        {
            [JsonProperty("Blacklisted Items (shortnames)")] public IList<string> Blacklist;
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    Blacklist = new List<string> {"rock"}
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
    }
}

// --- End of file: ItemRepair.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/infinite-tool ---
// --- Original File Path: I/InfiniteTool/InfiniteTool.cs ---

namespace Oxide.Plugins
{
    [Info("Infinite Tool", "birthdates", "2.0.1")]
    [Description("Allows player with permission to obtain unlimited ammo / durability")]
    public class InfiniteTool : RustPlugin
    {
        #region Variables
        private readonly string permission_durability = "infinitetool.durability";
        private readonly string permission_explosives = "infinitetool.explosives";
        private readonly string permission_rockets = "infinitetool.rockets";
        private readonly string permission_ammo = "infinitetool.ammo";
        #endregion

        #region Hooks
        private void Init()
        {
            LoadConfig();
            permission.RegisterPermission(permission_durability, this);
            permission.RegisterPermission(permission_explosives, this);
            permission.RegisterPermission(permission_rockets, this);
            permission.RegisterPermission(permission_ammo, this);
        }
        #endregion

        void OnWeaponFired(BaseProjectile projectile, BasePlayer player)
        {
            if(!player.IPlayer.HasPermission(permission_ammo)) return;
            if(projectile.primaryMagazine.contents != 1) return;
            projectile.primaryMagazine.contents = projectile.primaryMagazine.capacity;
            projectile.SendNetworkUpdateImmediate();
        }

        void OnExplosiveThrown(BasePlayer player)
        {
            if(!player.IPlayer.HasPermission(permission_explosives)) return;
            if(player.GetActiveItem()?.info.shortname.Contains("signal") == true) return;
            var weapon = player.GetActiveItem().GetHeldEntity() as ThrownWeapon;
            if(weapon == null) return;
            weapon.GetItem().amount += 1;
        }

        void OnLoseCondition(Item item, ref float amount)
        {
            if(item?.GetOwnerPlayer()?.IPlayer?.HasPermission(permission_durability) == true) amount = 0f;
        }

        void OnRocketLaunched(BasePlayer player)
        {
            if(!player.IPlayer.HasPermission(permission_rockets)) return;
            var weapon = player.GetActiveItem().GetHeldEntity() as BaseProjectile;
            if(weapon == null) return;
            weapon.primaryMagazine.contents = weapon.primaryMagazine.capacity;
            weapon.SendNetworkUpdateImmediate();
        }
    }
}
//Generated with birthdates' Plugin Maker


// --- End of file: InfiniteTool.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/infinite-vending-stock ---
// --- Original File Path: I/InfiniteVendingStock/InfiniteVendingStock.cs ---

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using static NPCVendingMachine;

namespace Oxide.Plugins
{
    [Info("Infinite Vending Stock", "Rustic", "1.0.2")]
    [Description("A very simple plugin unblocking buy amount limit and giving unlimited stock to all NPC Vending Machines")]

    public class InfiniteVendingStock : CovalencePlugin
    {

        private void OnServerInitialized()
        {
            server.Command("o.reload InfiniteVendingStock");
            
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var vendingMachine = entity as NPCVendingMachine;
                if (vendingMachine == null)
                    continue;

                RestockItems(vendingMachine);
            }
        }

        private void OnVendingTransaction(NPCVendingMachine vendingMachine)
        {
            NextTick(() =>
            {
                if (vendingMachine != null && !vendingMachine.IsDestroyed)
                {
                    RestockItems(vendingMachine);
                }
            });
        }

        private void RestockItems(NPCVendingMachine vendingMachine)
        {
            foreach (var item in vendingMachine.inventory.itemList)
            {
                if (item.amount != 1000000)
                {
                    item.amount = 1000000;
                    item.MarkDirty();
                }
            }
        }

    }
}

// --- End of file: InfiniteVendingStock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-smelt ---
// --- Original File Path: I/InstantSmelt/InstantSmelt.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Instant Smelt", "Orange", "2.0.5")]
    [Description("Smelt resources as soon as they are mined")]
    public class InstantSmelt : RustPlugin
    {
        #region Vars

        private const string permUse = "instantsmelt.use";
        private const string charcoalItemName = "charcoal";
        private const string woodItemName = "wood";

        #endregion
        
        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            cmd.AddChatCommand(config.command, this, nameof(cmdToggleChat));
            LoadData();
        }

        private void Unload()
        {
            SaveData();
        }

        private object OnCollectiblePickup(Item item, BasePlayer player)
        {
            return OnGather(player, item, false, true);
        }
        
        private object OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            return OnGather(player, item);
        }
        
        private object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            return OnGather(player, item, true);
        }

        #endregion

        #region Commands

        private void cmdToggleChat(BasePlayer player)
        {
            if (HasPermission(player) == false)
            {
                Message(player, "Permission");
                return;
            }

            var key = string.Empty;
            
            if (data.Contains(player.userID))
            {
                key = "Enabled";
                data.Remove(player.userID);
            }
            else
            {
                key = "Disabled";
                data.Add(player.userID);
            }
            
            Message(player, key);
        }

        #endregion

        #region Core

        private object OnGather(BasePlayer player, Item item, bool bonus = false, bool pickup = false)
        {
            var perm = HasPermission(player);
            if (perm == false)
            {
                return null;
            }

            if (data.Contains(player.userID))
            {
                return null;
            }

            var shortname = item.info.shortname;
            if (config.blackList.Contains(shortname))
            {
                return null;
            }

            var newItem = (Item) null;
            
            if (shortname == woodItemName)
            {
                newItem = ItemManager.CreateByName(charcoalItemName, item.amount);
            }
            else
            {
                var cookable = item.info.GetComponent<ItemModCookable>();
                if (cookable == null) {return null;}
                newItem = ItemManager.Create(cookable.becomeOnCooked, item.amount);
            }
            
            NextTick(() =>
            {
                newItem.amount = item.amount;
                item.GetHeldEntity()?.Kill();
                item.DoRemove();

                if (bonus == false)
                {
                    player.GiveItem(newItem, BaseEntity.GiveItemReason.ResourceHarvested);
                }
            });
                
            return pickup ? null : newItem;
        }

        private bool HasPermission(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, permUse);
        }

        #endregion
        
        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Command")]
            public string command;

            [JsonProperty(PropertyName = "A. Blacklist")]
            public List<string> blackList;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                command = "ismelt",
                blackList = new List<string>
                {
                    "shortname here",
                    "another shortname"
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
        
        #region Data 1.0.0

        private const string filename = "Temp/InstantSmelt/Playes";
        private List<ulong> data = new List<ulong>();

        private void LoadData()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<List<ulong>>(filename);
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }

            SaveData();
            timer.Every(Core.Random.Range(500, 700f), SaveData);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(filename, data);
        }

        #endregion
        
        #region Localization 1.1.1
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Permission", "You don't have permission to use that!"},
                {"Enabled", "You enabled instant smelt!"},
                {"Disabled", "You disabled instant smelt!"},
            }, this);
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.ChatMessage(message);
        }

        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        #endregion
    }
}

// --- End of file: InstantSmelt.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/items-blocker ---
// --- Original File Path: I/ItemsBlocker/ItemsBlocker.cs ---

//#define CHECK
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;
using System.Linq;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using System.Collections;
using Oxide.Core;
using System.IO;

namespace Oxide.Plugins
{
    [Info("ItemsBlocker", "Vlad-00003", "3.1.2", ResourceId = 2407)]
    [Description("Prevents some items from being used for a limited period of time.")]

    class ItemsBlocker : RustPlugin
    {
        #region Vars
        //private string Image = null;
        private Dictionary<string, string> Image =  new Dictionary<string, string>();
        private PluginConfig config;
        [PluginReference]
        Plugin Duel;
        private Dictionary<BasePlayer, Timer> Main = new Dictionary<BasePlayer, Timer>();
        private List<BasePlayer> OnScreen = new List<BasePlayer>();
        private Timer OnScreenUpdater;
        #endregion

        #region Config setup

        #region GUI Settings
        private class GUIPanel
        {
            [JsonProperty("Minimum anchor")]
            public string Amin;
            [JsonProperty("Maximum anchor")]
            public string Amax;
            [JsonProperty("Color")]
            public string Color;
        }
        private class GUIText : GUIPanel
        {
            [JsonProperty("Size")]
            public int Size;
            [JsonProperty("Outline")]
            public GUIOutline Outline;
        }
        private class GUIImage
        {
            [JsonProperty("Minimum anchor")]
            public string Amin;
            [JsonProperty("Maximum anchor")]
            public string Amax;
            [JsonProperty("Link to the image or file in the data folder")]
            public string Image;
            [JsonProperty("Opacity of the image")]
            public float Opacity;
        }
        private class GUIOutline
        {
            [JsonProperty("Use Outline")]
            public bool Use = true;
            [JsonProperty("Outline color")]
            public string Color = "0 0 0 1";
            [JsonProperty("Outline distance")]
            public string Distance = "1.0 -1.0";
        }
        #endregion

        private class GUISettings
        { 
            [JsonProperty("Backgound for main panel")]
            public GUIPanel Background = new GUIPanel()
            {
                Amin = null,
                Amax = null,
                Color = "0 0 0 0.8"
            };
            [JsonProperty("Main panel settings (shows if player attemts to use blocked cloth/item)")]
            public GUIPanel MainPanel = new GUIPanel()
            {
                Amin = "0.266 0.361",
                Amax = "0.734 0.639",
                Color = "#42e2f49f"
            };
            [JsonProperty("Settings for the text on main panel")]
            public GUIText TextOnMain = new GUIText()
            {
                Amin = "0 0",
                Amax = "1 1",
                Color = "#f4d041",
                Size = 20,
                Outline = new GUIOutline()
            };
            [JsonProperty("Use On Screen Panel")]
            public bool UseOnScreenPanel = true;
            [JsonProperty("On Screen Panel (shown if the block is active)")]
            public GUIPanel OnScreenPanel = new GUIPanel()
            {
                Amin = "0.016 0.028",
                Amax = "0.172 0.167",
                Color = "0 0 0 0.7"
            };
            [JsonProperty("Text settings for On Screen Panel")]
            public GUIText TextOnScreen = new GUIText()
            {
                Amin = "0 0",
                Amax = "0.66 1",
                Color = "green",
                Size = 13,
                Outline = new GUIOutline()
            };
            [JsonProperty("Image (shown on On Screen Panel")]
            public GUIImage Image = new GUIImage()
            {
                Amin = "0.67 0.25",
                Amax = "0.92 0.75",
                Opacity = 0.8f,
                Image = "http://www.rigormortis.be/wp-content/uploads/rust-icon-512.png"
            };
        }
        private class PluginConfig
        {
            [JsonProperty("Block end time")]
            public string BlockEndStr;
            [JsonProperty("Hour of block after wipe")]
            public int HoursOfBlock = 30;
            [JsonProperty("Chat prefix")]
            public string Prefix = "[Items Blocker]";
            [JsonProperty("Chat prefix color")]
            public string PrefixColor = "#f44253";
            [JsonProperty("Use chat insted of GUI")]
            public bool UseChat = false;
            [JsonProperty("Bypass permission")]
            public string BypassPermission = "itemsblocker.bypass";
            [JsonProperty("GUI Settings")]
            public GUISettings Gui = new GUISettings();
            [JsonProperty("List of blocked items")]
            public List<string> BlockedItems;
            [JsonProperty("List of blocked clothes")]
            public List<string> BlockedClothes;
            [JsonProperty("List of blocked ammunition")]
            public List<string> BlockedAmmo;

            [JsonIgnore]
            public DateTime BlockEnd;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    BlockEndStr = DateTime.Now.AddHours(30).ToString("dd.MM.yyyy HH:mm:ss"),
                    BlockedItems = new List<string>()
                    {
                        "Satchel Charge",
                        "Timed Explosive Charge",
                        "Eoka Pistol",
                        "Custom SMG",
                        "Assault Rifle",
                        "Bolt Action Rifle",
                        "Waterpipe Shotgun",
                        "Revolver",
                        "Thompson",
                        "Semi-Automatic Rifle",
                        "Semi-Automatic Pistol",
                        "Pump Shotgun",
                        "M249",
                        "Rocket Launcher",
                        "Flame Thrower",
                        "Double Barrel Shotgun",
                        "Beancan Grenade",
                        "F1 Grenade",
                        "MP5A4",
                        "LR-300 Assault Rifle",
                        "M92 Pistol",
                        "Python Revolver"
                    },
                    BlockedClothes = new List<string>()
                    {
                        "Metal Facemask",
                        "Metal Chest Plate",
                        "Road Sign Kilt",
                        "Road Sign Jacket",
                        "Heavy Plate Pants",
                        "Heavy Plate Jacket",
                        "Heavy Plate Helmet",
                        "Riot Helmet",
                        "Bucket Helmet",
                        "Coffee Can Helmet"
                    },
                    BlockedAmmo =  new List<string>()
                    {
                        "HV Pistol Ammo",
                        "Incendiary Pistol Bullet",
                        "HV 5.56 Rifle Ammo",
                        "Incendiary 5.56 Rifle Ammo",
                        "Explosive 5.56 Rifle Ammo",
                        "12 Gauge Slug",
                        "High Velocity Arrow",
                        "Incendiary Rocket",
                        "Rocket",
                        "High Velocity Rocket"
                    }
                };
            }
        }
        #endregion

        #region Config and Data Initialization
        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created, Block Start now and will remain for 30 hours. You can change it into the config.");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            DateTime BlockEnd;
            if (!DateTime.TryParseExact(config.BlockEndStr, "dd.MM.yyyy HH:mm:ss", CultureInfo.InvariantCulture, DateTimeStyles.None, out BlockEnd))
            {
                BlockEnd = SaveRestore.SaveCreatedTime.AddHours(config.HoursOfBlock);
                PrintWarning($"Unable to parse block end date format, block end set to {BlockEnd.ToString("dd.MM.yyyy HH:mm:ss")}");
                config.BlockEndStr = BlockEnd.ToString("dd.MM.yyyy HH:mm:ss");
                SaveConfig();
            }
            config.BlockEnd = BlockEnd;
            permission.RegisterPermission(config.BypassPermission, this);
            if(!string.IsNullOrEmpty(config.Gui.Image.Image))
                if (!config.Gui.Image.Image.ToLower().Contains("http"))
                {
                    config.Gui.Image.Image = "file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + config.Gui.Image.Image;
                }
            LoadData();
            permission.RegisterPermission("itemsblocker.refresh", this);
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        #endregion

        #region Data (Image save\load)
        private void LoadData()
        {
            try
            {
                Image = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, string>>(Title);
            }
            catch (Exception ex)
            {
                if(ex is JsonSerializationException)
                {
                    try
                    {
                        string old = Interface.Oxide.DataFileSystem.ReadObject<string>(Title);
                        Image[config.Gui.Image.Image] = old;
                        SaveData();
                        return;
                    }
                    catch(Exception ex1)
                    {
                        PrintWarning("Failed to convert old data fromat to the new. Data wiped.\n{0}", ex1.Message);
                        Image = new Dictionary<string, string>();
                        return;
                    }
                }
                PrintWarning("Failed to load datafile (is the file corrupt?)\n{0}", ex.Message);
                Image = new Dictionary<string, string>();
            }
        }
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Title, Image);
        }
        #endregion

        #region Initialization and quiting
        void OnServerInitialized()
        {
            if (!Image.ContainsKey(config.Gui.Image.Image))
                DownloadImage();
            else
                OnScreenPanel(true);
        }
        void Unload() => DestroyAllGui();
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ItemBlocked"] = "Using this item is blocked!",
                ["BlockTimeLeft"] = "\n{0}d {1:00}:{2:00}:{3:00} until unblock.",
                ["Weapon line 2"] = "\nYou can only use Hunting bow and Crossbow",
                ["Cloth line 2"] = "\nYou can only use wood and bone armor!",
                ["OnlyPlayer"] = "This command can be executed only from the game!",
                ["OnScreenText"] = "Some of the items are blocked!",
                ["Ammo blocked"] = "The ammo you are trying to use is blocked!"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ItemBlocked"] = "Использование данного предмета заблокировано!",
                ["BlockTimeLeft"] = "\nДо окончания блокировки осталось {0}д. {1:00}:{2:00}:{3:00}",
                ["Weapon line 2"] = "\nВы можете использовать только Лук и Арбалет",
                ["Cloth line 2"] = "\nИспользуйте только деревянную и костяную броню!",
                ["OnlyPlayer"] = "Эту команду можно использовать только в игре!",
                ["OnScreenText"] = "Некоторые предметы заблокированы!",
                ["Ammo blocked"] = "Вид боеприпасов, которые вы пытаетесь использовать заблокирован!"
            }, this, "ru");
        }
        string GetMsg(string key, BasePlayer player = null) => lang.GetMessage(key, this, player?.UserIDString);
        string GetMsg(string key) => lang.GetMessage(key, this);
        #endregion

        #region Oxide hooks
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (Main.ContainsKey(player))
                Main.Remove(player);
            if (OnScreen.Contains(player))
                OnScreen.Remove(player);
        }
        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!InBlock)
                return;
            if (!OnScreen.Contains(player))
                OnScreenPanelMain(player);
        }
        void OnNewSave(string filename)
        {
            config.BlockEnd = DateTime.Now.AddHours(config.HoursOfBlock);
            config.BlockEndStr = config.BlockEnd.ToString("dd.MM.yyyy HH:mm:ss", CultureInfo.InvariantCulture);
            SaveConfig();
            PrintWarning($"Wipe detected. Block end set to {config.BlockEndStr}");
        }
        object CanEquipItem(PlayerInventory inventory, Item item)
        {
            if (InBlock)
            {
                var player = inventory.GetComponent<BasePlayer>();
                if (InDuel(player) || IsNPC(player)) return null;
                if (permission.UserHasPermission(player.UserIDString, config.BypassPermission))
                    return null;
                if (config.BlockedItems.Contains(item.info.displayName.english) || config.BlockedItems.Contains(item.info.shortname))
                {
                    string reply = GetMsg("ItemBlocked", player);
                    reply += GetMsg("BlockTimeLeft", player);
                    reply += GetMsg("Weapon line 2", player);

                    if (config.UseChat)
                    {
                        SendToChat(player, reply);
                    }
                    else
                    {
                        BlockerUi(player, reply);
                    }
                    return false;
                }
            }
            return null;
        }
        object CanWearItem(PlayerInventory inventory, Item item)
        {
            if (InBlock)
            {
                var player = inventory.GetComponent<BasePlayer>();
                if (InDuel(player) || IsNPC(player)) return null;
                if (permission.UserHasPermission(player.UserIDString, config.BypassPermission))
                    return null;
                if (config.BlockedClothes.Contains(item.info.displayName.english) || config.BlockedClothes.Contains(item.info.shortname))
                {
                    string reply = GetMsg("ItemBlocked", player);
                    reply += GetMsg("BlockTimeLeft", player);
                    reply += GetMsg("Cloth line 2", player);
                    if (config.UseChat)
                    {
                        SendToChat(player, reply);
                    }
                    else
                    {
                        BlockerUi(player, reply);
                    }
                    return false;
                }
            }
            return null;
        }
        void OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
        {
            if (!InBlock) return;
            if (InDuel(player) || IsNPC(player)) return;
            if(IsAmmoBlocked(player, projectile))
            {
                SendToChat(player, GetMsg("Ammo blocked", player) + GetMsg("BlockTimeLeft", player));
            }
        }
        object OnReloadMagazine(BasePlayer player, BaseProjectile projectile)
        {
            if (InBlock)
            {
                if (InDuel(player) || IsNPC(player)) return null;
                var ammo = projectile.primaryMagazine.ammoType;
                if (IsAmmoBlocked(player, projectile))
                {
                    projectile.SendNetworkUpdateImmediate();
                    return false;
                }
            }
            return null;
        }
        #endregion

        #region Image
        [ConsoleCommand("ib.refresh")]
        private void CmdRefresh(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.player != null)
            {
                BasePlayer player = arg.Connection.player as BasePlayer;

                if (!permission.UserHasPermission(player.UserIDString, "itemsblocker.refresh"))
                    return;
            }
            DownloadImage();
        }
        private void DownloadImage()
        {
            PrintWarning("Downloading image...");
            ServerMgr.Instance.StartCoroutine(DownloadImage(config.Gui.Image.Image));
        }
        IEnumerator DownloadImage(string url)
        {
            using (var www = new WWW(url))
            {
                yield return www;
                if (this == null) yield break;
                if (www.error != null)
                {
                    PrintError($"Failed to add image. File address possibly invalide\n {url}");
                }
                else
                {
                    var reply = 0;
                    var tex = www.texture;
                    byte[] bytes = tex.EncodeToPNG();
                    Image[url] = FileStorage.server.Store(www.bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                    SaveData();
                    PrintWarning("Image download is complete.");
                    OnScreenPanel(true);
                    UnityEngine.Object.DestroyImmediate(tex);
                    yield break;
                }
            }
        }
        #endregion

        #region GUI

        #region PanelNames
        private string BlockerParent = "BlockerUI";
        private string BlockerPanel = "BlockerUIPanel";
        private string BlockerText = "BlockerUIText";
        private string OnScreenParent = "BlockerUIOnScreen";
        private string OnScreenText = "BlockerUIOnScreenText";
        #endregion

        #region GUI Creation
        private class UI
        {
            private static string ToRustColor(string input)
            {
                Color color;
                if (!ColorUtility.TryParseHtmlString(input, out color))
                {
                    var split = input.Split(' ');
                    for (var i = 0; i < 4; i++)
                    {
                        float num;
                        if (!float.TryParse(split[i], out num))
                        {
                            return null;
                        }
                        color[i] = num;
                    }
                }
                return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
            }

            #region Override to custom classes
            public static void CreatePanel(ref CuiElementContainer container, string Parent, string Name, GUIPanel panel, bool CursorEnabled = false) =>
                CreatePanel(ref container, Parent, Name, panel.Color, panel.Amin, panel.Amax, CursorEnabled);
            public static void CreateImage(ref CuiElementContainer container, string Parent, string Name, GUIImage Image, string Png) =>
                CreateImage(ref container, Parent, Name, Image.Opacity, Image.Amin, Image.Amax, Png);
            public static void CreateText(ref CuiElementContainer container, string Parent, string Name, GUIText TextComp, string Text, TextAnchor Anchor = TextAnchor.MiddleCenter) =>
                CreateText(ref container, Parent, Name, TextComp.Amin, TextComp.Amax, Text, TextComp.Color, TextComp.Size, TextComp.Outline, Anchor);
            #endregion
            public static void CreatePanel(ref CuiElementContainer container, string Parent, string Name, string Color, string Amin, string Amax, bool CursorEnabled = false)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = Amin, AnchorMax = Amax },
                    Image = { Color = ToRustColor(Color) },
                    CursorEnabled = CursorEnabled
                }, Parent, Name);
            }
            public static void CreateImage(ref CuiElementContainer container, string Parent, string Name, float opacity, string Amin, string Amax, string Image)
            {
                var ImageComp = new CuiRawImageComponent { Sprite = "assets/content/textures/generic/fulltransparent.tga", Color = $"1 1 1 {opacity}" };
                if (Image != null)
                {
                    ImageComp.Png = Image;
                }
                container.Add(new CuiElement
                {
                    Name = Name ?? CuiHelper.GetGuid(),
                    Parent = Parent,
                    Components = { ImageComp, new CuiRectTransformComponent { AnchorMin = Amin, AnchorMax = Amax } }
                });
            }
            public static void CreateFulscreenButton(ref CuiElementContainer container, string Parent, string Name, string Command)
            {
                container.Add(new CuiButton
                {
                    Button = { Command = Command, Color = "0 0 0 0"},
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1"},
                    Text = { Text = ""}
                }, Parent, Name);
            }
            public static void CreateText(ref CuiElementContainer container, string Parent, string Name, string Amin, string Amax, string Text, string TextColor, int FontSize, GUIOutline outline = null, TextAnchor Anchor = TextAnchor.MiddleCenter)
            {
                var Element = new CuiElement
                {
                    Parent = Parent,
                    Name = Name ?? CuiHelper.GetGuid(),
                    Components =
                    {
                        new CuiTextComponent { Color = ToRustColor(TextColor), FontSize = FontSize, Text = Text, Align = Anchor },
                        new CuiRectTransformComponent { AnchorMin = Amin, AnchorMax = Amax }
                    }
                };
                if (outline != null && outline.Use)
                {
                    Element.Components.Add(
                        new CuiOutlineComponent { Color = ToRustColor(outline.Color), Distance = outline.Distance });
                }
                container.Add(Element);
            }
        }
        #endregion

        #region Commands
        [ConsoleCommand("ib.close")]
        private void CmdCloseUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if(player == null)
            {
                arg.ReplyWith(GetMsg("OnlyPlayer"));
                return;
            }
            if (Main.ContainsKey(player))
            {
                Main[player]?.Destroy();
                Main.Remove(player);
                CuiHelper.DestroyUi(player, BlockerParent);
            }
        }
        #endregion

        private void DestroyAllGui()
        {
            OnScreenUpdater?.Destroy();
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, OnScreenParent);
                if (Main.ContainsKey(player))
                {
                    Main[player]?.Destroy();
                    Main.Remove(player);
                    CuiHelper.DestroyUi(player, BlockerParent);
                }
            }

        }

        private void OnScreenPanel(bool init = false)
        {
            if (!config.Gui.UseOnScreenPanel)
                return;
            if (init)
                foreach (var player in BasePlayer.activePlayerList)
                    OnScreenPanelMain(player);
            if (!InBlock)
            {
                DestroyAllGui();
                return;
            }
            foreach(var player in OnScreen)
            {
                CuiHelper.DestroyUi(player, OnScreenText);
                var container = new CuiElementContainer();
                string text = GetMsg("OnScreenText", player) + GetMsg("BlockTimeLeft", player);
                var timeleft = TimeLeft;
                text = string.Format(text, timeleft.Days, timeleft.Hours, timeleft.Minutes, timeleft.Seconds);
                UI.CreateText(ref container, OnScreenParent, OnScreenText, config.Gui.TextOnScreen, text);
                CuiHelper.AddUi(player, container);
            }
            OnScreenUpdater = timer.Once(1f, () => OnScreenPanel());
        }
        private void OnScreenPanelMain(BasePlayer player)
        {
            if (!config.Gui.UseOnScreenPanel)
                return;
            CuiHelper.DestroyUi(player, OnScreenParent);
            var container = new CuiElementContainer();
            UI.CreatePanel(ref container, "Hud", OnScreenParent, config.Gui.OnScreenPanel);
            if(Image.ContainsKey(config.Gui.Image.Image))
                UI.CreateImage(ref container, OnScreenParent, null, config.Gui.Image, Image[config.Gui.Image.Image]);
            CuiHelper.AddUi(player, container);
            OnScreen.Add(player);
        }
        private void BlockerUi(BasePlayer player, string inputText)
        {
            if (!Main.ContainsKey(player))
                ShowBlocker(player);
            CuiHelper.DestroyUi(player, BlockerText);
            var timeleft = TimeLeft;
            string formatted = string.Format(inputText, timeleft.Days, timeleft.Hours, timeleft.Minutes, timeleft.Seconds);
            var container = new CuiElementContainer();
            UI.CreateText(ref container, BlockerPanel, BlockerText, config.Gui.TextOnMain, formatted);
            CuiHelper.AddUi(player, container);
            Main[player] = timer.Once(1f, () => BlockerUi(player, inputText));
        }
        private void ShowBlocker(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, BlockerParent);
            var container = new CuiElementContainer();
            UI.CreatePanel(ref container, "Overlay", BlockerParent, config.Gui.Background.Color, "0 0", "1 1", true);
            UI.CreatePanel(ref container, BlockerParent, BlockerPanel, config.Gui.MainPanel);
            UI.CreateFulscreenButton(ref container, BlockerParent, null, "ib.close");
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Helpers

        private void Debug(string text)
        {
#if CHECK
            PrintWarning(text);
#endif
        }
        private bool IsAmmoBlocked(BasePlayer owner, BaseProjectile proj)
        {
            Debug($"IsAmmoBlocked called on player \"{owner.displayName}\" for weapon \"{proj.GetItem()?.info.displayName.english ?? "Unknown"}\"");
            List<Item> currentAmmo = owner.inventory.FindItemIDs(proj.primaryMagazine.ammoType.itemid).ToList();
            Item newAmmo = null;
            Debug($"CurrentAmmo count = {currentAmmo.Count}");
            if (currentAmmo.Count == 0)
            {
                List<Item> newAmmoList = new List<Item>();
                owner.inventory.FindAmmo(newAmmoList, proj.primaryMagazine.definition.ammoTypes);
                Debug(
                    $"CurrentAmmo count equals 0. NewAmmoList count = {newAmmoList.Count}\nTrying to get the first item.");
                if (newAmmoList.Count == 0)
                    return false;
                try
                {
                    newAmmo = newAmmoList[0];
                    Debug($"Successfully got item {newAmmo.info.displayName.english}");
                }
                catch (Exception e)
                {
                    PrintError($"Error in attempt to get the item from NewAmmoList. {e.GetType()}:\n{e.Message}");
                    return false;
                }
            }
            else
            {
                Debug($"CurrentAmmo count doesn't equals 0. Getting NewAmmo out of it.");
                try
                {
                    newAmmo = currentAmmo[0];
                    Debug($"Successfully got item {newAmmo.info.displayName.english}");
                }
                catch (Exception e)
                {
                    PrintError($"Error in attempt to get the item from the CurrentAmmo list. {e.GetType()}:\n{e.Message}");
                    return false;
                }
            }
            return config.BlockedAmmo.Contains(newAmmo.info.displayName.english) || config.BlockedAmmo.Contains(newAmmo.info.shortname);
        }
        private bool IsNPC(BasePlayer player)
        {
            //BotSpawn
            if (player is NPCPlayer)
                return true;
            //HumanNPC
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L))
                return true;
            return false;
        }
        private bool InDuel(BasePlayer player)
        {
            if (Duel == null) return false;
            return (bool)Duel.Call("IsPlayerOnActiveDuel", player);
        }
        TimeSpan TimeLeft => config.BlockEnd.Subtract(DateTime.Now);
        private bool InBlock
        {
            get
            {
                if (TimeLeft.TotalSeconds >= 0)
                {
                    return true;
                }
                return false;
            }
        }
        private void SendToChat(BasePlayer Player, string Message)
        {
            var timeleft = TimeLeft;
            Message = string.Format(Message, timeleft.Days, timeleft.Hours, timeleft.Minutes, timeleft.Seconds);
            PrintToChat(Player, "<color=" + config.PrefixColor + ">" + config.Prefix + "</color> " + Message);
        }
        #endregion
    }
}

// --- End of file: ItemsBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-cleaner ---
// --- Original File Path: I/ItemCleaner/ItemCleaner.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Item Cleaner", "Lorddy", "0.0.6")]
    [Description("Remove specified item from all containers and players")]
    public class ItemCleaner : RustPlugin
    {
        #region Fields
        private const string PERMISSION_USE = "itemcleaner.use";
        #endregion

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CmdHelp1"] = "<color=orange>/itemcleaner remove <Item Display Name| Item Shortname | Item ID></color> <color=yellow>[optional: Entity Owner Name] [optional:\"priv\" To look in current privilege] </color> - Clear all containers and players of the specified item",
                ["CmdHelp2"] = "<color=orange>/itemcleaner find  <Item Display Name| Item Shortname | Item ID></color> <color=yellow>[optional: Entity Owner Name] [optional:\"priv\" To look in current privilege] </color>- Find all containers and players of the specified item",
                ["ItemNotFound"] = "Item Definition Not Found",
                //["PlayerNotFound"] = "Player Not Found",
                ["NoPerm"] = "You don't have permission to use this command",
                ["RemovedFromStorage"] = "Removed {0} {1} item from {2} Storage Container",
                ["RemovedFromPlayer"] = "Removed {0} {1} item from Player {2}.",
                ["FoundFromStorage"] = "Found {0} {1} item from {2} Storage Container",
                ["FoundFromPlayer"] = "Found {0} {1} item from Player {2}.",
                ["TimeTaken"] = "Item Cleaner Command Took {0} ms",
                ["FoundStorage"] = "Checking {0} Storage Containers",
                ["StorageSearchFinish"] = "Storage Container Search Finished",
                ["PlayerSearchFinish"] = "Player Inventory Search Finished",
            }, this);
        }
        #endregion

        #region Hooks
        private void Loaded()
        {
            permission.RegisterPermission(PERMISSION_USE, this);
        }
        #endregion

        #region Commands

        [ChatCommand("itemcleaner")]
        private void ItemCleanerCommand(BasePlayer player, string command, string[] args)
        {
            if (!(permission.UserHasPermission(player.UserIDString,PERMISSION_USE)))
            {
                PrintToChat(player, lang.GetMessage("NoPerm", this, player.UserIDString));
                return;
            }
            if (args.Length < 2)
            {
                PrintToChat(player, lang.GetMessage("CmdHelp1", this, player.UserIDString));
                PrintToChat(player, lang.GetMessage("CmdHelp2", this, player.UserIDString));
                return;
            }
            bool remove = false;
            switch (args[0].ToLower())
            {
                case "remove": remove = true; break;
                case "find": remove = false; break;
                default:
                    PrintToChat(player, lang.GetMessage("CmdHelp1", this, player.UserIDString));
                    PrintToChat(player, lang.GetMessage("CmdHelp2", this, player.UserIDString));
                    return;
            }

            bool priv = args.Contains("priv");

            var itemname = args[1].ToLower();
            var itemId = -1;
            int.TryParse(args[1].ToLower(), out itemId);
            ItemDefinition itemDefinition = null;
            
            IPlayer entityOwner = null;
            if (args.Length >= 3)
                entityOwner = covalence.Players.FindPlayer(args[2].ToLower());

            for (int i = 0; i < ItemManager.itemList.Count; i++)
            {
                if (ItemManager.itemList[i].displayName.english.ToLower() == itemname.ToLower() ||
                    ItemManager.itemList[i].shortname == itemname.ToLower() ||
                    (itemId != -1 && ItemManager.itemList[i].itemid == itemId))
                {
                    itemDefinition = ItemManager.itemList[i];
                    break;
                }
            }
            if (itemDefinition == null)
            {
                PrintToChat(player, lang.GetMessage("ItemNotFound", this, player.UserIDString));
                return;
            }
            RemoveItem(player, itemDefinition, remove, priv ? null : entityOwner, priv);
        }
        #endregion

        #region Methods
        private void RemoveItem(BasePlayer player, ItemDefinition itemDefinition, bool remove = true, IPlayer entityOwner = null, bool priv = false)
        {
            DateTime startTime = DateTime.Now;

            //var scs = Resources.FindObjectsOfTypeAll<StorageContainer>();
            var playerPriv = player?.GetBuildingPrivilege();

            var scs = BaseNetworkable.serverEntities.OfType<StorageContainer>();

            int i = 0;
            foreach(var sc in scs)
            {
                if (sc is LootContainer || !sc.OwnerID.IsSteamId())
                {
                    continue;
                }

                timer.In(i * 0.01f, () => RemoveItem(sc, player, itemDefinition, playerPriv, remove, entityOwner, priv));
                i++; 
            }
            timer.In((i + 1) * 0.01f, () => PrintToChat(player, string.Format(lang.GetMessage("StorageSearchFinish", this, player.UserIDString))));
            string storageFound = string.Format(lang.GetMessage("FoundStorage", this, player.UserIDString), i);
            //Puts(storageFound);
            PrintToChat(player, storageFound);

            int j = 0;
            foreach(var p in BasePlayer.allPlayerList)
            {
                timer.In(j * 0.01f, () => RemoveItem(p, player, itemDefinition, playerPriv, remove, entityOwner, priv));
                j++;
            }

            timer.In((j + 1) * 0.01f, () => PrintToChat(player, string.Format(lang.GetMessage("PlayerSearchFinish", this, player.UserIDString))));

            string timeTaken = string.Format(lang.GetMessage("TimeTaken",this,player.UserIDString), DateTime.Now.Subtract(startTime).TotalMilliseconds);
            //Puts(timeTaken);
            PrintToChat(player, timeTaken);
        }

        void RemoveItem(StorageContainer sc, BasePlayer player, ItemDefinition itemDefinition, BuildingPrivlidge playerPriv, bool remove = true, IPlayer entityOwner = null, bool priv = false)
        {
            if (entityOwner != null && sc.OwnerID != ulong.Parse(entityOwner.Id)) return;

            if (priv == false || (priv && sc?.GetBuildingPrivilege()?.net.ID == playerPriv?.net.ID))
            {
                RemoveItem(player, itemDefinition, sc, remove);
            }
                
        }

        void RemoveItem(BasePlayer bp, BasePlayer player, ItemDefinition itemDefinition, BuildingPrivlidge playerPriv, bool remove = true, IPlayer entityOwner = null, bool priv = false)
        {
            if (entityOwner != null && bp.UserIDString != entityOwner.Id) return;
            if (priv == false || (priv && bp?.GetBuildingPrivilege()?.net.ID == playerPriv?.net.ID))
            {
                RemoveItem(player, itemDefinition, bp, remove);
            }
                
        }


        private void RemoveItem(BasePlayer player, ItemDefinition itemDefinition, BasePlayer target, bool remove)
        {
            if (target == null) return;
            PlayerInventory inventory = target.inventory;
            if (inventory == null) return;
            List<Item> list = inventory.containerMain.itemList.FindAll((Item x) => x.info.itemid == itemDefinition.itemid);
            list.AddRange(inventory.containerBelt.itemList.Where((Item x) => x.info.itemid == itemDefinition.itemid));
            list.AddRange(inventory.containerWear.itemList.Where((Item x) => x.info.itemid == itemDefinition.itemid));
            if (list.Count > 0)
            {
                string msg = string.Format(lang.GetMessage(remove ? "RemovedFromPlayer" : "FoundFromPlayer", this, player.UserIDString), list.Count, itemDefinition.displayName.english, target.displayName); ;
                //Puts(msg);
                PrintToChat(player, msg);

                if (remove)
                    foreach (var item in list)
                    {
                        item.Remove();
                    }
            }
        }
        private void RemoveItem(BasePlayer player, ItemDefinition itemDefinition, StorageContainer sc, bool remove)
        {
            ItemContainer inventory = sc.inventory;
            if (inventory == null) return;
            List<Item> list = inventory.FindItemsByItemID(itemDefinition.itemid);
            //Puts($"{sc.OwnerID}'s Container Item List: [{string.Join(", ", sc.inventory.itemList.Select(x => x.info.displayName.english))}]");
            if (list.Count > 0)
            {
                string msg = string.Format(lang.GetMessage(remove ? "RemovedFromStorage" : "FoundFromStorage", this, player.UserIDString), list.Count, itemDefinition.displayName.english, sc.net.ID);
                //Puts(msg);
                PrintToChat(player, msg);
                if (remove)
                    foreach (var item in list)
                    {
                        item.Remove();
                    }
            }
        }
        #endregion
    }
}



// --- End of file: ItemCleaner.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-heli-loot ---
// --- Original File Path: I/InstantHeliLoot/InstantHeliLoot.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Instant Heli Loot", "August", "1.0.3")]
    [Description("Makes Heli (and Bradley) Gibs lootable/harvestable immediately after being destroyed.")]
    class InstantHeliLoot : CovalencePlugin
    {
        protected override void LoadDefaultConfig()
        {
            Config["UnlockBradleyCrates"] = true;
            Config["UnlockHelicopterCrates"] = true;
            Config["UnlockHelicopterGibs"] = true;
            Config["RemoveFireballs"] = true;
        }

        private void Init()
        {
            if (!(bool) Config["UnlockBradleyCrates"] && !(bool) Config["UnlockHelicopterCrates"])
            {
                Unsubscribe( nameof( OnEntityDeath ) );
            }      
        }

        private void OnServerShutdown() => SaveConfig();
        
        private void UnlockCrates(Vector3 pos)
        {
            List<LockedByEntCrate> crates = new List<LockedByEntCrate>();
                
            Vis.Entities(pos, 20f, crates);

            foreach (var crate in crates)
            {
                crate.SetLocked(false);
            }
        }

        private void KillFire(Vector3 pos)
        {
            List<FireBall> fireBalls = new List<FireBall>();
            Vis.Entities(pos, 20f, fireBalls);
            if (fireBalls.Count > 0)
            {
                foreach ( FireBall fb in fireBalls )
                {
                    fb.Kill();
                }
            }
        }
        private void OnEntitySpawned(HelicopterDebris debris)
        {
            if ((bool) Config["UnlockHelicopterGibs"])
            {
                NextTick( () =>
                {
                    debris.tooHotUntil = -1;
                } );
            }           
        }
        private void OnEntityDeath(BradleyAPC apc, HitInfo info)
        {
            var pos = apc.transform.position;
            if ((bool) Config["UnlockBradleyCrates"])
            {
                NextTick( () => UnlockCrates(pos));
            }
            if ((bool) Config["RemoveFireballs"])
            {
                NextTick( () => { KillFire( pos ); } );
            }
        }

        private void OnEntityDeath(BaseHelicopter heli, HitInfo info)
        {
            var pos = heli.transform.position;
            if ((bool) Config["UnlockHelicopterCrates"])
            {
                NextTick( () => UnlockCrates(pos));
            }
            if ((bool) Config["RemoveFireballs"])
            {
                NextTick( () => { KillFire( pos ); } );
            }
        }
    }
}

// --- End of file: InstantHeliLoot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/identifier ---
// --- Original File Path: I/Identifier/Identifier.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Identifier", "Wulf", "2.0.3")]
    [Description("Gets identification information for one or all connected players")]
    public class Identifier : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Use permission system")]
            public bool UsePermissions = true;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandId"] = "id",
                ["CommandIdAll"] = "ids",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["NoPermission"] = " You have no permissions to use that!",
                ["NoPlayersFound"] = "No players found with name or ID '{0}'",
                ["NoPlayersConnected"] = "No players connected at the moment",
                ["PlayerNotFound"] = "Player '{0}' was not found",
                ["PlayersFound"] = "Multiple players were found, please specify: {0}",
                ["PlayerName"] = "Player Name: {0}",
                ["PlayerId"] = "Player ID: {0}",
                ["PlayerIpAddress"] = "IP Address: {0}",
                ["PlayerListFormat"] = "{0} ({1})",
                ["PlayerListFormatIp"] = "{0} ({1}) - {2}",
                ["SelfId"] = "Your player ID is {0}",
                ["TooManyPlayers"] = "Too many players connected to list them all",
                ["Unknown"] = "Unknown",
                ["UsageId"] = "Usage: {0} <player name or id> - Show identification info for specified player",
                ["UsageIdAll"] = "Usage: {0} - Show identification info for all connected players"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string permId = "identifier.id";
        private const string permIpAddress = "identifier.ipaddress";

        private void Init()
        {
            AddLocalizedCommand(nameof(CommandId));
            AddLocalizedCommand(nameof(CommandIdAll));

            permission.RegisterPermission(permId, this);
            permission.RegisterPermission(permIpAddress, this);
        }

        #endregion Initialization

        #region Commands

        private void CommandId(IPlayer player, string command, string[] args)
        {
            bool hasPermission = player.HasPermission(permId);

            if (args.Length == 0)
            {
                StringBuilder output = new StringBuilder();
                if (!player.IsServer)
                {
                    output.Append(GetLang("SelfId", player.Id, player.Id)); // TODO: Find a universal way to handle line break
                }
                if (hasPermission)
                {
                    output.Append(GetLang("UsageId", player.Id, command)).Append("\n"); // TODO: Find a universal way to handle line break
                    output.Append(GetLang("UsageIdAll", player.Id, GetLang("CommandIdAll", player.Id)));
                }
                Message(player, output.ToString());
                return;
            }

            IPlayer target = FindPlayer(string.Join(" ", args.ToArray()), player);
            if (target != null)
            {
                StringBuilder output = new StringBuilder();
                if (!config.UsePermissions || hasPermission)
                {
                    output.Append(GetLang("PlayerName", player.Id, target.Name)).Append("\n"); // TODO: Find a universal way to handle line break
                    output.Append(GetLang("PlayerId", player.Id, target.Id)).Append("\n"); // TODO: Find a universal way to handle line break
                }
                if (!config.UsePermissions && player.IsAdmin || player.HasPermission(permIpAddress))
                {
                    output.Append(GetLang("PlayerIpAddress", player.Id, string.IsNullOrEmpty(target.Address) ? GetLang("Unknown", player.Id) : target.Address));
                }
                Message(player, output.ToString());
            }
        }

        private void CommandIdAll(IPlayer player, string command, string[] args)
        {
            if (config.UsePermissions && !player.HasPermission(permId))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            int playersConnected = players.Connected.Count();

            if (playersConnected == 0)
            {
                Message(player, "NoPlayersConnected");
                return;
            }

            int targetedCount = 0;
            StringBuilder output = new StringBuilder();
            foreach (IPlayer target in players.Connected)
            {
                // TODO: Add support for limiting output to X amount of results
                // TODO: Add support for limiting results based on partial name/ID matches
                // TODO: Add support for pagination to split up large amount of results

                if (!config.UsePermissions && player.IsAdmin || player.HasPermission(permIpAddress))
                {
                    output.Append(GetLang("PlayerListFormatIp", player.Id, target.Name, target.Id, target.Address));
                }
                else
                {
                    output.Append(GetLang("PlayerListFormat", player.Id, target.Name, target.Id));
                }
                if (playersConnected != targetedCount)
                {
                    output.Append("\n"); // TODO: Find a universal way to handle line break
                }

                targetedCount++;
            }
            Message(player, output.ToString());
        }

        #endregion Commands

        #region Helpers

        private IPlayer FindPlayer(string playerNameOrId, IPlayer player)
        {
            IPlayer[] foundPlayers = players.FindPlayers(playerNameOrId).ToArray();
            if (foundPlayers.Length > 1)
            {
                Message(player, "PlayersFound", string.Join(", ", foundPlayers.Select(p => p.Name).Take(10).ToArray()).Truncate(60));
                return null;
            }

            IPlayer target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target == null)
            {
                Message(player, "NoPlayersFound", playerNameOrId);
                return null;
            }

            return target;
        }

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: Identifier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/imperium ---
// --- Original File Path: I/Imperium/Imperium.cs ---

/* LICENSE
 * Copyright (C) 2022-2024 evict
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#region > Singleton
namespace Oxide.Plugins
{
    using System;
    using System.IO;
    using Oxide.Core;
    using Oxide.Core.Plugins;
    using Oxide.Core.Configuration;
    using Oxide.Core.Libraries.Covalence;
    using UnityEngine;
    using System.Collections.Generic;
    using System.Linq;
    using Network;


    [Info("Imperium", "chucklenugget/evict", "2.2.9")]
    [Description("Land Claims for Rust")]
    public partial class Imperium : RustPlugin
    {
        //Optional Dependencies
        [PluginReference]
        private Plugin BetterChat, Clans, RaidableBases, NPCSpawn;
        private List<HookDeferral> HookDeferralRegistry = new List<HookDeferral>();
        public class HookDeferral
        {
            public string hookName;
            public Plugin plugin;

            public HookDeferral(string HookName, Plugin Plugin)
            {
                hookName = HookName;
                plugin = Plugin;
            }
        }

        //Hook Deferrals
        [PluginReference]
        private Plugin NpcSpawn, AirEvent;

        private void InitDeferList()
        {
            //RegisterHookDeferral("OnEntityTakeDamage", NpcSpawn);
            //RegisterHookDeferral("OnEntityTakeDamage", AirEvent);
            
        }

        private static Imperium Instance;
        private bool Ready;

        public static string dataDirectory = $"file://{Interface.Oxide.DataDirectory}{Path.DirectorySeparatorChar}ImperiumImages{Path.DirectorySeparatorChar}";
        private DynamicConfigFile AreasFile;
        private DynamicConfigFile FactionsFile;
        private DynamicConfigFile PinsFile;
        private DynamicConfigFile WarsFile;
        private GameObject GO;
        private ImperiumOptions Options;
        private Timer UpkeepCollectionTimer;
        private AreaManager Areas;
        private FactionManager Factions;
        private HudManager Hud;
        private PinManager Pins;
        private UserManager Users;
        private WarManager Wars;
        private ZoneManager Zones;
        private RecruitManager Recruits;

        private void Init()
        {
            AreasFile = GetDataFile("areas");
            FactionsFile = GetDataFile("factions");
            PinsFile = GetDataFile("pins");
            WarsFile = GetDataFile("wars");
        }

        private void RegisterHookDeferral(string hook, Plugin plugin)
        {
            if (plugin == null)
                return;
            HookDeferralRegistry.Add(new HookDeferral(hook, plugin));
        }

        private object GetExternalHookResult(string hook, params object[] args)
        {
            if (HookDeferralRegistry.Count == 0)
                return null;
            List<HookDeferral> filtered = HookDeferralRegistry.FindAll(r => r.hookName == hook && r.plugin != null);
            if (filtered.Count == 0)
                return null;
            object result = null;
            foreach (HookDeferral def in filtered)
            {
                if (def.plugin == null)
                    continue;
                result = def.plugin.Call(hook, args);
                if (result != null)
                    return result;
            }
            return null;
        }

        private void Loaded()
        {
            InitLang();
            InitDeferList();
            Permission.RegisterAll(this);
            try
            {
                Options = Config.ReadObject<ImperiumOptions>();
            }
            catch (Exception ex)
            {
                PrintError($"Error while loading configuration: {ex.ToString()}");
            }


            Puts("Area claims are " + (Options.Claims.Enabled ? "enabled" : "disabled"));
            Puts("Taxation is " + (Options.Taxes.Enabled ? "enabled" : "disabled"));
            Puts("Badlands are " + (Options.Badlands.Enabled ? "enabled" : "disabled"));
            Puts("Map pins are " + (Options.Map.PinsEnabled ? "enabled" : "disabled"));
            Puts("War is " + (Options.War.Enabled ? "enabled" : "disabled"));
            Puts("Decay reduction is " + (Options.Decay.Enabled ? "enabled" : "disabled"));
            Puts("Claim upkeep is " + (Options.Upkeep.Enabled ? "enabled" : "disabled"));
            Puts("Zones are " + (Options.Zones.Enabled ? "enabled" : "disabled"));

            if (Options.Upgrading.Enabled)
            {
                PrintWarning("Land upgrading is not available in this Imperium version yet! Disabling it");
                Options.Upgrading.Enabled = false;
            }

            if (Options.Recruiting.Enabled)
            {
                PrintWarning("Recruiting is not available in this Imperium version yet! Disabling it");
                //Options.Recruiting.Enabled = false;
            }

            if (BetterChat != null)
            {
                Puts("Using " + BetterChat.Name + " by " + BetterChat.Author);
                Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(BetterChat_FormattedFactionTag));
            }
            Instance = this;
            

            //Puts("Recruiting is " + (Options.Recruiting.Enabled ? "enabled" : "disabled"));

            // If the map has already been initialized, we can set up now; otherwise,
            // we need to wait until the savefile has been loaded.
            if (TerrainMeta.Size.x > 0) Setup();
        }

        private void OnServerInitialized(bool initial)
        {
            if (initial)
                Setup();
        }

        private void Setup()
        {
            GO = new GameObject();

            Areas = new AreaManager();
            Factions = new FactionManager();
            Hud = new HudManager();
            Pins = new PinManager();
            Users = new UserManager();
            Wars = new WarManager();
            Zones = new ZoneManager();
            Recruits = new RecruitManager();

            Factions.Init(TryLoad<FactionInfo>(FactionsFile));
            Areas.Init(TryLoad<AreaInfo>(AreasFile));
            Pins.Init(TryLoad<PinInfo>(PinsFile));
            Users.Init();
            Wars.Init(TryLoad<WarInfo>(WarsFile));
            Zones.Init();
            Hud.Init();

            Hud.GenerateMapOverlayImage();

            if (Options.Factions.OverrideInGameTeamSystem)
            {
                RelationshipManager.maxTeamSize = 128;
                RelationshipManager.maxTeamSize_Internal = 128;
            }

            if (Instance.Options.Factions.UseClansPlugin)
            {
                Factions.SyncAllWithClans();
            }

            if (Options.Upkeep.Enabled)
                UpkeepCollectionTimer =
                    timer.Every(Options.Upkeep.CheckIntervalMinutes * 60, Upkeep.CollectForAllFactions);


            PrintToChat($"{Title} v{Version} initialized.");
            Ready = true;
        }

        private void Unload()
        {
            SaveData();
            Hud.Destroy();
            Zones.Destroy();
            Users.Destroy();
            Wars.Destroy();
            Pins.Destroy();
            Areas.Destroy();
            Factions.Destroy();

            if (UpkeepCollectionTimer != null && !UpkeepCollectionTimer.Destroyed)
                UpkeepCollectionTimer.Destroy();

            if (GO != null)
                UnityEngine.Object.Destroy(GO);

            Instance = null;
        }

        private void OnServerSave()
        {
            timer.Once(Core.Random.Range(10, 30), SaveData);
        }

        private void SaveData()
        {
            AreasFile.WriteObject(Areas.Serialize());
            FactionsFile.WriteObject(Factions.Serialize());
            PinsFile.WriteObject(Pins.Serialize());
            WarsFile.WriteObject(Wars.Serialize());
        }

        private DynamicConfigFile GetDataFile(string name)
        {
            return Interface.Oxide.DataFileSystem.GetFile(Name + Path.DirectorySeparatorChar + name);
        }

        private IEnumerable<T> TryLoad<T>(DynamicConfigFile file)
        {
            List<T> items;

            try
            {
                items = file.ReadObject<List<T>>();
            }
            catch (Exception ex)
            {
                PrintWarning($"Error reading data from {file.Filename}: ${ex.ToString()}");
                items = new List<T>();
            }

            return items;
        }

        private void Log(string message, params object[] args)
        {
            LogToFile("log", String.Format(message, args), this, true);
        }

        private bool EnsureUserCanChangeFactionClaims(User user, Faction faction)
        {
            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return false;
            }

            if (faction.MemberCount < Options.Claims.MinFactionMembers)
            {
                user.SendChatMessage(nameof(Messages.FactionTooSmallToOwnLand), Options.Claims.MinFactionMembers);
                return false;
            }

            return true;
        }

        private bool EnsureFactionCanClaimArea(User user, Faction faction, Area area)
        {
            if (area.Type == AreaType.Badlands)
            {
                user.SendChatMessage(nameof(Messages.AreaIsBadlands), area.Id);
                return false;
            }

            if (faction.MemberCount < Instance.Options.Claims.MinFactionMembers)
            {
                user.SendChatMessage(nameof(Messages.FactionTooSmallToOwnLand), Instance.Options.Claims.MinFactionMembers);
                return false;
            }

            Area[] claimedAreas = Areas.GetAllClaimedByFaction(faction);

            if (Instance.Options.Claims.RequireContiguousClaims && !area.IsClaimed && claimedAreas.Length > 0)
            {
                int contiguousClaims = Areas.GetNumberOfContiguousClaimedAreas(area, faction);
                if (contiguousClaims == 0)
                {
                    user.SendChatMessage(nameof(Messages.AreaNotContiguous), area.Id, faction.Id);
                    return false;
                }
            }

            int? maxClaims = Instance.Options.Claims.MaxClaims;
            if (maxClaims != null && claimedAreas.Length >= maxClaims)
            {
                user.SendChatMessage(nameof(Messages.FactionOwnsTooMuchLand), faction.Id, maxClaims);
                return false;
            }

            return true;
        }

        private bool EnsureCupboardCanBeUsedForClaim(User user, BuildingPrivlidge cupboard)
        {
            if (cupboard == null)
            {
                user.SendChatMessage(nameof(Messages.SelectingCupboardFailedInvalidTarget));
                return false;
            }

            if (!cupboard.IsAuthed(user.Player))
            {
                user.SendChatMessage(nameof(Messages.SelectingCupboardFailedNotAuthorized));
                return false;
            }

            return true;
        }

        private bool EnsureLockerCanBeUsedForArmory(User user, Locker locker, Area area)
        {
            if (area == null || area.FactionId != user.Faction.Id)
            {
                user.SendChatMessage(nameof(Messages.AreaNotOwnedByYourFaction));
                return false;
            }
            return true;
        }

        private bool EnsureUserAndFactionCanEngageInDiplomacy(User user, Faction faction)
        {
            if (faction == null)
            {
                user.SendChatMessage(nameof(Messages.NotMemberOfFaction));
                return false;
            }

            if (faction.MemberCount < Options.Claims.MinFactionMembers)
            {
                user.SendChatMessage(nameof(Messages.FactionTooSmallToOwnLand));
                return false;
            }

            if (Areas.GetAllClaimedByFaction(faction).Length == 0)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotOwnLand));
                return false;
            }

            return true;
        }

        private bool EnforceCommandCooldown(User user, string command, int cooldownSeconds)
        {
            int secondsRemaining = user.GetSecondsLeftOnCooldown(command);

            if (secondsRemaining > 0)
            {
                user.SendChatMessage(nameof(Messages.CommandIsOnCooldown), secondsRemaining);
                return false;
            }

            user.SetCooldownExpiration(command, DateTime.UtcNow.AddSeconds(cooldownSeconds));
            return true;
        }

        private bool TryCollectFromStacks(ItemDefinition itemDef, IEnumerable<Item> stacks, int amount)
        {
            if (stacks.Sum(item => item.amount) < amount)
                return false;

            int amountRemaining = amount;
            var dirtyContainers = new HashSet<ItemContainer>();

            foreach (Item stack in stacks)
            {
                var amountToTake = Math.Min(stack.amount, amountRemaining);

                stack.amount -= amountToTake;
                amountRemaining -= amountToTake;

                dirtyContainers.Add(stack.GetRootContainer());

                if (stack.amount == 0)
                    stack.RemoveFromContainer();

                if (amountRemaining == 0)
                    break;
            }

            foreach (ItemContainer container in dirtyContainers)
                container.MarkDirty();

            return true;
        }
    }

}
namespace Oxide.Plugins
{
    using Oxide.Core.Plugins;
    using Oxide.Core.Libraries.Covalence;
    public partial class Imperium
    {
        private string BetterChat_FormattedFactionTag(IPlayer player)
        {
            if (Clans)
                return null;
            Faction faction = Factions.GetByMember(player.Id);
            if (faction == null)
                return string.Empty;
            FactionColorPicker colorPicker = new FactionColorPicker();
            return "[" + colorPicker.GetHexColorForFaction(faction.Id) + "][" + faction.Id + "][/#]";
        }

    }
}

#endregion

#region > Console To Chat

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        [ConsoleCommand("imperium.panel.close")]
        private void ccmdImperiumPanelClose(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            User user = player.GetComponent<User>();
            if (user == null)
                return;
            user.Panel.Close();
        }
    }
}

namespace Oxide.Plugins
{
    using UnityEngine;
    public partial class Imperium
    {
        [ConsoleCommand("imperium.panel.opentab")]
        private void ccmdImperiumPanelOpenTab(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            User user = player.GetComponent<User>();
            if (user == null)
                return;
            user.Panel.OpenTab(arg.Args[0]);
        }
    }
}

namespace Oxide.Plugins
{
    using UnityEngine;
    public partial class Imperium
    {
        [ConsoleCommand("imperium.panel.opencmd")]
        private void ccmdImperiumPanelOpenCmd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            User user = player.GetComponent<User>();
            if (user == null)
                return;
            user.Panel.OpenCommand(arg.Args[0]);
        }
    }
}

namespace Oxide.Plugins
{
    using UnityEngine;
    using System;
    using System.Text.RegularExpressions;
    public partial class Imperium
    {
        [ConsoleCommand("imperium.panel.run")]
        private void ccmdImperiumPanelRun(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            User user = player.GetComponent<User>();
            if (user == null)
                return;
            string chatCommand = user.Panel.GetFullConsoleCommand();
            Regex.Replace(chatCommand, @"[\""]", "\\\"", RegexOptions.None);
            player.SendConsoleCommand("chat.say " + chatCommand);
            if (Convert.ToBoolean(arg.Args[0]))
            {
                user.Panel.Close();
            }
            else
            {
                user.Panel.ClearCurrentCommand();
                user.Panel.Refresh();
            }

        }
    }
}
namespace Oxide.Plugins
{
    using System;
    using UnityEngine;
    public partial class Imperium
    {
        [ConsoleCommand("imperium.panel.setarg")]
        private void ccmdImperiumPanelSetArg(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;
            User user = player.GetComponent<User>();
            if (!user)
                return;
            if (arg.Args.Length < 3)
                return;
            string fullArg = "";
            for (int i = 2; i < arg.Args.Length; i++)
            {
                fullArg = fullArg + arg.Args[i];
                if (i != arg.Args.Length - 1)
                    fullArg = fullArg + " ";
            }
            user.Panel.SetArg(Convert.ToInt32(arg.Args[0]), fullArg, Convert.ToBoolean(arg.Args[1]));
        }
    }
}
#endregion

#region > Chat Commands
#region commons
namespace Oxide.Plugins
{
    public partial class Imperium
    {
        [ChatCommand("cancel")]
        private void OnCancelCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);

            if (user.CurrentInteraction == null)
            {
                user.SendChatMessage(nameof(Messages.NoInteractionInProgress));
                return;
            }

            user.SendChatMessage(nameof(Messages.InteractionCanceled));
            user.CancelInteraction();
            
        }

    }
}

namespace Oxide.Plugins
{
    using System.Text;

    public partial class Imperium
    {
        [ChatCommand("help")]
        private void OnHelpCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            if (user == null) return;

            var sb = new StringBuilder();

            sb.AppendLine($"<size=18>Welcome to {ConVar.Server.hostname}!</size>");
            sb.AppendLine($"Powered by {Name} v{Version} by <color=#ffd479>chucklenugget</color> and <color=#ffd479>evict</color>");
            sb.AppendLine(
                "Do <color=#ffd479>/i</color> to open Imperium UI. You can also do <color=#ffd479>bind i chat.say /i</color> in F1 console to easily toggle Imperium UI");
            sb.AppendLine();

            sb.Append(
                "The following commands are available. To learn more about each command, do <color=#ffd479>/command help</color>. ");
            sb.AppendLine("For example, to learn more about how to claim land, do <color=#ffd479>/claim help</color>.");
            sb.AppendLine();

            sb.AppendLine("<color=#ffd479>/faction</color> Create or join a faction");
            sb.AppendLine("<color=#ffd479>/claim</color> Claim areas of land");

            if (Options.Taxes.Enabled)
                sb.AppendLine("<color=#ffd479>/tax</color> Manage taxation of your land");

            if (Options.Map.PinsEnabled)
                sb.AppendLine("<color=#ffd479>/pin</color> Add pins (points of interest) to the map");

            if (Options.War.Enabled)
                sb.AppendLine("<color=#ffd479>/war</color> See active wars, declare war, or offer peace");

            if (Options.Badlands.Enabled)
            {
                if (user.HasPermission(Permission.AdminBadlands))
                    sb.AppendLine("<color=#ffd479>/badlands</color> Find or change badlands areas");
                else
                    sb.AppendLine("<color=#ffd479>/badlands</color> Find badlands (PVP) areas");
            }

            user.SendChatMessage(sb);
        }
    }
}
#endregion
#region /imperium
namespace Oxide.Plugins
{
    public partial class Imperium
    {
        [ChatCommand("i")]
        private void OnImperiumCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            user.Panel.Toggle();
        }
    }
}
#endregion
#region /pvp
namespace Oxide.Plugins
{
    public partial class Imperium
    {
        [ChatCommand("pvp")]
        private void OnPvpCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);

            if (!Options.Pvp.EnablePvpCommand)
            {
                user.SendChatMessage(nameof(Messages.PvpModeDisabled));
                return;
            }

            if (!EnforceCommandCooldown(user, "pvp", Options.Pvp.CommandCooldownSeconds))
                return;

            if (user.IsInPvpMode)
            {
                user.IsInPvpMode = false;
                user.SendChatMessage(nameof(Messages.ExitedPvpMode));
                Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
            }
            else
            {
                user.IsInPvpMode = true;
                user.SendChatMessage(nameof(Messages.EnteredPvpMode));
                Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
            }

            user.Hud.Refresh();
        }
    }
}
#endregion
#region /badlands
namespace Oxide.Plugins
{
    using System.Linq;

    public partial class Imperium
    {
        [ChatCommand("badlands")]
        private void OnBadlandsCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            if (user == null) return;

            if (!Options.Badlands.Enabled)
            {
                user.SendChatMessage(nameof(Messages.BadlandsDisabled));
                return;
            }

            if (args.Length == 0)
            {
                var areas = Areas.GetAllByType(AreaType.Badlands).Select(a => a.Id);
                user.SendChatMessage(nameof(Messages.BadlandsList), Util.Format(areas), Options.Taxes.BadlandsGatherBonus);
                return;
            }

            if (!user.HasPermission(Permission.AdminBadlands))
            {
                user.SendChatMessage(nameof(Messages.NoPermission));
                return;
            }

            var areaIds = args.Skip(1).Select(arg => Util.NormalizeAreaId(arg)).ToArray();

            switch (args[0].ToLower())
            {
                case "add":
                    if (args.Length < 2)
                        user.SendChatMessage(nameof(Messages.Usage), "/badlands add [XY XY XY...]");
                    else
                        OnAddBadlandsCommand(user, areaIds);
                    break;

                case "remove":
                    if (args.Length < 2)
                        user.SendChatMessage(nameof(Messages.Usage), "/badlands remove [XY XY XY...]");
                    else
                        OnRemoveBadlandsCommand(user, areaIds);
                    break;

                case "set":
                    if (args.Length < 2)
                        user.SendChatMessage(nameof(Messages.Usage), "/badlands set [XY XY XY...]");
                    else
                        OnSetBadlandsCommand(user, areaIds);
                    break;

                case "clear":
                    if (args.Length != 1)
                        user.SendChatMessage(nameof(Messages.Usage), "/badlands clear");
                    else
                        OnSetBadlandsCommand(user, new string[0]);
                    break;

                default:
                    OnBadlandsHelpCommand(user);
                    break;
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System.Collections.Generic;
    using System.Linq;

    public partial class Imperium
    {
        private void OnAddBadlandsCommand(User user, string[] args)
        {
            var areas = new List<Area>();

            foreach (string arg in args)
            {
                Area area = Areas.Get(Util.NormalizeAreaId(arg));

                if (area == null)
                {
                    user.SendChatMessage(nameof(Messages.UnknownArea), arg);
                    return;
                }

                if (area.Type != AreaType.Wilderness)
                {
                    user.SendChatMessage(nameof(Messages.AreaNotWilderness), area.Id);
                    return;
                }

                areas.Add(area);
            }

            Areas.AddBadlands(areas);
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
            user.SendChatMessage(nameof(Messages.BadlandsSet), Util.Format(Areas.GetAllByType(AreaType.Badlands)));
            Log($"{Util.Format(user)} added {Util.Format(areas)} to badlands");
        }
    }
}

namespace Oxide.Plugins
{
    using System.Text;

    public partial class Imperium
    {
        private User user;

        private void OnBadlandsHelpCommand(User user)
        {
            var sb = new StringBuilder();

            sb.AppendLine("Available commands:");
            sb.AppendLine("  <color=#ffd479>/badlands add XY [XY XY...]</color>: Add area(s) to the badlands");
            sb.AppendLine("  <color=#ffd479>/badlands remove XY [XY XY...]</color>: Remove area(s) from the badlands");
            sb.AppendLine("  <color=#ffd479>/badlands set XY [XY XY...]</color>: Set the badlands to a list of areas");
            sb.AppendLine("  <color=#ffd479>/badlands clear</color>: Remove all areas from the badlands");
            sb.AppendLine("  <color=#ffd479>/badlands help</color>: Prints this message");

            user.SendChatMessage(sb);
        }
    }
}

namespace Oxide.Plugins
{
    using System.Collections.Generic;
    using System.Linq;

    public partial class Imperium
    {
        private void OnRemoveBadlandsCommand(User user, string[] args)
        {
            var areas = new List<Area>();

            foreach (string arg in args)
            {
                Area area = Areas.Get(Util.NormalizeAreaId(arg));

                if (area == null)
                {
                    user.SendChatMessage(nameof(Messages.UnknownArea), arg);
                    return;
                }

                if (area.Type != AreaType.Badlands)
                {
                    user.SendChatMessage(nameof(Messages.AreaNotBadlands), area.Id);
                    return;
                }

                areas.Add(area);
            }

            Areas.Unclaim(areas);
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
            user.SendChatMessage(nameof(Messages.BadlandsSet), Util.Format(Areas.GetAllByType(AreaType.Badlands)));
            Log($"{Util.Format(user)} removed {Util.Format(areas)} from badlands");
        }
    }
}

namespace Oxide.Plugins
{
    using System.Collections.Generic;
    using System.Linq;

    public partial class Imperium
    {
        private void OnSetBadlandsCommand(User user, string[] args)
        {
            var areas = new List<Area>();

            foreach (string arg in args)
            {
                Area area = Areas.Get(Util.NormalizeAreaId(arg));

                if (area == null)
                {
                    user.SendChatMessage(nameof(Messages.UnknownArea), arg);
                    return;
                }

                if (area.Type != AreaType.Wilderness)
                {
                    user.SendChatMessage(nameof(Messages.AreaNotWilderness), area.Id);
                    return;
                }

                areas.Add(area);
            }

            Areas.Unclaim(Areas.GetAllByType(AreaType.Badlands));
            Areas.AddBadlands(areas);
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
            user.SendChatMessage(nameof(Messages.BadlandsSet), Util.Format(Areas.GetAllByType(AreaType.Badlands)));
            Log($"{Util.Format(user)} set badlands to {Util.Format(areas)}");
        }
    }
}
#endregion
#region /claim
namespace Oxide.Plugins
{
    using System.Linq;

    public partial class Imperium
    {
        [ChatCommand("claim")]
        private void OnClaimCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            if (user == null) return;

            if (!Options.Claims.Enabled)
            {
                user.SendChatMessage(nameof(Messages.AreaClaimsDisabled));
                return;
            }

            if (args.Length == 0)
            {
                OnClaimAddCommand(user);
                return;
            }

            var restArguments = args.Skip(1).ToArray();

            switch (args[0].ToLower())
            {
                case "add":
                    OnClaimAddCommand(user);
                    break;
                case "remove":
                    OnClaimRemoveCommand(user);
                    break;
                case "hq":
                    OnClaimHeadquartersCommand(user);
                    break;
                case "rename":
                    OnClaimRenameCommand(user, restArguments);
                    break;
                case "give":
                    OnClaimGiveCommand(user, restArguments);
                    break;
                case "cost":
                    OnClaimCostCommand(user, restArguments);
                    break;
                case "upkeep":
                    OnClaimUpkeepCommand(user);
                    break;
                case "show":
                    OnClaimShowCommand(user, restArguments);
                    break;
                case "list":
                    OnClaimListCommand(user, restArguments);
                    break;
                case "assign":
                    OnClaimAssignCommand(user, restArguments);
                    break;
                case "delete":
                    OnClaimDeleteCommand(user, restArguments);
                    break;
                case "info":
                case "upgrade":
                default:
                    OnClaimHelpCommand(user);
                    break;
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnClaimAddCommand(User user)
        {
            Faction faction = Factions.GetByMember(user);

            if (!EnsureUserCanChangeFactionClaims(user, faction))
                return;

            user.SendChatMessage(nameof(Messages.SelectClaimCupboardToAdd));
            user.BeginInteraction(new AddingClaimInteraction(faction));
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnClaimAssignCommand(User user, string[] args)
        {
            if (!user.HasPermission(Permission.AdminClaims))
            {
                user.SendChatMessage(nameof(Messages.NoPermission));
                return;
            }

            if (args.Length == 0)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/claim assign FACTION");
                return;
            }

            string factionId = Util.NormalizeFactionId(args[0]);
            Faction faction = Factions.Get(factionId);

            if (faction == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), factionId);
                return;
            }

            user.SendChatMessage(nameof(Messages.SelectClaimCupboardToAssign));
            user.BeginInteraction(new AssigningClaimInteraction(faction));
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnClaimCostCommand(User user, string[] args)
        {
            Faction faction = Factions.GetByMember(user);

            if (faction == null)
            {
                user.SendChatMessage(nameof(Messages.NotMemberOfFaction));
                return;
            }

            if (faction.MemberCount < Options.Claims.MinFactionMembers)
            {
                user.SendChatMessage(nameof(Messages.FactionTooSmallToOwnLand), Options.Claims.MinFactionMembers);
                return;
            }

            if (args.Length > 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/claim cost [XY]");
                return;
            }

            Area area;
            if (args.Length == 0)
                area = user.CurrentArea;
            else
                area = Areas.Get(Util.NormalizeAreaId(args[0]));

            if (area == null)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/claim cost [XY]");
                return;
            }

            if (area.Type == AreaType.Badlands)
            {
                user.SendChatMessage(nameof(Messages.AreaIsBadlands), area.Id);
                return;
            }
            else if (area.Type != AreaType.Wilderness)
            {
                user.SendChatMessage(nameof(Messages.CannotClaimAreaAlreadyClaimed), area.Id, area.FactionId);
                return;
            }

            int cost = area.GetClaimCost(faction);
            user.SendChatMessage(nameof(Messages.ClaimCost), area.Id, faction.Id, cost);
        }
    }
}

namespace Oxide.Plugins
{
    using System.Collections.Generic;

    public partial class Imperium
    {
        private void OnClaimDeleteCommand(User user, string[] args)
        {
            if (args.Length == 0)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/claim delete XY [XY XY...]");
                return;
            }

            if (!user.HasPermission(Permission.AdminClaims))
            {
                user.SendChatMessage(nameof(Messages.NoPermission));
                return;
            }

            var areas = new List<Area>();
            foreach (string arg in args)
            {
                Area area = Areas.Get(Util.NormalizeAreaId(arg));

                if (area.Type == AreaType.Badlands)
                {
                    user.SendChatMessage(nameof(Messages.AreaIsBadlands), area.Id);
                    return;
                }

                if (area.Type == AreaType.Wilderness)
                {
                    user.SendChatMessage(nameof(Messages.AreaIsWilderness), area.Id);
                    return;
                }

                areas.Add(area);
            }

            foreach (Area area in areas)
            {
                PrintToChat(Messages.AreaClaimDeletedAnnouncement, area.FactionId, area.Id);
                Log($"{Util.Format(user)} deleted {area.FactionId}'s claim on {area.Id}");
            }

            Areas.Unclaim(areas);
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnClaimGiveCommand(User user, string[] args)
        {
            if (args.Length == 0)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/claim give FACTION");
                return;
            }

            Faction sourceFaction = Factions.GetByMember(user);

            if (!EnsureUserCanChangeFactionClaims(user, sourceFaction))
                return;

            string factionId = Util.NormalizeFactionId(args[0]);
            Faction targetFaction = Factions.Get(factionId);

            if (targetFaction == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), factionId);
                return;
            }

            user.SendChatMessage(nameof(Messages.SelectClaimCupboardToTransfer));
            user.BeginInteraction(new TransferringClaimInteraction(sourceFaction, targetFaction));
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnClaimHeadquartersCommand(User user)
        {
            Faction faction = Factions.GetByMember(user);

            if (!EnsureUserCanChangeFactionClaims(user, faction))
                return;

            user.SendChatMessage(nameof(Messages.SelectClaimCupboardForHeadquarters));
            user.BeginInteraction(new SelectingHeadquartersInteraction(faction));
        }
    }
}

namespace Oxide.Plugins
{
    using System.Text;

    public partial class Imperium
    {
        private void OnClaimHelpCommand(User user)
        {
            var sb = new StringBuilder();

            sb.AppendLine("Available commands:");
            sb.AppendLine("  <color=#ffd479>/claim</color>: Add a claim for your faction");
            sb.AppendLine("  <color=#ffd479>/claim hq</color>: Select your faction's headquarters");
            sb.AppendLine("  <color=#ffd479>/claim remove</color>: Remove a claim for your faction (no undo!)");
            sb.AppendLine(
                "  <color=#ffd479>/claim give FACTION</color>: Give a claimed area to another faction (no undo!)");
            sb.AppendLine("  <color=#ffd479>/claim rename XY \"NAME\"</color>: Rename an area claimed by your faction");
            sb.AppendLine("  <color=#ffd479>/claim show XY</color>: Show who owns an area");
            sb.AppendLine("  <color=#ffd479>/claim list FACTION</color>: List all areas claimed for a faction");
            sb.AppendLine("  <color=#ffd479>/claim cost [XY]</color>: Show the cost for your faction to claim an area");

            if (!Options.Upkeep.Enabled)
                sb.AppendLine(
                    "  <color=#ffd479>/claim upkeep</color>: Show information about upkeep costs for your faction");

            sb.AppendLine("  <color=#ffd479>/claim help</color>: Prints this message");

            if (user.HasPermission(Permission.AdminClaims))
            {
                sb.AppendLine("Admin commands:");
                sb.AppendLine(
                    "  <color=#ffd479>/claim assign FACTION</color>: Use the hammer to assign a claim to another faction");
                sb.AppendLine(
                    "  <color=#ffd479>/claim delete XY [XY XY XY...]</color>: Remove the claim on the specified areas (no undo!)");
            }

            user.SendChatMessage(sb);
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Linq;
    using System.Text;

    public partial class Imperium
    {
        private void OnClaimListCommand(User user, string[] args)
        {
            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/claim list FACTION");
                return;
            }

            string factionId = Util.NormalizeFactionId(args[0]);
            Faction faction = Factions.Get(factionId);

            if (faction == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), factionId);
                return;
            }

            Area[] areas = Areas.GetAllClaimedByFaction(faction);
            Area headquarters = areas.FirstOrDefault(a => a.Type == AreaType.Headquarters);

            var sb = new StringBuilder();

            if (areas.Length == 0)
            {
                sb.AppendFormat(String.Format("<color=#ffd479>[{0}]</color> has no land holdings.", factionId));
            }
            else
            {
                float percentageOfMap = (areas.Length / (float)Areas.Count) * 100;
                sb.AppendLine(String.Format("<color=#ffd479>[{0}] owns {1} tiles ({2:F2}% of the known world)</color>",
                    faction.Id, areas.Length, percentageOfMap));
                sb.AppendLine(String.Format("Headquarters: {0}", (headquarters == null) ? "Unknown" : headquarters.Id));
                sb.AppendLine(String.Format("Areas claimed: {0}", Util.Format(areas)));
            }

            user.SendChatMessage(sb);
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnClaimRemoveCommand(User user)
        {
            Faction faction = Factions.GetByMember(user);

            if (!EnsureUserCanChangeFactionClaims(user, faction))
                return;

            user.SendChatMessage(nameof(Messages.SelectClaimCupboardToRemove));
            user.BeginInteraction(new RemovingClaimInteraction(faction));
        }
    }
}

namespace Oxide.Plugins
{
    using System;

    public partial class Imperium
    {
        private void OnClaimRenameCommand(User user, string[] args)
        {
            Faction faction = Factions.GetByMember(user);

            if (!EnsureUserCanChangeFactionClaims(user, faction))
                return;

            if (args.Length != 2)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/claim rename XY \"NAME\"");
                return;
            }

            var areaId = Util.NormalizeAreaId(args[0]);
            var name = Util.NormalizeAreaName(args[1]);

            if (name == null || name.Length < Options.Claims.MinAreaNameLength ||
                name.Length > Options.Claims.MaxAreaNameLength)
            {
                user.SendChatMessage(nameof(Messages.InvalidAreaName), Options.Claims.MinAreaNameLength,
                    Options.Claims.MaxAreaNameLength);
                return;
            }

            Area area = Areas.Get(areaId);

            if (area == null)
            {
                user.SendChatMessage(nameof(Messages.UnknownArea), areaId);
                return;
            }

            if (area.FactionId != faction.Id)
            {
                user.SendChatMessage(nameof(Messages.AreaNotOwnedByYourFaction), area.Id);
                return;
            }
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
            user.SendChatMessage(nameof(Messages.AreaRenamed), area.Id, name);
            Log($"{Util.Format(user)} renamed {area.Id} to {name}");

            area.Name = name;
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnClaimShowCommand(User user, string[] args)
        {
            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/claim show XY");
                return;
            }

            Area area = Areas.Get(Util.NormalizeAreaId(args[0]));

            switch (area.Type)
            {
                case AreaType.Badlands:
                    user.SendChatMessage(nameof(Messages.AreaIsBadlands), area.Id);
                    return;
                case AreaType.Claimed:
                    user.SendChatMessage(nameof(Messages.AreaIsClaimed), area.Id, area.FactionId);
                    return;
                case AreaType.Headquarters:
                    user.SendChatMessage(nameof(Messages.AreaIsHeadquarters), area.Id, area.FactionId);
                    return;
                default:
                    user.SendChatMessage(nameof(Messages.AreaIsWilderness), area.Id);
                    return;
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System;

    public partial class Imperium
    {
        private void OnClaimUpkeepCommand(User user)
        {
            if (!Options.Upkeep.Enabled)
            {
                user.SendChatMessage(nameof(Messages.UpkeepDisabled));
                return;
            }

            Faction faction = Factions.GetByMember(user);

            if (faction == null)
            {
                user.SendChatMessage(nameof(Messages.NotMemberOfFaction));
                return;
            }

            if (faction.MemberCount < Options.Claims.MinFactionMembers)
            {
                user.SendChatMessage(nameof(Messages.FactionTooSmallToOwnLand), Options.Claims.MinFactionMembers);
                return;
            }

            Area[] areas = Areas.GetAllClaimedByFaction(faction);

            if (areas.Length == 0)
            {
                user.SendChatMessage(nameof(Messages.NoAreasClaimed));
                return;
            }

            int upkeep = faction.GetUpkeepPerPeriod();
            var nextPaymentHours = (int)faction.NextUpkeepPaymentTime.Subtract(DateTime.UtcNow).TotalHours;

            if (nextPaymentHours > 0)
                user.SendChatMessage(nameof(Messages.UpkeepCost), upkeep, areas.Length, faction.Id, nextPaymentHours);
            else
                user.SendChatMessage(nameof(Messages.UpkeepCostOverdue), upkeep, areas.Length, faction.Id, nextPaymentHours);
        }
    }
}
#endregion
#region /faction
namespace Oxide.Plugins
{
    using System.Linq;

    public partial class Imperium
    {
        [ChatCommand("faction")]
        private void OnFactionCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            if (user == null) return;

            if (args.Length == 0)
            {
                OnFactionShowCommand(user);
                return;
            }

            var restArguments = args.Skip(1).ToArray();

            switch (args[0].ToLower())
            {
                case "create":
                    OnFactionCreateCommand(user, restArguments);
                    break;
                case "join":
                    OnFactionJoinCommand(user, restArguments);
                    break;
                case "leave":
                    OnFactionLeaveCommand(user, restArguments);
                    break;
                case "invite":
                    OnFactionInviteCommand(user, restArguments);
                    break;
                case "kick":
                    OnFactionKickCommand(user, restArguments);
                    break;
                case "promote":
                    OnFactionPromoteCommand(user, restArguments);
                    break;
                case "demote":
                    OnFactionDemoteCommand(user, restArguments);
                    break;
                case "disband":
                    OnFactionDisbandCommand(user, restArguments);
                    break;
                case "badlands":
                    OnFactionBadlandsCommand(user, restArguments);
                    break;
                case "help":
                default:
                    OnFactionHelpCommand(user);
                    break;
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System;

    public partial class Imperium
    {
        [ChatCommand("f")]
        private void OnFactionChatCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            if (user == null) return;

            string message = String.Join(" ", args).Trim();

            if (message.Length == 0)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/f MESSAGE...");
                return;
            }

            Faction faction = Factions.GetByMember(user);

            if (faction == null)
            {
                user.SendChatMessage(nameof(Messages.NotMemberOfFaction));
                return;
            }

            faction.SendChatMessage(nameof(Messages.FactionChatMessage), user.UserName, message);
            Puts("[FACTION] {0} - {1}: {2}", faction.Id, user.UserName, message);
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnFactionCreateCommand(User user, string[] args)
        {
            if (Instance.Options.Factions.UseClansPlugin)
            {
                user.SendChatMessage(nameof(Messages.CannotManageFactionUseClansInstead));
                return;
            }
            if (!user.HasPermission(Permission.ManageFactions))
            {
                user.SendChatMessage(nameof(Messages.NoPermission));
                return;
            }

            if (user.Faction != null)
            {
                user.SendChatMessage(nameof(Messages.AlreadyMemberOfFaction));
                return;
            }

            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/faction create NAME");
                return;
            }

            string id = Util.RemoveSpecialCharacters(args[0].Replace(" ", ""));

            if (id.Length < Options.Factions.MinFactionNameLength || id.Length > Options.Factions.MaxFactionNameLength)
            {
                user.SendChatMessage(nameof(Messages.InvalidFactionName), Options.Factions.MinFactionNameLength,
                    Options.Factions.MaxFactionNameLength);
                return;
            }

            if (Factions.Exists(id))
            {
                user.SendChatMessage(nameof(Messages.FactionAlreadyExists), id);
                return;
            }

            PrintToChat(Messages.FactionCreatedAnnouncement, id);
            Log($"{Util.Format(user)} created faction {id}");

            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_victory.prefab");
            Faction faction = Factions.Create(id, user);
            user.SetFaction(faction);
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnFactionDemoteCommand(User user, string[] args)
        {
            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/faction demote \"PLAYER\"");
                return;
            }

            Faction faction = Factions.GetByMember(user);

            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return;
            }

            User member = Users.Find(args[0]);

            if (member == null)
            {
                user.SendChatMessage(nameof(Messages.InvalidUser), args[0]);
                return;
            }

            if (!faction.HasMember(member))
            {
                user.SendChatMessage(nameof(Messages.UserIsNotMemberOfFaction), member.UserName, faction.Id);
                return;
            }

            if (faction.HasOwner(member))
            {
                user.SendChatMessage(nameof(Messages.CannotPromoteOrDemoteOwnerOfFaction), member.UserName, faction.Id);
                return;
            }

            if (!faction.HasManager(member))
            {
                user.SendChatMessage(nameof(Messages.UserIsNotManagerOfFaction), member.UserName, faction.Id);
                return;
            }

            user.SendChatMessage(nameof(Messages.ManagerRemoved), member.UserName, faction.Id);
            Log($"{Util.Format(user)} demoted {Util.Format(member)} in faction {faction.Id}");
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_failed.prefab");
            faction.Demote(member);
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    public partial class Imperium
    {
        private void OnFactionBadlandsCommand(User user, string[] args)
        {
            if (!Instance.Options.Factions.AllowFactionBadlands)
            {
                user.SendChatMessage(nameof(Messages.NoFactionBadlandsAllowed));
                return;
            }
            Faction faction = user.Faction;
            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return;
            }

            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/faction badlands confirm");
                return;
            }
            int elapsedSeconds = Instance.Options.Factions.CommandCooldownSeconds;
            int secondsRemaining = 1;
            if (faction.BadlandsCommandUsedTime != null)
            {
                elapsedSeconds = (int)(DateTime.Now - faction.BadlandsCommandUsedTime).Value.TotalSeconds;
            }

            if (elapsedSeconds < Instance.Options.Factions.CommandCooldownSeconds)
            {
                secondsRemaining = Instance.Options.Factions.CommandCooldownSeconds - elapsedSeconds;
                user.SendChatMessage(nameof(Messages.CommandIsOnCooldown), secondsRemaining);
                return;
            }

            if (faction.IsBadlands)
            {
                user.SendChatMessage(nameof(Messages.FactionIsNotBadlands));
                faction.IsBadlands = false;
                faction.BadlandsCommandUsedTime = DateTime.Now;
                Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_victory.prefab");
            }
            else
            {
                user.SendChatMessage(nameof(Messages.FactionIsBadlands));
                faction.IsBadlands = true;
                faction.BadlandsCommandUsedTime = DateTime.Now;
                Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_accept.prefab");
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnFactionDisbandCommand(User user, string[] args)
        {
            if (args.Length != 1 || args[0].ToLowerInvariant() != "forever")
            {
                user.SendChatMessage(nameof(Messages.Usage), "/faction disband forever");
                return;
            }
            if (Clans)
            {
                user.SendChatMessage(nameof(Messages.CannotManageFactionUseClansInstead));
                return;
            }
            Faction faction = user.Faction;

            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return;
            }

            PrintToChat(Messages.FactionDisbandedAnnouncement, faction.Id);
            Log($"{Util.Format(user)} disbanded faction {faction.Id}");
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_failed.prefab");
            Factions.Disband(faction);
        }
    }
}

namespace Oxide.Plugins
{
    using System.Text;

    public partial class Imperium
    {
        private void OnFactionHelpCommand(User user)
        {
            var sb = new StringBuilder();

            sb.AppendLine("Available commands:");
            sb.AppendLine("  <color=#ffd479>/faction</color>: Show information about your faction");
            sb.AppendLine(
                "  <color=#ffd479>/f MESSAGE...</color>: Send a message to all online members of your faction");

            if (user.HasPermission(Permission.ManageFactions))
                sb.AppendLine("  <color=#ffd479>/faction create</color>: Create a new faction");

            sb.AppendLine("  <color=#ffd479>/faction join FACTION</color>: Join a faction if you have been invited");
            sb.AppendLine("  <color=#ffd479>/faction leave</color>: Leave your current faction");
            sb.AppendLine(
                "  <color=#ffd479>/faction invite \"PLAYER\"</color>: Invite another player to join your faction");
            sb.AppendLine("  <color=#ffd479>/faction kick \"PLAYER\"</color>: Kick a player out of your faction");
            sb.AppendLine("  <color=#ffd479>/faction promote \"PLAYER\"</color>: Promote a faction member to manager");
            sb.AppendLine("  <color=#ffd479>/faction demote \"PLAYER\"</color>: Remove a faction member as manager");
            sb.AppendLine(
                "  <color=#ffd479>/faction disband forever</color>: Disband your faction immediately (no undo!)");
            sb.AppendLine("  <color=#ffd479>/faction help</color>: Prints this message");

            user.SendChatMessage(sb);
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnFactionInviteCommand(User user, string[] args)
        {
            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/faction invite \"PLAYER\"");
                return;
            }
            if (Clans)
            {
                user.SendChatMessage(nameof(Messages.CannotManageFactionUseClansInstead));
                return;
            }
            Faction faction = Factions.GetByMember(user);

            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return;
            }

            User member = Users.Find(args[0]);

            if (member == null)
            {
                user.SendChatMessage(nameof(Messages.InvalidUser), args[0]);
                return;
            }

            if (faction.HasMember(member))
            {
                user.SendChatMessage(nameof(Messages.UserIsAlreadyMemberOfFaction), member.UserName, faction.Id);
                return;
            }

            int? maxMembers = Options.Factions.MaxMembers;
            if (maxMembers != null && faction.MemberCount >= maxMembers)
            {
                user.SendChatMessage(nameof(Messages.FactionHasTooManyMembers), faction.Id, faction.MemberCount);
                return;
            }

            member.SendChatMessage(nameof(Messages.InviteReceived), user.UserName, faction.Id);
            user.SendChatMessage(nameof(Messages.InviteAdded), member.UserName, faction.Id);
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab", member.Player);

            Log($"{Util.Format(user)} invited {Util.Format(member)} to faction {faction.Id}");

            faction.AddInvite(member);
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnFactionJoinCommand(User user, string[] args)
        {
            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/faction join FACTION");
                return;
            }
            if (Clans)
            {
                user.SendChatMessage(nameof(Messages.CannotManageFactionUseClansInstead));
                return;
            }
            if (user.Faction != null)
            {
                user.SendChatMessage(nameof(Messages.AlreadyMemberOfFaction));
                return;
            }

            Faction faction = Factions.Get(args[0]);

            if (faction == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), args[0]);
                return;
            }

            if (!faction.HasInvite(user))
            {
                user.SendChatMessage(nameof(Messages.CannotJoinFactionNotInvited), faction.Id);
                return;
            }

            user.SendChatMessage(nameof(Messages.YouJoinedFaction), faction.Id);
            PrintToChat(Messages.FactionMemberJoinedAnnouncement, user.UserName, faction.Id);
            Log($"{Util.Format(user)} joined faction {faction.Id}");
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
            faction.AddMember(user);
            user.SetFaction(faction);
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnFactionKickCommand(User user, string[] args)
        {
            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/faction kick \"PLAYER\"");
                return;
            }
            if (Clans)
            {
                user.SendChatMessage(nameof(Messages.CannotManageFactionUseClansInstead));
                return;
            }
            Faction faction = user.Faction;

            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return;
            }

            User member = Users.Find(args[0]);

            if (member == null)
            {
                user.SendChatMessage(nameof(Messages.InvalidUser), args[0]);
                return;
            }

            if (!faction.HasMember(member))
            {
                user.SendChatMessage(nameof(Messages.UserIsNotMemberOfFaction), member.UserName, faction.Id);
                return;
            }

            if (faction.HasLeader(member))
            {
                user.SendChatMessage(nameof(Messages.CannotKickLeaderOfFaction), member.UserName, faction.Id);
                return;
            }

            user.SendChatMessage(nameof(Messages.MemberRemoved), member.UserName, faction.Id);
            PrintToChat(Messages.FactionMemberLeftAnnouncement, member.UserName, faction.Id);

            Log($"{Util.Format(user)} kicked {Util.Format(member)} from faction {faction.Id}");
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_failed.prefab");
            faction.RemoveMember(member);
            member.SetFaction(null);
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnFactionLeaveCommand(User user, string[] args)
        {
            if (args.Length != 0)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/faction leave");
                return;
            }
            if (Clans)
            {
                user.SendChatMessage(nameof(Messages.CannotManageFactionUseClansInstead));
                return;
            }
            Faction faction = user.Faction;

            if (faction == null)
            {
                user.SendChatMessage(nameof(Messages.NotMemberOfFaction));
                return;
            }

            if (faction.MemberCount == 1)
            {
                PrintToChat(Messages.FactionDisbandedAnnouncement, faction.Id);
                Log($"{Util.Format(user)} disbanded faction {faction.Id} by leaving as its only member");
                Factions.Disband(faction);
                return;
            }

            user.SendChatMessage(nameof(Messages.YouLeftFaction), faction.Id);
            PrintToChat(Messages.FactionMemberLeftAnnouncement, user.UserName, faction.Id);

            Log($"{Util.Format(user)} left faction {faction.Id}");
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_failed.prefab");
            faction.RemoveMember(user);
            user.SetFaction(null);
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnFactionPromoteCommand(User user, string[] args)
        {
            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/faction promote \"PLAYER\"");
                return;
            }
            Faction faction = Factions.GetByMember(user);

            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return;
            }

            User member = Users.Find(args[0]);

            if (member == null)
            {
                user.SendChatMessage(nameof(Messages.InvalidUser), args[0]);
                return;
            }

            if (!faction.HasMember(member))
            {
                user.SendChatMessage(nameof(Messages.UserIsNotMemberOfFaction), member.UserName, faction.Id);
                return;
            }

            if (faction.HasOwner(member))
            {
                user.SendChatMessage(nameof(Messages.CannotPromoteOrDemoteOwnerOfFaction), member.UserName, faction.Id);
                return;
            }

            if (faction.HasManager(member))
            {
                user.SendChatMessage(nameof(Messages.UserIsAlreadyManagerOfFaction), member.UserName, faction.Id);
                return;
            }

            user.SendChatMessage(nameof(Messages.ManagerAdded), member.UserName, faction.Id);
            Log($"{Util.Format(user)} promoted {Util.Format(member)} in faction {faction.Id}");
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_victory.prefab");
            faction.Promote(member);
        }
    }
}

namespace Oxide.Plugins
{
    using System.Text;

    public partial class Imperium
    {
        private void OnFactionShowCommand(User user)
        {
            Faction faction = user.Faction;

            if (faction == null)
            {
                user.SendChatMessage(nameof(Messages.NotMemberOfFaction));
                return;
            }

            var sb = new StringBuilder();

            sb.Append("You are ");
            if (faction.HasOwner(user))
                sb.Append("the owner");
            else if (faction.HasManager(user))
                sb.Append("a manager");
            else
                sb.Append("a member");

            sb.AppendLine($" of <color=#ffd479>[{faction.Id}]</color>.");

            User[] activeMembers = faction.GetAllActiveMembers();

            sb.AppendLine(
                $"<color=#ffd479>{faction.MemberCount}</color> member(s), <color=#ffd479>{activeMembers.Length}</color> online:");
            sb.Append("  ");

            foreach (User member in activeMembers)
                sb.Append($"<color=#ffd479>{member.UserName}</color>, ");

            sb.Remove(sb.Length - 2, 2);
            sb.AppendLine();

            if (faction.InviteIds.Count > 0)
            {
                User[] activeInvitedUsers = faction.GetAllActiveInvitedUsers();

                sb.AppendLine(
                    $"<color=#ffd479>{faction.InviteIds.Count}</color> invited player(s), <color=#ffd479>{activeInvitedUsers.Length}</color> online:");
                sb.Append("  ");

                foreach (User invitedUser in activeInvitedUsers)
                    sb.Append($"<color=#ffd479>{invitedUser.UserName}</color>, ");

                sb.Remove(sb.Length - 2, 2);
                sb.AppendLine();
            }

            user.SendChatMessage(sb);
        }
    }
}
#endregion
#region imperium.images.refresh
namespace Oxide.Plugins
{
    public partial class Imperium
    {
        [ConsoleCommand("imperium.images.refresh")]
        private void OnRefreshImagesConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            arg.ReplyWith("Refreshing images...");
            Hud.RefreshAllImages();
        }
    }
}
#endregion
#region /pin
namespace Oxide.Plugins
{
    using System.Linq;

    public partial class Imperium
    {
        [ChatCommand("pin")]
        private void OnPinCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            if (user == null) return;

            if (!Options.Map.PinsEnabled)
            {
                user.SendChatMessage(nameof(Messages.PinsDisabled));
                return;
            }

            ;

            if (args.Length == 0)
            {
                OnPinHelpCommand(user);
                return;
            }

            var restArguments = args.Skip(1).ToArray();

            switch (args[0].ToLower())
            {
                case "add":
                    OnPinAddCommand(user, restArguments);
                    break;
                case "remove":
                    OnPinRemoveCommand(user, restArguments);
                    break;
                case "list":
                    OnPinListCommand(user, restArguments);
                    break;
                case "delete":
                    OnPinDeleteCommand(user, restArguments);
                    break;
                case "help":
                default:
                    OnPinHelpCommand(user);
                    break;
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using UnityEngine;

    public partial class Imperium
    {
        private void OnPinAddCommand(User user, string[] args)
        {
            if (args.Length != 2)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/pin add TYPE \"NAME\"");
                return;
            }

            if (user.Faction == null)
            {
                user.SendChatMessage(nameof(Messages.NotMemberOfFaction));
                return;
            }

            Area area = user.CurrentArea;

            if (area == null)
            {
                user.SendChatMessage(nameof(Messages.YouAreInTheGreatUnknown));
                return;
            }

            if (area.FactionId == null || area.FactionId != user.Faction.Id)
            {
                user.SendChatMessage(nameof(Messages.AreaNotOwnedByYourFaction), area.Id);
                return;
            }

            PinType type;
            if (!Util.TryParseEnum(args[0], out type))
            {
                user.SendChatMessage(nameof(Messages.InvalidPinType), args[0]);
                return;
            }

            string name = Util.NormalizePinName(args[1]);
            if (name == null || name.Length < Options.Map.MinPinNameLength ||
                name.Length > Options.Map.MaxPinNameLength)
            {
                user.SendChatMessage(nameof(Messages.InvalidPinName), Options.Map.MinPinNameLength,
                    Options.Map.MaxPinNameLength);
                return;
            }

            Pin existingPin = Pins.Get(name);
            if (existingPin != null)
            {
                user.SendChatMessage(nameof(Messages.CannotCreatePinAlreadyExists), existingPin.Name, existingPin.AreaId);
                return;
            }

            if (Options.Map.PinCost > 0)
            {
                ItemDefinition scrapDef = ItemManager.FindItemDefinition("scrap");
                List<Item> stacks = user.Player.inventory.FindItemsByItemID(scrapDef.itemid);

                if (!Instance.TryCollectFromStacks(scrapDef, stacks, Options.Map.PinCost))
                {
                    user.SendChatMessage(nameof(Messages.CannotCreatePinCannotAfford), Options.Map.PinCost);
                    return;
                }
            }

            Vector3 position = user.Player.transform.position;

            var pin = new Pin(position, area, user, type, name);
            Pins.Add(pin);

            PrintToChat(Messages.PinAddedAnnouncement, user.Faction.Id, name, type.ToString().ToLower(), area.Id);
        }
    }
}

namespace Oxide.Plugins
{
    using System;

    public partial class Imperium
    {
        private void OnPinDeleteCommand(User user, string[] args)
        {
            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/pin delete \"NAME\"");
                return;
            }

            if (!user.HasPermission(Permission.AdminPins))
            {
                user.SendChatMessage(nameof(Messages.NoPermission));
                return;
            }

            string name = Util.NormalizePinName(args[0]);
            Pin pin = Pins.Get(name);

            if (pin == null)
            {
                user.SendChatMessage(nameof(Messages.UnknownPin), name);
                return;
            }

            Pins.Remove(pin);
            user.SendChatMessage(nameof(Messages.PinRemoved), pin.Name);
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    public partial class Imperium
    {
        private void OnPinHelpCommand(User user)
        {
            var sb = new StringBuilder();

            sb.AppendLine("Available commands:");
            sb.AppendLine("  <color=#ffd479>/pin list [TYPE]</color>: List all pins (or all of a certain type)");
            sb.AppendLine("  <color=#ffd479>/pin add TYPE \"NAME\"</color>: Create a pin at your current location");
            sb.AppendLine("  <color=#ffd479>/pin remove \"NAME\"</color>: Remove a pin you created");
            sb.AppendLine("  <color=#ffd479>/pin help</color>: Prints this message");

            if (user.HasPermission(Permission.AdminPins))
            {
                sb.AppendLine("Admin commands:");
                sb.AppendLine("  <color=#ffd479>/pin delete XY</color>: Delete a pin from an area");
            }

            sb.Append("Available pin types: ");
            foreach (string type in Enum.GetNames(typeof(PinType)).OrderBy(str => str.ToLowerInvariant()))
                sb.AppendFormat("<color=#ffd479>{0}</color>, ", type.ToLowerInvariant());
            sb.Remove(sb.Length - 2, 2);
            sb.AppendLine();

            user.SendChatMessage(sb);
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Linq;
    using System.Text;

    public partial class Imperium
    {
        private void OnPinListCommand(User user, string[] args)
        {
            if (args.Length > 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/pin list [TYPE]");
                return;
            }

            Pin[] pins = Pins.GetAll();

            if (args.Length == 1)
            {
                PinType type;
                if (!Util.TryParseEnum(args[0], out type))
                {
                    user.SendChatMessage(nameof(Messages.InvalidPinType), args[0]);
                    return;
                }

                pins = pins.Where(pin => pin.Type == type).ToArray();
            }

            if (pins.Length == 0)
            {
                user.SendChatMessage("There are no matching pins.");
                return;
            }

            var sb = new StringBuilder();
            sb.AppendLine(String.Format("There are <color=#ffd479>{0}</color> matching map pins:", pins.Length));
            foreach (Pin pin in pins.OrderBy(pin => pin.GetDistanceFrom(user.Player)))
            {
                int distance = (int)Math.Floor(pin.GetDistanceFrom(user.Player));
                sb.AppendLine(String.Format(
                    "  <color=#ffd479>{0} ({1}):</color> {2} (<color=#ffd479>{3}m</color> away)", pin.Name,
                    pin.Type.ToString().ToLowerInvariant(), pin.AreaId, distance));
            }

            user.SendChatMessage(sb);
        }
    }
}

namespace Oxide.Plugins
{
    using System;

    public partial class Imperium
    {
        private void OnPinRemoveCommand(User user, string[] args)
        {
            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/pin remove \"NAME\"");
                return;
            }

            if (user.Faction == null)
            {
                user.SendChatMessage(nameof(Messages.NotMemberOfFaction));
                return;
            }

            string name = Util.NormalizePinName(args[0]);
            Pin pin = Pins.Get(name);

            if (pin == null)
            {
                user.SendChatMessage(nameof(Messages.UnknownPin), name);
                return;
            }

            Area area = Areas.Get(pin.AreaId);
            if (area.FactionId != user.Faction.Id)
            {
                user.SendChatMessage(nameof(Messages.CannotRemovePinAreaNotOwnedByYourFaction), pin.Name, pin.AreaId);
                return;
            }

            Pins.Remove(pin);
            user.SendChatMessage(nameof(Messages.PinRemoved), pin.Name);
        }
    }
}
#endregion
#region /tax
namespace Oxide.Plugins
{
    using System.Linq;

    public partial class Imperium
    {
        [ChatCommand("tax")]
        private void OnTaxCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            if (user == null) return;

            if (!Options.Taxes.Enabled)
            {
                user.SendChatMessage(nameof(Messages.TaxationDisabled));
                return;
            }

            ;

            if (args.Length == 0)
            {
                OnTaxHelpCommand(user);
                return;
            }

            var restArguments = args.Skip(1).ToArray();

            switch (args[0].ToLower())
            {
                case "chest":
                    OnTaxChestCommand(user);
                    break;
                case "rate":
                    OnTaxRateCommand(user, restArguments);
                    break;
                case "help":
                default:
                    OnTaxHelpCommand(user);
                    break;
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnTaxChestCommand(User user)
        {
            Faction faction = Factions.GetByMember(user);

            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return;
            }

            user.SendChatMessage(nameof(Messages.SelectTaxChest));
            user.BeginInteraction(new SelectingTaxChestInteraction(faction));
        }
    }
}

namespace Oxide.Plugins
{
    using System;

    public partial class Imperium
    {
        private void OnTaxRateCommand(User user, string[] args)
        {
            Faction faction = Factions.GetByMember(user);

            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return;
            }

            float taxRate;
            try
            {
                taxRate = Convert.ToInt32(args[0]) / 100f;
            }
            catch
            {
                user.SendChatMessage(nameof(Messages.CannotSetTaxRateInvalidValue), Options.Taxes.MaxTaxRate * 100);
                return;
            }

            if (taxRate < 0 || taxRate > Options.Taxes.MaxTaxRate)
            {
                user.SendChatMessage(nameof(Messages.CannotSetTaxRateInvalidValue), Options.Taxes.MaxTaxRate * 100);
                return;
            }

            user.SendChatMessage(nameof(Messages.SetTaxRateSuccessful), faction.Id, taxRate * 100);
            Log($"{Util.Format(user)} set the tax rate for faction {faction.Id} to {taxRate * 100}%");
            Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
            Factions.SetTaxRate(faction, taxRate);
        }
    }
}

namespace Oxide.Plugins
{
    using System.Text;

    public partial class Imperium
    {
        private void OnTaxHelpCommand(User user)
        {
            var sb = new StringBuilder();

            sb.AppendLine("Available commands:");
            sb.AppendLine("  <color=#ffd479>/tax rate NN</color>: Set the tax rate for your faction");
            sb.AppendLine("  <color=#ffd479>/tax chest</color>: Select a container to use as your faction's tax chest");
            sb.AppendLine("  <color=#ffd479>/tax help</color>: Prints this message");

            user.SendChatMessage(sb);
        }
    }
}
#endregion
#region /recruit
/*
namespace Oxide.Plugins
{
    using System.Linq;

    public partial class Imperium
    {
        [ChatCommand("recruit")]
        void OnRecruitCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            if (user == null) return;

            if (!Options.Recruiting.Enabled)
            {
                user.SendChatMessage(nameof(Messages.RecruitingDisabled);
                return;
            }

            ;

            if (args.Length == 0)
            {
                OnRecruitHereCommand(user);
                return;
            }

            var restArguments = args.Skip(1).ToArray();

            switch (args[0].ToLower())
            {
                case "locker":
                    OnRecruitLockerCommand(user);
                    break;
                case "here":
                    OnRecruitHereCommand(user);
                    break;
                case "help":
                default:
                    OnRecruitHelpCommand(user);
                    break;
            }
        }
    }
}
*/

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnRecruitLockerCommand(User user)
        {
            Faction faction = Factions.GetByMember(user);

            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return;
            }

            user.SendChatMessage(nameof(Messages.SelectArmoryLocker));
            user.BeginInteraction(new SelectingArmoryLockerInteraction(faction));
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private void OnRecruitHereCommand(User user)
        {
            Faction faction = Factions.GetByMember(user);

            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return;
            }
            var npc = (global::HumanNPC)GameManager.server.CreateEntity("assets/rust.ai/agents/npcplayer/humannpc/scientist/scientistnpc_roam.prefab", user.transform.position, UnityEngine.Quaternion.identity, false);
            if (npc)
            {
                npc.gameObject.AwakeFromInstantiate();
                npc.Spawn();
                Recruit recruit = npc.gameObject.AddComponent<Recruit>();
                var nav = npc.GetComponent<BaseNavigator>();
                if (nav == null)
                    return;
                nav.DefaultArea = "Walkable";
                npc.NavAgent.areaMask = 1;
                npc.NavAgent.agentTypeID = -1372625422;
                npc.NavAgent.autoTraverseOffMeshLink = true;
                npc.NavAgent.autoRepath = true;
                npc.NavAgent.enabled = true;
                nav.CanUseCustomNav = true;
            }

        }
    }
}

namespace Oxide.Plugins
{
    using System.Text;

    public partial class Imperium
    {
        private void OnRecruitHelpCommand(User user)
        {
            var sb = new StringBuilder();

            sb.AppendLine("Available commands:");
            sb.AppendLine("  <color=#ffd479>/recruit locker NN</color>: Set the armory locker for the current land");
            sb.AppendLine("  <color=#ffd479>/recruit here</color>: Recruit a faction bot for the current land");
            sb.AppendLine("  <color=#ffd479>/recruit help</color>: Prints this message");

            user.SendChatMessage(sb);
        }
    }
}
#endregion
#region /upgrade
namespace Oxide.Plugins
{
    public partial class Imperium
    {
        [ChatCommand("upgrade")]
        private void OnUpgradeCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            if (user == null) return;
            if (!Instance.Options.Upgrading.Enabled)
            {
                user.SendChatMessage(nameof(Messages.UpgradingDisabled));
                return;
            }
            if (args.Length == 0)
            {
                OnUpgradeHelpCommand(user);
                return;
            }
            switch (args[0])
            {
                case "land":
                    OnUpgradeLandCommand(user);
                    break;
                case "cost":
                    OnUpgradeCostCommand(user);
                    break;
                default:
                    OnUpgradeHelpCommand(user);
                    break;
            }


        }
    }
}

namespace Oxide.Plugins
{
    using System.Text;
    using UnityEngine;
    public partial class Imperium
    {
        private void OnUpgradeCostCommand(User user)
        {
            Area area = Areas.GetByEntityPosition(user.Player);
            if (user.Faction == null)
            {
                user.SendMessage(Messages.NotMemberOfFaction);
                return;
            }
            if (area == null || area.FactionId != user.Faction.Id)
            {
                user.SendChatMessage(nameof(Messages.AreaNotOwnedByYourFaction));
                return;
            }
            if (area.Level >= Instance.Options.Upgrading.MaxUpgradeLevel)
            {
                user.SendChatMessage(nameof(Messages.AreaIsMaximumLevel));
                return;
            }
            var sb = new StringBuilder();
            int costLevels = Instance.Options.Upgrading.Costs.Count - 1;
            sb.AppendLine("Land upgrade costs for " + area.Name + " is");
            sb.AppendLine(area.UpgradeCost + " scrap");
            user.SendChatMessage(sb);
        }
    }
}

namespace Oxide.Plugins
{
    using System.Text;
    using UnityEngine;
    using System.Collections.Generic;
    public partial class Imperium
    {
        private void OnUpgradeLandCommand(User user)
        {
            Area area = Areas.GetByEntityPosition(user.Player);
            if (user.Faction == null)
            {
                user.SendMessage(Messages.NotMemberOfFaction);
                return;
            }
            if (area == null || area.FactionId != user.Faction.Id)
            {
                user.SendChatMessage(nameof(Messages.AreaNotOwnedByYourFaction));
                return;
            }
            if (area.Level >= Instance.Options.Upgrading.MaxUpgradeLevel)
            {
                user.SendChatMessage(nameof(Messages.AreaIsMaximumLevel));
                return;
            }
            if (!Instance.EnsureUserCanChangeFactionClaims(user, user.Faction))
            {
                user.SendMessage(Messages.UserIsNotManagerOfFaction);
                return;
            }
            var cost = area.UpgradeCost;
            if (cost > 0)
            {
                ItemDefinition scrapDef = ItemManager.FindItemDefinition("scrap");
                List<Item> stacks = user.Player.inventory.FindItemsByItemID(scrapDef.itemid);

                if (!Instance.TryCollectFromStacks(scrapDef, stacks, cost))
                {
                    user.SendChatMessage(nameof(Messages.CannotUpgradeAreaCannotAfford), cost);
                    return;
                }
            }
            area.Level++;
            user.SendChatMessage(nameof(Messages.AreaLevelUpgraded), area.Level);
            Util.RunEffect(user.transform.position, "assets/bundled/prefabs/fx/item_unlock.prefab");
        }
    }
}

namespace Oxide.Plugins
{
    using System.Text;
    public partial class Imperium
    {
        private void OnUpgradeHelpCommand(User user)
        {
            var sb = new StringBuilder();

            sb.AppendLine("Available commands:");
            sb.AppendLine("  <color=#ffd479>/upgrade cost</color>: Show cost to upgrade land");
            sb.AppendLine("  <color=#ffd479>/upgrade land</color>: Upgrade land level");
            sb.AppendLine("  <color=#ffd479>/upgrade</color>: Prints this message");
            user.SendChatMessage(sb);
        }
    }
}
#endregion
#region /hud
namespace Oxide.Plugins
{
    public partial class Imperium
    {
        [ChatCommand("hud")]
        private void OnHudCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            if (user == null) return;

            if (!EnforceCommandCooldown(user, "hud", Options.Map.CommandCooldownSeconds))
                return;

            user.Hud.Toggle();
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        [ConsoleCommand("imperium.hud.toggle")]
        private void OnHudToggleConsoleCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            User user = Users.Get(player);
            if (user == null) return;

            if (!EnforceCommandCooldown(user, "hud", Options.Map.CommandCooldownSeconds))
                return;

            user.Hud.Toggle();
        }
    }
}
#endregion
#region imperium.map.togglelayer
namespace Oxide.Plugins
{
    using System;

    public partial class Imperium
    {
        [ConsoleCommand("imperium.map.togglelayer")]
        private void OnMapToggleLayerConsoleCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            User user = Users.Get(player);
            if (user == null) return;

            if (!user.Map.IsVisible)
                return;

            string str = arg.GetString(0);
            UserMapLayer layer;

            if (String.IsNullOrEmpty(str) || !Util.TryParseEnum(arg.Args[0], out layer))
                return;

            user.Preferences.ToggleMapLayer(layer);
            user.Map.Refresh();
        }
    }
}
#endregion
#region /map
namespace Oxide.Plugins
{
    public partial class Imperium
    {
        [ChatCommand("map")]
        private void OnMapCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            if (user == null) return;

            if (!user.Map.IsVisible && !EnforceCommandCooldown(user, "map", Options.Map.CommandCooldownSeconds))
                return;

            user.Map.Toggle();
        }
    }
}
#endregion
#region imperium.map.toggle
namespace Oxide.Plugins
{
    public partial class Imperium
    {
        [ConsoleCommand("imperium.map.toggle")]
        private void OnMapToggleConsoleCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            User user = Users.Get(player);
            if (user == null) return;

            if (!user.Map.IsVisible && !EnforceCommandCooldown(user, "map", Options.Map.CommandCooldownSeconds))
                return;

            user.Map.Toggle();
        }
    }
}
#endregion
#region /war
namespace Oxide.Plugins
{
    using System.Linq;

    public partial class Imperium
    {
        [ChatCommand("war")]
        private void OnWarCommand(BasePlayer player, string command, string[] args)
        {
            User user = Users.Get(player);
            if (user == null) return;

            if (!Options.War.Enabled)
            {
                user.SendChatMessage(nameof(Messages.WarDisabled));
                return;
            }

            if (args.Length == 0)
            {
                OnWarHelpCommand(user);
                return;
            }

            var restArgs = args.Skip(1).ToArray();

            switch (args[0].ToLower())
            {
                case "list":
                    OnWarListCommand(user);
                    break;
                case "status":
                    OnWarStatusCommand(user);
                    break;
                case "declare":
                    OnWarDeclareCommand(user, restArgs);
                    break;
                case "end":
                    OnWarEndCommand(user, restArgs);
                    break;
                case "pending":
                    OnWarPendingCommand(user);
                    break;
                case "approve":
                    OnWarApproveCommand(user, restArgs);
                    break;
                case "deny":
                    OnWarDenyCommand(user, restArgs);
                    break;
                case "admin":
                    OnWarAdminCommand(user, restArgs);
                    break;
                default:
                    OnWarHelpCommand(user);
                    break;
            }
        }
    }
}


namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    public partial class Imperium
    {
        private void OnWarDeclareCommand(User user, string[] args)
        {
            Faction attacker = Factions.GetByMember(user);

            if (!EnsureUserAndFactionCanEngageInDiplomacy(user, attacker))
                return;

            if (args.Length < 2)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/war declare FACTION \"REASON\"");
                return;
            }

            Faction defender = Factions.Get(Util.NormalizeFactionId(args[0]));

            if (defender == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), args[0]);
                return;
            }

            if (attacker.Id == defender.Id)
            {
                user.SendChatMessage(nameof(Messages.CannotDeclareWarAgainstYourself));
                return;
            }

            War existingWar = Wars.GetActiveWarBetween(attacker, defender);

            if (existingWar != null)
            {
                user.SendChatMessage(nameof(Messages.CannotDeclareWarAlreadyAtWar), defender.Id);
                return;
            }

            if (Instance.Options.War.NoobFactionProtectionInSeconds > 0)
            {
                int elapsedSeconds = Instance.Options.War.NoobFactionProtectionInSeconds;
                int secondsRemaining = 1;
                elapsedSeconds = (int)(DateTime.Now - defender.CreationTime).TotalSeconds;

                if (elapsedSeconds < Instance.Options.War.NoobFactionProtectionInSeconds)
                {
                    secondsRemaining = Instance.Options.War.NoobFactionProtectionInSeconds - elapsedSeconds;
                    int minutesRemaining = secondsRemaining / 60;
                    if (secondsRemaining >= 60)
                    {
                        user.SendChatMessage(nameof(Messages.CannotDeclareWarDefenderProtected), defender.Id, secondsRemaining, "minutes");
                        return;
                    }
                    user.SendChatMessage(nameof(Messages.CannotDeclareWarDefenderProtected), defender.Id, secondsRemaining, "seconds");
                    return;
                }
            }


            string cassusBelli = args[1].Trim();

            if (cassusBelli.Length < Options.War.MinCassusBelliLength)
            {
                user.SendChatMessage(nameof(Messages.CannotDeclareWarInvalidCassusBelli), defender.Id);
                return;
            }

            if (Instance.Options.War.OnlineDefendersRequired > 0)
            {
                User[] defenders = Instance.Users.GetAll().Where(u => u.Faction != null && u.Faction.Id == defender.Id).ToArray();
                if (defenders.Length < Instance.Options.War.OnlineDefendersRequired)
                {
                    user.SendChatMessage(nameof(Messages.CannotDeclareWarDefendersNotOnline), Instance.Options.War.OnlineDefendersRequired);
                    return;
                }
            }

            var cost = Instance.Options.War.DeclarationCost;
            if (cost > 0)
            {
                ItemDefinition scrapDef = ItemManager.FindItemDefinition("scrap");
                var stacks = user.Player.inventory.FindItemsByItemID(scrapDef.itemid);

                if (!Instance.TryCollectFromStacks(scrapDef, stacks, cost))
                {
                    user.SendChatMessage(nameof(Messages.CannotDeclareWarCannotAfford), cost);
                    return;
                }
            }
            War war = Wars.DeclareWar(attacker, defender, user, cassusBelli);
            PrintToChat(Messages.WarDeclaredAnnouncement, war.AttackerId, war.DefenderId, war.CassusBelli);
            if (!war.IsActive)
                Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_accept.prefab");
            Log(
                $"{Util.Format(user)} declared war on faction {war.DefenderId} on behalf of {war.AttackerId} for reason: {war.CassusBelli}");


        }
    }
}

namespace Oxide.Plugins
{
    using System.Linq;
    public partial class Imperium
    {
        private void OnWarEndCommand(User user, string[] args)
        {
            Faction faction = Factions.GetByMember(user);

            if (!EnsureUserAndFactionCanEngageInDiplomacy(user, faction))
                return;

            Faction enemy = Factions.Get(Util.NormalizeFactionId(args[0]));

            if (enemy == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), args[0]);
                return;
            }

            War war = Wars.GetActiveWarBetween(faction, enemy);

            if (war == null)
            {
                user.SendChatMessage(nameof(Messages.NotAtWar), enemy.Id);
                return;
            }

            if (war.IsOfferingPeace(faction))
            {
                user.SendChatMessage(nameof(Messages.CannotOfferPeaceAlreadyOfferedPeace), enemy.Id);
                return;
            }

            war.OfferPeace(faction);

            if (war.IsAttackerOfferingPeace && war.IsDefenderOfferingPeace)
            {
                PrintToChat(Messages.WarEndedTreatyAcceptedAnnouncement, faction.Id, enemy.Id);
                Log($"{Util.Format(user)} accepted the peace offering of {enemy.Id} on behalf of {faction.Id}");
                Wars.EndWar(war, WarEndReason.Treaty);
                Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_victory.prefab");
                OnDiplomacyChanged();
            }
            else
            {
                Util.RunEffect(user.transform.position, "assets/prefabs/missions/effects/mission_failed.prefab");
                user.SendChatMessage(nameof(Messages.PeaceOffered), enemy.Id);
                Log($"{Util.Format(user)} offered peace to faction {enemy.Id} on behalf of {faction.Id}");
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System.Text;

    public partial class Imperium
    {
        private void OnWarHelpCommand(User user)
        {
            var sb = new StringBuilder();

            sb.AppendLine("Available commands:");
            sb.AppendLine("  <color=#ffd479>/war list</color>: Show all active wars");
            sb.AppendLine("  <color=#ffd479>/war status</color>: Show all active wars your faction is involved in");
            sb.AppendLine(
                "  <color=#ffd479>/war declare FACTION \"REASON\"</color>: Declare war against another faction");
            sb.AppendLine(
                "  <color=#ffd479>/war end FACTION</color>: Offer to end a war, or accept an offer made to you");
            if (user.HasPermission("imperium.admin.wars"))
            {
                sb.AppendLine(
                "  <color=#ffd479>/war admin pending</color>: List all wars waiting for admin approval");
                sb.AppendLine(
                "  <color=#ffd479>/war admin approve FACTION_1 FACTION_2</color>: Approve a war between two factions");
                sb.AppendLine(
               "  <color=#ffd479>/war admin deny FACTION_1 FACTION_2</color>: Deny a pending war between two factions");
            }
            sb.AppendLine("  <color=#ffd479>/war help</color>: Show this message");

            user.SendChatMessage(sb);
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Text;

    public partial class Imperium
    {
        private void OnWarListCommand(User user)
        {
            var sb = new StringBuilder();
            War[] wars = Wars.GetAllActiveWars();

            if (wars.Length == 0)
            {
                sb.Append("The island is at peace... for now. No wars have been declared.");
            }
            else
            {
                sb.AppendLine(String.Format("<color=#ffd479>The island is at war! {0} wars have been declared:</color>",
                    wars.Length));
                for (var idx = 0; idx < wars.Length; idx++)
                {
                    War war = wars[idx];
                    sb.AppendFormat("{0}. <color=#ffd479>{1}</color> vs <color=#ffd479>{2}</color>: {2}", (idx + 1),
                        war.AttackerId, war.DefenderId, war.CassusBelli);
                    sb.AppendLine();
                }
            }

            user.SendChatMessage(sb);
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Text;

    public partial class Imperium
    {
        private void OnWarStatusCommand(User user)
        {
            Faction faction = Factions.GetByMember(user);

            if (faction == null)
            {
                user.SendChatMessage(nameof(Messages.NotMemberOfFaction));
                return;
            }

            var sb = new StringBuilder();
            War[] wars = Wars.GetAllActiveWarsByFaction(faction);

            if (wars.Length == 0)
            {
                sb.AppendLine("Your faction is not involved in any wars.");
            }
            else
            {
                sb.AppendLine(
                    String.Format("<color=#ffd479>Your faction is involved in {0} wars:</color>", wars.Length));
                for (var idx = 0; idx < wars.Length; idx++)
                {
                    War war = wars[idx];
                    sb.AppendFormat("{0}. <color=#ffd479>{1}</color> vs <color=#ffd479>{2}</color>", (idx + 1),
                        war.AttackerId, war.DefenderId);
                    if (war.IsAttackerOfferingPeace)
                        sb.AppendFormat(": <color=#ffd479>{0}</color> is offering peace!", war.AttackerId);
                    if (war.IsDefenderOfferingPeace)
                        sb.AppendFormat(": <color=#ffd479>{0}</color> is offering peace!", war.DefenderId);
                    sb.AppendLine();
                }
            }

            user.SendChatMessage(sb);
        }
    }
}

namespace Oxide.Plugins
{
    using System.Linq;
    public partial class Imperium
    {
        private void OnWarAdminCommand(User user, string[] args)
        {
            if (!user.HasPermission("imperium.wars.admin"))
            {
                user.SendChatMessage(nameof(Messages.NoPermission));
                return;
            }
            var restArgs = args.Skip(1).ToArray();
            switch (args[0].ToLower())
            {
                case "pending":
                    OnWarAdminPendingCommand(user);
                    break;
                case "approve":
                    OnWarAdminApproveCommand(user, restArgs);
                    break;
                case "deny":
                    OnWarAdminDenyCommand(user, restArgs);
                    break;
                default:
                    OnWarHelpCommand(user);
                    break;
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Text;

    public partial class Imperium
    {
        private void OnWarAdminPendingCommand(User user)
        {
            var sb = new StringBuilder();
            War[] wars = Wars.GetAllAdminUnnaprovedWars();

            if (wars.Length == 0)
            {
                sb.AppendLine("There are no wars waiting for an admin decision");
            }
            else
            {
                sb.AppendLine(
                    String.Format("<color=#ffd479>There are {0} pending wars to approve or deny:</color>", wars.Length));
                for (var idx = 0; idx < wars.Length; idx++)
                {
                    War war = wars[idx];
                    sb.AppendFormat("{0}. <color=#ffd479>{1}</color> vs <color=#ffd479>{2}</color>", (idx + 1),
                        war.AttackerId, war.DefenderId);
                    sb.AppendLine();
                }
            }

            user.SendChatMessage(sb);
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Text;
    using System.Linq;

    public partial class Imperium
    {
        private void OnWarAdminApproveCommand(User user, string[] args)
        {
            if (args.Length != 2)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/war admin approve FACTION_1 FACTION_2");
                return;
            }
            War[] wars = Wars.GetAllAdminUnnaprovedWars();
            Faction f1 = Factions.Get(Util.NormalizeFactionId(args[0]));
            Faction f2 = Factions.Get(Util.NormalizeFactionId(args[1]));
            if (wars.Length == 0)
            {
                user.SendChatMessage("There are no wars waiting for an admin decision");
                return;
            }
            if (f1 == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), args[0]);
                return;
            }
            if (f2 == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), args[1]);
                return;
            }
            var war = wars.SingleOrDefault(w => w.AttackerId == f1.Id && w.DefenderId == f2.Id ||
            w.AttackerId == f2.Id && w.DefenderId == f1.Id);
            if (war == null)
            {
                user.SendChatMessage(nameof(Messages.NoWarBetweenFactions), f1.Id, f2.Id);
                return;
            }
            Instance.Wars.AdminApproveWar(war);
            PrintToChat(Messages.WarDeclaredAdminApproved, war.AttackerId, war.DefenderId, war.CassusBelli);
            Log(
                $"{Util.Format(user)} approved war between faction {war.DefenderId} and {war.AttackerId} for reason: {war.CassusBelli}");
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Text;
    using System.Linq;

    public partial class Imperium
    {
        private void OnWarAdminDenyCommand(User user, string[] args)
        {
            if (args.Length != 2)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/war admin deny FACTION_1 FACTION_2");
                return;
            }
            War[] wars = Wars.GetAllAdminUnnaprovedWars();
            Faction f1 = Factions.Get(Util.NormalizeFactionId(args[0]));
            Faction f2 = Factions.Get(Util.NormalizeFactionId(args[1]));
            if (wars.Length == 0)
            {
                user.SendChatMessage("There are no wars waiting for an admin decision");
                return;
            }
            if (f1 == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), args[0]);
                return;
            }
            if (f2 == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), args[1]);
                return;
            }
            var war = wars.SingleOrDefault(w => w.AttackerId == f1.Id && w.DefenderId == f2.Id ||
            w.AttackerId == f2.Id && w.DefenderId == f1.Id);
            if (war == null)
            {
                user.SendChatMessage(nameof(Messages.NoWarBetweenFactions), f1.Id, f2.Id);
                return;
            }
            Instance.Wars.AdminDenyeWar(war);
            PrintToChat(Messages.WarDeclaredAdminDenied, war.AttackerId, war.DefenderId, war.CassusBelli);
            Log(
                $"{Util.Format(user)} denied war between faction {war.DefenderId} and {war.AttackerId} for reason: {war.CassusBelli}");
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Text;
    using System.Linq;

    public partial class Imperium
    {
        private void OnWarApproveCommand(User user, string[] args)
        {
            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/war approve FACTION");
                return;
            }
            Faction faction = Factions.GetByMember(user);
            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return;
            }
            War[] wars = Wars.GetAllUnapprovedWarsByFaction(faction);
            Faction f1 = Factions.Get(Util.NormalizeFactionId(args[0]));
            if (wars.Length == 0)
            {
                user.SendChatMessage("There are no pending wars against your faction");
                return;
            }
            if (f1 == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), args[0]);
                return;
            }
            var war = wars.SingleOrDefault(w => w.AttackerId == f1.Id && w.DefenderId == faction.Id);
            if (war == null)
            {
                user.SendChatMessage(nameof(Messages.NoWarBetweenFactions), f1.Id, faction.Id);
                return;
            }
            Instance.Wars.DefenderApproveWar(war);
            PrintToChat(Messages.WarDeclaredDefenderApproved, war.AttackerId, war.DefenderId, war.CassusBelli);
            Log(
                 $"{Util.Format(user)} approved war between faction {war.DefenderId} and {war.AttackerId} for reason: {war.CassusBelli}");
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Text;
    using System.Linq;

    public partial class Imperium
    {
        private void OnWarDenyCommand(User user, string[] args)
        {
            if (args.Length != 1)
            {
                user.SendChatMessage(nameof(Messages.Usage), "/war deny FACTION");
                return;
            }
            Faction faction = Factions.GetByMember(user);
            if (faction == null || !faction.HasLeader(user))
            {
                user.SendChatMessage(nameof(Messages.NotLeaderOfFaction));
                return;
            }
            War[] wars = Wars.GetAllUnapprovedWarsByFaction(faction);
            Faction f1 = Factions.Get(Util.NormalizeFactionId(args[0]));
            if (wars.Length == 0)
            {
                user.SendChatMessage("There are no pending wars against your faction");
                return;
            }
            if (f1 == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), args[0]);
                return;
            }
            if (faction == null)
            {
                user.SendChatMessage(nameof(Messages.FactionDoesNotExist), args[1]);
                return;
            }
            var war = wars.SingleOrDefault(w => w.AttackerId == f1.Id && w.DefenderId == faction.Id);
            if (war == null)
            {
                user.SendChatMessage(nameof(Messages.NoWarBetweenFactions), f1.Id, faction.Id);
                return;
            }
            Instance.Wars.DefenderDenyWar(war);
            PrintToChat(Messages.WarDeclaredDefenderDenied, war.AttackerId, war.DefenderId, war.CassusBelli);
            Log(
                $"{Util.Format(user)} denied war between faction {war.DefenderId} and {war.AttackerId} for reason: {war.CassusBelli}");
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Text;

    public partial class Imperium
    {
        private void OnWarPendingCommand(User user)
        {
            Faction faction = Factions.GetByMember(user);

            if (faction == null)
            {
                user.SendChatMessage(nameof(Messages.NotMemberOfFaction));
                return;
            }

            var sb = new StringBuilder();
            War[] wars = Wars.GetAllUnapprovedWarsByFaction(faction);

            if (wars.Length == 0)
            {
                sb.AppendLine("Your faction has no unapproved wars.");
            }
            else
            {
                sb.AppendLine(
                    String.Format("<color=#ffd479>Your faction has {0} pending wars:</color>", wars.Length));
                for (var idx = 0; idx < wars.Length; idx++)
                {
                    War war = wars[idx];
                    sb.AppendFormat("{0}. <color=#ffd479>{1}</color> vs <color=#ffd479>{2}</color>", (idx + 1),
                        war.AttackerId, war.DefenderId);
                    if (!war.AdminApproved)
                        sb.AppendFormat(": <color=#ffd479>admin approval pending</color>");
                    if (!war.DefenderApproved)
                        sb.AppendFormat(": defender <color=#ffd479>{0}</color> approval pending", war.DefenderId);
                    sb.AppendLine();
                }
            }

            user.SendChatMessage(sb);
        }
    }
}
#endregion
#endregion

#region > API
namespace Oxide.Plugins
{
    using Oxide.Core.Plugins;

    public partial class Imperium
    {
        [HookMethod(nameof(GetFactionName))]
        public object GetFactionName(BasePlayer player)
        {
            User user = Users.Get(player);

            if (user == null || user.Faction == null)
                return null;
            else
                return user.Faction.Id;
        }
    }
}
#endregion

#region > Events
namespace Oxide.Plugins
{
    using Oxide.Core;

    public partial class Imperium : RustPlugin
    {
        private static class Events
        {
            public static void OnAreaChanged(Area area)
            {
                Interface.CallHook(nameof(OnAreaChanged), area);
            }

            public static void OnUserEnteredArea(User user, Area area)
            {
                Interface.CallHook(nameof(OnUserEnteredArea), user, area);
            }

            public static void OnUserLeftArea(User user, Area area)
            {
                Interface.CallHook(nameof(OnUserLeftArea), user, area);
            }

            public static void OnUserEnteredZone(User user, Zone zone)
            {
                Interface.CallHook(nameof(OnUserEnteredZone), user, zone);
            }

            public static void OnUserLeftZone(User user, Zone zone)
            {
                Interface.CallHook(nameof(OnUserLeftZone), user, zone);
            }

            public static void OnFactionCreated(Faction faction)
            {
                Interface.CallHook(nameof(OnFactionCreated), faction);
            }

            public static void OnFactionDisbanded(Faction faction)
            {
                Interface.CallHook(nameof(OnFactionDisbanded), faction);
            }

            public static void OnFactionTaxesChanged(Faction faction)
            {
                Interface.CallHook(nameof(OnFactionTaxesChanged), faction);
            }

            public static void OnFactionArmoryChanged(Faction faction)
            {
                Interface.CallHook(nameof(OnFactionArmoryChanged), faction);
            }

            public static void OnFactionBadlandsChanged(Faction faction)
            {
                Interface.CallHook(nameof(OnFactionBadlandsChanged), faction);
            }

            public static void OnPlayerJoinedFaction(Faction faction, User user)
            {
                Interface.CallHook(nameof(OnPlayerJoinedFaction), faction, user);
            }

            public static void OnPlayerLeftFaction(Faction faction, User user)
            {
                Interface.CallHook(nameof(OnPlayerLeftFaction), faction, user);
            }

            public static void OnPlayerInvitedToFaction(Faction faction, User user)
            {
                Interface.CallHook(nameof(OnPlayerInvitedToFaction), faction, user);
            }

            public static void OnPlayerUninvitedFromFaction(Faction faction, User user)
            {
                Interface.CallHook(nameof(OnPlayerUninvitedFromFaction), faction, user);
            }

            public static void OnPlayerPromoted(Faction faction, User user)
            {
                Interface.CallHook(nameof(OnPlayerPromoted), faction, user);
            }

            public static void OnPlayerDemoted(Faction faction, User user)
            {
                Interface.CallHook(nameof(OnPlayerDemoted), faction, user);
            }

            public static void OnPinCreated(Pin pin)
            {
                Interface.CallHook(nameof(OnPinCreated), pin);
            }

            public static void OnPinRemoved(Pin pin)
            {
                Interface.CallHook(nameof(OnPinRemoved), pin);
            }
        }
    }
}
#endregion

#region > UMod Hooks
namespace Oxide.Plugins
{
    using Network;
    using Oxide.Core;
    using UnityEngine;
    using Newtonsoft.Json.Linq;
    using Oxide.Core.Libraries.Covalence;
    using System.Collections.Generic;

    public partial class Imperium : RustPlugin
    {
        private void OnUserApprove(Connection connection)
        {
            Users.SetOriginalName(connection.userid.ToString(), connection.username);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;

            // If the player hasn't fully connected yet, try again in 2 seconds.
            if (player.IsReceivingSnapshot)
            {
                timer.In(2, () => OnPlayerConnected(player));
                return;
            }
            Users.Add(player);
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            User user = player.GetComponent<User>();
            if (user != null && !user.UpdatedMarkers)
            {
                Areas.UpdateAreaMarkers();
                user.UpdatedMarkers = true;
            }

        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (player != null)
                Users.Remove(player);
        }

        private object OnTeamCreate(BasePlayer player)
        {
            if (Instance.Options.Factions.OverrideInGameTeamSystem)
            {
                User user = Instance.Users.Get(player);
                if (user)
                {
                    user.SendChatMessage("You can't create a team. Say <color=#ffd479>/i</color> to create your faction");
                }
                return true;
            }
            return null;
        }

        private object OnTeamInvite(BasePlayer inviter, BasePlayer target)
        {
            if (Instance.Options.Factions.OverrideInGameTeamSystem)
            {
                return true;
            }
            return null;
        }

        private object OnTeamPromote(RelationshipManager.PlayerTeam team, BasePlayer newLeader)
        {
            if (Instance.Options.Factions.OverrideInGameTeamSystem)
            {
                return true;
            }
            return null;
        }

        private object OnTeamKick(ulong currentTeam, ulong newTeam, BasePlayer player)
        {
            if (Instance.Options.Factions.OverrideInGameTeamSystem)
            {
                return true;
            }
            return null;
        }

        private object OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            if (Instance.Options.Factions.OverrideInGameTeamSystem)
            {
                return true;
            }
            return null;
        }

        private object OnTeamDisband(RelationshipManager.PlayerTeam team)
        {
            if (Instance.Options.Factions.OverrideInGameTeamSystem)
            {
                return true;
            }
            return null;
        }

        private void OnHammerHit(BasePlayer player, HitInfo hit)
        {
            User user = Users.Get(player);
            if (user != null && user.CurrentInteraction != null)
                user.CompleteInteraction(hit);
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hit)
        {
            if (entity == null || hit == null)
                return null;

            object externalResult = Interface.CallHook("CanEntityTakeDamage", new object[] { entity, hit });

            if (externalResult != null)
            {
                if ((bool)externalResult == false)
                    return true;

                return null;
            }
            externalResult = GetExternalHookResult("OnEntityTakeDamage", new object[] { entity, hit });
            if (externalResult != null)
                return externalResult;

            if (hit.damageTypes.Has(Rust.DamageType.Decay))
                return Decay.AlterDecayDamage(entity, hit);

            User attacker = null;
            User defender = entity.GetComponent<User>();

            if (hit.InitiatorPlayer != null)
                attacker = hit.InitiatorPlayer.GetComponent<User>();

            // A player is being injured by something other than a player/NPC.
            if (attacker == null && defender != null)
                return Pvp.HandleIncidentalDamage(defender, hit);

            // One player is damaging another player.
            if (attacker != null && defender != null)
                return Pvp.HandleDamageBetweenPlayers(attacker, defender, hit);

            // A player is damaging a structure.
            if (attacker != null && defender == null)
                return Raiding.HandleDamageAgainstStructure(attacker, entity, hit);

            // A structure is taking damage from something that isn't a player.
            return Raiding.HandleIncidentalDamage(entity, hit);
        }

        private object OnTrapTrigger(BaseTrap trap, GameObject obj)
        {
            var player = obj.GetComponent<BasePlayer>();

            if (trap == null || player == null)
                return null;

            User defender = Users.Get(player);
            return Pvp.HandleTrapTrigger(trap, defender);
        }

        private object CanBeTargeted(BaseCombatEntity target, MonoBehaviour turret)
        {
            if (target == null || turret == null)
                return null;

            // Don't interfere with the helicopter.
            if (turret is HelicopterTurret)
                return null;

            var player = target as BasePlayer;

            if (player == null)
                return null;

            if (Users == null)
            {
                return null;
            }

            var defender = Users.Get(player);
            var entity = turret as BaseCombatEntity;

            if (defender == null || entity == null)
                return null;

            return Pvp.HandleTurretTarget(entity, defender);
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null)
                return;
            if (Hud == null)
                return;
            if (Options == null)
                return;
            var plane = entity as CargoPlane;
            if (plane != null)
                Hud.GameEvents.BeginEvent(plane);

            var drop = entity as SupplyDrop;
            if (Options.Zones.Enabled && drop != null)
                Zones.CreateForSupplyDrop(drop);

            var heli = entity as BaseHelicopter;
            if (heli != null)
                Hud.GameEvents.BeginEvent(heli);

            var chinook = entity as CH47Helicopter;
            if (chinook != null)
                Hud.GameEvents.BeginEvent(chinook);

            var crate = entity as HackableLockedCrate;
            if (crate != null)
                Hud.GameEvents.BeginEvent(crate);
            var cargoship = entity as CargoShip;
            if (Options.Zones.Enabled && cargoship != null)
                Zones.CreateForCargoShip(cargoship);
        }

        private object OnEntityReskin(BaseEntity entity, ItemSkinDirectory.Skin skin, BasePlayer player)
        {
            BuildingPrivlidge cupboard = entity as BuildingPrivlidge;
            if(cupboard == null)
                return null;
            Area area = Instance.Areas.GetByClaimCupboard(cupboard);
            if(area == null)
                return null;
            //Mark area as changing cupboard skin so the old cupboard Kill() does not trigger Unclaim()
            area.IsCupboardChangingSkin = true;
            //Remember player that reskinned the cupboard
            area.ClaimReskinningPlayer = player;
            area.ReskinnedCupboardLastPosition = cupboard.transform.position;
            return null;
        }

        private object OnEntityReskinned(BaseEntity entity, ItemSkinDirectory.Skin skin, BasePlayer player)
        {
            BuildingPrivlidge cupboard = entity as BuildingPrivlidge;
            if(cupboard == null)
                return null;
            
            Area area = null;

            if(player != null)
                area = Instance.Areas.GetByClaimReskinningPlayer(player);
            if(area == null)
                area = Instance.Areas.GetByReskinnedCupboardLastPosition(cupboard.transform.position);
            if(area == null)
                return null;
            if(!area.IsCupboardChangingSkin)
                return null;
            area.IsCupboardChangingSkin = false;
            area.ClaimReskinningPlayer = null;
            area.ClaimCupboard = cupboard;
            return null;
        }

        private void OnEntityKill(BaseNetworkable networkable)
        {
            var entity = networkable as BaseEntity;

            if (!Ready || entity == null)
                return;

            // If a claim TC was destroyed, remove the claim from the area.
            var cupboard = entity as BuildingPrivlidge;
            if (cupboard != null)
            {
                var area = Areas.GetByClaimCupboard(cupboard);
                if (area != null)
                {
                    if(area.IsCupboardChangingSkin)
                    {
                        PrintWarning("Attempt to unclaim area blocked because cupboard was reskinned!");
                        return;
                    }
                    PrintToChat(Messages.AreaClaimLostCupboardDestroyedAnnouncement, area.FactionId, area.Id);
                    Log(
                        $"{area.FactionId} lost their claim on {area.Id} because the tool cupboard was destroyed (hook function)");
                    Areas.Unclaim(area);
                }

                return;
            }

            // If a tax chest was destroyed, remove it from the faction data.
            var container = entity as StorageContainer;
            if (Options.Taxes.Enabled && container != null)
            {
                Faction faction = Factions.GetByTaxChest(container);
                if (faction != null)
                {
                    Log($"{faction.Id}'s tax chest was destroyed (hook function)");
                    faction.TaxChest = null;
                }

                return;
            }

            // If an armory locker was destroyed, remove it from the faction data.
            var locker = entity as Locker;
            if (Options.Recruiting.Enabled && locker != null)
            {
                var area = Areas.GetByArmoryLocker(locker);
                if (area != null)
                {
                    Instance.Puts("locker area is not null");
                    Log($"{area.FactionId}'s armory locker was destroyed at {area.Id} (hook function)");
                    Instance.Areas.RemoveArmory(area);
                }

                return;
            }

            // If a helicopter was destroyed, create an event zone around it.
            var helicopter = entity as BaseHelicopter;
            if (Options.Zones.Enabled && helicopter != null)
                Zones.CreateForDebrisField(helicopter);
        }

        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            Taxes.ProcessTaxesIfApplicable(dispenser, entity, item);
            Taxes.AwardBadlandsBonusIfApplicable(dispenser, entity, item);
        }

        private void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            Taxes.ProcessTaxesIfApplicable(dispenser, entity, item);
            Taxes.AwardBadlandsBonusIfApplicable(dispenser, entity, item);
        }

        private object OnEntityDeath(BasePlayer player, HitInfo hit)
        {
            if (player == null)
                return null;

            // When a player dies, remove them from the area and any zones they were in.
            User user = Users.Get(player);
            if (user != null)
            {
                user.CurrentArea = null;
                user.CurrentZones.Clear();
            }

            return null;
        }

        private object OnShopAcceptClick(ShopFront entity, BasePlayer player)
        {
            if (!Instance.Options.War.EnableShopfrontPeace)
                return null;

            var user1 = Instance.Users.Get(entity.vendorPlayer);
            var user2 = Instance.Users.Get(entity.customerPlayer);

            if (user1 == null || user2 == null)
                return null;
            if (user1.Faction == null || user2.Faction == null)
                return null;
            if (!Instance.Wars.AreFactionsAtWar(user1.Faction, user2.Faction))
                return null;
            if (user1.Faction.HasLeader(user1) && user2.Faction.HasLeader(user2))
                return null;
            user1.SendChatMessage("Only owners or managers of both enemy factions can trade right now. Trading will end the war");
            user2.SendChatMessage("Only owners or managers of both enemy factions can trade right now. Trading will end the war");
            return true;
        }

        private object OnShopCompleteTrade(ShopFront entity)
        {
            Instance.Wars.TryShopfrontTreaty(entity.vendorPlayer, entity.customerPlayer);
            return null;
        }

        private void OnUserEnteredArea(User user, Area area)
        {

            Area previousArea = user.CurrentArea;

            user.CurrentArea = area;
            user.Hud.Refresh();

            if (area == null || previousArea == null)
                return;
            if (area.Type == AreaType.Badlands && previousArea.Type != AreaType.Badlands)
            {
                // The player has entered the badlands.
                user.SendChatMessage(nameof(Messages.EnteredBadlands));
            }
            else if (area.Type == AreaType.Wilderness && previousArea.Type != AreaType.Wilderness)
            {
                // The player has entered the wilderness.
                user.SendChatMessage(nameof(Messages.EnteredWilderness));
            }
            else if (area.IsClaimed && !previousArea.IsClaimed)
            {
                // The player has entered a faction's territory.
                user.SendChatMessage(nameof(Messages.EnteredClaimedArea), area.FactionId);
            }
            else if (area.IsClaimed && previousArea.IsClaimed && area.FactionId != previousArea.FactionId)
            {
                // The player has crossed a border between the territory of two factions.
                user.SendChatMessage(nameof(Messages.EnteredClaimedArea), area.FactionId);
            }
        }

        private void OnUserLeftArea(User user, Area area)
        {

        }

        private void OnUserEnteredZone(User user, Zone zone)
        {
            user.CurrentZones.Add(zone);
            user.Hud.Refresh();
        }

        private void OnUserLeftZone(User user, Zone zone)
        {
            user.CurrentZones.Remove(zone);
            user.Hud.Refresh();
        }

        private void OnFactionCreated(Faction faction)
        {
            Hud.RefreshForAllPlayers();
        }

        private void OnFactionDisbanded(Faction faction)
        {
            Area[] areas = Instance.Areas.GetAllClaimedByFaction(faction);

            if (areas.Length > 0)
            {
                foreach (Area area in areas)
                    PrintToChat(Messages.AreaClaimLostFactionDisbandedAnnouncement, area.FactionId, area.Id);

                Areas.Unclaim(areas);
            }

            Wars.EndAllWarsForEliminatedFactions();
            Hud.RefreshForAllPlayers();
        }

        private void OnFactionTaxesChanged(Faction faction)
        {
            Hud.RefreshForAllPlayers();
        }

        private void OnFactionArmoryChanged(Faction faction)
        {

        }

        private void OnAreaChanged(Area area)
        {
            Areas.UpdateAreaMarkers();
            Wars.EndAllWarsForEliminatedFactions();
            Pins.RemoveAllPinsInUnclaimedAreas();
            Hud.GenerateMapOverlayImage();
            Hud.RefreshForAllPlayers();
        }

        private void OnDiplomacyChanged()
        {
            Hud.RefreshForAllPlayers();
        }

        #region CLANS by k1lly0u HOOKS

        private void OnPluginLoaded(CSharpPlugin plugin)
        {
            if (plugin == Clans)
            {
                if (Instance)
                    Instance.Factions.SyncAllWithClans();
            }
        }

        private void OnClanCreate(string tag)
        {
            if (Instance.Options.Factions.UseClansPlugin)
            {
                Faction faction = Factions.Get(tag);
                JObject clanInfo = Clans.CallHook("GetClan", tag) as JObject;
                if (clanInfo != null)
                {
                    string ownerid = clanInfo.GetValue("owner").Value<string>();
                    User owner = Users.Get(ownerid);
                    faction = Factions.Create(tag, owner);
                    owner.SetFaction(faction);
                }
            }
        }

        private void OnClanDisbanded(string tag, List<string> memberUserIDs)
        {
            if (Clans)
            {
                Factions.Disband(Factions.Get(tag));
            }
        }

        private void OnClanMemberJoined(string userID, string tag)
        {
            if (Clans)
            {
                User user = Users.Get(userID);
                Faction faction = Factions.Get(tag);
                if (faction != null && user != null)
                {
                    faction.AddMember(user);
                    user.SetFaction(faction);
                }
            }
        }

        private void OnClanMemberGone(string userID, string tag)
        {
            if (Instance.Options.Factions.UseClansPlugin)
            {
                User user = Users.Get(userID);
                Faction faction = Factions.Get(tag);
                if (faction != null && user != null)
                {
                    if (faction.HasOwner(user))
                    {
                        JObject jClan = (JObject)Clans.CallHook("GetClan", tag);
                        string clanOwnerId = jClan["owner"].Value<string>();
                        if (clanOwnerId != null)
                        {
                            faction.OwnerId = clanOwnerId;
                        }
                    }
                    faction.RemoveMember(user);
                    user.SetFaction(null);
                }
            }
        }

        #endregion
        #region > Raidable Bases Hooks

        private void OnPlayerEnteredRaidableBase(BasePlayer player, Vector3 raidPos, bool allowPVP, int mode)
        {
            User user = Instance.Users.Get(player);
            if(user == null)
                return;
            user.IsInsideRaidableBase = true;
        }
        private void OnPlayerExitedRaidableBase(BasePlayer player, Vector3 raidPos, bool allowPVP, int mode)
        {
            User user = Instance.Users.Get(player);
            if(user == null)
                return;
            user.IsInsideRaidableBase = false;
            
        }

        #endregion

        #region > NPCSpawn Hooks

        private object OnCustomNpcTarget(BasePlayer npc, BasePlayer target)
        {
            return null;
        }

        #endregion
    }
}
#endregion

#region > Decay
namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private static class Decay
        {
            public static object AlterDecayDamage(BaseEntity entity, HitInfo hit)
            {
                if (!Instance.Options.Decay.Enabled)
                    return null;

                if (entity == null || hit == null)
                    return null;


                Area area = GetAreaForDecayCalculation(entity);

                if (area == null)
                {
                    //Instance.PrintWarning($"An entity decayed in an unknown area. This shouldn't happen.");
                    return null;
                }

                float reduction = 0;

                if (area.Type == AreaType.Claimed || area.Type == AreaType.Headquarters)
                    reduction = Instance.Options.Decay.ClaimedLandDecayReduction;

                if (Instance.Options.Upgrading.Enabled && Instance.Options.Upgrading.MaxDecayExtraReduction > 0)
                    reduction += area.GetLevelDecayReduction();

                if (reduction >= 1)
                    return true;

                if (reduction > 0)
                    hit.damageTypes.Scale(Rust.DamageType.Decay, reduction);

                return null;
            }

            private static Area GetAreaForDecayCalculation(BaseEntity entity)
            {
                Area area = null;

                // If the entity is controlled by a claim cupboard, use the area the cupboard controls.
                BuildingPrivlidge cupboard = entity.GetBuildingPrivilege();
                if (cupboard)
                    area = Instance.Areas.GetByClaimCupboard(cupboard);

                // Otherwise, determine the area by its position in the world.
                if (area == null)
                    area = Instance.Areas.GetByEntityPosition(entity);

                return area;
            }
        }
    }
}
#endregion

#region > Messages
namespace Oxide.Plugins
{
    using System.Linq;
    using System.Reflection;
    using System.Collections.Generic;

    public partial class Imperium : RustPlugin
    {
        private static class Messages
        {
            public const string AreaClaimsDisabled = "Area claims are currently disabled.";
            public const string TaxationDisabled = "Taxation is currently disabled.";
            public const string RecruitingDisabled = "Recruiting is currently disabled.";
            public const string BadlandsDisabled = "Badlands are currently disabled.";
            public const string UpkeepDisabled = "Upkeep is currently disabled.";
            public const string WarDisabled = "War is currently disabled.";
            public const string PinsDisabled = "Map pins are currently disabled.";
            public const string PvpModeDisabled = "PVP Mode is currently not available.";
            public const string UpgradingDisabled = "Area upgrading is currently disabled.";

            public const string AreaIsBadlands = "<color=#ffd479>{0}</color> is a part of the badlands.";

            public const string AreaIsClaimed =
                "<color=#ffd479>{0}</color> has been claimed by <color=#ffd479>[{1}]</color>.";

            public const string AreaIsHeadquarters =
                "<color=#ffd479>{0}</color> is the headquarters of <color=#ffd479>[{1}]</color>.";

            public const string AreaIsWilderness = "<color=#ffd479>{0}</color> has not been claimed by a faction.";
            public const string AreaNotBadlands = "<color=#ffd479>{0}</color> is not a part of the badlands.";
            public const string AreaNotOwnedByYourFaction = "<color=#ffd479>{0}</color> is not owned by your faction.";
            public const string AreaNotWilderness = "<color=#ffd479>{0}</color> is not currently wilderness.";

            public const string AreaNotContiguous =
                "<color=#ffd479>{0}</color> is not connected to territory owned by <color=#ffd479>[{1}]</color>.";

            public const string YouAreInTheGreatUnknown = "You are currently in the great unknown!";

            public const string InteractionCanceled = "Command canceled.";
            public const string NoInteractionInProgress = "You aren't currently executing any commands.";
            public const string NoAreasClaimed = "Your faction has not claimed any areas.";

            public const string FactionChatMessage = "<color=#a1ff46>(FACTION)</color> {0}: {1}";

            public const string NotMemberOfFaction = "You are not a member of a faction.";
            public const string AlreadyMemberOfFaction = "You are already a member of a faction.";
            public const string NotLeaderOfFaction = "You must be an owner or a manager of a faction.";
            public const string FactionTooSmallToOwnLand = "To own land, a faction must have least {0} members.";

            public const string FactionOwnsTooMuchLand =
                "<color=#ffd479>[{0}]</color> already owns the maximum number of areas (<color=#ffd479>{1}</color>).";

            public const string FactionHasTooManyMembers =
                "<color=#ffd479>[{0}]</color> already has the maximum number of members (<color=#ffd479>{1}</color>).";
            public const string AreaIsMaximumLevel =
                "This land is already at maximum level";

            public const string FactionIsBadlands = "Your faction territory is now badlands";
            public const string FactionIsNotBadlands = "Your faction territory is no longer badlands";
            public const string NoFactionBadlandsAllowed = "Faction enforced badlands is disabled in this server";
            public const string FactionDoesNotOwnLand = "Your faction must own at least one area.";
            public const string FactionAlreadyExists = "There is already a faction named <color=#ffd479>[{0}]</color>.";
            public const string FactionDoesNotExist = "There is no faction named <color=#ffd479>[{0}]</color>.";
            public const string InvalidUser = "Couldn't find a user whose name matches \"{0}\".";

            public const string InvalidFactionName =
                "Faction names must be between {0} and {1} alphanumeric characters.";

            public const string NotAtWar = "You are not currently at war with <color=#ffd479>[{0}]</color>!";

            public const string Usage = "Usage: <color=#ffd479>{0}</color>";
            public const string CommandIsOnCooldown = "You can't do that again so quickly. Try again in {0} seconds.";
            public const string NoPermission = "You don't have permission to do that.";

            public const string MemberAdded =
                "You have added <color=#ffd479>{0}</color> as a member of <color=#ffd479>[{1}]</color>.";

            public const string MemberRemoved =
                "You have removed <color=#ffd479>{0}</color> as a member of <color=#ffd479>[{1}]</color>.";

            public const string ManagerAdded =
                "You have added <color=#ffd479>{0}</color> as a manager of <color=#ffd479>[{1}]</color>.";

            public const string ManagerRemoved =
                "You have removed <color=#ffd479>{0}</color> as a manager of <color=#ffd479>[{1}]</color>.";

            public const string UserIsAlreadyMemberOfFaction =
                "<color=#ffd479>{0}</color> is already a member of <color=#ffd479>[{1}]</color>.";

            public const string UserIsNotMemberOfFaction =
                "<color=#ffd479>{0}</color> is not a member of <color=#ffd479>[{1}]</color>.";

            public const string UserIsAlreadyManagerOfFaction =
                "<color=#ffd479>{0}</color> is already a manager of <color=#ffd479>[{1}]</color>.";

            public const string UserIsNotManagerOfFaction =
                "<color=#ffd479>{0}</color> is not a manager of <color=#ffd479>[{1}]</color>.";

            public const string CannotPromoteOrDemoteOwnerOfFaction =
                "<color=#ffd479>{0}</color> cannot be promoted or demoted, since they are the owner of <color=#ffd479>[{1}]</color>.";

            public const string CannotKickLeaderOfFaction =
                "<color=#ffd479>{0}</color> cannot be kicked, since they are an owner or manager of <color=#ffd479>[{1}]</color>.";

            public const string InviteAdded =
                "You have invited <color=#ffd479>{0}</color> to join <color=#ffd479>[{1}]</color>.";

            public const string InviteReceived =
                "<color=#ffd479>{0}</color> has invited you to join <color=#ffd479>[{1}]</color>. Say <color=#ffd479>/faction join {1}</color> to accept.";

            public const string CannotJoinFactionNotInvited =
                "You cannot join <color=#ffd479>[{0}]</color>, because you have not been invited.";

            public const string CannotManageFactionUseClansInstead =
                "This server uses the Clans plugin. Manage your faction through the Clans system instead. Say /clanhelp for more info";

            public const string YouJoinedFaction = "You are now a member of <color=#ffd479>[{0}]</color>.";
            public const string YouLeftFaction = "You are no longer a member of <color=#ffd479>[{0}]</color>.";

            public const string SelectingCupboardFailedInvalidTarget = "You must select a tool cupboard.";
            public const string SelectingCupboardFailedNotAuthorized = "You must be authorized on the tool cupboard.";
            public const string SelectingCupboardFailedCantUnclaimHeadquarters = "You must move your headquarters to another land first. Say <color=#ffd479>/claim hq</color> in another land";

            public const string SelectingCupboardFailedNotClaimCupboard =
                "That tool cupboard doesn't represent an area claim made by your faction.";

            public const string CannotClaimAreaAlreadyClaimed =
                "<color=#ffd479>{0}</color> has already been claimed by <color=#ffd479>[{1}]</color>.";

            public const string CannotClaimAreaCannotAfford =
                "Claiming this area costs <color=#ffd479>{0}</color> scrap. Add this amount to your inventory and try again.";

            public const string CannotUpgradeAreaCannotAfford =
                "Upgrading this area costs <color=#ffd479>{0}</color> scrap. Add this amount to your inventory and try again.";

            public const string CannotClaimAreaAlreadyOwned =
                "The area <color=#ffd479>{0}</color> is already owned by your faction, and this cupboard represents the claim.";

            public const string SelectClaimCupboardToAdd =
                "Use the hammer to select a tool cupboard to represent the claim. Say <color=#ffd479>/cancel</color> to cancel.";

            public const string SelectClaimCupboardToRemove =
                "Use the hammer to select the tool cupboard representing the claim you want to remove. Say <color=#ffd479>/cancel</color> to cancel.";

            public const string SelectClaimCupboardForHeadquarters =
                "Use the hammer to select the tool cupboard to represent your faction's headquarters. Say <color=#ffd479>/cancel</color> to cancel.";

            public const string SelectClaimCupboardToAssign =
                "Use the hammer to select a tool cupboard to represent the claim to assign to <color=#ffd479>[{0}]</color>. Say <color=#ffd479>/cancel</color> to cancel.";

            public const string SelectClaimCupboardToTransfer =
                "Use the hammer to select the tool cupboard representing the claim to give to <color=#ffd479>[{0}]</color>. Say <color=#ffd479>/cancel</color> to cancel.";

            public const string ClaimCupboardMoved =
                "You have moved the claim <color=#ffd479>{0}</color> to a new tool cupboard.";

            public const string ClaimCaptured =
                "You have captured <color=#ffd479>{0}</color> from <color=#ffd479>[{1}]</color>!";

            public const string ClaimAdded = "You have claimed <color=#ffd479>{0}</color> for your faction.";
            public const string ClaimRemoved = "You have removed your faction's claim on <color=#ffd479>{0}</color>.";

            public const string ClaimTransferred =
                "You have transferred ownership of <color=#ffd479>{0}</color> to <color=#ffd479>[{1}]</color>.";

            public const string InvalidAreaName =
                "Area names must be between <color=#ffd479>{0}</color> and <color=#ffd479>{1}</color> characters long.";

            public const string UnknownArea = "Unknown area <color=#ffd479>{0}</color>.";
            public const string AreaRenamed = "<color=#ffd479>{0}</color> is now known as <color=#ffd479>{1}</color>.";

            public const string ClaimsList = "<color=#ffd479>[{0}]</color> has claimed: <color=#ffd479>{1}</color>";

            public const string ClaimCost =
                "<color=#ffd479>{0}</color> can be claimed by <color=#ffd479>[{1}]</color> for <color=#ffd479>{2}</color> scrap.";

            public const string UpkeepCost =
                "It will cost <color=#ffd479>{0}</color> scrap per day to maintain the <color=#ffd479>{1}</color> areas claimed by <color=#ffd479>[{2}]</color>. Upkeep is due <color=#ffd479>{3}</color> hours from now.";

            public const string UpkeepCostOverdue =
                "It will cost <color=#ffd479>{0}</color> scrap per day to maintain the <color=#ffd479>{1}</color> areas claimed by <color=#ffd479>[{2}]</color>. Your upkeep is <color=#ffd479>{3}</color> hours overdue! Fill your Headquarters Cupboard with scrap immediately, before your claims begin to fall into ruin.";
            public const string SelectArmoryLocker =
                "Use the hammer to select the locker to set as this land armory. Say <color=#ffd479>/cancel</color> to cancel.";

            public const string SelectTaxChest =
                "Use the hammer to select the container to receive your faction's tribute. Say <color=#ffd479>/cancel</color> to cancel.";

            public const string SelectingTaxChestFailedInvalidTarget = "That can't be used as a tax chest.";

            public const string SelectingTaxChestSucceeded =
                "You have selected a new tax chest that will receive <color=#ffd479>{0}%</color> of the materials harvested within land owned by <color=#ffd479>[{1}]</color>. To change the tax rate, say <color=#ffd479>/tax rate PERCENT</color>.";
            public const string SelectingArmoryLockerFailedInvalidTarget =
                "That can't be used as an armory";

            public const string SelectingArmoryLockerSucceeded =
                "You have selected a new armory locker that will be used to recruit bots in {0}";

            public const string CannotSetTaxRateInvalidValue =
                "You must specify a valid percentage between <color=#ffd479>0-{0}%</color> as a tax rate.";

            public const string SetTaxRateSuccessful =
                "You have set the tax rate on the land holdings of <color=#ffd479>[{0}]</color> to <color=#ffd479>{1}%</color>.";

            public const string BadlandsSet = "Badlands areas are now: <color=#ffd479>{0}</color>";

            public const string BadlandsList =
                "Badlands areas are: <color=#ffd479>{0}</color>. Gather bonus is <color=#ffd479>{1}%</color>.";

            public const string CannotDeclareWarAgainstYourself = "You cannot declare war against yourself!";

            public const string CannotDeclareWarAlreadyAtWar =
                "You area already at war with <color=#ffd479>[{0}]</color>!";

            public const string CannotDeclareWarNoobAttacker =
                "You cannot declare war yet because your faction is not old enough. Try again in <color=#ffd479>[{0}]</color> {1}!";


            public const string CannotDeclareWarDefenderProtected =
                "You cannot declare war against <color=#ffd479>[{0}]</color> because this faction is not old enough. Try again in <color=#ffd479>[{1}]</color> {2}!";

            public const string CannotDeclareWarInvalidCassusBelli =
                "You cannot declare war against <color=#ffd479>[{0}]</color>, because your reason doesn't meet the minimum length.";

            public const string CannotDeclareWarCannotAfford =
                "Declaring war costs <color=#ffd479>{0}</color> scrap. Add this amount to your inventory and try again.";

            public const string CannotDeclareWarDefendersNotOnline =
                "Declaring war requires at least <color=#ffd479>{0}</color> defending member online. Try again when your enemies are online";
            public const string CannotOfferPeaceAlreadyOfferedPeace =
                "You have already offered peace to <color=#ffd479>[{0}]</color>.";

            public const string PeaceOffered =
                "You have offered peace to <color=#ffd479>[{0}]</color>. They must accept it before the war will end.";

            public const string EnteredBadlands =
                "<color=#ff0000>BORDER:</color> You have entered the badlands! Player violence is allowed here.";

            public const string EnteredWilderness = "<color=#ffd479>BORDER:</color> You have entered the wilderness.";

            public const string EnteredClaimedArea =
                "<color=#ffd479>BORDER:</color> You have entered land claimed by <color=#ffd479>[{0}]</color>.";

            public const string EnteredPvpMode =
                "<color=#ff0000>PVP ENABLED:</color> You are now in PVP mode. You can now hurt, and be hurt by, other players who are also in PVP mode.";

            public const string ExitedPvpMode =
                "<color=#00ff00>PVP DISABLED:</color> You are no longer in PVP mode. You can't be harmed by other players except inside of normal PVP areas.";

            public const string PvpModeOnCooldown = "You must wait at least {0} seconds to exit or re-enter PVP mode.";

            public const string InvalidPinType =
                "Unknown map pin type <color=#ffd479>{0}</color>. Say <color=#ffd479>/pin types</color> to see a list of available types.";

            public const string InvalidPinName =
                "Map pin names must be between <color=#ffd479>{0}</color> and <color=#ffd479>{1}</color> characters long.";

            public const string CannotCreatePinCannotAfford =
                "Creating a new map pin costs <color=#ffd479>{0}</color> scrap. Add this amount to your inventory and try again.";

            public const string CannotCreatePinAlreadyExists =
                "Cannot create a new map pin named <color=#ffd479>{0}</color>, since one already exists with the same name in <color=#ffd479>{1}</color>.";

            public const string UnknownPin = "Unknown map pin <color=#ffd479>{0}</color>.";

            public const string CannotRemovePinAreaNotOwnedByYourFaction =
                "Cannot remove the map pin named <color=#ffd479>{0}</color>, because the area <color=#ffd479>{1} is not owned by your faction.";

            public const string PinRemoved = "Removed map pin <color=#ffd479>{0}</color>.";

            public const string FactionCreatedAnnouncement =
                "<color=#00ff00>FACTION CREATED:</color> A new faction <color=#ffd479>[{0}]</color> has been created!";

            public const string FactionDisbandedAnnouncement =
                "<color=#00ff00>FACTION DISBANDED:</color> <color=#ffd479>[{0}]</color> has been disbanded!";

            public const string FactionMemberJoinedAnnouncement =
                "<color=#00ff00>MEMBER JOINED:</color> <color=#ffd479>{0}</color> has joined <color=#ffd479>[{1}]</color>!";

            public const string FactionMemberLeftAnnouncement =
                "<color=#00ff00>MEMBER LEFT:</color> <color=#ffd479>{0}</color> has left <color=#ffd479>[{1}]</color>!";

            public const string AreaClaimedAnnouncement =
                "<color=#00ff00>AREA CLAIMED:</color> <color=#ffd479>[{0}]</color> claims <color=#ffd479>{1}</color>!";

            public const string AreaClaimedAsHeadquartersAnnouncement =
                "<color=#00ff00>AREA CLAIMED:</color> <color=#ffd479>[{0}]</color> claims <color=#ffd479>{1}</color> as their headquarters!";

            public const string AreaLevelUpgraded =
                "Land upgraded to level {0}";

            public const string AreaCapturedAnnouncement =
                "<color=#ff0000>AREA CAPTURED:</color> <color=#ffd479>[{0}]</color> has captured <color=#ffd479>{1}</color> from <color=#ffd479>[{2}]</color>!";

            public const string AreaClaimRemovedAnnouncement =
                "<color=#ff0000>CLAIM REMOVED:</color> <color=#ffd479>[{0}]</color> has relinquished their claim on <color=#ffd479>{1}</color>!";

            public const string AreaClaimTransferredAnnouncement =
                "<color=#ff0000>CLAIM TRANSFERRED:</color> <color=#ffd479>[{0}]</color> has transferred their claim on <color=#ffd479>{1}</color> to <color=#ffd479>[{2}]</color>!";

            public const string AreaClaimAssignedAnnouncement =
                "<color=#ff0000>AREA CLAIM ASSIGNED:</color> <color=#ffd479>{0}</color> has been assigned to <color=#ffd479>[{1}]</color> by an admin.";

            public const string AreaClaimDeletedAnnouncement =
                "<color=#ff0000>AREA CLAIM REMOVED:</color> <color=#ffd479>[{0}]</color>'s claim on <color=#ffd479>{1}</color> has been removed by an admin.";

            public const string AreaClaimLostCupboardDestroyedAnnouncement =
                "<color=#ff0000>AREA CLAIM LOST:</color> <color=#ffd479>[{0}]</color> has lost its claim on <color=#ffd479>{1}</color>, because the tool cupboard was destroyed!";

            public const string AreaClaimLostArmoryDestroyedAnnouncement =
                "<color=#ff0000>AREA ARMORY LOST:</color> <color=#ffd479>[{0}]</color> has lost its armory on <color=#ffd479>{1}</color>, because the locker was destroyed!";

            public const string AreaClaimLostFactionDisbandedAnnouncement =
                "<color=#ff0000>AREA CLAIM LOST:</color> <color=#ffd479>[{0}]</color> has been disbanded, losing its claim on <color=#ffd479>{1}</color>!";

            public const string AreaClaimLostUpkeepNotPaidAnnouncement =
                "<color=#ff0000>AREA CLAIM LOST:</color>: <color=#ffd479>[{0}]</color> has lost their claim on <color=#ffd479>{1}</color> after it fell into ruin! Tool Cupboard destroyed!";

            public const string HeadquartersChangedAnnouncement =
                "<color=#00ff00>HQ CHANGED:</color> The headquarters of <color=#ffd479>[{0}]</color> is now <color=#ffd479>{1}</color>.";

            public const string NoWarBetweenFactions =
                "There are no war declarations between <color=#ffd479>[{0}]</color> and <color=#ffd479>[{1}]</color> ";

            public const string WarDeclaredAnnouncement =
                "<color=#ff0000>WAR DECLARED:</color> <color=#ffd479>[{0}]</color> has declared war on <color=#ffd479>[{1}]</color>! Their reason: <color=#ffd479>{2}</color>";

            public const string WarDeclaredAdminApproved =
                "<color=#ff0000>WAR APPROVED BY AN ADMIN:</color> An admin approved the war between <color=#ffd479>[{0}]</color> and <color=#ffd479>[{1}]</color>!";

            public const string WarDeclaredAdminDenied =
                "<color=#ff0000>WAR DENIED BY AN ADMIN:</color> An admin denied the war between <color=#ffd479>[{0}]</color> and <color=#ffd479>[{1}]</color>!";

            public const string WarDeclaredDefenderApproved =
                "<color=#ff0000>WAR APPROVED BY DEFENDERS:</color> <color=#ffd479>[{1}]</color> accepted the war declaration from <color=#ffd479>[{0}]</color>";

            public const string WarDeclaredDefenderDenied =
                "<color=#ff0000>WAR DENIED BY DEFENDERS:</color>  <color=#ffd479>[{1}]</color> rejected the war declaration from <color=#ffd479>[{0}]</color>";

            public const string WarEndedTreatyAcceptedAnnouncement =
                "<color=#00ff00>WAR ENDED:</color> The war between <color=#ffd479>[{0}]</color> and <color=#ffd479>[{1}]</color> has ended after both sides have agreed to a treaty.";

            public const string WarEndedFactionEliminatedAnnouncement =
                "<color=#00ff00>WAR ENDED:</color> The war between <color=#ffd479>[{0}]</color> and <color=#ffd479>[{1}]</color> has ended, since <color=#ffd479>[{2}]</color> no longer holds any land.";

            public const string PinAddedAnnouncement =
                "<color=#00ff00>POINT OF INTEREST:</color> <color=#ffd479>[{0}]</color> announces the creation of <color=#ffd479>{1}</color>, a new {2} located in <color=#ffd479>{3}</color>!";


            public static string Get(string key, string userId = null)
            {
                return Instance.lang.GetMessage(key, Instance, userId);
            }

            public static Dictionary<string, string> AsDictionary(BindingFlags bindingAttr = BindingFlags.Public | BindingFlags.DeclaredOnly)
            {
                var dict = typeof(Messages).GetFields().Select(f => new { Key = f.Name, Value = (string)f.GetValue(null) }).ToDictionary
                (
                    item => item.Key,
                    item => item.Value
                );
                return dict;

            }
        }

        private void InitLang()
        {
            Dictionary<string, string> messages = Messages.AsDictionary();
            lang.RegisterMessages(messages, this);

        }
    }
}
#endregion

#region > Pvp
namespace Oxide.Plugins
{
    using System;
    using System.Linq;

    public partial class Imperium
    {
        private static class Pvp
        {
            private static string[] BlockedPrefabs = new[]
            {
                "fireball_small",
                "fireball_small_arrow",
                "fireball_small_shotgun",
                "fireexplosion",
                "fireball_small_molotov"
            };

            public static object HandleDamageBetweenPlayers(User attacker, User defender, HitInfo hit)
            {
                if (!Instance.Options.Pvp.RestrictPvp)
                    return null;

                if (attacker == null || defender == null || hit == null)
                    return null;
                

                // Allow players to take the easy way out.
                if (hit.damageTypes.Has(Rust.DamageType.Suicide))
                    return null;

                // If the players are both in factions who are currently at war, they can damage each other anywhere.
                if (attacker.Faction != null && defender.Faction != null &&
                    Instance.Wars.AreFactionsAtWar(attacker.Faction, defender.Faction))
                    return null;

                // If both the attacker and the defender are in PVP mode, or in a PVP area/zone, they can damage one another.
                if (IsUserInDanger(attacker) && IsUserInDanger(defender))
                    return null;

                // Stop the damage.
                return true;
            }

            public static object HandleIncidentalDamage(User defender, HitInfo hit)
            {
                if (defender == null || hit == null)
                    return null;

                if (!Instance.Options.Pvp.RestrictPvp)
                    return null;

                if (hit.Initiator == null)
                    return null;

                // If the damage is coming from something other than a blocked prefab, allow it.
                if (!BlockedPrefabs.Contains(hit.Initiator.ShortPrefabName))
                    return null;

                //If player is inside a Raidable Base and the damage was initiated by a trap or turret, allow it.
                if(Instance.RaidableBases != null && defender.IsInsideRaidableBase &&
                     (hit.Initiator is AutoTurret ||
                      hit.Initiator is GunTrap ||
                      hit.Initiator is BaseTrap ||
                      hit.Initiator is FlameTurret ||
                      hit.Initiator is SamSite ||
                      hit.Initiator is Barricade || 
                      hit.Initiator is TeslaCoil))
                      {
                         return null;
                      }


                // If the player is in a PVP area or in PVP mode, allow the damage.
                if (IsUserInDanger(defender))
                    return null;

                return true;
            }

            public static object HandleTrapTrigger(BaseTrap trap, User defender)
            {
                if (!Instance.Options.Pvp.RestrictPvp)
                    return null;

                // A player can always trigger their own traps, to prevent exploiting this mechanic.
                if (defender == null || defender.Player == null || defender.Player.userID == trap.OwnerID)
                    return null;
                
                //Players can always trigger traps when inside a Raidable Base
                if(Instance.RaidableBases != null && defender.IsInsideRaidableBase)
                    return null;

                Area trapArea = Instance.Areas.GetByEntityPosition(trap);

                // If the defender is in a faction, they can trigger traps placed in areas claimed by factions with which they are at war.
                if (trapArea == null || defender.Faction != null && trapArea.FactionId != null &&
                    Instance.Wars.AreFactionsAtWar(defender.Faction.Id, trapArea.FactionId))
                    return null;


                // If the defender is in a PVP area or zone, the trap can trigger.
                // TODO: Ensure the trap is also in the PVP zone.
                if (IsUserInDanger(defender))
                    return null;

                // Stop the trap from triggering.
                return true;
            }

            public static object HandleTurretTarget(BaseCombatEntity turret, User defender)
            {
                if (!Instance.Options.Pvp.RestrictPvp)
                    return null;

                // A player can be always be targeted by their own turrets, to prevent exploiting this mechanic.
                if (defender.Player.userID == turret.OwnerID)
                    return null;

                Area turretArea = Instance.Areas.GetByEntityPosition(turret);

                //Players inside RaidableBases can be targeted by turrets
                if(defender.IsInsideRaidableBase)
                    return null;

                if (turretArea == null || defender.CurrentArea == null)
                    return null;

                // If the defender is in a faction, they can be targeted by turrets in areas claimed by factions with which they are at war.
                if (defender.Faction != null && turretArea.FactionId != null &&
                    Instance.Wars.AreFactionsAtWar(defender.Faction.Id, turretArea.FactionId))
                    return null;

                // If the defender is in a PVP area or zone, the turret can trigger.
                // TODO: Ensure the turret is also in the PVP zone.
                if (IsUserInDanger(defender))
                    return null;

                return false;
            }

            public static bool IsUserInDanger(User user)
            {
                return user.IsInPvpMode || 
                IsPvpArea(user.CurrentArea) || 
                user.CurrentZones.Any(IsPvpZone);
            }

            public static bool IsPvpZone(Zone zone)
            {
                switch (zone.Type)
                {
                    case ZoneType.Debris:
                    case ZoneType.SupplyDrop:
                        return Instance.Options.Pvp.AllowedInEventZones;
                    case ZoneType.Monument:
                        return Instance.Options.Pvp.AllowedInMonumentZones;
                    case ZoneType.Raid:
                        return Instance.Options.Pvp.AllowedInRaidZones;
                    default:
                        throw new InvalidOperationException($"Unknown zone type {zone.Type}");
                }
            }

            public static bool IsPvpArea(Area area)
            {
                if (area == null)
                    return Instance.Options.Pvp.AllowedInDeepWater;

                switch (area.Type)
                {
                    case AreaType.Badlands:
                        return Instance.Options.Pvp.AllowedInBadlands;
                    case AreaType.Claimed:
                    case AreaType.Headquarters:
                        {
                            if (Instance.Options.Pvp.AllowedInClaimedLand)
                            {
                                return true;
                            }
                            else if (Instance.Options.Factions.AllowFactionBadlands && Instance.Factions.Get(area.FactionId).IsBadlands)
                            {
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    case AreaType.Wilderness:
                        return Instance.Options.Pvp.AllowedInWilderness;
                    default:
                        throw new InvalidOperationException($"Unknown area type {area.Type}");
                }
            }
        }
    }
}
#endregion

#region > Raiding
namespace Oxide.Plugins
{
    using System;
    using System.Linq;

    public partial class Imperium
    {
        private static class Raiding
        {
            // Setting this to true will disable the rules which normally allow owners of land to damage their own structures
            // This means that for the purposes of structural damage, the player will be considered a hostile force, which
            // in turn allows easy testing of raiding rules. Should usually be false unless you're testing something.
            private const bool EnableTestMode = false;

            private enum DamageResult
            {
                Prevent,
                NotProtected,
                Friendly,
                BeingAttacked
            }

            private static string[] BlockedPrefabs = new[]
            {
                "fireball_small",
                "fireball_small_arrow",
                "fireball_small_shotgun",
                "fireexplosion"
            };
            private static string[] ProtectedPrefabs = new[]
            {
                "barricade.concrete",
                "barricade.metal",
                "barricade.sandbags",
                "barricade.stone",
                "barricade.wood",
                "barricade.woodwire",
                "bbq",
                "bed",
                "box.wooden.large",
                "ceilinglight",
                "chair",
                "cupboard",
                "door.double.hinged",
                "door.hinged",
                "dropbox",
                "fireplace",
                "floor.ladder.hatch",
                "floor.grill",
                "fridge",
                "furnace",
                "gates.external",
                "jackolantern",
                "lantern",
                "locker",
                "mailbox",
                "planter.large",
                "planter.small",
                "reactivetarget",
                "refinery",
                "repairbench",
                "researchtable",
                "rug",
                "searchlight",
                "shelves",
                "shutter",
                "sign.hanging",
                "sign.huge.wood",
                "sign.large.wood",
                "sign.medium.wood",
                "sign.pictureframe",
                "sign.pole.banner.large",
                "sign.post",
                "sign.small.wood",
                "stash.small",
                "spikes.floor",
                "spinner.wheel",
                "survivalfishtrap",
                "table",
                "tunalight",
                "vendingmachine",
                "wall.external",
                "wall.frame",
                "wall.window",
                "watchtower.wood",
                "water.barrel",
                "water.catcher",
                "water.purifier",
                "waterbarrel",
                "waterpurifier",
                "window.bars",
                "woodbox",
                "workbench",
                "switch",
                "orswitch",
                "andswitch",
                "xorswitch",
                "timer",
                "splitter",
                "blocker",
                "cabletunnel",
                "doorcontroller",
                "generator",
                "laserdetector",
                "pressurepad",
                "simplelight",
                "solarpanel",
                "electrical.branch",
                "electrical.combiner",
                "electrical.memorycell",
                "smallrechargablebattery",
                "large.rechargable.battery"
            };
            private static string[] RaidTriggeringPrefabs = new[]
            {
                "cupboard",
                "door.double.hinged",
                "door.hinged",
                "floor.ladder.hatch",
                "floor.grill",
                "gates.external",
                "vendingmachine",
                "wall.frame",
                "wall.external",
                "wall.window",
                "window.bars"
            };

            public static object HandleDamageAgainstStructure(User attacker, BaseEntity entity, HitInfo hit)
            {
                if (attacker == null || entity == null || hit == null)
                    return null;

                Area area = Instance.Areas.GetByEntityPosition(entity);

                if (area == null && entity.gameObject.GetComponent<BaseCombatEntity>() == null)
                {
                    //Instance.PrintWarning("An entity was damaged in an unknown area. This shouldn't happen.");
                    return null;
                }

                DamageResult result = DetermineDamageResult(attacker, area, entity);
                if (EnableTestMode)
                    Instance.Log("Damage from a player to structure with prefab {0}: {1}", entity.ShortPrefabName,
                        result.ToString());

                if (result == DamageResult.NotProtected)
                {
                    return null;
                }

                if (result == DamageResult.Friendly)
                {
                    if (entity.OwnerID == attacker.Player.userID)
                    {
                        return null;
                    }
                    if (!attacker.Faction.HasLeader(attacker) && (!area.IsWarZone && !area.IsHostile))
                    {
                        if (hit.damageTypes.Has(Rust.DamageType.Explosion) || hit.damageTypes.Has(Rust.DamageType.Heat))
                        {
                            hit.damageTypes.ScaleAll(Instance.Options.Factions.MemberOwnLandExplosiveRaidingDamageScale);
                            return null;
                        }
                        hit.damageTypes.ScaleAll(Instance.Options.Factions.MemberOwnLandEcoRaidingDamageScale);
                        return null;
                    }
                    return null;
                }

                if (result == DamageResult.Prevent)
                    return true;

                float reduction = area.GetDefensiveBonus();

                if (reduction >= 1)
                    return true;

                if (reduction > 0)
                    hit.damageTypes.ScaleAll(reduction);

                if (Instance.Options.Zones.Enabled)
                {
                    BuildingPrivlidge cupboard = entity.GetBuildingPrivilege();

                    if (cupboard != null && IsRaidTriggeringEntity(entity))
                    {
                        float remainingHealth = entity.Health() - hit.damageTypes.Total();
                        if (remainingHealth < 1)
                            Instance.Zones.CreateForRaid(cupboard);
                    }
                }

                return null;
            }

            private static DamageResult DetermineDamageResult(User attacker, Area area, BaseEntity entity)
            {
                // Players can always damage their own entities.
                if (!EnableTestMode && attacker.Player.userID == entity.OwnerID)
                    return DamageResult.Friendly;

                if (area == null || !IsProtectedEntity(entity))
                    return DamageResult.NotProtected;

                if (attacker.Faction != null)
                {
                    // Factions can damage any structure built on their own land.
                    if (!EnableTestMode && area.FactionId != null && attacker.Faction.Id == area.FactionId)
                        return DamageResult.Friendly;

                    // Factions who are at war can damage any structure on enemy land, subject to the defensive bonus.
                    if (area.FactionId != null && Instance.Wars.AreFactionsAtWar(attacker.Faction.Id, area.FactionId))
                        return DamageResult.BeingAttacked;

                    // Factions who are at war can damage any structure built by a member of an enemy faction, subject
                    // to the defensive bonus.
                    BasePlayer owner = BasePlayer.FindByID(entity.OwnerID);
                    if (owner != null)
                    {
                        Faction owningFaction = Instance.Factions.GetByMember(owner.UserIDString);
                        if (owningFaction != null && Instance.Wars.AreFactionsAtWar(attacker.Faction, owningFaction))
                            return DamageResult.BeingAttacked;
                    }
                }

                // If the structure is in a raidable area, it can be damaged subject to the defensive bonus.
                if (IsRaidableArea(area))
                    return DamageResult.BeingAttacked;

                // Prevent the damage.
                return DamageResult.Prevent;
            }

            public static object HandleIncidentalDamage(BaseEntity entity, HitInfo hit)
            {
                if (entity == null || hit == null)
                    return null;
                if (!Instance.Options.Raiding.RestrictRaiding)
                    return null;

                Area area = Instance.Areas.GetByEntityPosition(entity);

                if (area == null)
                {
                    //Instance.PrintWarning("An entity was damaged in an unknown area. This shouldn't happen.");
                    return null;
                }

                if (hit.Initiator == null)
                {
                    if (EnableTestMode)
                        Instance.Log("Incidental damage to {0} with no initiator", entity.ShortPrefabName);

                    return null;
                }

                // If the damage is coming from something other than a blocked prefab, allow it.
                if (!BlockedPrefabs.Contains(hit.Initiator.ShortPrefabName))
                {

                    if (EnableTestMode)
                    {
                        Instance.Log("Incidental damage to {0} caused by {1}, allowing since it isn't a blocked prefab",
                            entity.ShortPrefabName, hit.Initiator.ShortPrefabName);
                    }


                    return null;
                }

                // If the player is in a PVP area or in PVP mode, allow the damage.
                if (IsRaidableArea(area))
                {
                    if (EnableTestMode)
                        Instance.Log(
                            "Incidental damage to {0} caused by {1}, allowing since target is in raidable area",
                            entity.ShortPrefabName, hit.Initiator.ShortPrefabName);

                    return null;
                }

                if (EnableTestMode)
                    Instance.Log("Incidental damage to {0} caused by {1}, stopping since it is a blocked prefab",
                        entity.ShortPrefabName, hit.Initiator.ShortPrefabName);

                return true;
            }

            private static bool IsProtectedEntity(BaseEntity entity)
            {
                var buildingBlock = entity as BuildingBlock;

                // All building blocks except for twig are protected.
                if (buildingBlock != null)
                    return buildingBlock.grade != BuildingGrade.Enum.Twigs;

                // Some additional entities (doors, boxes, etc.) are also protected.
                if (ProtectedPrefabs.Any(prefab => entity.ShortPrefabName.Contains(prefab)))
                    return true;

                return false;
            }

            private static bool IsRaidTriggeringEntity(BaseEntity entity)
            {
                var buildingBlock = entity as BuildingBlock;

                // All building blocks except for twig are protected.
                if (buildingBlock != null)
                    return buildingBlock.grade != BuildingGrade.Enum.Twigs;

                // Destriction of some additional entities (doors, etc.) will also trigger raids.
                if (RaidTriggeringPrefabs.Any(prefab => entity.ShortPrefabName.Contains(prefab)))
                    return true;

                return false;
            }

            private static bool IsRaidableArea(Area area)
            {
                if (!Instance.Options.Raiding.RestrictRaiding)
                    return true;

                switch (area.Type)
                {
                    case AreaType.Badlands:
                        return Instance.Options.Raiding.AllowedInBadlands;
                    case AreaType.Claimed:
                    case AreaType.Headquarters:
                        return Instance.Options.Raiding.AllowedInClaimedLand;
                    case AreaType.Wilderness:
                        return Instance.Options.Raiding.AllowedInWilderness;
                    default:
                        throw new InvalidOperationException($"Unknown area type {area.Type}");
                }
            }


        }
    }
}
#endregion

#region > Tax
namespace Oxide.Plugins
{
    using UnityEngine;
    public partial class Imperium
    {
        private static class Taxes
        {
            public static void ProcessTaxesIfApplicable(ResourceDispenser dispenser, BaseEntity entity, Item item)
            {
                if (!Instance.Options.Taxes.Enabled)
                    return;

                var player = entity as BasePlayer;
                if (player == null)
                    return;

                User user = Instance.Users.Get(player);
                if (user == null)
                    return;

                Area area = user.CurrentArea;
                if (area == null || !area.IsClaimed)
                    return;

                Faction faction = Instance.Factions.Get(area.FactionId);
                if (!faction.CanCollectTaxes || faction.TaxChest.inventory.IsFull())
                    return;

                ItemDefinition itemDef = ItemManager.FindItemDefinition(item.info.itemid);
                if (itemDef == null)
                    return;

                float landBonus = Instance.Options.Taxes.ClaimedLandGatherBonus;
                float upgradeBonus = 0f;
                int bonus = (int)(item.amount * landBonus);

                if (Instance.Options.Upgrading.Enabled && Instance.Options.Upgrading.MaxTaxChestBonus > 0)
                {
                    upgradeBonus = area.GetLevelTaxBonus();
                    upgradeBonus = Mathf.Floor(landBonus * 100f) / 100f;
                }

                var tax = (int)(item.amount * faction.TaxRate);

                faction.TaxChest.inventory.AddItem(itemDef, (int)((tax + bonus) * (1 + upgradeBonus)));
                item.amount -= tax;
            }

            public static void AwardBadlandsBonusIfApplicable(ResourceDispenser dispenser, BaseEntity entity, Item item)
            {
                if (!Instance.Options.Badlands.Enabled)
                    return;

                var player = entity as BasePlayer;
                if (player == null) return;

                User user = Instance.Users.Get(player);

                if (user.CurrentArea != null && user.CurrentArea.Type == AreaType.Badlands)
                {
                    var bonus = (int)(item.amount * Instance.Options.Taxes.BadlandsGatherBonus);
                    item.amount += bonus;
                }
            }
        }
    }
}
#endregion

#region > Upkeep
namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using UnityEngine;

    public partial class Imperium
    {
        private static class Upkeep
        {
            public static void CollectForAllFactions()
            {
                foreach (Faction faction in Instance.Factions.GetAll())
                    Collect(faction);
            }

            public static void Collect(Faction faction)
            {
                DateTime now = DateTime.UtcNow;
                Area[] areas = Instance.Areas.GetAllTaxableClaimsByFaction(faction);

                if (areas.Length == 0)
                    return;

                if (now < faction.NextUpkeepPaymentTime)
                {
                    Instance.Log($"[UPKEEP] {faction.Id}: Upkeep not due until {faction.NextUpkeepPaymentTime}");
                    return;
                }

                int amountOwed = faction.GetUpkeepPerPeriod();
                var hoursSincePaid = (int)now.Subtract(faction.NextUpkeepPaymentTime).TotalHours;

                Instance.Log(
                    $"[UPKEEP] {faction.Id}: {hoursSincePaid} hours since upkeep paid, trying to collect {amountOwed} scrap for {areas.Length} area claims");

                var headquarters = areas.Where(a => a.Type == AreaType.Headquarters).FirstOrDefault();
                if (headquarters == null || headquarters.ClaimCupboard == null)
                {
                    Instance.Log($"[UPKEEP] {faction.Id}: Couldn't collect upkeep, faction has no headquarters");
                }
                else
                {
                    ItemDefinition scrapDef = ItemManager.FindItemDefinition("scrap");
                    ItemContainer container = headquarters.ClaimCupboard.inventory;
                    List<Item> stacks = container.FindItemsByItemID(scrapDef.itemid);

                    if (Instance.TryCollectFromStacks(scrapDef, stacks, amountOwed))
                    {
                        faction.NextUpkeepPaymentTime =
                            faction.NextUpkeepPaymentTime.AddHours(Instance.Options.Upkeep.CollectionPeriodHours);

                        faction.IsUpkeepPastDue = false;
                        Instance.Log(
                            $"[UPKEEP] {faction.Id}: {amountOwed} scrap upkeep collected, next payment due {faction.NextUpkeepPaymentTime}");
                        return;
                    }
                }

                faction.IsUpkeepPastDue = true;

                if (hoursSincePaid <= Instance.Options.Upkeep.GracePeriodHours)
                {
                    Instance.Log(
                        $"[UPKEEP] {faction.Id}: Couldn't collect upkeep, but still within {Instance.Options.Upkeep.GracePeriodHours} hour grace period");
                    return;
                }
                Area lostArea = null;
                Area[] NonHQAreas = areas.Where(a => a.Type != AreaType.Headquarters).ToArray();
                if (NonHQAreas.Length > 0)
                {
                    lostArea = NonHQAreas.OrderBy(area => Instance.Areas.GetDepthInsideFriendlyTerritory(area)).First();
                }


                if (lostArea == null)
                    lostArea = headquarters;
                Instance.Log(
                    $"[UPKEEP] {faction.Id}: Upkeep not paid in {hoursSincePaid} hours, seizing claim on {lostArea.Id}");
                Util.PrintToChat(nameof(Messages.AreaClaimLostUpkeepNotPaidAnnouncement), faction.Id, lostArea.Id);
                BuildingPrivlidge cupboard = lostArea.ClaimCupboard;
                Instance.Areas.Unclaim(lostArea);
                if (cupboard)
                    cupboard.Kill(BaseNetworkable.DestroyMode.Gib);
            }
        }
    }
}
#endregion

#region > Area
namespace Oxide.Plugins
{
    using Rust;
    using Rust.UI;
    using UnityEngine;

    public partial class Imperium
    {
        private class Area : MonoBehaviour
        {
            public Vector3 Position { get; private set; }
            public Vector3 Size { get; private set; }

            public string Id { get; private set; }
            public int Row { get; private set; }
            public int Col { get; private set; }

            public AreaType Type { get; set; }
            public string Name { get; set; }
            public string FactionId { get; set; }
            public string ClaimantId { get; set; }
            public BuildingPrivlidge ClaimCupboard { get; set; }
            public BasePlayer ClaimReskinningPlayer { get; set; }
            public Vector3 ReskinnedCupboardLastPosition { get; set; }
            public bool IsCupboardChangingSkin { get; set; }
            public Locker ArmoryLocker { get; set; }
            public int Level { get; set; }
            public bool HasRecruit = false;
            public string RecruitSpawnPosition = "0,0,0";

            public MapMarkerGenericRadius mapMarker;
            public VendingMachineMapMarker hqMarker;
            public MapMarkerGenericRadius hqMarkerColor;
            public BaseEntity textMarker;
            public bool IsClaimed
            {
                get { return FactionId != null; }
            }
            public bool IsTaxableClaim
            {
                get { return Type == AreaType.Claimed || Type == AreaType.Headquarters; }
            }
            public bool IsWarZone
            {
                get { return GetActiveWars().Length > 0; }
            }
            public bool IsHostile
            {
                get
                {
                    if (FactionId != null)
                    {
                        if (Instance.Factions.Get(FactionId) != null)
                        {
                            return Instance.Factions.Get(FactionId).IsBadlands;
                        }

                    }
                    return false;
                }
            }
            public int UpgradeCost
            {
                get
                {
                    var costs = Instance.Options.Upgrading.Costs;
                    return costs[Mathf.Clamp(Level, 0, costs.Count - 1)
                    ];
                }
            }
            public void Init(string id, int row, int col, Vector3 position, Vector3 size, AreaInfo info)
            {
                Id = id;
                Row = row;
                Col = col;
                Position = position;
                Size = size;


                if (info != null)
                    TryLoadInfo(info);
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = $"imperium_area_{id}";
                transform.position = position;
                transform.rotation = Quaternion.Euler(new Vector3(0, 0, 0));

                var collider = gameObject.AddComponent<BoxCollider>();
                collider.size = Size;
                collider.isTrigger = true;
                collider.enabled = true;


                gameObject.SetActive(true);
                enabled = true;
            }

            private void Awake()
            {
                InvokeRepeating("CheckClaimCupboard", 60f, 60f);
                InvokeRepeating("CheckArmoryLocker", 60f, 60f);
            }

            private void OnDestroy()
            {
                var collider = GetComponent<BoxCollider>();

                if (collider != null)
                    Destroy(collider);

                if (IsInvoking("CheckClaimCupboard"))
                    CancelInvoke("CheckClaimCupboard");
                if (IsInvoking("CheckArmoryLocker"))
                    CancelInvoke("CheckArmoryLocker");
            }

            private void TryLoadInfo(AreaInfo info)
            {
                BuildingPrivlidge cupboard = null;
                Locker locker = null;

                if (info.CupboardId != null)
                {
                    cupboard = BaseNetworkable.serverEntities.Find(new NetworkableId((ulong)info.CupboardId)) as BuildingPrivlidge;
                    if (cupboard == null)
                    {
                        Instance.Log(
                            $"[LOAD] Area {Id}: Cupboard entity {info.CupboardId} not found, treating as unclaimed");
                        return;
                    }
                }

                if (info.FactionId != null)
                {
                    Faction faction = Instance.Factions.Get(info.FactionId);
                    if (faction == null)
                    {
                        Instance.Log(
                            $"[LOAD] Area {Id}: Claimed by unknown faction {info.FactionId}, treating as unclaimed");
                        return;
                    }
                }

                Name = info.Name;
                Type = info.Type;
                FactionId = info.FactionId;
                ClaimantId = info.ClaimantId;
                ClaimCupboard = cupboard;
                Level = info.Level;
                HasRecruit = info.HasRecruit;
                RecruitSpawnPosition = info.RecruitSpawnPosition;

                if (info.ArmoryId != null)
                {
                    locker = BaseNetworkable.serverEntities.Find(new NetworkableId((ulong)info.ArmoryId)) as Locker;
                    if (locker == null)
                    {
                        Instance.Log(
                            $"[LOAD] Area {Id}: Locker entity {info.ArmoryId} not found");
                    }
                }

                ArmoryLocker = locker;

                if (FactionId != null)
                    Instance.Log(
                        $"[LOAD] Area {Id}: Claimed by {FactionId}, type = {Type}, cupboard = {Util.Format(ClaimCupboard)}");
            }

            private void CheckClaimCupboard()
            {
                if (ClaimCupboard == null || !ClaimCupboard.IsDestroyed)
                    return;

                Instance.Log(
                    $"{FactionId} lost their claim on {Id} because the tool cupboard was destroyed (periodic check)");
                Util.PrintToChat(nameof(Messages.AreaClaimLostCupboardDestroyedAnnouncement), FactionId, Id);
                Instance.Areas.Unclaim(this);
            }

            private void CheckArmoryLocker()
            {
                if (ArmoryLocker == null || !ArmoryLocker.IsDestroyed)
                    return;

                Instance.Log(
                    $"{FactionId} lost their armory on {Id} because the locker was destroyed (periodic check)");
                Util.PrintToChat(nameof(Messages.AreaClaimLostArmoryDestroyedAnnouncement), FactionId, Id);
                Instance.Areas.RemoveArmory(this);
            }

            private void OnTriggerEnter(Collider collider)
            {
                if (collider.gameObject.layer != (int)Layer.Player_Server)
                    return;

                var user = collider.GetComponentInParent<User>();

                if (user != null)
                {
                    if (user.CurrentArea != this)
                    {
                        Events.OnUserEnteredArea(user, this);
                    }
                }
            }

            private void OnTriggerExit(Collider collider)
            {
                if (collider.gameObject.layer != (int)Layer.Player_Server)
                    return;
                var user = collider.GetComponentInParent<User>();
                if (user != null)
                {
                    Events.OnUserLeftArea(user, this);
                }

            }

            public void UpdateAreaMarker(FactionColorPicker colorPicker)
            {
                bool markerExists = true;
                if (Type != AreaType.Headquarters)
                {
                    if (hqMarker != null)
                    {
                        hqMarker.Kill();
                        hqMarker = null;
                    }

                    if (hqMarkerColor != null)
                    {
                        hqMarkerColor.Kill();
                        hqMarkerColor = null;
                    }

                }
                if (Type == AreaType.Wilderness)
                {
                    if (mapMarker != null)
                        mapMarker.Kill();
                }
                else
                {
                    if (mapMarker == null)
                    {
                        markerExists = false;
                        var markerRadius = ((4000 / Instance.Areas.MapGrid.MapSize) * 0.5f);
                        var marker = GameManager.server.CreateEntity(
                            "assets/prefabs/tools/map/genericradiusmarker.prefab", transform.position)
                            as MapMarkerGenericRadius;
                        marker.radius = markerRadius;
                        marker.enableSaving = false;
                        mapMarker = marker;
                    }

                    if (Type == AreaType.Claimed)
                    {
                        mapMarker.alpha = 0.3f;
                        mapMarker.color1 = Util.ConvertSystemToUnityColor(
                            colorPicker.GetColorForFaction(FactionId));
                        mapMarker.color2 = Color.black;
                        if (!markerExists)
                            mapMarker.Spawn();
                        mapMarker.SendUpdate();
                    }
                    if (Type == AreaType.Headquarters)
                    {
                        mapMarker.alpha = 0.3f;
                        mapMarker.color1 = Util.ConvertSystemToUnityColor(
                            colorPicker.GetColorForFaction(FactionId));
                        mapMarker.color2 = Color.black;
                        if (!markerExists)
                            mapMarker.Spawn();
                        mapMarker.SendUpdate();

                        if (hqMarker == null)
                        {
                            if (ClaimCupboard)
                            {
                                Vector3 tcPosition = ClaimCupboard.transform.position;
                                var marker = GameManager.server.CreateEntity(
                                "assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", tcPosition)
                                as VendingMachineMapMarker;
                                marker.markerShopName = FactionId + " Headquarters";
                                marker.transform.position.Set(marker.transform.position.x, -100f, marker.transform.position.z);
                                hqMarker = marker;
                                hqMarker.enableSaving = false;
                                hqMarker.appType = ProtoBuf.AppMarkerType.Player;
                                hqMarker.Spawn();


                                var markerTop = GameManager.server.CreateEntity(
                            "assets/prefabs/tools/map/genericradiusmarker.prefab")
                            as MapMarkerGenericRadius;
                                markerTop.radius = 0.2f;
                                markerTop.enableSaving = false;
                                markerTop.color1 = Util.ConvertSystemToUnityColor(
                                   colorPicker.GetColorForFaction(FactionId));
                                markerTop.color2 = Color.black;
                                markerTop.alpha = 0.5f;
                                markerTop.SetParent(hqMarker);
                                markerTop.Spawn();
                                hqMarkerColor = markerTop;
                                hqMarker.SendNetworkUpdate();
                                markerTop.SendUpdate();

                            }

                        }
                    }
                    if (Type == AreaType.Badlands)
                    {
                        mapMarker.alpha = 0.2f;
                        mapMarker.color1 = Color.black;
                        mapMarker.color2 = Color.black;
                        if (!markerExists)
                            mapMarker.Spawn();
                        mapMarker.SendUpdate();
                    }

                }
            }

            public float GetDistanceFromEntity(BaseEntity entity)
            {
                return Vector3.Distance(entity.transform.position, transform.position);
            }

            public int GetClaimCost(Faction faction)
            {
                var costs = Instance.Options.Claims.Costs;
                int numberOfAreasOwned = Instance.Areas.GetAllClaimedByFaction(faction).Length;
                int index = Mathf.Clamp(numberOfAreasOwned, 0, costs.Count - 1);
                return costs[index];
            }

            public float GetDefensiveBonus()
            {
                var bonuses = Instance.Options.War.DefensiveBonuses;
                var depth = Instance.Areas.GetDepthInsideFriendlyTerritory(this);
                int index = Mathf.Clamp(depth, 0, bonuses.Count - 1);
                float bonus = bonuses[index];
                if (Instance.Options.Upgrading.Enabled && Instance.Options.Upgrading.MaxRaidDefenseBonus > 0)
                {
                    bonus = Mathf.Clamp(bonus + GetLevelDefensiveBonus(), 0, 1);
                    bonus = Mathf.Floor((bonus * 100) / 100);
                }
                return bonus;
            }

            public float GetTaxRate()
            {
                if (!IsTaxableClaim)
                    return 0;

                Faction faction = Instance.Factions.Get(FactionId);

                if (!faction.CanCollectTaxes)
                    return 0;

                return faction.TaxRate;
            }

            public War[] GetActiveWars()
            {
                if (FactionId == null)
                    return new War[0];

                return Instance.Wars.GetAllActiveWarsByFaction(FactionId);
            }

            private float GetRatio(int level, int maxLevel, float maxBonus)
            {
                return (level / maxLevel) * maxBonus;
            }
            public float GetLevelDefensiveBonus()
            {
                return GetRatio(Level,
                    Instance.Options.Upgrading.MaxUpgradeLevel,
                    Instance.Options.Upgrading.MaxRaidDefenseBonus);

            }
            public float GetLevelDecayReduction()
            {
                return GetRatio(Level,
                    Instance.Options.Upgrading.MaxUpgradeLevel,
                    Instance.Options.Upgrading.MaxDecayExtraReduction);
            }

            public float GetLevelTaxBonus()
            {
                return GetRatio(Level,
                    Instance.Options.Upgrading.MaxUpgradeLevel,
                    Instance.Options.Upgrading.MaxTaxChestBonus);
            }

            public AreaInfo Serialize()
            {
                return new AreaInfo
                {
                    Id = Id,
                    Name = Name,
                    Type = Type,
                    FactionId = FactionId,
                    ClaimantId = ClaimantId,
                    CupboardId = ClaimCupboard?.net?.ID.Value,
                    ArmoryId = ArmoryLocker?.net?.ID.Value,
                    Level = Level,
                    HasRecruit = HasRecruit,
                    RecruitSpawnPosition = RecruitSpawnPosition
                };
            }
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Imperium : RustPlugin
    {
        public class AreaInfo
        {
            [JsonProperty("id")] public string Id;

            [JsonProperty("name")] public string Name;

            [JsonProperty("type"), JsonConverter(typeof(StringEnumConverter))]
            public AreaType Type;

            [JsonProperty("factionId")] public string FactionId;

            [JsonProperty("claimantId")] public string ClaimantId;

            [JsonProperty("cupboardId")] public ulong? CupboardId;

            [JsonProperty("armoryId")] public ulong? ArmoryId;

            [JsonProperty("level")] public int Level;

            [JsonProperty("hasRecruit")] public bool HasRecruit;

            [JsonProperty("recruitSpawnPosition")] public string RecruitSpawnPosition;
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using UnityEngine;

    public partial class Imperium
    {
        private class AreaManager
        {
            private Dictionary<string, Area> Areas;
            private Area[,] Layout;

            public MapGrid MapGrid { get; }

            public int Count
            {
                get { return Areas.Count; }
            }

            public AreaManager()
            {
                MapGrid = new MapGrid();
                Areas = new Dictionary<string, Area>();
                Layout = new Area[MapGrid.NumberOfColumns, MapGrid.NumberOfRows];
            }

            public Area Get(string areaId)
            {
                Area area;
                if (Areas.TryGetValue(areaId, out area))
                    return area;
                else
                    return null;
            }

            public Area Get(int row, int col)
            {
                return Layout[row, col];
            }

            public Area[] GetAll()
            {
                return Areas.Values.ToArray();
            }

            public Area[] GetAllByType(AreaType type)
            {
                return Areas.Values.Where(a => a.Type == type).ToArray();
            }

            public Area[] GetAllClaimedByFaction(Faction faction)
            {
                return GetAllClaimedByFaction(faction.Id);
            }

            public Area[] GetAllClaimedByFaction(string factionId)
            {
                return Areas.Values.Where(a => a.FactionId == factionId).ToArray();
            }

            public Area[] GetAllTaxableClaimsByFaction(Faction faction)
            {
                return GetAllTaxableClaimsByFaction(faction.Id);
            }

            public Area[] GetAllTaxableClaimsByFaction(string factionId)
            {
                return Areas.Values.Where(a => a.FactionId == factionId && a.IsTaxableClaim).ToArray();
            }

            public Area GetByClaimCupboard(BuildingPrivlidge cupboard)
            {
                return GetByClaimCupboard(cupboard.net.ID.Value);
            }

            public Area GetByClaimReskinningPlayer(BasePlayer player)
            {
                if(player == null)
                    return null;
                return Areas.Values.FirstOrDefault(a =>
                    a.ClaimCupboard != null && a.ClaimReskinningPlayer == player);
            }

            public Area GetByReskinnedCupboardLastPosition(Vector3 testPosition)
            {
                return Areas.Values.FirstOrDefault(a =>
                    IsApproximatedly(a.ReskinnedCupboardLastPosition, testPosition));
                
            }

            private Vector3 Abs(Vector3 v)
            {
                return new Vector3(Mathf.Abs(v.x), Mathf.Abs(v.y), Mathf.Abs(v.z));
            }

            private bool IsApproximatedly(Vector3 v1, Vector3 v2)
            {
                Vector3 diff = Abs(v1 - v2);
                return (diff.x < 0.1f) && (diff.y < 0.1f) && (diff.z < 0.1f);
            }

            public Area GetByClaimCupboard(ulong cupboardId)
            {
                return Areas.Values.FirstOrDefault(a =>
                    a.ClaimCupboard != null && a.ClaimCupboard.net.ID.Value == cupboardId);
            }
            public Area GetByArmoryLocker(Locker locker)
            {
                return GetByClaimCupboard(locker.net.ID.Value);
            }

            public Area GetByArmoryLocker(ulong lockerId)
            {
                return Areas.Values.FirstOrDefault(a =>
                    a.ArmoryLocker != null && a.ArmoryLocker.net.ID.Value == lockerId);
            }

            public Area GetByEntityPosition(BaseEntity entity)
            {
                Vector3 position = entity.transform.position;

                int row = Mathf.FloorToInt((MapGrid.MapHeight / 2 - (position.z + (MapGrid.MapOffsetZ / 2))) / MapGrid.CellSize) + Instance.Options.Map.MapGridYOffset;
                int col = Mathf.FloorToInt((MapGrid.MapWidth / 2 + (position.x + (MapGrid.MapOffsetX) / 2)) / MapGrid.CellSize);
                if (Instance.Options.Pvp.AllowedUnderground && position.y < -20f)
                    return null;
                if (row < 0 || col < 0 || row >= MapGrid.NumberOfRows || col >= MapGrid.NumberOfColumns)
                    return null;

                return Layout[row, col];
            }

            public Area GetByWorldPosition(Vector3 position)
            {
                int row = Mathf.FloorToInt((MapGrid.MapHeight / 2 - (position.z + (MapGrid.MapOffsetZ / 2))) / MapGrid.CellSize) + Instance.Options.Map.MapGridYOffset;
                int col = Mathf.FloorToInt((MapGrid.MapWidth / 2 + (position.x + (MapGrid.MapOffsetX) / 2)) / MapGrid.CellSize);
                if (Instance.Options.Pvp.AllowedUnderground && position.y < -20f)
                    return null;
                if (row < 0 || col < 0 || row >= MapGrid.NumberOfRows || col >= MapGrid.NumberOfColumns)
                    return null;

                return Layout[row, col];
            }

            public void Claim(Area area, AreaType type, Faction faction, User claimant, BuildingPrivlidge cupboard)
            {
                area.Type = type;
                area.FactionId = faction.Id;
                area.ClaimantId = claimant.Id;
                area.ClaimCupboard = cupboard;


                Events.OnAreaChanged(area);
            }

            public void SetHeadquarters(Area area, Faction faction)
            {
                // Ensure that no other areas are considered headquarters.
                foreach (Area otherArea in GetAllClaimedByFaction(faction).Where(a => a.Type == AreaType.Headquarters))
                {
                    otherArea.Type = AreaType.Claimed;
                    Events.OnAreaChanged(otherArea);
                }

                area.Type = AreaType.Headquarters;
                Events.OnAreaChanged(area);
            }

            public void Unclaim(IEnumerable<Area> areas)
            {
                Unclaim(areas.ToArray());
            }

            public void Unclaim(params Area[] areas)
            {
                foreach (Area area in areas)
                {
                    area.Type = AreaType.Wilderness;
                    area.FactionId = null;
                    area.ClaimantId = null;
                    area.ClaimCupboard = null;

                    Events.OnAreaChanged(area);
                }
            }

            public void SetArmory(Area area, Locker locker)
            {
                area.ArmoryLocker = locker;

                Events.OnAreaChanged(area);
            }

            public void RemoveArmory(Area area)
            {
                area.ArmoryLocker = null;

                Events.OnAreaChanged(area);
            }

            public void AddBadlands(params Area[] areas)
            {
                foreach (Area area in areas)
                {
                    area.Type = AreaType.Badlands;
                    area.FactionId = null;
                    area.ClaimantId = null;
                    area.ClaimCupboard = null;

                    Events.OnAreaChanged(area);
                }
            }

            public void AddBadlands(IEnumerable<Area> areas)
            {
                AddBadlands(areas.ToArray());
            }

            public int GetNumberOfContiguousClaimedAreas(Area area, Faction owner)
            {
                int count = 0;

                // North
                if (area.Row > 0 && Layout[area.Row - 1, area.Col].FactionId == owner.Id)
                    count++;

                // South
                if (area.Row < MapGrid.NumberOfRows - 1 && Layout[area.Row + 1, area.Col].FactionId == owner.Id)
                    count++;

                // West
                if (area.Col > 0 && Layout[area.Row, area.Col - 1].FactionId == owner.Id)
                    count++;

                // East
                if (area.Col < MapGrid.NumberOfColumns - 1 && Layout[area.Row, area.Col + 1].FactionId == owner.Id)
                    count++;

                return count;
            }

            public int GetDepthInsideFriendlyTerritory(Area area)
            {
                if (!area.IsClaimed)
                    return 0;

                var depth = new int[4];

                // North
                for (var row = area.Row; row >= 0; row--)
                {
                    if (Layout[row, area.Col].FactionId != area.FactionId)
                        break;

                    depth[0]++;
                }

                // South
                for (var row = area.Row; row < MapGrid.NumberOfRows; row++)
                {
                    if (Layout[row, area.Col].FactionId != area.FactionId)
                        break;

                    depth[1]++;
                }

                // West
                for (var col = area.Col; col >= 0; col--)
                {
                    if (Layout[area.Row, col].FactionId != area.FactionId)
                        break;

                    depth[2]++;
                }

                // East
                for (var col = area.Col; col < MapGrid.NumberOfColumns; col++)
                {
                    if (Layout[area.Row, col].FactionId != area.FactionId)
                        break;

                    depth[3]++;
                }
                return depth.Min() - 1;
            }

            public void Init(IEnumerable<AreaInfo> areaInfos)
            {
                Instance.Puts("Creating area objects...");

                Dictionary<string, AreaInfo> lookup;
                if (areaInfos != null)
                    lookup = areaInfos.ToDictionary(a => a.Id);
                else
                    lookup = new Dictionary<string, AreaInfo>();

                for (var row = 0; row < MapGrid.NumberOfRows; row++)
                {
                    for (var col = 0; col < MapGrid.NumberOfColumns; col++)
                    {
                        string areaId = MapGrid.GetAreaId(row, col);
                        Vector3 position = MapGrid.GetPosition(row, col);
                        if (Instance.Options.Pvp.AllowedUnderground)
                        {
                            position.y = position.y + 480f;
                        }
                        Vector3 size = new Vector3(MapGrid.CellSize / 2, 500, MapGrid.CellSize / 2);

                        AreaInfo info = null;
                        lookup.TryGetValue(areaId, out info);

                        var area = new GameObject().AddComponent<Area>();
                        area.Init(areaId, row, col, position, size, info);
                        Areas[areaId] = area;
                        Layout[row, col] = area;
                    }
                }
                Instance.Areas.UpdateAreaMarkers();

                Instance.Puts($"Created {Areas.Values.Count} area objects.");
            }

            public void Destroy()
            {
                DestroyAreaMarkers();
                Area[] areas = UnityEngine.Object.FindObjectsOfType<Area>();

                if (areas != null)
                {
                    Instance.Puts($"Destroying {areas.Length} area objects...");
                    foreach (Area area in areas)
                        UnityEngine.Object.Destroy(area);
                }

                Areas.Clear();
                Array.Clear(Layout, 0, Layout.Length);

                Instance.Puts("Area objects destroyed.");
            }

            public AreaInfo[] Serialize()
            {
                return Areas.Values.Select(area => area.Serialize()).ToArray();
            }

            public void UpdateAreaMarkers()
            {
                FactionColorPicker colorPicker = new FactionColorPicker();

                Area[] AllAreas = GetAll();
                foreach (Area area in AllAreas)
                {
                    area.UpdateAreaMarker(colorPicker);
                }
            }

            public void DestroyAreaMarkers()
            {
                Area[] AllAreas = GetAll();
                foreach (Area area in AllAreas)
                {
                    if (area.mapMarker != null)
                    {
                        area.mapMarker.Kill();
                        area.mapMarker = null;
                    }

                    if (area.hqMarker != null)
                    {
                        area.hqMarker.Kill();
                        area.hqMarker = null;
                    }

                    if (area.hqMarkerColor != null)
                    {
                        area.hqMarkerColor.Kill();
                        area.hqMarkerColor = null;
                    }

                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium : RustPlugin
    {
        public enum AreaType
        {
            Wilderness,
            Claimed,
            Headquarters,
            Badlands
        }
    }
}
#endregion

#region > Faction
namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using UnityEngine;

    public partial class Imperium
    {
        private class Faction
        {
            public string Id { get; private set; }
            public string OwnerId { get; set; }
            public HashSet<string> MemberIds { get; }
            public HashSet<string> ManagerIds { get; }
            public HashSet<string> InviteIds { get; }
            public HashSet<string> Aggressors { get; }
            public ulong InGameTeamID { get; set; }

            public float TaxRate { get; set; }
            public StorageContainer TaxChest { get; set; }
            public DateTime NextUpkeepPaymentTime { get; set; }
            public bool IsUpkeepPastDue { get; set; }
            public bool IsBadlands { get; set; }
            public DateTime? BadlandsCommandUsedTime { get; set; }
            public DateTime CreationTime { get; set; }


            public bool CanCollectTaxes
            {
                get { return TaxChest != null; }
            }

            public int MemberCount
            {
                get { return MemberIds.Count; }
            }



            public Faction(string id, User owner)
            {
                Id = id;

                OwnerId = owner.Id;
                MemberIds = new HashSet<string> { owner.Id };
                ManagerIds = new HashSet<string>();
                InviteIds = new HashSet<string>();
                Aggressors = new HashSet<string>();
                TaxChest = null;
                TaxRate = Instance.Options.Taxes.DefaultTaxRate;
                NextUpkeepPaymentTime = DateTime.UtcNow.AddHours(Instance.Options.Upkeep.CollectionPeriodHours);
                IsBadlands = false;
                BadlandsCommandUsedTime = null;
            }

            public Faction(FactionInfo info)
            {
                Id = info.Id;

                OwnerId = info.OwnerId;
                MemberIds = new HashSet<string>(info.MemberIds);
                ManagerIds = new HashSet<string>(info.ManagerIds);
                InviteIds = new HashSet<string>(info.InviteIds);
                Aggressors = new HashSet<string>(info.Aggressors);
                InGameTeamID = info.InGameTeamID;
                if (info.TaxChestId != null)
                {
                    var taxChest = BaseNetworkable.serverEntities.Find(new NetworkableId((ulong)info.TaxChestId)) as StorageContainer;

                    if (taxChest == null || taxChest.IsDestroyed)
                        Instance.Log($"[LOAD] Faction {Id}: Tax chest entity {info.TaxChestId} was not found");
                    else
                        TaxChest = taxChest;
                }
                TaxRate = info.TaxRate;
                NextUpkeepPaymentTime = info.NextUpkeepPaymentTime;
                IsUpkeepPastDue = info.IsUpkeepPastDue;
                IsBadlands = info.IsBadlands;
                BadlandsCommandUsedTime = info.BadlandsCommandUsedTime;
                CreationTime = info.CreationTime;

                Instance.Log($"[LOAD] Faction {Id}: {MemberIds.Count} members, tax chest = {Util.Format(TaxChest)}");
            }

            public bool AddMember(User user)
            {
                if (!MemberIds.Add(user.Id))
                    return false;

                InviteIds.Remove(user.Id);

                Events.OnPlayerJoinedFaction(this, user);
                return true;
            }

            public bool RemoveMember(User user)
            {
                if (!HasMember(user.Id))
                    return false;

                if (HasOwner(user.Id))
                {
                    if (ManagerIds.Count > 0)
                    {
                        OwnerId = ManagerIds.FirstOrDefault();
                        ManagerIds.Remove(OwnerId);
                    }
                    else
                    {
                        OwnerId = MemberIds.FirstOrDefault();
                    }
                }

                MemberIds.Remove(user.Id);
                ManagerIds.Remove(user.Id);

                Events.OnPlayerLeftFaction(this, user);
                return true;
            }

            public bool AddInvite(User user)
            {
                if (!InviteIds.Add(user.Id))
                    return false;

                Events.OnPlayerInvitedToFaction(this, user);
                return true;
            }

            public bool RemoveInvite(User user)
            {
                if (!InviteIds.Remove(user.Id))
                    return false;

                Events.OnPlayerUninvitedFromFaction(this, user);
                return true;
            }

            public bool Promote(User user)
            {
                if (!MemberIds.Contains(user.Id))
                    throw new InvalidOperationException(
                        $"Cannot promote player {user.Id} in faction {Id}, since they are not a member");

                if (!ManagerIds.Add(user.Id))
                    return false;

                Events.OnPlayerPromoted(this, user);
                return true;
            }

            public bool Demote(User user)
            {
                if (!MemberIds.Contains(user.Id))
                    throw new InvalidOperationException(
                        $"Cannot demote player {user.Id} in faction {Id}, since they are not a member");

                if (!ManagerIds.Remove(user.Id))
                    return false;

                Events.OnPlayerDemoted(this, user);
                return true;
            }
            public bool SetBadlands(bool value)
            {
                IsBadlands = value;

                Events.OnFactionBadlandsChanged(this);
                return true;
            }

            public bool HasOwner(User user)
            {
                return HasOwner(user.Id);
            }

            public bool HasOwner(string userId)
            {
                return OwnerId == userId;
            }

            public bool HasLeader(User user)
            {
                return HasLeader(user.Id);
            }

            public bool HasLeader(string userId)
            {
                return HasOwner(userId) || HasManager(userId);
            }

            public bool HasManager(User user)
            {
                return HasManager(user.Id);
            }

            public bool HasManager(string userId)
            {
                return ManagerIds.Contains(userId);
            }

            public bool HasInvite(User user)
            {
                return HasInvite(user.Player.UserIDString);
            }

            public bool HasInvite(string userId)
            {
                return InviteIds.Contains(userId);
            }

            public bool HasMember(User user)
            {
                return HasMember(user.Player.UserIDString);
            }

            public bool HasMember(string userId)
            {
                return MemberIds.Contains(userId);
            }

            public User[] GetAllActiveMembers()
            {
                return MemberIds.Select(id => Instance.Users.Get(id)).Where(user => user != null).ToArray();
            }

            public User[] GetAllActiveInvitedUsers()
            {
                return InviteIds.Select(id => Instance.Users.Get(id)).Where(user => user != null).ToArray();
            }

            public int GetUpkeepPerPeriod()
            {
                var costs = Instance.Options.Upkeep.Costs;

                int totalCost = 0;
                for (var num = 0; num < Instance.Areas.GetAllTaxableClaimsByFaction(this).Length; num++)
                {
                    var index = Mathf.Clamp(num, 0, costs.Count - 1);
                    totalCost += costs[index];
                }

                return totalCost;
            }

            public void SendChatMessage(string message, params object[] args)
            {
                foreach (User user in GetAllActiveMembers())
                    user.SendChatMessage(message, args);
            }

            public void CreateFactionTeam()
            {
                List<User> activeMembers = GetAllActiveMembers().ToList();
                BasePlayer firstMember = activeMembers.FirstOrDefault().Player;
                RelationshipManager.PlayerTeam factionTeam = GetFactionPlayerTeam();
                RelationshipManager.PlayerTeam firstTeam = GetOwnerPlayerTeam();
                //If has any member online
                if (firstMember != null)
                {
                    //faction has no valid team
                    if (firstTeam == null)
                    {
                        firstTeam = RelationshipManager.ServerInstance.CreateTeam();
                        firstTeam.SetTeamLeader(firstMember.userID);
                        firstTeam.AddPlayer(firstMember);
                    }
                    InGameTeamID = firstTeam.teamID;
                    factionTeam = firstTeam;
                }
                //if faction team is still null here, something went very wrong.
                if (factionTeam == null)
                    return;

                //Remove all invalid players from the team
                foreach (ulong teamMember in factionTeam.members)
                {
                    if (!MemberIds.Contains(teamMember.ToString()))
                    {
                        User user = Instance.Users.Get(teamMember.ToString());
                        if (user)
                            user.EnsureIsInFactionTeam();
                    }
                }

                //Add all missing valid players to the team
                foreach (User factionMember in activeMembers)
                {
                    if (!factionTeam.members.Contains(factionMember.Player.userID))
                    {
                        factionMember.EnsureIsInFactionTeam();
                    }
                }
            }

            private RelationshipManager.PlayerTeam GetFactionPlayerTeam()
            {
                return RelationshipManager.ServerInstance.FindTeam(InGameTeamID);
            }

            private RelationshipManager.PlayerTeam GetOwnerPlayerTeam()
            {
                BasePlayer ownerPlayer = Instance.Users.Get(OwnerId).Player;
                if (ownerPlayer == null)
                    return null;
                return RelationshipManager.ServerInstance.FindTeam(ownerPlayer.userID);
            }

            public FactionInfo Serialize()
            {
                return new FactionInfo
                {
                    Id = Id,
                    OwnerId = OwnerId,
                    MemberIds = MemberIds.ToArray(),
                    ManagerIds = ManagerIds.ToArray(),
                    InviteIds = InviteIds.ToArray(),
                    Aggressors = Aggressors.ToArray(),
                    InGameTeamID = InGameTeamID,
                    TaxRate = TaxRate,
                    TaxChestId = TaxChest?.net?.ID.Value,
                    NextUpkeepPaymentTime = NextUpkeepPaymentTime,
                    IsBadlands = IsBadlands,
                    BadlandsCommandUsedTime = BadlandsCommandUsedTime,
                    CreationTime = CreationTime
                };
            }
        }
    }
}

namespace Oxide.Plugins
{
    using UnityEngine;

    public partial class Imperium
    {
        private class FactionEntityMonitor : MonoBehaviour
        {
            private void Awake()
            {
                InvokeRepeating("CheckTaxChests", 60f, 60f);
            }

            private void OnDestroy()
            {
                if (IsInvoking("CheckTaxChests")) CancelInvoke("CheckTaxChests");
            }

            private void EnsureAllTaxChestsStillExist()
            {
                foreach (Faction faction in Instance.Factions.GetAll())
                    EnsureTaxChestExists(faction);
            }

            private void EnsureTaxChestExists(Faction faction)
            {
                if (faction.TaxChest == null || !faction.TaxChest.IsDestroyed)
                    return;

                Instance.Log($"{faction.Id}'s tax chest was destroyed (periodic check)");
                faction.TaxChest = null;
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Imperium : RustPlugin
    {
        private class FactionInfo
        {
            [JsonProperty("id")] public string Id;

            [JsonProperty("ownerId")] public string OwnerId;

            [JsonProperty("memberIds")] public string[] MemberIds;

            [JsonProperty("managerIds")] public string[] ManagerIds;

            [JsonProperty("inviteIds")] public string[] InviteIds;

            [JsonProperty("aggressors")] public string[] Aggressors;

            [JsonProperty("inGameTeamID")] public ulong InGameTeamID;

            [JsonProperty("taxRate")] public float TaxRate;

            [JsonProperty("taxChestId")] public ulong? TaxChestId;

            [JsonProperty("nextUpkeepPaymentTime")]
            public DateTime NextUpkeepPaymentTime;

            [JsonProperty("isUpkeepPastDue")] public bool IsUpkeepPastDue;

            [JsonProperty("isBadlands")] public bool IsBadlands;

            [JsonProperty("badlandsCommandUsedTime"), JsonConverter(typeof(IsoDateTimeConverter))]
            public DateTime? BadlandsCommandUsedTime;

            [JsonProperty("creationTime"), JsonConverter(typeof(IsoDateTimeConverter))]
            public DateTime CreationTime;
        }


    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using UnityEngine;
    using Newtonsoft.Json.Linq;

    public partial class Imperium
    {
        private class FactionManager
        {
            private Dictionary<string, Faction> Factions = new Dictionary<string, Faction>();
            private FactionEntityMonitor EntityMonitor;

            public FactionManager()
            {
                Factions = new Dictionary<string, Faction>();
                EntityMonitor = Instance.GO.AddComponent<FactionEntityMonitor>();
            }

            public Faction Create(string id, User owner)
            {
                Faction faction;

                if (Factions.TryGetValue(id, out faction))
                    throw new InvalidOperationException(
                        $"Cannot create a new faction named ${id}, since one already exists");

                faction = new Faction(id, owner);
                faction.CreationTime = DateTime.Now;



                Factions.Add(id, faction);

                if (Instance.Options.Factions.OverrideInGameTeamSystem)
                {
                    faction.CreateFactionTeam();
                }

                Events.OnFactionCreated(faction);

                return faction;
            }

            public void Disband(Faction faction)
            {
                foreach (User user in faction.GetAllActiveMembers())
                    user.SetFaction(null);

                Factions.Remove(faction.Id);
                Events.OnFactionDisbanded(faction);
            }

            public Faction[] GetAll()
            {
                return Factions.Values.ToArray();
            }

            public Faction Get(string id)
            {
                Faction faction;
                if (Factions.TryGetValue(id, out faction))
                    return faction;
                else
                    return null;
            }

            public bool Exists(string id)
            {
                return Factions.ContainsKey(id);
            }

            public Faction GetByMember(User user)
            {
                return GetByMember(user.Id);
            }

            public Faction GetByMember(string userId)
            {
                return Factions.Values.Where(f => f.HasMember(userId)).FirstOrDefault();
            }

            public Faction GetByTaxChest(StorageContainer container)
            {
                return GetByTaxChest(container.net.ID.Value);
            }

            public Faction GetByTaxChest(ulong containerId)
            {
                return Factions.Values.SingleOrDefault(f => f.TaxChest != null && f.TaxChest.net.ID.Value == containerId);
            }

            public void SetTaxRate(Faction faction, float taxRate)
            {
                faction.TaxRate = taxRate;
                Events.OnFactionTaxesChanged(faction);
            }

            public void SetTaxChest(Faction faction, StorageContainer taxChest)
            {
                faction.TaxChest = taxChest;
                Events.OnFactionTaxesChanged(faction);
            }

            public void Init(IEnumerable<FactionInfo> factionInfos)
            {
                Instance.Puts($"Creating factions for {factionInfos.Count()} factions...");

                foreach (FactionInfo info in factionInfos)
                {
                    Faction faction = new Faction(info);
                    Factions.Add(faction.Id, faction);
                }

                Instance.Puts("Factions created.");
            }

            public void Destroy()
            {
                UnityEngine.Object.Destroy(EntityMonitor);
                Factions.Clear();
            }

            public FactionInfo[] Serialize()
            {
                return Factions.Values.Select(faction => faction.Serialize()).ToArray();
            }

            internal void SyncAllWithClans()
            {
                if (Instance.Options.Factions.UseClansPlugin)
                {
                    Instance.Puts("Syncing factions with Clans!");
                    //Disband all factions that don't have a matching clan
                    JArray AllClans = (JArray)Instance.Clans.CallHook("GetAllClans");
                    List<string> clanIds = new List<string>();
                    if (AllClans.Count > 0)
                    {
                        for (int i = 0; i < AllClans.Count; i++)
                        {
                            string clanId = AllClans[i].Value<string>();
                            clanIds.Add(clanId);

                        }
                    }
                    List<Faction> allFactions = GetAll().ToList();
                    if (allFactions.Count > 0)
                    {
                        foreach (Faction faction in allFactions)
                        {
                            if (!clanIds.Contains(faction.Id))
                            {
                                Disband(faction);
                            }
                        }
                    }
                    List<User> users = Instance.Users.GetAll().ToList();
                    if (users.Count > 0)
                    {
                        foreach (User user in Instance.Users.GetAll())
                        {
                            user.SyncWithClan();
                        }
                    }
                }
            }
        }
    }
}
#endregion

#region > Pin
namespace Oxide.Plugins
{
    using UnityEngine;

    public partial class Imperium
    {
        private class Pin
        {
            public Vector3 Position { get; }
            public string AreaId { get; }
            public string CreatorId { get; set; }
            public PinType Type { get; set; }
            public string Name { get; set; }

            public Pin(Vector3 position, Area area, User creator, PinType type, string name)
            {
                Position = position;
                AreaId = area.Id;
                CreatorId = creator.Id;
                Type = type;
                Name = name;
            }

            public Pin(PinInfo info)
            {
                Position = info.Position;
                AreaId = info.AreaId;
                CreatorId = info.CreatorId;
                Type = info.Type;
                Name = info.Name;
            }

            public float GetDistanceFrom(BaseEntity entity)
            {
                return GetDistanceFrom(entity.transform.position);
            }

            public float GetDistanceFrom(Vector3 position)
            {
                return Vector3.Distance(position, Position);
            }

            public PinInfo Serialize()
            {
                return new PinInfo
                {
                    Position = Position,
                    AreaId = AreaId,
                    CreatorId = CreatorId,
                    Type = Type,
                    Name = Name
                };
            }
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using UnityEngine;

    public partial class Imperium : RustPlugin
    {
        private class PinInfo
        {
            [JsonProperty("name")] public string Name;

            [JsonProperty("type"), JsonConverter(typeof(StringEnumConverter))]
            public PinType Type;

            [JsonProperty("position"), JsonConverter(typeof(UnityVector3Converter))]
            public Vector3 Position;

            [JsonProperty("areaId")] public string AreaId;

            [JsonProperty("creatorId")] public string CreatorId;
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public partial class Imperium
    {
        private class PinManager
        {
            private Dictionary<string, Pin> Pins;

            public PinManager()
            {
                Pins = new Dictionary<string, Pin>(StringComparer.OrdinalIgnoreCase);
            }

            public Pin Get(string name)
            {
                Pin pin;

                if (!Pins.TryGetValue(name, out pin))
                    return null;

                return pin;
            }

            public Pin[] GetAll()
            {
                return Pins.Values.ToArray();
            }

            public void Add(Pin pin)
            {
                Pins.Add(pin.Name, pin);
                Events.OnPinCreated(pin);
            }

            public void Remove(Pin pin)
            {
                Pins.Remove(pin.Name);
                Events.OnPinRemoved(pin);
            }

            public void RemoveAllPinsInUnclaimedAreas()
            {
                foreach (Pin pin in GetAll())
                {
                    Area area = Instance.Areas.Get(pin.AreaId);
                    if (!area.IsClaimed) Remove(pin);
                }
            }

            public void Init(IEnumerable<PinInfo> pinInfos)
            {
                Instance.Puts($"Creating pins for {pinInfos.Count()} pins...");

                foreach (PinInfo info in pinInfos)
                {
                    var pin = new Pin(info);
                    Pins.Add(pin.Name, pin);
                }

                Instance.Puts("Pins created.");
            }

            public void Destroy()
            {
                Pins.Clear();
            }

            public PinInfo[] Serialize()
            {
                return Pins.Values.Select(pin => pin.Serialize()).ToArray();
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private enum PinType
        {
            Arena,
            Hotel,
            Marina,
            Shop,
            Town
        }
    }
}
#endregion

#region > User
namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using System.Text;
    using UnityEngine;
    using System.Linq;
    using Newtonsoft.Json.Linq;
    //using ProtoBuf;

    public partial class Imperium
    {
        private class User : MonoBehaviour
        {
            private string OriginalName;
            private Dictionary<string, DateTime> CommandCooldownExpirations;
            public BasePlayer Player { get; private set; }
            public UserMap Map { get; private set; }
            public UserHud Hud { get; private set; }
            public UserPanel Panel { get; set; }
            public UserPreferences Preferences { get; set; }
            public Area CurrentArea { get; set; }
            public HashSet<Zone> CurrentZones { get; private set; }
            public Faction Faction { get; private set; }
            public Interaction CurrentInteraction { get; private set; }
            public DateTime MapCommandCooldownExpiration { get; set; }
            public DateTime PvpCommandCooldownExpiration { get; set; }
            public bool IsInPvpMode { get; set; }
            public bool IsInsideRaidableBase { get ; set; }

            public bool UpdatedMarkers = false;

            public string Id
            {
                get { return Player.UserIDString; }
            }

            public string UserName
            {
                get { return OriginalName; }
            }

            public string UserNameWithFactionTag
            {
                get { return Player.displayName; }
            }

            public void Init(BasePlayer player)
            {
                Player = player;
                OriginalName = player.displayName;
                CurrentZones = new HashSet<Zone>();
                CommandCooldownExpirations = new Dictionary<string, DateTime>();
                Preferences = UserPreferences.Default;

                Map = new UserMap(this);
                Hud = new UserHud(this);
                Panel = new UserPanel(this);

                IsInsideRaidableBase = false;

                InvokeRepeating(nameof(UpdateHud), 5f, 5f);
                InvokeRepeating(nameof(CheckArea), 2f, 2f);
            }

            private void OnDestroy()
            {
                Map.Hide();
                Hud.Hide();
                Panel.Hide();

                if (IsInvoking(nameof(UpdateHud))) CancelInvoke(nameof(UpdateHud));
                if (IsInvoking(nameof(CheckArea))) CancelInvoke(nameof(CheckArea));

                if (Player != null)
                    Player.displayName = OriginalName;
            }

            public void SetFaction(Faction faction)
            {
                if (Faction == faction)
                    return;
                CurrentInteraction = null;
                Faction = faction;

                if (faction == null)
                    Player.displayName = OriginalName;
                else
                    Player.displayName = $"[{faction.Id}] {Player.displayName}";
                if (Instance.Options.Factions.OverrideInGameTeamSystem)
                {
                    CancelInvoke("EnsureIsInFactionTeam");
                    Invoke("EnsureIsInFactionTeam", 3f);
                }

                Player.SendNetworkUpdate();
            }

            public bool HasPermission(string permission)
            {
                return Instance.permission.UserHasPermission(Player.UserIDString, permission);
            }

            public void BeginInteraction(Interaction interaction)
            {
                interaction.User = this;
                CurrentInteraction = interaction;
            }

            public void CompleteInteraction(HitInfo hit)
            {
                if (CurrentInteraction.TryComplete(hit))
                    CurrentInteraction = null;
            }

            public void CancelInteraction()
            {
                MapMarker
                CurrentInteraction = null;
            }

            public void SendChatMessage(string message, params object[] args)
            {
                string format = Instance.lang.GetMessage(message, Instance, Player.UserIDString);
                Instance.SendReply(Player, format, args);
            }

            public void SendChatMessage(StringBuilder sb)
            {
                Instance.SendReply(Player, sb.ToString().TrimEnd());
            }

            public void SendConsoleMessage(string message, params object[] args)
            {
                Player.ConsoleMessage(String.Format(message, args));
            }

            private void UpdateHud()
            {
                Hud.Refresh();
            }

            public int GetSecondsLeftOnCooldown(string command)
            {
                DateTime expiration;

                if (!CommandCooldownExpirations.TryGetValue(command, out expiration))
                    return 0;

                return (int)Math.Max(0, expiration.Subtract(DateTime.UtcNow).TotalSeconds);
            }

            public void SetCooldownExpiration(string command, DateTime time)
            {
                CommandCooldownExpirations[command] = time;
            }

            private void CheckArea()
            {
                Area currentArea = CurrentArea;
                Area correctArea = Instance.Areas.GetByEntityPosition(Player);

                if (currentArea != null && (correctArea == null || currentArea.Id != correctArea.Id))
                {
                    Events.OnUserLeftArea(this, currentArea);
                }
                Events.OnUserEnteredArea(this, correctArea);

            }

            public void EnsureIsInFactionTeam()
            {
                if (Player.currentTeam != 0UL)
                {
                    if (Faction == null || Player.currentTeam != Faction.InGameTeamID)
                    {
                        Player.Team.RemovePlayer(Player.userID);
                        if (Faction == null)
                            return;
                    }
                    if (Player.currentTeam == Faction.InGameTeamID)
                        return;
                }
                if (Player.currentTeam == 0UL && Faction == null)
                    return;
                RelationshipManager.PlayerTeam factionTeam;
                factionTeam = RelationshipManager.ServerInstance.FindTeam(Faction.InGameTeamID);
                if (factionTeam == null)
                {
                    Faction.CreateFactionTeam();
                    return;
                }
                factionTeam.AddPlayer(Player);
            }

            public void SyncWithClan()
            {
                if (!Instance.Options.Factions.UseClansPlugin)
                    return;

                if (Player == null)
                    return;
                string clanId = (string)Instance.Clans.CallHook("GetClanOf", Player);
                //is in correct faction already
                if (Faction?.Id == clanId)
                {
                    return;
                }
                //user is not in a clan
                if (clanId == null)
                {
                    //user is in a faction (Disband if owner, leave if not)
                    if (Faction != null)
                    {
                        if (Faction.HasOwner(this))
                        {
                            Instance.Factions.Disband(this.Faction);
                            SetFaction(null);
                        }
                        else
                        {
                            Faction.RemoveMember(this);
                            SetFaction(null);
                        }

                    }
                    return;
                }
                JObject jClan = (JObject)Instance.Clans.CallHook("GetClan", clanId);
                Faction clanFaction = Instance.Factions.Get(clanId);

                //corresponding clan for faction does not exist yet. If owner, create the correct faction
                if (clanFaction == null)
                {
                    User owner = Instance.Users.Get(jClan.GetValue("owner").Value<string>());
                    //clan owner is online
                    if (owner != null)
                    {
                        clanFaction = Instance.Factions.Create(clanId, owner);
                        if (owner.Faction != null)
                        {
                            Instance.Factions.Disband(owner.Faction);
                        }
                        owner.SetFaction(clanFaction);
                        if (this == owner)
                            return;
                    }
                }
                //if user faction is in a faction and is not in the clanFaction (might be null). Leave the current faction
                if (Faction != null && Faction != clanFaction)
                {

                    if (this.Faction.HasOwner(this))
                    {
                        Instance.Factions.Disband(this.Faction);
                        SetFaction(null);
                    }
                    else
                    {
                        Faction.RemoveMember(this);
                        SetFaction(null);
                    }
                }
                //set own faction if not equal clan faction
                if (Faction != clanFaction)
                    SetFaction(clanFaction);

            }

            private void CheckZones()
            {
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System.Collections.Generic;
    using System.Linq;

    public partial class Imperium
    {
        private class UserManager
        {
            private Dictionary<string, User> Users = new Dictionary<string, User>();
            private Dictionary<string, string> OriginalNames = new Dictionary<string, string>();

            public User[] GetAll()
            {
                return Users.Values.ToArray();
            }

            public User Get(BasePlayer player)
            {
                if (player == null) return null;
                return Get(player.UserIDString);
            }

            public User Get(string userId)
            {
                User user;
                if (Users.TryGetValue(userId, out user))
                    return user;
                else
                    return null;
            }

            public User Find(string searchString)
            {
                User user = Get(searchString);

                if (user != null)
                    return user;

                return Users.Values
                    .Where(u => u.UserName.ToLowerInvariant().Contains(searchString.ToLowerInvariant()))
                    .OrderBy(u =>
                        Util.GetLevenshteinDistance(searchString.ToLowerInvariant(), u.UserName.ToLowerInvariant()))
                    .FirstOrDefault();
            }

            public User Add(BasePlayer player)
            {
                Remove(player);

                string originalName;
                if (OriginalNames.TryGetValue(player.UserIDString, out originalName))
                    player.displayName = originalName;
                else
                    OriginalNames[player.UserIDString] = player.displayName;

                User user = player.gameObject.AddComponent<User>();
                user.Init(player);

                Faction faction = Instance.Factions.GetByMember(user);
                if (faction != null)
                    user.SetFaction(faction);
                else
                    user.SetFaction(null);

                Users[user.Player.UserIDString] = user;

                if (Instance.Options.Factions.UseClansPlugin)
                {
                    user.SyncWithClan();
                }

                return user;
            }

            public bool Remove(BasePlayer player)
            {
                User user = Get(player);
                if (user == null) return false;

                UnityEngine.Object.DestroyImmediate(user);
                Users.Remove(player.UserIDString);

                return true;
            }

            public void SetOriginalName(string userId, string name)
            {
                OriginalNames[userId] = name;
            }

            public void Init()
            {
                var players = BasePlayer.activePlayerList;

                Instance.Puts($"Creating user objects for {players.Count} players...");

                foreach (BasePlayer player in players)
                    Add(player);

                Instance.Puts($"Created {Users.Count} user objects.");
            }

            public void Destroy()
            {
                User[] users = UnityEngine.Object.FindObjectsOfType<User>();

                if (users == null)
                    return;

                Instance.Puts($"Destroying {users.Length} user objects.");

                foreach (var user in users)
                    UnityEngine.Object.DestroyImmediate(user);

                Users.Clear();

                Instance.Puts("User objects destroyed.");
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System;

    public partial class Imperium
    {
        private class UserPreferences
        {
            public UserMapLayer VisibleMapLayers { get; private set; }

            public void ShowMapLayer(UserMapLayer layer)
            {
                VisibleMapLayers |= layer;
            }

            public void HideMapLayer(UserMapLayer layer)
            {
                VisibleMapLayers &= ~layer;
            }

            public void ToggleMapLayer(UserMapLayer layer)
            {
                if (IsMapLayerVisible(layer))
                    HideMapLayer(layer);
                else
                    ShowMapLayer(layer);
            }

            public bool IsMapLayerVisible(UserMapLayer layer)
            {
                return (VisibleMapLayers & layer) == layer;
            }

            public static UserPreferences Default
            {
                get
                {
                    return new UserPreferences
                    {
                        VisibleMapLayers = UserMapLayer.Claims | UserMapLayer.Headquarters | UserMapLayer.Monuments |
                                           UserMapLayer.Pins
                    };
                }
            }
        }

        [Flags]
        private enum UserMapLayer
        {
            Claims = 1,
            Headquarters = 2,
            Monuments = 4,
            Pins = 8
        }
    }
}
#endregion

#region > War
namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    public partial class Imperium
    {
        private class War
        {

            public string AttackerId { get; set; }
            public string DefenderId { get; set; }
            public string DeclarerId { get; set; }
            public string CassusBelli { get; set; }

            public DateTime? AttackerPeaceOfferingTime { get; set; }
            public DateTime? DefenderPeaceOfferingTime { get; set; }

            public DateTime StartTime { get; private set; }
            public DateTime? EndTime { get; set; }
            public WarEndReason? EndReason { get; set; }

            public bool AdminApproved { get; set; }

            public bool DefenderApproved { get; set; }

            public bool IsActive
            {
                get { return EndTime == null && AdminApproved && DefenderApproved; }
            }

            public bool IsAttackerOfferingPeace
            {
                get { return AttackerPeaceOfferingTime != null; }
            }

            public bool IsDefenderOfferingPeace
            {
                get { return DefenderPeaceOfferingTime != null; }
            }

            public War(Faction attacker, Faction defender, User declarer, string cassusBelli)
            {
                AttackerId = attacker.Id;
                DefenderId = defender.Id;
                DeclarerId = declarer.Id;
                AdminApproved = !Instance.Options.War.AdminApprovalRequired;
                DefenderApproved = !Instance.Options.War.DefenderApprovalRequired;
                CassusBelli = cassusBelli;
                StartTime = DateTime.UtcNow;
            }

            public War(WarInfo info)
            {
                AttackerId = info.AttackerId;
                DefenderId = info.DefenderId;
                DeclarerId = info.DeclarerId;
                CassusBelli = info.CassusBelli;
                AdminApproved = info.AdminApproved;
                DefenderApproved = info.DefenderApproved;
                AttackerPeaceOfferingTime = info.AttackerPeaceOfferingTime;
                DefenderPeaceOfferingTime = info.DefenderPeaceOfferingTime;
                StartTime = info.StartTime;
                EndTime = info.EndTime;
            }

            public void OfferPeace(Faction faction)
            {
                if (AttackerId == faction.Id)
                    AttackerPeaceOfferingTime = DateTime.UtcNow;
                else if (DefenderId == faction.Id)
                    DefenderPeaceOfferingTime = DateTime.UtcNow;
                else
                    throw new InvalidOperationException(String.Format(
                        "{0} tried to offer peace but the faction wasn't involved in the war!", faction.Id));
            }

            public bool IsOfferingPeace(Faction faction)
            {
                return IsOfferingPeace(faction.Id);
            }

            public bool IsOfferingPeace(string factionId)
            {
                return (factionId == AttackerId && IsAttackerOfferingPeace) ||
                       (factionId == DefenderId && IsDefenderOfferingPeace);
            }

            public WarInfo Serialize()
            {
                return new WarInfo
                {
                    AttackerId = AttackerId,
                    DefenderId = DefenderId,
                    DeclarerId = DeclarerId,
                    CassusBelli = CassusBelli,
                    AdminApproved = AdminApproved,
                    DefenderApproved = DefenderApproved,
                    AttackerPeaceOfferingTime = AttackerPeaceOfferingTime,
                    DefenderPeaceOfferingTime = DefenderPeaceOfferingTime,
                    StartTime = StartTime,
                    EndTime = EndTime,
                    EndReason = EndReason
                };
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium : RustPlugin
    {
        private enum WarEndReason
        {
            Treaty,
            AttackerEliminatedDefender,
            DefenderEliminatedAttacker,
            AdminDenied,
            DefenderDenied
        }
    }
}

namespace Oxide.Plugins
{
    using System;

    public partial class Imperium
    {
        private enum WarPhase
        {
            Preparation,
            Combat,
            Raiding
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using Newtonsoft.Json.Linq;

    public partial class Imperium : RustPlugin
    {
        private class WarInfo
        {
            [JsonProperty("attackerId")] public string AttackerId;

            [JsonProperty("defenderId")] public string DefenderId;

            [JsonProperty("declarerId")] public string DeclarerId;

            [JsonProperty("cassusBelli")] public string CassusBelli;

            [JsonProperty("adminApproved")] public bool AdminApproved;

            [JsonProperty("defenderApproved")] public bool DefenderApproved;

            [JsonProperty("attackerPeaceOfferingTime"), JsonConverter(typeof(IsoDateTimeConverter))]
            public DateTime? AttackerPeaceOfferingTime;

            [JsonProperty("defenderPeaceOfferingTime"), JsonConverter(typeof(IsoDateTimeConverter))]
            public DateTime? DefenderPeaceOfferingTime;

            [JsonProperty("startTime"), JsonConverter(typeof(IsoDateTimeConverter))]
            public DateTime StartTime;

            [JsonProperty("endTime"), JsonConverter(typeof(IsoDateTimeConverter))]
            public DateTime? EndTime;

            [JsonProperty("endReason"), JsonConverter(typeof(StringEnumConverter))]
            public WarEndReason? EndReason;
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public partial class Imperium
    {
        private class WarManager
        {
            private List<War> Wars = new List<War>();

            public War[] GetAllActiveWars()
            {
                return Wars.Where(war => war.IsActive).OrderBy(war => war.StartTime).ToArray();
            }

            public War[] GetAllInactiveWars()
            {
                return Wars.Where(war => !war.IsActive).OrderBy(war => war.StartTime).ToArray();
            }

            public War[] GetAllActiveWarsByFaction(Faction faction)
            {
                return GetAllActiveWarsByFaction(faction.Id);
            }

            public War[] GetAllAdminUnnaprovedWars()
            {
                return GetAllInactiveWars().Where(war => !war.AdminApproved && war.EndTime == null)
                    .ToArray();
            }

            public War[] GetAllUnapprovedWarsByFaction(Faction faction)
            {
                return GetAllInactiveWars().Where(war => !war.IsActive && war.EndTime == null)
                    .ToArray();
            }

            public War[] GetAllActiveWarsByFaction(string factionId)
            {
                return GetAllActiveWars().Where(war => war.AttackerId == factionId || war.DefenderId == factionId)
                    .ToArray();
            }

            public War GetActiveWarBetween(Faction firstFaction, Faction secondFaction)
            {
                return GetActiveWarBetween(firstFaction.Id, secondFaction.Id);
            }

            public War GetActiveWarBetween(string firstFactionId, string secondFactionId)
            {
                return GetAllActiveWars().SingleOrDefault(war =>
                    (war.AttackerId == firstFactionId && war.DefenderId == secondFactionId) ||
                    (war.DefenderId == firstFactionId && war.AttackerId == secondFactionId)
                );
            }

            public bool AreFactionsAtWar(Faction firstFaction, Faction secondFaction)
            {
                return AreFactionsAtWar(firstFaction.Id, secondFaction.Id);
            }

            public bool AreFactionsAtWar(string firstFactionId, string secondFactionId)
            {
                return GetActiveWarBetween(firstFactionId, secondFactionId) != null;
            }

            public War DeclareWar(Faction attacker, Faction defender, User user, string cassusBelli)
            {
                var war = new War(attacker, defender, user, cassusBelli);
                Wars.Add(war);
                Instance.OnDiplomacyChanged();
                if (war.IsActive)
                {
                    Util.BroadcastEffect("assets/prefabs/missions/effects/mission_accept.prefab");
                }
                return war;
            }

            public bool TryShopfrontTreaty(BasePlayer player1, BasePlayer player2)
            {
                if (!Instance.Options.War.EnableShopfrontPeace)
                    return false;

                var user1 = Instance.Users.Get(player1);
                var user2 = Instance.Users.Get(player2);

                if (user1 == null || user2 == null)
                    return false;
                if (user1.Faction == null || user2.Faction == null)
                    return false;
                if (!Instance.Wars.AreFactionsAtWar(user1.Faction, user2.Faction))
                    return false;
                if (!user1.Faction.HasLeader(user1) || !user2.Faction.HasLeader(user2))
                    return false;
                EndWar(GetActiveWarBetween(user1.Faction, user2.Faction), WarEndReason.Treaty);
                Util.PrintToChat(nameof(Messages.WarEndedTreatyAcceptedAnnouncement), user1.Faction.Id, user2.Faction.Id);
                Instance.Log($"{Util.Format(user1)} and {Util.Format(user2)} accepted the peace by trading on a shop front");
                return true;
            }

            public void AdminApproveWar(War war)
            {
                war.AdminApproved = true;
                Instance.OnDiplomacyChanged();
                if (war.IsActive)
                {
                    Util.BroadcastEffect("assets/prefabs/missions/effects/mission_accept.prefab");
                }
            }

            public void AdminDenyeWar(War war)
            {
                war.AdminApproved = false;
                EndWar(war, WarEndReason.AdminDenied);
            }

            public void DefenderApproveWar(War war)
            {
                war.DefenderApproved = true;
                Instance.OnDiplomacyChanged();
                if (war.IsActive)
                {
                    Util.BroadcastEffect("assets/prefabs/missions/effects/mission_accept.prefab");
                }
            }

            public void DefenderDenyWar(War war)
            {
                war.DefenderApproved = false;
                EndWar(war, WarEndReason.DefenderDenied);
            }

            public void EndWar(War war, WarEndReason reason)
            {
                war.EndTime = DateTime.UtcNow;
                war.EndReason = reason;
                Instance.OnDiplomacyChanged();
            }

            public void EndAllWarsForEliminatedFactions()
            {
                bool dirty = false;

                foreach (War war in Wars)
                {
                    if (Instance.Areas.GetAllClaimedByFaction(war.AttackerId).Length == 0)
                    {
                        war.EndTime = DateTime.UtcNow;
                        war.EndReason = WarEndReason.DefenderEliminatedAttacker;
                        dirty = true;
                    }

                    if (Instance.Areas.GetAllClaimedByFaction(war.DefenderId).Length == 0)
                    {
                        war.EndTime = DateTime.UtcNow;
                        war.EndReason = WarEndReason.AttackerEliminatedDefender;
                        dirty = true;
                    }
                }

                if (dirty)
                    Instance.OnDiplomacyChanged();
            }

            public void Init(IEnumerable<WarInfo> warInfos)
            {
                Instance.Puts($"Loading {warInfos.Count()} wars...");

                foreach (WarInfo info in warInfos)
                {
                    var war = new War(info);
                    Wars.Add(war);
                    Instance.Log($"[LOAD] War {war.AttackerId} vs {war.DefenderId}, isActive = {war.IsActive}");
                }

                Instance.Puts("Wars loaded.");
            }
            public void Destroy()
            {
                Wars.Clear();
            }

            public WarInfo[] Serialize()
            {
                return Wars.Select(war => war.Serialize()).ToArray();
            }
        }
    }
}
#endregion

#region > Zone
namespace Oxide.Plugins
{
    using Rust;
    using System;
    using System.Collections.Generic;
    using UnityEngine;

    public partial class Imperium
    {
        private class Zone : MonoBehaviour
        {
            private const string SpherePrefab = "assets/prefabs/visualization/sphere.prefab";
            private List<BaseEntity> Spheres = new List<BaseEntity>();

            public ZoneType Type { get; private set; }
            public string Name { get; private set; }
            public MonoBehaviour Owner { get; private set; }
            public DateTime? EndTime { get; set; }

            public void Init(ZoneType type, string name, MonoBehaviour owner, float radius, int darkness,
                DateTime? endTime)
            {
                Type = type;
                Name = name;
                Owner = owner;
                EndTime = endTime;

                Vector3 position = GetGroundPosition(owner.transform.position);

                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = $"imperium_zone_{name.ToLowerInvariant()}";
                transform.position = position;
                transform.rotation = Quaternion.Euler(new Vector3(0, 0, 0));

                for (var idx = 0; idx < darkness; idx++)
                {
                    var sphere = GameManager.server.CreateEntity(SpherePrefab, position);

                    SphereEntity entity = sphere.GetComponent<SphereEntity>();
                    entity.lerpRadius = radius * 2;
                    entity.currentRadius = radius * 2;
                    entity.lerpSpeed = 0f;

                    sphere.Spawn();
                    Spheres.Add(sphere);
                }

                var collider = gameObject.AddComponent<SphereCollider>();
                collider.radius = radius;
                collider.isTrigger = true;
                collider.enabled = true;

                //Pin this zone to cargo ship so it follows it
                if (type == ZoneType.CargoShip)
                {
                    transform.SetParent(owner.transform, false);
                }

                if (endTime != null)
                    InvokeRepeating("CheckIfShouldDestroy", 10f, 5f);
            }

            private void OnDestroy()
            {
                var collider = GetComponent<SphereCollider>();

                if (collider != null)
                    Destroy(collider);

                foreach (BaseEntity sphere in Spheres)
                    sphere.KillMessage();

                if (IsInvoking("CheckIfShouldDestroy"))
                    CancelInvoke("CheckIfShouldDestroy");
            }

            private void OnTriggerEnter(Collider collider)
            {
                if (collider.gameObject.layer != (int)Layer.Player_Server)
                    return;

                var user = collider.GetComponentInParent<User>();

                if (user != null && !user.CurrentZones.Contains(this))
                    Events.OnUserEnteredZone(user, this);
            }

            private void OnTriggerExit(Collider collider)
            {
                if (collider.gameObject.layer != (int)Layer.Player_Server)
                    return;

                var user = collider.GetComponentInParent<User>();

                if (user != null && user.CurrentZones.Contains(this))
                    Events.OnUserLeftZone(user, this);
            }

            private void CheckIfShouldDestroy()
            {
                if (DateTime.UtcNow >= EndTime)
                    Instance.Zones.Remove(this);
            }

            private Vector3 GetGroundPosition(Vector3 pos)
            {
                return new Vector3(pos.x, TerrainMeta.HeightMap.GetHeight(pos), pos.z);
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using UnityEngine;

    public partial class Imperium
    {
        private class ZoneManager
        {
            private Dictionary<MonoBehaviour, Zone> Zones = new Dictionary<MonoBehaviour, Zone>();

            public void Init()
            {
                if (!Instance.Options.Zones.Enabled || Instance.Options.Zones.MonumentZones == null)
                    return;

                MonumentInfo[] monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>();
                foreach (MonumentInfo monument in monuments)
                {
                    float? radius = GetMonumentZoneRadius(monument);
                    if (radius != null)
                    {
                        Vector3 position = monument.transform.position;
                        Vector3 size = monument.Bounds.size;
                        Create(ZoneType.Monument, monument.displayPhrase.english, monument, (float)radius);
                    }
                }
            }

            public Zone GetByOwner(MonoBehaviour owner)
            {
                Zone zone;

                if (Zones.TryGetValue(owner, out zone))
                    return zone;

                return null;
            }

            public void CreateForDebrisField(BaseHelicopter helicopter)
            {
                Vector3 position = helicopter.transform.position;
                float radius = Instance.Options.Zones.EventZoneRadius;
                Create(ZoneType.Debris, "Debris Field", helicopter, radius, GetEventEndTime());
            }

            public void CreateForSupplyDrop(SupplyDrop drop)
            {
                Vector3 position = drop.transform.position;
                float radius = Instance.Options.Zones.EventZoneRadius;
                float lifespan = Instance.Options.Zones.EventZoneLifespanSeconds;
                Create(ZoneType.SupplyDrop, "Supply Drop", drop, radius, GetEventEndTime());
            }

            public void CreateForCargoShip(CargoShip cargoShip)
            {
                Vector3 position = cargoShip.transform.position;
                float radius = Instance.Options.Zones.EventZoneRadius;
                float lifespan = Instance.Options.Zones.EventZoneLifespanSeconds;
                Create(ZoneType.CargoShip, "Cargo Ship", cargoShip, radius, GetEventEndTime());
            }

            public void CreateForRaid(BuildingPrivlidge cupboard)
            {
                // If the building was already being raided, just extend the lifespan of the existing zone.
                Zone existingZone = GetByOwner(cupboard);
                if (existingZone)
                {
                    existingZone.EndTime = GetEventEndTime();
                    Instance.Puts(
                        $"Extending raid zone end time to {existingZone.EndTime} ({existingZone.EndTime.Value.Subtract(DateTime.UtcNow).ToShortString()} from now)");
                    return;
                }

                Vector3 position = cupboard.transform.position;
                float radius = Instance.Options.Zones.EventZoneRadius;

                Create(ZoneType.Raid, "Raid", cupboard, radius, GetEventEndTime());
            }

            public void Remove(Zone zone)
            {
                Instance.Puts($"Destroying zone {zone.name}");

                foreach (User user in Instance.Users.GetAll())
                    user.CurrentZones.Remove(zone);

                Zones.Remove(zone.Owner);

                UnityEngine.Object.Destroy(zone);
            }

            public void Destroy()
            {
                Zone[] zones = UnityEngine.Object.FindObjectsOfType<Zone>();

                if (zones != null)
                {
                    Instance.Puts($"Destroying {zones.Length} zone objects...");
                    foreach (Zone zone in zones)
                        UnityEngine.Object.DestroyImmediate(zone);
                }

                Zones.Clear();

                Instance.Puts("Zone objects destroyed.");
            }

            private void Create(ZoneType type, string name, MonoBehaviour owner, float radius, DateTime? endTime = null)
            {
                var zone = new GameObject().AddComponent<Zone>();
                zone.Init(type, name, owner, radius, Instance.Options.Zones.DomeDarkness, endTime);

                Instance.Puts($"Created zone {zone.Name} at {zone.transform.position} with radius {radius}");

                if (endTime != null)
                    Instance.Puts(
                        $"Zone {zone.Name} will be destroyed at {endTime} ({endTime.Value.Subtract(DateTime.UtcNow).ToShortString()} from now)");

                Zones.Add(owner, zone);
            }

            private float? GetMonumentZoneRadius(MonumentInfo monument)
            {
                if (monument.Type == MonumentType.Cave)
                    return null;

                foreach (var entry in Instance.Options.Zones.MonumentZones)
                {
                    if (monument.name.ToLowerInvariant().Contains(entry.Key))
                        return entry.Value;
                }

                return null;
            }

            private DateTime GetEventEndTime()
            {
                return DateTime.UtcNow.AddSeconds(Instance.Options.Zones.EventZoneLifespanSeconds);
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        public enum ZoneType
        {
            Monument,
            Debris,
            SupplyDrop,
            Raid,
            CargoShip
        }
    }
}
#endregion

#region > Recruit
namespace Oxide.Plugins
{
    using Rust;
    using UnityEngine;
    public partial class Imperium
    {
        public class Recruit : MonoBehaviour
        {
        }
    }
}
namespace Oxide.Plugins
{
    public partial class Imperium
    {
        public class RecruitInfo
        {
            //Existing bots serialized info
        }
    }
}
namespace Oxide.Plugins
{
    public partial class Imperium
    {
        public class RecruitManager
        {
            //Bot management
        }
    }
}
#endregion

#region > Faction Colors
namespace Oxide.Plugins
{
    using System.Collections.Generic;
    using System.Drawing;
    public partial class Imperium
    {
        private class FactionColorPicker
        {
            private static string[] Colors = new[]
            {
                "#00FF00", "#0000FF", "#FF0000", "#01FFFE", "#FFA6FE",
                "#FFDB66", "#006401", "#010067", "#95003A", "#007DB5",
                "#FF00F6", "#FFEEE8", "#774D00", "#90FB92", "#0076FF",
                "#D5FF00", "#FF937E", "#6A826C", "#FF029D", "#FE8900",
                "#7A4782", "#7E2DD2", "#85A900", "#FF0056", "#A42400",
                "#00AE7E", "#683D3B", "#BDC6FF", "#263400", "#BDD393",
                "#00B917", "#9E008E", "#001544", "#C28C9F", "#FF74A3",
                "#01D0FF", "#004754", "#E56FFE", "#788231", "#0E4CA1",
                "#91D0CB", "#BE9970", "#968AE8", "#BB8800", "#43002C",
                "#DEFF74", "#00FFC6", "#FFE502", "#620E00", "#008F9C",
                "#98FF52", "#7544B1", "#B500FF", "#00FF78", "#FF6E41",
                "#005F39", "#6B6882", "#5FAD4E", "#A75740", "#A5FFD2",
                "#FFB167", "#009BFF", "#E85EBE"
            };
            private Dictionary<string, Color> AssignedColors;
            private int NextColor = 0;

            public FactionColorPicker()
            {
                AssignedColors = new Dictionary<string, Color>();
            }

            public Color GetColorForFaction(string factionId)
            {
                Color color;

                if (!AssignedColors.TryGetValue(factionId, out color))
                {
                    color = Color.FromArgb(128, ColorTranslator.FromHtml(Colors[NextColor]));
                    AssignedColors.Add(factionId, color);
                    NextColor = (NextColor + 1) % Colors.Length;
                }

                return color;
            }

            public string GetHexColorForFaction(string factionId)
            {
                string hexcolor;
                Color color;

                if (!AssignedColors.TryGetValue(factionId, out color))
                {
                    color = Color.FromArgb(128, ColorTranslator.FromHtml(Colors[NextColor]));
                    AssignedColors.Add(factionId, color);
                    NextColor = (NextColor + 1) % Colors.Length;
                }
                hexcolor = $"#{color.R:X2}{color.G:X2}{color.B:X2}";

                return hexcolor;
            }
        }
    }
}
#endregion

#region > Map
namespace Oxide.Plugins
{
    using System;
    using UnityEngine;

    public partial class Imperium
    {
        public class MapGrid
        {
            public float GRID_CELL_SIZE = 146.3f;

            public float MapSize
            {
                get; set;
            }
            public float MapWidth
            {
                get; set;
            }

            public float MapHeight
            {
                get; set;
            }
            public float MapOffsetX
            {
                get; set;
            }

            public float MapOffsetZ
            {
                get; set;
            }

            public float CellSize
            {
                get; set;
            }

            public float CellSizeRatio
            {
                get { return (float)MapSize / CellSize; }
            }

            public float CellSizeRatioWidth
            {
                get { return (float)MapWidth / CellSize; }
            }

            public float CellSizeRatioHeight
            {
                get { return (float)MapHeight / CellSize; }
            }

            public int NumberOfCells { get; private set; }
            public int NumberOfColumns { get; private set; }
            public int NumberOfRows { get; private set; }

            private string[] RowIds;
            private string[] ColumnIds;
            private string[,] AreaIds;
            private Vector3[,] Positions;

            public MapGrid()
            {

                MapSize = TerrainMeta.Size.x;

                NumberOfRows = Mathf.FloorToInt((MapSize * 7) / 1024);
                NumberOfColumns = Mathf.FloorToInt((MapSize * 7) / 1024);

                CellSize = MapSize / NumberOfRows;

                MapWidth = Mathf.Floor(TerrainMeta.Size.x / CellSize) * CellSize;
                MapHeight = Mathf.Floor(TerrainMeta.Size.z / CellSize) * CellSize;

                MapWidth = NumberOfColumns * CellSize;
                MapHeight = NumberOfRows * CellSize;

                MapOffsetX = 0f;
                MapOffsetZ = 0f;
                RowIds = new string[NumberOfRows];
                ColumnIds = new string[NumberOfColumns];
                AreaIds = new string[NumberOfColumns, NumberOfRows];
                Positions = new Vector3[NumberOfColumns, NumberOfRows];
                Build();
            }

            public string GetRowId(int row)
            {
                return RowIds[row];
            }

            public string GetColumnId(int col)
            {
                return ColumnIds[col];
            }

            public string GetAreaId(int row, int col)
            {
                return AreaIds[row, col];
            }

            public Vector3 GetPosition(int row, int col)
            {
                return Positions[row, col];
            }

            private void Build()
            {
                string prefix = "";
                char letter = 'A';

                for (int col = 0; col < NumberOfColumns; col++)
                {
                    ColumnIds[col] = prefix + letter;
                    if (letter == 'Z')
                    {
                        prefix = "A";
                        letter = 'A';
                    }
                    else
                    {
                        letter++;
                    }
                }

                for (int row = 0; row < NumberOfRows; row++)
                    RowIds[row] = row.ToString();

                float z = (MapHeight / 2) - CellSize / 2 - (MapOffsetZ / 2) + (CellSize * Instance.Options.Map.MapGridYOffset);
                for (int row = 0; row < NumberOfRows; row++)
                {
                    float x = -(MapWidth / 2) + CellSize / 2 - (MapOffsetX / 2);
                    for (int col = 0; col < NumberOfColumns; col++)
                    {
                        var areaId = ColumnIds[col] + RowIds[row];
                        AreaIds[row, col] = areaId;
                        Positions[row, col] = new Vector3(x, 0, z);
                        x += CellSize;
                    }

                    z -= CellSize;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System.Collections;
    using System.Drawing;
    using System.Drawing.Drawing2D;

    public partial class Imperium
    {
        private class MapOverlayGenerator : UnityEngine.MonoBehaviour
        {
            public bool IsGenerating { get; private set; }

            public void Generate()
            {
                if (!IsGenerating)
                    StartCoroutine(GenerateOverlayImage());
            }

            private IEnumerator GenerateOverlayImage()
            {
                IsGenerating = true;
                Instance.Puts("Generating new map overlay image...");

                using (var bitmap = new Bitmap(Instance.Options.Map.ImageSize, Instance.Options.Map.ImageSize))
                using (var graphics = Graphics.FromImage(bitmap))
                {
                    var grid = Instance.Areas.MapGrid;
                    var tileSize = (int)(Instance.Options.Map.ImageSize / grid.CellSizeRatio);

                    var colorPicker = new FactionColorPicker();
                    var textBrush = new SolidBrush(Color.FromArgb(255, 255, 255, 255));

                    for (int row = 0; row < grid.NumberOfRows; row++)
                    {
                        for (int col = 0; col < grid.NumberOfColumns; col++)
                        {
                            Area area = Instance.Areas.Get(row, col);
                            var x = (col * tileSize);
                            var y = (row * tileSize);
                            var rect = new Rectangle(x, y, tileSize, tileSize);

                            if (area.Type == AreaType.Badlands)
                            {
                                // If the tile is badlands, color it in black.
                                var brush = new HatchBrush(HatchStyle.BackwardDiagonal, Color.FromArgb(32, 0, 0, 0),
                                    Color.FromArgb(255, 0, 0, 0));
                                graphics.FillRectangle(brush, rect);
                            }
                            else if (area.Type != AreaType.Wilderness)
                            {
                                // If the tile is claimed, fill it with a color indicating the faction.
                                var brush = new SolidBrush(colorPicker.GetColorForFaction(area.FactionId));
                                graphics.FillRectangle(brush, rect);
                            }

                            yield return null;
                        }
                    }

                    var gridLabelFont = new Font("Consolas", 14, FontStyle.Bold);
                    var gridLabelOffset = 5;
                    var gridLinePen = new Pen(Color.FromArgb(192, 0, 0, 0), 2);

                    for (int row = 0; row < grid.NumberOfRows; row++)
                    {
                        if (row > 0)
                            graphics.DrawLine(gridLinePen, 0, (row * tileSize), (grid.NumberOfRows * tileSize),
                                (row * tileSize));
                        graphics.DrawString(grid.GetRowId(row), gridLabelFont, textBrush, gridLabelOffset,
                            (row * tileSize) + gridLabelOffset);
                    }

                    for (int col = 1; col < grid.NumberOfColumns; col++)
                    {
                        graphics.DrawLine(gridLinePen, (col * tileSize), 0, (col * tileSize),
                            (grid.NumberOfColumns * tileSize));
                        graphics.DrawString(grid.GetColumnId(col), gridLabelFont, textBrush,
                            (col * tileSize) + gridLabelOffset, gridLabelOffset);
                    }

                    var converter = new ImageConverter();
                    var imageData = (byte[])converter.ConvertTo(bitmap, typeof(byte[]));

                    Image image = Instance.Hud.RegisterImage(UI.MapOverlayImageUrl, imageData, true);

                    Instance.Puts($"Generated new map overlay image {image.Id}.");
                    Instance.Log($"Created new map overlay image {image.Id}.");

                    IsGenerating = false;
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        public static class MonumentPrefab
        {
            private const string PrefabPrefix = "assets/bundled/prefabs/autospawn/monument/";

            public const string Airfield = PrefabPrefix + "large/airfield_1.prefab";
            public const string BanditTown = PrefabPrefix + "medium/bandit_town.prefab";
            public const string Compound = PrefabPrefix + "medium/compound.prefab";
            public const string Dome = PrefabPrefix + "small/sphere_tank.prefab";
            public const string Harbor1 = PrefabPrefix + "harbor/harbor_1.prefab";
            public const string Harbor2 = PrefabPrefix + "harbor/harbor_2.prefab";
            public const string GasStation = PrefabPrefix + "small/gas_station_1.prefab";
            public const string Junkyard = PrefabPrefix + "large/junkyard_1.prefab";
            public const string LaunchSite = PrefabPrefix + "large/launch_site_1.prefab";
            public const string Lighthouse = PrefabPrefix + "lighthouse/lighthouse.prefab";
            public const string MilitaryTunnel = PrefabPrefix + "large/military_tunnel_1.prefab";
            public const string MiningOutpost = PrefabPrefix + "small/warehouse.prefab";
            public const string QuarryStone = PrefabPrefix + "small/mining_quarry_a.prefab";
            public const string QuarrySulfur = PrefabPrefix + "small/mining_quarry_b.prefab";
            public const string QuaryHqm = PrefabPrefix + "small/mining_quarry_c.prefab";
            public const string PowerPlant = PrefabPrefix + "large/powerplant_1.prefab";
            public const string Trainyard = PrefabPrefix + "large/trainyard_1.prefab";
            public const string SatelliteDish = PrefabPrefix + "small/satellite_dish.prefab";
            public const string SewerBranch = PrefabPrefix + "medium/radtown_small_3.prefab";
            public const string Supermarket = PrefabPrefix + "small/supermarket_1.prefab";
            public const string WaterTreatmentPlant = PrefabPrefix + "large/water_treatment_plant_1.prefab";
            public const string WaterWellA = PrefabPrefix + "tiny/water_well_a.prefab";
            public const string WaterWellB = PrefabPrefix + "tiny/water_well_b.prefab";
            public const string WaterWellC = PrefabPrefix + "tiny/water_well_c.prefab";
            public const string WaterWellD = PrefabPrefix + "tiny/water_well_d.prefab";
            public const string WaterWellE = PrefabPrefix + "tiny/water_well_e.prefab";
        }
    }
}
#endregion

#region > Permissions
namespace Oxide.Plugins
{
    using System.Reflection;

    public partial class Imperium : RustPlugin
    {
        public static class Permission
        {
            public const string AdminFactions = "imperium.factions.admin";
            public const string AdminClaims = "imperium.claims.admin";
            public const string AdminBadlands = "imperium.badlands.admin";
            public const string AdminWars = "imperium.wars.admin";
            public const string AdminPins = "imperium.pins.admin";
            public const string ManageFactions = "imperium.factions";

            public static void RegisterAll(Imperium instance)
            {
                foreach (FieldInfo field in typeof(Permission).GetFields(BindingFlags.Public | BindingFlags.Static))
                    instance.permission.RegisterPermission((string)field.GetRawConstantValue(), instance);
            }
        }
    }
}
#endregion

#region > Utilities
namespace Oxide.Plugins
{
    using System;
    using Newtonsoft.Json;
    using UnityEngine;

    public partial class Imperium : RustPlugin
    {
        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue,
                JsonSerializer serializer)
            {
                string[] tokens = reader.Value.ToString().Trim().Split(' ');
                float x = Convert.ToSingle(tokens[0]);
                float y = Convert.ToSingle(tokens[1]);
                float z = Convert.ToSingle(tokens[2]);
                return new Vector3(x, y, z);
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Collections;
    using System.Text;
    using UnityEngine;

    public partial class Imperium
    {
        private static class Util
        {
            private const string NullString = "(null)";

            public static string Format(object obj)
            {
                if (obj == null) return NullString;

                var user = obj as User;
                if (user != null) return Format(user);

                var area = obj as Area;
                if (area != null) return Format(area);

                var entity = obj as BaseEntity;
                if (entity != null) return Format(entity);

                var list = obj as IEnumerable;
                if (list != null) return Format(list);

                return obj.ToString();
            }

            public static string Format(User user)
            {
                if (user == null)
                    return NullString;
                else
                    return $"{user.UserName} ({user.Id})";
            }

            public static string Format(Area area)
            {
                if (area == null)
                    return NullString;
                else if (!String.IsNullOrEmpty(area.Name))
                    return $"{area.Id} ({area.Name})";
                else
                    return area.Id;
            }

            public static string Format(BaseEntity entity)
            {
                if (entity == null)
                    return NullString;
                else if (entity.net == null)
                    return "(missing networkable)";
                else
                    return entity.net.ID.ToString();
            }

            public static string Format(IEnumerable items)
            {
                var sb = new StringBuilder();

                foreach (object item in items)
                    sb.Append($"{Format(item)}, ");

                sb.Remove(sb.Length - 2, 2);

                return sb.ToString();
            }

            public static string NormalizeAreaId(string input)
            {
                return input.ToUpper().Trim();
            }

            public static string NormalizeAreaName(string input)
            {
                return RemoveSpecialCharacters(input.Trim());
            }

            public static string NormalizePinName(string input)
            {
                return RemoveSpecialCharacters(input.Trim());
            }

            public static string NormalizeFactionId(string input)
            {
                string factionId = input.Trim();

                if (factionId.StartsWith("[") && factionId.EndsWith("]"))
                    factionId = factionId.Substring(1, factionId.Length - 2);

                return factionId;
            }

            public static string RemoveSpecialCharacters(string str)
            {
                if (String.IsNullOrEmpty(str))
                    return String.Empty;

                StringBuilder sb = new StringBuilder(str.Length);
                foreach (char c in str)
                {
                    if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
                        (c >= 'А' && c <= 'Я') || (c >= 'а' && c <= 'я') || c == ' ' || c == '.' || c == '_')
                        sb.Append(c);
                }

                return sb.ToString();
            }

            public static int GetLevenshteinDistance(string source, string target)
            {
                if (string.IsNullOrEmpty(source) && string.IsNullOrEmpty(target))
                    return 0;

                if (source.Length == target.Length)
                    return source.Length;

                if (source.Length == 0)
                    return target.Length;

                if (target.Length == 0)
                    return source.Length;

                var distance = new int[source.Length + 1, target.Length + 1];

                for (int idx = 0; idx <= source.Length; distance[idx, 0] = idx++) ;
                for (int idx = 0; idx <= target.Length; distance[0, idx] = idx++) ;

                for (int i = 1; i <= source.Length; i++)
                {
                    for (int j = 1; j <= target.Length; j++)
                    {
                        int cost = target[j - 1] == source[i - 1] ? 0 : 1;
                        distance[i, j] = Math.Min(
                            Math.Min(distance[i - 1, j] + 1, distance[i, j - 1] + 1),
                            distance[i - 1, j - 1] + cost
                        );
                    }
                }

                return distance[source.Length, target.Length];
            }

            public static bool TryParseEnum<T>(string str, out T value) where T : struct
            {
                if (!typeof(T).IsEnum)
                    throw new ArgumentException("Type parameter must be an enum");

                foreach (var name in Enum.GetNames(typeof(T)))
                {
                    if (String.Equals(name, str, StringComparison.OrdinalIgnoreCase))
                    {
                        value = (T)Enum.Parse(typeof(T), name);
                        return true;
                    }
                }

                value = default(T);
                return false;
            }

            public static void RunEffect(Vector3 position, string prefab, BasePlayer player = null)
            {
                var effect = new Effect();
                effect.Init(Effect.Type.Generic, position, Vector3.zero);
                effect.pooledString = prefab;

                if (player != null)
                {
                    EffectNetwork.Send(effect, player.net.connection);
                }
                else
                {
                    EffectNetwork.Send(effect);
                }
            }

            public static void BroadcastEffect(string prefab)
            {
                Vector3 position;
                BasePlayer player;
                foreach (User user in Instance.Users.GetAll())
                {
                    player = user.Player;
                    position = user.transform.position;
                    if (player)
                    {
                        var effect = new Effect();
                        effect.Init(Effect.Type.Generic, position, Vector3.zero);
                        effect.pooledString = prefab;
                        EffectNetwork.Send(effect, player.net.connection);
                    }
                }
            }

            public static void PrintToChat(string format, params object[] args)
            {
                foreach (User user in Instance.Users.GetAll())
                {
                    if (user.Player)
                    {
                        string message = Instance.lang.GetMessage(format, Instance, user.Player.userID.ToString());
                        user.SendChatMessage(message, args);
                    }
                }

            }

            public static int GetSecondsBetween(DateTime start, DateTime end)
            {
                return (int)(start - end).TotalSeconds;
            }

            public static Color ConvertSystemToUnityColor(System.Drawing.Color color)
            {
                Color result;
                result.r = color.R;
                result.g = color.G;
                result.b = color.B;
                result.a = 255f;
                return result;
            }
        }
    }
}
#endregion

#region > Interactions
namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;

    public partial class Imperium
    {
        private class AddingClaimInteraction : Interaction
        {
            public Faction Faction { get; private set; }

            public AddingClaimInteraction(Faction faction)
            {
                Faction = faction;
            }

            public override bool TryComplete(HitInfo hit)
            {
                var cupboard = hit.HitEntity as BuildingPrivlidge;
                Area area = User.CurrentArea;

                if (area == null)
                    return false;

                if (!Instance.EnsureUserCanChangeFactionClaims(User, Faction))
                    return false;

                if (!Instance.EnsureCupboardCanBeUsedForClaim(User, cupboard))
                    return false;

                if (!Instance.EnsureFactionCanClaimArea(User, Faction, area))
                    return false;

                Area[] claimedAreas = Instance.Areas.GetAllClaimedByFaction(Faction);
                AreaType type = (claimedAreas.Length == 0) ? AreaType.Headquarters : AreaType.Claimed;

                if (area.Type == AreaType.Wilderness)
                {
                    int cost = area.GetClaimCost(Faction);

                    if (cost > 0)
                    {
                        ItemDefinition scrapDef = ItemManager.FindItemDefinition("scrap");
                        List<Item> stacks = User.Player.inventory.FindItemsByItemID(scrapDef.itemid);

                        if (!Instance.TryCollectFromStacks(scrapDef, stacks, cost))
                        {
                            User.SendChatMessage(nameof(Messages.CannotClaimAreaCannotAfford), cost);
                            return false;
                        }
                    }

                    User.SendChatMessage(nameof(Messages.ClaimAdded), area.Id);

                    if (type == AreaType.Headquarters)
                    {
                        Util.PrintToChat(nameof(Messages.AreaClaimedAsHeadquartersAnnouncement), Faction.Id, area.Id);
                        Faction.NextUpkeepPaymentTime =
                            DateTime.UtcNow.AddHours(Instance.Options.Upkeep.CollectionPeriodHours);
                    }
                    else
                    {
                        Util.PrintToChat(nameof(Messages.AreaClaimedAnnouncement), Faction.Id, area.Id);
                    }
                    Util.RunEffect(User.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
                    Instance.Log($"{Util.Format(User)} claimed {area.Id} on behalf of {Faction.Id}");
                    Instance.Areas.Claim(area, type, Faction, User, cupboard);

                    return true;
                }

                if (area.FactionId == Faction.Id)
                {
                    if (area.ClaimCupboard.net.ID == cupboard.net.ID)
                    {
                        User.SendChatMessage(nameof(Messages.CannotClaimAreaAlreadyOwned), area.Id);
                        return false;
                    }
                    else
                    {
                        // If the same faction claims a new cupboard within the same area, move the claim to the new cupboard.
                        User.SendChatMessage(nameof(Messages.ClaimCupboardMoved), area.Id);
                        Instance.Log(
                            $"{Util.Format(User)} moved {area.FactionId}'s claim on {area.Id} from cupboard {Util.Format(area.ClaimCupboard)} to cupboard {Util.Format(cupboard)}");
                        area.ClaimantId = User.Id;
                        area.ClaimCupboard = cupboard;
                        Util.RunEffect(User.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
                        return true;
                    }
                }

                if (area.FactionId != Faction.Id)
                {
                    if (area.ClaimCupboard.net.ID != cupboard.net.ID)
                    {
                        // A new faction can't make a claim on a new cabinet within an area that is already claimed by another faction.
                        User.SendChatMessage(nameof(Messages.CannotClaimAreaAlreadyClaimed), area.Id, area.FactionId);
                        return false;
                    }

                    string previousFactionId = area.FactionId;

                    // If a new faction claims the claim cabinet for an area, they take control of that area.
                    User.SendChatMessage(nameof(Messages.ClaimCaptured), area.Id, area.FactionId);
                    Util.PrintToChat(nameof(Messages.AreaCapturedAnnouncement), Faction.Id, area.Id, area.FactionId);
                    Instance.Log(
                        $"{Util.Format(User)} captured the claim on {area.Id} from {area.FactionId} on behalf of {Faction.Id}");

                    Instance.Areas.Claim(area, type, Faction, User, cupboard);
                    Util.RunEffect(User.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
                    return true;
                }

                Instance.PrintWarning(
                    "Area was in an unknown state during completion of AddingClaimInteraction. This shouldn't happen.");
                return false;
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private class AssigningClaimInteraction : Interaction
        {
            public Faction Faction { get; private set; }

            public AssigningClaimInteraction(Faction faction)
            {
                Faction = faction;
            }

            public override bool TryComplete(HitInfo hit)
            {
                var cupboard = hit.HitEntity as BuildingPrivlidge;

                Area area = User.CurrentArea;

                if (area == null)
                {
                    User.SendChatMessage(nameof(Messages.YouAreInTheGreatUnknown));
                    return false;
                }

                if (area.Type == AreaType.Badlands)
                {
                    User.SendChatMessage(nameof(Messages.AreaIsBadlands), area.Id);
                    return false;
                }

                Area[] ownedAreas = Instance.Areas.GetAllClaimedByFaction(Faction);
                AreaType type = (ownedAreas.Length == 0) ? AreaType.Headquarters : AreaType.Claimed;

                Util.PrintToChat(nameof(Messages.AreaClaimAssignedAnnouncement), Faction.Id, area.Id);
                Instance.Log($"{Util.Format(User)} assigned {area.Id} to {Faction.Id}");

                Instance.Areas.Claim(area, type, Faction, User, cupboard);
                Util.RunEffect(User.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
                return true;
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private abstract class Interaction
        {
            public User User { get; set; }
            public abstract bool TryComplete(HitInfo hit);
        }
    }
}

namespace Oxide.Plugins
{
    using System.Linq;
    public partial class Imperium
    {
        private class RemovingClaimInteraction : Interaction
        {
            public Faction Faction { get; private set; }

            public RemovingClaimInteraction(Faction faction)
            {
                Faction = faction;
            }

            public override bool TryComplete(HitInfo hit)
            {
                var cupboard = hit.HitEntity as BuildingPrivlidge;
                var fAreas = Instance.Areas.GetAllClaimedByFaction(Faction).ToList();
                if (!Instance.EnsureUserCanChangeFactionClaims(User, Faction) ||
                    !Instance.EnsureCupboardCanBeUsedForClaim(User, cupboard))
                    return false;

                Area area = Instance.Areas.GetByClaimCupboard(cupboard);

                if (area == null)
                {
                    User.SendChatMessage(nameof(Messages.SelectingCupboardFailedNotClaimCupboard));
                    return false;
                }



                if (fAreas.Count > 1 && area.Type == AreaType.Headquarters)
                {
                    User.SendChatMessage(nameof(Messages.SelectingCupboardFailedCantUnclaimHeadquarters));
                    return false;
                }

                Util.PrintToChat(nameof(Messages.AreaClaimRemovedAnnouncement), Faction.Id, area.Id);
                Instance.Log($"{Util.Format(User)} removed {Faction.Id}'s claim on {area.Id}");

                Instance.Areas.Unclaim(area);
                Util.RunEffect(User.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
                return true;
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private class SelectingHeadquartersInteraction : Interaction
        {
            public Faction Faction { get; private set; }

            public SelectingHeadquartersInteraction(Faction faction)
            {
                Faction = faction;
            }

            public override bool TryComplete(HitInfo hit)
            {
                var cupboard = hit.HitEntity as BuildingPrivlidge;

                if (!Instance.EnsureUserCanChangeFactionClaims(User, Faction) ||
                    !Instance.EnsureCupboardCanBeUsedForClaim(User, cupboard))
                    return false;

                Area area = Instance.Areas.GetByClaimCupboard(cupboard);
                if (area == null)
                {
                    User.SendChatMessage(nameof(Messages.SelectingCupboardFailedNotClaimCupboard));
                    return false;
                }

                Util.PrintToChat(nameof(Messages.HeadquartersChangedAnnouncement), Faction.Id, area.Id);
                Instance.Log($"{Util.Format(User)} set {Faction.Id}'s headquarters to {area.Id}");

                Instance.Areas.SetHeadquarters(area, Faction);
                Util.RunEffect(User.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
                return true;
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private class SelectingTaxChestInteraction : Interaction
        {
            public Faction Faction { get; private set; }

            public SelectingTaxChestInteraction(Faction faction)
            {
                Faction = faction;
            }

            public override bool TryComplete(HitInfo hit)
            {
                var container = hit.HitEntity as StorageContainer;

                if (container == null)
                {
                    User.SendChatMessage(nameof(Messages.SelectingTaxChestFailedInvalidTarget));
                    return false;
                }

                User.SendChatMessage(nameof(Messages.SelectingTaxChestSucceeded), Faction.TaxRate * 100, Faction.Id);
                Instance.Log($"{Util.Format(User)} set {Faction.Id}'s tax chest to entity {Util.Format(container)}");
                Instance.Factions.SetTaxChest(Faction, container);
                Util.RunEffect(User.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
                return true;
            }
        }
    }
}

namespace Oxide.Plugins
{
    public partial class Imperium
    {
        private class SelectingArmoryLockerInteraction : Interaction
        {
            public Faction Faction { get; private set; }

            public SelectingArmoryLockerInteraction(Faction faction)
            {
                Faction = faction;
            }

            public override bool TryComplete(HitInfo hit)
            {
                var container = hit.HitEntity as Locker;
                if (container == null)
                {
                    User.SendChatMessage(nameof(Messages.SelectingArmoryLockerFailedInvalidTarget));
                    return false;
                }
                var area = Instance.Areas.GetByEntityPosition(container);
                if (!Instance.EnsureLockerCanBeUsedForArmory(User, container, area))
                    return false;
                User.SendChatMessage(nameof(Messages.SelectingArmoryLockerSucceeded), area.Id);
                Instance.Log($"{Util.Format(User)} set {Faction.Id}'s armory locker to entity {Util.Format(container)} at {area.Id}");
                Instance.Areas.SetArmory(area, container);
                Util.RunEffect(User.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
                return true;
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System.Linq;
    public partial class Imperium
    {
        private class TransferringClaimInteraction : Interaction
        {
            public Faction SourceFaction { get; }
            public Faction TargetFaction { get; }

            public TransferringClaimInteraction(Faction sourceFaction, Faction targetFaction)
            {
                SourceFaction = sourceFaction;
                TargetFaction = targetFaction;
            }

            public override bool TryComplete(HitInfo hit)
            {
                var cupboard = hit.HitEntity as BuildingPrivlidge;
                var fAreas = Instance.Areas.GetAllClaimedByFaction(SourceFaction).ToList();
                if (!Instance.EnsureUserCanChangeFactionClaims(User, SourceFaction) ||
                    !Instance.EnsureCupboardCanBeUsedForClaim(User, cupboard))
                    return false;

                Area area = Instance.Areas.GetByClaimCupboard(cupboard);

                if (area == null)
                {
                    User.SendChatMessage(nameof(Messages.SelectingCupboardFailedNotClaimCupboard));
                    return false;
                }

                if (area.FactionId != SourceFaction.Id)
                {
                    User.SendChatMessage(nameof(Messages.AreaNotOwnedByYourFaction), area.Id);
                    return false;
                }

                if (!Instance.EnsureFactionCanClaimArea(User, TargetFaction, area))
                    return false;



                if (fAreas.Count > 1 && area.Type == AreaType.Headquarters)
                {
                    User.SendChatMessage(nameof(Messages.SelectingCupboardFailedCantUnclaimHeadquarters));
                    return false;
                }

                Area[] claimedAreas = Instance.Areas.GetAllClaimedByFaction(TargetFaction);
                AreaType type = (claimedAreas.Length == 0) ? AreaType.Headquarters : AreaType.Claimed;

                Util.PrintToChat(nameof(Messages.AreaClaimTransferredAnnouncement), SourceFaction.Id, area.Id,
                    TargetFaction.Id);
                Instance.Log(
                    $"{Util.Format(User)} transferred {SourceFaction.Id}'s claim on {area.Id} to {TargetFaction.Id}");
                Util.RunEffect(User.transform.position, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
                Instance.Areas.Claim(area, type, TargetFaction, User, cupboard);

                return true;
            }
        }
    }
}
#endregion

#region > Options
namespace Oxide.Plugins
{
    using Newtonsoft.Json;

    public partial class Imperium : RustPlugin
    {
        private class BadlandsOptions
        {
            [JsonProperty("enabled")] public bool Enabled;

            public static BadlandsOptions Default = new BadlandsOptions
            {
                Enabled = true
            };
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;
    using System.Collections.Generic;

    public partial class Imperium : RustPlugin
    {
        private class ClaimOptions
        {
            [JsonProperty("enabled")] public bool Enabled;

            [JsonProperty("costs")] public List<int> Costs = new List<int>();

            [JsonProperty("maxClaims")] public int? MaxClaims;

            [JsonProperty("minAreaNameLength")] public int MinAreaNameLength;

            [JsonProperty("maxAreaNameLength")] public int MaxAreaNameLength;

            [JsonProperty("minFactionMembers")] public int MinFactionMembers;

            [JsonProperty("requireContiguousClaims")]
            public bool RequireContiguousClaims;

            public static ClaimOptions Default = new ClaimOptions
            {
                Enabled = true,
                Costs = new List<int> { 50, 100, 200, 300, 400, 500 },
                MaxClaims = null,
                MinAreaNameLength = 3,
                MaxAreaNameLength = 20,
                MinFactionMembers = 1,
                RequireContiguousClaims = true
            };
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;

    public partial class Imperium : RustPlugin
    {
        private class DecayOptions
        {
            [JsonProperty("enabled")] public bool Enabled;

            [JsonProperty("claimedLandDecayReduction")]
            public float ClaimedLandDecayReduction;

            public static DecayOptions Default = new DecayOptions
            {
                Enabled = false,
                ClaimedLandDecayReduction = 0.5f
            };
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;

    public partial class Imperium : RustPlugin
    {
        private class FactionOptions
        {
            [JsonProperty("minFactionNameLength")] public int MinFactionNameLength = 1;

            [JsonProperty("maxFactionNameLength")] public int MaxFactionNameLength = 8;

            [JsonProperty("maxMembers")] public int? MaxMembers;

            [JsonProperty("allowFactionBadlands")] public bool AllowFactionBadlands = false;

            [JsonProperty("factionBadlandsCommandCooldownSeconds")] public int CommandCooldownSeconds = 300;

            [JsonProperty("overrideInGameTeamSystem")] public bool OverrideInGameTeamSystem = false;

            [JsonProperty("memberOwnLandEcoRaidingDamageScale")] public float MemberOwnLandEcoRaidingDamageScale = 1f;

            [JsonProperty("memberOwnLandExplosiveRaidingDamageScale")] public float MemberOwnLandExplosiveRaidingDamageScale = 1f;

            [JsonProperty("useClansPlugin")] private bool _UseClansPlugin = false;

            [JsonIgnore]
            public bool UseClansPlugin { get { return (_UseClansPlugin && Instance.Clans != null); } }

            public static FactionOptions Default = new FactionOptions
            {
                MinFactionNameLength = 1,
                MaxFactionNameLength = 8,
                MaxMembers = null,
                AllowFactionBadlands = false,
                CommandCooldownSeconds = 600,
                OverrideInGameTeamSystem = true,
                MemberOwnLandEcoRaidingDamageScale = 1f,
                MemberOwnLandExplosiveRaidingDamageScale = 1f,
                _UseClansPlugin = false
            };


        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;
    using System.Collections.Generic;
    public partial class Imperium : RustPlugin
    {
        private class UpgradingOptions
        {
            [JsonProperty("enabled [THIS IS NOT AVAILABLE YET]")] public bool Enabled = false;
            [JsonProperty("maxUpgradeLevel")] public int MaxUpgradeLevel = 10;
            [JsonProperty("maxProduceBonus")] public float MaxProduceBonus = 0.5f;
            [JsonProperty("maxTaxChestBonus")] public float MaxTaxChestBonus = 1f;
            [JsonProperty("maxRaidDefenseBonus")] public float MaxRaidDefenseBonus = 0.2f;
            [JsonProperty("maxDecayExtraReduction")] public float MaxDecayExtraReduction = 1f;
            [JsonProperty("maxRecruitBotBuffs")] public float MaxRecruitBotsBuffs = 0.2f;
            [JsonProperty("costs")] public List<int> Costs = new List<int>();

            public static UpgradingOptions Default = new UpgradingOptions
            {
                Enabled = false,
                MaxUpgradeLevel = 10,
                MaxProduceBonus = 0.5f,
                MaxTaxChestBonus = 1f,
                MaxRaidDefenseBonus = 0.2f,
                MaxDecayExtraReduction = 1f,
                MaxRecruitBotsBuffs = 0.2f,
                Costs = new List<int> { 0, 100, 200, 300, 400, 500 }
            };
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;

    public partial class Imperium : RustPlugin
    {
        private class MapOptions
        {

            [JsonProperty("mapGridYOffset")] public int MapGridYOffset;

            [JsonProperty("pinsEnabled")] public bool PinsEnabled;

            [JsonProperty("minPinNameLength")] public int MinPinNameLength;

            [JsonProperty("maxPinNameLength")] public int MaxPinNameLength;

            [JsonProperty("pinCost")] public int PinCost;

            [JsonProperty("commandCooldownSeconds")]
            public int CommandCooldownSeconds;

            [JsonProperty("imageUrl")] public string ImageUrl;

            [JsonProperty("imageSize")] public int ImageSize;

            [JsonProperty("serverLogoUrl")] public string ServerLogoUrl;

            public static MapOptions Default = new MapOptions
            {
                MapGridYOffset = 0,
                PinsEnabled = true,
                MinPinNameLength = 2,
                MaxPinNameLength = 20,
                PinCost = 100,
                CommandCooldownSeconds = 10,
                ImageUrl = "",
                ImageSize = 1440,
                ServerLogoUrl = ""
            };
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;

    public partial class Imperium : RustPlugin
    {
        private class ImperiumOptions
        {
            [JsonProperty("badlands")] public BadlandsOptions Badlands = new BadlandsOptions();

            [JsonProperty("claims")] public ClaimOptions Claims = new ClaimOptions();

            [JsonProperty("decay")] public DecayOptions Decay = new DecayOptions();

            [JsonProperty("factions")] public FactionOptions Factions = new FactionOptions();

            [JsonProperty("hud")] public HudOptions Hud = new HudOptions();

            [JsonProperty("map")] public MapOptions Map = new MapOptions();

            [JsonProperty("pvp")] public PvpOptions Pvp = new PvpOptions();

            [JsonProperty("raiding")] public RaidingOptions Raiding = new RaidingOptions();

            [JsonProperty("taxes")] public TaxOptions Taxes = new TaxOptions();

            [JsonProperty("upkeep")] public UpkeepOptions Upkeep = new UpkeepOptions();

            [JsonProperty("war")] public WarOptions War = new WarOptions();

            [JsonProperty("zones")] public ZoneOptions Zones = new ZoneOptions();

            [JsonProperty("recruiting")] public RecruitingOptions Recruiting = new RecruitingOptions();

            [JsonProperty("upgrading")] public UpgradingOptions Upgrading = new UpgradingOptions();

            public static ImperiumOptions Default = new ImperiumOptions
            {
                Badlands = BadlandsOptions.Default,
                Claims = ClaimOptions.Default,
                Decay = DecayOptions.Default,
                Factions = FactionOptions.Default,
                Hud = HudOptions.Default,
                Map = MapOptions.Default,
                Pvp = PvpOptions.Default,
                Raiding = RaidingOptions.Default,
                Taxes = TaxOptions.Default,
                Upkeep = UpkeepOptions.Default,
                War = WarOptions.Default,
                Zones = ZoneOptions.Default,
                Recruiting = RecruitingOptions.Default,
                Upgrading = UpgradingOptions.Default
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading default configuration.");
            Config.WriteObject(ImperiumOptions.Default, true);
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;

    public partial class Imperium : RustPlugin
    {
        private class PvpOptions
        {
            [JsonProperty("restrictPvp")] public bool RestrictPvp;

            [JsonProperty("allowedInBadlands")] public bool AllowedInBadlands;

            [JsonProperty("allowedInClaimedLand")] public bool AllowedInClaimedLand;

            [JsonProperty("allowedInWilderness")] public bool AllowedInWilderness;

            [JsonProperty("allowedInEventZones")] public bool AllowedInEventZones;

            [JsonProperty("allowedInMonumentZones")]
            public bool AllowedInMonumentZones;

            [JsonProperty("allowedInRaidZones")] public bool AllowedInRaidZones;

            [JsonProperty("allowedInDeepWater")] public bool AllowedInDeepWater;

            [JsonProperty("allowedUnderground")] public bool AllowedUnderground;

            [JsonProperty("enablePvpCommand")] public bool EnablePvpCommand;


            [JsonProperty("commandCooldownSeconds")]
            public int CommandCooldownSeconds;

            public static PvpOptions Default = new PvpOptions
            {
                RestrictPvp = false,
                AllowedInBadlands = true,
                AllowedInClaimedLand = true,
                AllowedInEventZones = true,
                AllowedInMonumentZones = true,
                AllowedInRaidZones = true,
                AllowedInWilderness = true,
                AllowedInDeepWater = true,
                AllowedUnderground = true,
                EnablePvpCommand = false,
                CommandCooldownSeconds = 60
            };
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;

    public partial class Imperium : RustPlugin
    {
        private class RaidingOptions
        {
            [JsonProperty("restrictRaiding")] public bool RestrictRaiding;

            [JsonProperty("allowedInBadlands")] public bool AllowedInBadlands;

            [JsonProperty("allowedInClaimedLand")] public bool AllowedInClaimedLand;

            [JsonProperty("allowedInWilderness")] public bool AllowedInWilderness;

            public static RaidingOptions Default = new RaidingOptions
            {
                RestrictRaiding = false,
                AllowedInBadlands = true,
                AllowedInClaimedLand = true,
                AllowedInWilderness = true
            };
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;

    public partial class Imperium : RustPlugin
    {
        private class TaxOptions
        {
            [JsonProperty("enabled")] public bool Enabled;

            [JsonProperty("defaultTaxRate")] public float DefaultTaxRate;

            [JsonProperty("maxTaxRate")] public float MaxTaxRate;

            [JsonProperty("claimedLandGatherBonus")]
            public float ClaimedLandGatherBonus;

            [JsonProperty("badlandsGatherBonus")] public float BadlandsGatherBonus;

            public static TaxOptions Default = new TaxOptions
            {
                Enabled = true,
                DefaultTaxRate = 0.1f,
                MaxTaxRate = 0.2f,
                ClaimedLandGatherBonus = 0.1f,
                BadlandsGatherBonus = 0.1f
            };
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;

    public partial class Imperium : RustPlugin
    {
        private class RecruitingOptions
        {
            [JsonProperty("enabled [THIS IS NOT AVAILABLE YET]")] public bool Enabled;

            public static RecruitingOptions Default = new RecruitingOptions
            {
                Enabled = false
            };
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;

    public partial class Imperium : RustPlugin
    {
        private class HudOptions
        {
            [JsonProperty("showEventsHud")] public bool ShowEventsHUD;
            [JsonProperty("leftPanelXOffset")] public float LeftPanelXOffset = 0f;
            [JsonProperty("leftPanelYOffset")] public float LeftPanelYOffset = 0f;
            [JsonProperty("rightPanelXOffset")] public float RightPanelXOffset = 0f;
            [JsonProperty("rightPanelYOffset")] public float RightPanelYOffset = 0f;

            public static HudOptions Default = new HudOptions
            {
                ShowEventsHUD = true,
                LeftPanelXOffset = 0f,
                LeftPanelYOffset = 0f,
                RightPanelXOffset = 0f,
                RightPanelYOffset = 0f
            };
        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;
    using System.Collections.Generic;

    public partial class Imperium : RustPlugin
    {
        private class UpkeepOptions
        {
            [JsonProperty("enabled")] public bool Enabled;

            [JsonProperty("costs")] public List<int> Costs = new List<int>();

            [JsonProperty("checkIntervalMinutes")] public int CheckIntervalMinutes;

            [JsonProperty("collectionPeriodHours")]
            public int CollectionPeriodHours;

            [JsonProperty("gracePeriodHours")] public int GracePeriodHours;

            public static UpkeepOptions Default = new UpkeepOptions
            {
                Enabled = false,
                Costs = new List<int> { 10, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 },
                CheckIntervalMinutes = 15,
                CollectionPeriodHours = 24,
                GracePeriodHours = 12
            };

        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;
    using System.Collections.Generic;

    public partial class Imperium : RustPlugin
    {
        private class WarOptions
        {
            [JsonProperty("enabled")] public bool Enabled;

            [JsonProperty("noobFactionProtectionInSeconds")] public int NoobFactionProtectionInSeconds;

            [JsonProperty("declarationCost")] public int DeclarationCost;

            [JsonProperty("onlineDefendersRequired")] public int OnlineDefendersRequired;

            [JsonProperty("adminApprovalRequired")] public bool AdminApprovalRequired;

            [JsonProperty("defenderApprovalRequired")] public bool DefenderApprovalRequired;

            [JsonProperty("enableShopfrontPeace")] public bool EnableShopfrontPeace;

            [JsonProperty("priorAggressionRequired")] public bool PriorAggressionRequired;

            [JsonProperty("spamPreventionSeconds")] public int SpamPreventionSeconds;

            [JsonProperty("minCassusBelliLength")] public int MinCassusBelliLength;

            [JsonProperty("defensiveBonuses")] public List<float> DefensiveBonuses = new List<float>();

            public static WarOptions Default = new WarOptions
            {
                Enabled = true,
                NoobFactionProtectionInSeconds = 0,
                DeclarationCost = 0,
                OnlineDefendersRequired = 0,
                AdminApprovalRequired = false,
                DefenderApprovalRequired = false,
                PriorAggressionRequired = false,
                EnableShopfrontPeace = true,
                SpamPreventionSeconds = 0,
                MinCassusBelliLength = 50,
                DefensiveBonuses = new List<float> { 0, 0.5f, 1f }
            };


        }
    }
}

namespace Oxide.Plugins
{
    using Newtonsoft.Json;
    using System.Collections.Generic;

    public partial class Imperium : RustPlugin
    {
        private class ZoneOptions
        {
            [JsonProperty("enabled")] public bool Enabled;

            [JsonProperty("domeDarkness")] public int DomeDarkness;

            [JsonProperty("eventZoneRadius")] public float EventZoneRadius;

            [JsonProperty("eventZoneLifespanSeconds")]
            public float EventZoneLifespanSeconds;

            [JsonProperty("monumentZones")]
            public Dictionary<string, float> MonumentZones = new Dictionary<string, float>();

            public static ZoneOptions Default = new ZoneOptions
            {
                Enabled = true,
                DomeDarkness = 3,
                EventZoneRadius = 150f,
                EventZoneLifespanSeconds = 600f,
                MonumentZones = new Dictionary<string, float>
                {
                    {"airfield", 200},
                    {"sphere_tank", 120},
                    {"junkyard", 150},
                    {"launch_site", 300},
                    {"military_tunnel", 150},
                    {"powerplant", 175},
                    {"satellite_dish", 130},
                    {"trainyard", 180},
                    {"water_treatment_plant", 180 },
                    {"oilrig_1",200},
                    {"oilrig_2",200},
                    {"military_base",150},
                    {"research_base",150}
                }
            };
        }
    }
}
#endregion

#region > Game Event Watcher
namespace Oxide.Plugins
{
    using System.Collections.Generic;
    using UnityEngine;

    public partial class Imperium
    {
        private class GameEventWatcher : MonoBehaviour
        {
            private const float CheckIntervalSeconds = 5f;
            private HashSet<CargoPlane> CargoPlanes = new HashSet<CargoPlane>();
            private HashSet<BaseHelicopter> PatrolHelicopters = new HashSet<BaseHelicopter>();
            private HashSet<CH47Helicopter> ChinookHelicopters = new HashSet<CH47Helicopter>();
            private HashSet<HackableLockedCrate> LockedCrates = new HashSet<HackableLockedCrate>();
            private HashSet<CargoShip> CargoShips = new HashSet<CargoShip>();

            public bool IsCargoPlaneActive
            {
                get { return CargoPlanes.Count > 0; }
            }

            public bool IsHelicopterActive
            {
                get { return PatrolHelicopters.Count > 0; }
            }

            public bool IsChinookOrLockedCrateActive
            {
                get { return ChinookHelicopters.Count > 0 || LockedCrates.Count > 0; }
            }

            public bool IsCargoShipActive
            {
                get { return CargoShips.Count > 0; }
            }

            private void Awake()
            {
                foreach (CargoPlane plane in FindObjectsOfType<CargoPlane>())
                    BeginEvent(plane);

                foreach (BaseHelicopter heli in FindObjectsOfType<BaseHelicopter>())
                    BeginEvent(heli);

                foreach (CH47Helicopter chinook in FindObjectsOfType<CH47Helicopter>())
                    BeginEvent(chinook);

                foreach (HackableLockedCrate crate in FindObjectsOfType<HackableLockedCrate>())
                    BeginEvent(crate);

                foreach (CargoShip ship in FindObjectsOfType<CargoShip>())
                    BeginEvent(ship);

                InvokeRepeating("CheckEvents", CheckIntervalSeconds, CheckIntervalSeconds);
            }

            private void OnDestroy()
            {
                CancelInvoke();
            }

            public void BeginEvent(CargoPlane plane)
            {
                Instance.Puts($"Beginning cargoplane event, plane at @ {plane.transform.position}");
                CargoPlanes.Add(plane);
            }

            public void BeginEvent(BaseHelicopter heli)
            {
                Instance.Puts($"Beginning patrol helicopter event, heli at @ {heli.transform.position}");
                PatrolHelicopters.Add(heli);
            }

            public void BeginEvent(CH47Helicopter chinook)
            {
                Instance.Puts($"Beginning chinook event, heli at @ {chinook.transform.position}");
                ChinookHelicopters.Add(chinook);
            }

            public void BeginEvent(HackableLockedCrate crate)
            {
                Instance.Puts($"Beginning locked crate event, crate at @ {crate.transform.position}");
                LockedCrates.Add(crate);
            }

            public void BeginEvent(CargoShip ship)
            {
                Instance.Puts($"Beginning cargo ship event, ship at @ {ship.transform.position}");
                CargoShips.Add(ship);
            }

            private void CheckEvents()
            {
                var endedEvents = CargoPlanes.RemoveWhere(IsEntityGone)
                                  + PatrolHelicopters.RemoveWhere(IsEntityGone)
                                  + ChinookHelicopters.RemoveWhere(IsEntityGone)
                                  + LockedCrates.RemoveWhere(IsEntityGone)
                                  + CargoShips.RemoveWhere(IsEntityGone);

                if (endedEvents > 0)
                    Instance.Hud.RefreshForAllPlayers();
            }

            private bool IsEntityGone(BaseEntity entity)
            {
                return !entity.IsValid() || !entity.gameObject.activeInHierarchy;
            }
        }
    }
}
#endregion

#region > Hud
namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using Oxide.Game.Rust.Cui;

    public partial class Imperium
    {
        private class HudManager
        {
            private Dictionary<string, Image> Images;
            private bool UpdatePending;

            public GameEventWatcher GameEvents { get; private set; }

            private ImageDownloader ImageDownloader;
            private MapOverlayGenerator MapOverlayGenerator;

            public HudManager()
            {
                Images = new Dictionary<string, Image>();
                GameEvents = Instance.GO.AddComponent<GameEventWatcher>();
                ImageDownloader = Instance.GO.AddComponent<ImageDownloader>();
                MapOverlayGenerator = Instance.GO.AddComponent<MapOverlayGenerator>();
            }

            public void RefreshForAllPlayers()
            {
                if (UpdatePending)
                    return;

                Instance.NextTick(() =>
                {
                    foreach (User user in Instance.Users.GetAll())
                    {
                        user.Map.Refresh();
                        user.Hud.Refresh();
                    }

                    UpdatePending = false;
                });

                UpdatePending = true;
            }

            public Image RegisterImage(string url, byte[] imageData = null, bool overwrite = false)
            {
                Image image;

                if (Images.TryGetValue(url, out image) && !overwrite)
                    return image;
                else
                    image = new Image(url);

                Images[url] = image;

                if (imageData != null)
                    image.Save(imageData);
                else
                    ImageDownloader.Download(image);

                return image;
            }

            public void RefreshAllImages()
            {
                foreach (Image image in Images.Values.Where(image => !image.IsGenerated))
                {
                    image.Delete();
                    ImageDownloader.Download(image);
                }
            }

            public CuiRawImageComponent CreateImageComponent(string imageUrl)
            {
                Image image;

                if (String.IsNullOrEmpty(imageUrl))
                {
                    Instance.PrintError(
                        $"CuiRawImageComponent requested for an image with a null URL. Did you forget to set MapImageUrl in the configuration?");
                    return null;
                }

                if (!Images.TryGetValue(imageUrl, out image))
                {
                    Instance.PrintError(
                        $"CuiRawImageComponent requested for image with an unregistered URL {imageUrl}. This shouldn't happen.");
                    return null;
                }

                if (image.Id != null)
                    return new CuiRawImageComponent { Png = image.Id, Sprite = UI.TransparentTexture };
                else
                    return new CuiRawImageComponent { Url = image.Url, Sprite = UI.TransparentTexture };
            }

            public void GenerateMapOverlayImage()
            {
                MapOverlayGenerator.Generate();
            }

            public void Init()
            {
                UserPanel.InitializeUserPanelCommandDefs();
                RegisterImage(dataDirectory + "map-image.png");
                RegisterImage(dataDirectory + "server-logo.png");
                RegisterDefaultImages(typeof(UI.HudIcon));
                RegisterDefaultImages(typeof(UI.MapIcon));
            }

            public void Destroy()
            {
                UnityEngine.Object.DestroyImmediate(ImageDownloader);
                UnityEngine.Object.DestroyImmediate(MapOverlayGenerator);
                UnityEngine.Object.DestroyImmediate(GameEvents);

                foreach (Image image in Images.Values)
                    image.Delete();

                Images.Clear();
            }

            private void RegisterDefaultImages(Type type)
            {
                foreach (FieldInfo field in type.GetFields(BindingFlags.Public | BindingFlags.Static))
                {
                    RegisterImage((string)field.GetValue(null));
                }

            }
        }
    }
}

namespace Oxide.Plugins
{
    using System;

    public partial class Imperium
    {
        private class Image
        {
            public string Url { get; private set; }
            public string Id { get; private set; }

            public bool IsDownloaded
            {
                get { return Id != null; }
            }

            public bool IsGenerated
            {
                get { return Url != null && !Url.StartsWith("http", StringComparison.Ordinal); }
            }

            public Image(string url, string id = null)
            {
                Url = url;
                Id = id;
            }

            public string Save(byte[] data)
            {
                if (IsDownloaded) Delete();
                Id = FileStorage.server.Store(data, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID, 0)
                    .ToString();
                return Id;
            }

            public void Delete()
            {
                if (!IsDownloaded) return;
                FileStorage.server.Remove(Convert.ToUInt32(Id), FileStorage.Type.png,
                    CommunityEntity.ServerInstance.net.ID);
                Id = null;
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public partial class Imperium
    {
        private class ImageDownloader : MonoBehaviour
        {
            private Queue<Image> PendingImages = new Queue<Image>();

            public bool IsDownloading { get; private set; }

            public void Download(Image image)
            {
                PendingImages.Enqueue(image);
                if (!IsDownloading) DownloadNext();
            }

            private void DownloadNext()
            {
                if (PendingImages.Count == 0)
                {
                    IsDownloading = false;
                    return;
                }

                Image image = PendingImages.Dequeue();
                StartCoroutine(DownloadImage(image));

                IsDownloading = true;
            }

            private IEnumerator DownloadImage(Image image)
            {
                var www = new WWW(image.Url);
                yield return www;

                if (!String.IsNullOrEmpty(www.error))
                {
                    Instance.Puts($"Error while downloading image {image.Url}: {www.error}");
                }
                else if (www.bytes == null || www.bytes.Length == 0)
                {
                    Instance.Puts($"Error while downloading image {image.Url}: No data received");
                }
                else
                {
                    byte[] data = ImageConversion.EncodeToPNG(www.texture);
                    image.Save(data);
                    DestroyImmediate(www.texture);
                    Instance.Puts($"Stored {image.Url} as id {image.Id}");
                    DownloadNext();
                }
            }
        }
    }
}

namespace Oxide.Plugins
{
    using System;
    using System.Collections.Generic;

    public partial class Imperium
    {
        private class ImperiumMapMarker
        {
            public string IconUrl;
            public string Label;
            public float X;
            public float Z;

            public static ImperiumMapMarker ForUser(User user)
            {
                return new ImperiumMapMarker
                {
                    IconUrl = UI.MapIcon.Player,
                    X = TranslatePositionX(user.Player.transform.position.x),
                    Z = TranslatePositionZ(user.Player.transform.position.z)
                };
            }

            public static ImperiumMapMarker ForHeadquarters(Area area, Faction faction)
            {
                return new ImperiumMapMarker
                {
                    IconUrl = UI.MapIcon.Headquarters,
                    Label = Util.RemoveSpecialCharacters(faction.Id),
                    X = TranslatePositionX(area.ClaimCupboard.transform.position.x),
                    Z = TranslatePositionZ(area.ClaimCupboard.transform.position.z)
                };
            }

            public static ImperiumMapMarker ForMonument(MonumentInfo monument)
            {
                string iconUrl = GetIconForMonument(monument);
                return new ImperiumMapMarker
                {
                    IconUrl = iconUrl,
                    Label = (iconUrl == UI.MapIcon.Unknown) ? monument.displayPhrase.english : null,
                    X = TranslatePositionX(monument.transform.position.x),
                    Z = TranslatePositionZ(monument.transform.position.z)
                };
            }

            public static ImperiumMapMarker ForPin(Pin pin)
            {
                string iconUrl = GetIconForPin(pin);
                return new ImperiumMapMarker
                {
                    IconUrl = iconUrl,
                    Label = pin.Name,
                    X = TranslatePositionX(pin.Position.x),
                    Z = TranslatePositionZ(pin.Position.z)
                };
            }

            private static float TranslatePositionX(float pos)
            {
                var mapHeight = TerrainMeta.Size.x;
                return (pos + mapHeight / 2f) / mapHeight;
            }

            private static float TranslatePositionZ(float pos)
            {
                var mapWidth = TerrainMeta.Size.z;
                return (pos + mapWidth / 2f) / mapWidth;
            }

            private static string GetIconForMonument(MonumentInfo monument)
            {
                if (monument.Type == MonumentType.Cave) return UI.MapIcon.Cave;
                if (monument.name.Contains("airfield")) return UI.MapIcon.Airfield;
                if (monument.name.Contains("bandit_town")) return UI.MapIcon.BanditTown;
                if (monument.name.Contains("compound")) return UI.MapIcon.Compound;
                if (monument.name.Contains("sphere_tank")) return UI.MapIcon.Dome;
                if (monument.name.Contains("harbor")) return UI.MapIcon.Harbor;
                if (monument.name.Contains("gas_station")) return UI.MapIcon.GasStation;
                if (monument.name.Contains("junkyard")) return UI.MapIcon.Junkyard;
                if (monument.name.Contains("launch_site")) return UI.MapIcon.LaunchSite;
                if (monument.name.Contains("lighthouse")) return UI.MapIcon.Lighthouse;
                if (monument.name.Contains("military_tunnel")) return UI.MapIcon.MilitaryTunnel;
                if (monument.name.Contains("warehouse")) return UI.MapIcon.MiningOutpost;
                if (monument.name.Contains("powerplant")) return UI.MapIcon.PowerPlant;
                if (monument.name.Contains("quarry")) return UI.MapIcon.Quarry;
                if (monument.name.Contains("satellite_dish")) return UI.MapIcon.SatelliteDish;
                if (monument.name.Contains("radtown_small_3")) return UI.MapIcon.SewerBranch;
                if (monument.name.Contains("power_sub")) return UI.MapIcon.Substation;
                if (monument.name.Contains("supermarket")) return UI.MapIcon.Supermarket;
                if (monument.name.Contains("trainyard")) return UI.MapIcon.Trainyard;
                if (monument.name.Contains("water_treatment_plant")) return UI.MapIcon.WaterTreatmentPlant;
                return UI.MapIcon.Unknown;
            }
        }

        private static string GetIconForPin(Pin pin)
        {
            switch (pin.Type)
            {
                case PinType.Arena:
                    return UI.MapIcon.Arena;
                case PinType.Hotel:
                    return UI.MapIcon.Hotel;
                case PinType.Marina:
                    return UI.MapIcon.Marina;
                case PinType.Shop:
                    return UI.MapIcon.Shop;
                case PinType.Town:
                    return UI.MapIcon.Town;
                default:
                    return UI.MapIcon.Unknown;
            }
        }
    }
}

namespace Oxide.Plugins
{
    using Oxide.Game.Rust.Cui;
    using System;
    using System.Linq;
    using UnityEngine;
    using System.Globalization;
    public partial class Imperium
    {

        public static class UI
        {

            //public const string ImageBaseUrl = "";
            public const string MapOverlayImageUrl = "imperium://map-overlay.png";
            public const string TransparentTexture = "assets/content/textures/generic/fulltransparent.tga";

            public static class Element
            {
                public static string Hud = "Hud";
                public static string HudPanelLeft = "Imperium.HudPanel.Top";
                public static string HudPanelRight = "Imperium.HudPanel.Middle";
                public static string HudPanelWarning = "Imperium.HudPanel.Warning";
                public static string HudPanelText = "Imperium.HudPanel.Text";
                public static string HudPanelIcon = "Imperium.HudPanel.Icon";
                public static string Overlay = "Overlay";
                public static string MapDialog = "Imperium.MapDialog";
                public static string MapHeader = "Imperium.MapDialog.Header";
                public static string MapHeaderTitle = "Imperium.MapDialog.Header.Title";
                public static string MapHeaderCloseButton = "Imperium.MapDialog.Header.CloseButton";
                public static string MapContainer = "Imperium.MapDialog.MapContainer";
                public static string MapTerrainImage = "Imperium.MapDialog.MapTerrainImage";
                public static string MapLayers = "Imperium.MapDialog.MapLayers";
                public static string MapClaimsImage = "Imperium.MapDialog.MapLayers.ClaimsImage";
                public static string MapMarkerIcon = "Imperium.MapDialog.MapLayers.MarkerIcon";
                public static string MapMarkerLabel = "Imperium.MapDialog.MapLayers.MarkerLabel";
                public static string MapSidebar = "Imperium.MapDialog.Sidebar";
                public static string MapButton = "Imperium.MapDialog.Sidebar.Button";
                public static string MapServerLogoImage = "Imperium.MapDialog.Sidebar.ServerLogo";

                public static string PanelWindow = "Imperium.Panel.Window";
                public static string PanelDialog = "Imperium.Panel.Dialog";
                public static string PanelHeader = "Imperium.Panel.Header";
                public static string PanelHeaderTitle = "Imperium.Panel.Header.Title";
                public static string PanelSidebar = "Imperium.Panel.Sidebar";
                public static string PanelTab = "Imperium.Panel.Sidebar.Tab";
                public static string PanelLabel = "Imperium.Panel.Dialog.Label";
                public static string PanelCommandButton = "Imperium.Panel.Dialog.CommandButton";
                public static string PanelTextInput = "Imperium.Panel.Dialog.TextInput";
                public static string PanelConfirmButton = "Imperium.Panel.Dialog.ConfirmButton";
            }

            public static class HudIcon
            {
                public static string Badlands = dataDirectory + "icons/hud/badlands.png";
                public static string CargoPlaneIndicatorOn = dataDirectory + "icons/hud/cargoplane-on.png";
                public static string CargoPlaneIndicatorOff = dataDirectory + "icons/hud/cargoplane-off.png";
                public static string CargoShipIndicatorOn = dataDirectory + "icons/hud/cargo-ship-on.png";
                public static string CargoShipIndicatorOff = dataDirectory + "icons/hud/cargo-ship-off.png";
                public static string ChinookIndicatorOn = dataDirectory + "icons/hud/chinook-on.png";
                public static string ChinookIndicatorOff = dataDirectory + "icons/hud/chinook-off.png";
                public static string Claimed = dataDirectory + "icons/hud/claimed.png";
                public static string Clock = dataDirectory + "icons/hud/clock.png";
                public static string Debris = dataDirectory + "icons/hud/debris.png";
                public static string Defense = dataDirectory + "icons/hud/defense.png";
                public static string Harvest = dataDirectory + "icons/hud/harvest.png";
                public static string Headquarters = dataDirectory + "icons/hud/headquarters.png";
                public static string HelicopterIndicatorOn = dataDirectory + "icons/hud/helicopter-on.png";
                public static string HelicopterIndicatorOff = dataDirectory + "icons/hud/helicopter-off.png";
                public static string Monument = dataDirectory + "icons/hud/monument.png";
                public static string Players = dataDirectory + "icons/hud/players.png";
                public static string PvpMode = dataDirectory + "icons/hud/pvp.png";
                public static string Raid = dataDirectory + "icons/hud/raid.png";
                public static string Ruins = dataDirectory + "icons/hud/ruins.png";
                public static string Sleepers = dataDirectory + "icons/hud/sleepers.png";
                public static string SupplyDrop = dataDirectory + "icons/hud/supplydrop.png";
                public static string Taxes = dataDirectory + "icons/hud/taxes.png";
                public static string Warning = dataDirectory + "icons/hud/warning.png";
                public static string WarZone = dataDirectory + "icons/hud/warzone.png";
                public static string Wilderness = dataDirectory + "icons/hud/wilderness.png";
            }

            public static class MapIcon
            {
                public static string Airfield = dataDirectory + "icons/map/airfield.png";
                public static string Arena = dataDirectory + "icons/map/arena.png";
                public static string BanditTown = dataDirectory + "icons/map/bandit-town.png";
                public static string Cave = dataDirectory + "icons/map/cave.png";
                public static string Compound = dataDirectory + "icons/map/compound.png";
                public static string Dome = dataDirectory + "icons/map/dome.png";
                public static string GasStation = dataDirectory + "icons/map/gas-station.png";
                public static string Harbor = dataDirectory + "icons/map/harbor.png";
                public static string Headquarters = dataDirectory + "icons/map/headquarters.png";
                public static string Hotel = dataDirectory + "icons/map/hotel.png";
                public static string Junkyard = dataDirectory + "icons/map/junkyard.png";
                public static string LaunchSite = dataDirectory + "icons/map/launch-site.png";
                public static string Lighthouse = dataDirectory + "icons/map/lighthouse.png";
                public static string Marina = dataDirectory + "icons/map/marina.png";
                public static string MilitaryTunnel = dataDirectory + "icons/map/military-tunnel.png";
                public static string MiningOutpost = dataDirectory + "icons/map/mining-outpost.png";
                public static string Player = dataDirectory + "icons/map/player.png";
                public static string PowerPlant = dataDirectory + "icons/map/power-plant.png";
                public static string Quarry = dataDirectory + "icons/map/quarry.png";
                public static string SatelliteDish = dataDirectory + "icons/map/satellite-dish.png";
                public static string SewerBranch = dataDirectory + "icons/map/sewer-branch.png";
                public static string Shop = dataDirectory + "icons/map/shop.png";
                public static string Substation = dataDirectory + "icons/map/substation.png";
                public static string Supermarket = dataDirectory + "icons/map/supermarket.png";
                public static string Town = dataDirectory + "icons/map/town.png";
                public static string Trainyard = dataDirectory + "icons/map/trainyard.png";
                public static string Unknown = dataDirectory + "icons/map/unknown.png";
                public static string WaterTreatmentPlant = dataDirectory + "icons/map/water-treatment-plant.png";
            }

            public static class Colors
            {
                public static string Primary = "#CC412B";
                public static string Secondary = "#222222";
                public static string Highlight = "#2D2D2D";
                public static string Disabled = "#AAAAAA";
                public static string Success = "#708C41";
                public static string Info = "#206A9E";
            }


            public static CuiElementContainer Container(string panel, string color, UI4 dimensions, bool blur = true, string parent = "Overlay")
            {
                CuiElementContainer container = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = { Color = color, Material = blur ? "assets/content/ui/uibackgroundblur-ingamemenu.mat" : string.Empty },
                        RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                        CursorEnabled = true
                    },
                    new CuiElement().Parent = parent,
                    panel
                }
            };
                return container;
            }

            public static CuiElementContainer Popup(string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter, string parent = "Overlay")
            {
                CuiElementContainer container = UI.Container(panel, "0 0 0 0", dimensions);

                UI.Label(container, panel, text, size, UI4.Full, align);

                return container;
            }

            public static void Panel(CuiElementContainer container, string panel, string color, UI4 dimensions)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    FadeOut = 0.25f
                },
                panel);
            }

            public static void Label(CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    FadeOut = 0.25f
                },
                panel);
            }

            public static void Label(CuiElementContainer container, string panel, string color, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text, Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    FadeOut = 0.25f
                },
                panel);
            }

            public static void Button(CuiElementContainer container, string panel, string color, string text, int size, UI4 dimensions, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0f },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    Text = { Text = text, FontSize = size, Align = align },
                    FadeOut = 0.25f
                },
                panel);
            }

            public static void Input(CuiElementContainer container, string panel, string color, string text, int size, string command, UI4 dimensions, TextAnchor anchor = TextAnchor.MiddleLeft)
            {
                UI.Panel(container, panel, color, dimensions);
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                {
                    new CuiInputFieldComponent
                    {
                        Align = anchor,
                        CharsLimit = 300,
                        Command = command + text,
                        FontSize = size,
                        IsPassword = false,
                        Text = text,
                        NeedsKeyboard = true
                    },
                    new CuiRectTransformComponent {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                }
                });
            }

            public static void Image(CuiElementContainer container, string panel, string png, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                {
                    new CuiRawImageComponent {Png = png },
                    new CuiRectTransformComponent { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                }
                });
            }

            public static void Image(CuiElementContainer container, string panel, int itemId, ulong skinId, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                {
                    new CuiImageComponent { ItemId = itemId, SkinId = skinId },
                    new CuiRectTransformComponent { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                }
                });
            }

            public static void Toggle(CuiElementContainer container, string panel, string boxColor, int fontSize, UI4 dimensions, string command, bool isOn)
            {
                UI.Panel(container, panel, boxColor, dimensions);

                if (isOn)
                    UI.Label(container, panel, "✔", fontSize, dimensions);

                UI.Button(container, panel, "0 0 0 0", string.Empty, 0, dimensions, command);
            }

            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');

                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);

                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }

        }

        public class UI4
        {
            public float xMin, yMin, xMax, yMax;

            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }

            public string GetMin() => $"{xMin} {1 - yMax}";

            public string GetMax() => $"{xMax} {1 - yMin}";

            private static UI4 _full;

            public static UI4 Full
            {
                get
                {
                    if (_full == null)
                        _full = new UI4(0, 0, 1, 1);
                    return _full;
                }
            }
        }
    }

}

namespace Oxide.Plugins
{
    using Oxide.Game.Rust.Cui;
    using System;
    using System.Linq;
    using UnityEngine;

    public partial class Imperium
    {
        private class UserHud
        {
            private const float IconSize = 0.0775f;

            private static class PanelColor
            {
                //public const string BackgroundNormal = "1 0.95 0.875 0.075";
                public const string BackgroundNormal = "0 0 0 0.5";
                public const string BackgroundDanger = "0.77 0.25 0.17 0.75";
                public const string BackgroundSafe = "0.44 0.54 0.26 1";
                public const string TextNormal = "0.85 0.85 0.85 1";
                public const string TextDanger = "0.85 0.65 0.65 1";
                public const string TextSafe = "1 1 1 1";
            }

            public User User { get; }
            public bool IsDisabled { get; set; }

            public UserHud(User user)
            {
                User = user;
            }

            public void Show()
            {
                CuiHelper.AddUi(User.Player, Build());
            }

            public void Hide()
            {

                CuiHelper.DestroyUi(User.Player, UI.Element.HudPanelLeft);
                CuiHelper.DestroyUi(User.Player, UI.Element.HudPanelRight);
                CuiHelper.DestroyUi(User.Player, UI.Element.HudPanelWarning);
            }

            public void Toggle()
            {
                if (IsDisabled)
                {
                    IsDisabled = false;
                    Show();
                }
                else
                {
                    IsDisabled = true;
                    Hide();
                }
            }

            public void Refresh()
            {
                if (IsDisabled)
                    return;

                Hide();
                Show();
            }

            private CuiElementContainer Build()
            {

                var container = new CuiElementContainer();

                Area area = User.CurrentArea;
                float xOff = Instance.Options.Hud.LeftPanelXOffset;
                float yOff = Instance.Options.Hud.LeftPanelXOffset;
                UI4 ui4 = new UI4(0.006f + xOff, 0.011f + yOff, 0.241f + xOff, 0.044f + yOff);
                container.Add(new CuiPanel
                {
                    Image = { Color = GetLeftPanelBackgroundColor() },
                    RectTransform = { AnchorMin = ui4.GetMin(), AnchorMax = ui4.GetMax() }
                }, UI.Element.Hud, UI.Element.HudPanelLeft);

                xOff = Instance.Options.Hud.RightPanelXOffset;
                yOff = Instance.Options.Hud.RightPanelYOffset;
                ui4 = new UI4(0.759f + xOff, 0.011f + yOff, 0.994f + xOff, 0.044f + yOff);

                if (Instance.Options.Hud.ShowEventsHUD)
                {
                    container.Add(new CuiPanel
                    {
                        Image = { Color = PanelColor.BackgroundNormal },
                        RectTransform = { AnchorMin = ui4.GetMin(), AnchorMax = ui4.GetMax() }
                    }, UI.Element.Hud, UI.Element.HudPanelRight);
                }
                AddWidget(container, UI.Element.HudPanelLeft, GetLocationIcon(), GetLeftPanelTextColor(),
                    GetLocationDescription());

                if (area != null)
                {
                    if (area.Type == AreaType.Badlands)
                    {
                        string harvestBonus = String.Format("+{0}%", Instance.Options.Taxes.BadlandsGatherBonus * 100);
                        AddWidget(container, UI.Element.HudPanelLeft, UI.HudIcon.Harvest, GetLeftPanelTextColor(),
                            harvestBonus, 0.77f);
                    }
                    else if (area.IsWarZone)
                    {
                        string defensiveBonus = String.Format("+{0}%", area.GetDefensiveBonus() * 100);
                        AddWidget(container, UI.Element.HudPanelLeft, UI.HudIcon.Defense, GetLeftPanelTextColor(),
                            defensiveBonus, 0.77f);
                    }
                    else if (area.IsTaxableClaim)
                    {
                        string taxRate = String.Format("{0}%", area.GetTaxRate() * 100);
                        AddWidget(container, UI.Element.HudPanelLeft, UI.HudIcon.Taxes, GetLeftPanelTextColor(),
                            taxRate, 0.78f);
                    }
                }

                if (Instance.Options.Hud.ShowEventsHUD)
                {
                    string planeIcon = Instance.Hud.GameEvents.IsCargoPlaneActive
                    ? UI.HudIcon.CargoPlaneIndicatorOn
                    : UI.HudIcon.CargoPlaneIndicatorOff;
                    AddWidget(container, UI.Element.HudPanelRight, planeIcon);

                    string shipIcon = Instance.Hud.GameEvents.IsCargoShipActive
                        ? UI.HudIcon.CargoShipIndicatorOn
                        : UI.HudIcon.CargoShipIndicatorOff;
                    AddWidget(container, UI.Element.HudPanelRight, shipIcon, 0.1f);

                    string heliIcon = Instance.Hud.GameEvents.IsHelicopterActive
                        ? UI.HudIcon.HelicopterIndicatorOn
                        : UI.HudIcon.HelicopterIndicatorOff;
                    AddWidget(container, UI.Element.HudPanelRight, heliIcon, 0.2f);

                    string chinookIcon = Instance.Hud.GameEvents.IsChinookOrLockedCrateActive
                        ? UI.HudIcon.ChinookIndicatorOn
                        : UI.HudIcon.ChinookIndicatorOff;
                    AddWidget(container, UI.Element.HudPanelRight, chinookIcon, 0.3f);

                    string activePlayers = BasePlayer.activePlayerList.Count.ToString();
                    AddWidget(container, UI.Element.HudPanelRight, UI.HudIcon.Players, PanelColor.TextNormal, activePlayers,
                        0.43f);

                    string sleepingPlayers = BasePlayer.sleepingPlayerList.Count.ToString();
                    AddWidget(container, UI.Element.HudPanelRight, UI.HudIcon.Sleepers, PanelColor.TextNormal,
                        sleepingPlayers, 0.58f);

                    string currentTime = TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm");
                    AddWidget(container, UI.Element.HudPanelRight, UI.HudIcon.Clock, PanelColor.TextNormal, currentTime,
                        0.75f);
                }


                bool claimUpkeepPastDue = Instance.Options.Upkeep.Enabled && User.Faction != null &&
                                          User.Faction.IsUpkeepPastDue && Instance.Areas.GetAllClaimedByFaction(User.Faction.Id).Length > 0;
                if (User.IsInPvpMode || claimUpkeepPastDue)
                {
                    if (Instance.Options.Hud.ShowEventsHUD)
                    {
                        ui4.yMin += 0.045f;
                        ui4.yMax += 0.045f;
                    }
                    CuiPanel panel = new CuiPanel
                    {
                        Image = { Color = PanelColor.BackgroundDanger },
                        RectTransform = { AnchorMin = ui4.GetMin(), AnchorMax = ui4.GetMax() }
                    };

                    container.Add(panel, UI.Element.Hud, UI.Element.HudPanelWarning);

                    if (claimUpkeepPastDue)
                        AddWidget(container, UI.Element.HudPanelWarning, UI.HudIcon.Ruins, PanelColor.TextDanger,
                            "Claim upkeep past due! (" + User.Faction.GetUpkeepPerPeriod() + " scrap)");
                    else
                        AddWidget(container, UI.Element.HudPanelWarning, UI.HudIcon.PvpMode, PanelColor.TextDanger,
                            "PVP mode enabled");
                }

                return container;
            }

            private string GetRightPanelBackgroundColor()
            {
                if (User.IsInPvpMode)
                    return PanelColor.BackgroundDanger;
                else
                    return PanelColor.BackgroundNormal;
            }

            private string GetRightPanelTextColor()
            {
                if (User.IsInPvpMode)
                    return PanelColor.TextDanger;
                else
                    return PanelColor.TextNormal;
            }

            private string GetLocationIcon()
            {
                Zone zone = User.CurrentZones.FirstOrDefault();

                if (zone != null)
                {
                    switch (zone.Type)
                    {
                        case ZoneType.SupplyDrop:
                            return UI.HudIcon.SupplyDrop;
                        case ZoneType.Debris:
                            return UI.HudIcon.Debris;
                        case ZoneType.Monument:
                            return UI.HudIcon.Monument;
                        case ZoneType.Raid:
                            return UI.HudIcon.Raid;
                    }
                }

                Area area = User.CurrentArea;

                if (area == null)
                {
                    if (Instance.Options.Pvp.AllowedInDeepWater)
                        return UI.HudIcon.Monument;
                    else
                        return UI.HudIcon.Wilderness;
                }

                if (area.IsWarZone)
                    return UI.HudIcon.WarZone;

                switch (area.Type)
                {
                    case AreaType.Badlands:
                        return UI.HudIcon.Badlands;
                    case AreaType.Claimed:
                        return UI.HudIcon.Claimed;
                    case AreaType.Headquarters:
                        return UI.HudIcon.Headquarters;
                    default:
                        return UI.HudIcon.Wilderness;
                }
            }

            private string GetLocationDescription()
            {
                Area area = User.CurrentArea;
                Zone zone = User.CurrentZones.FirstOrDefault();

                if (zone != null)
                {
                    if (area == null)
                        return zone.Name;
                    else
                        return $"{area.Id}: {zone.Name}";
                }

                if (area == null)
                    return "The Great Unknown";

                switch (area.Type)
                {
                    case AreaType.Badlands:
                        return $"{area.Id}: Badlands";
                    case AreaType.Claimed:
                        if (!String.IsNullOrEmpty(area.Name))
                            return $"{area.Id}: {area.Name} ({area.FactionId})";
                        else
                            return $"{area.Id}: {area.FactionId} Territory";
                    case AreaType.Headquarters:
                        if (!String.IsNullOrEmpty(area.Name))
                            return $"{area.Id}: {area.Name} ({area.FactionId} HQ)";
                        else
                            return $"{area.Id}: {area.FactionId} Headquarters";
                    default:
                        return $"{area.Id}: Wilderness";
                }
            }

            private string GetLeftPanelBackgroundColor()
            {
                if(User == null)
                {
                    Instance.PrintWarning($"An UserHud is trying to update but has no User associated with it. This shouldn't happen");
                    return PanelColor.BackgroundNormal;
                }
                if (User.CurrentZones.Count > 0)
                    return PanelColor.BackgroundDanger;

                Area area = User.CurrentArea;

                if (area == null)
                {
                    if (Instance.Options.Pvp.AllowedInDeepWater)
                        return PanelColor.BackgroundDanger;
                    else
                        return PanelColor.BackgroundNormal;
                }

                if (area.IsWarZone || area.IsHostile)
                    return PanelColor.BackgroundDanger;

                switch (area.Type)
                {
                    case AreaType.Badlands:
                        return Instance.Options.Pvp.AllowedInBadlands
                            ? PanelColor.BackgroundDanger
                            : PanelColor.BackgroundNormal;
                    case AreaType.Claimed:
                    case AreaType.Headquarters:
                        return Instance.Options.Pvp.AllowedInClaimedLand
                            ? PanelColor.BackgroundDanger
                            : User.Faction != null && area.FactionId == User.Faction.Id
                            ? PanelColor.BackgroundSafe
                            : PanelColor.BackgroundNormal;
                    default:
                        return Instance.Options.Pvp.AllowedInWilderness
                            ? PanelColor.BackgroundDanger
                            : PanelColor.BackgroundNormal;
                }
            }

            private string GetLeftPanelTextColor()
            {
                if (User == null)
                {
                    Instance.PrintWarning($"An UserHud is trying to update but has no User associated with it. This shouldn't happen");
                    return PanelColor.TextNormal;
                }

                if (User.CurrentZones.Count > 0)
                    return PanelColor.TextDanger;

                Area area = User.CurrentArea;

                if (area == null)
                {
                    if (Instance.Options.Pvp.AllowedInDeepWater)
                        return PanelColor.TextDanger;
                    else
                        return PanelColor.TextNormal;
                }

                if (area.IsWarZone || area.Type == AreaType.Badlands)
                    return PanelColor.TextDanger;
                switch (area.Type)
                {
                    case AreaType.Badlands:
                        return Instance.Options.Pvp.AllowedInBadlands
                            ? PanelColor.TextDanger
                            : PanelColor.TextNormal;
                    case AreaType.Claimed:
                    case AreaType.Headquarters:
                        return Instance.Options.Pvp.AllowedInClaimedLand
                            ? PanelColor.TextDanger
                            : User.Faction != null && area.FactionId == User.Faction.Id
                            ? PanelColor.TextSafe
                            : PanelColor.TextNormal;
                    default:
                        return Instance.Options.Pvp.AllowedInWilderness
                            ? PanelColor.TextDanger
                            : PanelColor.TextNormal;
                }
            }

            private void AddWidget(CuiElementContainer container, string parent, string iconName, string textColor, string text,
                float left = 0f)
            {
                var guid = Guid.NewGuid().ToString();

                container.Add(new CuiElement
                {
                    Name = UI.Element.HudPanelIcon + guid,
                    Parent = parent,
                    Components =
                    {
                        Instance.Hud.CreateImageComponent(iconName),
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"{left} {IconSize}",
                            AnchorMax = $"{left + IconSize} {1 - IconSize}",
                            OffsetMin = "6 0",
                            OffsetMax = "6 0"
                        }
                    }
                });

                container.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = text,
                        Color = textColor,
                        FontSize = 13,
                        Align = TextAnchor.MiddleLeft,
                    },
                    RectTransform =
                    {
                        AnchorMin = $"{left + IconSize} 0",
                        AnchorMax = "1 1",
                        OffsetMin = "11 0",
                        OffsetMax = "11 0"
                    }
                }, parent, UI.Element.HudPanelText + guid);
            }

            private void AddWidget(CuiElementContainer container, string parent, string iconName, float left = 0f)
            {
                var guid = Guid.NewGuid().ToString();

                container.Add(new CuiElement
                {
                    Name = UI.Element.HudPanelIcon + guid,
                    Parent = parent,
                    Components =
                    {
                        Instance.Hud.CreateImageComponent(iconName),
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"{left} {IconSize}",
                            AnchorMax = $"{left + IconSize} {1 - IconSize}",
                            OffsetMin = "6 0",
                            OffsetMax = "6 0"
                        }
                    }
                });
            }
        }
    }
}

namespace Oxide.Plugins
{
    using Oxide.Game.Rust.Cui;
    using System.Collections.Generic;
    using System;
    using System.Linq;
    using UnityEngine;

    public partial class Imperium
    {
        private class UserPanel
        {
            public static List<UIChatCommandDef> UiCommands = new List<UIChatCommandDef>();
            public static void InitializeUserPanelCommandDefs()
            {
                UiCommands =
                new List<UIChatCommandDef>()
                {
                    //faction create
                    new UIChatCommandDef()
                    {
                        category = "faction",
                        displayName = "CREATE",
                        shortDescription = "Create a new faction with the given name (Max 8 name length)",
                        command = "faction create",
                        auth = UIChatCommandDef.FactionAuth.NotFactionMember,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Faction Name",
                                description = "The name of your new faction",
                                isSubstring = false,
                            }
                        }
                    },
                    //faction join
                    new UIChatCommandDef()
                    {
                        category = "faction",
                        displayName = "JOIN",
                        shortDescription = "Accept a faction invite, as long as you have been invited",
                        command = "faction join",
                        auth = UIChatCommandDef.FactionAuth.NotFactionMember,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Faction Name",
                                description = "The name of the faction you want to join",
                                isSubstring = false,
                            }
                        }
                    },
                    //faction show
                    new UIChatCommandDef()
                    {
                        category = "faction",
                        displayName = "INFO",
                        shortDescription = "Show information about your faction in the chat",
                        command = "faction",
                        auth = UIChatCommandDef.FactionAuth.Member,
                        authExclusive = false
                    },

                    //faction invite
                    new UIChatCommandDef()
                    {
                        category = "faction",
                        displayName = "INVITE MEMBER",
                        shortDescription = "Invite a player to your faction. \nThe player must then accept with FACTION JOIN",
                        command = "faction invite",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Player name",
                                description = "The player to invite to your faction",
                                isSubstring = true,
                            }
                        }
                    },
                    //faction promote
                    new UIChatCommandDef()
                    {
                        category = "faction",
                        displayName = "PROMOTE MEMBER",
                        shortDescription = "Promote a member to manager role",
                        command = "faction promote",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Player name",
                                description = "The player to promote to manager role",
                                isSubstring = true,
                            }
                        }
                    },
                    //faction demote
                    new UIChatCommandDef()
                    {
                        category = "faction",
                        displayName = "DEMOTE MEMBER",
                        shortDescription = "Demote a manager to member role",
                        command = "faction demote",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Player name",
                                description = "The player to demote to member role",
                                isSubstring = true,
                            }
                        }
                    },
                    //faction kick
                    new UIChatCommandDef()
                    {
                        category = "faction",
                        displayName = "KICK MEMBER",
                        shortDescription = "Kick a player from your faction",
                        command = "faction kick",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Player name",
                                description = "The player to kick from your faction",
                                isSubstring = true,
                            }
                        }
                    },

                    //faction badlands confirm
                    new UIChatCommandDef()
                    {
                        category = "faction",
                        displayName = "TOGGLE BADLANDS",
                        shortDescription = "Allows/Deny PVP in all of your faction's lands.",
                        command = "faction badlands confirm",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true
                    },
                    //faction leave
                    new UIChatCommandDef()
                    {
                        category = "faction",
                        displayName = "LEAVE",
                        shortDescription = "Leave your current faction",
                        command = "faction leave",
                        auth = UIChatCommandDef.FactionAuth.Member,
                        authExclusive = false
                    },

                    //faction disband forever
                    new UIChatCommandDef()
                    {
                        category = "faction",
                        displayName = "DISBAND",
                        shortDescription = "Disband your entire faction. \nThis action cannot be undone",
                        command = "faction disband forever",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true
                    },

                    //CLAIM
                    //claim add
                    new UIChatCommandDef()
                    {
                        category = "claim",
                        displayName = "CLAIM LAND",
                        shortDescription = "Starts claim interaction. \nHit a tool cupboard with a hammer to complete the interaction",
                        command = "claim add",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        closesUI = true
                    },
                    //claim remove
                    new UIChatCommandDef()
                    {
                        category = "claim",
                        displayName = "UNCLAIM LAND",
                        shortDescription = "Starts unclaim interaction. \nHit a tool cupboard with a hammer to complete the interaction",
                        command = "claim remove",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        closesUI = true
                    },
                    //claim hq
                    new UIChatCommandDef()
                    {
                        category = "claim",
                        displayName = "SET HEADQUARTERS",
                        shortDescription = "Starts set headquarters interaction. \nHit a tool cupboard with a hammer to complete the interaction",
                        command = "claim hq",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        closesUI = true
                    },
                    
                    //claim give
                    new UIChatCommandDef()
                    {
                        category = "claim",
                        displayName = "GIVE LAND",
                        shortDescription = "Gives the selected land to a target faction. \nHit a tool cupboard with a hammer to complete the interaction",
                        command = "claim give",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Faction Name",
                                description = "The faction to receive the land",
                                isSubstring = false,
                            }
                        },
                        closesUI = true
                    },
                    //claim rename
                    new UIChatCommandDef()
                    {
                        category = "claim",
                        displayName = "RENAME LAND",
                        shortDescription = "Rename the target land with the specified name",
                        command = "claim rename",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Land coordinates [XY]",
                                description = "The land to rename (Example usage: C6)",
                                isSubstring = false,
                            },
                            new UIChatCommandArg()
                            {
                                label = "Name",
                                description = "The new name for the land",
                                isSubstring = true,
                            },
                        }
                    },
                    //claim cost
                    new UIChatCommandDef()
                    {
                        category = "claim",
                        displayName = "CHECK CLAIM COST",
                        shortDescription = "Shows the scrap claim cost for a given land in the chat",
                        command = "claim cost",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Land coordinates [XY]",
                                description = "The land to check the claim cost (Example usage: C6)",
                                isSubstring = false,
                            }
                        }
                    },
                    //claim list
                    new UIChatCommandDef()
                    {
                        category = "claim",
                        displayName = "CLAIM LIST",
                        shortDescription = "Shows a list of areas claimed by a faction",
                        command = "claim list",
                        auth = UIChatCommandDef.FactionAuth.Member,
                        authExclusive = false,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Faction Name",
                                description = "Target faction to check for claimed areas",
                                isSubstring = false,
                            }
                        }
                    },
                    //claim upkeep
                    new UIChatCommandDef()
                    {
                        category = "claim",
                        displayName = "CHECK LAND UPKEEP",
                        shortDescription = "Show current land upkeep status",
                        command = "claim upkeep",
                        auth = UIChatCommandDef.FactionAuth.Member,
                        authExclusive = false
                    },

                    //claim assign
                    new UIChatCommandDef()
                    {
                        category = "claim",
                        displayName = "CLAIM ASSIGN (ADMIN)",
                        shortDescription = "Assigns a land to a target faction. \nHit a tool cupboard with a hammer to complete the interaction",
                        command = "claim assign",
                        auth = UIChatCommandDef.FactionAuth.ServerAdmin,
                        authExclusive = true,
                        closesUI = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Faction Name",
                                description = "Target faction to assign the land to",
                                isSubstring = false,
                            }
                        }
                    },

                    //claim delete
                    new UIChatCommandDef()
                    {
                        category = "claim",
                        displayName = "CLAIM DELETE (ADMIN)",
                        shortDescription = "Deletes an existing land claim",
                        command = "claim delete",
                        auth = UIChatCommandDef.FactionAuth.ServerAdmin,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Land coordinates [XY]",
                                description = "The land to remove the current claim. (Example usage: C6)",
                                isSubstring = false,
                            }
                        }
                    },



                    //TAX
                    //tax chest
                    new UIChatCommandDef()
                    {
                        category = "tax",
                        displayName = "SELECT TAX CHEST",
                        shortDescription = "Select a tax chest for your faction. \nHit a chest with a hammer to complete the interaction",
                        command = "tax chest",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        closesUI = true
                    },

                    //tax rate XX
                    new UIChatCommandDef()
                    {
                        category = "tax",
                        displayName = "SET TAX PERCENTAGE",
                        shortDescription = "Select your faction's tax percentage. \nThis percentage will be taken from any resources gathered \nand automatically appear in your faction's Tax Chest",
                        command = "tax rate",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Tax Percentage [XX]",
                                description = "The farming percentage to charge in your land (Example usage: 10)",
                                isSubstring = false,
                            }
                        }
                    },

                    //WAR
                    //war status
                    new UIChatCommandDef()
                    {
                        category = "war",
                        displayName = "WAR STATUS",
                        shortDescription = "Shows in the chat all wars your faction is involved",
                        command = "war status",
                        auth = UIChatCommandDef.FactionAuth.Member,
                        authExclusive = false
                    },
                    //war declare
                    new UIChatCommandDef()
                    {
                        category = "war",
                        displayName = "DECLARE WAR",
                        shortDescription = "Declare war against an enemy faction \nwith a given reason.\nCost to declare war is " +
                            Instance.Options.War.DeclarationCost + " scrap",
                        command = "war declare",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Target Faction",
                                description = "The enemy faction's name to declare war against",
                                isSubstring = false,
                            },
                            new UIChatCommandArg()
                            {
                                label = "Reason",
                                description = "The reason behind the war declaration",
                                isSubstring = true,
                            }
                        }
                    },

                    //war end
                    new UIChatCommandDef()
                    {
                        category = "war",
                        displayName = "END WAR",
                        shortDescription = "Ask for peace or accept a peace offer from an enemy faction.\nFaction leaders can also end war by trading in a shopfront",
                        command = "war end",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Enemy Faction",
                                description = "The enemy faction's name to end war",
                                isSubstring = false,
                            }
                        }
                    },

                    //war pending
                    new UIChatCommandDef()
                    {
                        category = "war",
                        displayName = "LIST PENDING WAR REQUESTS",
                        shortDescription = "Check for pending war requests against your faction that can be approved or denied",
                        command = "war pending",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true
                    },

                    //war approve
                    new UIChatCommandDef()
                    {
                        category = "war",
                        displayName = "APPROVE PENDING WAR REQUEST",
                        shortDescription = "Approve a war request from an enemy faction. \nThis will officialy start war between your factions",
                        command = "war approve",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Enemy Faction",
                                description = "The enemy faction's name to approve a pending war request",
                                isSubstring = false,
                            }
                        }
                    },

                    //war deny
                    new UIChatCommandDef()
                    {
                        category = "war",
                        displayName = "DENY PENDING WAR REQUEST",
                        shortDescription = "Deny pending war request against your faction. \nThis will cancel the war request",
                        command = "war deny",
                        auth = UIChatCommandDef.FactionAuth.Leader,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Enemy Faction",
                                description = "The enemy faction's name to deny a pending war request",
                                isSubstring = false,
                            }
                        }
                    },

                    //war admin pending
                    new UIChatCommandDef()
                    {
                        category = "war",
                        displayName = "LIST PENDING WAR REQUESTS (ADMIN)",
                        shortDescription = "List all pending war requests waiting for admin approval",
                        command = "war admin pending",
                        auth = UIChatCommandDef.FactionAuth.ServerAdmin,
                        authExclusive = true
                    },

                    //war approve
                    new UIChatCommandDef()
                    {
                        category = "war",
                        displayName = "APPROVE PENDING WAR REQUEST (ADMIN)",
                        shortDescription = "Approve a war request waiting for admin approval. \nThis will officialy start the war between the two factions",
                        command = "war admin approve",
                        auth = UIChatCommandDef.FactionAuth.ServerAdmin,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Faction 1",
                                description = "The first faction involved in the war declaration",
                                isSubstring = false,
                            },
                            new UIChatCommandArg()
                            {
                                label = "Faction 2",
                                description = "The second faction involved in the war declaration",
                                isSubstring = false,
                            }
                        }
                    },

                    //war deny
                    new UIChatCommandDef()
                    {
                        category = "war",
                        displayName = "DENY PENDING WAR REQUEST (ADMIN)",
                        shortDescription = "Deny a war request waiting for admin approval. \nThis will cancel the war request from the attackers",
                        command = "war admin deny",
                        auth = UIChatCommandDef.FactionAuth.ServerAdmin,
                        authExclusive = true,
                        args =
                        {
                            new UIChatCommandArg()
                            {
                                label = "Faction 1",
                                description = "The first faction involved in the war declaration",
                                isSubstring = false,
                            },
                            new UIChatCommandArg()
                            {
                                label = "Faction 2",
                                description = "The second faction involved in the war declaration",
                                isSubstring = false,
                            }
                        }
                    }
                };

            }

            public User User { get; }
            public bool IsDisabled = true;
            public string currentCategory = "";
            public UIChatCommandDef selectedCommand;
            public string currentCommand = "";
            public Dictionary<int, string> indexedArgs = new Dictionary<int, string>();
            public int currentRequiredArgs = 0;

            public const float SPACING = 0.015f;


            public class UIChatCommandDef
            {
                public string displayName;
                public string shortDescription;
                public string category;
                public string command;
                public string uid;
                public List<UIChatCommandArg> args = new List<UIChatCommandArg>();
                public FactionAuth auth = FactionAuth.NotFactionMember;
                public bool authExclusive = true;
                public bool closesUI = false;

                public UIChatCommandDef()
                {
                    uid = Guid.NewGuid().ToString();
                }


                public enum FactionAuth
                {
                    NotFactionMember,
                    Member,
                    Manager,
                    Leader,
                    ServerAdmin
                }
            }

            public class UIChatCommandArg
            {
                public string label;
                public string description;
                public bool isSubstring = false;
            }

            public UserPanel(User user)
            {
                User = user;
            }

            public void ClearCurrentCommand()
            {
                selectedCommand = null;
                currentCommand = "";
                indexedArgs.Clear();
            }

            public void OpenTab(string category)
            {
                ClearCurrentCommand();
                currentCategory = category;
                Refresh();
            }

            public void OpenCommand(string uid)
            {
                ClearCurrentCommand();
                currentCategory = null;
                selectedCommand = UiCommands.Find(c => c.uid == uid);
                Refresh();
            }

            private List<CuiElementContainer> Build()
            {
                List<CuiElementContainer> result = new List<CuiElementContainer>();

                CuiElementContainer container = UI.Container(UI.Element.PanelWindow,
                    UI.Color(UI.Colors.Secondary, 0.8f),
                    new UI4(0.62f, 0.05f, 1f, 0.85f), true);

                CuiElementContainer header = CreatePanelHeader(container);
                CuiElementContainer sidebar = CreatePanelSidebar(container);
                CuiElementContainer dialog = UI.Container(UI.Element.PanelDialog,
                    UI.Color(UI.Colors.Highlight, 0f),
                    new UI4(0.05f, 0.15f, 0.75f, 0.95f),
                    false,
                    UI.Element.PanelWindow);
                if (selectedCommand != null)
                {
                    CreateSelectedCommandDialog(dialog);
                }
                else if (currentCategory != null && currentCategory != "")
                {
                    CreateSelectedCategoryButtons(dialog);
                }
                else
                {
                    CreateHomeDialog(dialog);
                }


                result = new List<CuiElementContainer>() { container, header, sidebar, dialog };

                return result;
            }

            private CuiElementContainer CreatePanelHeader(CuiElementContainer container)
            {
                CuiElementContainer header = UI.Container(UI.Element.PanelHeader,
                    UI.Color(UI.Colors.Primary, 1f),
                    new UI4(0f, 0f, 1f, 0.1f),
                    false,
                    UI.Element.PanelWindow
                );
                UI.Label(header, UI.Element.PanelHeader,
                    "IMPERIUM",
                    36,
                    UI4.Full
                );
                UI.Button(header, UI.Element.PanelHeader,
                    UI.Color(UI.Colors.Secondary, 1f),
                    "X",
                    12,
                    new UI4(0.93f, 0.3f, 0.97f, 0.7f),
                    "imperium.panel.close"
                );

                return header;
            }

            private CuiElementContainer CreatePanelSidebar(CuiElementContainer container)
            {
                List<string> categories = new List<string>() { "faction", "claim", "tax", "war" };
                CuiElementContainer sidebar = UI.Container(UI.Element.PanelSidebar,
                    UI.Color(UI.Colors.Primary, 1f),
                    new UI4(0.8f, 0.1f, 1f, 1f),
                    false,
                    UI.Element.PanelWindow
                );
                float sy = SPACING;
                for (int i = 0; i < categories.Count; i++)
                {
                    UI.Button(sidebar, UI.Element.PanelSidebar,
                        UI.Color(UI.Colors.Primary, 1f),
                        categories[i].ToUpper(),
                        20,
                        new UI4(0f, sy, 1f, sy + 0.1f),
                        "imperium.panel.opentab " + categories[i].ToString()
                    );
                    sy += 0.1f + SPACING;
                }
                return sidebar;
            }

            private void CreateSelectedCommandDialog(CuiElementContainer container)
            {
                if (selectedCommand == null)
                    return;
                float sy = SPACING;

                UI.Label(container, UI.Element.PanelDialog,
                    selectedCommand.displayName, 26,
                    new UI4(0f, sy, 1f, sy + 0.1f),
                    TextAnchor.MiddleLeft);
                sy += SPACING + 0.1f;

                UI.Label(container, UI.Element.PanelDialog,
                    selectedCommand.shortDescription, 12,
                    new UI4(0f, sy, 1f, sy + 0.1f),
                    TextAnchor.UpperLeft);
                sy += SPACING + 0.1f;

                if (selectedCommand.args.Count > 0)
                {
                    for (int i = 0; i < selectedCommand.args.Count; i++)
                    {
                        UIChatCommandArg arg = selectedCommand.args[i];
                        UI.Label(container, UI.Element.PanelDialog,
                            arg.label, 18,
                            new UI4(0f, sy, 1f, sy + 0.05f),
                            TextAnchor.MiddleLeft);
                        sy += SPACING + 0.05f;

                        UI.Label(container, UI.Element.PanelDialog,
                            arg.description, 12,
                            new UI4(0f, sy, 1f, sy + 0.05f),
                            TextAnchor.MiddleLeft);
                        sy += SPACING + 0.05f;

                        UI.Input(container, UI.Element.PanelDialog, UI.Color(UI.Colors.Info, 0.75f),
                            "", 16, "imperium.panel.setarg " + i + " " + arg.isSubstring.ToString().ToLower(),
                            new UI4(0f, sy, 1f, sy + 0.05f)
                            );
                        sy += SPACING + 0.05f;
                    }
                }

                UI.Button(container, UI.Element.PanelDialog,
                    UI.Color(UI.Colors.Success, 1f),
                    "CONFIRM",
                    16,
                    new UI4(0.7f, 0.9f, 1f, 1f),
                    "imperium.panel.run " + selectedCommand.closesUI.ToString().ToLower(),
                    TextAnchor.MiddleCenter
                    );
            }

            private void CreateSelectedCategoryButtons(CuiElementContainer container)
            {
                if (currentCategory == null || currentCategory == "")
                    return;
                float sy = SPACING;

                string title = currentCategory.ToUpper();

                if (currentCategory == "faction" && User.Faction != null)
                {
                    title = title + " [" + User.Faction.Id.ToUpper() + "]";
                }

                UI.Label(container, UI.Element.PanelDialog,
                    title, 26,
                    new UI4(0f, sy, 1f, 0.1f),
                    TextAnchor.MiddleLeft);
                sy += SPACING + 0.1f;

                List<UIChatCommandDef> categoryCmds = UiCommands.FindAll(c => c.category == currentCategory);

                if (categoryCmds.Count > 0)
                {
                    int buttonsAdded = 0;
                    for (int i = 0; i < categoryCmds.Count; i++)
                    {
                        UIChatCommandDef cmd = categoryCmds[i];
                        bool skip = false;
                        if (cmd.authExclusive)
                        {
                            if (cmd.auth == UIChatCommandDef.FactionAuth.NotFactionMember && User.Faction != null)
                                skip = true;
                            if (cmd.auth == UIChatCommandDef.FactionAuth.Leader && User.Faction == null)
                                skip = true;
                            if (cmd.auth == UIChatCommandDef.FactionAuth.Leader && User.Faction != null && !User.Faction.HasLeader(User))
                                skip = true;
                            if (cmd.auth == UIChatCommandDef.FactionAuth.ServerAdmin && (User.Player.Connection.authLevel == 0))
                                skip = true;
                        }
                        else
                        {
                            if (cmd.auth == UIChatCommandDef.FactionAuth.Leader && User.Faction != null && !User.Faction.HasLeader(User))
                                skip = true;
                            if (cmd.auth > UIChatCommandDef.FactionAuth.NotFactionMember && User.Faction == null)
                                skip = true;
                            if (cmd.auth == UIChatCommandDef.FactionAuth.ServerAdmin && (User.Player.Connection.authLevel == 0))
                                skip = true;
                        }
                        string color = UI.Color(UI.Colors.Info, 1f);
                        if (cmd.auth == UIChatCommandDef.FactionAuth.ServerAdmin)
                            color = UI.Color(UI.Colors.Primary, 1f);
                        if (!skip)
                        {
                            UI.Button(container, UI.Element.PanelDialog,
                                color,
                                cmd.displayName,
                                14,
                                new UI4(0f, sy, 1f, sy + 0.05f),
                                "imperium.panel.opencmd " + cmd.uid,
                                TextAnchor.MiddleCenter);
                            sy += SPACING + 0.05f;
                            buttonsAdded++;
                        }

                    }
                    if (buttonsAdded == 0)
                    {
                        UI.Label(container, UI.Element.PanelDialog,
                            UI.Color(UI.Colors.Disabled, 1f),
                            "No options available yet.\n\nTry creating or joining a faction first", 18,
                            new UI4(0f, sy, 1f, sy + 0.5f),
                            TextAnchor.MiddleCenter);
                        sy += SPACING + 0.1f;
                    }
                }
            }

            private void CreateHomeDialog(CuiElementContainer container)
            {
                float sy = SPACING;
                string description = "At its heart, Imperium adds the idea of territory to Rust. \n\nThe game is divided into a grid of tiles matching those displayed on the in-game map. \n\nPlayers can create factions, and these factions can claim these tiles of land and levy taxes on resources harvested therein. \n\nFactions can declare war on one another and battle for control of the territory.";
                string credits = "Original creator: ChuckleNugget\nImperium 2.0 developer: evict";
                UI.Label(container, UI.Element.PanelDialog,
                    UI.Color(UI.Colors.Disabled, 1f),
                    "IMPERIUM", 26,
                    new UI4(0f, sy, 1f, 0.1f),
                    TextAnchor.MiddleCenter);
                sy += SPACING + 0.12f;

                UI.Label(container, UI.Element.PanelDialog,
                    UI.Color(UI.Colors.Disabled, 1f),
                    description, 18,
                    new UI4(0f, sy, 1f, 0.9f),
                    TextAnchor.UpperCenter);

                UI.Label(container, UI.Element.PanelDialog,
                    UI.Color(UI.Colors.Success, 1f),
                    credits, 12,
                    new UI4(0f, 0.90f, 1f, 1f),
                    TextAnchor.LowerLeft);
            }

            public void Close()
            {
                ClearCurrentCommand();
                Hide();
            }

            public void SetCommand(string command)
            {
                ClearCurrentCommand();
                currentCommand = command;
            }

            public string GetFullConsoleCommand()
            {
                string s = "";
                s = s + "\"/";
                s = s + selectedCommand.command;
                if (indexedArgs.Count > 0)
                {
                    for (int i = 0; i < indexedArgs.Count; i++)
                    {
                        s = s + " ";
                        s = s + indexedArgs[i];
                    }
                }
                s = s + "\"";
                return s;
            }
            public void SetArg(int index, string arg, bool isSubstring = false)
            {
                if (!indexedArgs.ContainsKey(index))
                {
                    indexedArgs.Add(index, arg);
                }
                else
                {
                    indexedArgs[index] = arg;
                }
                if (isSubstring)
                {
                    indexedArgs[index] = "\\\"" + indexedArgs[index] + "\\\"";
                }
            }

            public void RemoveArg(int index)
            {
                if (indexedArgs.ContainsKey(index))
                {
                    indexedArgs.Remove(index);
                }
            }

            public bool HasArg(int index)
            {
                return indexedArgs.ContainsKey(index);
            }

            public void Show()
            {
                List<CuiElementContainer> containers = Build();
                foreach (CuiElementContainer container in containers)
                {
                    CuiHelper.AddUi(User.Player, container);
                }
                IsDisabled = false;
            }

            public void Hide()
            {
                CuiHelper.DestroyUi(User.Player, UI.Element.PanelWindow);
                CuiHelper.DestroyUi(User.Player, UI.Element.PanelHeader);
                CuiHelper.DestroyUi(User.Player, UI.Element.PanelSidebar);
                CuiHelper.DestroyUi(User.Player, UI.Element.PanelDialog);
                IsDisabled = true;

            }

            public void Toggle()
            {
                if (IsDisabled)
                {
                    IsDisabled = false;
                    Show();
                }
                else
                {
                    IsDisabled = true;
                    Hide();
                }
            }

            public void Refresh()
            {
                if (IsDisabled)
                    return;

                Hide();
                Show();
            }
        }
    }
}
#endregion

#region > UI Console Commands

#endregion

#region > User Map
namespace Oxide.Plugins
{
    using System;
    using Oxide.Game.Rust.Cui;
    using UnityEngine;
    using System.Linq;

    public partial class Imperium
    {
        private class UserMap
        {
            public User User { get; }
            public bool IsVisible { get; private set; }

            public UserMap(User user)
            {
                User = user;
            }

            public void Show()
            {
                CuiHelper.AddUi(User.Player, BuildDialog());
                CuiHelper.AddUi(User.Player, BuildSidebar());
                CuiHelper.AddUi(User.Player, BuildMapLayers());
                IsVisible = true;
            }

            public void Hide()
            {
                CuiHelper.DestroyUi(User.Player, UI.Element.MapDialog);
                IsVisible = false;
            }

            public void Toggle()
            {
                if (IsVisible)
                    Hide();
                else
                    Show();
            }

            public void Refresh()
            {
                if (IsVisible)
                {
                    CuiHelper.DestroyUi(User.Player, UI.Element.MapSidebar);
                    CuiHelper.DestroyUi(User.Player, UI.Element.MapLayers);
                    CuiHelper.AddUi(User.Player, BuildSidebar());
                    CuiHelper.AddUi(User.Player, BuildMapLayers());
                }
            }

            // --- Dialog ---

            private CuiElementContainer BuildDialog()
            {
                var container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    Image = { Color = "0 0 0 0.75" },
                    RectTransform = { AnchorMin = "0.164 0.014", AnchorMax = "0.836 0.986" },
                    CursorEnabled = true
                }, UI.Element.Overlay, UI.Element.MapDialog);

                container.Add(new CuiPanel
                {
                    Image = { Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0.012 0.014", AnchorMax = "0.774 0.951" }
                }, UI.Element.MapDialog, UI.Element.MapContainer);

                AddDialogHeader(container);
                AddMapTerrainImage(container);

                return container;
            }

            private void AddDialogHeader(CuiElementContainer container)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = "0 0 0 1" },
                    RectTransform = { AnchorMin = "0 0.966", AnchorMax = "0.999 0.999" }
                }, UI.Element.MapDialog, UI.Element.MapHeader);

                container.Add(new CuiLabel
                {
                    Text = { Text = ConVar.Server.hostname, FontSize = 13, Align = TextAnchor.MiddleLeft, FadeIn = 0 },
                    RectTransform = { AnchorMin = "0.012 0.025", AnchorMax = "0.099 0.917" }
                }, UI.Element.MapHeader, UI.Element.MapHeaderTitle);

                container.Add(new CuiButton
                {
                    Text = { Text = "X", FontSize = 13, Align = TextAnchor.MiddleCenter },
                    Button = { Color = "0 0 0 0", Command = "imperium.map.toggle", FadeIn = 0 },
                    RectTransform = { AnchorMin = "0.972 0.083", AnchorMax = "0.995 0.917" }
                }, UI.Element.MapHeader, UI.Element.MapHeaderCloseButton);
            }

            private void AddMapTerrainImage(CuiElementContainer container)
            {
                CuiRawImageComponent image = Instance.Hud.CreateImageComponent(dataDirectory + "map-image.png");

                // If the image hasn't been loaded, just display a black box so we don't cause an RPC AddUI crash.
                if (image == null)
                    image = new CuiRawImageComponent { Color = "0 0 0 1" };

                container.Add(new CuiElement
                {
                    Name = UI.Element.MapTerrainImage,
                    Parent = UI.Element.MapContainer,
                    Components =
                    {
                        image,
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                });
            }

            // --- Sidebar ---

            private CuiElementContainer BuildSidebar()
            {
                var container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    Image = { Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0.786 0.014", AnchorMax = "0.988 0.951" }
                }, UI.Element.MapDialog, UI.Element.MapSidebar);

                AddLayerToggleButtons(container);
                AddServerLogo(container);

                return container;
            }

            private void AddLayerToggleButtons(CuiElementContainer container)
            {
                container.Add(new CuiButton
                {
                    Text = { Text = "Land Claims", FontSize = 14, Align = TextAnchor.MiddleCenter },
                    Button =
                    {
                        Color = GetButtonColor(UserMapLayer.Claims), Command = "imperium.map.togglelayer claims",
                        FadeIn = 0
                    },
                    RectTransform = { AnchorMin = "0 0.924", AnchorMax = "1 1" }
                }, UI.Element.MapSidebar, UI.Element.MapButton + Guid.NewGuid().ToString());

                container.Add(new CuiButton
                {
                    Text = { Text = "Faction Headquarters", FontSize = 14, Align = TextAnchor.MiddleCenter },
                    Button =
                    {
                        Color = GetButtonColor(UserMapLayer.Headquarters),
                        Command = "imperium.map.togglelayer headquarters", FadeIn = 0
                    },
                    RectTransform = { AnchorMin = "0 0.832", AnchorMax = "1 0.909" }
                }, UI.Element.MapSidebar, UI.Element.MapButton + Guid.NewGuid().ToString());

                container.Add(new CuiButton
                {
                    Text = { Text = "Monuments", FontSize = 14, Align = TextAnchor.MiddleCenter },
                    Button =
                    {
                        Color = GetButtonColor(UserMapLayer.Monuments),
                        Command = "imperium.map.togglelayer monuments", FadeIn = 0
                    },
                    RectTransform = { AnchorMin = "0 0.741", AnchorMax = "1 0.817" }
                }, UI.Element.MapSidebar, UI.Element.MapButton + Guid.NewGuid().ToString());

                container.Add(new CuiButton
                {
                    Text = { Text = "Pins", FontSize = 14, Align = TextAnchor.MiddleCenter },
                    Button =
                    {
                        Color = GetButtonColor(UserMapLayer.Pins), Command = "imperium.map.togglelayer pins",
                        FadeIn = 0
                    },
                    RectTransform = { AnchorMin = "0 0.649", AnchorMax = "1 0.726" }
                }, UI.Element.MapSidebar, UI.Element.MapButton + Guid.NewGuid().ToString());
            }

            private void AddServerLogo(CuiElementContainer container)
            {
                CuiRawImageComponent image = Instance.Hud.CreateImageComponent(dataDirectory + "server-logo.png");

                // If the image hasn't been loaded, just display a black box so we don't cause an RPC AddUI crash.
                if (image == null)
                    image = new CuiRawImageComponent { Color = "0 0 0 1" };

                container.Add(new CuiElement
                {
                    Name = UI.Element.MapServerLogoImage,
                    Parent = UI.Element.MapSidebar,
                    Components =
                    {
                        image,
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 0.133"}
                    }
                });
            }

            // --- Map Layers ---

            private CuiElementContainer BuildMapLayers()
            {
                var container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    Image = { Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
                }, UI.Element.MapContainer, UI.Element.MapLayers);

                if (User.Preferences.IsMapLayerVisible(UserMapLayer.Claims))
                    AddClaimsLayer(container);

                if (User.Preferences.IsMapLayerVisible(UserMapLayer.Monuments))
                    AddMonumentsLayer(container);

                if (User.Preferences.IsMapLayerVisible(UserMapLayer.Headquarters))
                    AddHeadquartersLayer(container);

                if (User.Preferences.IsMapLayerVisible(UserMapLayer.Pins))
                    AddPinsLayer(container);

                AddMarker(container, ImperiumMapMarker.ForUser(User));

                return container;
            }

            private void AddClaimsLayer(CuiElementContainer container)
            {
                CuiRawImageComponent image = Instance.Hud.CreateImageComponent(UI.MapOverlayImageUrl);

                // If the claims overlay hasn't been generated yet, just display a black box so we don't cause an RPC AddUI crash.
                if (image == null)
                    image = new CuiRawImageComponent { Color = "0 0 0 1" };

                container.Add(new CuiElement
                {
                    Name = UI.Element.MapClaimsImage,
                    Parent = UI.Element.MapLayers,
                    Components =
                    {
                        image,
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                });
            }

            private void AddMonumentsLayer(CuiElementContainer container)
            {
                var monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>();
                foreach (MonumentInfo monument in monuments.Where(ShowMonumentOnMap))
                    AddMarker(container, ImperiumMapMarker.ForMonument(monument));
            }

            private void AddHeadquartersLayer(CuiElementContainer container)
            {
                foreach (Area area in Instance.Areas.GetAllByType(AreaType.Headquarters))
                {
                    var faction = Instance.Factions.Get(area.FactionId);
                    AddMarker(container, ImperiumMapMarker.ForHeadquarters(area, faction));
                }
            }

            private void AddPinsLayer(CuiElementContainer container)
            {
                foreach (Pin pin in Instance.Pins.GetAll())
                    AddMarker(container, ImperiumMapMarker.ForPin(pin));
            }

            private void AddMarker(CuiElementContainer container, ImperiumMapMarker marker, float iconSize = 0.01f)
            {
                container.Add(new CuiElement
                {
                    Name = UI.Element.MapMarkerIcon + Guid.NewGuid().ToString(),
                    Parent = UI.Element.MapLayers,
                    Components =
                    {
                        Instance.Hud.CreateImageComponent(marker.IconUrl),
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"{marker.X - iconSize} {marker.Z - iconSize}",
                            AnchorMax = $"{marker.X + iconSize} {marker.Z + iconSize}"
                        }
                    }
                });

                if (!String.IsNullOrEmpty(marker.Label))
                {
                    container.Add(new CuiLabel
                    {
                        Text = { Text = marker.Label, FontSize = 8, Align = TextAnchor.MiddleCenter, FadeIn = 0 },
                        RectTransform =
                        {
                            AnchorMin = $"{marker.X - 0.1} {marker.Z - iconSize - 0.0175}",
                            AnchorMax = $"{marker.X + 0.1} {marker.Z - iconSize}"
                        }
                    }, UI.Element.MapLayers, UI.Element.MapMarkerLabel + Guid.NewGuid().ToString());
                }
            }

            private bool ShowMonumentOnMap(MonumentInfo monument)
            {
                return monument.Type != MonumentType.Cave
                       && !monument.name.Contains("power_sub")
                       && !monument.name.Contains("water_well")
                       && !monument.name.Contains("swamp")
                       && !monument.name.Contains("ice_lake");
            }

            private string GetButtonColor(UserMapLayer layer)
            {
                if (User.Preferences.IsMapLayerVisible(layer))
                    return "0 0 0 1";
                else
                    return "0.33 0.33 0.33 1";
            }
        }
    }
}
#endregion

#region > DEPRECATED
namespace Oxide.Plugins
{
    using System.Collections.Generic;

    public partial class Imperium
    {
        private class LruCache<K, V>
        {
            private Dictionary<K, LinkedListNode<LruCacheItem>> Nodes;
            private LinkedList<LruCacheItem> RecencyList;

            public int Capacity { get; private set; }

            public LruCache(int capacity)
            {
                Capacity = capacity;
                Nodes = new Dictionary<K, LinkedListNode<LruCacheItem>>();
                RecencyList = new LinkedList<LruCacheItem>();
            }

            public bool TryGetValue(K key, out V value)
            {
                LinkedListNode<LruCacheItem> node;

                if (!Nodes.TryGetValue(key, out node))
                {
                    value = default(V);
                    return false;
                }

                LruCacheItem item = node.Value;
                RecencyList.Remove(node);
                RecencyList.AddLast(node);

                value = item.Value;
                return true;
            }

            public void Set(K key, V value)
            {
                LinkedListNode<LruCacheItem> node;

                if (Nodes.TryGetValue(key, out node))
                {
                    RecencyList.Remove(node);
                    node.Value.Value = value;
                }
                else
                {
                    if (Nodes.Count >= Capacity)
                        Evict();

                    var item = new LruCacheItem(key, value);
                    node = new LinkedListNode<LruCacheItem>(item);
                }

                RecencyList.AddLast(node);
                Nodes[key] = node;
            }

            public bool Remove(K key)
            {
                LinkedListNode<LruCacheItem> node;

                if (!Nodes.TryGetValue(key, out node))
                    return false;

                Nodes.Remove(key);
                RecencyList.Remove(node);

                return true;
            }

            public void Clear()
            {
                Nodes.Clear();
                RecencyList.Clear();
            }

            private void Evict()
            {
                LruCacheItem item = RecencyList.First.Value;
                RecencyList.RemoveFirst();
                Nodes.Remove(item.Key);
            }

            private class LruCacheItem
            {
                public K Key;
                public V Value;

                public LruCacheItem(K key, V value)
                {
                    Key = key;
                    Value = value;
                }
            }
        }
    }
}
#endregion

// --- End of file: Imperium.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/items-info ---
// --- Original File Path: I/ItemsInfo/ItemsInfo.cs ---

using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Items Info", "Iv Misticos", "1.0.3")]
    [Description("Get actual information about items.")]
    class ItemsInfo : RustPlugin
    {
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Incorrect Arguments", "Please, specify correct arguments." }
            }, this);
        }

        private void Init()
        {
            cmd.AddConsoleCommand("itemsinfo.all", this, CommandConsoleHandle);
            cmd.AddConsoleCommand("itemsinfo.find", this, CommandConsoleHandle);
        }

        private bool CommandConsoleHandle(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
                return false;
            
            arg.ReplyWith(GetItemsInfo(arg.Args, arg.cmd.FullName == "itemsinfo.find", arg.Player()?.UserIDString));
            return true;
        }

        private string GetItemsInfo(IReadOnlyList<string> parameters, bool search, string id)
        {
            if (parameters == null || (search && parameters.Count < 2) || parameters.Count < 1)
                return GetMsg("Incorrect Arguments", id);
            
            var reply = new StringBuilder();
            var items = ItemManager.itemList;
            var itemsCount = items.Count;

            var found = 0;
            for (var i = 0; i < itemsCount; i++)
            {
                var item = items[i];
                if (search && item.shortname.IndexOf(parameters[0], StringComparison.CurrentCultureIgnoreCase) == -1)
                    continue;

                for (var j = search ? 1 : 0; j < parameters.Count; j++)
                {
                    switch (parameters[j])
                    {
                        case "number":
                        {
                            reply.Append($"#{++found}\n");
                            break;
                        }
                        
                        case "shortname":
                        {
                            reply.Append($"Shortname: {item.shortname}\n");
                            break;
                        }

                        case "id":
                        {
                            reply.Append($"ID: {item.itemid}\n");
                            break;
                        }

                        case "name":
                        {
                            reply.Append($"Name: {item.displayName.english}\n");
                            break;
                        }

                        case "description":
                        {
                            reply.Append($"Description: {item.displayDescription.english}\n");
                            break;
                        }

                        case "condition":
                        {
                            reply.Append($"Max Condition: {item.condition.max}\n");
                            break;
                        }

                        case "repair":
                        {
                            reply.Append($"Is Repairable: {item.condition.repairable}\n");
                            break;
                        }
                    }
                }
            }

            return reply.ToString();
        }

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);
    }
}

// --- End of file: ItemsInfo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/info-panel ---
// --- Original File Path: I/InfoPanel/InfoPanel.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using UnityEngine;

/*
   ToDo: https://umod.org/community/info-panel/35582-feature-for-dangerous-treasure-event
        Add support for dangerous-treasure-event

*/

namespace Oxide.Plugins
{
    [Info("InfoPanel", "Gonzi", "1.0.9")]
    [Description("A little panel with useful information.")]
    public class InfoPanel : RustPlugin
    {
        #region DefaultConfigs

        private static string DefaultFontColor = "1 1 1 1";
        public bool IsReady;

        #endregion

        private Timer TestTimer;

        private Dictionary<string, Dictionary<string, IPanel>> PlayerPanels =
            new Dictionary<string, Dictionary<string, IPanel>>();

        private Dictionary<string, Dictionary<string, IPanel>> PlayerDockPanels =
            new Dictionary<string, Dictionary<string, IPanel>>();

        private Dictionary<string, List<string>> LoadedPluginPanels = new Dictionary<string, List<string>>();

        #region DefaultConfig

        private static PluginConfig Settings;

        private readonly List<string> TimeFormats = new List<string>
        {
            "H:mm",
            "HH:mm",
            "h:mm",
            "h:mm tt",
        };

        PluginConfig DefaultConfig()
        {
            var DefaultConfig = new PluginConfig
            {
                ThirdPartyPanels = new Dictionary<string, Dictionary<string, PanelConfig>>(),

                Messages = Messages,
                TimeFormats = TimeFormats,
                CoordType = 2,
                CompassDirections = new Dictionary<string, string>
                {
                    {"n", "North"},
                    {"ne", "Northeast"},
                    {"e", "East"},
                    {"se", "Southeast"},
                    {"s", "South"},
                    {"sw", "Southwest"},
                    {"w", "West"},
                    {"nw", "Northwest"},
                },
                Docks = new Dictionary<string, DockConfig>
                {
                    {
                        "BottomLeftDock", new DockConfig
                        {
                            Available = true,
                            Width = 0.18f,
                            Height = 0.03f,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0.005 0.165 0.005 0.005",
                            BackgroundColor = "0 0 0 0.4",
                        }
                    },
                    {
                        "BottomRightDock", new DockConfig
                        {
                            Available = true,
                            Width = 0.19f,
                            Height = 0.03f,
                            AnchorX = "Right",
                            AnchorY = "Bottom",
                            Margin = "0.005 0.005 0.005 0.165",
                            BackgroundColor = "0 0 0 0.4",
                        }
                    },
                    {
                        "TopLeftDock", new DockConfig
                        {
                            Available = true,
                            Width = 0.175f,
                            Height = 0.03f,
                            AnchorX = "Left",
                            AnchorY = "Top",
                            Margin = "0.005 0.005 0.005 0.005",
                            BackgroundColor = "0 0 0 0.4",
                        }
                    },
                    {
                        "TopRightDock", new DockConfig
                        {
                            Available = true,
                            Width = 0.29f,
                            Height = 0.03f,
                            AnchorX = "Right",
                            AnchorY = "Top",
                            Margin = "0.005 0.005 0.005 0.005",
                            BackgroundColor = "0 0 0 0.4",
                        }
                    }
                },

                Panels = new Dictionary<string, PanelConfig>
                {
                    {
                        "Clock", new PanelConfig
                        {
                            Available = true,
                            Permission = null,
                            Dock = "BottomLeftDock",
                            Order = 1,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.2f,
                            Height = 0.95f,
                            BackgroundColor = "0.1 0.1 0.1 0",
                            Text = new PanelTextConfig
                            {
                                Align = TextAnchor.MiddleCenter,
                                FontColor = DefaultFontColor,
                                FontSize = 14,
                                Margin = "0 0.01 0 0.01",
                            },
                            PanelSettings = new Dictionary<string, object>
                            {
                                {"ClockUpdateFrequency (seconds)", ClockUpdateFrequency},
                                {"TimeFormat", "HH:mm"}
                            }
                        }
                    },
                    {
                        "MessageBox", new PanelConfig
                        {
                            Available = true,
                            Permission = null,
                            Dock = "TopRightDock",
                            Order = 7,
                            AnchorX = "Right",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.005",
                            Width = 1f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.4",
                            Text = new PanelTextConfig
                            {
                                Align = TextAnchor.MiddleCenter,
                                FontColor = DefaultFontColor,
                                FontSize = 14,
                            },
                            PanelSettings = new Dictionary<string, object>
                            {
                                {"MessageUpdateFrequency (seconds)", MessageUpdateFrequency},
                                {"MsgOrder", "normal"}
                            }
                        }
                    },
                    {
                        "Balance", new PanelConfig
                        {
                            Available = true,
                            Permission = null,
                            Dock = "BottomLeftDock",
                            Order = 7,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.4f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.4",
                            Image = new PanelImageConfig
                            {
                                Order = 1,
                                Width = 0.2f,
                                Height = 0.8f,
                                Margin = "0 0.01 0.1 0.01",
                                Url = "https://i.imgur.com/XgJg7ZC.png",
                            },
                            Text = new PanelTextConfig
                            {
                                Order = 2,
                                Width = 0.848f,
                                Height = 1f,
                                Align = TextAnchor.MiddleCenter,
                                FontColor = DefaultFontColor,
                                FontSize = 12,
                                Margin = "0 0.02 0 0",
                            },
                            PanelSettings = new Dictionary<string, object>
                            {
                                {"RefreshRate(s)", "5"},
                            }
                        }
                    },
                    {
                        "Points", new PanelConfig
                        {
                            Available = true,
                            Permission = null,
                            Dock = "BottomLeftDock",
                            Order = 8,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.4f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.4",
                            Image = new PanelImageConfig
                            {
                                Order = 1,
                                Width = 0.2f,
                                Height = 0.8f,
                                Margin = "0 0.01 0.1 0.01",
                                Url = "https://i.imgur.com/cdOsBa8.png",
                            },
                            Text = new PanelTextConfig
                            {
                                Order = 2,
                                Width = 0.848f,
                                Height = 1f,
                                Align = TextAnchor.MiddleCenter,
                                FontColor = DefaultFontColor,
                                FontSize = 12,
                                Margin = "0 0.02 0 0",
                            },
                            PanelSettings = new Dictionary<string, object>
                            {
                                {"RefreshRate(s)", "5"},
                            }
                        }
                    },
                    { "Coordinates", new PanelConfig
                        {
                            Available = true,
                            Permission = null,
                            Dock = "TopLeftDock",
                            Order = 7,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.8f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.4",
                            Image = new PanelImageConfig
                            {
                                Order = 1,
                                Width = 0.13f,
                                Height = 0.8f,
                                Margin = "0 0.01 0.1 0.01",
                                Url = "https://i.imgur.com/nUlXLbO.png",
                            },
                            Text = new PanelTextConfig
                            {
                                Order = 2,
                                Width = 0.848f,
                                Height = 1f,
                                Align = TextAnchor.MiddleCenter,
                                FontColor = DefaultFontColor,
                                FontSize = 12,
                                Margin = "0 0.02 0 0",
                            },
                            PanelSettings = new Dictionary<string, object>
                            {
                                {"RefreshRate(s)", "3"},
                            }
                        }
                    },
                    {
                        "Compass", new PanelConfig
                        {
                            Available = false,
                            Permission = null,
                            Dock = "BottomRightDock",
                            Order = 8,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.5f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.4",
                            Image = new PanelImageConfig
                            {
                                Order = 1,
                                Width = 0.188f,
                                Height = 0.8f,
                                Margin = "0 0.01 0.1 0.03",
                                Url = "https://i.imgur.com/7brpZTi.png",
                            },
                            Text = new PanelTextConfig
                            {
                                Order = 2,
                                Width = 0.76f,
                                Height = 1f,
                                Align = TextAnchor.MiddleCenter,
                                FontColor = DefaultFontColor,
                                FontSize = 12,
                                Margin = "0 0.02 0 0",
                            },
                            PanelSettings = new Dictionary<string, object>
                            {
                                {"RefreshRate(s)", "1"},
                                {"TextOrAngle", "text"}
                            }
                        }
                    },
                    {
                        "OPlayers", new PanelConfig
                        {
                            Available = true,
                            Permission = null,
                            Dock = "TopLeftDock",
                            Order = 2,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.31f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.4",
                            Image = new PanelImageConfig
                            {
                                Order = 1,
                                Width = 0.35f,
                                Height = 0.8f,
                                Margin = "0 0.05 0.1 0.05",
                                Url = "https://i.imgur.com/ogL8T6p.png",
                            },
                            Text = new PanelTextConfig
                            {
                                Order = 2,
                                Width = 0.68f,
                                Height = 1f,
                                Align = TextAnchor.MiddleCenter,
                                FontColor = DefaultFontColor,
                                FontSize = 14,
                            }
                        }
                    },
                    {
                        "Sleepers", new PanelConfig
                        {
                            Available = true,
                            Permission = null,
                            Dock = "TopLeftDock",
                            Order = 3,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.225f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.4",
                            Image = new PanelImageConfig
                            {
                                Order = 1,
                                Width = 0.4f,
                                Height = 0.8f,
                                Margin = "0 0.05 0.1 0.05",
                                Url = "https://i.imgur.com/HZobcwc.png",
                            },
                            Text = new PanelTextConfig
                            {
                                Order = 2,
                                Width = 0.63f,
                                Height = 1f,
                                Align = TextAnchor.MiddleCenter,
                                FontColor = DefaultFontColor,
                                FontSize = 14,
                            }
                        }
                    },
                    {
                        "AirdropEvent", new PanelConfig
                        {
                            Available = true,
                            Permission = null,
                            Dock = "TopLeftDock",
                            Order = 4,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.1f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.4",
                            Image = new PanelImageConfig
                            {
                                Order = 1,
                                Width = 0.8f,
                                Height = 0.8f,
                                Margin = "0 0.1 0.1 0.1",
                                Url = "https://i.imgur.com/WUQNWgj.png",
                            },
                            PanelSettings = new Dictionary<string, object>
                            {
                                {"InactiveColor", "1 1 1 0.1"},
                                {"ActiveColor", "0 1 0 1"},
                            }
                        }
                    },
                    {
                        "HelicopterEvent", new PanelConfig
                        {
                            Available = true,
                            Permission = null,
                            Dock = "TopLeftDock",
                            Order = 5,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.1f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.5",
                            Image = new PanelImageConfig
                            {
                                Order = 1,
                                Width = 0.75f,
                                Height = 0.8f,
                                Margin = "0 0.15 0.1 0.1",
                                Url = "https://i.imgur.com/PJBCJAv.png",
                            },
                            PanelSettings = new Dictionary<string, object>
                            {
                                {"InactiveColor", "1 1 1 0.1"},
                                {"ActiveColor", "0.7 0.2 0.2 1"},
                            }
                        }
                    },
                    {
                        "ChinookEvent", new PanelConfig
                        {
                            Available = true,
                            Permission = null,
                            Dock = "TopLeftDock",
                            Order = 5,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.1f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.5",
                            Image = new PanelImageConfig
                            {
                                Order = 1,
                                Width = 0.75f,
                                Height = 0.8f,
                                Margin = "0 0.15 0.1 0.1",
                                Url = "https://i.imgur.com/6ES0vIG.png",
                            },
                            PanelSettings = new Dictionary<string, object>
                            {
                                {"InactiveColor", "1 1 1 0.1"},
                                {"ActiveColor", "0.7 0.2 0.2 1"},
                            }
                        }
                    },
                    {
                        "CargoShipEvent", new PanelConfig
                        {
                            Available = true,
                            Permission = null,
                            Dock = "TopLeftDock",
                            Order = 5,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.1f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.4",
                            Image = new PanelImageConfig
                            {
                                Order = 1,
                                Width = 0.75f,
                                Height = 0.8f,
                                Margin = "0 0.15 0.1 0.1",
                                Url = "https://i.imgur.com/twAPVF8.png",
                            },
                            PanelSettings = new Dictionary<string, object>
                            {
                                {"InactiveColor", "1 1 1 0.1"},
                                {"ActiveColor", "0 1 0 1"},
                            }
                        }
                    },

                    {
                        "Radiation", new PanelConfig
                        {
                            Available = false,
                            Permission = null,
                            Dock = "TopLeftDock",
                            Order = 6,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.1f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.4",
                            Image = new PanelImageConfig
                            {
                                Order = 1,
                                Width = 0.75f,
                                Height = 0.8f,
                                Margin = "0 0.15 0.1 0.1",
                                Url = "https://i.imgur.com/Z0ar6gu.png",
                            },
                            PanelSettings = new Dictionary<string, object>
                            {
                                {"InactiveColor", "1 1 1 0.1"},
                                {"ActiveColor", "1 1 0 1"},
                                {"RefreshRate(s)", "3"}
                            }
                        }
                    },
                    {
                        "BradleyEvent", new PanelConfig
                        {
                            Available = false,
                            Permission = null,
                            Dock = "TopLeftDock",
                            Order = 5,
                            AnchorX = "Left",
                            AnchorY = "Bottom",
                            Margin = "0 0 0 0.01",
                            Width = 0.1f,
                            Height = 0.95f,
                            BackgroundColor = "0 0 0 0.4",
                            Image = new PanelImageConfig
                            {
                                Order = 1,
                                Width = 0.75f,
                                Height = 0.8f,
                                Margin = "0 0.15 0.1 0.1",
                                Url = "https://i.imgur.com/61Gdczt.png",
                            },
                            PanelSettings = new Dictionary<string, object>
                            {
                                {"InactiveColor", "1 1 1 0.1"},
                                {"ActiveColor", "0.7 0.2 0.2 1"}
                            }
                        }
                    }
                }
            };

            return DefaultConfig;
        }

        class PluginConfig
        {
            //public Dictionary<string, string> Settings { get; set; }

            public Dictionary<string, DockConfig> Docks { get; set; }
            public Dictionary<string, PanelConfig> Panels { get; set; }
            public int CoordType { get; set; }

            public Dictionary<string, Dictionary<string, PanelConfig>> ThirdPartyPanels { get; set; }

            public List<string> Messages { get; set; }
            public List<string> TimeFormats { get; set; }
            public Dictionary<string, string> CompassDirections { get; set; }

            public T GetPanelSettingsValue<T>(string Panel, string Setting, T defaultValue)
            {
                PanelConfig panelConfig;
                if (!Panels.TryGetValue(Panel, out panelConfig))
                    return defaultValue;

                if (panelConfig.PanelSettings == null)
                    return defaultValue;

                object value;
                if (!panelConfig.PanelSettings.TryGetValue(Setting, out value))
                    return defaultValue;

                return (T)Convert.ChangeType(value, typeof(T));
            }

            public bool CheckPanelAvailability(string Panel)
            {
                PanelConfig panelConfig;
                if (!Panels.TryGetValue(Panel, out panelConfig))
                    return false;

                if (!panelConfig.Available)
                    return false;

                DockConfig dockConfig;
                return Docks.TryGetValue(panelConfig.Dock, out dockConfig) && dockConfig.Available;
            }
        }

        class DockConfig
        {
            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public bool Available { get; set; } = true;

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string AnchorX { get; set; } = "Left";

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string AnchorY { get; set; } = "Bottom";

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public float Width { get; set; } = 0.05f;

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public float Height { get; set; } = 0.95f;

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string BackgroundColor { get; set; } = "0 0 0 0.4";

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string Margin { get; set; } = "0 0 0 0.005";

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public PanelImageConfig Image { get; set; }
        }

        class BasePanelConfig
        {
            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public bool Available { get; set; } = true;

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string AnchorX { get; set; } = "Left";

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string AnchorY { get; set; } = "Bottom";

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public float Width { get; set; } = 0.05f;

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public float Height { get; set; } = 0.95f;

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public int Order { get; set; }

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string BackgroundColor { get; set; } = "0 0 0 0.4";

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string Margin { get; set; } = "0 0 0 0.005";
        }

        class PanelConfig : BasePanelConfig
        {
            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public bool Autoload { get; set; } = true;

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string Dock { get; set; } = "BottomLeftDock";

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public Dictionary<string, object> PanelSettings { get; set; }

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public PanelImageConfig Image { get; set; }

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public PanelTextConfig Text { get; set; }

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public float FadeOut { get; set; }

            public string Permission { get; set; }
        }

        class PanelTextConfig : BasePanelConfig
        {
            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public new float Width { get; set; } = 1f;

            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public TextAnchor Align { get; set; } = TextAnchor.MiddleCenter;

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string FontColor { get; set; } = "1 1 1 1";

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public int FontSize { get; set; } = 14;

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string Content { get; set; } = "No Content";

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public float FadeIn { get; set; }

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public float FadeOut { get; set; }
        }

        class PanelImageConfig : BasePanelConfig
        {
            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public new float Width { get; set; } = 1f;

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string Url { get; set; }

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public string Color { get; set; } = null;
        }

        protected void LoadConfigValues()
        {
            Settings = Config.ReadObject<PluginConfig>();

            var UnOrderPanels = Settings.Panels.Where(p => p.Value.Order == 0).ToDictionary(s => s.Key, s => s.Value);

            var all = Settings.Panels.ToDictionary(s => s.Key, s => s.Value);
            foreach (var pan in all)
            {
                if (Settings.Panels[pan.Key].Permission != null) permission.RegisterPermission("infopanel." + Settings.Panels[pan.Key].Permission, this);
            }

            if (UnOrderPanels.Count == 0)
                return;

            PrintWarning("Reordering Panels.");

            foreach (var PanelCfg in UnOrderPanels)
            {

                //int HighestSiblingOrder = Settings.Panels.Where(p => p.Value.Dock == Settings.Panels[PanelName].Dock && p.Value.AnchorX == Settings.Panels[PanelName].AnchorX).Max(m => m.Value.Order);
                Settings.Panels[PanelCfg.Key].Order = PanelReOrder(PanelCfg.Value.Dock, PanelCfg.Value.AnchorX);
            }

            Config.WriteObject(Settings, true);
            PrintWarning("Config Saved.");
        }

        int PanelReOrder(string DockName, string AnchorX)
        {
            var SiblingPanels = Settings.Panels.Where(p => p.Value.Dock == DockName && p.Value.AnchorX == AnchorX);

            var Max = 0;
            if (SiblingPanels.Any())
                Max = SiblingPanels.Max(m => m.Value.Order);

            foreach (var pPanelCfg in Settings.ThirdPartyPanels)
            {
                if (pPanelCfg.Value.Count == 0) continue;

                var SiblingPluginPAnels = pPanelCfg.Value.Where(p => p.Value.Dock == DockName && p.Value.AnchorX == AnchorX);

                if (SiblingPluginPAnels.Any())
                {
                    var PluginMax = pPanelCfg.Value.Where(p => p.Value.Dock == DockName && p.Value.AnchorX == AnchorX).Max(m => m.Value.Order);
                    if (PluginMax > Max)
                        Max = PluginMax;
                }
            }
            return Max + 1;
        }

        #endregion

        #region Hooks

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config.WriteObject(DefaultConfig(), true);
            PrintWarning("Default configuration file created.");
        }

        void Init()
        {
            LoadConfigValues();
            LoadData();
        }

        void OnServerInitialized()
        {
            Clock = new Watch
            (
                Settings.GetPanelSettingsValue("Clock", "ClockUpdateFrequency (seconds)", ClockUpdateFrequency),
                Settings.CheckPanelAvailability("Clock")
            );

            MessageBox = new Messenger
            (
                Settings.Messages,
                Settings.GetPanelSettingsValue("MessageBox", "MessageUpdateFrequency (seconds)", MessageUpdateFrequency),
                Settings.GetPanelSettingsValue("MessageBox", "MsgOrder", "normal")
            );

            Airplane = new AirplaneEvent();
            Helicopter = new HelicopterEvent();
            Cargoship = new CargoshipEvent();
            Chinook = new ChinookEvent();
            Bradley = new BradleyEvent();

            CompassObj = new Compass
            (
                Settings.GetPanelSettingsValue("Compass", "RefreshRate(s)", 1)
            );

            Rad = new Radiation
            (
                Settings.GetPanelSettingsValue("Radiation", "RefreshRate(s)", 3)
            );

            Poi = new Points
            (
                Settings.GetPanelSettingsValue("Points", "RefreshRate(s)", 3)
            );

            Bala = new Balance
            (
                Settings.GetPanelSettingsValue("Balance", "RefreshRate(s)", 3)
            );

            Coord = new Coordinates
            (
                Settings.GetPanelSettingsValue("Coordinates", "RefreshRate(s)", 3)
            );

            foreach (var player in BasePlayer.activePlayerList)
            {
                LoadPanels(player);
                InitializeGUI(player);
            }

            if (Settings.CheckPanelAvailability("Radiation"))
            {
                RadiationUpdater = timer.Repeat(Rad.RefreshRate, 0, () => Rad.Refresh(storedData, PlayerPanels));
            }

            if (Settings.CheckPanelAvailability("Points"))
            {
                PointsUpdater = timer.Repeat(Poi.RefreshRate, 0, () => Poi.Refresh(storedData, PlayerPanels));
            }

            if (Settings.CheckPanelAvailability("Balance"))
            {
                BalanceUpdater = timer.Repeat(Bala.RefreshRate, 0, () => Bala.Refresh(storedData, PlayerPanels));
            }

            if (Settings.CheckPanelAvailability("Coordinates"))
            {
                CoordUpdater = timer.Repeat(Coord.RefreshRate, 0, () => Coord.Refresh(storedData, PlayerPanels));
            }

            if (Settings.CheckPanelAvailability("MessageBox"))
            {
                MsgUpdater = timer.Repeat(MessageBox.RefreshRate, 0,
                    () => MessageBox.Refresh(storedData, PlayerPanels));
            }

            if (Settings.CheckPanelAvailability("Clock"))
            {
                TimeUpdater = timer.Repeat(Clock.RefresRate, 0, () => Clock.Refresh(storedData, PlayerPanels));
            }

            if (Settings.CheckPanelAvailability("Compass"))
            {
                CompassUpdater = timer.Repeat(CompassObj.RefreshRate, 0,
                    () => CompassObj.Refresh(storedData, PlayerPanels));
            }

            //TestTimer = timer.Repeat(5, 0, () => TestSH());

            ActivePlanes = UnityEngine.Object.FindObjectsOfType<CargoPlane>().ToList();

            if (ActivePlanes.Count > 0)
            {
                CheckAirplane();
            }
            else
            {
                Airplane.Refresh(storedData, PlayerPanels);
            }

            ActiveHelicopters = UnityEngine.Object.FindObjectsOfType<PatrolHelicopter>().ToList();

            if (ActiveHelicopters.Count > 0)
            {
                CheckHelicopter();
            }
            else
            {
                Helicopter.Refresh(storedData, PlayerPanels);
            }

            ActiveBradleys = UnityEngine.Object.FindObjectsOfType<BradleyAPC>().ToList();

            if (ActiveBradleys.Count > 0)
            {
                CheckBradley();
            }
            else
            {
                Bradley.Refresh(storedData, PlayerPanels);
            }

            ActiveChinooks = UnityEngine.Object.FindObjectsOfType<CH47Helicopter>().ToList();

            if (ActiveChinooks.Count > 0)
            {
                CheckChinook();
            }
            else
            {
                Chinook.Refresh(storedData, PlayerPanels);
            }

            ActiveCargoships = UnityEngine.Object.FindObjectsOfType<CargoShip>().ToList();

            if (ActiveCargoships.Count > 0)
            {
                CheckCargoship();
            }
            else
            {
                Cargoship.Refresh(storedData, PlayerPanels);
            }

            IsReady = true;
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerConnected(player));
                return;
            }

            if (PlayerPanels.ContainsKey(player.UserIDString))
            {
                PlayerPanels.Remove(player.UserIDString);
            }

            if (PlayerDockPanels.ContainsKey(player.UserIDString))
            {
                PlayerDockPanels.Remove(player.UserIDString);
            }

            timer.In(1, () => GUITimerInit(player));
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            PlayerPanels.Remove(player.UserIDString);
            PlayerDockPanels.Remove(player.UserIDString);

            timer.Once(2, RefreshOnlinePlayers);
            timer.Once(2, RefreshSleepers);
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            timer.Once(2, RefreshSleepers);
        }

        private void OnEntitySpawned(BaseEntity Entity)
        {
            if (!IsReady)
            {
                timer.In(10, () => OnEntitySpawned(Entity));
                return;
            }

            if (Entity == null) return;
            if (Entity is PatrolHelicopter && Settings.Panels["HelicopterEvent"].Available)
            {
                ActiveHelicopters.Add((PatrolHelicopter)Entity);

                if (HelicopterTimer == false)
                {
                    CheckHelicopter();
                }
            }

            if (Entity is CargoPlane && Settings.Panels["AirdropEvent"].Available)
            {
                ActivePlanes.Add((CargoPlane)Entity);

                if (AirplaneTimer == false)
                {
                    CheckAirplane();
                }
            }

            if (Entity is CargoShip && Settings.Panels["CargoShipEvent"].Available)
            {
                ActiveCargoships.Add((CargoShip)Entity);

                if (CargoshipTimer == false)
                {
                    CheckCargoship();
                }
            }

            if (Entity is CH47Helicopter && Settings.Panels["ChinookEvent"].Available)
            {
                ActiveChinooks.Add((CH47Helicopter)Entity);

                if (ChinookTimer == false)
                {
                    CheckChinook();
                }
            }

            if (Entity is BradleyAPC && Settings.CheckPanelAvailability("BradleyEvent") &&
                Settings.Panels["BradleyEvent"].Available)
            {
                ActiveBradleys.Add((BradleyAPC)Entity);

                if (BradleyTimer == false)
                {
                    CheckBradley();
                }
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                DestroyGUI(player);

            SaveData();

            PlayerPanels.Clear();
            PlayerDockPanels.Clear();

            Err.Clear();
            ErrD.Clear();
            ErrB.Clear();
            ErrA.Clear();

            storedData = null;
            Settings = null;
        }

        void OnPluginUnloaded(Plugin plugin)
        {
            if (!Settings.ThirdPartyPanels.ContainsKey(plugin.Title)) return;
            var PluginPanels = LoadedPluginPanels[plugin.Title];

            foreach (var PanelName in PluginPanels)
            {
                foreach (var pair in PlayerPanels)
                {
                    pair.Value[PanelName].DestroyPanel();
                    pair.Value[PanelName].Remover();
                }
            }

            LoadedPluginPanels.Remove(plugin.Title);
        }

        void OnServerSave()
        {
            SaveData();
        }

        void OnServerShutdown()
        {
            SaveData();
        }

        #endregion

        #region PanelLoad

        /// <summary>
        /// </summary>
        /// <param name="Player"></param>
        private void LoadPanels(BasePlayer Player)
        {
            foreach (var Docks in Settings.Docks)
            {
                if (!Settings.Docks[Docks.Key].Available)
                    continue;
                LoadDockPanel(Docks.Key, Player);
            }

            var playerDockPanel = PlayerDockPanels[Player.UserIDString];
            foreach (var grouppedByDock in Settings.Panels.GroupBy(g => g.Value.Dock).ToDictionary(gd => gd.Key,
                gd => gd.Select(p => p).ToDictionary(gk => gk.Key, gk => gk.Value)))
            {
                if (!Settings.Docks[grouppedByDock.Key].Available)
                    continue;

                foreach (var panelCfg in grouppedByDock.Value)
                {
                    if (!Settings.CheckPanelAvailability(panelCfg.Key))
                        continue;
                    if (panelCfg.Value.Permission == null ||
                        permission.UserHasPermission(Player.UserIDString, panelCfg.Value.Permission))
                        LoadPanel(playerDockPanel[grouppedByDock.Key], panelCfg.Key, panelCfg.Value);
                }
            }

            foreach (var loadedPluginPanel in LoadedPluginPanels)
            {
                foreach (var panelName in loadedPluginPanel.Value)
                {
                    Dictionary<string, PanelConfig> panelConfigs;
                    PanelConfig panelConfig;
                    if (!Settings.ThirdPartyPanels.TryGetValue(loadedPluginPanel.Key, out panelConfigs)
                        || !panelConfigs.TryGetValue(panelName, out panelConfig)
                        || !panelConfig.Available)
                        continue;

                    if (panelConfig.Permission == null ||
                        permission.UserHasPermission(Player.UserIDString, panelConfig.Permission))
                        LoadPanel(playerDockPanel[panelConfig.Dock], panelName, panelConfig);
                }
            }
        }

        private IPanel LoadDockPanel(string DockName, BasePlayer Player)
        {
            var dockConfig = Settings.Docks[DockName];
            var DockPanel = new IPanel(DockName, Player, PlayerPanels, PlayerDockPanels)
            {
                Width = dockConfig.Width,
                Height = dockConfig.Height,
                AnchorX = dockConfig.AnchorX,
                AnchorY = dockConfig.AnchorY,
                Margin = Vector4Parser(dockConfig.Margin),
                BackgroundColor = ColorEx.Parse(dockConfig.BackgroundColor),
                IsDock = true
            };

            //LoadedDocks.Add(DockName, DockPanel);

            Dictionary<string, IPanel> panels;
            if (!PlayerDockPanels.TryGetValue(Player.UserIDString, out panels))
                PlayerDockPanels.Add(Player.UserIDString, panels = new Dictionary<string, IPanel>());
            panels.Add(DockName, DockPanel);

            return DockPanel;
        }

        private void LoadPanel(IPanel Dock, string PanelName, PanelConfig PCfg)
        {
            var Panel = Dock.AddPanel(PanelName);
            Panel.Width = PCfg.Width;
            Panel.Height = PCfg.Height;
            Panel.AnchorX = PCfg.AnchorX;
            Panel.AnchorY = PCfg.AnchorY;
            Panel.Margin = Vector4Parser(PCfg.Margin);
            Panel.BackgroundColor = ColorEx.Parse(PCfg.BackgroundColor);
            Panel.Order = PCfg.Order;
            Panel.Autoload = PCfg.Autoload;
            Panel.IsPanel = true;
            Panel.DockName = Dock.Name;
            Panel.FadeOut = Dock.FadeOut;

            if (PCfg.Text != null)
            {
                var Text = Panel.AddText(PanelName + "Text");
                Text.Width = PCfg.Text.Width;
                Text.Height = PCfg.Text.Height;
                Text.Margin = Vector4Parser(PCfg.Text.Margin);
                Text.Content = PCfg.Text.Content;
                Text.FontColor = ColorEx.Parse(PCfg.Text.FontColor);
                Text.FontSize = PCfg.Text.FontSize;
                Text.Align = PCfg.Text.Align;
                Text.Order = PCfg.Text.Order;
                Text.FadeOut = PCfg.Text.FadeOut;
                Text.TextComponent.FadeIn = PCfg.Text.FadeIn;
            }

            if (PCfg.Image != null)
            {
                var Image = Panel.AddImage(PanelName + "Image");
                Image.Width = PCfg.Image.Width;
                Image.Height = PCfg.Image.Height;
                Image.Margin = Vector4Parser(PCfg.Image.Margin);
                Image.Url = PCfg.Image.Url;
                Image.Order = PCfg.Image.Order;
                if (PCfg.Image.Color != null)
                    Image.Color = ColorEx.Parse(PCfg.Image.Color);
            }
        }

        #endregion

        #region Clock

        private Watch Clock;
        private int ClockUpdateFrequency = 4;
        private Timer TimeUpdater;

        public class Watch
        {
            string ClockFormat = "HH:mm";
            public int RefresRate = 4;
            public bool Available = true;

            TOD_Sky Sky = TOD_Sky.Instance;

            public Watch(int RefreshRate, bool Available)
            {
                RefresRate = RefreshRate;
                this.Available = Available;
            }

            public string GetServerTime(string PlayerID, StoredData storedData)
            {
                return DateTime.Now.AddHours(storedData.GetPlayerPanelSettings(PlayerID, "Clock", "Offset", 0))
                    .ToString(storedData.GetPlayerPanelSettings(PlayerID, "Clock", "TimeFormat", ClockFormat),
                        CultureInfo.InvariantCulture);
            }

            public string GetSkyTime(string PlayerID, StoredData storedData)
            {
                return Sky.Cycle.DateTime.ToString(
                    storedData.GetPlayerPanelSettings(PlayerID, "Clock", "TimeFormat", ClockFormat),
                    CultureInfo.InvariantCulture);
            }

            public string ShowTime(string PlayerID, StoredData storedData)
            {
                if (storedData.GetPlayerPanelSettings(PlayerID, "Clock", "Type", "Game") == "Server")
                    return GetServerTime(PlayerID, storedData);

                return GetSkyTime(PlayerID, storedData);
            }

            public void Refresh(StoredData storedData, Dictionary<string, Dictionary<string, IPanel>> panels)
            {
                if (!Settings.CheckPanelAvailability("Clock"))
                    return;

                foreach (var panel in pane