ls)
                {
                    IPanel iPanel;
                    if (!panel.Value.TryGetValue("ClockText", out iPanel)) continue;
                    var showTime = ShowTime(panel.Key, storedData);
                    var panelText = (IPanelText)iPanel;
                    if (!showTime.Equals(panelText.Content))
                    {
                        panelText.Content = showTime;
                        panelText.Refresh();
                    }
                }
            }
        }

        #endregion

        #region MessageBox

        private Messenger MessageBox;
        private Timer MsgUpdater;
        private int MessageUpdateFrequency = 20;

        private List<string> Messages = new List<string>
            {"Welcome!", "Beware! You Are Not Alone!", "Leeeeeeeeeeeroy Jenkins"};

        private bool MessageBoxAvailable = true;


        public class Messenger
        {
            List<string> Messages;
            public int RefreshRate = 20;
            private int Counter = 0;
            private string MsgOrder = "normal";

            public Messenger(List<string> msgs, int RefreshRate, string MsgOrder)
            {
                Messages = msgs;
                this.RefreshRate = RefreshRate;
                this.MsgOrder = MsgOrder;

                if (MsgOrder == "random")
                {
                    Counter = Core.Random.Range(0, Messages.Count - 1);
                }
            }

            public string GetMessage()
            {
                return Messages[Counter];
            }

            private void RefreshCounter()
            {
                if (MsgOrder == "random")
                {
                    var OldCounter = Counter;
                    var NewCounter = Core.Random.Range(0, Messages.Count - 1);

                    if (OldCounter == NewCounter)
                    {
                        if (NewCounter + 1 <= Messages.Count - 1)
                        {
                            Counter = NewCounter + 1;
                            return;
                        }
                        else if (NewCounter - 1 >= 0)
                        {
                            Counter = NewCounter - 1;
                            return;
                        }
                    }

                    Counter = NewCounter;
                    return;
                }

                Counter++;
                if (Counter >= Messages.Count)
                    Counter = 0;
            }

            public void Refresh(StoredData storedData, Dictionary<string, Dictionary<string, IPanel>> panels)
            {
                if (!Settings.CheckPanelAvailability("MessageBox"))
                    return;

                foreach (var panel in panels)
                {
                    IPanel iPanel;
                    if (!panel.Value.TryGetValue("MessageBoxText", out iPanel)) continue;
                    var message = GetMessage();
                    var panelText = (IPanelText)iPanel;
                    if (!message.Equals(panelText.Content))
                    {
                        panelText.Content = message;
                        panelText.Refresh();
                    }
                }

                RefreshCounter();
            }
        }

        #endregion

        #region Events

        private Timer HeliAttack;
        private Timer RadiationUpdater;

        private AirplaneEvent Airplane;
        private List<CargoPlane> ActivePlanes;
        private bool AirplaneTimer = false;

        private HelicopterEvent Helicopter;
        private List<PatrolHelicopter> ActiveHelicopters;
        private bool HelicopterTimer = false;

        private CargoshipEvent Cargoship;
        private List<CargoShip> ActiveCargoships;
        private bool CargoshipTimer = false;

        private ChinookEvent Chinook;
        private List<CH47Helicopter> ActiveChinooks;
        private bool ChinookTimer = false;

        private Radiation Rad;

        private PatrolHelicopter ActiveHelicopter;
        private CH47Helicopter ActiveChinook;
        private CargoShip ActiveCargoship;

        private BradleyEvent Bradley;
        private List<BradleyAPC> ActiveBradleys;
        private bool BradleyTimer = false;

        public class AirplaneEvent
        {
            public bool isActive = false;
            public Color ImageColor;

            public AirplaneEvent()
            {
                ImageColor =
                    ColorEx.Parse(Settings.GetPanelSettingsValue("AirdropEvent", "InactiveColor", "1 1 1 0.1"));
            }

            public void SetActivity(bool active)
            {
                isActive = active;

                if (isActive)
                {
                    ImageColor =
                        ColorEx.Parse(Settings.GetPanelSettingsValue("AirdropEvent", "ActiveColor", "0 1 0 1"));
                    return;
                }

                ImageColor =
                    ColorEx.Parse(Settings.GetPanelSettingsValue("AirdropEvent", "InactiveColor", "1 1 1 0.1"));
                return;
            }

            public void Refresh(StoredData storedData, Dictionary<string, Dictionary<string, IPanel>> panels)
            {
                if (!Settings.CheckPanelAvailability("AirdropEvent"))
                    return;

                foreach (var panel in panels)
                {
                    IPanel iPanel;
                    if (!panel.Value.TryGetValue("AirdropEventImage", out iPanel)) continue;
                    var panelRawImage = (IPanelRawImage)iPanel;
                    if (panelRawImage.Color != ImageColor)
                    {
                        panelRawImage.Color = ImageColor;
                        panelRawImage.Refresh();
                    }
                }
            }
        }

        public class HelicopterEvent
        {
            public bool isActive = false;
            public Color ImageColor;

            public HelicopterEvent()
            {
                ImageColor =
                    ColorEx.Parse(Settings.GetPanelSettingsValue("HelicopterEvent", "InactiveColor", "1 1 1 0.1"));
            }

            public void SetActivity(bool active)
            {
                isActive = active;

                if (isActive)
                {
                    ImageColor =
                        ColorEx.Parse(Settings.GetPanelSettingsValue("HelicopterEvent", "ActiveColor", "1 0 0 1"));
                    return;
                }

                ImageColor =
                    ColorEx.Parse(Settings.GetPanelSettingsValue("HelicopterEvent", "InactiveColor", "1 1 1 0.1"));
            }

            public void Refresh(StoredData storedData, Dictionary<string, Dictionary<string, IPanel>> panels)
            {
                if (!Settings.CheckPanelAvailability("HelicopterEvent"))
                    return;

                foreach (var panel in panels)
                {
                    IPanel iPanel;
                    if (!panel.Value.TryGetValue("HelicopterEventImage", out iPanel)) continue;
                    var panelRawImage = (IPanelRawImage)iPanel;
                    if (panelRawImage.Color != ImageColor)
                    {
                        panelRawImage.Color = ImageColor;
                        panelRawImage.Refresh();
                    }
                }
            }
        }


        public class CargoshipEvent
        {
            public bool isActive = false;
            public Color ImageColor;

            public CargoshipEvent()
            {
                ImageColor =
                    ColorEx.Parse(Settings.GetPanelSettingsValue("CargoShipEvent", "InactiveColor", "1 1 1 0.1"));
            }

            public void SetActivity(bool active)
            {
                isActive = active;

                if (isActive)
                {
                    ImageColor =
                        ColorEx.Parse(Settings.GetPanelSettingsValue("CargoShipEvent", "ActiveColor", "1 0 0 1"));
                    return;
                }

                ImageColor =
                    ColorEx.Parse(Settings.GetPanelSettingsValue("CargoShipEvent", "InactiveColor", "1 1 1 0.1"));
            }

            public void Refresh(StoredData storedData, Dictionary<string, Dictionary<string, IPanel>> panels)
            {
                if (!Settings.CheckPanelAvailability("CargoShipEvent"))
                    return;

                foreach (var panel in panels)
                {
                    IPanel iPanel;
                    if (!panel.Value.TryGetValue("CargoShipEventImage", out iPanel)) continue;
                    var panelRawImage = (IPanelRawImage)iPanel;
                    if (panelRawImage.Color != ImageColor)
                    {
                        panelRawImage.Color = ImageColor;
                        panelRawImage.Refresh();
                    }
                }
            }
        }

        public class ChinookEvent
        {
            public bool isActive = false;
            public Color ImageColor;

            public ChinookEvent()
            {
                ImageColor =
                    ColorEx.Parse(Settings.GetPanelSettingsValue("ChinookEvent", "InactiveColor", "1 1 1 0.1"));
            }

            public void SetActivity(bool active)
            {
                isActive = active;

                if (isActive)
                {
                    ImageColor =
                        ColorEx.Parse(Settings.GetPanelSettingsValue("ChinookEvent", "ActiveColor", "1 0 0 1"));
                    return;
                }

                ImageColor =
                    ColorEx.Parse(Settings.GetPanelSettingsValue("ChinookEvent", "InactiveColor", "1 1 1 0.1"));
            }

            public void Refresh(StoredData storedData, Dictionary<string, Dictionary<string, IPanel>> panels)
            {
                if (!Settings.CheckPanelAvailability("ChinookEvent"))
                    return;

                foreach (var panel in panels)
                {
                    IPanel iPanel;
                    if (!panel.Value.TryGetValue("ChinookEventImage", out iPanel)) continue;
                    var panelRawImage = (IPanelRawImage)iPanel;
                    if (panelRawImage.Color != ImageColor)
                    {
                        panelRawImage.Color = ImageColor;
                        panelRawImage.Refresh();
                    }
                }
            }
        }

        public class Radiation
        {
            bool isActive = false;
            public Color ImageColor;
            public int RefreshRate = 3;

            public Radiation(int RefreshRate)
            {
                isActive = ConVar.Server.radiation;
                this.RefreshRate = RefreshRate;
                if (isActive)
                {
                    ImageColor = ColorEx.Parse(Settings.GetPanelSettingsValue("Radiation", "ActiveColor", "1 1 0 1"));
                }
                else
                {
                    ImageColor =
                        ColorEx.Parse(Settings.GetPanelSettingsValue("Radiation", "InactiveColor", "1 1 1 0.1"));
                }
            }

            public void SetActivity(bool active)
            {
                isActive = active;

                if (isActive)
                {
                    ImageColor = ColorEx.Parse(Settings.GetPanelSettingsValue("Radiation", "ActiveColor", "1 0 0 1"));
                    return;
                }

                ImageColor = ColorEx.Parse(Settings.GetPanelSettingsValue("Radiation", "InactiveColor", "1 1 1 0.1"));
            }

            public void Refresh(StoredData storedData, Dictionary<string, Dictionary<string, IPanel>> panels)
            {
                if (isActive == ConVar.Server.radiation)
                    return;

                SetActivity(ConVar.Server.radiation);

                if (!Settings.CheckPanelAvailability("Radiation"))
                    return;

                foreach (var panel in panels)
                {
                    IPanel iPanel;
                    if (!panel.Value.TryGetValue("RadiationImage", out iPanel)) continue;
                    var panelRawImage = (IPanelRawImage)iPanel;
                    if (panelRawImage.Color != ImageColor)
                    {
                        panelRawImage.Color = ImageColor;
                        panelRawImage.Refresh();
                    }
                }
            }
        }

        public class BradleyEvent
        {
            public bool isActive = false;
            public Color ImageColor;

            public BradleyEvent()
            {
                ImageColor =
                    ColorEx.Parse(Settings.GetPanelSettingsValue("BradleyEvent", "InactiveColor", "1 1 1 0.1"));
            }

            public void SetActivity(bool active)
            {
                isActive = active;

                if (isActive)
                {
                    ImageColor =
                        ColorEx.Parse(Settings.GetPanelSettingsValue("BradleyEvent", "ActiveColor", "0.7 0.2 0.2 1"));
                    return;
                }

                ImageColor =
                    ColorEx.Parse(Settings.GetPanelSettingsValue("BradleyEvent", "InactiveColor", "1 1 1 0.1"));
            }

            public void Refresh(StoredData storedData, Dictionary<string, Dictionary<string, IPanel>> panels)
            {
                if (!Settings.CheckPanelAvailability("BradleyEvent"))
                    return;

                foreach (var panel in panels)
                {
                    IPanel iPanel;
                    if (!panel.Value.TryGetValue("BradleyEventImage", out iPanel)) continue;
                    var panelRawImage = (IPanelRawImage)iPanel;
                    if (panelRawImage.Color != ImageColor)
                    {
                        panelRawImage.Color = ImageColor;
                        panelRawImage.Refresh();
                    }
                }
            }
        }

        public void CheckAirplane()
        {
            ActivePlanes.RemoveAll(p => !p.IsValid() || !p.gameObject.activeInHierarchy);
            if (ActivePlanes.Count > 0)
            {
                if (Airplane.isActive == false)
                {
                    Airplane.SetActivity(true);
                    Airplane.Refresh(storedData, PlayerPanels);
                }

                AirplaneTimer = true;
                timer.In(10, CheckAirplane);
                return;
            }

            Airplane.SetActivity(false);
            Airplane.Refresh(storedData, PlayerPanels);
            AirplaneTimer = false;
        }

        public void CheckHelicopter()
        {
            ActiveHelicopters.RemoveAll(p => !p.IsValid() || !p.gameObject.activeInHierarchy);

            if (ActiveHelicopters.Count > 0)
            {
                if (Helicopter.isActive == false)
                {
                    Helicopter.SetActivity(true);
                    Helicopter.Refresh(storedData, PlayerPanels);
                }

                HelicopterTimer = true;
                timer.In(5, CheckHelicopter);
                return;
            }

            Helicopter.SetActivity(false);
            Helicopter.Refresh(storedData, PlayerPanels);
            HelicopterTimer = false;
        }

        public void CheckCargoship()
        {
            ActiveCargoships.RemoveAll(p => !p.IsValid() || !p.gameObject.activeInHierarchy);

            if (ActiveCargoships.Count > 0)
            {
                if (Cargoship.isActive == false)
                {
                    Cargoship.SetActivity(true);
                    Cargoship.Refresh(storedData, PlayerPanels);
                }

                CargoshipTimer = true;
                timer.In(5, CheckCargoship);
                return;
            }

            Cargoship.SetActivity(false);
            Cargoship.Refresh(storedData, PlayerPanels);
            CargoshipTimer = false;
        }

        public void CheckBradley()
        {
            ActiveBradleys.RemoveAll(p => !p.IsValid() || !p.gameObject.activeInHierarchy);
            if (ActiveBradleys.Count > 0)
            {
                if (Bradley.isActive == false)
                {
                    Bradley.SetActivity(true);
                    Bradley.Refresh(storedData, PlayerPanels);
                }

                BradleyTimer = true;
                timer.In(5, CheckBradley);
                return;
            }

            Bradley.SetActivity(false);
            Bradley.Refresh(storedData, PlayerPanels);
            BradleyTimer = false;
        }

        public void CheckChinook()
        {
            ActiveChinooks.RemoveAll(p => !p.IsValid() || !p.gameObject.activeInHierarchy);

            if (ActiveChinooks.Count > 0)
            {
                if (Chinook.isActive == false)
                {
                    Chinook.SetActivity(true);
                    Chinook.Refresh(storedData, PlayerPanels);
                }

                ChinookTimer = true;
                timer.In(5, CheckChinook);
                return;
            }

            Chinook.SetActivity(false);
            Chinook.Refresh(storedData, PlayerPanels);
            ChinookTimer = false;
        }

        #endregion

        #region Balance

        private Balance Bala;
        private Timer BalanceUpdater;

        public class Balance
        {
            public int RefreshRate = 3;

            public Balance(int RefreshRate)
            {
                this.RefreshRate = RefreshRate;
            }

            public double GetBalance(string PlayerID)
            {
                var player = RustCore.FindPlayerByIdString(PlayerID);
                if (player == null) return 0.0;
                return (double)(Interface.Oxide.CallHook("Balance", player.UserIDString) ?? 0.0);
            }

            public void Refresh(StoredData storedData, Dictionary<string, Dictionary<string, IPanel>> panels)
            {
                if (!Settings.CheckPanelAvailability("Balance"))
                    return;

                foreach (var panel in panels)
                {
                    IPanel iPanel;
                    if (!panel.Value.TryGetValue("BalanceText", out iPanel)) continue;
                    var balance = $"{GetBalance(panel.Key):N}";
                    var panelText = (IPanelText)iPanel;
                    if (!balance.Equals(panelText.Content))
                    {
                        panelText.Content = balance;
                        panelText.Refresh();
                    }
                }
            }
        }

        #endregion

        #region Points

        private Points Poi;
        private Timer PointsUpdater;

        public class Points
        {
            public int RefreshRate = 3;

            public Points(int RefreshRate)
            {
                this.RefreshRate = RefreshRate;
            }

            public int GetPoints(string PlayerID)
            {
                var player = RustCore.FindPlayerByIdString(PlayerID);
                if (player == null) return 0;
                return (int)(Interface.Oxide.CallHook("CheckPoints", player.userID) ?? 0);
            }

            public void Refresh(StoredData storedData, Dictionary<string, Dictionary<string, IPanel>> panels)
            {
                if (!Settings.CheckPanelAvailability("Points"))
                    return;

                foreach (var panel in panels)
                {
                    IPanel iPanel;
                    if (!panel.Value.TryGetValue("PointsText", out iPanel)) continue;
                    var points = $"{GetPoints(panel.Key)}";
                    var panelText = (IPanelText)iPanel;
                    if (!points.Equals(panelText.Content))
                    {
                        panelText.Content = points;
                        panelText.Refresh();
                    }
                }
            }
        }

        #endregion

        #region Coordinates

        private Coordinates Coord;

        private Timer CoordUpdater;

        public class Coordinates
        {
            public int RefreshRate = 3;

            public Coordinates(int RefreshRate)
            {
                this.RefreshRate = RefreshRate;
            }

            public string GetCoord(string PlayerID)
            {
                var player = RustCore.FindPlayerByIdString(PlayerID);
                var type = Settings.CoordType;
                if (player == null) return string.Empty;
                switch (type)
                {
                    case 0:
                        return
                            $"X: {player.transform.position.x.ToString("0")} | Z: {player.transform.position.z.ToString("0")}";
                    case 1:
                        return FormatGridReference(player.ServerPosition);
                    case 2:
                        return
                            $"X: {player.transform.position.x.ToString("0")} | Z: {player.transform.position.z.ToString("0")} | {FormatGridReference(player.ServerPosition)}";
                    default:
                        return FormatGridReference(player.ServerPosition);
                }
            }

            public void Refresh(StoredData storedData, Dictionary<string, Dictionary<string, IPanel>> panels)
            {
                if (!Settings.CheckPanelAvailability("Coordinates"))
                    return;

                foreach (var panel in panels)
                {
                    IPanel iPanel;
                    if (!panel.Value.TryGetValue("CoordinatesText", out iPanel)) continue;
                    var coord = GetCoord(panel.Key);
                    var panelText = (IPanelText)iPanel;
                    if (!coord.Equals(panelText.Content))
                    {
                        panelText.Content = coord;
                        panelText.Refresh();
                    }
                }
            }
        }

        #endregion

        #region Compass

        private Compass CompassObj;

        private Timer CompassUpdater;

        public class Compass
        {
            public int RefreshRate = 3;

            public Compass(int RefreshRate)
            {
                this.RefreshRate = RefreshRate;
            }

            public string GetDirection(string PlayerID)
            {
                var player = RustCore.FindPlayerByIdString(PlayerID);

                if (player == null) return string.Empty;

                var PCurrent = player.eyes.rotation.eulerAngles;

                string str = $"{PCurrent.y.ToString("0")}\u00B0";

                if (Settings.GetPanelSettingsValue("Compass", "TextOrAngle", "text") == "text")
                {
                    if (PCurrent.y > 337.5 || PCurrent.y < 22.5)
                        str = Settings.CompassDirections["n"];
                    else if (PCurrent.y > 22.5 && PCurrent.y < 67.5)
                        str = Settings.CompassDirections["ne"];
                    else if (PCurrent.y > 67.5 && PCurrent.y < 112.5)
                        str = Settings.CompassDirections["e"];
                    else if (PCurrent.y > 112.5 && PCurrent.y < 157.5)
                        str = Settings.CompassDirections["se"];
                    else if (PCurrent.y > 157.5 && PCurrent.y < 202.5)
                        str = Settings.CompassDirections["s"];
                    else if (PCurrent.y > 202.5 && PCurrent.y < 247.5)
                        str = Settings.CompassDirections["sw"];
                    else if (PCurrent.y > 247.5 && PCurrent.y < 292.5)
                        str = Settings.CompassDirections["w"];
                    else if (PCurrent.y > 292.5 && PCurrent.y < 337.5)
                        str = Settings.CompassDirections["nw"];
                }

                return str;
            }

            public void Refresh(StoredData storedData, Dictionary<string, Dictionary<string, IPanel>> panels)
            {
                if (!Settings.CheckPanelAvailability("Compass"))
                {
                    return;
                }

                foreach (var panel in panels)
                {
                    if (panel.Value.ContainsKey("CompassText"))
                    {
                        var direction = GetDirection(panel.Key);
                        var panelText = (IPanelText)panel.Value["CompassText"];
                        if (!direction.Equals(panelText.Content))
                        {
                            panelText.Content = direction;
                            panelText.Refresh();
                        }
                    }
                }
            }
        }

        #endregion

        #region Commands

        [ChatCommand("ipanel")]
        private void IPanelCommand(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                var Str = "InfoPanel Available Commands:\n";
                Str += "<b><color=#ffa500ff>/ipanel</color></b> - Chat Command list \n";
                Str += "<b><color=#ffa500ff>/ipanel <hide|show></color></b>- To hide or show the panel. \n";
                Str += "<b><color=#ffa500ff>/ipanel clock game</color></b> - Change to game time. \n";
                Str +=
                    "<b><color=#ffa500ff>/ipanel clock server <offset></color></b> - Change to server time.\n Offset: Add hours to the clock. (-23 - 23) \n";
                Str += "<b><color=#ffa500ff>/ipanel timeformat</color></b> - To change time format. \n";

                PrintToChat(player, Str);

                return;
            }

            switch (args[0])
            {
                case "hide":
                    if (!storedData.GetPlayerSettings(player.UserIDString, "enable", true))
                    {
                        break;
                    }

                    ChangePlayerSettings(player, "enable", "false");
                    DestroyGUI(player);
                    break;
                case "show":
                    if (storedData.GetPlayerSettings(player.UserIDString, "enable", true))
                    {
                        break;
                    }

                    ChangePlayerSettings(player, "enable", "true");
                    RevealGUI(player);
                    break;

                case "clock":
                    if (args[1] == "server")
                    {
                        ChangePlayerPanelSettings(player, "Clock", "Type", "Server");

                        if (args.Length == 3)
                        {
                            var offset = 0;

                            if (int.TryParse(args[2], out offset) && offset > -23 && offset < 23)
                            {
                                ChangePlayerPanelSettings(player, "Clock", "Offset", offset.ToString());
                            }
                        }
                    }
                    else if (args[1] == "game")
                    {
                        ChangePlayerPanelSettings(player, "Clock", "Type", "Game");
                    }

                    break;
                case "timeformat":
                    if (args.Length == 1)
                    {
                        var Str = "Available Time Formats:\n";

                        for (var index = 0; index < Settings.TimeFormats.Count; index++)
                        {
                            Str +=
                                $"[<color=#ffa500ff>{index}</color>] - {DateTime.Now.ToString(Settings.TimeFormats[index])}\n";
                        }

                        PrintToChat(player, Str + "Usage: /ipanel timeformat <color=#ffa500ff> NUMBER </color>");
                    }
                    else if (args.Length == 2)
                    {
                        var TimeFormat = 0;
                        if (int.TryParse(args[1], out TimeFormat) && TimeFormat >= 0 &&
                            TimeFormat < Settings.TimeFormats.Count)
                        {
                            ChangePlayerPanelSettings(player, "Clock", "TimeFormat", TimeFormats[TimeFormat]);
                        }
                    }

                    break;
                default:
                    PrintToChat(player, "Wrong Command!");
                    break;
            }

            ;
        }

        [ChatCommand("iptest")]
        private void IPaCommand(BasePlayer player, string command, string[] args)
        {
        }

        [ChatCommand("iperr")]
        private void IPCommand(BasePlayer player, string command, string[] args)
        {
            /*
            foreach (string item in Err)
            {
                Puts(item);
            }*/

            /*foreach (KeyValuePair<string,Dictionary<string,IPanel>> item in PlayerDockPanels)
            {
                foreach (KeyValuePair<string, IPanel> itemm in item.Value)
                {
                    Puts(itemm.Key);
                }
            }*/
            /*
            foreach (KeyValuePair<string, int> item in ErrB.OrderBy(k => k.Key))
            {
                Puts(item.Key + " - " + item.Value);
            }*/
            /*
             foreach (KeyValuePair<string, List<string>> item in ErrA)
             {
                 Puts(item.Key + " -> ");

                 foreach (string itemm in item.Value)
                 {
                     Puts(itemm);
                 }

                 Puts("--------");
             }*/

            Err.Clear();
            ErrA.Clear();
            ErrB.Clear();
        }

        #endregion

        #region StoredData

        public static StoredData storedData;

        public class StoredData
        {
            public Dictionary<string, PlayerSettings> Players;

            public StoredData()
            {
                Players = new Dictionary<string, PlayerSettings>();
            }

            public bool CheckPlayerData(BasePlayer Player)
            {
                return Players.ContainsKey(Player.UserIDString);
            }

            public T GetPlayerSettings<T>(string PlayerID, string Key, T DefaultValue)
            {
                PlayerSettings playerSettings;
                if (Players.TryGetValue(PlayerID, out playerSettings))
                    return playerSettings.GetSetting(Key, DefaultValue);
                return DefaultValue;
            }

            public T GetPlayerPanelSettings<T>(BasePlayer Player, string Panel, string Key, T DefaultValue)
            {
                PlayerSettings playerSettings;
                if (Players.TryGetValue(Player.UserIDString, out playerSettings))
                    return playerSettings.GetPanelSetting(Panel, Key, DefaultValue);
                return DefaultValue;
            }

            public T GetPlayerPanelSettings<T>(string PlayerID, string Panel, string Key, T DefaultValue)
            {
                PlayerSettings playerSettings;
                if (Players.TryGetValue(PlayerID, out playerSettings))
                    return playerSettings.GetPanelSetting(Panel, Key, DefaultValue);
                return DefaultValue;
            }
        }

        public class PlayerSettings
        {
            public string UserId;
            public Dictionary<string, string> Settings;
            public Dictionary<string, Dictionary<string, string>> PanelSettings;

            public PlayerSettings()
            {
                Settings = new Dictionary<string, string>();
                PanelSettings = new Dictionary<string, Dictionary<string, string>>();
            }

            public PlayerSettings(BasePlayer player)
            {
                UserId = player.UserIDString;
                Settings = new Dictionary<string, string>();
                PanelSettings = new Dictionary<string, Dictionary<string, string>>();
            }

            public void SetSetting(string Key, string Value)
            {
                Settings[Key] = Value;
            }

            public void SetPanelSetting(string Panel, string Key, string Value)
            {
                Dictionary<string, string> settings;
                if (!PanelSettings.TryGetValue(Panel, out settings))
                    PanelSettings.Add(Panel, settings = new Dictionary<string, string>());

                settings[Key] = Value;
            }

            public T GetPanelSetting<T>(string Panel, string Key, T DefaultValue)
            {
                Dictionary<string, string> PanelConfig;
                if (!PanelSettings.TryGetValue(Panel, out PanelConfig))
                    return DefaultValue;

                string value;
                if (!PanelConfig.TryGetValue(Key, out value))
                    return DefaultValue;

                if (value == null)
                    return DefaultValue;
                return (T)Convert.ChangeType(value, typeof(T));
            }


            public T GetSetting<T>(string Key, T DefaultValue)
            {
                string value;
                if (!Settings.TryGetValue(Key, out value))
                    return DefaultValue;

                if (value == null)
                    return DefaultValue;

                return (T)Convert.ChangeType(value, typeof(T));
            }
        }

        public void LoadData()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("InfoPanel_db");
            if (storedData == null)
            {
                storedData = new StoredData();
                SaveData();
            }
        }

        public void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("InfoPanel_db", storedData);
        }

        public void ChangePlayerSettings(BasePlayer player, string Key, string Value)
        {
            PlayerSettings playerSettings;
            if (!storedData.Players.TryGetValue(player.UserIDString, out playerSettings))
                storedData.Players[player.UserIDString] = playerSettings = new PlayerSettings(player);
            playerSettings.SetSetting(Key, Value);
        }

        public void ChangePlayerPanelSettings(BasePlayer player, string Panel, string Key, string Value)
        {
            PlayerSettings playerSettings;
            if (!storedData.Players.TryGetValue(player.UserIDString, out playerSettings))
                storedData.Players[player.UserIDString] = playerSettings = new PlayerSettings(player);
            playerSettings.SetPanelSetting(Panel, Key, Value);
        }

        #endregion

        public List<string> Err = new List<string>();
        public Dictionary<string, List<string>> ErrA = new Dictionary<string, List<string>>();
        public Dictionary<string, int> ErrB = new Dictionary<string, int>();
        public Dictionary<string, int> ErrD = new Dictionary<string, int>();

        #region IPanelClass

        [JsonObject(MemberSerialization.OptIn)]
        public class IPanel
        {
            #region Class Variables

            [JsonProperty("name")] public string Name { get; set; }

            [JsonProperty("parent")] public string ParentName { get; set; } = "Hud";

            [JsonProperty("components")] public List<ICuiComponent> Components = new List<ICuiComponent>();

            [JsonProperty("fadeOut")] public float FadeOut { get; set; }

            //Left-Right
            public Vector2 HorizontalPosition { get; set; } = new Vector2(0f, 1f);

            //Bottom-Top
            public Vector2 VerticalPosition { get; set; } = new Vector2(0f, 1f);

            public string AnchorX { get; set; } = "Left";

            public string AnchorY { get; set; } = "Bottom";

            public Vector4 Padding = Vector4.zero;
            public Vector4 Margin { get; set; } = Vector4.zero;

            public float Width { get; set; } = 1f;

            public float Height { get; set; } = 1f;

            public Color _BGColor = Color.black;

            public Color BackgroundColor
            {
                get { return _BGColor; }
                set
                {
                    _BGColor = value;

                    if (ImageComponent == null)
                    {
                        ImageComponent = new CuiImageComponent();
                        Components.Insert(0, ImageComponent);
                    }

                    ImageComponent.Color = $"{value.r} {value.g} {value.b} {value.a}";
                }
            }

            public int Order = 0;

            public float _VerticalOffset = 0f;

            public float VerticalOffset
            {
                get { return _VerticalOffset; }

                set
                {
                    _VerticalOffset = value;
                    SetVerticalPosition();
                }
            }

            //public Dictionary<string, IPanel> Childs = new Dictionary<string, IPanel>();
            public List<string> Childs = new List<string>();

            //Components
            public CuiRectTransformComponent RecTransform;
            public CuiImageComponent ImageComponent;

            //public bool ChildsChanged = false;

            BasePlayer Owner = null;

            public string DockName = null;

            public bool IsActive = false;
            public bool IsHidden = false;

            public bool IsPanel = false;
            public bool IsDock = false;

            public bool Autoload = true;
            private Dictionary<string, Dictionary<string, IPanel>> playerPanels;
            private Dictionary<string, Dictionary<string, IPanel>> playerDockPanels;

            #endregion

            public IPanel(string name, BasePlayer Player, Dictionary<string, Dictionary<string, IPanel>> playerPanels,
                Dictionary<string, Dictionary<string, IPanel>> playerDockPanels)
            {
                Name = name;
                Owner = Player;
                this.playerPanels = playerPanels;
                this.playerDockPanels = playerDockPanels;

                //LoadedPanels.Add(this._Name, this);

                Dictionary<string, IPanel> playerPanel;
                if (!playerPanels.TryGetValue(Player.UserIDString, out playerPanel))
                    playerPanels.Add(Player.UserIDString, playerPanel = new Dictionary<string, IPanel>());
                playerPanel.Add(name, this);

                RecTransform = new CuiRectTransformComponent();
                Components.Add(RecTransform);
            }

            public void SetAnchorXY(string Horizontal, string Vertical)
            {
                AnchorX = Horizontal;
                AnchorY = Vertical;
            }

            #region Positioning

            //x,y,z,w
            public void SetHorizontalPosition()
            {
                float Left;
                float Right;
                var Offset = GetOffset();

                if (AnchorX == "Right")
                {
                    Right = 1f - Margin.w;
                    Left = Right - Width;

                    HorizontalPosition = new Vector2(Left, Right) - new Vector2(Offset, Offset);
                }
                else
                {
                    Left = 0f + Margin.y;
                    Right = Left + Width;

                    HorizontalPosition = new Vector2(Left, Right) + new Vector2(Offset, Offset);
                }

                RecTransform.AnchorMin = $"{HorizontalPosition.x} {VerticalPosition.x}";
                RecTransform.AnchorMax = $"{HorizontalPosition.y} {VerticalPosition.y}";
            }

            public void SetVerticalPosition()
            {
                float Top;
                float Bottom;

                if (AnchorY == "Top")
                {
                    Top = 1f - Margin.x;
                    Bottom = Top - Height;
                    VerticalPosition = new Vector2(Bottom, Top) + new Vector2(_VerticalOffset, _VerticalOffset);
                }
                else
                {
                    Bottom = 0f + Margin.z;
                    Top = Bottom + Height;

                    VerticalPosition = new Vector2(Bottom, Top) + new Vector2(_VerticalOffset, _VerticalOffset);
                }

                RecTransform.AnchorMin = $"{HorizontalPosition.x} {VerticalPosition.x}";
                RecTransform.AnchorMax = $"{HorizontalPosition.y} {VerticalPosition.y}";
            }

            float FullWidth()
            {
                return Width + Margin.y + Margin.w;
            }

            float GetSiblingsFullWidth()
            {
                return 1f;
            }

            #endregion

            #region Json

            public string ToJson()
            {
                SetHorizontalPosition();
                SetVerticalPosition();

                return JsonConvert.SerializeObject(
                    this,
                    new JsonSerializerSettings
                    {
                        NullValueHandling = NullValueHandling.Ignore,
                        DefaultValueHandling = DefaultValueHandling.Ignore
                    }
                );
            }


            public float GetOffset()
            {
                var Offset = 0f;

                var Parent = GetPanel(ParentName);

                if (Parent == null)
                    return Offset;

                var Siblings = Parent.GetChilds()
                    .Where(c => c.Value.AnchorX == AnchorX && c.Value.Order <= Order && c.Value.IsActive &&
                                c.Value.Name != Name).Select(c => c.Value).OrderBy(s => s.Order);

                foreach (var Sibling in Siblings)
                    Offset += Sibling.Width + Sibling.Margin.y + Sibling.Margin.w;

                return Offset;
            }

            public string GetJson(bool Brackets = true)
            {
                var Panel = ToJson();
                return Brackets ? $"[{Panel}]" : Panel;
            }

            #endregion

            #region Childs

            public int GetLastChild()
            {
                if (Childs.Count == 0)
                {
                    return 0;
                }
                else
                {
                    return GetChilds().Max(p => p.Value.Order);
                }
            }

            public IPanelText AddText(string Name)
            {
                var Text = new IPanelText(Name, Owner, playerPanels, playerDockPanels) { ParentName = this.Name };
                Childs.Add(Name);
                return Text;
            }

            public IPanelRawImage AddImage(string Name)
            {
                var Image = new IPanelRawImage(Name, Owner, playerPanels, playerDockPanels) { ParentName = this.Name };
                Childs.Add(Name);
                return Image;
            }

            public IPanel AddPanel(string Name)
            {
                var Panel = new IPanel(Name, Owner, playerPanels, playerDockPanels) { ParentName = this.Name };
                Childs.Add(Name);
                return Panel;
            }

            #endregion

            #region Selectors

            List<string> GetActiveAfterThis()
            {
                var Panels = playerPanels[Owner.UserIDString]
                    .Where(p => p.Value.IsActive && p.Value.Order > Order && p.Value.ParentName == ParentName &&
                                p.Value.AnchorX == AnchorX)
                    .OrderBy(s => s.Value.Order)
                    .Select(k => k.Key)
                    .ToList();

                return Panels;
            }

            public Dictionary<string, IPanel> GetChilds()
            {
                return playerPanels[Owner.UserIDString].Where(x => Childs.Contains(x.Key))
                    .ToDictionary(se => se.Key, se => se.Value);
            }

            public IPanel GetParent()
            {
                return GetPanel(ParentName);
            }

            public List<IPanel> GetSiblings()
            {
                return GetPanel(ParentName)?.GetChilds().Where(c => c.Value.AnchorX == AnchorX && c.Value.Name != Name)
                    .Select(c => c.Value).OrderBy(s => s.Order).ToList() ?? new List<IPanel>();
            }

            public IPanel GetPanel(string PName)
            {
                Dictionary<string, IPanel> panels;
                IPanel panel;
                if (playerPanels.TryGetValue(Owner.UserIDString, out panels) && panels.TryGetValue(PName, out panel))
                    return panel;
                return null;
            }

            public IPanel GetDock()
            {
                if (DockName == null) return null;
                Dictionary<string, IPanel> panels;
                IPanel panel;
                if (playerDockPanels.TryGetValue(Owner.UserIDString, out panels) &&
                    panels.TryGetValue(DockName, out panel))
                    return panel;
                return null;
            }

            #endregion

            #region GUI

            public void Hide()
            {
                foreach (var Panel in GetChilds().Where(p => p.Value.IsActive))
                    Panel.Value.Hide();

                CuiHelper.DestroyUi(Owner, Name);
                //CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(this.Owner.net.connection), null, "DestroyUI", new Facepunch.ObjectList(this._Name));
            }

            public void Reveal()
            {
                //Interface.Oxide.LogInfo(GetJson()); //TODO
                CuiHelper.AddUi(Owner, GetJson());
                //CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(this.Owner.net.connection), null, "AddUI", new Facepunch.ObjectList(GetJson()));

                IsActive = true;
                IsHidden = false;

                foreach (var Child in GetChilds().Where(p => p.Value.Autoload || p.Value.IsActive)
                    .OrderBy(s => s.Value.Order))
                    Child.Value.Reveal();
            }

            void ReDrawPanels(List<string> PanelsName)
            {
                foreach (var PanelName in PanelsName)
                    GetPanel(PanelName)?.DestroyPanel(false);

                foreach (var PanelName in PanelsName)
                    GetPanel(PanelName)?.ShowPanel();
            }

            public void ShowPanel(bool Childs = true)
            {
                if (storedData.GetPlayerSettings(Owner.UserIDString, "enable", true))
                {
                    var Dock = GetDock();
                    if (Dock != null && Dock.IsActive == false)
                        Dock.ShowPanel(false);

                    var ActivePanelsAfterThis = GetActiveAfterThis();

                    foreach (var PanelName in ActivePanelsAfterThis)
                        GetPanel(PanelName)?.DestroyPanel(false);

                    //ErrB.Add(this.Name + ErrB.Count,ActivePanelsAfterThis.Count);

                    if (storedData.GetPlayerSettings(Owner.UserIDString, "enable", true))
                    {
                        //Interface.Oxide.LogInfo(GetJson()); //TODO
                        CuiHelper.AddUi(Owner, GetJson());
                        //CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(this.Owner.net.connection), null, "AddUI", new Facepunch.ObjectList(GetJson()));
                    }

                    IsActive = true;
                    IsHidden = false;

                    if (Childs)
                    {
                        foreach (var Child in GetChilds().Where(p => p.Value.Autoload || p.Value.IsActive)
                            .OrderBy(s => s.Value.Order))
                            Child.Value.ShowPanel();
                    }

                    foreach (var PanelName in ActivePanelsAfterThis)
                        GetPanel(PanelName)?.ShowPanel();
                }
                else
                {
                    ShowPanelIfHidden();
                }
            }

            void ShowPanelIfHidden(bool Childs = true)
            {
                IsActive = true;
                IsHidden = true;
                if (Childs)
                {
                    foreach (var Child in GetChilds().Where(p => p.Value.Autoload || p.Value.IsActive)
                        .OrderBy(s => s.Value.Order))
                        Child.Value.ShowPanel();
                }
            }


            public void DestroyPanel(bool Redraw = true)
            {
                foreach (var Panel in GetChilds().Where(p => p.Value.IsActive))
                    Panel.Value.DestroyPanel(false);

                CuiHelper.DestroyUi(Owner, Name);
                //CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(this.Owner.net.connection), null, "DestroyUI", new Facepunch.ObjectList(this._Name));

                IsActive = false;

                if (Redraw)
                    ReDrawPanels(GetActiveAfterThis());

                var Dock = GetDock();
                if (Dock?.GetChilds().Count(p => p.Value.IsActive) == 0) Dock.DestroyPanel();
            }


            public virtual void Refresh()
            {
                DestroyPanel();
                ShowPanel();
            }

            #endregion

            #region Util

            public void Remover()
            {
                foreach (var Child in GetChilds())
                    Child.Value.Remover();

                GetPanel(ParentName).Childs.Remove(Name);
                playerPanels[Owner.UserIDString].Remove(Name);
            }

            protected string ColorToString(Color color)
            {
                return $"{color.r} {color.g} {color.b} {color.a}";
            }

            #endregion
        }

        public class IPanelText : IPanel
        {
            public string Content
            {
                get { return TextComponent.Text; }
                set { TextComponent.Text = value; }
            }

            public TextAnchor Align
            {
                get { return TextComponent.Align; }

                set { TextComponent.Align = value; }
            }

            public int FontSize
            {
                get { return TextComponent.FontSize; }
                set { TextComponent.FontSize = value; }
            }

            public Color _FontColor = Color.white;

            public Color FontColor
            {
                get { return _FontColor; }
                set
                {
                    _FontColor = value;
                    TextComponent.Color = $"{value.r} {value.g} {value.b} {value.a}";
                }
            }

            public CuiTextComponent TextComponent;

            public IPanelText(string Name, BasePlayer Player,
                Dictionary<string, Dictionary<string, IPanel>> playerPanels,
                Dictionary<string, Dictionary<string, IPanel>> playerDockPanels) : base(Name, Player, playerPanels,
                playerDockPanels)
            {
                TextComponent = new CuiTextComponent();
                Components.Insert(0, TextComponent);
            }

            public void RefreshText(BasePlayer player, string text)
            {
                DestroyPanel();
                Content = text;
                ShowPanel();
            }
        }

        public class IPanelRawImage : IPanel
        {
            public string Url
            {
                get { return RawImageComponent.Url; }
                set { RawImageComponent.Url = value; }
            }

            public Color _Color;

            public Color Color
            {
                get { return _Color; }
                set
                {
                    _Color = value;
                    RawImageComponent.Color = ColorToString(value);
                }
            }

            public CuiRawImageComponent RawImageComponent;

            public IPanelRawImage(string Name, BasePlayer Player,
                Dictionary<string, Dictionary<string, IPanel>> playerPanels,
                Dictionary<string, Dictionary<string, IPanel>> playerDockPanels) : base(Name, Player, playerPanels,
                playerDockPanels)
            {
                RawImageComponent = new CuiRawImageComponent();
                Components.Insert(0, RawImageComponent);
            }
        }

        #endregion

        #region GUI

        private void DestroyGUI(BasePlayer player)
        {
            foreach (var Dock in PlayerDockPanels[player.UserIDString])
            {
                Dock.Value.DestroyPanel(false);
            }
        }

        void GUITimerInit(BasePlayer player)
        {
            if (player == null) return;

            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(2, () => GUITimerInit(player));
            }
            else if (!PlayerDockPanels.ContainsKey(player.UserIDString))
            {
                LoadPanels(player);
                InitializeGUI(player);

                RefreshOnlinePlayers();
            }
        }

        private void InitializeGUI(BasePlayer player)
        {
            if (!storedData.GetPlayerSettings(player.UserIDString, "enable", true))
                return;

            foreach (var Panel in PlayerPanels[player.UserIDString])
            {
                switch (Panel.Key)
                {
                    case "ClockText":
                        ((IPanelText)Panel.Value).Content = Clock.ShowTime(player.UserIDString, storedData);
                        break;
                    case "OPlayersText":
                        ((IPanelText)Panel.Value).Content =
                            BasePlayer.activePlayerList.Count + "/" + ConVar.Server.maxplayers;
                        break;
                    case "SleepersText":
                        ((IPanelText)Panel.Value).Content = BasePlayer.sleepingPlayerList.Count.ToString();
                        break;
                    case "MessageBoxText":
                        ((IPanelText)Panel.Value).Content = MessageBox.GetMessage();
                        break;
                    case "CoordinatesText":
                        ((IPanelText)Panel.Value).Content = Coord.GetCoord(player.UserIDString);
                        break;
                    case "BalanceText":
                        ((IPanelText)Panel.Value).Content = $"{Bala.GetBalance(player.UserIDString):N}";
                        break;
                    case "RadiationImage":
                        ((IPanelRawImage)Panel.Value).Color = Rad.ImageColor;
                        break;
                    case "AirdropEventImage":
                        ((IPanelRawImage)Panel.Value).Color = Airplane.ImageColor;
                        break;
                    case "HelicopterEventImage":
                        ((IPanelRawImage)Panel.Value).Color = Helicopter.ImageColor;
                        break;
                    case "ChinookEventImage":
                        ((IPanelRawImage)Panel.Value).Color = Chinook.ImageColor;
                        break;
                    case "BradleyEventImage":
                        ((IPanelRawImage)Panel.Value).Color = Bradley.ImageColor;
                        break;
                    case "CargoShipEventImage":
                        ((IPanelRawImage)Panel.Value).Color = Cargoship.ImageColor;
                        break;
                    case "CompassText":
                        ((IPanelText)Panel.Value).Content = CompassObj.GetDirection(player.UserIDString);
                        break;
                }
            }

            foreach (var Dock in PlayerDockPanels[player.UserIDString])
            {
                if (Dock.Value.Childs.Count != 0)
                    Dock.Value.ShowPanel();
            }
        }

        private void RevealGUI(BasePlayer player)
        {
            foreach (var Dock in PlayerDockPanels[player.UserIDString])
            {
                if (Dock.Value.Childs.Count != 0)
                    Dock.Value.ShowPanel();
            }
        }

        private void RefreshOnlinePlayers()
        {
            foreach (var panel in PlayerPanels)
            {
                if (Settings.GetPanelSettingsValue("OPlayers", "Available", true) &&
                    panel.Value.ContainsKey("OPlayersText"))
                {
                    var panelText = (IPanelText)panel.Value["OPlayersText"];
                    panelText.Content = $"{BasePlayer.activePlayerList.Count}/{ConVar.Server.maxplayers}";
                    panelText.Refresh();
                }
            }
        }

        private void RefreshSleepers()
        {
            foreach (var panel in PlayerPanels)
            {
                if (Settings.GetPanelSettingsValue("Sleepers", "Available", true) &&
                    panel.Value.ContainsKey("SleepersText"))
                {
                    var panelText = (IPanelText)panel.Value["SleepersText"];
                    panelText.Content = BasePlayer.sleepingPlayerList.Count.ToString();
                    panelText.Refresh();
                }
            }
        }

        #endregion

        #region API

        private bool PanelRegister(string PluginName, string PanelName, string json)
        {
            List<string> loadedPlugin;
            if (LoadedPluginPanels.TryGetValue(PluginName, out loadedPlugin) && loadedPlugin.Contains(PanelName))
                return true;

            var Cfg = JsonConvert.DeserializeObject<PanelConfig>(json);

            Dictionary<string, PanelConfig> thirdPartyPanel;
            if (!Settings.ThirdPartyPanels.TryGetValue(PluginName, out thirdPartyPanel))
                Settings.ThirdPartyPanels.Add(PluginName, thirdPartyPanel = new Dictionary<string, PanelConfig>());

            if (!thirdPartyPanel.ContainsKey(PanelName))
            {
                Cfg.Order = PanelReOrder(Cfg.Dock, Cfg.AnchorX);
                thirdPartyPanel.Add(PanelName, Cfg);

                Config.WriteObject(Settings, true);
                PrintWarning($"New panel added to the config file: {PanelName}");
            }

            foreach (var Docks in PlayerDockPanels)
            {
                if (Docks.Value.ContainsKey(Cfg.Dock))
                    LoadPanel(Docks.Value[Cfg.Dock], PanelName, Cfg);
            }

            if (!LoadedPluginPanels.TryGetValue(PluginName, out loadedPlugin))
                LoadedPluginPanels.Add(PluginName, loadedPlugin = new List<string>());
            loadedPlugin.Add(PanelName);

            return true;
        }

        private bool ShowPanel(string PluginName, string PanelName, string PlayerId = null)
        {
            if (!Settings.ThirdPartyPanels[PluginName][PanelName].Available)
                return false;

            if (PlayerId != null && PlayerPanels.ContainsKey(PlayerId))
            {
                PlayerPanels[PlayerId][PanelName].ShowPanel();
                return true;
            }

            foreach (var PlayerID in PlayerPanels.Keys)
                PlayerPanels[PlayerID][PanelName].ShowPanel();

            return true;
        }

        private bool HidePanel(string PluginName, string PanelName, string PlayerId = null)
        {
            if (!Settings.ThirdPartyPanels[PluginName][PanelName].Available)
                return false;

            if (PlayerId != null && PlayerPanels.ContainsKey(PlayerId))
            {
                PlayerPanels[PlayerId][PanelName].DestroyPanel();
                return true;
            }

            foreach (var PlayerID in PlayerPanels.Keys)
                PlayerPanels[PlayerID][PanelName].DestroyPanel();

            return true;
        }

        private bool RefreshPanel(string PluginName, string PanelName, string PlayerId = null)
        {
            if (!Settings.ThirdPartyPanels[PluginName][PanelName].Available)
                return false;

            if (PlayerId != null && PlayerPanels.ContainsKey(PlayerId))
            {
                PlayerPanels[PlayerId][PanelName].DestroyPanel();
                PlayerPanels[PlayerId][PanelName].ShowPanel();
                return true;
            }

            foreach (var PlayerID in PlayerPanels.Keys)
            {
                PlayerPanels[PlayerID][PanelName].DestroyPanel();
                PlayerPanels[PlayerID][PanelName].ShowPanel();
            }

            return true;
        }

        private void SetPanelAttribute(string PluginName, string PanelName, string Attribute, string Value,
            string PlayerId = null)
        {
            if (PlayerId != null && PlayerPanels.ContainsKey(PlayerId))
            {
                var Panel = PlayerPanels[PlayerId][PanelName];
                var PropInfo = Panel.GetType().GetProperty(Attribute);

                if (PropInfo == null)
                {
                    PrintWarning("Wrong Attribute name: " + Attribute);
                    return;
                }

                if (Attribute == "FontColor" || Attribute == "BackgroundColor")
                {
                    PropInfo.SetValue(Panel, ColorEx.Parse(Value), null);
                }
                else if (Attribute == "Margin")
                {
                    PropInfo.SetValue(Panel, Vector4Parser(Value), null);
                }
                else
                {
                    var ConvertedValue = Convert.ChangeType(Value, PropInfo.PropertyType);

                    PropInfo.SetValue(Panel, ConvertedValue, null);
                }

                return;
            }

            foreach (var playerID in PlayerPanels.Keys)
            {
                var Panel = PlayerPanels[playerID][PanelName];
                var PropInfo = Panel.GetType().GetProperty(Attribute);

                if (PropInfo == null)
                {
                    PrintWarning("Wrong Attribute name: " + Attribute);
                    return;
                }

                if (Attribute == "FontColor" || Attribute == "BackgroundColor")
                {
                    PropInfo.SetValue(Panel, ColorEx.Parse(Value), null);
                }
                else if (Attribute == "Margin")
                {
                    PropInfo.SetValue(Panel, Vector4Parser(Value), null);
                }
                else
                {
                    var ConvertedValue = Convert.ChangeType(Value, PropInfo.PropertyType);

                    PropInfo.SetValue(Panel, ConvertedValue, null);
                }
            }
        }

        private bool SendPanelInfo(string PluginName, List<string> Panels)
        {
            Dictionary<string, PanelConfig> panelConfig;
            if (!Settings.ThirdPartyPanels.TryGetValue(PluginName, out panelConfig))
            {
                return false;
            }

            var Removable = panelConfig.Keys.Except(Panels).ToList();

            foreach (var item in Removable)
            {
                panelConfig.Remove(item);
            }

            if (Removable.Count > 0)
            {
                Config.WriteObject(Settings, true);
                PrintWarning($"Config File refreshed! {Removable.Count} panel removed!");
            }

            return true;
        }

        private bool IsPlayerGUILoaded(string PlayerId)
        {
            return PlayerPanels.ContainsKey(PlayerId);
        }

        #endregion

        #region Utility

        internal static Vector4 Vector4Parser(string p)
        {
            var strArrays = p.Split(' ');
            if (strArrays.Length != 4)
                return Vector4.zero;
            return new Vector4(float.Parse(strArrays[0]), float.Parse(strArrays[1]), float.Parse(strArrays[2]),
                float.Parse(strArrays[3]));
        }

        public static string FormatGridReference(Vector3 position)
        {
            Vector2 roundedPos = new Vector2(World.Size / 2 + position.x, World.Size / 2 - position.z);
            string grid = $"{NumberToLetter((int)(roundedPos.x / 150))}:{(int)(roundedPos.y / 150)}";
            return grid;
        }

        public static string NumberToLetter(int num)
        {
            int num2 = Mathf.FloorToInt(num / 26);
            int num3 = num % 26;
            string text = string.Empty;
            if (num2 > 0)
            {
                for (int i = 0; i < num2; i++)
                {
                    text += Convert.ToChar(65 + i);
                }
            }

            return text + Convert.ToChar(65 + num3).ToString();
        }

        #endregion
    }
}

// --- End of file: InfoPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/inbound ---
// --- Original File Path: I/Inbound/Inbound.cs ---

using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Inbound", "Substrata", "0.6.9")]
    [Description("Broadcasts notifications when patrol helicopters, supply drops, cargo ships, etc. are inbound")]

    class Inbound : RustPlugin
    {
        [PluginReference]
        Plugin DiscordMessages, PopupNotifications, UINotify,
        // Compatibility
        AirdropPrecision, FancyDrop;

        bool initialized;
        float worldSize; int cellCount; float cellSize;  float gridBottom; float gridTop; float gridLeft; float gridRight;
        bool hasOilRig; bool hasLargeRig; Vector3 oilRigPos; Vector3 largeRigPos; bool hasExcavator; Vector3 excavatorPos;
        ulong chatIconID; string webhookURL;

        void OnServerInitialized(bool initial) => InitVariables();

        void OnEntitySpawned(PatrolHelicopter heli)
        {
            if (!initialized) return;

            NextTick(() =>
            {
                if (heli == null || heli.IsDestroyed) return;
                SendInboundMessage(Lang("PatrolHeli", null, Location(heli.transform.position), Destination(heli.myAI.destination)), configData.alerts.patrolHeli);
            });
        }

        void OnEntitySpawned(CargoShip ship)
        {
            if (!initialized) return;

            timer.Once(3f, () =>
            {
                if (ship == null || ship.IsDestroyed) return;

                string destination = string.Empty;
                if (TerrainMeta.Path.OceanPatrolFar != null)
                {
                    int targetNodeIndex = ship.targetNodeIndex != -1 ? ship.targetNodeIndex : ship.GetClosestNodeToUs();
                    if (targetNodeIndex != -1 && TerrainMeta.Path.OceanPatrolFar.Count > targetNodeIndex)
                    {
                        destination = Destination(TerrainMeta.Path.OceanPatrolFar[targetNodeIndex]);
                    }
                }

                SendInboundMessage(Lang("CargoShip_", null, Location(ship.transform.position), destination), configData.alerts.cargoShip);
            });
        }

        void OnCargoShipHarborApproach(CargoShip ship)
        {
            if (!initialized || ship == null || ship.IsDestroyed) return;

            SendInboundMessage(Lang("CargoShipApproachHarbor", null, GetHarborLocation(ship)), configData.alerts.cargoShipHarbor);
        }

        void OnCargoShipHarborArrived(CargoShip ship)
        {
            if (!initialized || ship == null || ship.IsDestroyed) return;

            SendInboundMessage(Lang("CargoShipAtHarbor", null, GetHarborLocation(ship)), configData.alerts.cargoShipHarbor);
        }

        void OnCargoShipHarborLeave(CargoShip ship)
        {
            if (!initialized || ship == null || ship.IsDestroyed) return;

            SendInboundMessage(Lang("CargoShipLeaveHarbor", null, GetHarborLocation(ship)), configData.alerts.cargoShipHarbor);
        }

        void OnEntitySpawned(CH47HelicopterAIController ch47)
        {
            if (!initialized) return;

            timer.Once(2f, () =>
            {
                if (ch47 == null || ch47.IsDestroyed) return;
                SendInboundMessage(Lang("CH47", null, Location(ch47.transform.position), Destination(ch47.GetMoveTarget())), configData.alerts.ch47 && (!configData.misc.hideRigCrates || !ch47.ShouldLand()));
            });
        }

        void OnBradleyApcInitialize(BradleyAPC apc)
        {
            if (!initialized) return;

            NextTick(() =>
            {
                if (apc == null || apc.IsDestroyed) return;
                SendInboundMessage(Lang("BradleyAPC", null, Location(apc.transform.position)), configData.alerts.bradleyAPC);
            });
        }

        void OnEntitySpawned(TravellingVendor travellingVendor)
        {
            if (!initialized) return;

            NextTick(() =>
            {
                if (travellingVendor == null || travellingVendor.IsDestroyed) return;
                SendInboundMessage(Lang("TravellingVendor", null, Location(travellingVendor.transform.position)), configData.alerts.travellingVendor);
            });
        }

        void OnExcavatorResourceSet(ExcavatorArm arm, string resourceName, BasePlayer player)
        {
            if (!initialized) return;

            if (arm == null || arm.IsOn()) return;
            NextTick(() =>
            {
                if (player == null || arm == null || arm.IsDestroyed || !arm.IsOn()) return;
                SendInboundMessage(Lang("Excavator_", null, player.displayName, Location(arm.transform.position, null, true)), configData.alerts.excavator);
            });
        }

        void OnEntitySpawned(HackableLockedCrate crate)
        {
            if (!initialized) return;

            NextTick(() =>
            {
                if (crate == null || crate.IsDestroyed) return;
                SendInboundMessage(Lang("HackableCrateSpawned", null, Location(crate.transform.position, crate)), configData.alerts.hackableCrateSpawn && !HideCrateAlert(crate));
            });
        }

        void CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            if (!initialized) return;

            NextTick(() =>
            {
                if (player == null || crate == null || crate.IsDestroyed || !crate.IsBeingHacked()) return;
                SendInboundMessage(Lang("HackingCrate", null, player.displayName, Location(crate.transform.position, crate)), configData.alerts.hackingCrate && !HideCrateAlert(crate));
            });
        }

        // Supply Drops
        private HashSet<CalledDrop> calledDrops = new HashSet<CalledDrop>();
        private class CalledDrop
        {
            public IPlayer _iplayer = null;
            public SupplySignal _signal = null;
            public CargoPlane _plane = null;
            public SupplyDrop _drop = null;
        }

        void OnExplosiveThrown(BasePlayer player, SupplySignal signal)
        {
            if (!initialized) return;

            NextTick(() =>
            {
                if (player == null || signal == null) return;
                if (SupplyPlayerCompatible())
                    calledDrops.Add(new CalledDrop() { _iplayer = player.IPlayer, _signal = signal });
                SendInboundMessage(Lang("SupplySignal", null, player.displayName, Location(player.transform.position, player)), configData.alerts.supplySignal);
            });
        }

        void OnExplosiveDropped(BasePlayer player, SupplySignal signal) => OnExplosiveThrown(player, signal);

        void OnCargoPlaneSignaled(CargoPlane plane, SupplySignal signal)
        {
            if (plane == null || signal == null) return;
            foreach (var calledDrop in calledDrops)
            {
                if (calledDrop._signal == signal)
                {
                    calledDrop._plane = plane;
                    break;
                }
            }
        }

        void OnExcavatorSuppliesRequested(ExcavatorSignalComputer computer, BasePlayer player, CargoPlane plane)
        {
            if (!initialized) return;

            NextTick(() =>
            {
                if (player == null || plane == null) return;
                if (SupplyPlayerCompatible())
                    calledDrops.Add(new CalledDrop() { _iplayer = player.IPlayer, _plane = plane });
                SendInboundMessage(Lang("ExcavatorSupplyRequest", null, player.displayName, Location(player.transform.position)), configData.alerts.excavatorSupply);
            });
        }

        void OnAirdrop(CargoPlane plane, Vector3 dest)
        {
            if (!initialized) return;

            timer.Once(2f, () =>
            {
                if (plane == null) return;
                CalledDrop calledDrop = GetCalledDrop(plane, null);
                SendInboundMessage(Lang("CargoPlane_", null, SupplyDropPlayer(calledDrop), Location(plane.transform.position), Destination(dest)), configData.alerts.cargoPlane && !HideSupplyAlert(calledDrop));
            });
        }

        private HashSet<ulong> droppedDrops = new HashSet<ulong>();
        void OnSupplyDropDropped(SupplyDrop drop, CargoPlane plane)
        {
            if (!initialized) return;

            NextTick(() =>
            {
                if (drop == null || droppedDrops.Contains(drop.net.ID.Value)) return;
                droppedDrops.Add(drop.net.ID.Value);
                CalledDrop calledDrop = GetCalledDrop(plane, null);
                if (calledDrop != null) calledDrop._drop = drop;
                SendInboundMessage(Lang("SupplyDropDropped", null, SupplyDropPlayer(calledDrop), Location(drop.transform.position)), configData.alerts.supplyDrop && !HideSupplyAlert(calledDrop));
            });
        }

        void OnEntitySpawned(SupplyDrop drop) => NextTick(() => OnSupplyDropDropped(drop, null));

        private HashSet<ulong> landedDrops = new HashSet<ulong>();
        void OnSupplyDropLanded(SupplyDrop drop)
        {
            if (!initialized || drop == null || landedDrops.Contains(drop.net.ID.Value)) return;
            landedDrops.Add(drop.net.ID.Value);
            CalledDrop calledDrop = GetCalledDrop(null, drop);
            SendInboundMessage(Lang("SupplyDropLanded_", null, SupplyDropPlayer(calledDrop), Location(drop.transform.position)), configData.alerts.supplyDropLand && !HideSupplyAlert(calledDrop));
        }

        void OnEntityKill(SupplyDrop drop)
        {
            if (drop == null) return;
            CalledDrop calledDrop = GetCalledDrop(null, drop);
            if (calledDrop != null) calledDrops.Remove(calledDrop);
            droppedDrops.Remove(drop.net.ID.Value);
            landedDrops.Remove(drop.net.ID.Value);
        }

        #region Messages
        void SendInboundMessage(string message, bool alert)
        {
            if (string.IsNullOrEmpty(message)) return;

            string msg = Regex.Replace(message, filterTags, string.Empty);

            if (alert)
            {
                if (configData.notifications.chat)
                    Server.Broadcast(message, null, chatIconID);

                if (configData.notifications.popup && PopupNotifications)
                    PopupNotifications.Call("CreatePopupNotification", msg);

                if (configData.uiNotify.enabled && UINotify)
                    SendUINotify(msg);

                if (configData.discordMessages.enabled && DiscordMessages && webhookURL.Contains("/api/webhooks/"))
                    SendDiscordMessage(msg);
            }
            if (alert || configData.logging.allEvents)
                LogInboundMessage(msg);
        }

        void SendUINotify(string msg)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (permission.UserHasPermission(player.UserIDString, "uinotify.see"))
                    UINotify.Call("SendNotify", player, configData.uiNotify.type, msg);
            }
        }

        void SendDiscordMessage(string msg)
        {
            string dMsg = Lang("DiscordMessage_", null, msg);
            if (string.IsNullOrWhiteSpace(dMsg)) return;

            if (configData.discordMessages.embedded)
            {
                object fields = new[]
                {
                    new {
                        name = configData.discordMessages.embedTitle, value = dMsg, inline = false
                    }
                };
                string json = JsonConvert.SerializeObject(fields);
                DiscordMessages.Call("API_SendFancyMessage", webhookURL, string.Empty, configData.discordMessages.embedColor, json);
            }
            else
                DiscordMessages.Call("API_SendTextMessage", webhookURL, dMsg);
        }

        void LogInboundMessage(string msg)
        {
            if (configData.logging.console)
                Puts(msg);
            
            if (configData.logging.file)
                LogToFile("log", $"[{DateTime.Now.ToString("HH:mm:ss")}] {msg}", this);
        }
        #endregion

        #region Helpers
        private string Location(Vector3 pos, BaseEntity entity = null, bool hideExc = false)
        {
            string location = GetLocation(pos, entity, hideExc);
            return !string.IsNullOrEmpty(location) ? Lang("Location", null, location) : string.Empty;
        }

        private string Destination(Vector3 pos)
        {
            string destination = GetLocation(pos, null);
            return !string.IsNullOrEmpty(destination) ? Lang("Destination", null, destination) : string.Empty;
        }

        private string GetLocation(Vector3 pos, BaseEntity entity, bool hideExc = false)
        {
            var sb = new StringBuilder();

            if (configData.location.showCargoShip)
                if (IsAtCargoShip(entity)) sb.Append("Cargo Ship");

            if (configData.location.showOilRigs && sb.Length == 0)
            {
                if (IsAtOilRig(pos)) sb.Append("Oil Rig");
                else if (IsAtLargeRig(pos)) sb.Append("Large Oil Rig");
            }

            if (configData.location.showExcavator && !hideExc && sb.Length == 0)
                if (IsAtExcavator(pos)) sb.Append("The Excavator");

            if (configData.location.showGrid && sb.Length == 0)
            {
                if (pos.x > gridLeft && (!configData.location.hideOffGrid || !IsOffGrid(pos)))
                    sb.Append(GetGrid(pos));
            }

            if (configData.location.showCoords)
            {
                bool hideDecimals = configData.location.hideCoordDecimals;
                string x = hideDecimals ? Mathf.Round(pos.x).ToString()+"," : pos.x.ToString("0.##")+",";
                string y = hideDecimals ? Mathf.Round(pos.y).ToString()+"," : pos.y.ToString("0.##")+",";
                string z = hideDecimals ? Mathf.Round(pos.z).ToString() : pos.z.ToString("0.##");
                if (configData.location.hideYCoord) y = string.Empty;

                sb.Append(sb.Length == 0 ? x+y+z : $" ({x}{y}{z})");
            }

            return sb.ToString();
        }

        string GetHarborLocation(CargoShip cargoShip)
        {
            if (cargoShip.harborIndex != -1 && CargoShip.harbors.Count > cargoShip.harborIndex)
            {
                var currentHarbor = CargoShip.harbors[cargoShip.harborIndex];
                return Location(currentHarbor.harborTransform.position);
            }

            return string.Empty;
        }

        string GetGrid(Vector3 pos)
        {
            int x = Mathf.FloorToInt((pos.x + (worldSize / 2)) / cellSize);
            int z = Mathf.FloorToInt((pos.z + (worldSize / 2)) / cellSize);

            string columnLabel = string.Empty;
            int num = x / 26;

            if (num > 0)
            {
                for (int i = 0; i < num; i++)
                {
                    columnLabel += Convert.ToChar(65 + i);
                }
            }

            columnLabel += Convert.ToChar(65 + (x % 26));

            int row = cellCount - 1 - z;

            return $"{columnLabel}{row}";
        }

        private CalledDrop GetCalledDrop(CargoPlane plane, SupplyDrop drop)
        {
            foreach (var calledDrop in calledDrops)
            {
                if ((plane != null && calledDrop._plane == plane) || (drop != null && calledDrop._drop == drop))
                    return calledDrop;
            }
            return null;
        }

        private string SupplyDropPlayer(CalledDrop calledDrop)
        {
            IPlayer iplayer = calledDrop != null ? calledDrop._iplayer : null;
            return configData.misc.showSupplyPlayer && iplayer != null ? Lang("SupplyDropPlayer", null, iplayer.Name) : string.Empty;
        }

        private bool HideSupplyAlert(CalledDrop calledDrop)
        {
            bool playerCalled = calledDrop != null;
            return SupplyPlayerCompatible() && ((configData.misc.hideCalledSupply && playerCalled) || (configData.misc.hideRandomSupply && !playerCalled));
        }

        private bool HideCrateAlert(HackableLockedCrate crate)
        {
            Vector3 pos = crate.transform.position;
            return (configData.misc.hideCargoCrates && IsAtCargoShip(crate)) || (configData.misc.hideRigCrates && (IsAtOilRig(pos) || IsAtLargeRig(pos)));
        }

        const string filterTags = @"(?i)<\/?(align|alpha|color|cspace|indent|line-height|line-indent|margin|mark|mspace|pos|size|space|voffset|b|i|lowercase|uppercase|smallcaps|s|u|sup|sub)(\s*=[^>]*?)?\s*\/?>";
        private bool IsAtOilRig(Vector3 pos) => hasOilRig && Vector3Ex.Distance2D(oilRigPos, pos) <= 60f;
        private bool IsAtLargeRig(Vector3 pos) => hasLargeRig && Vector3Ex.Distance2D(largeRigPos, pos) <= 75f;
        private bool IsAtCargoShip(BaseEntity entity) => entity?.GetComponentInParent<CargoShip>();
        private bool IsAtExcavator(Vector3 pos) => hasExcavator && Vector3Ex.Distance2D(excavatorPos, pos) <= 145f;
        private bool IsOffGrid(Vector3 pos) => pos.x < gridLeft || pos.x > gridRight || pos.z < gridBottom || pos.z > gridTop;
        private bool SupplyPlayerCompatible() => !FancyDrop && !AirdropPrecision;

        void InitVariables()
        {
            // Grid
            worldSize = TerrainMeta.Size.x;
            cellCount = Mathf.FloorToInt((worldSize * 7) / 1024);
            cellSize = worldSize / cellCount;

            gridBottom = TerrainMeta.Position.z;
            gridTop = gridBottom + (cellSize * cellCount);
            gridLeft = TerrainMeta.Position.x;
            gridRight = gridLeft + (cellSize * cellCount);

            // Monuments
            foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
            {
                var name = monument.name;
                if (name == "assets/bundled/prefabs/autospawn/monument/large/excavator_1.prefab")
                {
                    hasExcavator = true;
                    excavatorPos = monument.transform.localToWorldMatrix.MultiplyPoint3x4(new Vector3(20f,0,-30f));
                    continue;
                }
                if (name == "assets/bundled/prefabs/autospawn/monument/offshore/oilrig_1.prefab")
                {
                    hasLargeRig = true;
                    largeRigPos = monument.transform.position;
                    continue;
                }
                if (name == "assets/bundled/prefabs/autospawn/monument/offshore/oilrig_2.prefab")
                {
                    hasOilRig = true;
                    oilRigPos = monument.transform.position;
                    continue;
                }
            }

            // General & plugins
            if (configData.notifications.chat && configData.misc.chatIcon != 0)
            {
                if (!configData.misc.chatIcon.IsSteamId())
                    PrintWarning("Chat Icon is not set to a valid SteamID64.");
                else
                    chatIconID = configData.misc.chatIcon;
            }

            if (configData.notifications.popup && !PopupNotifications)
                PrintWarning("The 'Popup Notifications' plugin could not be found.");

            if (configData.discordMessages.enabled)
            {
                webhookURL = configData.discordMessages.webhookURL;
                if (!DiscordMessages)
                    PrintWarning("The 'Discord Messages' plugin could not be found.");
                else if (!webhookURL.Contains("/api/webhooks/"))
                    PrintWarning("The 'Discord Messages' Webhook URL is missing or invalid.");
            }

            if (configData.uiNotify.enabled && !UINotify)
                PrintWarning("The 'UI Notify' plugin could not be found.");

            if (!SupplyPlayerCompatible() && (configData.misc.showSupplyPlayer || configData.misc.hideCalledSupply || configData.misc.hideRandomSupply))
                PrintWarning("The 'Supply Drop Player' options are not currently compatible with Fancy Drop or Aidrop Precision. Using defaults (false).");

            initialized = true;
        }
        #endregion

        #region Configuration
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Notifications")]
            public Notifications notifications { get; set; }
            [JsonProperty(PropertyName = "Discord Messages")]
            public DiscordMessages discordMessages { get; set; }
            [JsonProperty(PropertyName = "UI Notify")]
            public UINotify uiNotify { get; set; }
            [JsonProperty(PropertyName = "Alerts")]
            public Alerts alerts { get; set; }
            [JsonProperty(PropertyName = "Location")]
            public Location location { get; set; }
            [JsonProperty(PropertyName = "Misc")]
            public Misc misc { get; set; }
            [JsonProperty(PropertyName = "Logging")]
            public Logging logging { get; set; }

            public class Notifications
            {
                [JsonProperty(PropertyName = "Chat Notifications")]
                public bool chat { get; set; }
                [JsonProperty(PropertyName = "Popup Notifications")]
                public bool popup { get; set; }
            }

            public class DiscordMessages
            {
                [JsonProperty(PropertyName = "Enabled")]
                public bool enabled { get; set; }
                [JsonProperty(PropertyName = "Webhook URL")]
                public string webhookURL { get; set; }
                [JsonProperty(PropertyName = "Embedded Messages")]
                public bool embedded { get; set; }
                [JsonProperty(PropertyName = "Embed Color")]
                public int embedColor { get; set; }
                [JsonProperty(PropertyName = "Embed Title")]
                public string embedTitle { get; set; }
            }

            public class UINotify
            {
                [JsonProperty(PropertyName = "Enabled")]
                public bool enabled { get; set; }
                [JsonProperty(PropertyName = "Notification Type")]
                public int type { get; set; }
            }

            public class Alerts
            {
                [JsonProperty(PropertyName = "Patrol Helicopter Alerts")]
                public bool patrolHeli { get; set; }
                [JsonProperty(PropertyName = "Cargo Ship Alerts")]
                public bool cargoShip { get; set; }
                [JsonProperty(PropertyName = "Cargo Ship Harbor Alerts")]
                public bool cargoShipHarbor { get; set; }
                [JsonProperty(PropertyName = "Cargo Plane Alerts")]
                public bool cargoPlane { get; set; }
                [JsonProperty(PropertyName = "CH47 Chinook Alerts")]
                public bool ch47 { get; set; }
                [JsonProperty(PropertyName = "Bradley APC Alerts")]
                public bool bradleyAPC { get; set; }
                [JsonProperty(PropertyName = "Travelling Vendor Alerts")]
                public bool travellingVendor { get; set; }
                [JsonProperty(PropertyName = "Excavator Activated Alerts")]
                public bool excavator { get; set; }
                [JsonProperty(PropertyName = "Excavator Supply Request Alerts")]
                public bool excavatorSupply { get; set; }
                [JsonProperty(PropertyName = "Hackable Crate Alerts")]
                public bool hackableCrateSpawn { get; set; }
                [JsonProperty(PropertyName = "Player Hacking Crate Alerts")]
                public bool hackingCrate { get; set; }
                [JsonProperty(PropertyName = "Supply Signal Alerts")]
                public bool supplySignal { get; set; }
                [JsonProperty(PropertyName = "Supply Drop Alerts")]
                public bool supplyDrop { get; set; }
                [JsonProperty(PropertyName = "Supply Drop Landed Alerts")]
                public bool supplyDropLand { get; set; }
            }

            public class Location
            {
                [JsonProperty(PropertyName = "Show Grid")]
                public bool showGrid { get; set; }
                [JsonProperty(PropertyName = "Show 'Oil Rig' Labels")]
                public bool showOilRigs { get; set; }
                [JsonProperty(PropertyName = "Show 'Cargo Ship' Label")]
                public bool showCargoShip { get; set; }
                [JsonProperty(PropertyName = "Show 'Excavator' Label")]
                public bool showExcavator { get; set; }
                [JsonProperty(PropertyName = "Hide Unmarked Grids")]
                public bool hideOffGrid { get; set; }
                [JsonProperty(PropertyName = "Show Coordinates")]
                public bool showCoords { get; set; }
                [JsonProperty(PropertyName = "Hide Y Coordinate")]
                public bool hideYCoord { get; set; }
                [JsonProperty(PropertyName = "Hide Coordinate Decimals")]
                public bool hideCoordDecimals { get; set; }
            }

            public class Misc
            {
                [JsonProperty(PropertyName = "Chat Icon (SteamID64)")]
                public ulong chatIcon { get; set; }
                [JsonProperty(PropertyName = "Hide Cargo Ship Crate Messages")]
                public bool hideCargoCrates { get; set; }
                [JsonProperty(PropertyName = "Hide Oil Rig Crate & Chinook Messages")]
                public bool hideRigCrates { get; set; }
                [JsonProperty(PropertyName = "Show Supply Drop Player")]
                public bool showSupplyPlayer { get; set; }
                [JsonProperty(PropertyName = "Hide Player-Called Supply Drop Messages")]
                public bool hideCalledSupply { get; set; }
                [JsonProperty(PropertyName = "Hide Random Supply Drop Messages")]
                public bool hideRandomSupply { get; set; }
            }

            public class Logging
            {
                [JsonProperty(PropertyName = "Log To Console")]
                public bool console { get; set; }
                [JsonProperty(PropertyName = "Log To File")]
                public bool file { get; set; }
                [JsonProperty(PropertyName = "Log All Events")]
                public bool allEvents { get; set; }
            }

            [JsonProperty(PropertyName = "Version (Do not modify)")]
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null) throw new Exception();

                if (configData.Version < Version)
                    UpdateConfigValues();

                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                notifications = new ConfigData.Notifications
                {
                    chat = true,
                    popup = false
                },
                discordMessages = new ConfigData.DiscordMessages
                {
                    enabled = false,
                    webhookURL = string.Empty,
                    embedded = true,
                    embedColor = 3447003,
                    embedTitle = ":arrow_lower_right:  Inbound"
                },
                uiNotify = new ConfigData.UINotify
                {
                    enabled = false,
                    type = 0
                },
                alerts = new ConfigData.Alerts
                {
                    patrolHeli = true,
                    cargoShip = true,
                    cargoShipHarbor = true,
                    cargoPlane = true,
                    ch47 = true,
                    bradleyAPC = true,
                    travellingVendor = true,
                    excavator = true,
                    excavatorSupply = true,
                    hackableCrateSpawn = true,
                    hackingCrate = true,
                    supplySignal = true,
                    supplyDrop = true,
                    supplyDropLand = true
                },
                location = new ConfigData.Location
                {
                    showGrid = true,
                    showOilRigs = true,
                    showCargoShip = true,
                    showExcavator = true,
                    hideOffGrid = true,
                    showCoords = false,
                    hideYCoord = false,
                    hideCoordDecimals = false
                },
                misc = new ConfigData.Misc
                {
                    chatIcon = 0,
                    hideCargoCrates = false,
                    hideRigCrates = false,
                    showSupplyPlayer = false,
                    hideCalledSupply = false,
                    hideRandomSupply = false
                },
                logging = new ConfigData.Logging
                {
                    console = false,
                    file = false,
                    allEvents = false
                },
                Version = Version
            };
        }

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");
            ConfigData baseConfig = GetBaseConfig();
            if (configData.Version < new Core.VersionNumber(0, 6, 0))
            {
                configData = baseConfig;
                configData.notifications.chat = Convert.ToBoolean(GetConfig("Notifications (true/false)", "Chat Notifications", true));
                configData.notifications.popup = Convert.ToBoolean(GetConfig("Notifications (true/false)", "Popup Notifications", false));
                configData.discordMessages.enabled = Convert.ToBoolean(GetConfig("Discord Messages", "Enabled (true/false)", false));
                configData.discordMessages.webhookURL = Convert.ToString(GetConfig("Discord Messages", "Webhook URL", string.Empty));
                configData.alerts.bradleyAPC = Convert.ToBoolean(GetConfig("Alerts (true/false)", "Bradley APC Alerts", true));
                configData.alerts.cargoPlane = Convert.ToBoolean(GetConfig("Alerts (true/false)", "Cargo Plane Alerts", true));
                configData.alerts.cargoShip = Convert.ToBoolean(GetConfig("Alerts (true/false)", "Cargo Ship Alerts", true));
                configData.alerts.ch47 = Convert.ToBoolean(GetConfig("Alerts (true/false)", "CH47 Chinook Alerts", true));
                configData.alerts.excavator = Convert.ToBoolean(GetConfig("Alerts (true/false)", "Excavator Alerts", true));
                configData.alerts.hackableCrateSpawn = Convert.ToBoolean(GetConfig("Alerts (true/false)", "Hackable Crate Alerts", true));
                configData.alerts.patrolHeli = Convert.ToBoolean(GetConfig("Alerts (true/false)", "Patrol Helicopter Alerts", true));
                configData.alerts.hackingCrate = Convert.ToBoolean(GetConfig("Alerts (true/false)", "Player Hacking Crate Alerts", true));
                configData.alerts.supplySignal = Convert.ToBoolean(GetConfig("Alerts (true/false)", "Player Supply Signal Alerts", true));
                configData.alerts.supplyDrop = Convert.ToBoolean(GetConfig("Alerts (true/false)", "Supply Drop Alerts", true));
                configData.alerts.supplyDropLand = Convert.ToBoolean(GetConfig("Alerts (true/false)", "Supply Drop Landed Alerts", true));
                configData.location.showGrid = Convert.ToBoolean(GetConfig("Grid (true/false)", "Show Grid", true));
                configData.location.showOilRigs = Convert.ToBoolean(GetConfig("Grid (true/false)", "Show Oil Rig / Cargo Ship Labels", true));
                configData.location.showCargoShip = Convert.ToBoolean(GetConfig("Grid (true/false)", "Show Oil Rig / Cargo Ship Labels", true));
                configData.location.showCoords = Convert.ToBoolean(GetConfig("Coordinates (true/false)", "Show Coordinates", false));
                configData.misc.chatIcon = Convert.ToUInt64(GetConfig("Chat Icon", "Steam ID", 0));
                configData.misc.hideCargoCrates = Convert.ToBoolean(GetConfig("Misc (true/false)", "Hide Cargo Ship Crate Messages", false));
                configData.misc.hideRigCrates = Convert.ToBoolean(GetConfig("Misc (true/false)", "Hide Oil Rig Crate Messages", false));
                configData.logging.console = Convert.ToBoolean(GetConfig("Misc (true/false)", "Log To Console", false));
                configData.logging.file = Convert.ToBoolean(GetConfig("Misc (true/false)", "Log To File", false));

                BackupLang();
            }
            if (configData.Version < new Core.VersionNumber(0, 6, 5))
            {
                configData.alerts.cargoShipHarbor = baseConfig.alerts.cargoShipHarbor;
            }
            if (configData.Version < new Core.VersionNumber(0, 6, 7))
            {
                configData.alerts.travellingVendor = baseConfig.alerts.travellingVendor;
            }
            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        object GetConfig(string menu, string dataValue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
            }
            object value;
            if (!data.TryGetValue(dataValue, out value))
            {
                value = defaultValue;
                data[dataValue] = value;
            }
            return value;
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();
        protected override void SaveConfig() => Config.WriteObject(configData, true);
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PatrolHeli"] = "Patrol Helicopter inbound{0}{1}",
                ["CargoShip_"] = "Cargo Ship inbound{0}{1}",
                ["CargoShipApproachHarbor"] = "Cargo Ship is approaching the harbor{0}",
                ["CargoShipAtHarbor"] = "Cargo Ship has docked at the harbor{0}",
                ["CargoShipLeaveHarbor"] = "Cargo Ship is leaving the harbor{0}",
                ["CargoPlane_"] = "{0}Cargo Plane inbound{1}{2}",
                ["CH47"] = "Chinook inbound{0}{1}",
                ["BradleyAPC"] = "Bradley APC inbound{0}",
                ["TravellingVendor"] = "Travelling Vendor inbound{0}",
                ["Excavator_"] = "{0} has activated The Excavator{1}",
                ["ExcavatorSupplyRequest"] = "{0} has requested a supply drop{1}",
                ["HackableCrateSpawned"] = "Hackable Crate has spawned{0}",
                ["HackingCrate"] = "{0} is hacking a locked crate{1}",
                ["SupplySignal"] = "{0} has deployed a supply signal{1}",
                ["SupplyDropDropped"] = "{0}Supply Drop has dropped{1}",
                ["SupplyDropLanded_"] = "{0}Supply Drop has landed{1}",
                ["SupplyDropPlayer"] = "{0}'s ",
                ["Location"] = " at {0}",
                ["Destination"] = " and headed to {0}",
                ["DiscordMessage_"] = "{0}"
            }, this);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        void BackupLang()
        {
            PrintWarning("Backing up language file to /oxide/logs/Inbound");
            Dictionary<string, string> langFile = lang.GetMessages(lang.GetServerLanguage(), this);
            string langJson = JsonConvert.SerializeObject(langFile, Formatting.Indented);
            LogToFile($"lang_backup_{DateTime.Now.ToString("HH-mm-ss")}", langJson, this);
        }
        #endregion
    }
}

// --- End of file: Inbound.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/inventory-viewer ---
// --- Original File Path: I/InventoryViewer/InventoryViewer.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using ProtoBuf;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info("Inventory Viewer", "Whispers88", "4.1.2")]
    [Description("Allows players with permission assigned to view anyone's inventory")]
    public class InventoryViewer : CovalencePlugin
    {
        #region Init
        private static List<string> _registeredhooks = new List<string> { "OnLootEntityEnd", "CanMoveItem", "OnEntityDeath" };
        private const string permuse = "inventoryviewer.allowed";
        private const string permunlock = "inventoryviewer.unlock";
        private void OnServerInitialized()
        {
            permission.RegisterPermission(permuse, this);
            permission.RegisterPermission(permunlock, this);

            AddCovalenceCommand(new[] { "viewinv", "viewinventory", "inspect" }, "ViewInvCmd");

            UnSubscribeFromHooks();
        }

        private void Unload()
        {
            foreach (var a in _viewingtarget.Values.ToList())
            {
                if (a.corpse != null)
                    a.corpse.Kill();
                if (a.backpack != null)
                    a.backpack.Kill();
            }
        }

        #endregion Init

        #region Configuration
        private Configuration config;
        public class Configuration
        {
            [JsonProperty("View inventory raycast distance")]
            public float raycastdist = 10;

            [JsonProperty("View inventory timeout (seconds) set to 0 to disable")]
            public float timeout = 60;

            [JsonProperty("Use console logging")]
            public bool consolelogging = false;

            [JsonProperty("Use discord logging")]
            public bool discordlogging = false;

            [JsonProperty("Webhook URL")]
            public string discordwebhook = "";

            [JsonProperty("Discord name")]
            public string discordname = "Inventory Viewer";

            [JsonProperty("Discord avatar URL")]
            public string discordavatarurl = "https://i.imgur.com/BLoVcpz.png";

            [JsonProperty("View Backpack Button AnchorMin")]
            public string ImageAnchorMin = "0.175 0.017";

            [JsonProperty("View Backpack Button AnchorMax")]
            public string ImageAnchorMax = "0.22 0.08";
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPerms"] = "You don't have permissions to use this command",
                ["NoPlayersFound"] = "No players were found by the identifier of {0}",
                ["NoPlayersFoundRayCast"] = "No players were found",
                ["ViewingPLayer"] = "Viewing <color=orange>{0}'s</color> inventory"

            }, this);
        }

        #endregion Localization

        #region Commands
        private void ViewInvCmd(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, permuse))
            {
                ChatMessage(iplayer, GetLang("NoPerms"));
                return;
            }

            if (args.Length == 0 || string.IsNullOrEmpty(args[0]))
            {
                RaycastHit hitinfo;
                if (!Physics.Raycast(player.eyes.HeadRay(), out hitinfo, 3f, (int)Layers.Server.Players))
                {
                    ChatMessage(iplayer, "NoPlayersFoundRayCast");
                    return;
                }

                BasePlayer targetplayerhit = hitinfo.GetEntity().ToPlayer();
                if (targetplayerhit == null)
                {
                    ChatMessage(iplayer, "NoPlayersFoundRayCast");
                    return;
                }

                ChatMessage(iplayer, "ViewingPLayer", targetplayerhit.displayName);
                ViewInventory(player, targetplayerhit);

                return;
            }
            IPlayer target = FindPlayer(args[0]);
            if (target == null)
            {
                ChatMessage(iplayer, "NoPlayersFound", args[0]);
                return;
            }

            BasePlayer targetplayer = target.Object as BasePlayer;
            if (targetplayer == null)
            {
                ChatMessage(iplayer, "NoPlayersFound", args[0]);
                return;
            }

            ChatMessage(iplayer, "ViewingPLayer", targetplayer.displayName);
            ViewInventory(player, targetplayer);
        }

        #endregion Commands

        #region Methods
        private Dictionary<ulong, LootingData> _viewingtarget = new Dictionary<ulong, LootingData>();
        private void ViewInventory(BasePlayer player, BasePlayer targetplayer)
        {
            if (_viewingtarget.Count == 0)
                SubscribeToHooks();

            player.EndLooting();

            LootableCorpse corpse = GameManager.server.CreateEntity(StringPool.Get(2604534927), Vector3.zero) as LootableCorpse;
            if (config.timeout != 0)
                timer.Once(config.timeout, () => EndCorpseLooting(player, corpse));

            corpse.syncPosition = false;
            corpse.limitNetworking = true;
            corpse.playerName = $"{targetplayer.displayName} - ({targetplayer.userID})";
            corpse.playerSteamID = 0;
            corpse.enableSaving = false;
            corpse.Spawn();
            corpse.CancelInvoke(corpse.RemoveCorpse);
            corpse.SetFlag(BaseEntity.Flags.Locked, true);
            Buoyancy bouyancy;
            if (corpse.TryGetComponent<Buoyancy>(out bouyancy))
            {
                UnityEngine.Object.Destroy(bouyancy);
            }
            Rigidbody ridgidbody;
            if (corpse.TryGetComponent<Rigidbody>(out ridgidbody))
            {
                UnityEngine.Object.Destroy(ridgidbody);
            }
            corpse.SendAsSnapshot(player.Connection);

            timer.Once(0.3f, () =>
            {
                StartLooting(player, targetplayer, corpse);
            });
        }

        private void StartLooting(BasePlayer player, BasePlayer targetplayer, LootableCorpse corpse)
        {
            player.inventory.loot.AddContainer(targetplayer.inventory.containerMain);
            player.inventory.loot.AddContainer(targetplayer.inventory.containerWear);
            player.inventory.loot.AddContainer(targetplayer.inventory.containerBelt);
            player.inventory.loot.entitySource = corpse;
            player.inventory.loot.PositionChecks = false;
            player.inventory.loot.MarkDirty();
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer<string>(null, player, "RPC_OpenLootPanel", "player_corpse");

            if (_viewingtarget.TryGetValue(player.userID, out LootingData lootingData))
            {
                if (lootingData.targetPlayer != targetplayer)
                {
                    if (lootingData.corpse != null)
                        corpse.Kill();
                    if (lootingData.backpack != null)
                        lootingData.backpack.Kill();

                }
                _viewingtarget[player.userID] = new LootingData() { corpse = corpse, targetPlayer = targetplayer, backpack = null };
            }
            else
            {
                _viewingtarget.Add(player.userID, new LootingData() { corpse = corpse, targetPlayer = targetplayer });

            }
            if (config.consolelogging)
                LogWarning($"{player.displayName}({player.userID}) is viewing the inventory of {targetplayer.displayName}({targetplayer.userID})");
        }

        #endregion Methods

        #region Hooks

        private void OnLootEntityEnd(BasePlayer player, StorageContainer container)
        {
            if (_viewingtarget.TryGetValue(player.userID, out LootingData lootingData))
            {
                if (lootingData.backpack != null)
                {
                    lootingData.backpack.Kill();

                    lootingData.backpack = null;

                    timer.Once(0.3f, () =>
                    {
                        if (player != null && lootingData.targetPlayer != null && lootingData.corpse != null)
                            StartLooting(player, lootingData.targetPlayer, lootingData.corpse);
                    });
                    return;
                }

                if (lootingData.corpse != null)
                {
                    if (config.discordlogging)
                        player.StartCoroutine(LogToDiscord(player, lootingData.targetPlayer,
                            lootingData.corpse));

                    lootingData.corpse.Kill();

                    _viewingtarget.Remove(player.userID);
                }
            }

            LootableCorpse corpse = container.GetEntity() as LootableCorpse;

            if (_viewingtarget.Count == 0)
                UnSubscribeFromHooks();

        }

        private void EndCorpseLooting(BasePlayer player, LootableCorpse corpse)
        {
            if (corpse != null)
            {
                if (!_viewingtarget.TryGetValue(player.userID, out LootingData lootingData)) return;

                if (config.discordlogging)
                    player.StartCoroutine(LogToDiscord(player, lootingData.targetPlayer,
                        corpse));

                _viewingtarget.Remove(player.userID);

                if (corpse != null)
                    corpse.Kill();

            }

            if (_viewingtarget.Count == 0)
                UnSubscribeFromHooks();
        }

        private class LootingData
        {
            public LootableCorpse? corpse;
            public StorageContainer? backpack;
            public BasePlayer targetPlayer;
        }

        private Dictionary<LootableCorpse, List<Item>> _logtaken = new Dictionary<LootableCorpse, List<Item>>();
        private Dictionary<LootableCorpse, List<Item>> _loggiven = new Dictionary<LootableCorpse, List<Item>>();
        private object CanMoveItem(Item item, PlayerInventory playerInventory, ItemContainerId targetContainer, int targetSlot, int amount)
        {
            BasePlayer player = playerInventory.baseEntity;
            if (player == null) return null;

            if (!_viewingtarget.TryGetValue(player.userID, out LootingData lootingData))
                return null;

            if (lootingData.backpack == null)
            {

                if (item.IsBackpack() && item.contents != null && item.contents?.itemList.Count > 0)
                {
                    ViewBackpack(player, item);
                    return false;
                }
            }

            LootableCorpse corpse = lootingData.corpse;

            if (corpse.HasFlag(BaseEntity.Flags.Locked) && !HasPerm(player.UserIDString, permunlock)) return false;
            if (config.discordlogging)
            {
                ItemContainer targetcon;
                if (targetContainer.Value == 0)
                {
                    List<Item> takenlist;
                    if (_logtaken.TryGetValue(corpse, out takenlist))
                    {
                        takenlist.Add(item);
                    }
                    else
                    {
                        _logtaken[corpse] = new List<Item>() { item };
                    }
                    return null;
                }
                targetcon = player.inventory.FindContainer(targetContainer);
                if (targetcon.GetOwnerPlayer() == player && item.parent.playerOwner != player)
                {
                    List<Item> takenlist;
                    if (_logtaken.TryGetValue(corpse, out takenlist))
                    {
                        takenlist.Add(item);
                    }
                    else
                    {
                        _logtaken[corpse] = new List<Item>() { item };
                    }
                    Item targetitem = targetcon.GetSlot(targetSlot);
                    if (targetitem != null)
                    {
                        List<Item> givenlist;
                        if (_loggiven.TryGetValue(corpse, out givenlist))
                        {
                            givenlist.Add(targetitem);
                        }
                        else
                        {
                            _loggiven[corpse] = new List<Item>() { targetitem };
                        }
                    }
                }
                else
                {
                    if (item.parent.playerOwner == player)
                    {
                        List<Item> givenlist;
                        if (_loggiven.TryGetValue(corpse, out givenlist))
                        {
                            givenlist.Add(item);
                        }
                        else
                        {
                            _loggiven[corpse] = new List<Item>() { item };
                        }
                        Item targetitem = targetcon.GetSlot(targetSlot);
                        if (targetitem != null)
                        {
                            List<Item> takenlist;
                            if (_logtaken.TryGetValue(corpse, out takenlist))
                            {
                                takenlist.Add(targetitem);
                            }
                            else
                            {
                                _logtaken[corpse] = new List<Item>() { targetitem };
                            }
                        }
                    }
                }
            }
            return null;
        }


        private static string _coffinPrefab = "assets/prefabs/misc/halloween/coffin/coffinstorage.prefab";

        private void ViewBackpack(BasePlayer player, Item targetItem)
        {
            if (!_viewingtarget.TryGetValue(player.userID, out LootingData lootingData)) return;

            StorageContainer storage = GameManager.server.CreateEntity(_coffinPrefab, Vector3.zero) as StorageContainer;

            storage.syncPosition = false;
            storage.limitNetworking = true;
            storage.enableSaving = false;

            storage.Spawn();

            storage.inventory.playerOwner = player;

            if (storage.TryGetComponent<DestroyOnGroundMissing>(out DestroyOnGroundMissing groundMissing))
            {
                UnityEngine.Object.Destroy(groundMissing);
            }

            if (storage.TryGetComponent<GroundWatch>(out GroundWatch ridgidbody))
            {
                UnityEngine.Object.Destroy(ridgidbody);
            }

            _viewingtarget[player.userID].backpack = storage;

            timer.Once(0.1f, () =>
            {

                player.inventory.loot.Clear();
                player.inventory.loot.AddContainer(targetItem.contents);
                player.inventory.loot.entitySource = storage;
                player.inventory.loot.PositionChecks = false;
                player.inventory.loot.MarkDirty();
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer<string>(null, player, "RPC_OpenLootPanel", "generic_resizable");

                if (config.consolelogging)
                    LogWarning(
                        $"{player.displayName}({player.userID}) is viewing the backpack of {targetItem.parent.playerOwner.displayName}({targetItem.parent.playerOwner.displayName})");
            });

        }


        #endregion Hooks

        #region Helpers

        private IPlayer FindPlayer(string nameOrId)
        {
            IPlayer[] foundPlayers = players.FindPlayers(nameOrId).Where(p => p.IsConnected).ToArray();
            if (foundPlayers.Length > 1)
            {
                return null;
            }
            IPlayer target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target == null || !target.IsConnected)
            {
                return null;
            }
            return target;
        }

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private string GetLang(string langKey, string playerId = null, params object[] args) => string.Format(lang.GetMessage(langKey, this, playerId), args);
        private void ChatMessage(IPlayer player, string langKey, params object[] args)
        {
            if (player.IsConnected) player.Message(GetLang(langKey, player.Id, args));
        }

        private void UnSubscribeFromHooks()
        {
            foreach (var hook in _registeredhooks)
                Unsubscribe(hook);
        }

        private void SubscribeToHooks()
        {
            foreach (var hook in _registeredhooks)
                Subscribe(hook);
        }
        #endregion Helpers

        #region Public Helpers
        public void _ViewInventory(BasePlayer basePlayer, BasePlayer targetPlayer)
        {
            if (!HasPerm(basePlayer.UserIDString, permuse)) return;
            ViewInventory(basePlayer, targetPlayer);
        }
        #endregion

        #region Old Methods
        private void ViewInventoryCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player.UserIDString, permuse)) return;
            IPlayer target = FindPlayer(args[0]);
            if (target == null)
            {
                ChatMessage(player.IPlayer, "NoPlayersFound", args[0]);
                return;
            }
            BasePlayer targetplayer = target.Object as BasePlayer;
            ViewInventory(player, targetplayer);
        }
        #endregion Old Methods

        #region Discord

        private IEnumerator LogToDiscord(BasePlayer viewer, BasePlayer viewing, LootableCorpse corpse)
        {
            var msg = DiscordMessage(viewer, viewing, corpse);
            string jsonmsg = JsonConvert.SerializeObject(msg);
            UnityWebRequest wwwpost = new UnityWebRequest(config.discordwebhook, "POST");
            byte[] jsonToSend = new System.Text.UTF8Encoding().GetBytes(jsonmsg.ToString());
            wwwpost.uploadHandler = (UploadHandler)new UploadHandlerRaw(jsonToSend);
            wwwpost.SetRequestHeader("Content-Type", "application/json");
            yield return wwwpost.SendWebRequest();

            if (wwwpost.isNetworkError || wwwpost.isHttpError)
            {
                LogWarning(wwwpost.error);
                yield break;
            }
            wwwpost.Dispose();
        }

        private Message DiscordMessage(BasePlayer viewer, BasePlayer viewing, LootableCorpse corpse)
        {
            var fields = new List<Message.Fields>()
                    {
                        new Message.Fields("Viewer: ", $"{viewer.displayName}({viewer.userID})", true),
                        new Message.Fields("Viewing: ", $"{viewing.displayName}({viewing.userID})", true),
                    };
            string given = "";
            List<Item> givenlist;
            if (_loggiven.TryGetValue(corpse, out givenlist))
            {
                foreach (var i in givenlist)
                {
                    given += $"{i.amount} x {i.info.name}, ";
                }
                fields.Add(new Message.Fields("Items given: ", $"{given}", false));
                _loggiven.Remove(corpse);
            }
            string taken = "";
            List<Item> takenlist;
            if (_logtaken.TryGetValue(corpse, out takenlist))
            {
                foreach (var j in takenlist)
                {
                    taken += $"{j.amount} x {j.info.name}, ";
                }
                fields.Add(new Message.Fields("Items taken: ", $"{taken}", false));
                _logtaken.Remove(corpse);
            }
            var footer = new Message.Footer($"Logged @{DateTime.UtcNow:dd/MM/yy HH:mm:ss}");
            var embeds = new List<Message.Embeds>()
                    {
                        new Message.Embeds("Server - " + ConVar.Server.hostname, "Inventory viewer log" , fields, footer)
                    };
            Message msg = new Message(config.discordname, config.discordavatarurl, embeds);
            return msg;
        }

        public class Message
        {
            public string username { get; set; }
            public string avatar_url { get; set; }
            public List<Embeds> embeds { get; set; }

            public class Fields
            {
                public string name { get; set; }
                public string value { get; set; }
                public bool inline { get; set; }
                public Fields(string name, string value, bool inline)
                {
                    this.name = name;
                    this.value = value;
                    this.inline = inline;
                }
            }

            public class Footer
            {
                public string text { get; set; }
                public Footer(string text)
                {
                    this.text = text;
                }
            }

            public class Embeds
            {
                public string title { get; set; }
                public string description { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Embeds(string title, string description, List<Fields> fields, Footer footer)
                {
                    this.title = title;
                    this.description = description;
                    this.fields = fields;
                    this.footer = footer;
                }
            }

            public Message(string username, string avatar_url, List<Embeds> embeds)
            {
                this.username = username;
                this.avatar_url = avatar_url;
                this.embeds = embeds;
            }
        }

        #endregion Discord
    }
}

// --- End of file: InventoryViewer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-skin-randomizer ---
// --- Original File Path: I/ItemSkinRandomizer/ItemSkinRandomizer.cs ---

using System.Collections.Generic;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust.Workshop;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Item Skin Randomizer", "Mevent", "1.6.3")]
	[Description("Simple plugin that will select a random skin for an item when crafting")]
	public class ItemSkinRandomizer : RustPlugin
	{
		#region Fields

		private const string permUse = "itemskinrandomizer.use";

		private const string permUseEntities = "itemskinrandomizer.useentities";

		private const string permReSkin = "itemskinrandomizer.reskin";

		private Dictionary<string, List<ulong>> skins = new Dictionary<string, List<ulong>>();

		#endregion

		#region Config

		private static ConfigData _config = new ConfigData();

		private class ConfigData
		{
			[JsonProperty("Commands")] public string[] Commands =
			{
				"reskin",
				"rskin",
				"randomskin"
			};

			[JsonProperty("Blocked skin id's")] public ulong[] BlockedSkins =
			{
				12,
				345,
				6789
			};

			[JsonProperty("Blocked items")] public string[] BlockedItems =
			{
				"grenade.f1",
				"explosive.satchel"
			};

			[JsonProperty("Set random skins for entities?")]
			public bool UseEntities = true;

			[JsonProperty("Blocked entities")] public string[] BlockedEntities =
			{
				"grenade.f1",
				"explosive.satchel"
			};
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();

			try
			{
				_config = Config.ReadObject<ConfigData>();
				if (_config == null) LoadDefaultConfig();
			}
			catch
			{
				for (var i = 0; i < 3; i++)
					PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");

				LoadDefaultConfig();
				return;
			}

			ValidateConfig();
			SaveConfig();
		}

		private void ValidateConfig()
		{
			if (Interface.Oxide.CallHook("Debug_UseDefaultValues") != null)
			{
				PrintWarning("Using default configuration in debug mode");
				_config = new ConfigData();
			}
		}

		protected override void LoadDefaultConfig()
		{
			_config = new ConfigData();
		}

		protected override void SaveConfig()
		{
			Config.WriteObject(_config);
		}

		#endregion

		#region Hooks

		private void Init()
		{
			RegisterPermissions();

			RegisterCommands();

			if (!_config.UseEntities)
				Unsubscribe(nameof(OnEntitySpawned));
		}

		private void OnServerInitialized()
		{
			GenerateSkins();
		}

		private void Unload()
		{
			_config = null;
		}

		private void OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter crafter)
		{
			if (task == null || task.skinID != 0 ||
			    item?.info == null ||
			    crafter == null || crafter.owner == null ||
			    !permission.UserHasPermission(crafter.owner.UserIDString, permUse) ||
			    _config.BlockedItems.Contains(item.info.shortname)) return;

			SetRandomSkin(null, item);
		}

		private void OnEntitySpawned(BaseEntity entity)
		{
			if (entity == null || entity.OwnerID == 0 || entity.skinID != 0 ||
			    !permission.UserHasPermission(entity.OwnerID.ToString(), permUse) ||
			    _config.BlockedEntities.Contains(entity.ShortPrefabName)) return;

			SetRandomSkin(null, entity);
		}

		#endregion

		#region Commands

		private void CmdControl(IPlayer cov, string command, string[] args)
		{
			var player = cov?.Object as BasePlayer;
			if (player == null)
				return;

			if (!cov.HasPermission(permReSkin))
			{
				Message(player, Permission);
				return;
			}

			var item = player.GetActiveItem();
			if (item != null)
			{
				SetRandomSkin(player, item);
				return;
			}

			if (!player.CanBuild())
			{
				Message(player, CantBuild);
				return;
			}

			var entity = GetLookEntity<BaseEntity>(player);
			if (entity != null)
			{
				SetRandomSkin(player, entity);
				return;
			}

			Message(player, NoObject);
		}

		#endregion

		#region Utils

		private void RegisterCommands()
		{
			AddCovalenceCommand(_config.Commands, nameof(CmdControl));
		}

		private void RegisterPermissions()
		{
			permission.RegisterPermission(permUse, this);

			permission.RegisterPermission(permUseEntities, this);

			permission.RegisterPermission(permReSkin, this);
		}

		private static string FixNames(string name)
		{
			switch (name)
			{
				case "wall.external.high.wood": return "wall.external.high";
				case "electric.windmill.small": return "generator.wind.scrap";
				case "graveyardfence": return "wall.graveyard.fence";
				case "coffinstorage": return "coffin.storage";
			}

			return name;
		}

		private void GenerateSkins()
		{
			foreach (var pair in Approved.All)
			{
				if (pair.Value == null || pair.Value.Skinnable == null)
					continue;

				var skinId = pair.Value.WorkshopdId;
				if (skinId == 0 || _config.BlockedSkins.Contains(skinId))
					continue;

				var key = pair.Value.Skinnable.ItemName;
				if (key.Contains("lr300"))
					key = "rifle.lr300";

				List<ulong> list;
				if (skins.TryGetValue(key, out list))
				{
					if (!list.Contains(skinId))
						skins[key].Add(skinId);
				}
				else
				{
					skins.Add(key, new List<ulong>());
				}
			}
		}

		private void SetRandomSkin(BasePlayer player, Item item)
		{
			var skin = GetRandomSkin(item.info.shortname);
			if (skin == 0) return;

			item.skin = skin;
			item.MarkDirty();

			var held = item.GetHeldEntity();
			if (held != null)
			{
				held.skinID = skin;
				held.SendNetworkUpdate();
			}

			Message(player, ChangedTo, skin);
		}

		private void SetRandomSkin(BasePlayer player, BaseEntity entity)
		{
			var shortname = entity.ShortPrefabName;

			switch (shortname)
			{
				case "sleepingbag_leather_deployed":
					shortname = "sleepingbag";
					break;

				case "vendingmachine.deployed":
					shortname = "vending.machine";
					break;

				case "woodbox_deployed":
					shortname = "box.wooden";
					break;

				case "reactivetarget_deployed":
					shortname = "target.reactive";
					break;

				default:
				{
					shortname = entity.ShortPrefabName;
					shortname = Regex.Replace(shortname, "\\.deployed|_deployed", "");
					shortname = FixNames(shortname);
					break;
				}
			}

			var def = ItemManager.FindItemDefinition(shortname);
			if (def == null) return;

			var skin = GetRandomSkin(def.shortname);
			if (skin == 0) return;

			entity.skinID = skin;
			entity.SendNetworkUpdate();

			Message(player, ChangedTo, skin);
		}

		private ulong GetRandomSkin(string key)
		{
			List<ulong> list;
			return skins.TryGetValue(key, out list) ? list.GetRandom() : 0;
		}

		private static T GetLookEntity<T>(BasePlayer player)
		{
			RaycastHit hit;
			if (!Physics.Raycast(player.eyes.HeadRay(), out hit)) return default(T);

			var entity = hit.GetEntity();
			return entity == null ? default(T) : entity.GetComponent<T>();
		}

		#endregion

		#region Lang

		private const string
			CantBuild = "Cant Build",
			ChangedTo = "Changed To",
			NoObject = "No Object",
			Permission = "Permission";

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				[Permission] = "You don't have permission to use that!",
				[NoObject] = "You need to hold item or look on object!",
				[ChangedTo] = "Skin was changed to {0}",
				[CantBuild] = "You need building privilege to use that!"
			}, this);
		}

		private void Message(BasePlayer player, string messageKey, params object[] args)
		{
			if (player == null) return;

			player.ChatMessage(GetMessage(messageKey, player.UserIDString, args));
		}

		private string GetMessage(string messageKey, string playerID, params object[] args)
		{
			return string.Format(lang.GetMessage(messageKey, this, playerID), args);
		}

		#endregion
	}
}

// --- End of file: ItemSkinRandomizer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-h2o ---
// --- Original File Path: I/InstantH2O/InstantH2O.cs ---

using System.Collections.Generic;
using System.Linq;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Instant H2O", "Lincoln", "1.1.2")]
    [Description("Instantly fills water catchers upon placement")]
    public class InstantH2O : RustPlugin
    {
        private HashSet<ulong> playerList = new HashSet<ulong>(); // This will be cleared on reload
        private HashSet<ulong> persistentPlayerList = new HashSet<ulong>(); // This will be saved and loaded

        private Dictionary<WaterCatcher, Timer> timerDict = new Dictionary<WaterCatcher, Timer>();

        private const string permUse = "InstantH2O.use";
        private const string dataFileName = "InstantH2O_Data";

        private class PluginData
        {
            public HashSet<ulong> PersistentPlayerList { get; set; } = new HashSet<ulong>();
        }

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Enabled"] = "<color=#ffc34d>InstantH2O</color>: Instantly fill water catchers <color=#b0fa66>Enabled</color>.",
                ["Disabled"] = "<color=#ffc34d>InstantH2O</color>: Instantly fill water catchers <color=#ff6666>Disabled</color>.",
                ["noPerm"] = "<color=#ffc34d>InstantH2O</color>: You do not have permissions to use this.",
                ["Reload"] = "<color=#ffc34d>InstantH2O</color>: Instantly fill water catchers <color=#ff6666>disabled</color> due to a plugin reload.",
            }, this);
        }
        #endregion

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permUse, this);
            LoadData();
            RestoreWaterCatchers();
        }

        private bool HasPermission(BasePlayer player) => permission.UserHasPermission(player.UserIDString, permUse);

        [ChatCommand("h2o")]
        private void H2OCMD(BasePlayer player, string command, string[] args)
        {
            if (player == null || !HasPermission(player))
            {
                player?.ChatMessage(lang.GetMessage("noPerm", this, player.UserIDString));
                return;
            }

            if (playerList.Contains(player.userID))
            {
                playerList.Remove(player.userID);
                persistentPlayerList.Remove(player.userID); // Update the persistent list as well
                player.ChatMessage(lang.GetMessage("Disabled", this, player.UserIDString));
            }
            else
            {
                playerList.Add(player.userID);
                persistentPlayerList.Add(player.userID); // Update the persistent list as well
                player.ChatMessage(lang.GetMessage("Enabled", this, player.UserIDString));
            }

            SaveData();
            UpdateWaterCatchers(player.userID);
        }

        private void UpdateWaterCatchers(ulong userId)
        {
            foreach (var entity in BaseNetworkable.serverEntities.OfType<WaterCatcher>().ToArray())
            {
                if (entity == null || entity.OwnerID == 0) continue;

                if (persistentPlayerList.Contains(entity.OwnerID))
                {
                    StartWaterCatcherTimer(entity);
                }
                else
                {
                    StopWaterCatcherTimer(entity);
                }
            }
        }
        private void StartWaterCatcherTimer(WaterCatcher entity)
        {
            entity.maxOutputFlow = 1000;

            if (timerDict.ContainsKey(entity))
            {
                return;
            }

            Timer newTimer = timer.Every(1.0f, () =>
            {
                if (entity == null || entity.inventory == null)
                {
                    StopWaterCatcherTimer(entity);
                    return;
                }

                // Check if inventory exists and has items
                if (entity.inventory.itemList != null && entity.inventory.itemList.Count > 0)
                {
                    var waterItem = entity.inventory.itemList[0];
                    int max = entity.inventory.maxStackSize;
                    int current = waterItem.amount;

                    if (current < max)
                    {
                        int delta = max - current;
                        entity.AddResource(delta);
                        entity.maxOutputFlow = 10000;
                        entity.SendNetworkUpdateImmediate();
                    }
                }
                else
                {
                    // Initialize water collection when inventory is empty
                    entity.AddResource(1);
                    entity.SendNetworkUpdateImmediate();
                }
            });

            timerDict.Add(entity, newTimer);
        }
        private void StopWaterCatcherTimer(WaterCatcher entity)
        {
            Timer existingTimer;
            if (timerDict.TryGetValue(entity, out existingTimer))
            {
                existingTimer.Destroy();
                timerDict.Remove(entity);
            }
        }

        private void OnEntitySpawned(WaterCatcher entity)
        {
            if (entity == null || entity.OwnerID == 0) return;

            if (persistentPlayerList.Contains(entity.OwnerID))
            {
                StartWaterCatcherTimer(entity);
            }
        }

        private void Unload()
        {
            playerList.Clear(); // Clear the current state list
            SaveData();
        }

        private void LoadData()
        {
            var storedData = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(dataFileName);
            persistentPlayerList = storedData.PersistentPlayerList ?? new HashSet<ulong>();
        }

        private void SaveData()
        {
            var storedData = new PluginData { PersistentPlayerList = persistentPlayerList };
            Interface.Oxide.DataFileSystem.WriteObject(dataFileName, storedData);
        }

        private void RestoreWaterCatchers()
        {
            foreach (var entity in BaseNetworkable.serverEntities.OfType<WaterCatcher>().ToArray())
            {
                if (entity == null || entity.OwnerID == 0) continue;

                if (persistentPlayerList.Contains(entity.OwnerID))
                {
                    StartWaterCatcherTimer(entity);
                }
            }
        }
    }
}


// --- End of file: InstantH2O.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-barricades ---
// --- Original File Path: I/InstantBarricades/InstantBarricades.cs ---

﻿using ConVar;
using JetBrains.Annotations;
using Oxide.Core;
using Oxide.Core.Libraries;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("InstantBarricades", "4yzhen", "1.0.0")]
    [Description("A Simple Light Weight plugin to destroy wooden barricades in Supermarkets. etc")]
    public class InstantBarricades : RustPlugin
    {
        private void OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            if (entity.ShortPrefabName.Contains("door_barricade_"))
            {
                entity.Kill();
            }
        }
    }
}


// --- End of file: InstantBarricades.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-startup ---
// --- Original File Path: I/InstantStartup/InstantStartup.cs ---

﻿namespace Oxide.Plugins
{
    [Info("Instant Startup", "Kaysharp/patched by chrome", "1.0.3")]
    [Description("Instant engine Startup for Minicopter and Scrap Transport Helicopter")]
    public class InstantStartup : RustPlugin
    {
        private string permissionuse = "Instantstartup.use";
        private void Init()
        {
            permission.RegisterPermission(permissionuse, this);
        }
        private void OnEngineStarted(BaseMountable entity, BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionuse)) return;
            var vehicle = player.GetMountedVehicle();
            if (vehicle == null) return;
            if (vehicle is Minicopter)
            {
                var Heli = vehicle as Minicopter;
                if (Heli == null) return;
                Heli.engineController.FinishStartingEngine();
            }
        }
    }
}

// --- End of file: InstantStartup.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-craft ---
// --- Original File Path: I/InstantCraft/InstantCraft.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Oxide.Core;
using UnityEngine;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Instant Craft", "Vlad-0003 / Orange / rostov114", "2.2.8")]
    [Description("Allows players to instantly craft items with features")]
    public class InstantCraft : RustPlugin
    {
        #region Vars
        private const string permUse = "instantcraft.use";
        private const string permNormal = "instantcraft.normal";
        private readonly object True = true;
        private readonly object False = false;
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permNormal, this);

            _config.Init(this);

            if (!_config.HasAnyBlockedItems)
            {
                Unsubscribe(nameof(CanCraft));
            }
        }

        private object CanCraft(ItemCrafter itemCrafter, ItemBlueprint blueprint, int amount, bool free)
        {
            if (_config.IsBlocked(blueprint.targetItem))
            {
                Message(itemCrafter.baseEntity, "Blocked");
                return False;
            }

            return null;
        }

        private object OnItemCraft(ItemCraftTask task, BasePlayer owner)
        {
            if (task.cancelled)
            {
                return null;
            }

            if (permission.UserHasPermission(owner.UserIDString, permNormal) || !permission.UserHasPermission(owner.UserIDString, permUse))
            {
                return null;
            }

            List<int> stacks = GetStacks(task.blueprint.targetItem, task.amount * task.blueprint.amountToCreate);
            int slots = FreeSlots(owner);
            if (!HasPlace(slots, stacks))
            {
                CancelTask(task, owner, "Slots", stacks.Count, slots);
                return False;
            }

            if (_config.IsNormal(task.blueprint.targetItem))
            {
                Message(owner, "Normal");
                return null;
            }

            if (!GiveItem(task, owner, stacks))
            {
                return null;
            }

            return True;
        }
        #endregion

        #region API

        [HookMethod(nameof(API_IsItemBlocked))]
        public bool API_IsItemBlocked(ItemDefinition itemDefinition)
        {
            return _config.IsBlocked(itemDefinition);
        }

        [HookMethod(nameof(API_GetIsItemBlockedCallback))]
        public Func<ItemDefinition, bool> API_GetIsItemBlockedCallback()
        {
            return itemDefinition => _config.IsBlocked(itemDefinition);
        }

        #endregion

        #region Helpers
        public void CancelTask(ItemCraftTask task, BasePlayer owner, string reason, params object[] args)
        {
            task.cancelled = true;
            Message(owner, reason, args);
            GiveRefund(task, owner);
            Interface.CallHook("OnItemCraftCancelled", task, owner.inventory.crafting);
        }

        public void GiveRefund(ItemCraftTask task, BasePlayer owner)
        {
            if (task.takenItems != null && task.takenItems.Count > 0)
            {
                foreach (var item in task.takenItems)
                {
                    owner.inventory.GiveItem(item, null);
                }
            }
        }

        public bool GiveItem(ItemCraftTask task, BasePlayer owner, List<int> stacks)
        {
            ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
            int iteration = 0;

            if (_config.split)
            {
                foreach (var stack in stacks)
                {
                    if (!Give(task, owner, stack, skin) && iteration <= 0)
                    {
                        return false;
                    }

                    iteration++;
                }
            }
            else
            {
                int final = 0;
                foreach (var stack in stacks)
                {
                    final += stack;
                }

                if (!Give(task, owner, final, skin))
                {
                    return false;
                }
            }

            task.cancelled = true;
            return true;
        }

        public bool Give(ItemCraftTask task, BasePlayer owner, int amount, ulong skin)
        {
            Item item = null;
            try
            {
                item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, amount, skin);
            }
            catch (Exception e)
            {
                PrintError($"Exception creating item! targetItem: {task.blueprint.targetItem}-{amount}-{skin}; Exception: {e}");
            }

            if (item == null)
            {
                return false;
            }

            if (item.hasCondition && task.conditionScale != 1f)
            {
                item.maxCondition *= task.conditionScale;
                item.condition = item.maxCondition;
            }

            item.OnVirginSpawn(owner);
            item.SetItemOwnership(owner, ItemOwnershipPhrases.CraftedPhrase);

            if (task.instanceData != null)
            {
                item.instanceData = task.instanceData;
            }

            Interface.CallHook("OnItemCraftFinished", task, item, owner.inventory.crafting);

            if (owner.inventory.GiveItem(item))
            {
                owner.Command("note.inv", new object[]{item.info.itemid, amount});
                return true;
            }

            ItemContainer itemContainer = owner.inventory.crafting.containers.First<ItemContainer>();
            owner.Command("note.inv", new object[]{item.info.itemid, item.amount});
            owner.Command("note.inv", new object[]{item.info.itemid, -item.amount});
            item.Drop(itemContainer.dropPosition, itemContainer.dropVelocity, default(Quaternion));

            return true;
        }

        public int FreeSlots(BasePlayer player)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            var taken = player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count;
            return slots - taken;
        }

        public List<int> GetStacks(ItemDefinition item, int amount)
        {
            var list = new List<int>();
            var maxStack = item.stackable;

            if (maxStack == 0)
            {
                maxStack = 1;
            }

            while (amount > maxStack)
            {
                amount -= maxStack;
                list.Add(maxStack);
            }

            list.Add(amount);

            return list; 
        }

        public bool HasPlace(int slots, List<int> stacks)
        {
            if (!_config.checkPlace)
            {
                return true;
            }

            if (_config.split && slots - stacks.Count < 0)
            {
                return false;
            }

            return slots > 0;
        }
        #endregion

        #region Localization 1.1.1
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Blocked", "Crafting of that item is blocked!"},
                {"Slots", "You don't have enough place to craft! Need {0}, have {1}!"},
                {"Normal", "Item will be crafted with normal speed."}
            }, this, "en");
        }

        public void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.ChatMessage(message);
        }

        public string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }
        #endregion

        #region Configuration 1.1.0
        private Configuration _config;
        private class Configuration
        {
            [JsonProperty(PropertyName = "Check for free place")]
            public bool checkPlace = true;

            [JsonProperty(PropertyName = "Split crafted stacks")]
            public bool split = true;

            [JsonProperty(PropertyName = "Normal Speed")]
            private string[] normal =
            {
                "hammer",
                "put item shortname here"
            };

            [JsonProperty(PropertyName = "Blacklist")]
            private string[] blocked =
            {
                "rock",
                "put item shortname here"
            };

            private HashSet<int> _normalCraftItemIds = new HashSet<int>();
            private HashSet<int> _blockedItemIds = new HashSet<int>();

            [JsonIgnore]
            public bool HasAnyBlockedItems => _blockedItemIds.Count > 0;

            public void Init(InstantCraft plugin)
            {
                ValidateItemShortNames(plugin, normal, _normalCraftItemIds);
                ValidateItemShortNames(plugin, blocked, _blockedItemIds);
            }

            public bool IsNormal(ItemDefinition itemDefinition) => _normalCraftItemIds.Contains(itemDefinition.itemid);
            public bool IsBlocked(ItemDefinition itemDefinition) => _blockedItemIds.Contains(itemDefinition.itemid);

            private void ValidateItemShortNames(InstantCraft plugin, string[] itemShortNameList, HashSet<int> validItemIdList)
            {
                foreach (var itemShortName in itemShortNameList)
                {
                    if (itemShortName == "put item shortname here")
                        return;

                    var itemDefinition = ItemManager.FindItemDefinition(itemShortName);
                    if (itemDefinition == null)
                    {
                        plugin.PrintError($"Invalid item short name in config: {itemShortName}");
                        continue;
                    }

                    validItemIdList.Add(itemDefinition.itemid);
                }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<Configuration>();
                SaveConfig();
            }
            catch
            {
                PrintError("Error reading config, please check!");

                Unsubscribe(nameof(OnItemCraft));
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion
    }
}

// --- End of file: InstantCraft.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ingame-clock-gui ---
// --- Original File Path: I/IngameClockGUI/IngameClockGUI.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
	[Info("Ingame Clock GUI", "deer_SWAG", "0.0.7", ResourceId = 1245)]
	[Description("Displays ingame and server time")]
	public class IngameClockGUI : RustPlugin
	{
		const string databaseName = "IngameClockGUI";
		const int isClockEnabled = 1 << 0;
		const int isServerTime = 1 << 1;
		const string defaultInfoSize = "0.3";

		class Data
		{
			public HashSet<Player> Players = new HashSet<Player>();

			public Data() {}
		}

		class Player
		{
			public ulong userID;
			public short options;

			public Player() {}
			public Player(ulong id, short o)
			{
				userID = id;
				options = o;
			}
		}

		private class TimedInfo
		{
			public DateTime startTime;
			public DateTime endTime;
			public string text;
			public bool serverTime;
			public string size;

			public TimedInfo(DateTime st, DateTime et, string txt, bool server, string s)
			{
				startTime = st;
				endTime = et;
				text = txt;
				serverTime = server;
				size = s;
			}
		}

		private string clockJson = @"
		[{
			""name"":   ""Clock"",
			""parent"": ""Overlay"",
			""components"":
			[
				{
					""type"":	   ""UnityEngine.UI.Button"",
					""color"":	   ""%background%"",
					""imagetype"": ""Tiled""
				},
				{
					""type"":	   ""RectTransform"",
					""anchormin"": ""%left% %bottom%"",
					""anchormax"": ""%right% %top%""
				}
			]
		},
		{
			""parent"": ""Clock"",
			""components"":
			[
				{
					""type"":	  ""UnityEngine.UI.Text"",
					""text"":	  ""%prefix%%time%%postfix%"",
					""fontSize"": %size%,
					""color"":    ""%color%"",
					""align"":    ""MiddleCenter""
				},
				{
					""type"":	   ""RectTransform"",
					""anchormin"": ""0 0"",
					""anchormax"": ""1 0.9""
				}
			]
		}]";

		private string infoJson = @"
		[{
			""name"":   ""ClockInfo"",
			""parent"": ""Overlay"",
			""components"":
			[
				{
					""type"":	   ""UnityEngine.UI.Button"",
					""color"":	   ""%background%"",
					""imagetype"": ""Tiled""
				},
				{
					""type"":	   ""RectTransform"",
					""anchormin"": ""%info_left% %bottom%"",
					""anchormax"": ""%info_right% %top%""
				}
			]
		},
		{
			""parent"": ""ClockInfo"",
			""components"":
			[
				{
					""type"":	  ""UnityEngine.UI.Text"",
					""text"":	  ""%info%"",
					""fontSize"": %size%,
					""color"":    ""%color%"",
					""align"":    ""MiddleCenter""
				},
				{
					""type"":	   ""RectTransform"",
					""anchormin"": ""0.01 0"",
					""anchormax"": ""0.99 1""
				}
			]
		}]";

		// -------------------- MAIN --------------------

		Data 		data;
		Timer 		updateTimer;
		TOD_Sky 	sky;
		DateTime 	dt;

		string   time = "";
		DateTime gameTime;
		DateTime serverTime;

		private TimedInfo 		currentTI;
		private List<TimedInfo> tiList;

		protected override void LoadDefaultConfig()
		{
			Config.Clear();

			CheckCreateConfig();

			SaveConfig();
			Puts("Default config was saved and loaded!");
		}

		void OnServerInitialized()
		{
			data = Interface.Oxide.DataFileSystem.ReadObject<Data>(databaseName);
			tiList = new List<TimedInfo>();
			currentTI = null;
			sky = TOD_Sky.Instance;

			CheckCreateConfig();

			double left   = (double)Config["Position", "Left"];
			double right  = (double)Config["Position", "Left"] + (double)Config["Size", "Width"];
			double bottom = (double)Config["Position", "Bottom"];
			double top    = (double)Config["Position", "Bottom"] + (double)Config["Size", "Height"];

			clockJson = clockJson.Replace("%background%", (string)Config["BackgroundColor"])
								 .Replace("%color%", (string)Config["TextColor"])
								 .Replace("%size%", Config["FontSize"].ToString())
								 .Replace("%left%", left.ToString())
								 .Replace("%right%", right.ToString())
								 .Replace("%bottom%", bottom.ToString())
								 .Replace("%top%", top.ToString())
								 .Replace("%prefix%", (string)Config["Prefix"])
								 .Replace("%postfix%", (string)Config["Postfix"]);

			// --- for timed notifications

			List<object> ti = (List<object>)Config["TimedInfo"];
			int size = ti.Count;

			for(int i = 0; i < size; i++)
			{
				string infoString = (string)ti[i];

				if(infoString.Length > 0)
					tiList.Add(GetTimedInfo(infoString));
			}

			double info_left = right + 0.002;

			infoJson = infoJson.Replace("%background%", (string)Config["BackgroundColor"])
							   .Replace("%color%", (string)Config["TextColor"])
							   .Replace("%size%", Config["FontSize"].ToString())
							   .Replace("%bottom%", bottom.ToString())
							   .Replace("%top%", top.ToString())
							   .Replace("%info_left%", info_left.ToString())
							   .Replace("%info_right%", defaultInfoSize);
			// ---

			UpdateTime();

			updateTimer = timer.Repeat((int)Config["UpdateTimeInSeconds"], 0, () => UpdateTime());
		}

		void Unload()
		{
			SaveData();
			DestroyGUI();
			DestroyInfo();
		}

		[ChatCommand("clock")]
		void cmdChat(BasePlayer player, string command, string[] args)
		{
			if(args.Length == 1)
			{
				if(args[0] == "server" || args[0] == "s")
				{
					if((bool)Config["PreventChangingTime"])
						PrintToChat(player, (string)Config["Messages", "PreventChangeEnabled"]);
					else
						if(data.Players.Count > 0)
						{
							foreach(Player p in data.Players)
							{
								if(p.userID == player.userID)
								{
									if(GetOption(p.options, isServerTime))
									{
										p.options &= ~isServerTime;
										PrintToChat(player, (string)Config["Messages", "STDisabled"]);
									}
									else
									{
										p.options += isServerTime;
										PrintToChat(player, (string)Config["Messages", "STEnabled"]);
									}

									break;
								}
							}
						}
						else
						{
							data.Players.Add(new Player(player.userID, isClockEnabled | isServerTime));
							PrintToChat(player, (string)Config["Messages", "STEnabled"]);
						}
				}
				else
				{
					PrintToChat(player, (string)Config["Messages", "Help"]);
				}
			}
			else
			{
				bool found = false;

				if(data.Players.Count > 0)
				{
					foreach(Player p in data.Players)
					{
						if(p.userID == player.userID)
						{
							found = true;

							if(GetOption(p.options, isClockEnabled))
							{
								p.options &= ~isClockEnabled;
								DestroyGUI();
								PrintToChat(player, (string)Config["Messages", "Disabled"]);
							}
							else
							{
								p.options += isClockEnabled;
								AddGUI();
								PrintToChat(player, (string)Config["Messages", "Enabled"]);
							}

							break;
						}
						else
						{
							found = false;
						}
					}

					if(!found)
					{
						data.Players.Add(new Player(player.userID, 0));
						DestroyGUI();
						PrintToChat(player, (string)Config["Messages", "Disabled"]);
					}
				}
				else
				{
					data.Players.Add(new Player(player.userID, 0));
					PrintToChat(player, (string)Config["Messages", "Disabled"]);
				}
			}
		}

		void AddGUI()
		{
			if(data?.Players?.Count > 0)
			{
				int size = BasePlayer.activePlayerList.Count;
				for(int i = 0; i < size; i++)
				{
					BasePlayer bp = BasePlayer.activePlayerList[i];
					bool found = false;

					foreach(Player p in data.Players)
					{
						if(p.userID == bp.userID)
						{
							found = true;

							if(GetOption(p.options, isClockEnabled))
							{
								if(!((bool)Config["PreventChangingTime"]))
									if(GetOption(p.options, isServerTime))
										dt = serverTime;
									else
										dt = gameTime;

								ShowTime();

								CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(bp.net.connection),	null, "AddUI", clockJson.Replace("%time%", time));
							}

							break;
						}
						else
						{
							found = false;
						}
					}

					if(!found)
					{
						if(!((bool)Config["PreventChangingTime"]))
							dt = gameTime;
						ShowTime();
						CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(bp.net.connection),	null, "AddUI", clockJson.Replace("%time%", time));
					}
				}
			}
			else
			{
				int size = BasePlayer.activePlayerList.Count;
				for(int i = 0; i < size; i++)
				{
					BasePlayer bp = BasePlayer.activePlayerList[i];
					if(!((bool)Config["PreventChangingTime"]))
						dt = gameTime;
					ShowTime();
					CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(bp.net.connection),	null, "AddUI", clockJson.Replace("%time%", time));
				}
			}
		}

		private void UpdateTime()
		{
			gameTime = sky.Cycle.DateTime;
			serverTime = DateTime.Now;

			if((bool)Config["PreventChangingTime"])
				if((bool)Config["ServerTime"])
					dt = serverTime;
				else
					dt = gameTime;

			DestroyGUI();
			AddGUI();
			UpdateInfo();
		}

		private void DestroyGUI()
		{
			int size = BasePlayer.activePlayerList.Count;
			for(int i = 0; i < size; i++)
			{
				BasePlayer bp = BasePlayer.activePlayerList[i];
				CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(bp.net.connection), null, "DestroyUI", "Clock");
			}
		}

		private void ShowTime()
		{
			if((int)Config["TimeFormat"] == 24)
				if((bool)Config["ShowSeconds"])
					time = dt.ToString("HH:mm:ss");
				else
					time = dt.ToString("HH:mm");
			else
				if((bool)Config["ShowSeconds"])
					time = dt.ToString("h:mm:ss tt");
				else
					time = dt.ToString("h:mm tt");
		}

		void ShowInfo(string text, string iSize)
		{
			int size = BasePlayer.activePlayerList.Count;
			for(int i = 0; i < size; i++)
				CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(BasePlayer.activePlayerList[i].net.connection),	null,  "AddUI", infoJson.Replace("%info%", text).Replace("%info_right%", iSize));
		}

		void UpdateInfo()
		{
			if(tiList.Count > 0)
			{
				DateTime g = DateTime.Parse(gameTime.ToString("HH:mm"));
				DateTime s = DateTime.Parse(serverTime.ToString("HH:mm"));

				if(currentTI == null)
				{
					for(int i = 0; i < tiList.Count; i++)
					{
						if(!tiList[i].serverTime)
						{
							if(g.Ticks > tiList[i].startTime.Ticks && g.Ticks < tiList[i].endTime.Ticks)
							{
								currentTI = tiList[i];
								ShowInfo(tiList[i].text, tiList[i].size);
							}
						}
						else
						{
							if(s.Ticks > tiList[i].startTime.Ticks && s.Ticks < tiList[i].endTime.Ticks)
							{
								currentTI = tiList[i];
								ShowInfo(tiList[i].text, tiList[i].size);
							}
						}
					}
				}
				else
				{
					if(!currentTI.serverTime)
					{
						if(g.Ticks > currentTI.endTime.Ticks)
						{
							currentTI = null;
							DestroyInfo();
						}
					}
					else
					{
						if(s.Ticks > currentTI.endTime.Ticks)
						{
							currentTI = null;
							DestroyInfo();
						}
					}
				}
			}
		}

		void DestroyInfo()
		{
			int size = BasePlayer.activePlayerList.Count;
			for(int i = 0; i < size; i++)
				CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(BasePlayer.activePlayerList[i].net.connection), null, "DestroyUI", "ClockInfo");
		}

		// -------------------- UTILS --------------------

		void SaveData()
		{
			Interface.Oxide.DataFileSystem.WriteObject(databaseName, data);
		}

		bool GetOption(int options, int option)
		{
			if((options & option) != 0)
				return true;
			else
				return false;
		}

		void SendHelpText(BasePlayer player)
		{
			PrintToChat(player, (string)Config["Messages", "Help"]);
		}

		private enum TIStates { Init, StartBracket, StartTime, FirstColon, SecondColon, Hyphen, EndTime, AfterBracket, Text, Size, SizeAfterDot };

		private TimedInfo GetTimedInfo(string source)
		{
			source = source.TrimStart();
			source = source.TrimEnd();

			TIStates currentState = TIStates.Init;

			string startTime = "", endTime = "", text = "", nSize = "";
			bool st = false; // Server time

			int size = source.Length;

			for(int i = 0; i < size; i++)
			{				
				switch(currentState)
				{
					case TIStates.Init:
						{
							if (source[i] == '[')
							{
								currentState = TIStates.StartTime;
							}
							else if(source[i] == 's' || source[i] == 'S')
							{
								st = true;
								i++;
								currentState = TIStates.StartTime;
							}
							break;
						}
					case TIStates.StartTime:
						{
							if (Char.IsDigit(source[i]))
							{
								startTime += source[i];
							}
							else if (source[i] == ':')
							{
								startTime += source[i];
								currentState = TIStates.FirstColon;
							}
							break;
						}
					case TIStates.FirstColon:
						{
							if (Char.IsDigit(source[i]))
							{
								startTime += source[i];
							}
							else if(source[i] == '-')
							{
								i--;
								currentState = TIStates.Hyphen;
							}
							break;
						}
					case TIStates.Hyphen:
						{
							if (Char.IsDigit(source[i]))
							{
								i--;
								currentState = TIStates.EndTime;
							}
							break;
						}
					case TIStates.EndTime:
						{
							if (Char.IsDigit(source[i]))
							{
								endTime += source[i];
							}
							else if (source[i] == ':')
							{
								endTime += source[i];
								currentState = TIStates.SecondColon;
							}
							break;
						}
					case TIStates.SecondColon:
						{
							if (Char.IsDigit(source[i]))
								endTime += source[i];
							else if(source[i] == ']')
								currentState = TIStates.AfterBracket;
							else if(source[i] == '-')
								currentState = TIStates.Size;
							break;
						}
					case TIStates.Size:
						{
							if(Char.IsDigit(source[i]))
							{
								nSize += source[i];
							}
							else if(source[i] == '.')
							{
								nSize += '.';
								currentState = TIStates.SizeAfterDot;
							}
							break;
						}
					case TIStates.SizeAfterDot:
						{
							if(Char.IsDigit(source[i]))
								nSize += source[i];
							else if(source[i] == ']')
								currentState = TIStates.AfterBracket;
							break;
						}
					case TIStates.AfterBracket:
						{
							if(source[i] != ' ')
								text += source[i];
							currentState = TIStates.Text;
							break;
						}
					case TIStates.Text:
						{
							text += source[i];
							break;
						}
				}
			}

			if(nSize.Length == 0)
				nSize = defaultInfoSize;

			return new TimedInfo(DateTime.Parse(startTime), DateTime.Parse(endTime), text, st, nSize);
		}

		// -------------------- DEFAULT CONFIG --------------------

		void CheckCreateConfig()
		{
			if(Config["UpdateTimeInSeconds"] == null)
				Config["UpdateTimeInSeconds"] = 2;

			if(Config["ShowSeconds"] == null)
				Config["ShowSeconds"] = false;

			if(Config["BackgroundColor"] == null)
				Config["BackgroundColor"] = "0.1 0.1 0.1 0.3";

			if(Config["TextColor"] == null)
				Config["TextColor"] = "1 1 1 0.3";

			if(Config["FontSize"] == null)
				Config["FontSize"] = 14;

			if(Config["Position", "Left"] == null)
				Config["Position", "Left"] = 0.01;

			if(Config["Position", "Bottom"] == null)
				Config["Position", "Bottom"] = 0.015;

			if(Config["Size", "Width"] == null)
				Config["Size", "Width"] = 0.05;

			if(Config["Size", "Height"] == null)
				Config["Size", "Height"] = 0.03;

			if(Config["ServerTime"] == null)
				Config["ServerTime"] = false;

			if(Config["PreventChangingTime"] == null)
				Config["PreventChangingTime"] = false;

			if(Config["TimeFormat"] == null)
				Config["TimeFormat"] = 24;

			if(Config["Prefix"] == null)
				Config["Prefix"] = "";

			if(Config["Postfix"] == null)
				Config["Postfix"] = "";

			if(Config["TimedInfo"] == null)
				Config["TimedInfo"] = new string[1] {""};

			if(Config["Messages", "Enabled"] == null)
				Config["Messages", "Enabled"] = "You have enabled clock";

			if(Config["Messages", "Disabled"] == null)
				Config["Messages", "Disabled"] = "You have disabled clock";

			if(Config["Messages", "STEnabled"] == null)
				Config["Messages", "STEnabled"] = "Now your clock shows server time";

			if(Config["Messages", "STDisabled"] == null)
				Config["Messages", "STDisabled"] = "Now your clock shows ingame time";

			if(Config["Messages", "Help"] == null)
				Config["Messages", "Help"] = "Clock:\n/clock - toggle clock\n/clock server - toggle server/ingame time";

			if(Config["Messages", "PreventChangeEnabled"] == null)
				Config["Messages", "PreventChangeEnabled"] = "You can't choose between server or ingame time";

			SaveConfig();
		}
	}
}

// --- End of file: IngameClockGUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ignore ---
// --- Original File Path: I/Ignore/Ignore.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Ignore", "MisterPixie", "2.1.03")]
    [Description("Just an ignore API.")]
    class Ignore : CovalencePlugin
    {
        private ConfigData configData;
        private Dictionary<string, PlayerData> IgnoreData;

        class ConfigData
        {
            public int IgnoreLimit { get; set; }
        }

        class PlayerData
        {
            public string Name { get; set; } = string.Empty;
            public HashSet<string> Ignores { get; set; } = new HashSet<string>();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                IgnoreLimit = 30
            };
            Config.WriteObject(config, true);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"List", "Ignored {0}:\n{1}"},
                {"NoIngored", "Your ignore list is empty."},
                {"NotOnIgnorelist", "{0} not found on your ignore list."},
                {"IgnoreRemoved", "{0} was removed from your ignore list."},
                {"PlayerNotFound", "Player '{0}' not found."},
                {"CantAddSelf", "You cant add yourself."},
                {"AlreadyOnList", "{0} is already ignored."},
                {"IgnoreAdded", "{0} is now ignored."},
                {"IgnorelistFull", "Your ignore list is full."},
                {"HelpText", "Use /ignore <add|+|remove|-|list> <name/steamID> to add/remove/list ignores"},
                {"Syntax", "Syntax: /ignore <add/+/remove/-> <name/steamID> or /ignore list"}
            }, this);
        }

        private void Init()
        {

            configData = Config.ReadObject<ConfigData>();
            try
            {
                IgnoreData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, PlayerData>>(Name);
            }
            catch
            {
                IgnoreData = new Dictionary<string, PlayerData>();
            }

            AddCovalenceCommand("ignore", "cmdIgnore");
        }

        private void SaveIgnores()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, IgnoreData);
        }

        private bool AddIgnore(string playerId, string ignoreId)
        {
            var playerData = GetPlayerData(playerId);
            if (playerData.Ignores.Count >= configData.IgnoreLimit || !playerData.Ignores.Add(ignoreId)) return false;
            SaveIgnores();
            return true;
        }

        private bool RemoveIgnore(string playerId, string ignoreId)
        {
            if (!GetPlayerData(playerId).Ignores.Remove(ignoreId)) return false;
            SaveIgnores();
            return true;
        }

        private bool HasIgnored(string playerId, string ignoreId)
        {
            return GetPlayerData(playerId).Ignores.Contains(ignoreId);
        }

        private bool AreIgnored(string playerId, string ignoreId)
        {
            return GetPlayerData(playerId).Ignores.Contains(ignoreId) && GetPlayerData(ignoreId).Ignores.Contains(playerId);
        }

        private bool IsIgnored(string playerId, string ignoreId)
        {
            return GetPlayerData(ignoreId).Ignores.Contains(playerId);
        }

        private string[] GetIgnoreList(string playerId)
        {
            var playerData = GetPlayerData(playerId);
            var players = new List<string>();
            foreach (var friend in playerData.Ignores)
                players.Add(GetPlayerData(friend).Name);
            return players.ToArray();
        }

        private string[] IsIgnoredBy(string player)
        {
            PlayerData value;
            var ignores = IgnoreData.TryGetValue(player, out value) ? value.Ignores.ToArray() : new string[0];
            return ignores.ToList().ConvertAll(f => f.ToString()).ToArray();
        }

        private PlayerData GetPlayerData(string playerId)
        {
            var player = FindPlayer(playerId);
            PlayerData playerData;
            if (!IgnoreData.TryGetValue(playerId, out playerData))
                IgnoreData[playerId] = playerData = new PlayerData();
            if (player != null) playerData.Name = player.Name;
            return playerData;
        }

        private void cmdIgnore(IPlayer player, string command, string[] args)
        {
            if (args == null || args.Length <= 0 || args.Length == 1 && !args[0].Equals("list", StringComparison.OrdinalIgnoreCase))
            {
                player.Reply(Lang("Syntax", player.Id));
                return;
            }
            switch (args[0].ToLower())
            {
                case "list":
                    var ignoreList = GetIgnoreList(player.Id);
                    if (ignoreList.Length > 0)
                        player.Reply(Lang("List", player.Id,$"{ignoreList.Length}/{configData.IgnoreLimit}", string.Join(", ", ignoreList)));
                    else
                        player.Reply(Lang("NoIngored", player.Id));
                    return;
                case "add":
                case "+":
                    var ignorePlayer = FindPlayer(args[1]);
                    if (ignorePlayer == null)
                    {
                        player.Reply(Lang("PlayerNotFound", player.Id, args[1]));
                        return;
                    }
                    if (player == ignorePlayer)
                    {
                        player.Reply(Lang("CantAddSelf", player.Id));
                        return;
                    }
                    var playerData = GetPlayerData(player.Id);
                    if (playerData.Ignores.Count >= configData.IgnoreLimit)
                    {
                        player.Reply(Lang("IgnorelistFull", player.Id));
                        return;
                    }
                    if (playerData.Ignores.Contains(ignorePlayer.Id))
                    {
                        player.Reply(Lang("AlreadyOnList",player.Id, ignorePlayer.Name));
                        return;
                    }
                    AddIgnore(player.Id, ignorePlayer.Id);
                    player.Reply(Lang("IgnoreAdded", player.Id, ignorePlayer.Name));
                    return;
                case "remove":
                case "-":
                    var ignore = FindIgnore(args[1]);
                    if (ignore == string.Empty)
                    {
                        player.Reply(Lang("NotOnIgnorelist", player.Id, args[1]));
                        return;
                    }
                    var removed = RemoveIgnore(player.Id, ignore);
                    player.Reply(Lang(removed ? "IgnoreRemoved" : "NotOnIgnorelist", player.Id, args[1]));
                    return;
            }
        }

        private void SendHelpText(IPlayer player)
        {
            player.Reply(Lang("HelpText", player.Id));
        }

        private string FindIgnore(string ignore)
        {
            if (string.IsNullOrEmpty(ignore)) return String.Empty;
            foreach (var playerData in IgnoreData)
            {
                if (playerData.Key.ToString().Equals(ignore) || playerData.Value.Name.Contains(ignore))
                    return playerData.Key;
            }
            return string.Empty;
        }

        private IPlayer FindPlayer(string nameOrIdOrIp)
        {
            foreach (var activePlayer in covalence.Players.Connected)
            {
                if (activePlayer.Id == nameOrIdOrIp)
                    return activePlayer;
                if (activePlayer.Name.Contains(nameOrIdOrIp))
                    return activePlayer;
                if (activePlayer.Address == nameOrIdOrIp)
                    return activePlayer;
            }
            return null;
        }

    }
}


// --- End of file: Ignore.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/indestructable-buildings ---
// --- Original File Path: I/IndestructableBuildings/IndestructableBuildings.cs ---

using System;
using System.Collections.Generic;

using Rust;

namespace Oxide.Plugins
{

    [Info("Indestructable Buildings", "Mughisi", "1.0.1", ResourceId=966)]
    class IndestructableBuildings : RustPlugin
    {

        #region Configuration Data

        bool configChanged;

        // Plugin settings
        string defaultChatPrefix = "Protector";
        string defaultChatPrefixColor = "#008000ff";

        string chatPrefix;
        string chatPrefixColor;

        // Plugin options
        bool defaultProtectFoundations = true;
        bool defaultProtectAllBuildingBlocks = true;
        bool defaultInformPlayer = true;
        float defaultInformInterval = 30;

        bool protectFoundations;
        bool protectAllBuildingBlocks;
        bool informPlayer;
        float informInterval;

        // Messages
        string defaultHelpText = "Damage to {0} has been disabled.";
        string defaultInformMessage = "You cannot deal damage to {0}!";

        string helpText;
        string informMessage;

        #endregion

        class OnlinePlayer
        {
            public BasePlayer Player;
            public float LastInformTime;

            public OnlinePlayer(BasePlayer player)
            {
            }
        }

        [OnlinePlayers] Hash<BasePlayer, OnlinePlayer> onlinePlayers = new Hash<BasePlayer, OnlinePlayer>();
        DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        protected override void LoadDefaultConfig()
        {
            Log("Created a new default configuration file.");
            Config.Clear();
            LoadVariables();
        }

        void Loaded()
        {
            LoadVariables();

            // Save config changes when required
            if (configChanged)
            {
                Log("The configuration file was updated.");
                SaveConfig();
            }
        }

        void LoadVariables()
        {
            // Settings
            chatPrefix = Convert.ToString(GetConfigValue("Settings", "ChatPrefix", defaultChatPrefix));
            chatPrefixColor = Convert.ToString(GetConfigValue("Settings", "ChatPrefixColor", defaultChatPrefixColor));

            // Options
            protectFoundations = bool.Parse(Convert.ToString(GetConfigValue("Options", "ProtectFoundations", defaultProtectFoundations)));
            protectAllBuildingBlocks = bool.Parse(Convert.ToString(GetConfigValue("Options", "ProtectAllBuildingBlocks", defaultProtectAllBuildingBlocks)));
            informPlayer = bool.Parse(Convert.ToString(GetConfigValue("Options", "StickyGrenades", defaultInformPlayer)));
            informInterval = float.Parse(Convert.ToString(GetConfigValue("Options", "InformInterval", defaultInformInterval)));

            // Messages
            helpText = Convert.ToString(GetConfigValue("Messages", "HelpText", defaultHelpText));
            informMessage = Convert.ToString(GetConfigValue("Messages", "InformMessage", defaultInformMessage));
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var block = entity as BuildingBlock;
            if (!block) return;
            if (((block.blockDefinition.hierachyName == "foundation" || block.blockDefinition.hierachyName == "foundation.triangle") && protectFoundations) || protectAllBuildingBlocks)
                info.damageTypes = new DamageTypeList();

            if (info.damageTypes.Total() != 0f) return;

            var player = info.Initiator as BasePlayer;
            if (player && informPlayer && onlinePlayers[player].LastInformTime + informInterval < GetTimestamp())
            {
                onlinePlayers[player].LastInformTime = GetTimestamp();
                SendChatMessage(player, informMessage, (protectAllBuildingBlocks ? "buildings" : "foundations"));
            }
        }

        void OnPlayerInit(BasePlayer player) 
            => onlinePlayers[player].LastInformTime = 0f;

        void SendHelpText(BasePlayer player)
        {
            if (!protectFoundations && !protectAllBuildingBlocks) return;
            SendChatMessage(player, helpText, (protectAllBuildingBlocks ? "buildings" : "foundations"));
        }

        #region Helper Methods

        void Log(string message) 
            => Puts("{0} : {1}", Title, message);

        void SendChatMessage(BasePlayer player, string message, params object[] arguments) 
            => PrintToChat(player, $"<color={chatPrefixColor}>{chatPrefix}</color>: {message}", arguments);
        
        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;

            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }

            if (!data.TryGetValue(setting, out value))
            {
                value = defaultValue;
                data[setting] = value;
                configChanged = true;
            }

            return value;
        }
        private long GetTimestamp()
            => Convert.ToInt64((System.DateTime.UtcNow.Subtract(epoch)).TotalSeconds);

        #endregion

    }

}

// --- End of file: IndestructableBuildings.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-translations ---
// --- Original File Path: I/ItemTranslations/ItemTranslations.cs ---

using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Item Translations", "Ryan", "1.0.0")]
    [Description("Provides a data file of item names for translation")]
    class ItemTranslations : RustPlugin
    {
        private StoredData sData;

        private class StoredData
        {
            public Dictionary<string, string> ItemTranslations = new Dictionary<string, string>();
        }

        private void OnServerInitialized()
        {
            var count = 0;
            foreach (var item in ItemManager.itemList)
            {
                if (!sData.ItemTranslations.ContainsKey(item.displayName.english))
                {
                    sData.ItemTranslations.Add(item.displayName.english, item.displayName.english);
                }
                else if (item.displayName.english != sData.ItemTranslations[item.displayName.english])
                {
                    item.displayName.english = sData.ItemTranslations[item.displayName.english];
                    count++;
                }
            }
            if(count != 0)
                PrintWarning($"Updated {count} item translations");
            Interface.Oxide.DataFileSystem.WriteObject(Name, sData);
        }

        private void Init()
        {
            sData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
        }
    }
}


// --- End of file: ItemTranslations.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-inspector ---
// --- Original File Path: I/ItemInspector/ItemInspector.cs ---

﻿using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System.Linq;
using System.Text;
using Rust;

namespace Oxide.Plugins
{
	[Info("Item Inspector", "mr01sam", "1.0.0")]
	[Description("Allows players to inspect items to see their true stats")]
	public class ItemInspector : CovalencePlugin
	{
		[PluginReference]
		private readonly Plugin Craftsman;

		#region Permissions
		private const string PermissionUse = "iteminspector.use";
		private const string PermissionAdmin = "iteminspector.admin";
		#endregion

		#region Oxide Hooks
		void OnServerInitialized( bool initial )
		{
			permission.RegisterPermission(PermissionUse, this);
			permission.RegisterPermission(PermissionAdmin, this);
		}
		#endregion

		#region API Methods
		private Dictionary<string, object> GetItemData( Item item )
		{
			ItemData data = new ItemData();
			BaseEntity heldEntity = item.GetHeldEntity();
			ItemCategory itemCategory = item.info.category;
			if (true)
			{
				data.AddMetadata("category", item.info.category);
				data.AddMetadata("uid", item.uid);
				data.AddMetadata("short_name", item.info.shortname);
				data.AddMetadata("id", item.info.itemid);
				data.AddInfo("display_name", item.info.displayName.translated);
			}
			if (heldEntity != null)
			{
				data.AddMetadata("object", heldEntity.GetType().ToString());
			}
			if (item._maxCondition > 0)
			{
				data.AddInfo("condition", item._condition);
				data.AddInfo("max_condition", item._maxCondition);
			}
			if (Craftsman && (bool)Craftsman.Call("HasCraftingCategory", heldEntity, item))
			{
				data.AddInfo("quality", (int)Craftsman.Call("GetCraftingQualityOfItem", item.uid));
				data.AddInfo("max_quality", (int)Craftsman.Call("GetMaxCraftingQuality"));
			}
			if (item.info.stackable > 1)
			{
				data.AddInfo("amount", item.amount);
				data.AddInfo("max_amount", item.info.stackable);
			}
			if (item.skin != 0)
			{
				data.AddMetadata("skin", item.skin);
			}
			if (new List<ItemCategory>() {
				ItemCategory.Tool,
				ItemCategory.Weapon
			}.Contains(itemCategory) && heldEntity != null && IsClassOf(heldEntity, typeof(BaseMelee)))
			{
				BaseMelee baseMelee = (BaseMelee)heldEntity;
				if (baseMelee.gathering.Tree.gatherDamage > 0 || baseMelee.gathering.Flesh.gatherDamage > 0 || baseMelee.gathering.Ore.gatherDamage > 0)
				{
					data.AddInfo("gather_rate", new Dictionary<string, float>() {
						{ "tree", baseMelee.gathering.Tree.gatherDamage },
						{ "ore", baseMelee.gathering.Ore.gatherDamage },
						{ "flesh", baseMelee.gathering.Flesh.gatherDamage }
					});
				}
				float totalDamage = 0;
				foreach (DamageTypeEntry dt in baseMelee.damageTypes)
				{
					totalDamage += dt.amount;
				}
				if (totalDamage > 0)
				{
					data.AddInfo("damage", totalDamage);
				}
			}
			if (new List<ItemCategory>() {
				ItemCategory.Weapon
			}.Contains(itemCategory) && heldEntity != null && IsClassOf(heldEntity, typeof(ProjectileWeaponMod)))
			{
				ProjectileWeaponMod projectileWeaponMod = (ProjectileWeaponMod)heldEntity;
				if (projectileWeaponMod.projectileDamage.scalar > 0 || projectileWeaponMod.projectileVelocity.scalar > 0 || projectileWeaponMod.projectileDistance.scalar > 0)
				{
					data.AddInfo("modifiers", new Dictionary<string, float>()
					{
						{ "damage", projectileWeaponMod.projectileDamage.scalar },
						{ "velocity", projectileWeaponMod.projectileVelocity.scalar },
						{ "distance", projectileWeaponMod.projectileDistance.scalar }
					});
				}
			}

			if (new List<ItemCategory>() {
				ItemCategory.Weapon,
				ItemCategory.Tool
			}.Contains(itemCategory) && heldEntity != null && IsClassOf(heldEntity, typeof(AttackEntity)))
			{

				List<string> mods = new List<string>();
				float scaleAmount = 1f;
				if (IsClassOf(heldEntity, typeof(BaseProjectile)))
				{
					BaseProjectile baseProjectile = (BaseProjectile)heldEntity;

					if (item.contents != null && item.contents.itemList != null && item.contents.itemList.Count > 0)
					{
						foreach (Item item2 in item.contents.itemList)
						{
							mods.Add(item2.info.displayName.translated);
						}
						data.AddInfo("mods", mods.ToArray());
					}
				}
				if (WeaponDamages.ContainsKey(item.info.shortname))
				{
					float damageBase = WeaponDamages[item.info.shortname];
					float damageScaled = damageBase * scaleAmount;
					if (item.contents != null && item.contents.itemList != null)
					{
						foreach (Item item2 in item.contents.itemList)
						{
							if (((ProjectileWeaponMod)item2.GetHeldEntity()).projectileDamage.scalar > 0)
							{
								damageScaled *= ((ProjectileWeaponMod)item2.GetHeldEntity()).projectileDamage.scalar;
							}
						}
					}
					data.AddInfo("damage", damageScaled);
				}
			}
			if (Craftsman)
			{
				ulong creatorId = (ulong)Craftsman.Call("GetItemCreatorId", item.uid);
				if (creatorId != 0)
				{
					BasePlayer basePlayer = BasePlayer.FindByID(creatorId);
					if (basePlayer != null)
					{
						data.AddInfo("creator", basePlayer.displayName);
					}
				}
			}
			if (new List<ItemCategory>() {
				ItemCategory.Attire,
			}.Contains(itemCategory) && ClothingProtection.ContainsKey(item.info.shortname))
			{
				ClothingResistances prot = ClothingProtection[item.info.shortname];
				data.AddInfo("protection", new Dictionary<string, float>() {
						{ "projectile", prot.Projectile },
						{ "melee", prot.Melee },
						{ "bite", prot.Bite },
						{ "cold", prot.Cold },
						{ "radiation", prot.Radiation },
						{ "explosion", prot.Explosion }
					});
			}

			return new Dictionary<string, object>()
			{
				{ "info", data.info },
				{ "metadata", data.metadata },
			};
		}
		#endregion

		#region Classes
		private class ItemData {
			public readonly Dictionary<string, object> metadata;
			public readonly Dictionary<string, object> info;

			public ItemData(  )
			{
				this.metadata = new Dictionary<string, object>();
				this.info = new Dictionary<string, object>();
			}

			public void AddInfo( string key, object value ) {
				this.info.Add(key, value);
			}

			public void AddMetadata( string key, object value )
			{
				this.metadata.Add(key, value);
			}
		}

		#endregion

		#region Helpers
		private bool IsClassOf(object entity, Type type) {
			return entity.GetType() == type || entity.GetType().IsSubclassOf(type);
		}

		private string Size( int size, string text )
		{
			return $"<size={size}>{text}</size>";
		}

		private string Color( string color, string text )
		{
			return $"<color={color}>{text}</color>";
		}

		private string Header( string titlestr, string color )
		{
			return Size(16, Color(color, titlestr + ":\n"));
		}

		private string Label( string labelstr, string color ) {
			return Color(color, labelstr + ": ");
		}

		private string Text( string statstr, string color) {
			return Color(color, statstr + "\n");
		}

		private string FormatList( string[] elements ) {
			return String.Join(" | ", elements.ToArray());
		}

		private string FormatDict( string[] keys, string[] values )
		{
			return String.Join(" | ", (from k in keys select $"{values[Array.IndexOf(keys, k)]} {k}").ToArray());
		}

		private string FormatString( string str ) {
			return str;
		}

		private string FormatRatio( string left, string right )
		{
			return $"{left}/{right}";
		}

		private string LabelText( string label, string text, string color ) {
			return $"{Label(label, config.Colors.Labels)}{Text(text, color)}";
		}

		private void PrintItemStats( IPlayer player, Dictionary<string, object> data )
		{
			StringBuilder message = new StringBuilder();
			
			if (data.ContainsKey("info") && (permission.UserHasPermission(player.Id, PermissionUse) || permission.UserHasPermission(player.Id, PermissionAdmin))) {
				message.Append($"{Header(Lang("inspect", player.Id), config.Colors.Title)}");
				foreach (KeyValuePair<string, object> entry in (Dictionary<string, object>) data["info"])
				{
					switch (entry.Key)
					{
						case "condition":
							message.Append(LabelText(
								Lang(entry.Key, player.Id),
								FormatRatio(entry.Value.ToString(), ((Dictionary<string, object>)data["info"])["max_condition"].ToString()),
								config.Colors.Ratios
							));
							break;
						case "quality":
							message.Append(LabelText(
								Lang(entry.Key, player.Id),
								FormatRatio(entry.Value.ToString(), ((Dictionary<string, object>)data["info"])["max_quality"].ToString()),
								config.Colors.Ratios
							));
							break;
						case "amount":
							message.Append(LabelText(
								Lang(entry.Key, player.Id),
								FormatRatio(entry.Value.ToString(), ((Dictionary<string, object>)data["info"])["max_amount"].ToString()),
								config.Colors.Ratios
							));
							break;
						case "gather_rate":
							message.Append(LabelText(
								Lang(entry.Key, player.Id),
								FormatDict(
									(from k in ((Dictionary<string, float>) entry.Value).Keys select Lang(k.ToString(), player.Id)).ToArray(),
									(from v in ((Dictionary<string, float>) entry.Value).Values select v.ToString()).ToArray()
								),
								config.Colors.Mappings
							));
							break;
						case "modifiers":
							message.Append(LabelText(
								Lang(entry.Key, player.Id),
								FormatDict(
									(from k in ((Dictionary<string, float>)entry.Value).Keys select Lang(k.ToString(), player.Id)).ToArray(),
									(from v in ((Dictionary<string, float>)entry.Value).Values select v.ToString()).ToArray()
								),
								config.Colors.Mappings
							));
							break;
						case "mods":
							message.Append(LabelText(
								Lang(entry.Key, player.Id),
								FormatList(
									(from v in (string[]) entry.Value select v.ToString()).ToArray()
								),
								config.Colors.Lists
							));
							break;
						case "protection":
							message.Append(LabelText(
								Lang(entry.Key, player.Id),
								FormatDict(
									(from k in ((Dictionary<string, float>)entry.Value).Keys select Lang(k.ToString(), player.Id)).ToArray(),
									(from v in ((Dictionary<string, float>)entry.Value).Values select v.ToString()).ToArray()
								),
								config.Colors.Mappings
							));
							break;
						default:
							if (!entry.Key.StartsWith("max_"))
							{
								message.Append(LabelText(
									Lang(entry.Key, player.Id),
									FormatString(entry.Value.ToString()),
									config.Colors.Info
								));
							}
							break;
					}
				}
			}
			if (data.ContainsKey("metadata") && permission.UserHasPermission(player.Id, PermissionAdmin))
			{
				foreach (KeyValuePair<string, object> entry in (Dictionary<string, object>)data["metadata"])
				{
					switch (entry.Key)
					{
						default:
							if (!entry.Key.StartsWith("max_"))
							{
								message.Append(LabelText(
									Lang(entry.Key, player.Id),
									FormatString(entry.Value.ToString()),
									config.Colors.Metadata
								));
							}
							break;
					}
				}
			}

			player.Reply(message.ToString());
		}
		#endregion

		#region Commands
		[Command("inspect")]
		private void cmd_inspect( IPlayer player, string command, string[] args )
		{
			if (permission.UserHasPermission(player.Id, PermissionUse) || permission.UserHasPermission(player.Id, PermissionAdmin))
			{
				BasePlayer basePlayer = BasePlayer.FindByID(ulong.Parse(player.Id));
				Item activeItem = basePlayer.GetActiveItem();
				if (activeItem == null)
				{
					player.Reply(Lang("no_active_item", player.Id));
					return;
				}
				PrintItemStats(player, GetItemData(activeItem));
			}
			else
			{
				player.Reply(Lang("no_perms", player.Id));
			}
		}
		#endregion

		#region Config
		private Configuration config;
		private class Configuration
		{
			[JsonProperty(PropertyName = "Colors")]
			public ColorsConfig Colors = new ColorsConfig();


			public class ColorsConfig
			{
				[JsonProperty(PropertyName = "Title")]
				public string Title { get; set; } = "#cf391f";

				[JsonProperty(PropertyName = "Labels")]
				public string Labels { get; set; } = "#CACACA";

				[JsonProperty(PropertyName = "Info")]
				public string Info { get; set; } = "#e6b265";

				[JsonProperty(PropertyName = "Metadata")]
				public string Metadata { get; set; } = "#d683a7";

				[JsonProperty(PropertyName = "Lists")]
				public string Lists { get; set; } = "#69c7e0";

				[JsonProperty(PropertyName = "Ratios")]
				public string Ratios { get; set; } = "#93ed96";

				[JsonProperty(PropertyName = "Mappings")]
				public string Mappings { get; set; } = "#d36dde";
			}
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();

			try
			{
				config = Config.ReadObject<Configuration>();
				if (config == null) throw new Exception();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
			}

			SaveConfig();
		}

		protected override void SaveConfig() => Config.WriteObject(config);

		protected override void LoadDefaultConfig() => config = new Configuration();
		#endregion

		#region Localization
		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["inspect"] = "Inspected",
				["category"] = "Category",
				["uid"] = "UID",
				["short_name"] = "Short Name",
				["id"] = "ID",
				["display_name"] = "Name",
				["object"] = "Object",
				["condition"] = "Condition",
				["quality"] = "Quality",
				["amount"] = "Amount",
				["skin"] = "Skin",
				["gather_rate"] = "Gather Rate",
				["damage"] = "Damage",
				["modifiers"] = "Modifiers",
				["mods"] = "Mods",
				["creator"] = "Creator",
				["protection"] = "Protection",
				["no_active_item"] = "You must have an item selected in your hotbar to use this command",
				["no_perms"] = "You do not have permission to use this command",
				["tree"] = "Tree",
				["flesh"] = "Flesh",
				["ore"] = "Ore",
				["velocity"] = "Velocity",
				["distance"] = "Distance",
				["projectile"] = "Projectile",
				["melee"] = "Melee",
				["bite"] = "Bite",
				["cold"] = "Cold",
				["radiation"] = "Radiation",
				["explosion"] = "Explosion"
			}, this);
		}

		private string Lang( string key, string id = null, params object[] args ) => string.Format(lang.GetMessage(key, this, id), args);
		#endregion

		#region Data
		private Dictionary<string, float> WeaponDamages = new Dictionary<string, float>()
		{
			{ "rifle.ak", 50 },
			{ "rifle.bolt", 80 },
			{ "rifle.lr300", 40 },
			{ "rifle.l96", 80 },
			{ "rifle.m39", 50 },
			{ "rifle.semiauto", 40 },
			{ "pistol.m92", 45 },
			{ "pistol.eoka", 180 },
			{ "pistol.python", 55 },
			{ "pistol.revolver", 35 },
			{ "pistol.nailgun", 18 },
			{ "pistol.semiauto", 40 },
			{ "lmg.m249", 65 },
			{ "smg.mp5", 35 },
			{ "smg.thompson", 37 },
			{ "smg.2", 30 },
			{ "bow.compound", 100 },
			{ "bow.hunting", 40 },
			{ "crossbow", 60 },
			{ "shotgun.pump", 180 },
			{ "shotgun.spas12", 117 },
			{ "shotgun.double", 180 },
			{ "shotgun.waterpipe", 180 },
			{ "multiplegrenadelauncher", 90 },
			{ "rocket.launcher", 350 },
			{ "snowballgun", 25 },
			{ "grenade.f1", 225 },
			{ "grenade.beancan", 115 },
			{ "explosive.satchel", 475 },
			{ "explosive.timed", 550 },
			{ "surveycharge", 20 }
		};

		private class ClothingResistances
		{
			[JsonProperty(PropertyName = "Projectile")]
			public float Projectile = 0f;
			[JsonProperty(PropertyName = "Melee")]
			public float Melee = 0f;
			[JsonProperty(PropertyName = "Bite")]
			public float Bite = 0f;
			[JsonProperty(PropertyName = "Radiation")]
			public float Radiation = 0f;
			[JsonProperty(PropertyName = "Explosion")]
			public float Explosion = 0f;
			[JsonProperty(PropertyName = "Cold")]
			public float Cold = 0f;
		}

		private Dictionary<string, ClothingResistances> ClothingProtection = new Dictionary<string, ClothingResistances>
		{
			{ "metal.plate.torso", new ClothingResistances { Projectile = 25f, Melee = 20f, Bite = 3f, Cold = -8f } },
			{ "metal.facemask", new ClothingResistances { Projectile = 50f, Melee = 70f, Bite = 8f, Cold = -4f, Explosion = 8f } },
			{ "hazmatsuit", new ClothingResistances { Projectile = 30f, Melee = 30f, Bite = 8f, Radiation = 50f, Cold = 8, Explosion = 5f } },
			{ "mask.bandana", new ClothingResistances { Projectile = 5f, Melee = 10f, Bite = 3f, Radiation = 3f, Cold = 10} },
			{ "attire.banditguard", new ClothingResistances { Projectile = 30f, Melee = 30f, Bite = 15f, Radiation = 50f, Cold = 8, Explosion = 17f } },
			{ "hat.cap", new ClothingResistances { Projectile = 10f, Melee = 10f, Bite = 3f, Radiation = 1f, Cold = 7 } },
			{ "hat.beenie", new ClothingResistances { Projectile = 10f, Melee = 10f, Bite = 3f, Radiation = 1f, Cold = 7 } },
			{ "hat.boonie", new ClothingResistances { Projectile = 10f, Melee = 10f, Bite = 3f, Radiation = 1f, Cold = 7 } },
			{ "shoes.boots", new ClothingResistances { Projectile = 10f, Melee = 10f, Bite = 3f, Radiation = 3f, Cold = 8 } },
			{ "bone.armor.suit", new ClothingResistances { Projectile = 25f, Melee = 40f, Bite = 13f, Radiation = 4f, Explosion = 7f } },
			{ "deer.skull.mask", new ClothingResistances { Projectile = 25f, Melee = 40f, Bite = 13f, Radiation = 4f, Explosion = 7f } },
			{ "bucket.helmet", new ClothingResistances { Projectile = 20f, Melee = 50f, Bite = 8f, Radiation = 4f, Cold = 6f, Explosion = 8f } },
			{ "burlap.gloves.new", new ClothingResistances { Melee = 5f, Bite = 2f, Radiation = 3f, Cold = 4f } },
			{ "burlap.headwrap", new ClothingResistances { Projectile = 15f, Melee = 15f, Bite = 3f, Radiation = 2f, Cold = 7f } },
			{ "burlap.shirt", new ClothingResistances { Projectile = 10f, Melee = 10f, Bite = 3f, Radiation = 2f, Cold = 7f } },
			{ "burlap.shoes", new ClothingResistances { Projectile = 5f, Melee = 5f, Bite = 2f, Radiation = 2f, Cold = 3f } },
			{ "burlap.trousers", new ClothingResistances { Projectile = 10f, Melee = 10f, Bite = 3f, Radiation = 2f, Cold = 7f } },
			{ "movembermoustachecard", new ClothingResistances { Projectile = 5f, Melee = 10f, Bite = 3f, Radiation = 3f, Cold = 10f } },
			{ "clatter.helmet", new ClothingResistances { Projectile = 20f, Melee = 50f, Bite = 8f, Radiation = 4f, Cold = 6f, Explosion = 8f } },
			{ "coffeecan.helmet", new ClothingResistances { Projectile = 35f, Melee = 50f, Bite = 8f, Radiation = 5f, Explosion = 8f } },
			{ "hat.dragonmask", new ClothingResistances { Projectile = 30f, Melee = 60f, Bite = 10f, Radiation = 4f, Cold = 6f, Explosion = 13f } },
			{ "boots.frog", new ClothingResistances { Radiation = 5f, Cold = 8f } },
			{ "hat.gas.mask", new ClothingResistances { Projectile = 20f, Melee = 50f, Bite = 8f, Radiation = 4f, Cold = 6f, Explosion = 8f } },
			{ "ghostsheet", new ClothingResistances { Projectile = 20f, Melee = 15f, Bite = 6f, Radiation = 5f, Cold = 8f } },
			{ "twitch.headset", new ClothingResistances { Projectile = 20f, Melee = 25f, Bite = 7f, Radiation = 5f, Cold = 10f } },
			{ "heavy.plate.helmet", new ClothingResistances { Projectile = 90f, Melee = 80f, Bite = 13f, Radiation = 7f, Cold = -17f, Explosion = 17f } },
			{ "heavy.plate.jacket", new ClothingResistances { Projectile = 75f, Melee = 70f, Bite = 12f, Radiation = 7f, Cold = -17f, Explosion = 17f } },
			{ "heavy.plate.pants", new ClothingResistances { Projectile = 75f, Melee = 70f, Bite = 12f, Radiation = 7f, Cold = -17f, Explosion = 17f } },
			{ "scientistsuit_heavy", new ClothingResistances { Projectile = 30f, Melee = 30f, Bite = 15f, Radiation = 50f, Cold = 8f, Explosion = 17f } },
			{ "attire.hide.boots", new ClothingResistances { Projectile = 5f, Melee = 5f, Bite = 3f, Radiation = 2f, Cold = 5f } },
			{ "attire.hide.helterneck", new ClothingResistances { Projectile = 10f, Melee = 10f, Bite = 3f, Radiation = 2f, Cold = 7f } },
			{ "attire.hide.pants", new ClothingResistances { Projectile = 10f, Melee = 10f, Bite = 8f, Radiation = 2f, Cold = 4f } },
			{ "attire.hide.poncho", new ClothingResistances { Projectile = 10f, Melee = 40f, Bite = 5f, Radiation = 8f, Cold = 8f, Explosion = 5f } },
			{ "attire.hide.skirt", new ClothingResistances { Projectile = 10f, Melee = 10f, Bite = 3f, Radiation = 2f, Cold = 7f } },
			{ "attire.hide.vest", new ClothingResistances { Projectile = 15f, Melee = 15f, Bite = 8f, Radiation = 3f, Cold = 5f } },
			{ "horse.shoes.advanced", new ClothingResistances { Projectile = 5f, Melee = 5f, Bite = 3f, Radiation = 2f, Cold = 5f } },
			{ "hoodie", new ClothingResistances { Projectile = 20f, Melee = 15f, Bite = 6f, Radiation = 5f, Cold = 8f } },
			{ "mask.balaclava", new ClothingResistances { Projectile = 15f, Melee = 15f, Bite = 3f, Radiation = 3f, Cold = 13f, Explosion = 3f } },
			{ "jacket", new ClothingResistances { Projectile = 15f, Melee = 20f, Bite = 7f, Radiation = 5f, Cold = 10f } },
			{ "jumpsuit.suit", new ClothingResistances { Projectile = 25f, Melee = 40f, Bite = 13f, Radiation = 4f, Explosion = 7f } },
			{ "burlap.gloves", new ClothingResistances { Projectile = 5f, Melee = 5f, Bite = 2f, Radiation = 4f, Cold = 5f } },
			{ "tshirt.long", new ClothingResistances { Projectile = 15f, Melee = 15f, Bite = 6f, Radiation = 5f, Cold = 10f } },
			{ "hat.oxmask", new ClothingResistances { Projectile = 30f, Melee = 60f, Bite = 10f, Radiation = 4f, Cold = 6f, Explosion = 13f } },
			{ "movembermoustache", new ClothingResistances { Projectile = 5f, Melee = 10f, Bite = 3f, Radiation = 3f, Cold = 10f } },
			{ "halloween.mummysuit", new ClothingResistances { Melee = 10f, Bite = 5f, Radiation = 15f, Cold = 13f } },
			{ "attire.nesthat", new ClothingResistances { Projectile = 30f, Melee = 60f, Bite = 10f, Radiation = 4f, Cold = 6f, Explosion = 13f } },
			{ "nightvisiongoggles", new ClothingResistances { Projectile = 15f, Melee = 20f, Bite = 3f, Cold = 4f } },
			{ "attire.ninja.suit", new ClothingResistances { Projectile = 25f, Melee = 30f, Bite = 8f, Radiation = 15f, Cold = 8f, Explosion = 5f } },
			{ "pants", new ClothingResistances { Projectile = 15f, Melee = 15f, Bite = 3f, Radiation = 5f, Cold = 8f } },
			{ "roadsign.jacket", new ClothingResistances { Projectile = 20f, Melee = 25f, Bite = 10f, Cold = -8f } },
			{ "roadsign.kilt", new ClothingResistances { Projectile = 20f, Melee = 25f, Bite = 10f, Cold = -8f } },
			{ "hat.ratmask", new ClothingResistances { Projectile = 30f, Melee = 60f, Bite = 10f, Radiation = 4f, Cold = 6f, Explosion = 13f } },
			{ "attire.reindeer.headband", new ClothingResistances { Projectile = 15f, Melee = 15f, Bite = 3f, Radiation = 2f, Cold = 7f } },
			{ "riot.helmet", new ClothingResistances { Projectile = 25f, Melee = 80f, Bite = 13f, Radiation = 5f, Cold = 6f, Explosion = 8f } },
			{ "roadsign.gloves", new ClothingResistances { Projectile = 10f, Melee = 25f, Bite = 10f, Cold = -8f } },
			{ "santabeard", new ClothingResistances { Projectile = 5f, Melee = 10f, Bite = 3f, Radiation = 3f, Cold = 10f } },
			{ "santahat", new ClothingResistances { Projectile = 25f, Melee = 40f, Bite = 13f, Radiation = 4f, Explosion = 7f } },
			{ "scarecrow.suit", new ClothingResistances { Projectile = 10f, Bite = 5f, Radiation = 15f, Cold = 13f } },
			{ "scarecrowhead", new ClothingResistances { Projectile = 30f, Melee = 60f, Bite = 10f, Radiation = 4f, Cold = 6f, Explosion = 13f } },
			{ "hazmatsuit_scientist", new ClothingResistances { Projectile = 30f, Melee = 30f, Bite = 8f, Radiation = 50f, Cold = 8f, Explosion = 5f } },
			{ "hazmatsuit_scientist_peacekeeper", new ClothingResistances { Projectile = 30f, Melee = 30f, Bite = 8f, Radiation = 50f, Cold = 8f, Explosion = 5f } },
			{ "shirt.collared", new ClothingResistances { Projectile = 15f, Melee = 15f, Bite = 5f, Radiation = 3f, Cold = 6f } },
			{ "pants.shorts", new ClothingResistances { Projectile = 10f, Melee = 10f, Bite = 3f, Radiation = 2f, Cold = 7f } },
			{ "jacket.snow", new ClothingResistances { Projectile = 20f, Melee = 30f, Bite = 5f, Radiation = 20f, Cold = 17f } },
			{ "tactical.gloves", new ClothingResistances { Projectile = 10f, Melee = 5f, Bite = 2f, Radiation = 5f, Cold = 7f } },
			{ "halloween.surgeonsuit", new ClothingResistances { Projectile = 25f, Melee = 30f, Bite = 8f, Radiation = 15f, Cold = 8f, Explosion = 5f } },
			{ "shirt.tanktop", new ClothingResistances { Projectile = 10f, Melee = 10f, Bite = 3f, Radiation = 2f, Cold = 2f } },
			{ "tshirt", new ClothingResistances { Projectile = 15f, Melee = 15f, Bite = 5f, Radiation = 3f, Cold = 6f } },
			{ "diving.wetsuit", new ClothingResistances { Melee = 10f, Bite = 5f, Radiation =15f, Cold = 13f } },
			{ "hat.wolf", new ClothingResistances { Projectile = 30f, Melee = 60f, Bite = 10f, Radiation = 4f, Cold = 6f, Explosion = 13f } },
			{ "wood.armor.helmet", new ClothingResistances { Projectile = 15f, Melee = 25f, Bite = 3f, Radiation = 2f, Cold = 7f } },
			{ "wood.armor.pants", new ClothingResistances { Projectile = 10f, Melee = 40f, Bite = 5f, Radiation = 5f, Explosion = 5f } },
			{ "wood.armor.jacket", new ClothingResistances { Projectile = 10f, Melee = 40f, Bite = 5f, Radiation = 5f, Explosion = 5f } }
		};
		#endregion
	}
}


// --- End of file: ItemInspector.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-search ---
// --- Original File Path: I/ItemSearch/ItemSearch.cs ---

﻿using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Item Search", "Jacob", "1.0.2", ResourceId = 2679)]
    class ItemSearch : RustPlugin
    {
        #region Chat Command

        [ChatCommand("item")]
        private void ItemSearchCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "itemsearch.able") && !player.IsAdmin)
            {
                PrintToChat(player, lang.GetMessage("PermissionError", this, player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                PrintToChat(player, lang.GetMessage("SyntaxError", this, player.UserIDString));
                return;
            }

            ItemDefinition item;
            var name = string.Join(" ", args.Skip(1).ToArray()).ToLower();
            switch (args[0].ToLower())
            {
                case "name":
                    if (args.Length < 2)
                    {
                        PrintToChat(player, lang.GetMessage("SyntaxError", this, player.UserIDString));
                        return;
                    }

                    item = ItemManager.itemList.FirstOrDefault(x => x.displayName.english.ToLower().Contains(name));
                    if (item == null)
                    {
                        PrintToChat(player, lang.GetMessage("NonexistentItem", this, player.UserIDString));
                        return;
                    }

                    PrintToChat(player, lang.GetMessage("ItemInfo", this, player.UserIDString)
                        .Replace("{name}", item.displayName.english)
                        .Replace("{category}", item.category.ToString())
                        .Replace("{description}", item.displayDescription.english)
                        .Replace("{ID}", item.itemid.ToString())
                        .Replace("{shortname}", item.shortname));
                    break;

                case "shortname":
                    if (args.Length < 2)
                    {
                        PrintToChat(player, lang.GetMessage("SyntaxError", this, player.UserIDString));
                        return;
                    }

                    item = ItemManager.itemList.FirstOrDefault(x => x.shortname.Contains(name));
                    if (item == null)
                    {
                        PrintToChat(player, lang.GetMessage("NonexistentItem", this, player.UserIDString));
                        return;
                    }

                    PrintToChat(player, lang.GetMessage("ItemInfo", this, player.UserIDString)
                        .Replace("{name}", item.displayName.english)
                        .Replace("{category}", item.category.ToString())
                        .Replace("{description}", item.displayDescription.english)
                        .Replace("{ID}", item.itemid.ToString())
                        .Replace("{shortname}", item.shortname));
                    break;

                case "help":
                    if (args.Length < 1)
                    {
                        PrintToChat(player, lang.GetMessage("SyntaxError", this, player.UserIDString));
                        return;
                    }

                    PrintToChat(player, lang.GetMessage("Help", this, player.UserIDString));
                    break;
                
                default:
                    PrintToChat(player, lang.GetMessage("SyntaxError", this, player.UserIDString));
                    break;
            }
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages() => lang.RegisterMessages(new Dictionary<string, string>
        {
            {"Help", "<size=16>Item Search Help</size>" +
                     "\n<size=14><color=lightblue>/item name <name></color></size> <size=13>Searches items by name.</size>" +
                     "\n<size=14><color=lightblue>/item shortname <name></color></size> <size=13>Searches items by shortname.</size>"},
            {"ItemInfo", "<size=16>{name}</size>" +
                         "\n<size=14><color=lightblue>Category</color></size> <size=13>{category}</size>" +
                         "\n<size=14><color=lightblue>Description</color></size> <size=13>{description}</size>" +
                         "\n<size=14><color=lightblue>ID</color></size> <size=13>{ID}</size>" +
                         "\n<size=14><color=lightblue>Shortname</color></size> <size=13>{shortname}</size>"},
            {"NonexistentItem", "Error, nonexistent item."},
            {"PermissionError", "Error, you lack permission."},
            {"SyntaxError", "Error, incorrect syntax. Try looking at <color=lightblue>/item help</color>."}
        }, this);

        #endregion

        #region Oxide Hooks

        private void Init() => permission.RegisterPermission("itemsearch.able", this);

        #endregion
    }
}

// --- End of file: ItemSearch.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/invisible-sleepers ---
// --- Original File Path: I/InvisibleSleepers/InvisibleSleepers.cs ---

using Network;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Invisible Sleepers", "collect_vood", "1.0.14")]
    [Description("Makes all sleepers invisible")]
    public class InvisibleSleepers : RustPlugin
    {
        [PluginReference]
        private Plugin Friends, Clans;

        #region Constants

        const string permAllow = "invisiblesleepers.allow";
        const string permBypass = "invisiblesleepers.bypass";

        #endregion

        #region Config

        private ConfigurationFile Configuration;
        private class ConfigurationFile
        {
            [JsonProperty(PropertyName = "Performance Mode")]
            public bool PerformanceMode = false;
            [JsonProperty(PropertyName = "Show clan members")]
            public bool ShowClan = false;
            [JsonProperty(PropertyName = "Show team members")]
            public bool ShowTeam = false;
            [JsonProperty(PropertyName = "Show friends")]
            public bool ShowFriends = false;
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Configuration = new ConfigurationFile();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigurationFile>();
            SaveConfig();
        }
        protected override void SaveConfig() => Config.WriteObject(Configuration);

        #endregion

        #region Hooks

        private void Init()
        {
            Unsubscribe("OnPlayerSleep");
            permission.RegisterPermission(permAllow, this);
            permission.RegisterPermission(permBypass, this);
            if (Configuration.PerformanceMode)
            {
                Unsubscribe("CanNetworkTo");
                foreach (BasePlayer player in BasePlayer.sleepingPlayerList)
                {
                    if (player != null && HasPerm(player))
                        player.limitNetworking = true;
                }
            }
            else
            {
                foreach (BasePlayer player in BasePlayer.sleepingPlayerList)
                {
                    if (player != null && HasPerm(player))
                        HideSleeper(player);
                }
            }
        }

        private void OnServerInitialized()
        {
            // Resubscribing to not get null exception on server startup
            Subscribe("OnPlayerSleep");
        }

        //Credit: most code taken from the vanish plugin made by Wulf
        private object CanNetworkTo(BasePlayer player, BasePlayer target)
        {
            if ((player != null && target != null)
                && player.IsSleeping() && HasPerm(player))
            {
                if (CanBypass(target, player))
                    return null;
                return false;
            }
            return null;
        }

        private object CanNetworkTo(HeldEntity entity, BasePlayer target)
            => entity == null ? null : CanNetworkTo(entity.GetOwnerPlayer(), target);
        
        private object CanBeTargeted(BasePlayer player, MonoBehaviour monoBehaviour)
        {
            if (player && player.IsSleeping() && HasPerm(player))
                return false;
            return null;
        }

        private void HideSleeper(BasePlayer player)
        {
            List<Connection> connections = new List<Connection>();
            foreach (BasePlayer target in BasePlayer.activePlayerList)
            {
                if (target == null || player == target || !target.IsConnected || CanBypass(target, player))
                    continue;
                if (target.net?.connection != null)
                    connections.Add(target.net.connection);
            }

            HeldEntity heldEntity = player.GetHeldEntity();
            if (heldEntity != null)
            {
                heldEntity.SetHeld(false);
                heldEntity.UpdateVisiblity_Invis();
                heldEntity.SendNetworkUpdate();
            }

            if (Net.sv.write.Start())
            {
                Net.sv.write.PacketID(Message.Type.EntityDestroy);
                Net.sv.write.EntityID(player.net.ID);
                Net.sv.write.UInt8((byte)BaseNetworkable.DestroyMode.None);
                Net.sv.write.Send(new SendInfo(connections));
            }

            player.DisablePlayerCollider();
        }

        //Credit: birthdates for .limitNetworking possibly fixing some lag issues
        private void OnPlayerSleep(BasePlayer player)
        {
            if (player != null && HasPerm(player))
            {
                if (Configuration.PerformanceMode)
                    player.limitNetworking = true;
                else
                    HideSleeper(player);
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (player != null) 
            {
                player.limitNetworking = false;
                player.EnablePlayerCollider();
            }
        }

        #endregion

        #region Helpers

        private bool HasPerm(BasePlayer player) => permission.UserHasPermission(player.UserIDString, permAllow);

        private bool CanBypass(BasePlayer player, BasePlayer target)
        {
            if (player == null || target == null) return false;
            if (permission.UserHasPermission(player.UserIDString, permBypass) || Configuration.ShowTeam && IsTeamMember(player, target) || 
                    Configuration.ShowFriends && IsFriend(player, target) || Configuration.ShowClan && IsClanMember(player, target))
                return true;
            return false;
        }

        private bool IsClanMember(BasePlayer player, BasePlayer target)
        {
            if (Clans == null || !Clans.IsLoaded)
                return false;

            var playerClan = Clans.Call<string>("GetClanOf", player);
            var otherPlayerClan = Clans.Call<string>("GetClanOf", target);
            if (playerClan == null || otherPlayerClan == null)
                return false;
            return playerClan == otherPlayerClan;
        }

        private bool IsTeamMember(BasePlayer player, BasePlayer target) => RelationshipManager.ServerInstance.FindTeam(player.currentTeam)?.members.Contains(target.userID) ?? false;

        private bool IsFriend(BasePlayer player, BasePlayer target) => Friends?.Call<bool>("AreFriendsS", player.UserIDString, target.UserIDString) ?? false;

        #endregion
    }
}


// --- End of file: InvisibleSleepers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/individual-damage-controller ---
// --- Original File Path: I/IndividualDC/IndividualDC.cs ---

﻿using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("IndividualDC", "k1lly0u", "0.1.3", ResourceId = 1758)]
    [Description("Damage controller for individual bones and weapons")]
    class IndividualDC : RustPlugin
    {   
        private ConfigData configData;
        public string[] Bodyparts = new string[]
                {
                    "r_forearm",
                    "l_forearm",
                    "l_upperarm",
                    "r_upperarm",
                    "r_hand",
                    "l_hand",
                    "pelvis",
                    "l_hip",
                    "r_hip",
                    "spine3",
                    "spine4",
                    "spine1",
                    "spine2",
                    "r_knee",
                    "r_foot",
                    "r_toe",
                    "l_knee",
                    "l_foot",
                    "l_toe",
                    "head",
                    "neck",
                    "jaw",
                    "r_eye",
                    "l_eye"
                };
        class ConfigData
        {
            public Dictionary<string, Dictionary<string, float>> Weapons { get; set; }            
        }
        void OnServerInitialized()
        {
            lang.RegisterMessages(messages, this);
            LoadVariables();
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            var config = new ConfigData{ Weapons = SetConfigData() };
            Config.WriteObject(config, true);
        }        
        private Dictionary<string, Dictionary<string, float>> SetConfigData()
        {
            Dictionary<string, Dictionary<string, float>> weapons = new Dictionary<string, Dictionary<string, float>>();
            foreach (ItemDefinition definition in ItemManager.itemList)
            {
                if (definition != null)
                    if (definition.category.ToString() == "Weapon")                        
                        if (!definition.shortname.Contains("mod"))
                        {
                            weapons.Add(definition.shortname, new Dictionary<string, float>());
                            foreach (var entry in Bodyparts)
                                weapons[definition.shortname].Add(entry, 1.0f);
                        }                    
            }
            return weapons;
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        private void LoadConfigVariables()
        {
            configData = Config.ReadObject<ConfigData>();
        }
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            try
            {
                if (entity is BasePlayer && hitInfo.Initiator is BasePlayer)
                {
                    if (entity as BasePlayer == null || hitInfo == null) return;

                    string bodypart = StringPool.Get(hitInfo.HitBone);
                    if (bodypart == null || bodypart == "") return;

                    string weapon = hitInfo.Weapon.GetItem().info.shortname;
                    if (weapon == null || weapon == "") return;

                    if (InList(weapon, bodypart))
                    {
                        float modifier = configData.Weapons[weapon][bodypart];
                        hitInfo.damageTypes.ScaleAll(modifier);
                    }
                }
            }
            catch (NullReferenceException ex)
            {
            }
        } 
        private bool InList(string weapon, string bodypart)
        {
            bool changed = false;
            if (!configData.Weapons.ContainsKey(weapon))
            {
                configData.Weapons.Add(weapon, new Dictionary<string, float>());
                foreach (var entry in Bodyparts)
                    if (!configData.Weapons[weapon].ContainsKey(entry))
                        configData.Weapons[weapon].Add(entry, 1.0f);
                changed = true;
            }
            if (!configData.Weapons[weapon].ContainsKey(bodypart))
            {
                foreach (var entry in configData.Weapons)
                    if (!configData.Weapons[entry.Key].ContainsKey(bodypart))
                        configData.Weapons[entry.Key].Add(bodypart, 1.0f);
                changed = true;
            }
            if (changed) Config.WriteObject(configData, true);
            return true;
        }
        [ChatCommand("scale")]
        private void cmdScale(BasePlayer player, string command, string[] args)
        {
            if (!isAuth(player)) return;
            if (args == null || args.Length == 0)
            {
                SendReply(player, lang.GetMessage("1",this, player.UserIDString));
                SendReply(player, lang.GetMessage("2", this, player.UserIDString));
                SendReply(player, lang.GetMessage("3", this, player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "weapon":
                    if (args.Length >= 3)
                    {
                        if (configData.Weapons.ContainsKey(args[1].ToLower()))
                        {
                            if (configData.Weapons[args[1].ToLower()].ContainsKey(args[2].ToLower()))
                            {
                                float i = 1.0f;
                                if (args.Length == 4)
                                    if (!float.TryParse(args[3], out i)) i = 1.0f;
                                configData.Weapons[args[1].ToLower()][args[2].ToLower()] = i;
                                Config.WriteObject(configData, true);
                                SendReply(player, string.Format(lang.GetMessage("7", this, player.UserIDString), args[1], args[2], i));
                                return;
                            }
                            SendReply(player, string.Format(lang.GetMessage("4", this, player.UserIDString), args[2].ToLower()));
                            return;
                        }
                        SendReply(player, string.Format(lang.GetMessage("5", this, player.UserIDString), args[1].ToLower()));
                        return;
                    }
                    SendReply(player, lang.GetMessage("6", this, player.UserIDString));
                    return;
                case "list":
                    for (int i = 0; i < Bodyparts.Length; i += 3)
                        SendReply(player, Bodyparts[i] + ", " + Bodyparts[i + 1] + ", " + Bodyparts[i + 2]);
                    return;
            }
            
        }
        private bool isAuth(BasePlayer player)
        {
            if (player.net.connection.authLevel >= 1) return true;
            return false;
        }

        Dictionary<string, string> messages = new Dictionary<string, string>
        {
            {"1", "<color=orange>/scale weapon <shortname> <bone> <amount></color> - Scale damage done for <shortname> to <bone>"},
            {"2", "<color=orange>-- ex. /scale weapon rifle.ak pelvis 1.25</color> - Damage done from a assault rifle to a pelvis is set to 125%"},
            {"3", "<color=orange>/scale list</color> - Displays all bones"},
            {"4", "Could not find a weapon with the shortname: <color=orange>{0}</color>"},
            {"5", "Could not find a bone called: <color=orange>{0}</color>. Check /scale list"},
            {"6", "<color=orange>/scale weapon <shortname> <bone> <amount></color>"},
            {"7","You have changed <color=orange>{0}'s</color> damage against <color=orange>{1}</color> to <color=orange>{2}</color>x damage" }
        };
    }
}

// --- End of file: IndividualDC.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/inventory-lock ---
// --- Original File Path: I/InventoryLock/InventoryLock.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using UnityEngine;

/*
 * Rewritten from scratch and maintained to present by VisEntities
 * Originally created by Sonny-Boi, up to version 1.0.0
 */

namespace Oxide.Plugins
{
    [Info("Inventory Lock", "VisEntities", "2.0.0")]
    [Description("Locks player's inventory when joining the server or upon entering certain zones.")]
    public class InventoryLock : RustPlugin
    {
        #region 3rd Party Dependencies

        [PluginReference]
        private readonly Plugin ZoneManager;

        #endregion 3rd Party Dependencies

        #region Fields

        private static InventoryLock _plugin;
        private static Configuration _config;

        public enum ContainerType
        {
            Belt,
            Clothing,
            Main,
            All
        }

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Lock On Connect")]
            public List<ContainerType> LockOnConnect { get; set; }

            [JsonProperty("Locked Zones")]
            public List<LockedZone> LockedZones { get; set; }

            public class LockedZone
            {
                [JsonProperty("Zone Id")]
                public string ZoneId { get; set; }

                [JsonProperty("Container Types")]
                public List<ContainerType> ContainerTypes { get; set; }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                LockOnConnect = new List<ContainerType>
                {
                    ContainerType.Clothing,
                },
                LockedZones = new List<Configuration.LockedZone>
                {
                    new Configuration.LockedZone
                    {
                        ZoneId = "42626527",
                        ContainerTypes = new List<ContainerType>
                        {
                            ContainerType.Clothing,
                            ContainerType.Belt
                        }
                    },
                    new Configuration.LockedZone
                    {
                        ZoneId = "89401263",
                        ContainerTypes = new List<ContainerType>
                        {
                            ContainerType.All,
                        }
                    },
                }
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Init()
        {
            _plugin = this;
            PermissionUtil.RegisterPermissions();
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player != null)
                {
                    LockOrUnlockContainerSlots(player, ContainerType.All, lockSlots: false);
                }
            }

            _config = null;
            _plugin = null;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (PermissionUtil.VerifyHasPermission(player, PermissionUtil.BYPASS))
                return;

            if (_config.LockOnConnect != null && _config.LockOnConnect.Count > 0)
            {
                foreach (ContainerType containerType in _config.LockOnConnect)
                {
                    LockOrUnlockContainerSlots(player, containerType, true);
                }
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            LockOrUnlockContainerSlots(player, ContainerType.All, lockSlots: false);
        }

        #endregion Oxide Hooks

        #region Zone Hooks

        private void OnEnterZone(string zoneId, BasePlayer player)
        {
            if (PermissionUtil.VerifyHasPermission(player, PermissionUtil.BYPASS))
                return;

            foreach (var lockedZone in _config.LockedZones)
            {
                if (lockedZone.ZoneId != zoneId)
                    continue;

                foreach (ContainerType containerType in lockedZone.ContainerTypes)
                    LockOrUnlockContainerSlots(player, containerType, lockSlots: true);

                break;
            }
        }

        private void OnExitZone(string zoneId, BasePlayer player)
        {
            foreach (var lockedZone in _config.LockedZones)
            {
                if (lockedZone.ZoneId != zoneId)
                    continue;

                LockOrUnlockContainerSlots(player, ContainerType.All, lockSlots: false);
                break;
            }
        }

        #endregion Zone Hooks

        #region Functions

        public static void LockOrUnlockContainerSlots(BasePlayer player, ContainerType containerType, bool lockSlots)
        {
            List<ItemContainer> containers = new List<ItemContainer>();

            switch (containerType)
            {
                case ContainerType.Clothing:
                    containers.Add(player.inventory.containerWear);
                    break;
                case ContainerType.Belt:
                    containers.Add(player.inventory.containerBelt);
                    break;
                case ContainerType.Main:
                    containers.Add(player.inventory.containerMain);
                    break;
                case ContainerType.All:
                    containers.Add(player.inventory.containerWear);
                    containers.Add(player.inventory.containerBelt);
                    containers.Add(player.inventory.containerMain);
                    break;
            }

            foreach (var container in containers)
            {
                bool isCurrentlyLocked = container.HasFlag(ItemContainer.Flag.IsLocked);
                if (lockSlots && !isCurrentlyLocked)
                {
                    container.SetFlag(ItemContainer.Flag.IsLocked, true);
                }
                else if (!lockSlots && isCurrentlyLocked)
                {
                    container.SetFlag(ItemContainer.Flag.IsLocked, false);
                }
            }

            player.inventory.SendSnapshot();
        }

        #endregion Functions

        #region Helper Functions

        private static bool VerifyPluginBeingLoaded(Plugin plugin)
        {
            return plugin != null && plugin.IsLoaded ? true : false;
        }

        #endregion Helper Functions

        #region Utility Classes

        private static class PermissionUtil
        {
            public const string ADMIN = "inventorylock.admin";
            public const string BYPASS = "inventorylock.bypass";

            public static void RegisterPermissions()
            {
                _plugin.permission.RegisterPermission(ADMIN, _plugin);
                _plugin.permission.RegisterPermission(BYPASS, _plugin);
            }

            public static bool VerifyHasPermission(BasePlayer player, string permissionName = ADMIN)
            {
                return _plugin.permission.UserHasPermission(player.UserIDString, permissionName);
            }
        }

        #endregion Utility Classes

        #region Commands

        /// <summary>
        /// inv.lock <PlayerId or PlayerName> <ContainerType> <True or False>
        /// </summary>

        [ConsoleCommand("inv.lock")]
        private void cmdLockInventory(ConsoleSystem.Arg conArgs)
        {
            BasePlayer cmdSender = conArgs.Player();
            if (cmdSender == null)
                return;

            if (!PermissionUtil.VerifyHasPermission(cmdSender, PermissionUtil.ADMIN))
            {
                SendReplyToPlayer(cmdSender, Lang.AdminPermissionRequired);
                return;
            }

            if (!conArgs.HasArgs(3))
            {
                SendReplyToPlayer(cmdSender, Lang.InvalidArguments);
                return;
            }

            BasePlayer targetPlayer = conArgs.GetPlayer(0);
            string containerTypeArg = conArgs.GetString(1);
            bool lockSlotsArg = conArgs.GetBool(2);

            if (targetPlayer == null)
            {
                SendReplyToPlayer(cmdSender, Lang.PlayerNotFound);
                return;
            }

            if (PermissionUtil.VerifyHasPermission(targetPlayer, PermissionUtil.BYPASS))
            {
                SendReplyToPlayer(cmdSender, Lang.PlayerHasBypass, targetPlayer.displayName);
                return;
            }

            if (!Enum.TryParse(containerTypeArg, true, out ContainerType containerType))
            {
                SendReplyToPlayer(cmdSender, Lang.InvalidContainerType);
                return;
            }

            LockOrUnlockContainerSlots(targetPlayer, containerType, lockSlotsArg);

            string successLangKey;
            if (lockSlotsArg)
                successLangKey = Lang.LockSuccess;
            else
                successLangKey = Lang.UnlockSuccess;

            SendReplyToPlayer(cmdSender, successLangKey, containerType.ToString(), targetPlayer.displayName);
        }

        #endregion Commands

        #region Localization

        private class Lang
        {
            public const string InvalidArguments = "InvalidArguments";
            public const string PlayerNotFound = "PlayerNotFound";
            public const string InvalidContainerType = "InvalidContainerType";
            public const string LockSuccess = "LockSuccess";
            public const string UnlockSuccess = "UnlockSuccess";
            public const string PlayerHasBypass = "PlayerHasBypass ";
            public const string AdminPermissionRequired = "AdminPermissionRequired ";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.InvalidArguments] = "Invalid arguments provided. Usage: inv.lock <PlayerId or PlayerName> <ContainerType> <True or False>",
                [Lang.PlayerNotFound] = "Player not found.",
                [Lang.InvalidContainerType] = "Invalid container type provided.",
                [Lang.LockSuccess] = "Successfully locked <color=#ffb347>{0}</color> container for <color=#ffb347>{1}</color>.",
                [Lang.UnlockSuccess] = "Successfully unlocked <color=#ffb347>{0}</color> container for <color=#ffb347>{1}</color>.",
                [Lang.PlayerHasBypass] = "<color=#ffb347>{0}</color> has bypass permission and cannot have their inventory locked or unlocked.",
                [Lang.AdminPermissionRequired] = "You do not have the required admin permission to execute this command.",
            }, this, "en");
        }

        private void SendReplyToPlayer(BasePlayer player, string messageKey, params object[] args)
        {
            string message = lang.GetMessage(messageKey, this, player.UserIDString);
            if (args.Length > 0)
                message = string.Format(message, args);

            SendReply(player, message);
        }

        #endregion Localization
    }
}

// --- End of file: InventoryLock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ignore-collision ---
// --- Original File Path: I/IgnoreCollision/IgnoreCollision.cs ---

using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("IgnoreCollision", "2CHEVSKII", "1.1.1")]
    [Description("This plugin removes collisions between dropped items")]
    internal class IgnoreCollision : RustPlugin
    {

        #region [Fields]


        private bool ignore = true;
        private bool dynamicIgnore = true;

        private bool logs = true;
        private int ignoreStartAmount = 300;
        private int droppedItemCount = 0;
        private bool nowDisabled = false;


        #endregion

        #region [Config]


        protected override void LoadDefaultConfig() { }

        private void LoadConfigVariables()
        {
            CheckConfig("1.Disable collision", ref ignore);
            CheckConfig("2.Dynamic collision disabling", ref dynamicIgnore);
            CheckConfig("3.Amount to disable collision", ref ignoreStartAmount);
            CheckConfig("5.Log plugin activity", ref logs);
            SaveConfig();
        }

        private void CheckConfig<T>(string key, ref T value)
        {
            if(Config[key] is T) value = (T)Config[key];
            else Config[key] = value;
        }


        #endregion

        #region [Hooks]


        private void Init() => LoadConfigVariables();

        private void Loaded()
        {
            if(ignore)
            {
                if(!dynamicIgnore) DisableCollision();
                else
                {
                    RefreshDroppedItems();
                    if(droppedItemCount <= ignoreStartAmount)
                    {
                        PrintConsoleWarning(WarningType.MoreThan);
                        DisableCollision();
                    }
                }
            }
            PrintConsoleWarning(WarningType.Load);
        }

        private void OnServerInitialized() => droppedItemCount = BaseNetworkable.serverEntities.OfType<DroppedItem>().Count();

        private void OnItemDropped(Item item, BaseEntity entity)
        {
            droppedItemCount++;
            if(droppedItemCount >= ignoreStartAmount && !nowDisabled)
            {
                PrintConsoleWarning(WarningType.MoreThan);
                DisableCollision();
            }
        }

        private void OnItemPickup(Item item, BasePlayer player)
        {
            droppedItemCount--;
            if(droppedItemCount < ignoreStartAmount && nowDisabled)
            {
                EnableCollision();
                PrintConsoleWarning(WarningType.LessThan);
            }
        }

        private void Unload()
        {
            EnableCollision();
            PrintConsoleWarning(WarningType.Unload);
        }


        #endregion

        #region [Core]


        private void DisableCollision() { Physics.IgnoreLayerCollision(26, 26, true); nowDisabled = true; }

        private void EnableCollision() { Physics.IgnoreLayerCollision(26, 26, false); nowDisabled = false; }

        private void RefreshDroppedItems() => droppedItemCount = BaseNetworkable.serverEntities.OfType<DroppedItem>().Count();


        #endregion

        #region [Logs]


        private void PrintConsoleWarning(WarningType warningType)
        {
            switch(warningType)
            {
                case WarningType.Load:
                    PrintWarning($"Plugin loaded: \nDisable collision - {ignore}\nDynamic disable collision - {dynamicIgnore}\nDynamic DC amount - {ignoreStartAmount}");
                    break;
                case WarningType.Unload:
                    PrintWarning($"Plugin is being unloaded, all items collision enabled!");
                    break;
                case WarningType.MoreThan:
                    if(logs) PrintWarning($"Dropped item limit exceed ({ignoreStartAmount}) - collision disabled!");
                    break;
                case WarningType.LessThan:
                    if(logs) PrintWarning($"Dropped items less than limit ({ignoreStartAmount}) - collision enabled!");
                    break;
                default:
                    break;
            }
        }

        private enum WarningType { Load, Unload, MoreThan, LessThan }


        #endregion

    }
}

// --- End of file: IgnoreCollision.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-barrels ---
// --- Original File Path: I/InstantBarrels/InstantBarrels.cs ---

﻿namespace Oxide.Plugins
{
    [Info("Instant Barrels", "Mevent", "1.0.3")]
    [Description("Allows you to destroy barrels and roadsigns with one hit")]
    public class InstantBarrels : CovalencePlugin
    {
        #region Fields

        private const string PermUse = "InstantBarrels.use";

        private const string PermRoadSigns = "InstantBarrels.roadsigns";

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            permission.RegisterPermission(PermUse, this);

            permission.RegisterPermission(PermRoadSigns, this);
        }

        private void OnEntityTakeDamage(LootContainer container, HitInfo info)
        {
            if (container == null || info == null) return;

            var player = info.InitiatorPlayer;
            if (player == null) return;

            var cov = player.IPlayer;
            if (cov == null) return;

            if (cov.HasPermission(PermUse) && container.ShortPrefabName.Contains("barrel") ||
                cov.HasPermission(PermRoadSigns) && container.ShortPrefabName.Contains("roadsign"))
                info.damageTypes.ScaleAll(1000f);
        }

        #endregion
    }
}

// --- End of file: InstantBarrels.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/igniter-plus ---
// --- Original File Path: I/IgniterPlus/IgniterPlus.cs ---

﻿using System.Collections.Generic;
using Facepunch;
using Rust;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
        [Info("IgniterPlus", "Bran", "0.0.5")]
        [Description("Configure electrical igniters")]
    public class IgniterPlus : RustPlugin
    {
        List<Igniter> igniters = new List<Igniter>();

        int counter = 0;
        private void OnServerInitialized()
        {
            foreach (var entity in UnityEngine.Object.FindObjectsOfType<Igniter>())
            {
                counter++;
                OnEntitySpawned(entity);
            }

            Puts($"OnServerInitialized {counter} igniters were processed.");
        }



        private void OnEntitySpawned(Igniter entity)
        {

            entity.SelfDamagePerIgnite = configData.Options.SelfDamagePerIgnite;
            entity.IgniteRange = configData.Options.IgniteRange;
            entity.IgniteFrequency = configData.Options.IgniteFrequency;
            entity.PowerConsumption = configData.Options.PowerConsumption;
            if (configData.Options.Power)
            {
                entity.UpdateHasPower(25, 1);
            }
        }

        private void Unload()
        {
            foreach (var entity in igniters)
            {
                entity.SelfDamagePerIgnite = 0.5f;
                entity.IgniteRange = 5f;
                entity.IgniteFrequency = 1f;
                entity.PowerConsumption = 2;
                entity.UpdateHasPower(0, 1);
            }
        }

        #region Config
        void Init()
        {
            LoadConfigVariables();
        }

        private ConfigData configData;
        class ConfigData
        {
            public Options Options = new Options();
        }

        class Options
        {
            
            public float SelfDamagePerIgnite = 0.5f;
            public float IgniteRange = 5f;
            public float IgniteFrequency = 1f;
            public int PowerConsumption = 2;
            public bool Power = false;
        }

        private void LoadConfigVariables()
        {
            configData = Config.ReadObject<ConfigData>();
            SaveConfig(configData);
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating new config file.");
            var config = new ConfigData();
            SaveConfig(config);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        #endregion
    }

}

// --- End of file: IgniterPlus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/invulnerable-players ---
// --- Original File Path: I/InvulnerablePlayers/InvulnerablePlayers.cs ---

﻿using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Invulnerable Players", "Hamster", "1.0.4")]
    [Description("Prevents aggression / targeting of entities to the player")]
    public class InvulnerablePlayers : RustPlugin
    {
        
        private const string PermUse = "invulnerableplayers.use";
        private List<BasePlayer> _data = new List<BasePlayer>();
        
        #region Hook

        private void Init()
        {
            permission.RegisterPermission(PermUse, this);
        }
        
		 protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "No Permission", "You don't have enough permissions" },
                { "Enabled", "<b><color=#9acd32><size=16>Enabled</size></color></b>" },
                { "Disabled", "<b><color=#ce422b><size=16>Disabled</size></color></b>" }
            }, this);
        }
		
        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var basePlayer = entity as BasePlayer;
            if (basePlayer == null || !_data.Contains(basePlayer))
                return null;

            return false;
        }
        
        private object CanHelicopterStrafeTarget(PatrolHelicopterAI entity, BasePlayer target)
        {
            if (_data.Contains(target))
                return false;

            return null;
        }
        
        // turret/heli
        private object CanBeTargeted(BaseCombatEntity entity, MonoBehaviour behaviour)
        {
            var basePlayer = entity as BasePlayer;

            if (basePlayer != null && _data.Contains(basePlayer))
                return false;

            return null;
        }
        
        //apc
        private object CanBradleyApcTarget(BradleyAPC apc, BaseEntity entity)
        {
            var basePlayer = entity as BasePlayer;
            
            if (basePlayer != null && _data.Contains(basePlayer))
                return false;

            return null;
        }

        // heli
        private object CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer basePlayer)
        {
            if (_data.Contains(basePlayer))
                return false;

            return null;
        }
        
        //scientist NPCs
        private object OnNpcPlayerTarget(NPCPlayerApex npc, BaseEntity entity)
        {
            var basePlayer = entity as BasePlayer;
            
            if (basePlayer != null && _data.Contains(basePlayer) && !IsNpc(basePlayer))
                return false;

            return null;
        }

        //animals
        private object OnNpcTarget(BaseNpc npc, BaseEntity entity)
        {
            var basePlayer = entity as BasePlayer;
            
            if (basePlayer != null && _data.Contains(basePlayer))
                return false;

            return null;
        }

        private bool CanNpcAttack(BaseNpc npc, BaseEntity entity)
        {
            var basePlayer = entity as BasePlayer;
            if (basePlayer != null && basePlayer.IsAdmin) { return false; };
            return true;
        }
        
        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity)
        {
            var basePlayer = entity as BasePlayer;

            if (basePlayer != null && _data.Contains(basePlayer))
                return false;

            return null;
        }
        
        //Traps and mines
        private object OnTrapTrigger(BaseTrap trap, GameObject go)
        {
            var basePlayer = go.GetComponent<BasePlayer>();
            if (basePlayer != null && _data.Contains(basePlayer))
                return false;

            return null;
        }
        
        private object OnPlayerLand(BasePlayer basePlayer, float num)
        {
            if (_data.Contains(basePlayer))
            {
                return false;
            }
            return null;
        }
        
        private static bool IsNpc(BasePlayer player) //исключение НПС
        {
            if (player == null) return false;
            //BotSpawn
            if (player is NPCPlayer)
                return true;
            // ReSharper disable once ConditionIsAlwaysTrueOrFalse
            if (player is NPCPlayerApex)
                return true;
#pragma warning disable 184
            if (player is BaseNpc)
#pragma warning restore 184
                return true;
            //HumanNPC
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L))
                return true;
            return false;
        }

        #endregion

        #region Metabolism

        private object OnRunPlayerMetabolism(PlayerMetabolism metabolism)
        {
            var basePlayer = metabolism.GetComponent<BasePlayer>();

            if (basePlayer != null && _data.Contains(basePlayer))
            {
                basePlayer.InitializeHealth(100, 100);
                metabolism.oxygen.Add(metabolism.oxygen.max);
                metabolism.wetness.Add(-metabolism.wetness.max);
                metabolism.radiation_level.Add(-metabolism.radiation_level.max);
                metabolism.radiation_poison.Add(-metabolism.radiation_poison.max);
                metabolism.temperature.Reset();
                metabolism.hydration.Add(metabolism.hydration.max);
                metabolism.calories.Add(metabolism.calories.max);
                metabolism.bleeding.Reset();
                return false;
            }
            return null;
        }

        #endregion

        #region Command
        
        [ChatCommand("inv")]
        private void CmdCraftBoat(BasePlayer basePlayer, string command, string[] args)
        {
            var ids = basePlayer.UserIDString;
            if (!permission.UserHasPermission(ids, PermUse) && !basePlayer.IsAdmin)
            {
                basePlayer.ChatMessage(GetMsg("No Permission", ids));
                return;
            }

            if (_data.Contains(basePlayer))
            {
                _data.Remove(basePlayer);
                basePlayer.ChatMessage(GetMsg("Disabled", ids));
                return;
            }
            
            _data.Add(basePlayer);
            basePlayer.ChatMessage(GetMsg("Enabled", ids));
        }

        #endregion

        #region Hh

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion
        
    }
}

// --- End of file: InvulnerablePlayers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-inventory-cleaner ---
// --- Original File Path: I/InventoryCleaner/InventoryCleaner.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System;
using Rust;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Security;
using System.Reflection;
using Object = System.Object;
using System.Text;
using System.Numerics;
using System.Runtime;
using Network;

namespace Oxide.Plugins
{
    [Info("Inventory Cleaner", "Joao Pster", "2.1.1")]
    [Description("Allows players to clear their own or another player's inventory.")]
    public class InventoryCleaner : RustPlugin
    {
        #region Fields

        private class MyPermissions
        {
            public const string Clear = "inventorycleaner.allowed";
            public const string ClearOthers = "inventorycleaner.cleaneveryone";
            public const string ClearOnDeath = "inventorycleaner.cleanondeath";
            public const string ClearOnLogout = "inventorycleaner.cleanonexit";
        }

        private readonly string[] _permissions = GetAllPublicConstantValues<string>(typeof(MyPermissions)).ToArray();

        private static Configuration _config;

        #endregion

        #region Configuration

        private class Configuration
        {
            [JsonProperty(PropertyName = "[Message Image]")]
            public ulong MessageImage { get; set; } = 0;

            [JsonProperty(PropertyName = "[Message Prefix]")]
            public string MessagePrefix { get; set; } = "[Clear Inventory]";
        }

        private Configuration DefaultConfig() => new Configuration();

        protected override void LoadDefaultConfig()
        {
            PrintWarning("We are creating a new configuration file!");
            _config = DefaultConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception err)
            {
                PrintWarning("Failed to load the config file!");
                PrintWarning("Please, remove your config from config folder and reload plugin.");
                PrintError(err.ToString());
                return;
            }

            SaveConfig();
        }

        #endregion

        #region Helper Functions

        // This is to convert the class MyPermissions into an array of permissions.
        private static List<T> GetAllPublicConstantValues<T>(Type type)
        {
            return type
                .GetFields(BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy)
                .Where(fi => fi.IsLiteral && !fi.IsInitOnly && fi.FieldType == typeof(T))
                .Select(x => (T)x.GetRawConstantValue())
                .ToList();
        }

        private string GenerateMessage(string message, string color = "#ffffff", int size = 14, bool italic = false)
        {
            var text = italic ? $"<size={size}>{_config.MessagePrefix} <color={color}><i>{message}</i></color></size>" : $"<size={size}>{_config.MessagePrefix} <color={color}>{message}</color></size>";
            return text;
        }

        private bool HasPermission(BasePlayer player, string permissionName, bool send = true)
        {
            if (player == null) return false;

            var has = permission.UserHasPermission(player.UserIDString, permissionName);
            if (!has && send)
            {
                string message = GenerateMessage(GetMessage(MessageKey.NoPermission, player.UserIDString, permissionName), "#FFFFFF", 14, false);
                SendChatMessage(player, message);
            }

            return has;
        }

        private void SendConsoleMessage(BasePlayer player, string message)
        {
            player.ConsoleMessage(message);
        }

        private void SendChatMessage(BasePlayer player, string message)
        {
            Player.Message(player, message, _config.MessageImage);
        }

        private void ReplyPlayer(IPlayer player, string message)
        {
            player.Reply(message);
        }

        private void SendMessageToAll(string message)
        {
            Server.Broadcast(message, _config.MessageImage);
        }
        
        private bool[] hasAllPermissions(IPlayer iplayer)
        {
            List<bool> bools = new List<bool>();

            foreach (var perm in _permissions)
            {
                bools.Add(iplayer.HasPermission(perm));
            }

            return bools.ToArray();
        }

        #endregion

        #region Permissions

        private string[] CheckPermissions(string[] permArray)
        {
            var toPerm = new List<string>();

            foreach (var perm in permArray)
            {
                if (!permission.PermissionExists(perm)) toPerm.Add(perm);
            }

            return toPerm.ToArray();
        }

        private bool IsAllowed(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.UserIDString, perm)) return true;


            return false;
        }

        private void LoadPermissions()
        {
            var toPerm = CheckPermissions(_permissions);
            if (toPerm.Length == 0) return;
            
            PrintWarning("Registering permissions...");
            foreach (var perm in toPerm)
            {
                permission.RegisterPermission(perm, this);
            }
        }

        #endregion

        #region Initialization and Saving

        private void Init()
        {
            LoadPermissions();

            // Register chat/console command under many different aliases
            // When running from chat, prefix with a forward slash /

            AddCovalenceCommand(new string[] {"clearinv", "cleaninv", "clear.inv", "clean.inv", "inv.clear", "invclear", "inv.clean", "invclean"}, nameof(ClearCovalenceCommand), MyPermissions.Clear); 
        }

        #endregion

        #region Clear Hooks

        object OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (!HasPermission(player, MyPermissions.ClearOnDeath, false)) return null;

            player.inventory.Strip();
            string msg = GenerateMessage(GetMessage(MessageKey.OnDeath, player.UserIDString, player.displayName), "green", 14);
            SendChatMessage(player, msg);

            return null;
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (player.IsDead()) return;
            if (!HasPermission(player, MyPermissions.ClearOnLogout, false)) return;

            player.inventory.Strip();
        }

        #endregion
        
        #region Panel Functions
        
        private void CommandsPanel(IPlayer iplayer, params string[] args)
        {
            var sb = new StringBuilder();
            sb.Append(GetMessage(MessageKey.Header, iplayer.Id, Author, Version));
            sb.Append(GetMessage(MessageKey.Gone, iplayer.Id));
            sb.Append(GetMessage(MessageKey.Opts, iplayer.Id));
            sb.Append(GetMessage(MessageKey.OptAll, iplayer.Id));
            sb.Append(GetMessage(MessageKey.OptInv, iplayer.Id));
            sb.Append(GetMessage(MessageKey.OptBelt, iplayer.Id));
            sb.Append(GetMessage(MessageKey.OptWear, iplayer.Id));
            sb.Append(GetMessage(MessageKey.OptEvery, iplayer.Id));

            ReplyPlayer(iplayer, sb.ToString());
        }

        private void HelpPanel(IPlayer iplayer)
        {
            var mCp = hasAllPermissions(iplayer);

            var sb = new StringBuilder();
            sb.Append(GetMessage(MessageKey.Header, iplayer.Id, Author, Version));
            sb.Append(GetMessage(MessageKey.Gone, iplayer.Id));
            sb.Append(GetMessage(MessageKey.Perms, iplayer.Id, iplayer.Name));
            sb.Append(GetMessage(MessageKey.PermUse, iplayer.Id, mCp[0]));
            sb.Append(GetMessage(MessageKey.PermEvery, iplayer.Id, mCp[1]));
            sb.Append(GetMessage(MessageKey.PermDeath, iplayer.Id, mCp[2]));
            sb.Append(GetMessage(MessageKey.PermLogout, iplayer.Id, mCp[3]));
            sb.Append(GetMessage(MessageKey.InvComands, iplayer.Id));

            ReplyPlayer(iplayer, sb.ToString());
        }
        
        #endregion

        #region Clear Functions
        
        private void DeleteFromEveryone(IPlayer iplayer, string opt)
        {
            PrintWarning($"{iplayer.Name} is trying to run Delete Everyone!");
            if (!iplayer.HasPermission(MyPermissions.ClearOthers)) return;
            PrintWarning($"{iplayer.Name}: Running Delete Everyone Started!");

            List<BasePlayer> players = BasePlayer.allPlayerList.ToList();

            foreach (var p in players)
            {
                var inv = p.inventory;
                switch (opt)
                {
                    case "main":
                        inv.Strip();
                        SendMessageToAll(GenerateMessage(GetMessage(MessageKey.EveryAllCleaned, iplayer.Id), "red", 18));
                        break;
                    case "inv":
                        inv.containerMain.Clear();
                        SendMessageToAll(GenerateMessage(GetMessage(MessageKey.EveryInvCleaned, iplayer.Id), "red", 18));
                        break;
                    case "belt":
                        inv.containerBelt.Clear();
                        SendMessageToAll(GenerateMessage(GetMessage(MessageKey.EveryBeltCleaned, iplayer.Id), "red", 18));
                        break;
                    case "wear":
                        inv.containerWear.Clear();
                        SendMessageToAll(GenerateMessage(GetMessage(MessageKey.EveryWearCleaned, iplayer.Id), "red", 18));
                        break;
                    default:
                        var msg = GenerateMessage(GetMessage(MessageKey.OptNotFound, iplayer.Id), "red", 14);
                        ReplyPlayer(iplayer, msg);
                        break;
                }
            }

            PrintWarning($"{iplayer.Name}: Running Delete Everyone Finished!");
        }

        private void ClearOneContainer(IPlayer iplayer, ItemContainer container, string msgKey, string option = "main", bool every = false)
        {
            // Everyone
            if (every)
            {
                DeleteFromEveryone(iplayer, option);
                return;
            }
            
            // Singular
            container.Clear();
            ItemManager.DoRemoves();
            
            var msg = GenerateMessage(GetMessage(msgKey, iplayer.Id, iplayer.Name), "green", 14);
            ReplyPlayer(iplayer, msg);
        }

        private void ClearAllContainers(IPlayer iplayer, string msgKey, string option = "main", bool every = false)
        {
            // Everyone
            if (every)
            {
                DeleteFromEveryone(iplayer, option);
                return;
            }

            // Singular
            var player = iplayer.Object as BasePlayer;
            player.inventory.Strip();
            ItemManager.DoRemoves();

            var msg = GenerateMessage(GetMessage(msgKey, iplayer.Id, iplayer.Name), "green", 14);
            ReplyPlayer(iplayer, msg);
        }

        #endregion

        #region Chat and/or Console Commands
        private void ClearCovalenceCommand(IPlayer iplayer, string command, string[] args)
        {
            // This is a client-oriented command, so no need to go further if ran from console
            if (iplayer.IsServer)
            {
                return;
            }

            // Get BasePlayer from IPlayer
            var player = iplayer.Object as BasePlayer;

            if (!iplayer.HasPermission(MyPermissions.Clear))
            {
                return;
            }

            if (args.Length == 0)
            {
                // Default Case
                ClearAllContainers(iplayer, MessageKey.AllCleaned);
                return;
            }

            var every = ((args.Length > 1) && (args[1].ToLower() == "everyone"));

            var opt = args[0].ToLower();

            switch (opt)
            {
                case "main":
                    ClearAllContainers(iplayer, MessageKey.AllCleaned, opt, every);
                    break;
                case "inv":
                    ClearOneContainer(iplayer, player.inventory.containerMain, MessageKey.InvCleaned, opt, every);
                    break;
                case "belt":
                    ClearOneContainer(iplayer, player.inventory.containerBelt, MessageKey.InvCleaned, opt, every);
                    break;
                case "wear":
                    ClearOneContainer(iplayer, player.inventory.containerWear, MessageKey.InvCleaned, opt, every);
                    break;
                case "help":
                    HelpPanel(iplayer);
                    break;
                case "cmds":
                    CommandsPanel(iplayer);
                    break;
                default:
                    ReplyPlayer(iplayer, GenerateMessage(GetMessage(MessageKey.OptNotFound, iplayer.Id, opt)));
                    break;
            }
        }
        #endregion

        #region Localization 

        private static class MessageKey
        {
            public const string NoPermission = "[No Permission]";
            public const string NotFound = "[Not Found]";
            public const string OptNotFound = "[Option Not Found]";
            public const string CorrectUse = "[Correct Use]";
            public const string BeltCleaned = "[Belt Cleaned]";
            public const string EveryBeltCleaned = "[Every Belt Cleaned]";
            public const string InvCleaned = "[Inventory Cleaned]";
            public const string EveryInvCleaned = "InventoryCleaner.EveryInvCleaned";
            public const string WearCleaned = "[Wear Cleaned]";
            public const string EveryWearCleaned = "InventoryCleaner.EveryWearCleaned";
            public const string AllCleaned = "[All Cleaned]";
            public const string EveryAllCleaned = "InventoryCleaner.EveryAllCleaned";
            public const string OnDeath = "[On Death]";
            public const string Header = "[Interface Header]";
            public const string Gone = "[Interface Gome]";
            public const string Opts = "[Interface Options]";
            public const string Perms = "[Interface Perms]";
            public const string OptAll = "[Interface Opt All]";
            public const string OptInv = "[Interface Opt Inv]";
            public const string OptBelt = "[Interface Opt Belt]";
            public const string OptWear = "[Interface Opt Wear]";
            public const string OptEvery = "[Interface Opt Every]";
            public const string PermUse = "[Interface Perm Use]";
            public const string PermEvery = "[Interface Perm Every]";
            public const string PermDeath = "[Interface Perm Death]";
            public const string PermLogout = "[Interface Perm Logout]";
            public const string InvComands = "[Interface Comands]";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [MessageKey.NoPermission] = "You don't have the permission <color=#FF0000>{0}</color> to do that!",
                [MessageKey.NotFound] = "Command <color=red>{0}</color> not found!",
                [MessageKey.OptNotFound] = "Option <color=red>/clearinv {0}</color> not found!",
                [MessageKey.CorrectUse] = "The correct use is: <color=green>/clearinv [command]</color>",
                [MessageKey.BeltCleaned] = "{0}, your belt has just been cleaned!",
                [MessageKey.EveryBeltCleaned] = "The Belt of all players logged into the server has just been removed!",
                [MessageKey.InvCleaned] = "{0}, your inventory has just been cleaned!",
                [MessageKey.EveryInvCleaned] = "The Inventory of all players logged into the server has just been removed!",
                [MessageKey.WearCleaned] = "{0}, your clothing slots has just been cleaned!",
                [MessageKey.EveryWearCleaned] = "The Clothing Slots of all players logged into the server has just been removed!",
                [MessageKey.AllCleaned] = "{0}, everything you have has just been cleaned!",
                [MessageKey.EveryAllCleaned] = "All Items of all players logged into the server has just been removed!",
                [MessageKey.OnDeath] = "{0}, you died and everything you had was deleted before your death!",
                [MessageKey.Header] = "<size=16><color=green>Clear Inventory by {0}</color></size> v{1} \n",
                [MessageKey.Gone] = "<color=#ff0000>Warning:</color> Once items removed they are GONE ! \n\n",
                [MessageKey.Opts] = "Hi, the base commands is <color=green>/clearinv [opts]</color>, see the opts:\n\n",
                [MessageKey.Perms] = "Hi <color=green>{0}</color>, this is your permissions: \n",
                [MessageKey.OptAll] = "<color=yellow>main</color>: remove all your items \n",
                [MessageKey.OptInv] = "<color=yellow>inv</color>: remove all items from your inventory \n",
                [MessageKey.OptBelt] = "<color=yellow>belt</color>: remove all items from your belt \n",
                [MessageKey.OptWear] = "<color=yellow>wear</color>: remove all items from your clothing slots \n\n",
                [MessageKey.OptEvery] = "And, if you have permission, you can do <color=red>/clearinv [opts] everyone</color> to remove the items from everyone who is logged on to the server!",
                [MessageKey.PermUse] = "<color=yellow>Use Clear:</color> {0} \n",
                [MessageKey.PermEvery] = "<color=yellow>Clear Everyone:</color> {0} \n",
                [MessageKey.PermDeath] = "<color=yellow>Clear on Death:</color> {0} \n",
                [MessageKey.PermLogout] = "<color=yellow>Clear on logout:</color> {0} \n\n",
                [MessageKey.InvComands] = "Use <color=green>/clearinv cmds</color> to see the comands.",
            }, this, "en"); ; ;
        }

        private string GetMessage(string messageKey, string playerId = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(messageKey, this, playerId), args);
            }
            catch (Exception err)
            {
                PrintError($"Error on Get Message from Lang: {err.Message}");
                throw;
            }
        }

        #endregion

    }
}


// --- End of file: InventoryCleaner.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-retriever ---
// --- Original File Path: I/ItemRetriever/ItemRetriever.cs ---

﻿using HarmonyLib;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;

namespace Oxide.Plugins
{
    [Info("Item Retriever", "WhiteThunder", "0.7.4")]
    [Description("Allows players to build, craft, reload and more using items from external containers.")]
    internal class ItemRetriever : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin InstantCraft;

        private static ItemRetriever _instance;

        private const int InventorySize = 24;
        private const Item.Flag SearchableItemFlag = (Item.Flag)(1 << 24);
        private const Item.Flag UnsearchableItemFlag = (Item.Flag)(1 << 25);
        private const ItemDefinition.Flag SearchableItemDefinitionFlag = (ItemDefinition.Flag)(1 << 24);

        // The CustomItemDefinitions plugin adds this flag to all custom item definitions.
        // Custom items to be skipped when adding items to network messages, since they have invalid item ids.
        private const ItemDefinition.Flag CustomItemDefinitionFlag = (ItemDefinition.Flag)128;

        private static readonly object True = true;
        private static readonly object False = false;

        private readonly CustomItemDefinitionTracker _customItemDefinitionTracker = new();
        private readonly SupplierManager _supplierManager;
        private readonly ContainerManager _containerManager;
        private readonly ApiInstance _api;
        private readonly Dictionary<int, int> _overridenIngredients = new();
        private readonly List<Item> _reusableItemList = new();
        private Func<ItemDefinition, bool> _isBlockedByInstantCraft;

        public ItemRetriever()
        {
            _api = new ApiInstance(this);
            _supplierManager = new(_customItemDefinitionTracker);
            _containerManager = new(_customItemDefinitionTracker);
        }

        #endregion

        #region Harmony Patches

        [AutoPatch]
        [HarmonyPatch(typeof(PlayerInventory), "FindItemByItemID", typeof(int))]
        private static class Patch_PlayerInventory_FindItemByItemID
        {
            private static readonly CodeInstruction OnInventoryItemFindInstruction = new(OpCodes.Ldstr, nameof(OnInventoryItemFind));

            private static readonly MethodInfo _replacementMethod = typeof(Patch_PlayerInventory_FindItemByItemID)
                .GetMethod(nameof(ReplacementMethod), BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

            private static readonly CodeInstruction[] _newInstructions =
            {
                new(OpCodes.Ldarg_0),
                new(OpCodes.Ldarg_1),
                new(OpCodes.Call, _replacementMethod),
                new(OpCodes.Ret),
            };

            private static Item ReplacementMethod(PlayerInventory playerInventory, int itemId)
            {
                if (_instance is { IsLoaded: true })
                {
                    return _instance.Call(nameof(OnInventoryItemFind), playerInventory, itemId) as Item;
                }

                return null;
            }

            private static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions)
            {
                if (instructions.Any(instruction => HarmonyUtils.InstructionsMatch(instruction, OnInventoryItemFindInstruction)))
                    return instructions;

                return _newInstructions;
            }
        }

        [AutoPatch]
        [HarmonyPatch(typeof(PlayerInventory), "FindAmmo", typeof(AmmoTypes))]
        private static class Patch_PlayerInventory_FindAmmo
        {
            private static readonly CodeInstruction OnInventoryAmmoItemFindInstruction = new(OpCodes.Ldstr, nameof(OnInventoryAmmoItemFind));

            private static readonly MethodInfo _replacementMethod = typeof(Patch_PlayerInventory_FindAmmo)
                .GetMethod(nameof(ReplacementMethod), BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

            private static readonly CodeInstruction[] _newInstructions =
            {
                new(OpCodes.Ldarg_0),
                new(OpCodes.Ldarg_1),
                new(OpCodes.Call, _replacementMethod),
                new(OpCodes.Ret),
            };

            private static Item ReplacementMethod(PlayerInventory playerInventory, AmmoTypes ammoTypes)
            {
                if (_instance is { IsLoaded: true })
                {
                    return _instance.Call(nameof(OnInventoryAmmoItemFind), playerInventory, ammoTypes) as Item;
                }

                return null;
            }

            private static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions)
            {
                if (instructions.Any(instruction => HarmonyUtils.InstructionsMatch(instruction, OnInventoryAmmoItemFindInstruction)))
                    return instructions;

                return _newInstructions;
            }
        }

        private static class HarmonyUtils
        {
            public static bool InstructionsMatch(CodeInstruction a, CodeInstruction b)
            {
                if (a.opcode != b.opcode)
                    return false;

                if (a.operand == null)
                    return b.operand == null;

                return a.operand.Equals(b.operand);
            }
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _instance = this;
        }

        private void OnServerInitialized()
        {
            RefreshInstantCraftCallback();
        }

        private void Unload()
        {
            _containerManager.RemoveContainers();
            ObjectCache.Clear<int>();
            ObjectCache.Clear<float>();
            ObjectCache.Clear<ulong>();
            ObjectCache.Clear<Item.Flag>();

            _instance = null;
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Name == nameof(InstantCraft))
            {
                RefreshInstantCraftCallback();
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            _supplierManager.RemoveSupplier(plugin);
            _containerManager.RemoveContainers(plugin);

            if (plugin.Name == nameof(InstantCraft))
            {
                RefreshInstantCraftCallback();
            }
        }

        private void OnEntitySaved(BasePlayer player, BaseNetworkable.SaveInfo saveInfo)
        {
            SerializeForNetwork(player, saveInfo.msg.basePlayer.inventory.invMain);
        }

        private void OnInventoryNetworkUpdate(PlayerInventory inventory, ItemContainer container, ProtoBuf.UpdateItemContainer updatedItemContainer, PlayerInventory.Type inventoryType)
        {
            if (inventoryType != PlayerInventory.Type.Main)
                return;

            SerializeForNetwork(inventory.baseEntity, updatedItemContainer.container[0]);
        }

        private object OnInventoryItemsCount(PlayerInventory inventory, int itemId)
        {
            var itemQuery = new ItemIdQuery(itemId);
            return ObjectCache.Get(SumPlayerItems(inventory.baseEntity, ref itemQuery, countPlayerWearables: true));
        }

        private object OnInventoryItemsTake(PlayerInventory inventory, List<Item> collect, int itemId, int amount)
        {
            var itemQuery = new ItemIdQuery(itemId);
            return ObjectCache.Get(TakePlayerItems(inventory.baseEntity, ref itemQuery, amount, collect, includePlayerWearables: true));
        }

        private object OnInventoryItemsFind(PlayerInventory inventory, int itemId)
        {
            var itemQuery = new ItemIdQuery(itemId);
            var list = new List<Item>();
            FindPlayerItems(inventory.baseEntity, ref itemQuery, list, includePlayerWearables: true);
            return list;
        }

        private object OnInventoryItemFind(PlayerInventory inventory, int itemId)
        {
            var itemQuery = new ItemIdQuery(itemId);
            _reusableItemList.Clear();
            FindPlayerItems(inventory.baseEntity, ref itemQuery, _reusableItemList, includePlayerWearables: true);
            return _reusableItemList.FirstOrDefault();
        }

        private object OnInventoryAmmoFind(PlayerInventory inventory, List<Item> collect, AmmoTypes ammoType)
        {
            FindPlayerAmmo(inventory.baseEntity, ammoType, collect);
            return False;
        }

        private Item OnInventoryAmmoItemFind(PlayerInventory inventory, ItemDefinition itemDefinition)
        {
            if ((object)itemDefinition == null)
                return null;

            _reusableItemList.Clear();
            var itemQuery = new ItemIdQuery(itemDefinition.itemid);
            FindPlayerItems(inventory.baseEntity, ref itemQuery, _reusableItemList, includePlayerWearables: true);
            return _reusableItemList.FirstOrDefault();
        }

        private Item OnInventoryAmmoItemFind(PlayerInventory inventory, AmmoTypes ammoType)
        {
            _reusableItemList.Clear();
            FindPlayerAmmo(inventory.baseEntity, ammoType, _reusableItemList);
            return _reusableItemList.FirstOrDefault();
        }

        private object OnIngredientsCollect(ItemCrafter itemCrafter, ItemBlueprint blueprint, ItemCraftTask task, int amount, BasePlayer player)
        {
            ExposedHooks.OnIngredientsDetermine(_overridenIngredients, blueprint, amount, player);

            var collect = new List<Item>();
            if (_overridenIngredients.Count > 0)
            {
                foreach (var entry in _overridenIngredients)
                {
                    if (entry.Value <= 0)
                        continue;

                    var itemQuery = new ItemIdQuery(entry.Key);
                    TakePlayerItems(player, ref itemQuery, entry.Value, collect, task);
                }
            }
            else
            {
                for (var i = 0; i < blueprint.ingredients.Count; i++)
                {
                    var ingredient = blueprint.ingredients[i];
                    var itemQuery = new ItemIdQuery(ingredient.itemid);
                    TakePlayerItems(player, ref itemQuery, (int)ingredient.amount * amount, collect, task);
                }
            }

            for (var i = 0; i < collect.Count; i++)
            {
                collect[i].CollectedForCrafting(player);
            }

            task.takenItems = collect;
            return False;
        }

        private object CanCraft(ItemCrafter itemCrafter, ItemBlueprint blueprint, int amount, bool free)
        {
            if (_isBlockedByInstantCraft?.Invoke(blueprint.targetItem) == true)
                return null;

            var basePlayer = itemCrafter.baseEntity;
            ExposedHooks.OnIngredientsDetermine(_overridenIngredients, blueprint, amount, basePlayer);

            if (_overridenIngredients.Count > 0)
            {
                foreach (var entry in _overridenIngredients)
                {
                    if (entry.Value <= 0)
                        continue;

                    var itemQuery = new ItemIdQuery(entry.Key);
                    if (SumPlayerItems(basePlayer, ref itemQuery) < entry.Value)
                        return False;
                }
            }
            else
            {
                for (var i = 0; i < blueprint.ingredients.Count; i++)
                {
                    var ingredient = blueprint.ingredients[i];
                    var itemQuery = new ItemIdQuery(ingredient.itemid);
                    if (SumPlayerItems(basePlayer, ref itemQuery) < ingredient.amount * amount)
                        return False;
                }
            }

            return True;
        }

        #endregion

        #region API

        private class ApiInstance
        {
            public readonly Dictionary<string, object> ApiWrapper;

            private readonly ItemRetriever _plugin;
            private SupplierManager _supplierManager => _plugin._supplierManager;
            private ContainerManager _containerManager => _plugin._containerManager;

            public ApiInstance(ItemRetriever plugin)
            {
                _plugin = plugin;

                ApiWrapper = new Dictionary<string, object>
                {
                    [nameof(AddSupplier)] = new Action<Plugin, Dictionary<string, object>>(AddSupplier),
                    [nameof(RemoveSupplier)] = new Action<Plugin>(RemoveSupplier),
                    [nameof(HasContainer)] = new Func<BasePlayer, ItemContainer, bool>(HasContainer),
                    [nameof(AddContainer)] = new Action<Plugin, BasePlayer, IItemContainerEntity, ItemContainer, Func<Plugin, BasePlayer, ItemContainer, bool>>(AddContainer),
                    [nameof(RemoveContainer)] = new Action<Plugin, BasePlayer, ItemContainer>(RemoveContainer),
                    [nameof(RemoveAllContainersForPlayer)] = new Action<Plugin, BasePlayer>(RemoveAllContainersForPlayer),
                    [nameof(RemoveAllContainersForPlugin)] = new Action<Plugin>(RemoveAllContainersForPlugin),
                    [nameof(FindPlayerItems)] = new Action<BasePlayer, Dictionary<string, object>, List<Item>>(FindPlayerItems),
                    [nameof(SumPlayerItems)] = new Func<BasePlayer, Dictionary<string, object>, int>(SumPlayerItems),
                    [nameof(TakePlayerItems)] = new Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int>(TakePlayerItems),
                    [nameof(FindPlayerAmmo)] = new Action<BasePlayer, AmmoTypes, List<Item>>(FindPlayerAmmo),
                };
            }

            public void AddSupplier(Plugin plugin, Dictionary<string, object> spec)
            {
                if (plugin == null)
                    throw new ArgumentNullException(nameof(plugin));

                _supplierManager.AddSupplier(plugin, spec);
            }

            public void RemoveSupplier(Plugin plugin)
            {
                if (plugin == null)
                    throw new ArgumentNullException(nameof(plugin));

                _supplierManager.RemoveSupplier(plugin);
            }

            public bool HasContainer(BasePlayer player, ItemContainer container)
            {
                return _containerManager.HasContainer(player, container);
            }

            public void AddContainer(Plugin plugin, BasePlayer player, IItemContainerEntity containerEntity, ItemContainer container, Func<Plugin, BasePlayer, ItemContainer, bool> canUseContainer)
            {
                if (_containerManager.AddContainer(plugin, player, containerEntity, container, canUseContainer))
                {
                    MarkInventoryDirty(player);
                }
            }

            public void RemoveContainer(Plugin plugin, BasePlayer player, ItemContainer container)
            {
                if (_containerManager.RemoveContainer(plugin, player, container))
                {
                    MarkInventoryDirty(player);
                }
            }

            public void RemoveAllContainersForPlayer(Plugin plugin, BasePlayer player)
            {
                if (_containerManager.RemoveContainers(plugin, player))
                {
                    MarkInventoryDirty(player);
                }
            }

            public void RemoveAllContainersForPlugin(Plugin plugin)
            {
                var updatedPlayers = _containerManager.RemoveContainers(plugin);
                if ((updatedPlayers?.Count ?? 0) > 0)
                {
                    foreach (var player in updatedPlayers)
                    {
                        MarkInventoryDirty(player);
                    }
                }
            }

            public void FindPlayerItems(BasePlayer player, Dictionary<string, object> itemQueryDict, List<Item> collect)
            {
                var itemQuery = ItemQuery.Parse(itemQueryDict);
                _plugin.FindPlayerItems(player, ref itemQuery, collect);
            }

            public int SumPlayerItems(BasePlayer player, Dictionary<string, object> itemQueryDict)
            {
                var itemQuery = ItemQuery.Parse(itemQueryDict);
                return _plugin.SumPlayerItems(player, ref itemQuery);
            }

            public int TakePlayerItems(BasePlayer player, Dictionary<string, object> itemQueryDict, int amount, List<Item> collect)
            {
                var itemQuery = ItemQuery.Parse(itemQueryDict);
                return _plugin.TakePlayerItems(player, ref itemQuery, amount, collect);
            }

            public void FindPlayerAmmo(BasePlayer player, AmmoTypes ammoType, List<Item> collect)
            {
                _plugin.FindPlayerAmmo(player, ammoType, collect);
            }
        }

        [HookMethod(nameof(API_GetApi))]
        public Dictionary<string, object> API_GetApi()
        {
            return _api.ApiWrapper;
        }

        [HookMethod(nameof(API_AddSupplier))]
        public void API_AddSupplier(Plugin plugin, Dictionary<string, object> spec)
        {
            _api.AddSupplier(plugin, spec);
        }

        [HookMethod(nameof(API_RemoveSupplier))]
        public void API_RemoveSupplier(Plugin plugin)
        {
            _api.RemoveSupplier(plugin);
        }

        [HookMethod(nameof(API_HasContainer))]
        public object API_HasContainer(BasePlayer player, ItemContainer container)
        {
            return ObjectCache.Get(_api.HasContainer(player, container));
        }

        [HookMethod(nameof(API_AddContainer))]
        public void API_AddContainer(Plugin plugin, BasePlayer player, IItemContainerEntity containerEntity, ItemContainer container, Func<Plugin, BasePlayer, ItemContainer, bool> canUseContainer = null)
        {
            _api.AddContainer(plugin, player, containerEntity, container, canUseContainer);
        }

        [HookMethod(nameof(API_RemoveContainer))]
        public void API_RemoveContainer(Plugin plugin, BasePlayer player, ItemContainer container)
        {
            _api.RemoveContainer(plugin, player, container);
        }

        [HookMethod(nameof(API_RemoveAllContainersForPlayer))]
        public void API_RemoveAllContainersForPlayer(Plugin plugin, BasePlayer player)
        {
            _api.RemoveAllContainersForPlayer(plugin, player);
        }

        [HookMethod(nameof(API_RemoveAllContainersForPlugin))]
        public void API_RemoveAllContainersForPlugin(Plugin plugin)
        {
            _api.RemoveAllContainersForPlugin(plugin);
        }

        [HookMethod(nameof(API_FindPlayerItems))]
        public void API_FindPlayerItems(BasePlayer player, Dictionary<string, object> itemQuery, List<Item> collect)
        {
            _api.FindPlayerItems(player, itemQuery, collect);
        }

        [HookMethod(nameof(API_SumPlayerItems))]
        public object API_SumPlayerItems(BasePlayer player, Dictionary<string, object> itemQuery)
        {
            return ObjectCache.Get(_api.SumPlayerItems(player, itemQuery));
        }

        [HookMethod(nameof(API_TakePlayerItems))]
        public object API_TakePlayerItems(BasePlayer player, Dictionary<string, object> itemQuery, int amount, List<Item> collect)
        {
            return ObjectCache.Get(_api.TakePlayerItems(player, itemQuery, amount, collect));
        }

        [HookMethod(nameof(API_FindPlayerAmmo))]
        public void API_FindPlayerAmmo(BasePlayer player, AmmoTypes ammoType, List<Item> collect)
        {
            _api.FindPlayerAmmo(player, ammoType, collect);
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static void OnIngredientsDetermine(Dictionary<int, int> overridenIngredients, ItemBlueprint blueprint, int amount, BasePlayer player)
            {
                overridenIngredients.Clear();
                Interface.CallHook("OnIngredientsDetermine", overridenIngredients, blueprint, ObjectCache.Get(amount), player);
            }
        }

        #endregion

        #region Helper Methods

        private static void MarkInventoryDirty(BasePlayer player)
        {
            player.inventory.containerMain?.MarkDirty();
        }

        private static int GetHighestUsedSlot(ProtoBuf.ItemContainer containerData)
        {
            var highestUsedSlot = -1;

            for (var i = 0; i < containerData.contents.Count; i++)
            {
                var item = containerData.contents[i];
                if (item.slot > highestUsedSlot)
                {
                    highestUsedSlot = item.slot;
                }
            }

            return highestUsedSlot;
        }

        private void RefreshInstantCraftCallback()
        {
            _isBlockedByInstantCraft = InstantCraft?.Call("API_GetIsItemBlockedCallback") as Func<ItemDefinition, bool>;
        }

        private void SerializeForNetwork(BasePlayer player, ProtoBuf.ItemContainer containerData)
        {
            if (containerData == null)
                return;

            var firstAvailableInvisibleSlot = Math.Max(InventorySize, GetHighestUsedSlot(containerData) + 1);
            var nextInvisibleSlot = firstAvailableInvisibleSlot;

            var itemsAdded = ItemUtils.SerializeForNetwork(_customItemDefinitionTracker, player.inventory.containerMain.itemList, containerData, ref nextInvisibleSlot, addChildContainersOnly: true)
                + ItemUtils.SerializeForNetwork(_customItemDefinitionTracker, player.inventory.containerBelt.itemList, containerData, ref nextInvisibleSlot, addChildContainersOnly: true)
                + ItemUtils.SerializeForNetwork(_customItemDefinitionTracker, player.inventory.containerWear.itemList, containerData, ref nextInvisibleSlot, addChildContainersOnly: true)
                + _supplierManager.SerializeForNetwork(player, containerData, ref nextInvisibleSlot)
                + _containerManager.SerializeForNetwork(player, containerData, ref nextInvisibleSlot);

            if (itemsAdded > 0)
            {
                if (containerData.slots >= 24)
                {
                    containerData.slots = firstAvailableInvisibleSlot + itemsAdded;
                }
            }
        }

        private void FindPlayerItems<T>(BasePlayer player, ref T itemQuery, List<Item> collect, bool includePlayerWearables = false) where T : IItemQuery
        {
            _supplierManager.FindPlayerItems(player, ref itemQuery, collect, beforeInventory: true);
            ItemUtils.FindItems(player.inventory.containerMain.itemList, ref itemQuery, collect);
            ItemUtils.FindItems(player.inventory.containerBelt.itemList, ref itemQuery, collect);
            ItemUtils.FindItems(player.inventory.containerWear.itemList, ref itemQuery, collect, childItemsOnly: !includePlayerWearables);
            _supplierManager.FindPlayerItems(player, ref itemQuery, collect);
            _containerManager.FindPlayerItems(player, ref itemQuery, collect);
        }

        private int SumPlayerItems<T>(BasePlayer player, ref T itemQuery, bool countPlayerWearables = false) where T : IItemQuery
        {
            return ItemUtils.SumItems(player.inventory.containerMain.itemList, ref itemQuery)
                + ItemUtils.SumItems(player.inventory.containerBelt.itemList, ref itemQuery)
                + ItemUtils.SumItems(player.inventory.containerWear.itemList, ref itemQuery, childItemsOnly: !countPlayerWearables)
                + _supplierManager.SumPlayerItems(player, ref itemQuery)
                + _containerManager.SumPlayerItems(player, ref itemQuery);
        }

        private int TakePlayerItems<T>(BasePlayer player, ref T itemQuery, int amountToTake, List<Item> collect, ItemCraftTask itemCraftTask = null, bool includePlayerWearables = false) where T : IItemQuery
        {
            var amountTaken = _supplierManager.TakePlayerItems(player, ref itemQuery, amountToTake, collect, itemCraftTask, beforeInventory: true);
            if (amountTaken >= amountToTake)
                return amountTaken;

            amountTaken += ItemUtils.TakeItems(player.inventory.containerMain.itemList, ref itemQuery, amountToTake - amountTaken, collect);
            if (amountTaken >= amountToTake)
                return amountTaken;

            amountTaken += ItemUtils.TakeItems(player.inventory.containerBelt.itemList, ref itemQuery, amountToTake - amountTaken, collect);
            if (amountTaken >= amountToTake)
                return amountTaken;

            amountTaken += ItemUtils.TakeItems(player.inventory.containerWear.itemList, ref itemQuery, amountToTake - amountTaken, collect, childItemsOnly: !includePlayerWearables);
            if (amountTaken >= amountToTake)
                return amountTaken;

            amountTaken += _supplierManager.TakePlayerItems(player, ref itemQuery, amountToTake - amountTaken, collect, itemCraftTask);
            if (amountTaken >= amountToTake)
                return amountTaken;

            amountTaken += _containerManager.TakePlayerItems(player, ref itemQuery, amountToTake - amountTaken, collect);

            return amountTaken;
        }

        private void FindPlayerAmmo(BasePlayer player, AmmoTypes ammoType, List<Item> collect)
        {
            _supplierManager.FindPlayerAmmo(player, ammoType, collect, beforeInventory: true);
            player.inventory.containerMain?.FindAmmo(collect, ammoType);
            player.inventory.containerBelt?.FindAmmo(collect, ammoType);
            player.inventory.containerWear?.FindAmmo(collect, ammoType);
            _supplierManager.FindPlayerAmmo(player, ammoType, collect);
            _containerManager.FindPlayerAmmo(player, ammoType, collect);
        }

        #endregion

        #region Helper Classes

        private static class StringUtils
        {
            public static bool EqualsIgnoreCase(string a, string b)
            {
                return string.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;
            }
        }

        private static class ObjectCache
        {
            private static class StaticObjectCache<T>
            {
                private static readonly Dictionary<T, object> _cacheByValue = new();

                public static object Get(T value)
                {
                    if (!_cacheByValue.TryGetValue(value, out var cachedObject))
                    {
                        cachedObject = value;
                        _cacheByValue[value] = cachedObject;
                    }

                    return cachedObject;
                }

                public static void Clear()
                {
                    _cacheByValue.Clear();
                }
            }

            public static object Get<T>(T value)
            {
                return StaticObjectCache<T>.Get(value);
            }

            public static object Get(bool value)
            {
                return value ? True : False;
            }

            public static void Clear<T>()
            {
                StaticObjectCache<T>.Clear();
            }
        }

        private class CustomItemDefinitionTracker
        {
            private readonly HashSet<int> _customItemDefinitionIds = new();

            public bool IsCustomItemDefinition(ItemDefinition itemDefinition)
            {
                return itemDefinition.HasFlag(CustomItemDefinitionFlag);
            }

            public bool IsCustomItemDefinition(Item item)
            {
                return IsCustomItemDefinition(item.info);
            }

            public bool IsCustomItemDefinition(int itemId)
            {
                if (_customItemDefinitionIds.Contains(itemId))
                    return true;

                var itemDefinition = ItemManager.FindItemDefinition(itemId);
                if (itemDefinition == null)
                    return true;

                if (IsCustomItemDefinition(itemDefinition))
                {
                    _customItemDefinitionIds.Add(itemId);
                    return true;
                }

                return false;
            }
        }

        #endregion

        #region Item Utils

        private static class ItemUtils
        {
            public static int SerializeForNetwork(CustomItemDefinitionTracker customItemDefinitionTracker,
                List<Item> itemList, ProtoBuf.ItemContainer containerData, ref int nextInvisibleSlot, bool addChildContainersOnly = false)
            {
                var itemsAdded = 0;

                for (var i = 0; i < itemList.Count; i++)
                {
                    var item = itemList[i];
                    if (customItemDefinitionTracker.IsCustomItemDefinition(item))
                        continue;

                    if (!addChildContainersOnly)
                    {
                        var itemData = item.Save();
                        itemData.slot = nextInvisibleSlot++;
                        containerData.contents.Add(itemData);
                        itemsAdded++;
                    }

                    if (HasSearchableContainer(item, out var childItemList))
                    {
                        itemsAdded += SerializeForNetwork(customItemDefinitionTracker, childItemList, containerData, ref nextInvisibleSlot);
                    }
                }

                return itemsAdded;
            }

            public static int SerializeForNetwork(CustomItemDefinitionTracker customItemDefinitionTracker,
                List<ProtoBuf.Item> itemList, ProtoBuf.ItemContainer containerData, ref int nextInvisibleSlot)
            {
                var itemsAdded = 0;

                for (var i = 0; i < itemList.Count; i++)
                {
                    var itemData = itemList[i];
                    if (customItemDefinitionTracker.IsCustomItemDefinition(itemData.itemid))
                        continue;

                    itemData.slot = nextInvisibleSlot++;
                    if (itemData.UID.Value == 0)
                    {
                        // Items that don't have UIDs (fake items) need unique UIDs.
                        itemData.UID = new ItemId(ulong.MaxValue - (ulong)nextInvisibleSlot);
                    }

                    containerData.contents.Add(itemData);
                    itemsAdded++;

                    if (HasSearchableContainer(itemData, out var childItemList))
                    {
                        itemsAdded += SerializeForNetwork(customItemDefinitionTracker, childItemList, containerData, ref nextInvisibleSlot);
                    }
                }

                return itemsAdded;
            }

            public static void FindItems<T>(List<Item> itemList, ref T itemQuery, List<Item> collect, bool childItemsOnly = false) where T : IItemQuery
            {
                for (var i = 0; i < itemList.Count; i++)
                {
                    var item = itemList[i];
                    var usableAmount = childItemsOnly ? 0 : itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                    {
                        collect.Add(item);
                    }

                    if (HasSearchableContainer(item, out var childItemList))
                    {
                        FindItems(childItemList, ref itemQuery, collect);
                    }
                }
            }

            public static int SumItems<T>(List<Item> itemList, ref T itemQuery, bool childItemsOnly = false) where T : IItemQuery
            {
                var sum = 0;

                for (var i = 0; i < itemList.Count; i++)
                {
                    var item = itemList[i];
                    sum += childItemsOnly ? 0 : itemQuery.GetUsableAmount(item);

                    if (HasSearchableContainer(item, out var childItemList))
                    {
                        sum += SumItems(childItemList, ref itemQuery);
                    }
                }

                return sum;
            }

            public static int TakeItems<T>(List<Item> itemList, ref T itemQuery, int totalAmountToTake, List<Item> collect, bool childItemsOnly = false) where T : IItemQuery
            {
                var totalAmountTaken = 0;

                for (var i = itemList.Count - 1; i >= 0; i--)
                {
                    var amountToTake = totalAmountToTake - totalAmountTaken;
                    if (amountToTake <= 0)
                        break;

                    var item = itemList[i];
                    var usableAmount = childItemsOnly ? 0 : itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                    {
                        amountToTake = Math.Min(item.amount, amountToTake);

                        if (item.amount > amountToTake)
                        {
                            if (collect != null)
                            {
                                var splitItem = item.SplitItem(amountToTake);
                                var playerOwner = splitItem.GetOwnerPlayer();
                                if (playerOwner != null)
                                {
                                    splitItem.CollectedForCrafting(playerOwner);
                                }

                                collect.Add(splitItem);
                            }
                            else
                            {
                                item.amount -= amountToTake;
                                item.MarkDirty();
                            }
                        }
                        else
                        {
                            item.RemoveFromContainer();

                            if (collect != null)
                            {
                                collect.Add(item);
                            }
                            else
                            {
                                item.Remove();
                            }
                        }

                        totalAmountTaken += amountToTake;
                    }

                    if (HasSearchableContainer(item, out var childItemList))
                    {
                        totalAmountTaken += TakeItems(childItemList, ref itemQuery, amountToTake, collect);
                    }

                    if (totalAmountTaken >= totalAmountToTake)
                        return totalAmountTaken;
                }

                return totalAmountTaken;
            }

            private static bool IsSearchableItemDefinition(ItemDefinition itemDefinition)
            {
                return (itemDefinition.flags & (ItemDefinition.Flag.Backpack | SearchableItemDefinitionFlag)) != 0;
            }

            private static bool IsSearchableItemDefinition(int itemId)
            {
                var itemDefinition = ItemManager.FindItemDefinition(itemId);
                if ((object)itemDefinition == null)
                    return false;

                return IsSearchableItemDefinition(itemDefinition);
            }

            private static bool HasSearchableContainer(Item item, out List<Item> itemList)
            {
                itemList = item.contents?.itemList;
                if (itemList is not { Count: > 0 })
                    return false;

                if (item.HasFlag(SearchableItemFlag))
                    return true;

                if (item.HasFlag(UnsearchableItemFlag))
                    return false;

                return IsSearchableItemDefinition(item.info);
            }

            private static bool HasSearchableContainer(ProtoBuf.Item itemData, out List<ProtoBuf.Item> itemList)
            {
                itemList = itemData.contents?.contents;
                if (itemList is not { Count: > 0 })
                    return false;

                var itemFlags = (Item.Flag)itemData.flags;
                if (itemFlags.HasFlag(SearchableItemFlag))
                    return true;

                if (itemFlags.HasFlag(UnsearchableItemFlag))
                    return false;

                return IsSearchableItemDefinition(itemData.itemid);
            }
        }

        #endregion

        #region Item Query

        private interface IItemQuery
        {
            int GetUsableAmount(Item item);
            void PopulateItemQuery(Dictionary<string, object> itemQueryDict);
        }

        private struct ItemIdQuery : IItemQuery
        {
            public int ItemId;

            public ItemIdQuery(int itemId)
            {
                ItemId = itemId;
            }

            public int GetUsableAmount(Item item)
            {
                return ItemId != item.info.itemid ? 0 : item.amount;
            }

            public void PopulateItemQuery(Dictionary<string, object> itemQueryDict)
            {
                itemQueryDict.Clear();
                itemQueryDict[ItemQuery.ItemIdField] = ObjectCache.Get(ItemId);
            }
        }

        private struct ItemQuery : IItemQuery
        {
            public const string BlueprintIdField = "BlueprintId";
            public const string DisplayNameField = "DisplayName";
            public const string DataIntField = "DataInt";
            public const string FlagsContainField = "FlagsContain";
            public const string FlagsEqualField = "FlagsEqual";
            public const string IgnoreItemField = "IgnoreItem";
            public const string ItemDefinitionField = "ItemDefinition";
            public const string ItemIdField = "ItemId";
            public const string MinConditionField = "MinCondition";
            public const string RequireEmptyField = "RequireEmpty";
            public const string SkinIdField = "SkinId";

            public static ItemQuery Parse(Dictionary<string, object> raw)
            {
                var itemQuery = new ItemQuery();

                GetOption(raw, BlueprintIdField, out itemQuery.BlueprintId);
                GetOption(raw, DisplayNameField, out itemQuery.DisplayName);
                GetOption(raw, DataIntField, out itemQuery.DataInt);
                GetOption(raw, FlagsContainField, out itemQuery.FlagsContain);
                GetOption(raw, FlagsEqualField, out itemQuery.FlagsEqual);
                GetOption(raw, IgnoreItemField, out itemQuery.IgnoreItem);
                GetOption(raw, ItemDefinitionField, out itemQuery.ItemDefinition);
                GetOption(raw, ItemIdField, out itemQuery.ItemId);
                GetOption(raw, MinConditionField, out itemQuery.MinCondition);
                GetOption(raw, RequireEmptyField, out itemQuery.RequireEmpty);
                GetOption(raw, SkinIdField, out itemQuery.SkinId);

                return itemQuery;
            }

            private static void GetOption<T>(Dictionary<string, object> dict, string key, out T result)
            {
                result = dict.TryGetValue(key, out var value) && value is T valueOfType
                    ? valueOfType
                    : default;
            }

            public int? BlueprintId;
            public int? DataInt;
            public string DisplayName;
            public Item.Flag? FlagsContain;
            public Item.Flag? FlagsEqual;
            public Item IgnoreItem;
            public ItemDefinition ItemDefinition;
            public int? ItemId;
            public float MinCondition;
            public bool RequireEmpty;
            public ulong? SkinId;

            public int GetUsableAmount(Item item)
            {
                if (IgnoreItem != null && item == IgnoreItem)
                    return 0;

                var itemId = GetItemId();
                if (itemId.HasValue && itemId != item.info.itemid)
                    return 0;

                if (SkinId.HasValue && SkinId != item.skin)
                    return 0;

                if (BlueprintId.HasValue && BlueprintId != item.blueprintTarget)
                    return 0;

                if (DataInt.HasValue && DataInt != (item.instanceData?.dataInt ?? 0))
                    return 0;

                if (FlagsContain.HasValue && !item.flags.HasFlag(FlagsContain.Value))
                    return 0;

                if (FlagsEqual.HasValue && FlagsEqual != item.flags)
                    return 0;

                if (MinCondition > 0 && HasCondition() && (item.conditionNormalized < MinCondition || item.maxConditionNormalized < MinCondition))
                    return 0;

                if (!string.IsNullOrEmpty(DisplayName) && !StringUtils.EqualsIgnoreCase(DisplayName, item.name))
                    return 0;

                return RequireEmpty && item.contents?.itemList?.Count > 0
                    ? Math.Max(0, item.amount - 1)
                    : item.amount;
            }

            public void PopulateItemQuery(Dictionary<string, object> itemQueryDict)
            {
                itemQueryDict.Clear();

                if (BlueprintId.HasValue)
                    itemQueryDict[BlueprintIdField] = ObjectCache.Get(BlueprintId.Value);

                if (DataInt.HasValue)
                    itemQueryDict[DataIntField] = ObjectCache.Get(DataInt.Value);

                if (DisplayName != null)
                    itemQueryDict[DisplayNameField] = DisplayName;

                if (FlagsContain.HasValue)
                    itemQueryDict[FlagsContainField] = ObjectCache.Get(FlagsContain.Value);

                if (FlagsEqual.HasValue)
                    itemQueryDict[FlagsEqualField] = ObjectCache.Get(FlagsEqual.Value);

                var itemId = GetItemId();
                if (itemId.HasValue)
                    itemQueryDict[ItemIdField] = ObjectCache.Get(itemId.Value);

                if (MinCondition > 0)
                    itemQueryDict[MinConditionField] = ObjectCache.Get(MinCondition);

                if (RequireEmpty)
                    itemQueryDict[RequireEmptyField] = True;

                if (SkinId.HasValue)
                    itemQueryDict[SkinIdField] = ObjectCache.Get(SkinId.Value);

                if (IgnoreItem != null)
                    itemQueryDict[IgnoreItemField] = IgnoreItem;
            }

            private int? GetItemId()
            {
                if (ItemDefinition != null)
                    return ItemDefinition?.itemid ?? ItemId;

                return ItemId;
            }

            private ItemDefinition GetItemDefinition()
            {
                if ((object)ItemDefinition == null && ItemId.HasValue)
                {
                    ItemDefinition = ItemManager.FindItemDefinition(ItemId.Value);
                }

                return ItemDefinition;
            }

            private bool HasCondition()
            {
                return GetItemDefinition()?.condition.enabled ?? false;
            }
        }

        #endregion

        #region Item Supplier Manager

        private class ItemSupplier
        {
            public static ItemSupplier FromSpec(Plugin plugin, Dictionary<string, object> spec)
            {
                var supplier = new ItemSupplier { Plugin = plugin };

                GetOption(spec, "Priority", out supplier.Priority);
                GetOption(spec, "FindPlayerItems", out supplier.FindPlayerItems);
                GetOption(spec, "SumPlayerItems", out supplier.SumPlayerItems);
                GetOption(spec, "TakePlayerItems", out supplier.TakePlayerItems);
                GetOption(spec, "TakePlayerItemsV2", out supplier.TakePlayerItemsV2);
                GetOption(spec, "FindPlayerAmmo", out supplier.FindPlayerAmmo);
                GetOption(spec, "SerializeForNetwork", out supplier.SerializeForNetwork);

                return supplier;
            }

            private static void GetOption<T>(Dictionary<string, object> dict, string key, out T result)
            {
                result = dict.TryGetValue(key, out var value) && value is T valueOfType
                    ? valueOfType
                    : default;
            }

            public Plugin Plugin { get; private set; }
            public int Priority;
            public Action<BasePlayer, Dictionary<string, object>, List<Item>> FindPlayerItems;
            public Func<BasePlayer, Dictionary<string, object>, int> SumPlayerItems;
            public Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int> TakePlayerItems;
            public Func<BasePlayer, Dictionary<string, object>, int, List<Item>, ItemCraftTask, int> TakePlayerItemsV2;
            public Action<BasePlayer, AmmoTypes, List<Item>> FindPlayerAmmo;
            public Action<BasePlayer, List<ProtoBuf.Item>> SerializeForNetwork;
        }

        private class SupplierManager
        {
            private static void RemoveSupplier(List<ItemSupplier> supplierList, Plugin plugin)
            {
                for (var i = 0; i < supplierList.Count; i++)
                {
                    var supplier = supplierList[i];
                    if (supplier.Plugin.Name != plugin.Name)
                        continue;

                    supplierList.RemoveAt(i);
                    return;
                }
            }

            private static void SortSupplierList(List<ItemSupplier> supplierList)
            {
                supplierList.Sort((a, b) =>
                {
                    var priorityOrder = a.Priority.CompareTo(b.Priority);
                    if (priorityOrder != 0)
                        return priorityOrder;

                    return string.Compare(a.Plugin.Name, b.Plugin.Name, StringComparison.OrdinalIgnoreCase);
                });
            }

            private CustomItemDefinitionTracker _customItemDefinitionTracker;
            // Use a list with standard for loops for high performance.
            private List<ItemSupplier> _allSuppliers = new();
            private List<ItemSupplier> _beforeInventorySuppliers = new();
            private List<ItemSupplier> _afterInventorySuppliers = new();

            private List<ProtoBuf.Item> _reusableItemListForNetwork = new(32);
            private Dictionary<string, object> _reusableItemQuery = new();

            public SupplierManager(CustomItemDefinitionTracker customItemDefinitionTracker)
            {
                _customItemDefinitionTracker = customItemDefinitionTracker;
            }

            public void AddSupplier(Plugin plugin, Dictionary<string, object> spec)
            {
                RemoveSupplier(plugin);
                var supplier = ItemSupplier.FromSpec(plugin, spec);

                _allSuppliers.Add(supplier);

                if (supplier.Priority < 0)
                {
                    _beforeInventorySuppliers.Add(supplier);
                    SortSupplierList(_beforeInventorySuppliers);
                }
                else
                {
                    _afterInventorySuppliers.Add(supplier);
                    SortSupplierList(_afterInventorySuppliers);
                }
            }

            public void RemoveSupplier(Plugin plugin)
            {
                RemoveSupplier(_allSuppliers, plugin);
                RemoveSupplier(_beforeInventorySuppliers, plugin);
                RemoveSupplier(_afterInventorySuppliers, plugin);
            }

            public int SerializeForNetwork(BasePlayer player, ProtoBuf.ItemContainer containerData, ref int nextInvisibleSlot)
            {
                if (_allSuppliers.Count == 0)
                    return 0;

                _reusableItemListForNetwork.Clear();

                for (var i = 0; i < _allSuppliers.Count; i++)
                {
                    _allSuppliers[i].SerializeForNetwork?.Invoke(player, _reusableItemListForNetwork);
                }

                var itemsAdded = ItemUtils.SerializeForNetwork(_customItemDefinitionTracker, _reusableItemListForNetwork, containerData, ref nextInvisibleSlot);

                _reusableItemListForNetwork.Clear();

                return itemsAdded;
            }

            public void FindPlayerItems<T>(BasePlayer player, ref T itemQuery, List<Item> collect, bool beforeInventory = false) where T : IItemQuery
            {
                var suppliers = beforeInventory ? _beforeInventorySuppliers : _afterInventorySuppliers;
                if (suppliers.Count == 0)
                    return;

                itemQuery.PopulateItemQuery(_reusableItemQuery);

                for (var i = 0; i < suppliers.Count; i++)
                {
                    suppliers[i].FindPlayerItems?.Invoke(player, _reusableItemQuery, collect);
                }
            }

            public int SumPlayerItems<T>(BasePlayer player, ref T itemQuery) where T : IItemQuery
            {
                if (_allSuppliers.Count == 0)
                    return 0;

                itemQuery.PopulateItemQuery(_reusableItemQuery);

                var sum = 0;

                for (var i = 0; i < _allSuppliers.Count; i++)
                {
                    sum += _allSuppliers[i].SumPlayerItems?.Invoke(player, _reusableItemQuery) ?? 0;
                }

                return sum;
            }

            public int TakePlayerItems<T>(BasePlayer player, ref T itemQuery, int amountToTake, List<Item> collect, ItemCraftTask itemCraftTask, bool beforeInventory = false) where T : IItemQuery
            {
                var suppliers = beforeInventory ? _beforeInventorySuppliers : _afterInventorySuppliers;
                if (suppliers.Count == 0)
                    return 0;

                itemQuery.PopulateItemQuery(_reusableItemQuery);

                var amountTaken = 0;

                for (var i = 0; i < suppliers.Count; i++)
                {
                    amountTaken += suppliers[i].TakePlayerItemsV2?.Invoke(player, _reusableItemQuery, amountToTake - amountTaken, collect, itemCraftTask)
                        ?? suppliers[i].TakePlayerItems?.Invoke(player, _reusableItemQuery, amountToTake - amountTaken, collect)
                        ?? 0;

                    if (amountTaken >= amountToTake)
                        return amountTaken;
                }

                return amountTaken;
            }

            public void FindPlayerAmmo(BasePlayer player, AmmoTypes ammoType, List<Item> collect, bool beforeInventory = false)
            {
                var suppliers = beforeInventory ? _beforeInventorySuppliers : _afterInventorySuppliers;
                if (suppliers.Count == 0)
                    return;

                for (var i = 0; i < suppliers.Count; i++)
                {
                    suppliers[i].FindPlayerAmmo?.Invoke(player, ammoType, collect);
                }
            }
        }

        #endregion

        #region Container Manager

        private class EntityTracker : FacepunchBehaviour
        {
            public static EntityTracker AddToEntity(BaseEntity entity, ContainerManager containerManager)
            {
                var entityTracker = entity.gameObject.AddComponent<EntityTracker>();
                entityTracker._entity = entity;
                entityTracker._containerManager = containerManager;
                return entityTracker;
            }

            private BaseEntity _entity;
            private ContainerManager _containerManager;
            private List<ContainerEntry> _containerList = new();

            public void AddContainer(ContainerEntry containerEntry)
            {
                _containerList.Add(containerEntry);
            }

            public void RemoveContainer(ContainerEntry containerEntry)
            {
                if (!_containerList.Remove(containerEntry))
                    return;

                MarkInventoryDirty(containerEntry.Player);

                if (_containerList.Count == 0 && _entity != null && !_entity.IsDestroyed)
                {
                    DestroyImmediate(this);
                }
            }

            private void OnDestroy()
            {
                for (var i = _containerList.Count - 1; i >= 0; i--)
                {
                    _containerManager.RemoveContainer(_containerList[i]);
                }

                _containerManager.UnregisterEntity(_entity);
            }
        }

        private struct ContainerEntry
        {
            public Plugin Plugin;
            public BasePlayer Player;
            public EntityTracker EntityTracker;
            public ItemContainer Container;
            public Func<Plugin, BasePlayer, ItemContainer, bool> CanUseContainer;
            private Action _handleDirty;

            public bool IsValid => Container?.itemList != null;

            public void Activate()
            {
                var player = Player;
                _handleDirty = () => MarkInventoryDirty(player);
                Container.onDirty += _handleDirty;
            }

            public void Deactivate()
            {
                if (EntityTracker != null)
                {
                    EntityTracker.RemoveContainer(this);
                }

                Container.onDirty -= _handleDirty;
            }

            public bool CanUse()
            {
                return CanUseContainer?.Invoke(Plugin, Player, Container) ?? true;
            }
        }

        private class ContainerManager
        {
            private static bool HasContainer(List<ContainerEntry> containerList, ItemContainer container)
            {
                foreach (var containerEntry in containerList)
                {
                    if (containerEntry.Container == container)
                        return true;
                }

                return false;
            }

            private static bool RemoveEntries(List<ContainerEntry> containerList, Plugin plugin, BasePlayer player)
            {
                var anyRemoved = false;

                for (var i = containerList.Count - 1; i >= 0; i--)
                {
                    var containerEntry = containerList[i];
                    if (containerEntry.Plugin.Name == plugin.Name && containerEntry.Player == player)
                    {
                        containerList.RemoveAt(i);
                        containerEntry.Deactivate();
                        anyRemoved = true;
                    }
                }

                return anyRemoved;
            }

            private static bool RemoveEntry(List<ContainerEntry> containerList, Plugin plugin, BasePlayer player, ItemContainer container)
            {
                for (var i = containerList.Count - 1; i >= 0; i--)
                {
                    var containerEntry = containerList[i];
                    if (containerEntry.Plugin == plugin
                        && containerEntry.Player == player
                        && containerEntry.Container == container)
                    {
                        containerList.RemoveAt(i);
                        containerEntry.Deactivate();
                        return true;
                    }
                }

                return false;
            }

            private CustomItemDefinitionTracker _customItemDefinitionTracker;
            private Dictionary<ulong, List<ContainerEntry>> _playerContainerEntries = new();
            private Dictionary<BaseEntity, EntityTracker> _entityTrackers = new();

            public ContainerManager(CustomItemDefinitionTracker customItemDefinitionTracker)
            {
                _customItemDefinitionTracker = customItemDefinitionTracker;
            }

            public void UnregisterEntity(BaseEntity entity)
            {
                _entityTrackers.Remove(entity);
            }

            public bool HasContainer(BasePlayer player, ItemContainer container)
            {
                var containerList = GetContainerList(player);
                return containerList != null && HasContainer(containerList, container);
            }

            public bool AddContainer(Plugin plugin, BasePlayer player, IItemContainerEntity containerEntity, ItemContainer container, Func<Plugin, BasePlayer, ItemContainer, bool> canUseContainer = null)
            {
                var containerList = GetContainerList(player);
                if (containerList == null)
                {
                    containerList = new List<ContainerEntry>();
                    _playerContainerEntries[player.userID] = containerList;
                }

                if (HasContainer(containerList, container))
                    return false;

                var containerEntry = new ContainerEntry
                {
                    Plugin = plugin,
                    Player = player,
                    Container = container,
                    CanUseContainer = canUseContainer,
                };

                containerEntry.Activate();

                var entity = containerEntity as BaseEntity;
                if ((object)entity != null)
                {
                    if (!_entityTrackers.TryGetValue(entity, out var entityTracker))
                    {
                        entityTracker = EntityTracker.AddToEntity(entity, this);
                        _entityTrackers[entity] = entityTracker;
                    }

                    containerEntry.EntityTracker = entityTracker;
                    entityTracker.AddContainer(containerEntry);
                }

                containerList.Add(containerEntry);
                return true;
            }

            public bool RemoveContainer(Plugin plugin, BasePlayer player, ItemContainer container)
            {
                var containerList = GetContainerList(player);
                if (containerList == null)
                    return false;

                var removed = RemoveEntry(containerList, plugin, player, container);

                if (containerList.Count == 0)
                {
                    _playerContainerEntries.Remove(player.userID);
                }

                return removed;
            }

            public bool RemoveContainer(ContainerEntry containerEntry)
            {
                return RemoveContainer(containerEntry.Plugin, containerEntry.Player, containerEntry.Container);
            }

            public bool RemoveContainers(Plugin plugin, BasePlayer player)
            {
                var anyRemoved = false;

                var containerList = GetContainerList(player);
                if (containerList != null)
                {
                    anyRemoved |= RemoveEntries(containerList, plugin, player);

                    if (containerList.Count == 0)
                    {
                        _playerContainerEntries.Remove(player.userID);
                    }
                }

                return anyRemoved;
            }

            public HashSet<BasePlayer> RemoveContainers(Plugin plugin)
            {
                HashSet<BasePlayer> updatedPlayers = null;

                List<ulong> removePlayerIds = null;

                foreach (var (player, containerList) in _playerContainerEntries)
                {
                    List<ContainerEntry> removeContainers = null;

                    foreach (var containerEntry in containerList)
                    {
                        if (containerEntry.Plugin == plugin)
                        {
                            removeContainers ??= new List<ContainerEntry>();
                            removeContainers.Add(containerEntry);

                            updatedPlayers ??= new HashSet<BasePlayer>();
                            updatedPlayers.Add(containerEntry.Player);
                        }
                    }

                    if (removeContainers != null)
                    {
                        foreach (var containerEntry in removeContainers)
                        {
                            containerList.Remove(containerEntry);
                            containerEntry.Deactivate();
                        }
                    }

                    if (containerList.Count == 0)
                    {
                        removePlayerIds ??= new List<ulong>();
                        removePlayerIds.Add(player);
                    }
                }

                if (removePlayerIds != null)
                {
                    foreach (var playerId in removePlayerIds)
                    {
                        _playerContainerEntries.Remove(playerId);
                    }
                }

                return updatedPlayers;
            }

            public void RemoveContainers()
            {
                foreach (var containerList in _playerContainerEntries.Values)
                {
                    foreach (var containerEntry in containerList)
                    {
                        containerEntry.Deactivate();
                    }
                }
            }

            public List<ContainerEntry> GetContainerList(BasePlayer player)
            {
                return _playerContainerEntries.GetValueOrDefault(player.userID);
            }

            public int SerializeForNetwork(BasePlayer player, ProtoBuf.ItemContainer containerData, ref int nextInvisibleSlot)
            {
                var containerList = GetContainerList(player);
                if (containerList == null)
                    return 0;

                var itemsAdded = 0;

                for (var i = 0; i < containerList.Count; i++)
                {
                    var containerEntry = containerList[i];
                    if (!containerEntry.IsValid || !containerEntry.CanUse())
                        continue;

                    itemsAdded += ItemUtils.SerializeForNetwork(_customItemDefinitionTracker, containerEntry.Container.itemList, containerData, ref nextInvisibleSlot);
                }

                return itemsAdded;
            }

            public void FindPlayerItems<T>(BasePlayer player, ref T itemQuery, List<Item> collect) where T : IItemQuery
            {
                var containerList = GetContainerList(player);
                if (containerList == null)
                    return;

                for (var i = 0; i < containerList.Count; i++)
                {
                    var containerEntry = containerList[i];
                    if (!containerEntry.IsValid || !containerEntry.CanUse())
                        continue;

                    ItemUtils.FindItems(containerEntry.Container.itemList, ref itemQuery, collect);
                }
            }

            public int SumPlayerItems<T>(BasePlayer player, ref T itemQuery) where T : IItemQuery
            {
                var containerList = GetContainerList(player);
                if (containerList == null)
                    return 0;

                var sum = 0;

                for (var i = 0; i < containerList.Count; i++)
                {
                    var containerEntry = containerList[i];
                    if (!containerEntry.IsValid || !containerEntry.CanUse())
                        continue;

                    sum += ItemUtils.SumItems(containerEntry.Container.itemList, ref itemQuery);
                }

                return sum;
            }

            public int TakePlayerItems<T>(BasePlayer player, ref T itemQuery, int amountToTake, List<Item> collect) where T : IItemQuery
            {
                var containerList = GetContainerList(player);
                if (containerList == null)
                    return 0;

                var amountTaken = 0;

                for (var i = 0; i < containerList.Count; i++)
                {
                    var containerEntry = containerList[i];
                    if (!containerEntry.IsValid || !containerEntry.CanUse())
                        continue;

                    amountTaken += ItemUtils.TakeItems(containerEntry.Container.itemList, ref itemQuery, amountToTake - amountTaken, collect);

                    if (amountTaken >= amountToTake)
                        return amountTaken;
                }

                return amountTaken;
            }

            public void FindPlayerAmmo(BasePlayer player, AmmoTypes ammoType, List<Item> collect)
            {
                var containerList = GetContainerList(player);
                if (containerList == null)
                    return;

                for (var i = 0; i < containerList.Count; i++)
                {
                    var containerEntry = containerList[i];
                    if (!containerEntry.CanUse())
                        continue;

                    containerEntry.Container.FindAmmo(collect, ammoType);
                }
            }
        }

        #endregion
    }
}


// --- End of file: ItemRetriever.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/infinite-ammo ---
// --- Original File Path: I/InfiniteAmmo/InfiniteAmmo.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Infinite Ammo", "collect_vood & Mughisi", "1.3.0")]
    [Description("Allows permission based Infinite Ammo")]
    public class InfiniteAmmo : CovalencePlugin
    {
        #region Fields

        private readonly string _usePermission = "infiniteammo.use";

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                { "Disabled", "You no longer have infinite ammo!" },
                { "Enabled", "You now have infinite ammo!" },
                { "NotAllowed", "You are not allowed to use this command." },
            }, this);
        }

        #endregion

        #region Configuration

        private ConfigurationFile _configuration;

        public class ConfigurationFile
        {
            [JsonProperty(PropertyName = "Ammo Toggle Command")]
            public string AmmoToggleCommand = "toggleammo";     
            
            [JsonProperty(PropertyName = "Chat Prefix")]
            public string ChatPrefix = "Infinite Ammo";    
            
            [JsonProperty(PropertyName = "Chat Prefix Color")]
            public string ChatPrefixColor = "#008800";            
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configuration = new ConfigurationFile();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _configuration = Config.ReadObject<ConfigurationFile>();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_configuration);

        #endregion

        #region Data

        private StoredData _storedData;

        public class StoredData
        {
            [JsonProperty(PropertyName = "Active Infinite Ammo Player UserIds", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> ActiveUsers = new List<ulong>();
        }
        
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);
        }

        private void Unload()
        {
            SaveData();
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

            permission.RegisterPermission(_usePermission, this);

            AddCovalenceCommand(_configuration.AmmoToggleCommand, nameof(CommandToggleAmmo));
        }

        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player)
        {
            if (!IsInfiniteAmmo(player.userID))
            {
                return;
            }

            var heldEntity = projectile.GetItem();
            heldEntity.condition = heldEntity.info.condition.max;

            if (projectile.primaryMagazine.contents > 0)
            {
                return;
            }

            projectile.primaryMagazine.contents = projectile.primaryMagazine.capacity;
            projectile.SendNetworkUpdateImmediate();
        }

        private void OnRocketLaunched(BasePlayer player)
        {
            if (!IsInfiniteAmmo(player.userID))
            {
                return;
            }

            var heldEntity = player.GetActiveItem();
            if (heldEntity == null)
            {
                return;
            }

            heldEntity.condition = heldEntity.info.condition.max;

            var weapon = heldEntity.GetHeldEntity() as BaseProjectile;
            if (weapon == null)
            {
                return;
            }

            if (weapon.primaryMagazine.contents > 0)
            {
                return;
            }

            weapon.primaryMagazine.contents = weapon.primaryMagazine.capacity;
            weapon.SendNetworkUpdateImmediate();
        }

        private void OnMeleeThrown(BasePlayer player, Item item)
        {
            if (!IsInfiniteAmmo(player.userID))
            {
                return;
            }

            var newMelee = ItemManager.CreateByItemID(item.info.itemid, item.amount, item.skin);
            newMelee._condition = item._condition;

            player.GiveItem(newMelee, BaseEntity.GiveItemReason.PickedUp);
        }

        private void OnServerSave()
        {
            SaveData();
        }

        #endregion

        #region Commands

        private void CommandToggleAmmo(IPlayer iPlayer, string cmd, string[] args)
        {
            var bPlayer = iPlayer.Object as BasePlayer;

            if (bPlayer == null)
            {
                return;
            }

            if (!CanUseInfiniteAmmo(bPlayer))
            {
                SendMessage(bPlayer, GetMessage("NotAllowed", bPlayer));
                return;
            }

            if (!IsInfiniteAmmo(bPlayer.userID))
            {
                _storedData.ActiveUsers.Add(bPlayer.userID);
                SendMessage(bPlayer, GetMessage("Enabled", bPlayer));
            }
            else
            {
                _storedData.ActiveUsers.Remove(bPlayer.userID);
                SendMessage(bPlayer, GetMessage("Disabled", bPlayer));
            }
        }

        #endregion

        #region Methods

        private void SendMessage(BasePlayer player, string message)
        {
            player.ChatMessage($"<color={_configuration.ChatPrefixColor}>{_configuration.ChatPrefix}</color>: {message}");
        }

        private bool IsInfiniteAmmo(ulong userId) => _storedData.ActiveUsers.Contains(userId);

        private bool CanUseInfiniteAmmo(BasePlayer player)
            => (player.IsAdmin || permission.UserHasPermission(player.UserIDString, _usePermission));

        private string GetMessage(string key, BasePlayer player, params string[] args) 
            => String.Format(lang.GetMessage(key, this, player.UserIDString), args);

        #endregion
    }
}

// --- End of file: InfiniteAmmo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-cost-calculator ---
// --- Original File Path: I/ItemCostCalculator/ItemCostCalculator.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Item Cost Calculator", "Absolut/Arainrr", "2.0.15", ResourceId = 2109)]
    internal class ItemCostCalculator : RustPlugin
    {
        #region Fields

        [PluginReference]
        private Plugin ImageLibrary, RustTranslationAPI;

        private readonly Dictionary<ItemDefinition, double> itemsCost = new Dictionary<ItemDefinition, double>();

        private enum FileType
        {
            GUIShop,
            ServerReward,
            Ingredient,
        }

        #endregion Fields

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                if (!configData.displayNames.ContainsKey(itemDefinition.shortname))
                {
                    configData.displayNames.Add(itemDefinition.shortname, itemDefinition.displayName.english);
                }
                var itemBlueprint = ItemManager.FindBlueprint(itemDefinition);
                if (itemBlueprint != null)
                {
                    foreach (var itemAmount in itemBlueprint.ingredients)
                    {
                        if (!configData.materials.ContainsKey(itemAmount.itemDef.shortname))
                        {
                            configData.materials.Add(itemAmount.itemDef.shortname, 1);
                        }
                    }
                }
                else if (!configData.noMaterials.ContainsKey(itemDefinition.shortname))
                {
                    configData.noMaterials.Add(itemDefinition.shortname, 1);
                }
            }
            foreach (var material in configData.materials)
            {
                if (configData.noMaterials.ContainsKey(material.Key))
                {
                    configData.noMaterials.Remove(material.Key);
                }
            }

            SaveConfig();
            CalculateItemsCost();
            foreach (FileType value in Enum.GetValues(typeof(FileType)))
            {
                CreateDataFile(value, lang.GetServerLanguage());
            }
        }

        #endregion Oxide Hooks

        #region Methods

        private void CalculateItemsCost()
        {
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                double amount;
                if (configData.materials.TryGetValue(itemDefinition.shortname, out amount))
                {
                    itemsCost.Add(itemDefinition, amount);
                    continue;
                }
                if (configData.noMaterials.TryGetValue(itemDefinition.shortname, out amount))
                {
                    itemsCost.Add(itemDefinition, amount);
                    continue;
                }

                var itemBlueprint = ItemManager.FindBlueprint(itemDefinition);
                if (itemBlueprint == null)
                    continue;

                double cost = 0;
                var ingredients = GetItemIngredients(itemBlueprint);
                foreach (var ingredient in ingredients)
                {
                    if (configData.materials.TryGetValue(ingredient.Key.shortname, out amount))
                    {
                        cost += ingredient.Value * amount;
                    }
                    else
                    {
                        if (itemsCost.TryGetValue(ingredient.Key, out amount))
                        {
                            cost += ingredient.Value * amount;
                        }
                    }
                }
                if (cost > 0)
                {
                    cost /= itemBlueprint.amountToCreate;
                    if (configData.gatherRateOffset > 0f)
                    {
                        cost *= configData.gatherRateOffset;
                    }
                    int rarity;
                    if (configData.rarityList.TryGetValue(itemDefinition.shortname, out rarity) && rarity > 0f)
                    {
                        cost += cost * (rarity / 100d);
                    }
                    float level;
                    if (configData.workbenchMultiplier.TryGetValue(itemBlueprint.workbenchLevelRequired, out level) && level > 0f)
                    {
                        cost += cost * (level / 100d);
                    }
                    itemsCost.Add(itemDefinition, cost);
                }
            }
        }

        private Dictionary<ItemDefinition, int> GetItemIngredients(ItemBlueprint itemBlueprint)
        {
            var ingredients = new Dictionary<ItemDefinition, int>();
            Dictionary<string, int> ingredientsOverride;
            if (configData.ingredientsOverride.TryGetValue(itemBlueprint.targetItem.shortname, out ingredientsOverride))
            {
                foreach (var ingredientOverride in ingredientsOverride)
                {
                    var itemDefinition = ItemManager.FindItemDefinition(ingredientOverride.Key);
                    if (itemDefinition != null)
                    {
                        ingredients.Add(itemDefinition, ingredientOverride.Value);
                    }
                }
                return ingredients;
            }
            foreach (var itemAmount in itemBlueprint.ingredients)
            {
                ingredients.Add(itemAmount.itemDef, (int)itemAmount.amount);
            }
            return ingredients;
        }

        private void CreateDataFile(FileType fileType, string language = null)
        {
            if (!string.IsNullOrEmpty(language) && RustTranslationAPI != null && !IsSupportedLanguage(language))
            {
                language = "en";
            }
            switch (fileType)
            {
                case FileType.GUIShop:
                {
                    var guiShopData = new ShopData();
                    var itemDisplayNames = new Dictionary<string, string>();
                    foreach (var entry in itemsCost)
                    {
                        var displayName = GetItemDisplayName(language, entry.Key);
                        if (string.IsNullOrEmpty(displayName))
                            continue;
                        var displayNameKey = displayName;
                        var imageUrl = GetImageUrl(entry.Key);
                        if (guiShopData.ShopItems.ContainsKey(displayNameKey))
                        {
                            displayNameKey += $"_Repeat_{UnityEngine.Random.Range(0, 9999)}";
                        }

                        if (!guiShopData.ShopItems.ContainsKey(displayNameKey))
                        {
                            itemDisplayNames.Add(entry.Key.shortname, displayNameKey);
                            guiShopData.ShopItems.Add(displayNameKey, new ShopItem
                            {
                                DisplayName = displayName,
                                Shortname = entry.Key.shortname,
                                EnableBuy = true,
                                EnableSell = true,
                                BuyPrice = Math.Round(entry.Value, configData.keepdecimal),
                                SellPrice = Math.Round(entry.Value * configData.recoveryRate, configData.keepdecimal),
                                Image = !string.IsNullOrEmpty(imageUrl) ? imageUrl : $"https://rustlabs.com/img/items180/{entry.Key.shortname}.png",
                            });
                        }
                    }

                    guiShopData.ShopItems = guiShopData.ShopItems.OrderBy(p => p.Key).ToDictionary(p => p.Key, o => o.Value);

                    foreach (var itemDefinition in ItemManager.GetItemDefinitions())
                    {
                        ShopCategory shopCategory;
                        var categoryKey = itemDefinition.category.ToString();
                        if (!guiShopData.ShopCategories.TryGetValue(categoryKey, out shopCategory))
                        {
                            shopCategory = new ShopCategory
                            {
                                DisplayName = categoryKey,
                                EnabledCategory = true,
                                Description = "You currently have {0} coins to spend in the " + categoryKey + " shop",
                            };
                            guiShopData.ShopCategories.Add(categoryKey, shopCategory);
                        }

                        string displayName;
                        if (!itemDisplayNames.TryGetValue(itemDefinition.shortname, out displayName))
                        {
                            displayName = itemDefinition.displayName.english;
                        }
                        if (!string.IsNullOrEmpty(displayName))
                        {
                            shopCategory.Items.Add(displayName);
                        }
                    }

                    SaveData("GUIShop", guiShopData);
                    PrintWarning("GUIShop successfully created, data file path: data/ItemCostCalculator/ItemCostCalculator_GUIShop.json");
                    return;
                }

                case FileType.ServerReward:
                {
                    var serverRewardsData = new Dictionary<string, RewardData>();
                    var skin = 0UL;
                    foreach (var entry in itemsCost)
                    {
                        var displayName = GetItemDisplayName(language, entry.Key);
                        if (string.IsNullOrEmpty(displayName))
                            continue;
                        var shortName = $"{entry.Key.shortname}_{skin}";
                        Category category;
                        if (!Enum.TryParse(entry.Key.category.ToString(), out category))
                        {
                            category = Category.None;
                        }
                        if (!serverRewardsData.ContainsKey(shortName))
                        {
                            serverRewardsData.Add(shortName, new RewardData
                            {
                                shortname = entry.Key.shortname,
                                amount = 1,
                                skinId = skin,
                                isBp = false,
                                category = category,
                                displayName = displayName,
                                cost = (int)Math.Round(entry.Value),
                                cooldown = 0,
                            });
                        }
                    }

                    serverRewardsData = serverRewardsData.OrderBy(p => p.Key).ToDictionary(p => p.Key, o => o.Value);
                    SaveData("ServerRewards", serverRewardsData);
                    PrintWarning("ServerRewards successfully created, data file path: data/ItemCostCalculator/ItemCostCalculator_ServerRewards.json");
                    return;
                }

                case FileType.Ingredient:
                {
                    var itemIngredients = new Dictionary<string, Ingredient>();
                    foreach (var itemDefinition in ItemManager.GetItemDefinitions())
                    {
                        var itemBlueprint = ItemManager.FindBlueprint(itemDefinition);
                        if (itemBlueprint != null)
                        {
                            Ingredient ingredient = new Ingredient();
                            ingredient.description = $"{string.Join(", ", itemBlueprint.ingredients.Select(x => $"'{x.itemDef.shortname} x{x.amount}"))}' to craft '{itemDefinition.shortname} x{itemBlueprint.amountToCreate}'.";
                            ingredient.amountToCreate = itemBlueprint.amountToCreate;
                            ingredient.ingredients = new Dictionary<string, int>();
                            foreach (var itemAmount in itemBlueprint.ingredients)
                            {
                                ingredient.ingredients.Add(itemAmount.itemDef.shortname, (int)itemAmount.amount);
                            }
                            itemIngredients.Add(itemDefinition.shortname, ingredient);
                        }
                    }
                    SaveData("ItemIngredients", itemIngredients);
                    PrintWarning("ItemIngredients successfully created, data file path: data/ItemCostCalculator/ItemCostCalculator_ItemIngredients.json");
                    return;
                }
            }
        }

        private struct Ingredient
        {
            public string description;
            public int amountToCreate;
            public Dictionary<string, int> ingredients;
        }

        private string GetImageUrl(ItemDefinition itemDefinition, ulong skin = 0)
        {
            if (ImageLibrary == null)
                return null;
            return (string)ImageLibrary.Call("GetImageURL", itemDefinition.shortname, skin);
        }

        #region RustTranslationAPI

        private bool IsSupportedLanguage(string language) => (bool)RustTranslationAPI.Call("IsSupportedLanguage", language);

        private string GetItemTranslationByShortName(string language, string itemShortName) => (string)RustTranslationAPI.Call("GetItemTranslationByShortName", language, itemShortName);

        private string GetItemDisplayName(string language, ItemDefinition itemDefinition)
        {
            string displayName;
            if (RustTranslationAPI != null)
            {
                displayName = GetItemTranslationByShortName(language, itemDefinition.shortname);
                if (!string.IsNullOrEmpty(displayName))
                {
                    return displayName;
                }
            }
            if (configData.displayNames.TryGetValue(itemDefinition.shortname, out displayName))
            {
                return displayName;
            }
            return itemDefinition.displayName.english;
        }

        #endregion RustTranslationAPI

        #endregion Methods

        #region API

        private double GetItemCost(string shortname)
        {
            var itemDefinition = ItemManager.FindItemDefinition(shortname);
            if (itemDefinition == null)
                return -1;
            return GetItemCost(itemDefinition);
        }

        private double GetItemCost(int itemID)
        {
            var itemDefinition = ItemManager.FindItemDefinition(itemID);
            if (itemDefinition == null)
                return -1;
            return GetItemCost(itemDefinition);
        }

        private double GetItemCost(ItemDefinition itemDefinition)
        {
            double cost;
            if (!itemsCost.TryGetValue(itemDefinition, out cost))
            {
                return -1;
            }
            return cost;
        }

        private Dictionary<string, double> GetItemsCostByShortName()
        {
            return itemsCost.ToDictionary(x => x.Key.shortname, y => y.Value);
        }

        private Dictionary<int, double> GetItemsCostByID()
        {
            return itemsCost.ToDictionary(x => x.Key.itemid, y => y.Value);
        }

        private Dictionary<ItemDefinition, double> GetItemsCostByDefinition()
        {
            return itemsCost.ToDictionary(x => x.Key, y => y.Value);
        }

        #endregion API

        #region Commands

        [ConsoleCommand("costfile")]
        private void CmdCostFile(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs() || !arg.IsAdmin)
            {
                goto SyntaxError;
            }

            var language = arg.Args.Length > 1 ? arg.Args[1].ToLower() : null;
            switch (arg.Args[0].ToLower())
            {
                case "shop":
                    CreateDataFile(FileType.GUIShop, language);
                    return;

                case "reward":
                    CreateDataFile(FileType.ServerReward, language);
                    return;

                case "ingredients":
                    CreateDataFile(FileType.Ingredient, language);
                    return;
            }
        SyntaxError:
            SendReply(arg, "Syntax error, please type 'costfile <shop / reward / ingredients> [language]'");
        }

        #endregion Commands

        #region Configuration

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "GUIShop - Recovery rate (Sell / Buy)")]
            public float recoveryRate = 0.5f;

            [JsonProperty(PropertyName = "GUIShop - Keep decimal")]
            public int keepdecimal = 2;

            [JsonProperty(PropertyName = "Gather rate offset")]
            public float gatherRateOffset = 1f;

            [JsonProperty(PropertyName = "Materials list")]
            public Dictionary<string, double> materials = new Dictionary<string, double>();

            [JsonProperty(PropertyName = "No materials list")]
            public Dictionary<string, double> noMaterials = new Dictionary<string, double>();

            [JsonProperty(PropertyName = "Rarity list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> rarityList = new Dictionary<string, int>
            {
                ["timed.explosive"] = 50,
                ["rifle.bolt"] = 20,
                ["hammer"] = 0
            };

            [JsonProperty(PropertyName = "Workbench level multiplier")]
            public Dictionary<int, float> workbenchMultiplier = new Dictionary<int, float>
            {
                [0] = 0,
                [1] = 0,
                [2] = 0,
                [3] = 0
            };

            [JsonProperty(PropertyName = "Item ingredients override", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, Dictionary<string, int>> ingredientsOverride = new Dictionary<string, Dictionary<string, int>>
            {
                ["horse.shoes.basic"] = new Dictionary<string, int>
                {
                    ["metal.fragments"] = 50,
                }
            };

            [JsonProperty(PropertyName = "Item displayNames")]
            public Dictionary<string, string> displayNames = new Dictionary<string, string>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig()
        {
            //configData.materials = configData.materials.OrderBy(p => p.Key).ToDictionary(p => p.Key, o => o.Value);
            //configData.noMaterials = configData.noMaterials.OrderBy(p => p.Key).ToDictionary(p => p.Key, o => o.Value);
            Config.WriteObject(configData);
        }

        #endregion Configuration

        #region DataFile

        //From Server Rewards
        private enum Category
        {
            None,
            Weapon,
            Construction,
            Items,
            Resources,
            Attire,
            Tool,
            Medical,
            Food,
            Ammunition,
            Traps,
            Misc,
            Component,
            Electrical,
            Fun
        }

        private class RewardData
        {
            public string shortname;
            public string customIcon;
            public int amount;
            public ulong skinId;
            public bool isBp;
            public Category category;
            public string displayName;
            public int cost;
            public int cooldown;
        }

        //From GUI Shop

        private class ShopData
        {
            [JsonProperty("Shop - Shop Categories")]
            public Dictionary<string, ShopCategory> ShopCategories = new Dictionary<string, ShopCategory>();

            [JsonProperty("Shop - Shop List")]
            public Dictionary<string, ShopItem> ShopItems = new Dictionary<string, ShopItem>();
        }

        private class ShopItem
        {
            public string DisplayName;
            public bool CraftAsDisplayName = false;
            public string Shortname;
            public int ItemId;
            public bool MakeBlueprint = false;
            public bool AllowSellOfUsedItems = false;
            public float Condition;
            public bool EnableBuy = true;
            public bool EnableSell = true;
            public string Image = "";
            public double SellPrice;
            public double BuyPrice;
            public int BuyCooldown;
            public int SellCooldown;
            public int[] BuyQuantity = { 1, 10, 100, 1000 };
            public int[] SellQuantity = { 1, 10, 100, 1000 };
            public int BuyLimit = 0;
            public int BuyLimitResetCoolDown = 0;
            public bool SwapLimitToQuantityBuyLimit;
            public int SellLimit = 0;
            public int SellLimitResetCoolDown = 0;
            public bool SwapLimitToQuantitySoldLimit;
            public string KitName = "";
            public List<string> Command = new List<string>();
            public bool RunCommandAndCustomShopItem = false;
            public List<char> GeneTypes = new List<char>();
            public ulong SkinId;
        }

        private class ShopCategory
        {
            public string DisplayName;
            public string DisplayNameColor = null;
            public string Description;
            public string DescriptionColor = null;
            public string Permission = "";
            public string Currency = "";
            public bool CustomCurrencyAllowSellOfUsedItems;
            public string CustomCurrencyNames = "";
            public int CustomCurrencyIDs = -0;
            public ulong CustomCurrencySkinIDs = 0;
            public bool EnabledCategory;
            public bool EnableNPC;
            public string NPCId = "";
            public HashSet<string> NpcIds = new HashSet<string>();
            public HashSet<string> Items = new HashSet<string>();
        }

        private void SaveData<T>(string name, T data) => Interface.Oxide.DataFileSystem.WriteObject(Name + "/" + Name + "_" + name, data);

        #endregion DataFile
    }
}

// --- End of file: ItemCostCalculator.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/instant-research ---
// --- Original File Path: I/InstantResearch/InstantResearch.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Instant Research", "Artasan/Tori1157", "2.0.3", ResourceId = 1318)]
    [Description("Allows control over research speed.")]
    public class InstantResearch : RustPlugin
    {
        #region Fields

        private bool Changed;
        private bool Override;

        private float researchSpeed;

        private const string instantPermission = "instantresearch.instant";
        private const string controlledPermission = "instantresearch.controlled";

        #endregion

        #region Loaded

        private void Init()
        {
            permission.RegisterPermission("instantresearch.instant", this);
            permission.RegisterPermission("Instantresearch.controlled", this);

            LoadVariables();
        }

        private void LoadVariables()
        {
            researchSpeed = Convert.ToSingle(GetConfig("Options", "Research Speed", 10));
            Override = Convert.ToBoolean(GetConfig("Options", "Override 'Controlled' with 'Instant'", false));

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Both Permission"] = "<color=red>You can't have both permissions!</color>\n\nNow using default research speed, contact an <color=cyan>Administrator</color> to fix the issue.",
            }, this);
        }

        #endregion

        #region Functions

        private void OnItemResearch(ResearchTable table, Item targetItem, BasePlayer player)
        {
            if (player == null) return;

            if (CanInstant(player) && CanControlled(player))
            {
                if (Override)
                {
                    table.researchDuration = 0f;
                    return;
                }

                rust.SendChatMessage(player, "", lang.GetMessage("Both Permission", this, player.UserIDString));
                table.researchDuration = 10f;
                return;
            }

            if (!CanControlled(player) && !CanInstant(player))
            {
                table.researchDuration = 10f;
                return;
            }

            if (CanInstant(player))
            {
                table.researchDuration = 0f;
            }

            if (CanControlled(player))
            {
                table.researchDuration = researchSpeed;
            }
        }

        #endregion

        #region Helpers

        bool CanInstant(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, instantPermission);
        }

        bool CanControlled(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, controlledPermission);
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;

            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;

            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion
    }
}

// --- End of file: InstantResearch.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-puller ---
// --- Original File Path: I/ItemPuller/ItemPuller.cs ---

using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Item Puller", "collect_vood", "1.2.4")]
    [Description("Gives you the ability to pull items from containers")]
    class ItemPuller : CovalencePlugin
    {
        [PluginReference]
        private Plugin Friends, Clans;

        #region Constants + other variables
        const string permUse = "itempuller.use";
        const string permForcePull = "itempuller.forcepull";
        const string permBuildPull = "itempuller.buildpull";
        List<BasePlayer> uiEnabled = new List<BasePlayer>();
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                { "NoPermission", "You don't have permission to use this." },
                { "NoPermissionBuild", "You don't have permission to use build pull." },
                { "InvalidArg", "Invalid argument" },
                { "MissingItem", "Missing <color=#ff0000>{0}</color>!" },
                { "Settings", "<color=#00AAFF>Item Puller Settings:</color>\nItem Puller: {0}\nAutocraft: {1}\nFrom Toolcupboard: {2}\nForce Pulling: {3}" },
                { "ForcePulled", "Items were force pulled <color=#7FFF00>sucessfully</color>!" },
                { "ItemsPulled", "Items were moved <color=#7FFF00>successfully</color>!" },
                { "NotInBuildingZone", "You need to be in building priviledge zone to use item puller!" },
                { "PlayerFull", "Cannot pull items, inventory full!" },
                { "Help", "<color=#00AAFF>Item Puller Help:</color>\n<color=#7FFF00>/ip</color> - toggle item puller on/off\n<color=#7FFF00>/ip <autocraft></color> - toggle autocraft on/off\n<color=#7FFF00>/ip <fromtc></color> - toggle tool cupboard pulling on/off\n<color=#7FFF00>/ip <fp></color> - toggle force pulling on/off\n<color=#7FFF00>/ip <settings></color> - show current settings" },
                { "toggleon", "<color=#7FFF00>Activated</color> Item Puller" },
                { "toggleoff", "<color=#ff0000>Disabled</color> Item Puller" },
                { "fromTCon", "<color=#7FFF00>Activated</color> Item Pulling from Tool Cupboard" },
                { "fromTCoff", "<color=#ff0000>Disabled</color> Item Pulling from Tool Cupboard" },
                { "autocrafton", "<color=#7FFF00>Activated</color> Item Puller auto crafting" },
                { "autocraftoff", "<color=#ff0000>Disabled</color> Item Puller auto crafting" },
                { "fpon", "<color=#7FFF00>Activated</color> Item force pulling" },
                { "fpoff", "<color=#ff0000>Disabled</color> Item force pulling" },
                { "uiturnon", "Turn on"},
                { "uiturnoff", "Turn off"},
                { "uititle", "Item Puller"},
                { "uiitempulleroption", "Item Puller"},
                { "uiautocraftoption", "Autocraft"},
                { "uifromtcoption", "Pull from TC"}
            }, this);
        }
        #endregion

        #region Config
        private Configuration config;
        private class Configuration
        {
            [JsonProperty("Command")]
            public string Command = "ip";
            [JsonProperty("Pull on build")]
            public bool pullOnBuild = true;
            [JsonProperty("Check for Owner")]
            public bool checkForOwner = false;
            [JsonProperty("Check for Team")]
            public bool checkForTeam = false;
            [JsonProperty("Check for Friend")]
            public bool checkForFriends = false;
            [JsonProperty("Check for Clan")]
            public bool checkForClans = false;
            [JsonProperty(PropertyName = "Player Default Settings", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, bool> PlayerDefaultSettings = new Dictionary<string, bool>
            {
                { "Enabled", false },
                { "Autocraft", false },
                { "Pull from ToolCupboard", true },
                { "Force Pull (recommend to not set true)", false }
            };
            [JsonProperty(PropertyName = "Ui Enabled")]
            public bool useUi = true;
            [JsonProperty(PropertyName = "Global Ui Position")]
            public Vector2 UiPosition = new Vector2(0.6505f, 0.022f);
            [JsonProperty(PropertyName = "Custom Ui Positions Enabled")]
            public bool CustomUiPosition = false;
            [JsonProperty(PropertyName = "Custom Positions (Box wise)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<CustomOtherPositions> CustomOtherPositions = new List<CustomOtherPositions> { new CustomOtherPositions() };
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            config = new Configuration();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<Configuration>();
            SaveConfig();
        }
        protected override void SaveConfig() => Config.WriteObject(config);

        private class CustomOtherPositions
        {
            [JsonProperty(PropertyName = "Box Shortname")]
            public string boxShortname = "entity.shortname";
            [JsonProperty(PropertyName = "Disable Ui")]
            public bool DisableUi = false;
            [JsonProperty(PropertyName = "Ui Position")]
            public Vector2 UiPosition { get; set; } = new Vector2(0.6505f, 0.022f);
        }
        #endregion

        #region Data
        private StoredData storedData;
        private Dictionary<ulong, PlayerSettings> allPlayerSettings => storedData.AllPlayerSettings;

        private class PlayerSettings
        {
            public bool enabled;
            public bool autocraft;
            public bool fromTC;
            public bool fp;
        }
        private class StoredData
        {
            public Dictionary<ulong, PlayerSettings> AllPlayerSettings { get; private set; } = new Dictionary<ulong, PlayerSettings>();
        }
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        private void OnServerSave() => SaveData();
        private void Unload()
        {
            SaveData();
            for (int i = 0; i < uiEnabled.Count; i++)
                DestroyUi(uiEnabled[i]);
        }

        private void CreatePlayerSettings(BasePlayer player)
        {
            if (!allPlayerSettings.ContainsKey(player.userID))
            {
                allPlayerSettings[player.userID] = new PlayerSettings
                {
                    enabled = config.PlayerDefaultSettings["Enabled"],
                    autocraft = config.PlayerDefaultSettings["Autocraft"],
                    fromTC = config.PlayerDefaultSettings["Pull from ToolCupboard"],
                    fp = config.PlayerDefaultSettings["Force Pull (recommend to not set true)"]
                };
            }
        }
        #endregion

        #region Hooks
        private void Init()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

            foreach (var player in BasePlayer.activePlayerList)
                CreatePlayerSettings(player);

            AddCovalenceCommand(config.Command, nameof(ItemPullerChatCommand));

            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permForcePull, this);
            permission.RegisterPermission(permBuildPull, this);
        }
        private void Loaded()
        {
            if (config.checkForFriends && (!Friends || !Friends.IsLoaded))
                PrintWarning("You are missing the Friends API plugin(check for Friends won't work)");
            if (config.checkForClans && (!Clans || !Clans.IsLoaded))
                PrintWarning("You are missing the Clans plugin(check for Clans won't work)");
        }
        object OnMessagePlayer(string message, BasePlayer player)
        {
            if (player == null)
                return null;
            if (message == "Can't afford to place!" && allPlayerSettings[player.userID].enabled)
                return true;
            return null;
        }
        object CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount)
        {
            var player = itemCrafter.GetComponent<BasePlayer>();
            if (player == null)
                return null;
            if (!allPlayerSettings[player.userID].enabled)
                return null;
            if (CheckPermissions(player) == null)
                return null;

            Results results = ScanItems(player, bp.ingredients, amount);

            object status = GiveItems(player, results, bp.ingredients);

            return status;
        }
        object CanAffordToPlace(BasePlayer player, Planner planner, Construction construction)
        {
            if (!config.pullOnBuild || !allPlayerSettings[player.userID].enabled)
                return null;
            var itemCrafter = player.GetComponent<ItemCrafter>();
            if (itemCrafter == null)
                return null;
            if (CheckPermissions(player, true) == null)
                return null;

            Results results = ScanItems(player, construction.defaultGrade.costToBuild, 1);

            object status = GiveItems(player, results, construction.defaultGrade.costToBuild);

            return status;
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (uiEnabled.Contains(player))
                uiEnabled.Remove(player);
        }
        private void OnPlayerConnected(BasePlayer player) { CreatePlayerSettings(player); }
        #endregion

        #region Commands
        void ItemPullerChatCommand(IPlayer player, string cmd, string[] args)
        {
            BasePlayer bPlayer;
            if ((bPlayer = player.Object as BasePlayer) == null)
                return;
            if (!HasPerm(bPlayer, permUse))
            {
                player.Reply(string.Format(lang.GetMessage("NoPermission", this, player.Id)));
                return;
            }
            if (!(args.Length > 0))
            {
                ChangeEnabled(bPlayer, "enable");
                return;
            }
            else
            {
                switch (args[0].ToLower())
                {
                    case "help":
                        player.Reply(string.Format(lang.GetMessage("Help", this, player.Id)));
                        break;
                    case "ac":
                    case "autocraft":
                        ChangeEnabled(bPlayer, "autocraft");
                        break;
                    case "fromtc":
                        ChangeEnabled(bPlayer, "fromtc");
                        break;
                    case "fp":
                    case "forcepull":
                        ChangeEnabled(bPlayer, "fp");
                        break;
                    case "settings":
                        var ps = allPlayerSettings[bPlayer.userID];
                        player.Reply(string.Format(lang.GetMessage("Settings", this, player.Id), GetOptionFormatted(ps.enabled), GetOptionFormatted(ps.autocraft), GetOptionFormatted(ps.fromTC), GetOptionFormatted(ps.fp)));
                        break;
                    default:
                        player.Reply(string.Format(lang.GetMessage("InvalidArg", this, player.Id)));
                        break;
                }
            }
        }
        string GetOptionFormatted(bool option)
        {
            if (option)
                return "<color=#7FFF00>Activated</color>";
            else
                return "<color=#ff0000>Disabled</color>";
        }
        #endregion

        #region UI
        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            var boxStorage = entity as BoxStorage;

            if (boxStorage == null || !HasPerm(player, permUse))
                return;

            if (config.useUi)
                CreateUi(player, entity);           
        }

        private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            var boxStorage = entity as BoxStorage;

            if (boxStorage == null || !HasPerm(player, permUse))
                return;

            if (config.useUi)
                DestroyUi(player);
        }
        string ToggleButtonColor(bool Enabled)
        {
            string toggleButtonColor = !Enabled
                            ? "0.415 0.5 0.258 0.4"
                            : "0.8 0.254 0.254 0.4";
            return toggleButtonColor;
        }
        string ToggleButtonTextColor(bool Enabled)
        {
            string toggleButtonTextColor = !Enabled
                                            ? "0.607 0.705 0.431"
                                            : "0.705 0.607 0.431";
            return toggleButtonTextColor;
        }
        private CuiElementContainer CreateUi(BasePlayer player, BaseEntity entity)
        {
            PlayerSettings settings = allPlayerSettings[player.userID];
            
            if (uiEnabled.Contains(player))
                DestroyUi(player);
            else
                uiEnabled.Add(player);

            Vector2 uiPosition = config.UiPosition;

            if (config.CustomUiPosition && entity != null)
            {
                foreach (var customUiPos in config.CustomOtherPositions)
                {
                    if (customUiPos.boxShortname == entity.ShortPrefabName || (entity.ShortPrefabName == "woodbox_deployed" && customUiPos.boxShortname == "box.wooden"))
                    {
                        uiPosition = customUiPos.UiPosition;
                        if (customUiPos.DisableUi)
                            return null;
                    }
                    else
                        continue;
                }
            }

            Vector2 uiSize = new Vector2(0.1785f, 0.111f);

            CuiElementContainer result = new CuiElementContainer();
            string rootPanelName = result.Add(new CuiPanel
            {
                Image = new CuiImageComponent
                {
                    Color = "0 0 0 0"
                },
                RectTransform =
                {
                    AnchorMin = uiPosition.x + " " + uiPosition.y,
                    AnchorMax = uiPosition.x + uiSize.x + " " + (uiPosition.y + uiSize.y)
                }
            }, "Overlay", "ItemPullerUi");

            string headerPanel = result.Add(new CuiPanel
            {
                Image = new CuiImageComponent
                {
                    Color = "0.75 0.75 0.75 0.1"
                },
                RectTransform =
                {
                    AnchorMin = "0 0.775",
                    AnchorMax = "1 1"
                }
            }, rootPanelName);

            result.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0.051 0",
                    AnchorMax = "1 0.95"
                },
                Text =
                {
                    Text = lang.GetMessage("uititle", this, player.UserIDString),
                    Align = TextAnchor.MiddleLeft,
                    Color = "0.77 0.7 0.7 1",
                    FontSize = 13
                }
            }, headerPanel);

            string contentPanel = result.Add(new CuiPanel
            {
                Image = new CuiImageComponent
                {
                    Color = "0.65 0.65 0.65 0.06"
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 0.74"
                }
            }, rootPanelName);

            result.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0.022 0.676",
                    AnchorMax = "0.25 0.964"
                },
                Button =
                {
                    Command = $"{config.Command}",
                    Color = ToggleButtonColor(settings.enabled)
                },
                Text =
                {
                    Align = TextAnchor.MiddleCenter,
                    Text = settings.enabled ? lang.GetMessage("uiturnoff", this, player.UserIDString) : lang.GetMessage("uiturnon", this, player.UserIDString),
                    Color = ToggleButtonTextColor(settings.enabled),
                    FontSize = 11
                }
            }, contentPanel);

            result.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0.022 0.353",
                    AnchorMax = "0.25 0.64"
                },
                Button =
                {
                    Command = $"{config.Command} autocraft",
                    Color = ToggleButtonColor(settings.autocraft)
                },
                Text =
                {
                    Align = TextAnchor.MiddleCenter,
                    Text = settings.autocraft ? lang.GetMessage("uiturnoff", this, player.UserIDString) : lang.GetMessage("uiturnon", this, player.UserIDString),
                    Color = ToggleButtonTextColor(settings.autocraft),
                    FontSize = 11
                }
            }, contentPanel);

            result.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0.022 0.029",
                    AnchorMax = "0.25 0.317"
                },
                Button =
                {
                    Command = $"{config.Command} fromtc",
                    Color = ToggleButtonColor(settings.fromTC)
                },
                Text =
                {
                    Align = TextAnchor.MiddleCenter,
                    Text = settings.fromTC ? lang.GetMessage("uiturnoff", this, player.UserIDString) : lang.GetMessage("uiturnon", this, player.UserIDString),
                    Color = ToggleButtonTextColor(settings.fromTC),
                    FontSize = 11
                }
            }, contentPanel);

            // Explanations
            result.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0.307 0.676",
                    AnchorMax = "0.636 0.964"
                },
                Text =
                {
                    Text = lang.GetMessage("uiitempulleroption", this, player.UserIDString),
                    Align = TextAnchor.MiddleLeft,
                    Color = "0.77 0.7 0.7 1",
                    FontSize = 11
                }
            }, contentPanel);
            result.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0.307 0.353",
                    AnchorMax = "0.636 0.64"
                },
                Text =
                {
                    Text = lang.GetMessage("uiautocraftoption", this, player.UserIDString),
                    Align = TextAnchor.MiddleLeft,
                    Color = "0.77 0.7 0.7 1",
                    FontSize = 11
                }
            }, contentPanel);
            result.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0.307 0.036",
                    AnchorMax = "0.636 0.324"
                },
                Text =
                {
                    Text = lang.GetMessage("uifromtcoption", this, player.UserIDString),
                    Align = TextAnchor.MiddleLeft,
                    Color = "0.77 0.7 0.7 1",
                    FontSize = 11
                }
            }, contentPanel);
            
            CuiHelper.AddUi(player, result);
            return result;
        }

        private void DestroyUi(BasePlayer player)
        {
            if (uiEnabled.Contains(player))
                uiEnabled.Remove(player);
            CuiHelper.DestroyUi(player, "ItemPullerUi");
        }

        private void UpdateUi(BasePlayer player, BaseEntity entity)
        {
            DestroyUi(player);
            CreateUi(player, entity);
        }
        #endregion

        #region Helpers
        class Results
        {
            public bool hasResources = false;
            public Dictionary<Item, int> transferItems = new Dictionary<Item, int>();
            public int check = 0;
        }

        Results ScanItems(BasePlayer player, List<ItemAmount> ingredients, int amount)
        {
            var results = new Results();

            var hasIngredient = new List<ItemAmount>();

            var itemCrafter = player.GetComponent<ItemCrafter>();
            if (itemCrafter == null)
                return results;

            foreach (var itemAmount in ingredients)
            {
                if (HasIngredient(itemCrafter, itemAmount, amount))
                {
                    results.check++;
                    hasIngredient.Add(itemAmount);
                    if (hasIngredient.Count >= ingredients.Count)
                    {
                        results.hasResources = true;
                        return results;
                    }
                    continue;
                }
                else
                {
                    int required = (int)itemAmount.amount;

                    if (!allPlayerSettings[player.userID].fp || !CanForcePull(player))
                    {
                        // Gets Item info from Containers in Building Area
                        var possibleItems = GetUsableItems(player, itemAmount.itemid, required);
                        if (possibleItems != null)
                        {
                            results.check++;
                            foreach (var Item in possibleItems)
                                results.transferItems.Add(Item.Key, Item.Value);
                        }
                        else
                        {
                            player.ChatMessage(string.Format(lang.GetMessage("MissingItem", this, player.UserIDString), itemAmount.itemDef.displayName.english));
                            break;
                        }
                    }
                    else
                        ForceUsableItem(itemCrafter, itemAmount.itemid, required);
                }
            }
            return results;
        }
        object GiveItems(BasePlayer player, Results results, List<ItemAmount> ingredients)
        {
            if (results.hasResources)
                return null;

            if (results.check >= ingredients.Count)
            {
                foreach (var Item in results.transferItems)
                {
                    if (Item.Value != 0)
                        Item.Key.SplitItem(Item.Value).MoveToContainer(player.inventory.containerMain);
                    else
                        Item.Key.MoveToContainer(player.inventory.containerMain);
                }
                player.ChatMessage(string.Format(lang.GetMessage("ItemsPulled", this, player.UserIDString)));
                if (!allPlayerSettings[player.userID].autocraft)
                    return false;
            }
            else if (allPlayerSettings[player.userID].fp)
            {
                player.ChatMessage(string.Format(lang.GetMessage("ForcePulled", this, player.UserIDString)));
                if (!allPlayerSettings[player.userID].autocraft)
                    return false;
            }
            return null;
        }
        private void ForceUsableItem(ItemCrafter itemCrafter, int itemid, int required)
        {
            var player = itemCrafter.GetComponent<BasePlayer>();
            Item item = ItemManager.CreateByItemID(itemid, required);
            if (item != null)
                player.GiveItem(item);
        }
        Dictionary<Item, int> GetUsableItems(BasePlayer player, int itemid, int required)
        {
            var itemDef = ItemManager.FindItemDefinition(itemid);
            if (itemDef == null)
                return null;
            var building = player.GetBuildingPrivilege().GetBuilding();
            var possibleItems = new Dictionary<Item, int>();
            if (building != null)
            {
                foreach (var decayEntities in building.GetDominatingBuildingPrivilege().GetBuilding().decayEntities)
                {
                    if (decayEntities.GetEntity() is StorageContainer)
                    {
                        var storageContainer = decayEntities.GetEntity() as StorageContainer;
                        if (storageContainer.OwnerID != player.userID)
                        {
                            if (config.checkForOwner)
                                continue;
                            if (config.checkForTeam)
                            {
                                var storageOwner = BasePlayer.FindByID(storageContainer.OwnerID);
                                if (storageOwner == null) continue;
                                if (!IsTeamMember(storageOwner, player)) continue;
                            }
                            if (config.checkForFriends && Friends != null && Friends.IsLoaded)
                            {
                                if (!(bool)Friends?.Call("AreFriends", player.userID, storageContainer.OwnerID))
                                    continue;
                            }
                            if (config.checkForClans && Clans != null && Clans.IsLoaded)
                            {
                                string clantag = Clans?.Call("GetClanOf", storageContainer.OwnerID) as string;
                                if (clantag == null) continue;
                                JObject clan = Clans?.Call("GetClan", clantag) as JObject;
                                if (clan == null) continue;
                                JArray members = clan["members"] as JArray;
                                if (members == null) continue;
                                if (!members.Contains(player.UserIDString)) continue;
                            }
                        }
                        if (storageContainer.PrefabName.Contains("cupboard") && !allPlayerSettings[player.userID].fromTC) continue;
                        foreach (Item item in storageContainer.inventory.itemList)
                        {
                            if (required == 0) break;
                            if (item.info.itemid == itemDef.itemid)
                            {
                                if (required >= item.amount)
                                {
                                    required -= item.amount;
                                    possibleItems.Add(item, 0);
                                }
                                else
                                {
                                    possibleItems.Add(item, required);
                                    required = 0;
                                }
                            }
                        }
                    }
                }
                if (required == 0) return possibleItems;
                else return null;
            }
            return null;
        }
        private bool IsTeamMember(BasePlayer player, BasePlayer possibleMember)
        {
            if (player.currentTeam == 0 || possibleMember.currentTeam == 0)
                return false;
            return player.currentTeam == possibleMember.currentTeam;
        }
        private bool IsFull(BasePlayer player)
        {
            if (player.inventory.containerMain.IsFull() && player.inventory.containerBelt.IsFull())
                return true;
            else
                return false;
        }
        private bool HasIngredient(ItemCrafter itemCrafter, ItemAmount itemAmount, int amount)
        {
            int num = 0;
            foreach (var itemContainer in itemCrafter.containers)
            {
                num += itemContainer.GetAmount(itemAmount.itemid, true);
            }
            float iAmount = itemAmount.amount * amount;
            int required = (int)iAmount - num;
            if (!(num >= iAmount))
                return false;
            else
                return true;
        }
        object CheckPermissions(BasePlayer player, bool OnBuild = false)
        {
            if (!IsInBuildingZone(player) && !allPlayerSettings[player.userID].fp)
            {
                player.ChatMessage(string.Format(lang.GetMessage("NotInBuildingZone", this, player.UserIDString)));
                return null;
            }
            if (!HasPerm(player, permUse))
            {
                player.ChatMessage(string.Format(lang.GetMessage("NoPermission", this, player.UserIDString)));
                return null;
            }
            if (OnBuild && !HasPerm(player, permBuildPull))
            {
                player.ChatMessage(string.Format(lang.GetMessage("NoPermissionBuild", this, player.UserIDString)));
                return null;
            }
            if (IsFull(player))
            {
                player.ChatMessage(string.Format(lang.GetMessage("PlayerFull", this, player.UserIDString)));
                return null;
            }
            return true;
        }
        private bool IsEnabled(BasePlayer player) { return allPlayerSettings[player.userID].enabled; }
        private bool IsAutocraft(BasePlayer player) { return allPlayerSettings[player.userID].autocraft; }
        private bool IsFromTC(BasePlayer player) { return allPlayerSettings[player.userID].fromTC; }
        private bool IsForcePulling(BasePlayer player) { return allPlayerSettings[player.userID].fp; }

        private void ChangeEnabled(BasePlayer player, string setting)
        {
            switch (setting)
            {
                case "enable":
                    if (IsEnabled(player))
                    {
                        allPlayerSettings[player.userID].enabled = false;
                        player.ChatMessage(string.Format(lang.GetMessage("toggleoff", this, player.UserIDString)));
                    }
                    else
                    {
                        allPlayerSettings[player.userID].enabled = true;
                        player.ChatMessage(string.Format(lang.GetMessage("toggleon", this, player.UserIDString)));
                    }
                    break;
                case "autocraft":
                    if (IsAutocraft(player))
                    {
                        allPlayerSettings[player.userID].autocraft = false;
                        player.ChatMessage(string.Format(lang.GetMessage("autocraftoff", this, player.UserIDString)));
                    }
                    else
                    {
                        allPlayerSettings[player.userID].autocraft = true;
                        player.ChatMessage(string.Format(lang.GetMessage("autocrafton", this, player.UserIDString)));
                    }
                    break;
                case "fromtc":
                    if (IsFromTC(player))
                    {
                        allPlayerSettings[player.userID].fromTC = false;
                        player.ChatMessage(string.Format(lang.GetMessage("fromTCoff", this, player.UserIDString)));
                    }
                    else
                    {
                        allPlayerSettings[player.userID].fromTC = true;
                        player.ChatMessage(string.Format(lang.GetMessage("fromTCon", this, player.UserIDString)));
                    }
                    break;
                case "fp":
                    if (!CanForcePull(player))
                    {
                        player.ChatMessage(string.Format(lang.GetMessage("NoPermission", this, player.UserIDString)));
                        break;
                    }
                    else
                    {
                        if (IsForcePulling(player))
                        {
                            allPlayerSettings[player.userID].fp = false;
                            player.ChatMessage(string.Format(lang.GetMessage("fpoff", this, player.UserIDString)));
                        }
                        else
                        {
                            allPlayerSettings[player.userID].fp = true;
                            player.ChatMessage(string.Format(lang.GetMessage("fpon", this, player.UserIDString)));
                        }
                        break;
                    }
            }
            if (uiEnabled.Contains(player))
            {
                BaseEntity entity = null;
                if (player.inventory.loot.IsLooting())
                    entity = player.inventory.loot.entitySource;
                UpdateUi(player, entity);
            }

        }

        private bool HasPerm(BasePlayer player, string perm) => (permission.UserHasPermission(player.UserIDString, perm));
        private bool IsInBuildingZone(BasePlayer player) => (player.IsBuildingAuthed());
        private bool CanForcePull(BasePlayer player) => (permission.UserHasPermission(player.UserIDString, permForcePull));
        #endregion
    }
}


// --- End of file: ItemPuller.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/item-finder ---
// --- Original File Path: I/ItemFinder/ItemFinder.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using System;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Item Finder", "Camoec", 1.3)]
    [Description("Get count of specific item in the server")]

    public class ItemFinder : CovalencePlugin
    {
        private const string Perm = "itemfinder.use";
        private DateTime lastCommand = new DateTime();

        private PluginConfig _config;
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Cooldown (is seconds)")]
            public int Cooldown = 5;
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);
        protected override void LoadDefaultConfig()
        {
            _config = new PluginConfig();
            SaveConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                    throw new Exception();

                SaveConfig(); // override posible obsolet / outdated config
            }
            catch (Exception)
            {
                PrintError("Loaded default config.");

                LoadDefaultConfig();
            }
        }

        private void Init()
        {
            permission.RegisterPermission(Perm, this);
        }

        private class ItemsInfo
        {
            public string shortname;
            public int itemId;

            public int droppedCount;
            public int dropped;
            public int inPlayers;
            public int inCointaners;

            public int totalCount => droppedCount + inPlayers + inCointaners;
        }

        [Command("itemfinder")]
        private void GetActiveEnts(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(Perm))
            {
                player.Reply(Lang("NoPermission", player.Id));
                return;
            }

            if (args.Length == 0)
            {
                player.Reply(Lang("InvalidSyntax", player.Id));
                return;
            }

            if(DateTime.Now - lastCommand < TimeSpan.FromSeconds(_config.Cooldown))
            {
                player.Reply(string.Format(Lang("Cooldown", player.Id), _config.Cooldown - (int)(DateTime.Now - lastCommand).TotalSeconds));
                return;
            }

            lastCommand = DateTime.Now;

            var info = GetInfo(args[0]);

            if (info == null)
            {
                player.Reply(string.Format(Lang("NotFound", player.Id), info.shortname));
                return;
            }

            player.Reply(string.Format(Lang("Found", player.Id), info.itemId, info.dropped, info.inCointaners, info.inPlayers, info.totalCount));
        }

        private int? GetItemId(string shortname) => ItemManager.FindItemDefinition(shortname)?.itemid;
        private ItemsInfo GetInfo(string shortname)
        {
            ItemsInfo info = new ItemsInfo();
            info.shortname = shortname;
            int? itemid = GetItemId(shortname);
            info.itemId = itemid != null ? itemid.Value : -1;

            ItemDefinition itemDef = null;
            for (int i = 0; i <  ItemManager.itemList.Count;i++)
            {
                if (ItemManager.itemList[i].shortname == shortname)
                    itemDef = ItemManager.itemList[i];
            }

            if(itemDef == null)
            {
                // item not found
                return null;
            }

            // Get in players inventory
            foreach(BasePlayer player in BasePlayer.allPlayerList)
            {
                if (player == null)
                    continue;

                player.inventory.containerMain.itemList.ForEach((item) =>
                {
                    if (item.info.itemid == info.itemId)
                        info.inPlayers += item.amount;
                });
                player.inventory.containerBelt.itemList.ForEach((item) =>
                {
                    if (item.info.itemid == info.itemId)
                        info.inPlayers += item.amount;
                });
                player.inventory.containerWear.itemList.ForEach((item) =>
                {
                    if (item.info.itemid == info.itemId)
                        info.inPlayers += item.amount;
                });
            }

            // Get in AllCointainers
            foreach(var entity in BaseNetworkable.serverEntities)
            {
                var droppedItem = entity as DroppedItem;
                if(droppedItem != null)
                {
                    var item = droppedItem.GetItem();
                    if (item.info.itemid == info.itemId)
                    {
                        info.dropped += item.amount;
                    }
                    continue;
                }

                var container = entity as StorageContainer;
                if (container == null || container is LootContainer)
                    continue;

                var foundItems = container.inventory.FindItemsByItemID(info.itemId);
                foundItems.ForEach(item =>
                {
                    info.inCointaners += item.amount;
                });
            }

            return info;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["InvalidSyntax"] = "Use <color=#eb4213>/itemfinder</color> [item shortname]",
                ["NotFound"] = "Item '{0}' not found",
                ["Found"] = "<color=#eb4213>ItemInfo:</color>\r\nItemId:{0}\r\nDropped:{1}\r\nInContainers:{2}\r\ninPlayers:{3}\r\nTotal:{4}",
                ["NoPermission"] = "You not have permission to use this command",
                ["Cooldown"] = "You need to wait {0} seconds to use this command"
            }, this);
        }

        private string Lang(string key, string userid) => lang.GetMessage(key, this, userid);

    }
}

// --- End of file: ItemFinder.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-server-stats ---
// --- Original File Path: D/DiscordServerStats/DiscordServerStats.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Discord Server Stats", "MJSU", "2.1.0")]
    [Description("Displays stats about the server in discord")]
    public class DiscordServerStats : CovalencePlugin
    {
        #region Class Fields
        [PluginReference] private Plugin PlaceholderAPI;
        
        private StoredData _storedData; //Plugin Data
        private PluginConfig _pluginConfig; //Plugin Config

        private const string WebhookMessageUpdate = "{0}/messages/{1}";
        private const string WebhooksMessageCreate = "{0}?wait=true";
        private const string WebhookDefault = "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

        private readonly Hash<string, DateTime> _joinedDate = new Hash<string, DateTime>();
        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>
        {
            ["Content-Type"] = "application/json" 
        };

        private readonly Hash<string, MessageHandler> _handlers = new Hash<string, MessageHandler>();

        private Action<IPlayer, StringBuilder, bool> _replacer;
        private readonly StringBuilder _parser = new StringBuilder();

        private bool _isOnline;
        
        public enum DebugEnum { Message, None, Error, Warning, Info }

        private static DiscordServerStats _ins;
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _ins = this;
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            if (_storedData.MessageId != null)
            {
                _storedData.WebhookMessages[_pluginConfig.MessageConfigs[0].DiscordWebhook] = new MessageData{MessageId = _storedData.MessageId};
                _storedData.MessageId = null;
                SaveData();
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [PluginLang.OnlineStatus] = ":green_circle:",
                [PluginLang.OfflineStatus] = ":red_circle:",
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        public PluginConfig AdditionalConfig(PluginConfig config)
        {
            //Migrates data from Version 2.0.* -> 2.1.0
            if (config.StatsEmbed != null)
            {
                config.MessageConfigs = new List<MessageConfig>
                {
                    new MessageConfig(null)
                    {
                        DiscordWebhook = config.DiscordWebhook,
                        UpdateInterval = config.UpdateInterval,
                        StatsEmbed = config.StatsEmbed
                    }
                };
                config.DiscordWebhook = null;
                config.UpdateInterval = 0;
                config.StatsEmbed = null;
            }
            //End Data Migration from Version 2.0.* -> 2.1.0
            
            DiscordMessageConfig defaultEmbed = new DiscordMessageConfig
            {
                Content = config.StatsEmbed?.Content ?? string.Empty,
                Embeds = config.StatsEmbed?.Embeds ?? new List<EmbedConfig>{ new EmbedConfig
                {
                    Title = "{server.name}",
                    Description = "Live Server Stats",
                    Url = string.Empty,
                    Color = "#de8732",
                    Image = string.Empty,
                    Thumbnail = string.Empty,
                    Fields = new List<FieldConfig>
                    {
                        new FieldConfig
                        {
                            Title = "Status",
                            Value = "{discordserverstats.status}",
                            Inline = true,
                            Enabled = true
                        },
                        
                        new FieldConfig
                        {
                            Title = "Online / Max Players",
                            Value = "{server.players} / {server.players.max}",
                            Inline = true,
                            Enabled = true
                        },
#if RUST
                        new FieldConfig
                        {
                            Title = "Sleepers",
                            Value = "{server.players.sleepers}",
                            Inline = true,
                            Enabled = true
                        },
                        new FieldConfig
                        {
                            Title = "Players Loading",
                            Value = "{server.players.loading}",
                            Inline = true,
                            Enabled = true
                        },
                        new FieldConfig
                        {
                            Title = "Players In Queue",
                            Value = "{server.players.queued}",
                            Inline = true,
                            Enabled = true
                        },   
#endif
                        new FieldConfig
                        {
                            Title = "In Game Time",
                            Value = "{server.time:hh:mm:ss tt}",
                            Inline = true,
                            Enabled = true
                        },   
#if RUST
                        new FieldConfig
                        {
                            Title = "Map Entities",
                            Value = "{server.entities}",
                            Inline = true,
                            Enabled = true
                        },
                        new FieldConfig
                        {
                            Title = "Server Framerate",
                            Value = "{server.fps}",
                            Inline = true,
                            Enabled = true
                        },
                        new FieldConfig
                        {
                            Title = "Seed",
                            Value = "[{world.seed}](https://rustmaps.com/map/{world.size}_{world.seed})",
                            Inline = true,
                            Enabled = true
                        },
                        new FieldConfig
                        {
                            Title = "Size",
                            Value = "{world.size!km}km ({world.size!km^2}km^2)",
                            Inline = true,
                            Enabled = true
                        },
#endif
                        new FieldConfig
                        {
                            Title = "Protocol",
                            Value = "{server.protocol}",
                            Inline = true,
                            Enabled = true
                        },
#if RUST
                        new FieldConfig
                        {
                            Title = "Memory Usage",
                            Value = "{server.memory.used:0.00!gb} GB / {server.memory.total:0.00!gb} GB" ,
                            Inline = true,
                            Enabled = true
                        },
                        new FieldConfig
                        {
                            Title = "Network IO",
                            Value = "In: {server.network.in:0.00!kb} KB/s Out: {server.network.out:0.00!kb} KB/s " ,
                            Inline = true,
                            Enabled = true
                        },
                        new FieldConfig
                        {
                            Title = "Last Wiped Date Time",
                            Value = "{server.map.wipe.last:MM/dd/yy hh:mm:ss tt!local}" ,
                            Inline = true,
                            Enabled = true
                        },
                        
                        new FieldConfig
                        {
                            Title = "Last Blueprint Wipe Date Time",
                            Value = "{server.blueprints.wipe.last:MM/dd/yy hh:mm:ss tt!local}" ,
                            Inline = true,
                            Enabled = true
                        },
#endif
                        new FieldConfig
                        {
                            Title = "Last Joined",
                            Value = "{player.joined.last}" ,
                            Inline = true,
                            Enabled = true
                        },
                        new FieldConfig
                        {
                            Title = "Last Disconnected",
                            Value = "{player.disconnected.last} ({player.disconnected.last.duration:%h}H {player.disconnected.last.duration:%m}M {player.disconnected.last.duration:%s}S)" ,
                            Inline = true,
                            Enabled = true
                        },
                        new FieldConfig
                        {
                            Title = "Click & Connect",
                            Value = "steam://connect/{server.address}:{server.port}",
                            Inline = false,
                            Enabled = true
                        }
                    },
                    Footer = new FooterConfig
                    {
                        IconUrl = string.Empty,
                        Text = string.Empty,
                        Enabled = true
                    },
                    Enabled = true
                    }
                }
            };

            config.MessageConfigs = config.MessageConfigs ?? new List<MessageConfig>
            {
                new MessageConfig(null)
                {
                    StatsEmbed = defaultEmbed
                }
            };

            return config;
        }

        private void OnServerInitialized()
        {
            _isOnline = true;
            foreach (IPlayer player in players.Connected)
            {
                OnUserConnected(player);
            }
            
            if (PlaceholderAPI == null || !PlaceholderAPI.IsLoaded)
            {
                PrintError("Missing plugin dependency PlaceholderAPI: https://umod.org/plugins/placeholder-api");
                return;
            }
            
            if(PlaceholderAPI.Version < new VersionNumber(2, 2, 0))
            {
                PrintError("Placeholder API plugin must be version 2.2.0 or higher");
                return;
            }
        }

        private void OnServerSave()
        {
            NextTick(SaveData);
        }

        private void OnServerShutdown()
        {
            _isOnline = false;
            foreach (MessageHandler handler in _handlers.Values)
            {
                handler.SendUpdateMessage();
            }
        }
        
        private void Unload()
        {
            SaveData();
            _ins = null;
        }
        #endregion

        #region Hooks
        private void OnUserConnected(IPlayer player)
        {
            _joinedDate[player.Id] = DateTime.Now;
            _storedData.LastConnected = player.Name;
        }

        private void OnUserDisconnected(IPlayer player)
        {
            _storedData.LastDisconnectedDuration = DateTime.Now - _joinedDate[player.Id];
            _storedData.LastDisconnected = player.Name;
        }
        #endregion

        #region Message Handling
        public void SetupMessaging()
        {
            for (int index = 0; index < _pluginConfig.MessageConfigs.Count; index++)
            {
                MessageConfig config = _pluginConfig.MessageConfigs[index];
                config.DiscordWebhook = config.DiscordWebhook.Replace("/api/webhooks", "/api/v9/webhooks");

                if (string.IsNullOrEmpty(config.DiscordWebhook) || config.DiscordWebhook == WebhookDefault)
                {
                    PrintWarning($"Webhook URL not specified. Please set webhook url in config for message index {index}.");
                    continue;
                }

                _handlers[config.DiscordWebhook] = new MessageHandler(config);
            }
        }
        #endregion

        #region PlaceholderAPI
        public string ParseField(string field)
        {
            _parser.Length = 0;
            _parser.Append(field);
            GetReplacer()?.Invoke(null, _parser, false);
            return _parser.ToString();
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin?.Name == "PlaceholderAPI")
            {
                _replacer = null;
            }
        }
        
        private void OnPlaceholderAPIReady()
        {
            RegisterPlaceholder("player.joined.last", (player, s) => _storedData.LastConnected, "Displays the name of the player who joined last");
            RegisterPlaceholder("player.disconnected.last", (player, s) => _storedData.LastDisconnected, "Displays the name of the player who disconnected last");
            RegisterPlaceholder("player.disconnected.last.duration", (player, s) => _storedData.LastDisconnectedDuration, "Displays duration of the last disconnected player");
            RegisterPlaceholder("discordserverstats.status", (player, s) => _isOnline ? Lang(PluginLang.OnlineStatus) : Lang(PluginLang.OfflineStatus), "Displays if the server is online or offline.");
            SetupMessaging();
        }

        public void RegisterPlaceholder(string key, Func<IPlayer, string, object> action, string description = null)
        {
            if (IsPlaceholderApiLoaded())
            {
                PlaceholderAPI.Call("AddPlaceholder", this, key, action, description);
            }
        }

        public Action<IPlayer, StringBuilder, bool> GetReplacer()
        {
            if (!IsPlaceholderApiLoaded())
            {
                return _replacer;
            }
            
            return _replacer ?? (_replacer = PlaceholderAPI.Call<Action<IPlayer, StringBuilder, bool>>("GetProcessPlaceholders", 1));
        }

        public bool IsPlaceholderApiLoaded() => PlaceholderAPI != null && PlaceholderAPI.IsLoaded;
        #endregion

        #region Helper Methods
        public void Debug(DebugEnum level, string message)
        {
            if (level > _pluginConfig.DebugLevel)
            {
                return;
            }

            switch (level)
            {
                case DebugEnum.Error:
                    PrintError(message);
                    break;
                case DebugEnum.Warning:
                    PrintWarning(message);
                    break;
                default:
                    Puts($"{level}: {message}");
                    break;
            }
        }
        
        public string Lang(string key)
        {
            return lang.GetMessage(key, this);
        }

        public void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);
        #endregion

        #region Classes
        public class PluginConfig
        {
            [JsonProperty(PropertyName = "Stats Messages")]
            public List<MessageConfig> MessageConfigs { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DebugEnum.Warning)]
            [JsonProperty(PropertyName = "Debug Level (None, Error, Warning, Info)")]
            public DebugEnum DebugLevel { get; set; }

            #region Obsolete
            [Obsolete("This was removed in version 2.1.0")]
            [JsonProperty(PropertyName = "Discord Webhook")]
            public string DiscordWebhook { get; set; }
            
            [Obsolete("This was removed in version 2.1.0")]
            [JsonProperty(PropertyName = "Message Update Interval (Minutes)")]
            public float UpdateInterval { get; set; }

            [Obsolete("This was removed in version 2.1.0")]
            [JsonProperty(PropertyName = "Stats Embed Message")]
            public DiscordMessageConfig StatsEmbed { get; set; }
            
            public bool ShouldSerializeDiscordWebhook()
            {
                return DiscordWebhook != null;
            }

            public bool ShouldSerializeUpdateInterval()
            {
                return UpdateInterval != 0;
            }
            
            public bool ShouldSerializeStatsEmbed()
            {
                return StatsEmbed != null;
            }
            #endregion
        }

        public class MessageConfig
        {
            [DefaultValue(WebhookDefault)]
            [JsonProperty(PropertyName = "Discord Webhook")]
            public string DiscordWebhook { get; set; }

            [DefaultValue(1f)]
            [JsonProperty(PropertyName = "Message Update Interval (Minutes)")]
            public float UpdateInterval { get; set; }
            
            [JsonProperty(PropertyName = "Embed Message")]
            public DiscordMessageConfig StatsEmbed { get; set; }

            public MessageConfig(MessageConfig settings)
            {
                DiscordWebhook = settings?.DiscordWebhook ?? WebhookDefault;
                UpdateInterval = settings?.UpdateInterval ?? 1;
                StatsEmbed = settings?.StatsEmbed;
            }
        }

        private class StoredData
        {
            [Obsolete("This was removed in version 2.1.0")]
            public string MessageId { get; set; }
            public string LastConnected { get; set; } = "N/A";
            public string LastDisconnected { get; set; } = "N/A";
            public TimeSpan LastDisconnectedDuration = TimeSpan.Zero;
            public Hash<string, MessageData> WebhookMessages = new Hash<string, MessageData>();
            
            public bool ShouldSerializeMessageId()
            {
                return MessageId != null;
            }
        }

        public class MessageData
        {
            public string MessageId { get; set; }
        }

        private static class PluginLang
        {
            public const string OnlineStatus = nameof(OnlineStatus);
            public const string OfflineStatus = nameof(OfflineStatus);
        }

        public class MessageHandler
        {
            public MessageConfig Config { get; }
            public MessageData Data { get; private set; }
            public Timer Timer { get; }
            public string MessageId { get; private set; }

            public MessageHandler(MessageConfig config)
            {
                Config = config;
                Data = _ins._storedData.WebhookMessages[config.DiscordWebhook];
                if (Data == null)
                {
                    SendCreateMessage();
                }
                else
                {
                    MessageId = Data.MessageId;
                    SendUpdateMessage();
                }
                
                Timer = _ins.timer.Every(config.UpdateInterval * 60, SendUpdateMessage);
            }
            
            public void SendCreateMessage()
            {
                DiscordMessage create = _ins.ParseMessage(Config.StatsEmbed);
                _ins.CreateDiscordMessage(Config.DiscordWebhook, create, new Action<int, DiscordMessage>((code, response) =>
                {
                    if (code == 404)
                    {
                        _ins.PrintWarning("Create message returned 404. Please confirm webhook url in config is correct.");
                        return;
                    }
                
                    if (response == null)
                    {
                        _ins.PrintWarning($"Created message returned null. Code: {code}");
                        return;
                    }

                    MessageId = response.Id;
                    Data = new MessageData { MessageId = MessageId };
                    _ins._storedData.WebhookMessages[Config.DiscordWebhook] = Data;
                    _ins.SaveData();
                }));
            }

            public void SendUpdateMessage()
            {
                if (string.IsNullOrEmpty(MessageId))
                {
                    SendCreateMessage();
                    return;
                }
                
                DiscordMessage update = _ins.ParseMessage(Config.StatsEmbed);
                update.Id = MessageId;

                _ins.UpdateDiscordMessage(Config.DiscordWebhook, update, new Action<int, DiscordMessage>((code,response) =>
                {
                    if (code == 404 && response == null)
                    {
                        SendCreateMessage();
                    }
                }));
            }
        }
        #endregion

        #region Discord Embed
        #region Send Embed Methods
        /// <summary>
        /// Sends the DiscordMessage
        /// </summary>
        /// <param name="webhook"></param>
        /// <param name="message">Message being sent</param>
        /// <param name="callback"></param>
        private void CreateDiscordMessage<T>(string webhook, DiscordMessage message, Action<int, T> callback)
        {
            StringBuilder json = message.ToJson();
            if (_pluginConfig.DebugLevel >= DebugEnum.Info)
            {
                Debug(DebugEnum.Info, $"{nameof(UpdateDiscordMessage)} message.ToJson()\n{json}");
            }
            
            webrequest.Enqueue(string.Format(WebhooksMessageCreate, webhook), json.ToString(), (code, response) => SendDiscordMessageCallback(code, response, callback), null, RequestMethod.POST, _headers);
        }

        /// <summary>
        /// Sends the DiscordMessage
        /// </summary>
        /// <param name="webhook"></param>
        /// <param name="message">Message being sent</param>
        /// <param name="callback"></param>
        private void UpdateDiscordMessage<T>(string webhook, DiscordMessage message, Action<int, T> callback)
        {
            StringBuilder json = message.ToJson();
            if (_pluginConfig.DebugLevel >= DebugEnum.Info)
            {
                Debug(DebugEnum.Info, $"{nameof(UpdateDiscordMessage)} message.ToJson()\n{json}");
            }

            webrequest.Enqueue(string.Format(WebhookMessageUpdate, webhook, message.Id), json.ToString(), (code, response) => SendDiscordMessageCallback(code, response, callback), null, RequestMethod.PATCH, _headers);
        }

        /// <summary>
        /// Callback when sending the embed if any errors occured
        /// </summary>
        /// <param name="code">HTTP response code</param>
        /// <param name="message">Response message</param>
        /// <param name="callback"></param>
        private void SendDiscordMessageCallback<T>(int code, string message, Action<int, T> callback)
        {
            if (code == 404)
            {
                callback?.Invoke(code, default(T));
                return;
            }
            
            if (code != 204 && code != 200)
            {
                PrintError($"An error occured sending the message Code: {code} Message: {message}");
                callback?.Invoke(code, default(T));
                return;
            }
            
            callback?.Invoke(code, JsonConvert.DeserializeObject<T>(message));
        }
        #endregion
        
        #region Helper Methods

        private const string OwnerIcon = "https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/47/47db946f27bc76d930ac82f1656f7a10707bb67d_full.jpg";

        private void AddPluginInfoFooter(Embed embed)
        {
            embed.AddFooter($"{Title} V{Version} by {Author}", OwnerIcon);
        }
        #endregion
        
        #region Embed Classes

        private class DiscordMessage
        {
            /// <summary>
            /// The id of the message
            /// </summary>
            [JsonProperty("id")]
            public string Id { get; set; }
            
            /// <summary>
            /// The name of the user sending the message changing this will change the webhook bots name
            /// </summary>
            [JsonProperty("username")]
            private string Username { get; set; }

            /// <summary>
            /// The avatar url of the user sending the message changing this will change the webhook bots avatar
            /// </summary>
            [JsonProperty("avatar_url")]
            private string AvatarUrl { get; set; }

            /// <summary>
            /// String only content to be sent
            /// </summary>
            [JsonProperty("content")]
            private string Content { get; set; }

            /// <summary>
            /// Embeds to be sent
            /// </summary>
            [JsonProperty("embeds")]
            private List<Embed> Embeds { get; set; }

            [JsonConstructor]
            public DiscordMessage()
            {

            }

            public DiscordMessage(string username = null, string avatarUrl = null)
            {
                Username = username;
                AvatarUrl = avatarUrl;
            }

            public DiscordMessage(string content, string username = null, string avatarUrl = null)
            {
                Content = content;
                Username = username;
                AvatarUrl = avatarUrl;
            }

            public DiscordMessage(Embed embed, string username = null, string avatarUrl = null)
            {
                Username = username;
                AvatarUrl = avatarUrl;
                AddEmbed(embed);
            }

            /// <summary>
            /// Adds a new embed to the list of embed to send
            /// </summary>
            /// <param name="embed">Embed to add</param>
            /// <returns>This</returns>
            /// <exception cref="IndexOutOfRangeException">Thrown if more than 10 embeds are added in a send as that is the discord limit</exception>
            public DiscordMessage AddEmbed(Embed embed)
            {
                if (Embeds == null)
                {
                    Embeds = new List<Embed>();
                }

                if (Embeds.Count >= 10)
                {
                    throw new IndexOutOfRangeException("Only 10 embeds are allowed per message");
                }

                Embeds.Add(embed);
                return this;
            }

            /// <summary>
            /// Adds string content to the message
            /// </summary>
            /// <param name="content"></param>
            /// <returns></returns>
            public DiscordMessage AddContent(string content)
            {
                Content = content;
                return this;
            }

            /// <summary>
            /// Changes the username and avatar image for the bot sending the message
            /// </summary>
            /// <param name="username">username to change</param>
            /// <param name="avatarUrl">avatar img url to change</param>
            /// <returns>This</returns>
            public DiscordMessage AddSender(string username, string avatarUrl)
            {
                Username = username;
                AvatarUrl = avatarUrl;
                return this;
            }

            /// <summary>
            /// Returns message as JSON to be sent in the web request
            /// </summary>
            /// <returns></returns>
            public StringBuilder ToJson() => new StringBuilder(JsonConvert.SerializeObject(this, Formatting.None,
                new JsonSerializerSettings {NullValueHandling = NullValueHandling.Ignore}));
        }

        private class Embed
        {
            /// <summary>
            /// Color of the left side bar of the embed message
            /// </summary>
            [JsonProperty("color")]
            private int Color { get; set; }

            /// <summary>
            /// Fields to be added to the embed message
            /// </summary>
            [JsonProperty("fields")]
            private List<Field> Fields { get; } = new List<Field>();

            /// <summary>
            /// Title of the embed message
            /// </summary>
            [JsonProperty("title")]
            private string Title { get; set; }

            /// <summary>
            /// Description of the embed message
            /// </summary>
            [JsonProperty("description")]
            private string Description { get; set; }
            
            /// <summary>
            /// Description of the embed message
            /// </summary>
            [JsonProperty("url")]
            private string Url { get; set; }

            /// <summary>
            /// Image to added to the embed message. Appears at the bottom of the message above the footer
            /// </summary>
            [JsonProperty("image")]
            private Image Image { get; set; }

            /// <summary>
            /// Thumbnail image added to the embed message. Appears in the top right corner
            /// </summary>
            [JsonProperty("thumbnail")]
            private Image Thumbnail { get; set; }

            /// <summary>
            /// Video to add to the embed message
            /// </summary>
            [JsonProperty("video")]
            private Video Video { get; set; }

            /// <summary>
            /// Author to add to the embed message. Appears above the title.
            /// </summary>
            [JsonProperty("author")]
            private AuthorInfo Author { get; set; }

            /// <summary>
            /// Footer to add to the embed message. Appears below all content.
            /// </summary>
            [JsonProperty("footer")]
            private Footer Footer { get; set; }
            
            /// <summary>
            /// Timestamp for the embed
            /// </summary>
            [JsonProperty("timestamp")]
            private DateTime? Timestamp { get; set; }

            /// <summary>
            /// Adds a title to the embed message
            /// </summary>
            /// <param name="title">Title to add</param>
            /// <returns>This</returns>
            public Embed AddTitle(string title)
            {
                Title = title;
                return this;
            }

            /// <summary>
            /// Adds a description to the embed message
            /// </summary>
            /// <param name="description">description to add</param>
            /// <returns>This</returns>
            public Embed AddDescription(string description)
            {
                Description = description;
                return this;
            }
            
            /// <summary>
            /// Adds a url to the embed message
            /// </summary>
            /// <param name="url"></param>
            /// <returns>This</returns>
            public Embed AddUrl(string url)
            {
                Url = url;
                return this;
            }

            /// <summary>
            /// Adds an author to the embed message. The author will appear above the title
            /// </summary>
            /// <param name="name">Name of the author</param>
            /// <param name="iconUrl">Icon Url to use for the author</param>
            /// <param name="url">Url to go to when the authors name is clicked on</param>
            /// <param name="proxyIconUrl">Backup icon url. Can be left null if you only have one icon url</param>
            /// <returns>This</returns>
            public Embed AddAuthor(string name, string iconUrl = null, string url = null, string proxyIconUrl = null)
            {
                Author = new AuthorInfo(name, iconUrl, url, proxyIconUrl);
                return this;
            }

            /// <summary>
            /// Adds a footer to the embed message
            /// </summary>
            /// <param name="text">Text to be added to the footer</param>
            /// <param name="iconUrl">Icon url to add in the footer. Appears to the left of the text</param>
            /// <param name="proxyIconUrl">Backup icon url. Can be left null if you only have one icon url</param>
            /// <returns>This</returns>
            public Embed AddFooter(string text, string iconUrl = null, string proxyIconUrl = null)
            {
                Footer = new Footer(text, iconUrl, proxyIconUrl);

                return this;
            }

            /// <summary>
            /// Adds an int based color to the embed. Color appears as a bar on the left side of the message
            /// </summary>
            /// <param name="color"></param>
            /// <returns></returns>
            public Embed AddColor(int color)
            {
                if (color < 0x0 || color > 0xFFFFFF)
                {
                    throw new Exception($"Color '{color}' is outside the valid color range");
                }
                
                Color = color;
                return this;
            }

            /// <summary>
            /// Adds a hex based color. Color appears as a bar on the left side of the message
            /// </summary>
            /// <param name="color">Color in string hex format</param>
            /// <returns>This</returns>
            /// <exception cref="Exception">Exception thrown if color is outside of range</exception>
            public Embed AddColor(string color)
            {
                int parsedColor = int.Parse(color.TrimStart('#'), NumberStyles.AllowHexSpecifier);
                if (parsedColor < 0x0 || parsedColor > 0xFFFFFF)
                {
                    throw new Exception($"Color '{color}' is outside the valid color range");
                }

                Color = parsedColor;
                return this;
            }

            /// <summary>
            /// Adds a RGB based color. Color appears as a bar on the left side of the message
            /// </summary>
            /// <param name="red">Red value between 0 - 255</param>
            /// <param name="green">Green value between 0 - 255</param>
            /// <param name="blue">Blue value between 0 - 255</param>
            /// <returns>This</returns>
            /// <exception cref="Exception">Thrown if red, green, or blue is outside of range</exception>
            public Embed AddColor(int red, int green, int blue)
            {
                if (red < 0 || red > 255 || green < 0 || green > 255 || blue < 0 || blue > 255)
                {
                    throw new Exception($"Color Red:{red} Green:{green} Blue:{blue} is outside the valid color range. Must be between 0 - 255");
                }

                Color = red * 65536 + green * 256 + blue;;
                return this;
            }

            /// <summary>
            /// Adds a blank field.
            /// If inline it will add a blank column.
            /// If not inline will add a blank row
            /// </summary>
            /// <param name="inline">If the field is inline</param>
            /// <returns>This</returns>
            public Embed AddBlankField(bool inline)
            {
                Fields.Add(new Field("\u200b", "\u200b", inline));
                return this;
            }

            /// <summary>
            /// Adds a new field with the name as the title and value as the value.
            /// If inline will add a new column. If row will add in a new row.
            /// </summary>
            /// <param name="name"></param>
            /// <param name="value"></param>
            /// <param name="inline"></param>
            /// <returns></returns>
            public Embed AddField(string name, string value, bool inline)
            {
                Fields.Add(new Field(name, value, inline));
                return this;
            }

            /// <summary>
            /// Adds an image to the embed. The url should point to the url of the image.
            /// If using attachment image you can make the url: "attachment://{image name}.{image extension}
            /// </summary>
            /// <param name="url">Url for the image</param>
            /// <param name="width">width of the image</param>
            /// <param name="height">height of the image</param>
            /// <param name="proxyUrl">Backup url for the image</param>
            /// <returns></returns>
            public Embed AddImage(string url, int? width = null, int? height = null, string proxyUrl = null)
            {
                Image = new Image(url, width, height, proxyUrl);
                return this;
            }

            /// <summary>
            /// Adds a thumbnail in the top right corner of the embed
            /// If using attachment image you can make the url: "attachment://{image name}.{image extension}
            /// </summary>
            /// <param name="url">Url for the image</param>
            /// <param name="width">width of the image</param>
            /// <param name="height">height of the image</param>
            /// <param name="proxyUrl">Backup url for the image</param>
            /// <returns></returns>
            public Embed AddThumbnail(string url, int? width = null, int? height = null, string proxyUrl = null)
            {
                Thumbnail = new Image(url, width, height, proxyUrl);
                return this;
            }

            /// <summary>
            /// Adds a video to the embed
            /// </summary>
            /// <param name="url">Url for the video</param>
            /// <param name="width">Width of the video</param>
            /// <param name="height">Height of the video</param>
            /// <returns></returns>
            public Embed AddVideo(string url, int? width = null, int? height = null)
            {
                Video = new Video(url, width, height);
                return this;
            }
            
            public Embed AddTimestamp()
            {
                Timestamp = DateTime.UtcNow;
                return this;
            }
            
            public Embed AddTimestamp(DateTime timestamp)
            {
                Timestamp = timestamp;
                return this;
            }
        }

        /// <summary>
        /// Field for and embed message
        /// </summary>
        private class Field
        {
            /// <summary>
            /// Name of the field
            /// </summary>
            [JsonProperty("name")]
            private string Name { get; }

            /// <summary>
            /// Value for the field
            /// </summary>
            [JsonProperty("value")]
            private string Value { get; }

            /// <summary>
            /// If the field should be in the same row or a new row
            /// </summary>
            [JsonProperty("inline")]
            private bool Inline { get; }

            public Field(string name, string value, bool inline)
            {
                Name = name;
                Value = value;
                Inline = inline;
            }
        }

        /// <summary>
        /// Image for an embed message
        /// </summary>
        private class Image
        {
            /// <summary>
            /// Url for the image
            /// </summary>
            [JsonProperty("url")]
            private string Url { get; }

            /// <summary>
            /// Width for the image
            /// </summary>
            [JsonProperty("width")]
            private int? Width { get; }

            /// <summary>
            /// Height for the image
            /// </summary>
            [JsonProperty("height")]
            private int? Height { get; }

            /// <summary>
            /// Proxy url for the image
            /// </summary>
            [JsonProperty("proxyURL")]
            private string ProxyUrl { get; }

            public Image(string url, int? width, int? height, string proxyUrl)
            {
                Url = url;
                Width = width;
                Height = height;
                ProxyUrl = proxyUrl;
            }
        }

        /// <summary>
        /// Video for an embed message
        /// </summary>
        private class Video
        {
            /// <summary>
            /// Url to the video
            /// </summary>
            [JsonProperty("url")]
            private string Url { get; }

            /// <summary>
            /// Width of the video
            /// </summary>
            [JsonProperty("width")]
            private int? Width { get; }

            /// <summary>
            /// Height of the video
            /// </summary>
            [JsonProperty("height")]
            private int? Height { get; }

            public Video(string url, int? width, int? height)
            {
                Url = url;
                Width = width;
                Height = height;
            }
        }

        /// <summary>
        /// Author of an embed message
        /// </summary>
        private class AuthorInfo
        {
            /// <summary>
            /// Name of the author
            /// </summary>
            [JsonProperty("name")]
            private string Name { get; }

            /// <summary>
            /// Url to go to when clicking on the authors name
            /// </summary>
            [JsonProperty("url")]
            private string Url { get; }

            /// <summary>
            /// Icon url for the author
            /// </summary>
            [JsonProperty("icon_url")]
            private string IconUrl { get; }

            /// <summary>
            /// Proxy icon url for the author
            /// </summary>
            [JsonProperty("proxy_icon_url")]
            private string ProxyIconUrl { get; }

            public AuthorInfo(string name, string iconUrl, string url, string proxyIconUrl)
            {
                Name = name;
                Url = url;
                IconUrl = iconUrl;
                ProxyIconUrl = proxyIconUrl;
            }
        }

        /// <summary>
        /// Footer for an embed message
        /// </summary>
        private class Footer
        {
            /// <summary>
            /// Text for the footer
            /// </summary>
            [JsonProperty("text")]
            private string Text { get; }

            /// <summary>
            /// Icon url for the footer
            /// </summary>
            [JsonProperty("icon_url")]
            private string IconUrl { get; }

            /// <summary>
            /// Proxy icon url for the footer
            /// </summary>
            [JsonProperty("proxy_icon_url")]
            private string ProxyIconUrl { get; }

            public Footer(string text, string iconUrl, string proxyIconUrl)
            {
                Text = text;
                IconUrl = iconUrl;
                ProxyIconUrl = proxyIconUrl;
            }
        }

        #endregion

        #region Attachment Classes
        /// <summary>
        /// Enum for attachment content type
        /// </summary>
        private enum AttachmentContentType
        {
            Png,
            Jpg
        }

        private class Attachment
        {
            /// <summary>
            /// Attachment data
            /// </summary>
            public byte[] Data { get; }
            
            /// <summary>
            /// File name for the attachment.
            /// Used in the url field of an image
            /// </summary>
            public string Filename { get; }
            
            /// <summary>
            /// Content type for the attachment
            /// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
            /// </summary>
            public string ContentType { get; }

            public Attachment(byte[] data, string filename, AttachmentContentType contentType)
            {
                Data = data;
                Filename = filename;

                switch (contentType)
                {
                    case AttachmentContentType.Jpg:
                        ContentType = "image/jpeg";
                        break;
                    
                    case AttachmentContentType.Png:
                        ContentType = "image/png";
                        break;
                }
            }

            public Attachment(byte[] data, string filename, string contentType)
            {
                Data = data;
                Filename = filename;
                ContentType = contentType;
            }
        }
        
        #endregion

        #region Config Classes

        public class DiscordMessageConfig
        {
            public string Content { get; set; }
 
            public List<EmbedConfig> Embeds { get; set; }
        }
        
        public class EmbedConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled { get; set; }
            
            [JsonProperty("Title")]
            public string Title { get; set; }
            
            [JsonProperty("Description")]
            public string Description { get; set; }
            
            [JsonProperty("Url")]
            public string Url { get; set; }
            
            [JsonProperty("Embed Color")]
            public string Color { get; set; }
            
            [JsonProperty("Image Url")]
            public string Image { get; set; }
            
            [JsonProperty("Thumbnail Url")]
            public string Thumbnail { get; set; }
            
            [JsonProperty("Add Timestamp")]
            public bool Timestamp { get; set; }
            
            [JsonProperty("Fields")]
            public List<FieldConfig> Fields { get; set; }
            
            [JsonProperty("Footer")]
            public FooterConfig Footer { get; set; }
        }
        
        public class FieldConfig
        {
            [JsonProperty("Title")]
            public string Title { get; set; }
            
            [JsonProperty("Value")]
            public string Value { get; set; }
            
            [JsonProperty("Inline")]
            public bool Inline { get; set; }

            [JsonProperty("Enabled")]
            public bool Enabled { get; set; }
        }

        public class FooterConfig
        {
            [JsonProperty("Icon Url")]
            public string IconUrl { get; set; }
            
            [JsonProperty("Text")]
            public string Text { get; set; }
            
            [JsonProperty("Enabled")]
            public bool Enabled { get; set; }
        }
        #endregion
        
        #region Config Methods
        private DiscordMessage ParseMessage(DiscordMessageConfig config)
        {
            DiscordMessage message = new DiscordMessage();

            if (!string.IsNullOrEmpty(config.Content))
            {
                message.AddContent(ParseField(config.Content));
            }

            if (config.Embeds != null)
            {
                foreach (EmbedConfig embedConfig in config.Embeds)
                {
                    if (!embedConfig.Enabled)
                    {
                        continue;
                    }

                    Embed embed = new Embed();
                    string title = ParseField(embedConfig.Title);
                    if (!string.IsNullOrEmpty(title))
                    {
                        embed.AddTitle(title);
                    }

                    string description = ParseField(embedConfig.Description);
                    if (!string.IsNullOrEmpty(description))
                    {
                        embed.AddDescription(description);
                    }

                    string url = ParseField(embedConfig.Url);
                    if (!string.IsNullOrEmpty(url))
                    {
                        embed.AddUrl(url);
                    }

                    string color = ParseField(embedConfig.Color);
                    if (!string.IsNullOrEmpty(color))
                    {
                        embed.AddColor(color);
                    }

                    string img = ParseField(embedConfig.Image);
                    if (!string.IsNullOrEmpty(img))
                    {
                        embed.AddImage(img);
                    }

                    string thumbnail = ParseField(embedConfig.Thumbnail);
                    if (!string.IsNullOrEmpty(thumbnail))
                    {
                        embed.AddThumbnail(thumbnail);
                    }

                    if (embedConfig.Timestamp)
                    {
                        embed.AddTimestamp();
                    }

                    foreach (FieldConfig field in embedConfig.Fields.Where(f => f.Enabled))
                    {
                        string value = ParseField(field.Value);
                        if (string.IsNullOrEmpty(value))
                        {
                            //PrintWarning($"Field: {field.Title} was skipped because the value was null or empty.");
                            continue;
                        }

                        embed.AddField(field.Title, value, field.Inline);
                    }

                    if (embedConfig.Footer != null && embedConfig.Footer.Enabled)
                    {
                        if (string.IsNullOrEmpty(embedConfig.Footer.Text) &&
                            string.IsNullOrEmpty(embedConfig.Footer.IconUrl))
                        {
                            AddPluginInfoFooter(embed);
                        }
                        else
                        {
                            string text = ParseField(embedConfig.Footer.Text);
                            string footerUrl = ParseField(embedConfig.Footer.IconUrl);
                            embed.AddFooter(text, footerUrl);
                        }
                    }

                    message.AddEmbed(embed);
                }
            }

            return message;
        }
        #endregion
        #endregion
    }
}


// --- End of file: DiscordServerStats.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/damage-mod-deployables ---
// --- Original File Path: D/DMDeployables/DMDeployables.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Damage Mod: Deployables", "ColonBlow", "1.1.13")]
    [Description("Prevents/allows damage to numerous deployables")]
    class DMDeployables : RustPlugin
    {
        // Added config option to only block damage if under TC Privledge if set to block damage for deployable

        private Dictionary<string, bool> deployables = new Dictionary<string, bool>();
        private Dictionary<string, string> prefabs = new Dictionary<string, string>();
        private bool init = false;

        void OnServerInitialized() => LoadVariables();

        void Unload()
        {
            deployables.Clear();
            prefabs.Clear();
        }

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (!init || entity == null || hitInfo == null)
                return null;

            var kvp = prefabs.FirstOrDefault(x => x.Key == entity.PrefabName);

            bool underPriv = entity.GetBuildingPrivilege();
            if (!underPriv) return !string.IsNullOrEmpty(kvp.Value) && deployables.ContainsKey(kvp.Value) && deployables[kvp.Value] && !blockOnlyUnderTC ? (object)true : null;
            else return !string.IsNullOrEmpty(kvp.Value) && deployables.ContainsKey(kvp.Value) && deployables[kvp.Value] ? (object)true : null;
        }

        #region Config
        private bool Changed;
        private bool blockOnlyUnderTC = false;

        void LoadVariables()
        {
            CheckCfg("_Global Setting - Only Block Damage if under TC Privledge ? ", ref blockOnlyUnderTC);

            foreach (var itemDef in ItemManager.GetItemDefinitions().ToList())
            {
                var mod = itemDef.GetComponent<ItemModDeployable>();

                if (mod != null)
                {
                    deployables[itemDef.displayName.translated] = Convert.ToBoolean(GetConfig("Deployables", string.Format("Block {0}", itemDef.displayName.translated), false));
                    prefabs[mod.entityPrefab.resourcePath] = itemDef.displayName.translated;
                }
            }

            init = true;

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
            LoadVariables();
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        #endregion
    }
}


// --- End of file: DMDeployables.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dynamic-wire-colors ---
// --- Original File Path: D/DynamicWireColors/DynamicWireColors.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using static WireTool;
using static IOEntity;

namespace Oxide.Plugins
{
    [Info("Dynamic Wire Colors", "WhiteThunder", "1.1.2")]
    [Description("Temporarily changes the color of wires and hoses while they are providing insufficient power or fluid.")]
    internal class DynamicWireColors : CovalencePlugin
    {
        #region Fields

        private Configuration _config;

        private const string PermissionUse = "dynamicwirecolors.use";

        private WaitWhile WaitWhileSaving = new(() => SaveRestore.IsSaving);

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
        }

        private void OnServerInitialized()
        {
            SetupAllEntities(networkUpdate: true, fixDestinationColor: true);
        }

        private void Unload()
        {
            ResetAllEntities(networkUpdate: true);
        }

        private void OnOutputUpdate(IOEntity sourceEntity)
        {
            NextTick(() =>
            {
                if (sourceEntity == null)
                    return;

                ProcessSourceEntity(sourceEntity);
            });
        }

        private void OnServerSave()
        {
            ServerMgr.Instance.StartCoroutine(ResetColorsWhileSaving());
        }

        #endregion

        #region Exposed Hooks

        private bool ChangeColorWasBlocked(IOEntity ioEntity, IOSlot slot, WireColour color)
        {
            return Interface.CallHook("OnDynamicWireColorChange", ioEntity, slot, color) is false;
        }

        #endregion

        #region Helper Methods

        private IOSlot GetConnectedSourceSlot(IOSlot destinationSlot, out IOEntity sourceEntity)
        {
            sourceEntity = destinationSlot.connectedTo.Get();
            if (sourceEntity == null)
                return null;

            return sourceEntity.outputs[destinationSlot.connectedToSlot];
        }

        private IOSlot GetConnectedDestinationSlot(IOSlot sourceSlot, out IOEntity destinationEntity)
        {
            destinationEntity = sourceSlot.connectedTo.Get();
            if (destinationEntity == null)
                return null;

            return destinationEntity.inputs[sourceSlot.connectedToSlot];
        }

        private void CopySourceSlotColorsToDestinationSlots(IOEntity sourceEntity)
        {
            // This fixes an issue where loading a save does not restore the input slot colors.
            // This workaround updates the input slot colors to match the output colors when the plugin loads.
            // Without this workaround, we can't use the input colors to know which color to revert back to.
            foreach (var sourceSlot in sourceEntity.outputs)
            {
                var destinationSlot = GetConnectedDestinationSlot(sourceSlot, out _);
                if (destinationSlot == null)
                    continue;

                // Note: This intentionally does not check permissions or call a hook because:
                //   a) It shouldn't be necessary.
                //   b) It would require that other parts of the plugin do the same checks.
                // This can be changed if it turns out that some other plugin is using the destination slot color for special reasons.
                if (destinationSlot.wireColour == WireColour.Gray)
                {
                    destinationSlot.wireColour = sourceSlot.wireColour;
                }
            }
        }

        private bool EntityHasPermission(IOEntity ioEntity)
        {
            if (ioEntity.OwnerID == 0)
                return _config.AppliesToUnownedEntities;

            if (!_config.RequiresPermission)
                return true;

            return permission.UserHasPermission(ioEntity.OwnerID.ToString(), PermissionUse);
        }

        private bool EitherEntityHasPermission(IOEntity ioEntity1, IOEntity ioEntity2, string perm)
        {
            return EntityHasPermission(ioEntity1) || EntityHasPermission(ioEntity2);
        }

        private void ChangeSlotColor(IOEntity ioEntity, IOSlot slot, WireColour color, bool networkUpdate)
        {
            if (slot.wireColour == color || ChangeColorWasBlocked(ioEntity, slot, color))
                return;

            slot.wireColour = color;

            if (networkUpdate)
            {
                ioEntity.SendNetworkUpdate();
            }
        }

        private void SetupAllEntities(bool networkUpdate, bool fixDestinationColor)
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var ioEntity = entity as IOEntity;
                if (ioEntity == null)
                    continue;

                if (fixDestinationColor)
                {
                    CopySourceSlotColorsToDestinationSlots(ioEntity);
                }

                ProcessSourceEntity(ioEntity, networkUpdate);
            }
        }

        private void ResetAllEntities(bool networkUpdate)
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var destinationEntity = entity as IOEntity;
                if (destinationEntity == null)
                    continue;

                foreach (var destinationSlot in destinationEntity.inputs)
                {
                    var sourceSlot = GetConnectedSourceSlot(destinationSlot, out var sourceEntity);
                    if (sourceSlot == null)
                        continue;

                    ChangeSlotColor(sourceEntity, sourceSlot, destinationSlot.wireColour, networkUpdate);
                }
            }
        }

        private bool HasOtherMainInput(IOEntity ioEntity, IOSlot currentSlot)
        {
            foreach (var slot in ioEntity.inputs)
            {
                if (slot.type == currentSlot.type && slot.mainPowerSlot && slot != currentSlot)
                    return true;
            }

            return false;
        }

        private bool SufficientPowerOrFluid(IOEntity destinationEntity, IOSlot destinationSlot, int inputAmount)
        {
            if (inputAmount == 0)
                return false;

            // Only electrical entities have the concept of "sufficient" power (could be wrong).
            if (destinationSlot.type != IOType.Electric)
                return true;

            if (inputAmount >= destinationEntity.ConsumptionAmount())
                return true;

            // If not providing sufficient power, only change color if there are no other main power inputs.
            // This avoids dynamically coloring a toggle input, for example, unless that input is providing exactly 0.
            return HasOtherMainInput(destinationEntity, destinationSlot);
        }

        private void ProcessSourceEntity(IOEntity sourceEntity, bool networkUpdate = true)
        {
            foreach (var sourceSlot in sourceEntity.outputs)
            {
                if (sourceSlot.type != IOType.Electric && sourceSlot.type != IOType.Fluidic)
                    continue;

                var destinationSlot = GetConnectedDestinationSlot(sourceSlot, out var destinationEntity);
                if (destinationSlot == null)
                    continue;

                if (!EitherEntityHasPermission(sourceEntity, destinationEntity, PermissionUse))
                    continue;

                var inputAmount = sourceEntity.GetPassthroughAmount(destinationSlot.connectedToSlot);

                if (SufficientPowerOrFluid(destinationEntity, destinationSlot, inputAmount))
                {
                    // Don't check for permission here since we want to be able to reset the color even if the player lost permission.
                    ChangeSlotColor(sourceEntity, sourceSlot, destinationSlot.wireColour, networkUpdate);
                }
                else if (EitherEntityHasPermission(sourceEntity, destinationEntity, PermissionUse))
                {
                    ChangeSlotColor(sourceEntity, sourceSlot, _config.GetInsufficientColorForType(sourceSlot.type), networkUpdate);
                }
            }
        }

        private IEnumerator ResetColorsWhileSaving()
        {
            // Reset colors so they save without modification, in case an ungraceful shutdown does not invoke Unload() before saving.
            TrackStart();
            ResetAllEntities(networkUpdate: false);
            TrackEnd();

            yield return WaitWhileSaving;

            // Restore dynamic colors, as if the plugin had just loaded.
            TrackStart();
            SetupAllEntities(networkUpdate: false, fixDestinationColor: false);
            TrackEnd();
        }

        #endregion

        #region Configuration

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("InsufficientPowerColor")]
            [JsonConverter(typeof(StringEnumConverter))]
            public WireColour InsufficientPowerColor = WireColour.Red;

            [JsonProperty("InsufficientFluidColor")]
            [JsonConverter(typeof(StringEnumConverter))]
            public WireColour InsufficientFluidColor = WireColour.Red;

            [JsonProperty("RequiresPermission")]
            public bool RequiresPermission = true;

            [JsonProperty("AppliesToUnownedEntities")]
            public bool AppliesToUnownedEntities = false;

            public WireColour GetInsufficientColorForType(IOType ioType)
            {
                return ioType == IOType.Fluidic
                    ? InsufficientFluidColor
                    : InsufficientPowerColor;
            }
        }

        private Configuration GetDefaultConfig() => new();

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion
    }
}


// --- End of file: DynamicWireColors.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/damage-mod-building-blocks ---
// --- Original File Path: D/DMBuildingBlocks/DMBuildingBlocks.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using System;

namespace Oxide.Plugins
{
    [Info("DMBuildingBlocks", "ColonBlow", "1.0.9")]
    class DMBuildingBlocks : RustPlugin
    {

        #region Loadup

        private void Loaded()
        {
            lang.RegisterMessages(messages, this);
            permission.RegisterPermission("dmbuildingblocks.admin", this);
        }

        #endregion

        #region Configuration

        private static PluginConfig config;

        private class PluginConfig
        {
            public GlobalSettings globalSettings { get; set; }

            public class GlobalSettings
            {
                [JsonProperty(PropertyName = "Scale - Precent of damage allowed to any Building block that is currently protected (default is 0%) : ")] public float ProtectionScale { get; set; }
                [JsonProperty(PropertyName = "Protect - Foundation Square ? ")] public bool ProtectFoundation { get; set; }
                [JsonProperty(PropertyName = "Protect - Foundation Steps ? ")] public bool ProtectFoundationSteps { get; set; }
                [JsonProperty(PropertyName = "Protect - Foundation Triange ? ")] public bool ProtectFoundationTriangle { get; set; }
                [JsonProperty(PropertyName = "Protect - Wall Low ? ")] public bool ProtectLowWall { get; set; }
                [JsonProperty(PropertyName = "Protect - Wall Half ? ")] public bool ProtectHalfWall { get; set; }
                [JsonProperty(PropertyName = "Protect - Wall Full ? ")] public bool ProtectWall { get; set; }
                [JsonProperty(PropertyName = "Protect - Wall Frame ? ")] public bool ProtectWallFrame { get; set; }
                [JsonProperty(PropertyName = "Protect - Wall Window ? ")] public bool ProtectWindowWall { get; set; }
                [JsonProperty(PropertyName = "Protect - Wall Doorway ? ")] public bool ProtectDoorway { get; set; }
                [JsonProperty(PropertyName = "Protect - Floor Square ? ")] public bool ProtectFloor { get; set; }
                [JsonProperty(PropertyName = "Protect - Floor Triangle ? ")] public bool ProtectFloorTriangle { get; set; }
                [JsonProperty(PropertyName = "Protect - Floor Triangle Frame ? ")] public bool ProtectTriangleFrame { get; set; }
                [JsonProperty(PropertyName = "Protect - Floor Frame ? ")] public bool ProtectFloorFrame { get; set; }
                [JsonProperty(PropertyName = "Protect - Stairs L Shaped ? ")] public bool ProtectStairsLShaped { get; set; }
                [JsonProperty(PropertyName = "Protect - Stairs U Shaped ? ")] public bool ProtectStairsUShaped { get; set; }
                [JsonProperty(PropertyName = "Protect - Stairs Spiral ? ")] public bool ProtectStairsSpiral { get; set; }
                [JsonProperty(PropertyName = "Protect - Stairs Spiral Triangle ? ")] public bool ProtectStairsSpiralTriangle { get; set; }
                [JsonProperty(PropertyName = "Protect - Ramp ? ")] public bool ProtectRamp { get; set; }
                [JsonProperty(PropertyName = "Protect - Roof ? ")] public bool ProtectRoof { get; set; }
            }

            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                globalSettings = new PluginConfig.GlobalSettings
                {
                    ProtectionScale = 0f,
                    ProtectFoundation = false,
                    ProtectFoundationSteps = false,
                    ProtectFoundationTriangle = false,
                    ProtectTriangleFrame = false,
                    ProtectLowWall = false,
                    ProtectHalfWall = false,
                    ProtectWall = false,
                    ProtectWallFrame = false,
                    ProtectWindowWall = false,
                    ProtectDoorway = false,
                    ProtectFloor = false,
                    ProtectFloorTriangle = false,
                    ProtectFloorFrame = false,
                    ProtectStairsLShaped = false,
                    ProtectStairsUShaped = false,
                    ProtectStairsSpiral = false,
                    ProtectStairsSpiralTriangle = false,
                    ProtectRamp = false,
                    ProtectRoof = false
                }
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created!!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Localization

        Dictionary<string, string> messages = new Dictionary<string, string>()
            {
                {"nopermission", "You do not have permission to use that command" },
                {"protectscale", "Protection Scale is set to : " },
                {"wrongsyntax", "Incorrect Syntax used. Please check to make sure you typed the commmand correctly" },
                {"ProtectFoundation", "You have set ProtectFoundations to " },
                {"ProtectFoundationSteps", "You have set ProtectFoundationSteps to " },
                {"ProtectFoundationTriangle", "You have set ProtectFoundationTriangle to " },
                {"ProtectWindowWall", "You have set ProtectWindowWall to " },
                {"ProtectDoorway", "You have set ProtectDoorway to " },
                {"ProtectFloor", "You have set ProtectFloor to " },
                {"ProtectFloorTriangle", "You have set ProtectFloorTriangles to " },
                {"ProtectHalfWall", "You have set ProtectHalfWall to " },
                {"ProtectStairsLShaped", "You have set ProtectStairsLShaped to " },
                {"ProtectStairsUShaped", "You have set ProtectStairsUShaped to " },
                {"ProtectStairsSpiral", "You have set ProtectStairsSpiral to " },
                {"ProtectStairsSpiralTriangle", "You have set ProtectStairsSpiralTriangle to " },
                {"ProtectRoof", "You have set ProtectRoof to " },
                {"ProtectRamp", "You have set ProtectRamp to " },
                {"ProtectLowWall", "You have set ProtectLowWall to " },
                {"ProtectWall", "You have set ProtectWall to " },
                {"ProtectWallFrame", "You have set ProtectWallFrame to " },
                {"ProtectTriangleFrame", "You have set ProtectTriangleFrame to " },
                {"ProtectFloorFrame", "You have set ProtectFloorFrame to " }
            };

        #endregion

        #region Hooks

        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        private void OnEntityTakeDamage(BuildingBlock buildingBlock, HitInfo hitInfo)
        {
            if (config.globalSettings.ProtectStairsSpiral == true && buildingBlock.name.Contains("block.stair.spiral")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectStairsSpiralTriangle == true && buildingBlock.name.Contains("stairs.spiral.triangle")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectTriangleFrame == true && buildingBlock.name.Contains("floor.triangle.frame")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectRamp == true && buildingBlock.name.Contains("ramp/ramp")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }

            else if (config.globalSettings.ProtectFoundation == true && buildingBlock.name.Contains("foundation/foundation")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectFoundationTriangle == true && buildingBlock.name.Contains("foundation.triangle")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectFoundationSteps == true && buildingBlock.name.Contains("foundation.steps")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectWindowWall == true && buildingBlock.name.Contains("wall.window")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectDoorway == true && buildingBlock.name.Contains("wall.doorway")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectFloor == true && buildingBlock.name.Contains("floor/floor")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectFloorTriangle == true && buildingBlock.name.Contains("floor.triangle") && !buildingBlock.name.Contains("frame")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectHalfWall == true && buildingBlock.name.Contains("wall.half")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectStairsLShaped == true && buildingBlock.name.Contains("stairs.l")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectStairsUShaped == true && buildingBlock.name.Contains("stairs.u")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectRoof == true && buildingBlock.name.Contains("roof/roof")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectLowWall == true && buildingBlock.name.Contains("wall.low")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectWall == true && buildingBlock.name.Contains("/wall/wall")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectWallFrame == true && buildingBlock.name.Contains("wall.frame")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
            else if (config.globalSettings.ProtectFloorFrame == true && buildingBlock.name.Contains("floor.frame")) { hitInfo.damageTypes.ScaleAll(config.globalSettings.ProtectionScale * 0.01f); return; }
        }

        #endregion

        #region Commands

        [ChatCommand("ProtectionScale")]
        private void chatCommand_ProtectionScale(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin"))
            {
                SendReply(player, lang.GetMessage("nopermission", this));
            }
            if (HasPermission(player, "dmbuildingblocks.admin"))
            {
                if (args != null && args.Length > 0)
                {
                    float argstring;

                    if (float.TryParse(args[0].ToLower(), out argstring))
                    {
                        config.globalSettings.ProtectionScale = argstring;
                        SaveConfig();
                        SendReply(player, lang.GetMessage("protectscale", this) + argstring.ToString() + "% Damage Allowed");
                    }
                    else
                    {
                        SendReply(player, lang.GetMessage("wrongsyntax", this));
                    }
                }
                return;
            }
        }

        [ChatCommand("ProtectFoundation")]
        private void chatCommand_ProtectFoundation(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectFoundation = true;
                if (argstring == "false") config.globalSettings.ProtectFoundation = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectFoundation", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectFoundationSteps")]
        private void chatCommand_ProtectFoundationSteps(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectFoundationSteps = true;
                if (argstring == "false") config.globalSettings.ProtectFoundationSteps = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectFoundationSteps", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectFoundationTriangle")]
        private void chatCommand_ProtectFoundationTriangle(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectFoundationTriangle = true;
                if (argstring == "false") config.globalSettings.ProtectFoundationTriangle = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectFoundationTriangle", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectTriangleFrame")]
        private void chatCommand_ProtectTriangleFrame(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectTriangleFrame = true;
                if (argstring == "false") config.globalSettings.ProtectTriangleFrame = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectTriangleFrame", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectWindowWall")]
        private void chatCommand_ProtectWindowWall(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectWindowWall = true;
                if (argstring == "false") config.globalSettings.ProtectWindowWall = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectWindowWall", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectDoorway")]
        private void chatCommand_ProtectDoorway(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectDoorway = true;
                if (argstring == "false") config.globalSettings.ProtectDoorway = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectDoorway", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectFloor")]
        private void chatCommand_ProtectFloor(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectFloor = true;
                if (argstring == "false") config.globalSettings.ProtectFloor = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectFloor", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectFloorTriangle")]
        private void chatCommand_ProtectFloorTriangle(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectFloorTriangle = true;
                if (argstring == "false") config.globalSettings.ProtectFloorTriangle = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectFloorTriangle", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectHalfWall")]
        private void chatCommand_ProtectHalfWall(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectHalfWall = true;
                if (argstring == "false") config.globalSettings.ProtectHalfWall = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectHalfWall", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectStairsLShaped")]
        private void chatCommand_ProtectStairsLShaped(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectStairsLShaped = true;
                if (argstring == "false") config.globalSettings.ProtectStairsLShaped = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectStairsLShaped", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectStairsUShaped")]
        private void chatCommand_ProtectStairsUShaped(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectStairsUShaped = true;
                if (argstring == "false") config.globalSettings.ProtectStairsUShaped = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectStairsUShaped", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectStairsSpiral")]
        private void chatCommand_ProtectStairsSpiral(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectStairsSpiral = true;
                if (argstring == "false") config.globalSettings.ProtectStairsSpiral = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectStairsSpiral", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectStairsSpiralTriangle")]
        private void chatCommand_ProtectStairsSpiralTriangle(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectStairsSpiralTriangle = true;
                if (argstring == "false") config.globalSettings.ProtectStairsSpiralTriangle = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectStairsSpiralTriangle", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectRoof")]
        private void chatCommand_ProtectRoof(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectRoof = true;
                if (argstring == "false") config.globalSettings.ProtectRoof = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectRoof", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectRamp")]
        private void chatCommand_ProtectRamp(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectRamp = true;
                if (argstring == "false") config.globalSettings.ProtectRamp = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectRamp", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectLowWall")]
        private void chatCommand_ProtectLowWall(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectLowWall = true;
                if (argstring == "false") config.globalSettings.ProtectLowWall = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectLowWall", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectWall")]
        private void chatCommand_ProtectWall(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectWall = true;
                if (argstring == "false") config.globalSettings.ProtectWall = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectWall", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectWallFrame")]
        private void chatCommand_ProtectWallFrame(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectWallFrame = true;
                if (argstring == "false") config.globalSettings.ProtectWallFrame = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectWallFrame", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        [ChatCommand("ProtectFloorFrame")]
        private void chatCommand_ProtectFloorFrame(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "dmbuildingblocks.admin")) { SendReply(player, lang.GetMessage("nopermission", this)); return; }
            if (args != null && args.Length > 0)
            {
                string argstring = args[0].ToLower();
                if (argstring == "true") config.globalSettings.ProtectFloorFrame = true;
                if (argstring == "false") config.globalSettings.ProtectFloorFrame = false;
                SaveConfig();
                SendReply(player, lang.GetMessage("ProtectFloorFrame", this) + argstring);
                return;
            }
            SendReply(player, lang.GetMessage("wrongsyntax", this));
        }

        #endregion
    }
}

// --- End of file: DMBuildingBlocks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-team ---
// --- Original File Path: D/DiscordTeam/DiscordTeam.cs ---

using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Entities.Applications;
using Oxide.Ext.Discord.Entities.Channels;
using Oxide.Ext.Discord.Entities.Gatway;
using Oxide.Ext.Discord.Entities.Gatway.Events;
using Oxide.Ext.Discord.Entities.Guilds;
using Oxide.Ext.Discord.Entities.Permissions;
using Oxide.Ext.Discord.Entities.Voice;
using Oxide.Ext.Discord.Libraries.Linking;
using Oxide.Ext.Discord.Logging;

namespace Oxide.Plugins
{
    [Info("Discord Team", "Owned", "2.0.0")]
    [Description("Creates a private voice channel in Discord when creating a team in-game")]
    class DiscordTeam : CovalencePlugin
    {
      #region Plugin variables
      [DiscordClient] private DiscordClient _client;
      private DiscordRole role;
      private Hash<string, DiscordChannel> listTeamChannels = new Hash<string, DiscordChannel>();
      private confData config;
      private bool _init;

      private readonly DiscordSettings _settings = new DiscordSettings
      {
        Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers | GatewayIntents.GuildVoiceStates
      };

      private readonly DiscordLink _link = GetLibrary<DiscordLink>();
      
      private DiscordGuild _guild;
      #endregion
      protected override void LoadDefaultConfig()
      {
        Config.WriteObject(new confData(),true);
      }
      public class confData
      {
        [JsonProperty("Discord Bot Token")]
        public string Token = string.Empty;
        
        [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
        public Snowflake GuildId { get; set; }

        [JsonProperty("Change channel when user create the team")]
        public bool moveLeader = true;

        [JsonProperty("Discord users can see other team's private vocal channel")]
        public bool seeOtherTeam = false;

        [JsonProperty("Using roles")]
        public bool roleUsage = false;

        [JsonProperty("Name of the player's role on discord (not @everyone)")]
        public string rolePlayer = "Player";

        [JsonProperty("Max players in a voice channel")]
        public int maxPlayersChannel = 3;
        
        [JsonConverter(typeof(StringEnumConverter))]
        [DefaultValue(DiscordLogLevel.Info)]
        [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
        public DiscordLogLevel ExtensionDebugging { get; set; } = DiscordLogLevel.Info;
      }

      protected override void LoadDefaultMessages()
      {
        lang.RegisterMessages(new Dictionary<string, string>
        {
          ["messageChannelCreated"] = "A private voice channel was created on Discord for your team !",
          ["messageChannelDeleted"] = "Your private voice channel on Discord has been deleted !",
          ["messageMemberJoin"] = "You have been added to your team's private voice channel on Discord !",
          ["messageMemberLeft"] = "You have been removed from your team's private voice channel on Discord !",
          ["channelName"] = "{0}'s Team"

        }, this);

        lang.RegisterMessages(new Dictionary<string, string>
        {
          ["messageChannelCreated"] = "Un salon vocal privé a été crée sur Discord pour votre équipe !",
          ["messageChannelDeleted"] = "Votre salon vocal privé sur Discord a été supprimé !",
          ["messageMemberJoin"] = "Vous avez été ajouté au salon vocal privé de votre équipe sur Discord !",
          ["messageMemberLeft"] = "Vous avez été retiré du salon vocal privé de votre équipe sur Discord !",
          ["channelName"] = "L'équipe de {0}"
        }, this, "fr");
      }

      string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);
      private void Init()
      {
        config = Config.ReadObject<confData>();
      }
      private void OnServerInitialized()
      {
        StartDiscordTeam();
      }

      private void StartDiscordTeam()
      {
        if (!string.IsNullOrEmpty(config.Token))
        {
          _settings.ApiToken = config.Token;
          _settings.LogLevel = config.ExtensionDebugging;
          _client.Connect(_settings);
        }
        else
        {
          PrintError("Discord Bot Token (API key) in the configuration file is missing");
        }
      }
      
      [HookMethod(DiscordHooks.OnDiscordGatewayReady)]
      private void OnDiscordGatewayReady(GatewayReadyEvent ready)
      {
        if (ready.Guilds.Count == 0)
        {
          PrintError("Your bot was not found in any discord servers. Please invite it to a server and reload the plugin.");
          return;
        }

        DiscordGuild guild = null;
        if (ready.Guilds.Count == 1 && !config.GuildId.IsValid())
        {
          guild = ready.Guilds.Values.FirstOrDefault();
        }

        if (guild == null)
        {
          guild = ready.Guilds[config.GuildId];
        }

        if (guild == null)
        {
          PrintError("Failed to find a matching guild for the Discord Server Id. " +
                     "Please make sure your guild Id is correct and the bot is in the discord server.");
          return;
        }
                
        if (!_client.Bot.Application.Flags.HasValue || !_client.Bot.Application.Flags.Value.HasFlag(ApplicationFlags.GatewayGuildMembersLimited))
        {
          PrintError($"You need to enable \"Server Members Intent\" for {_client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n" +
                     $"{Name} will not function correctly until that is fixed. Once updated please reload {Name}.");
          return;
        }
            
        _guild = guild;

        if(config.roleUsage)
        {
          if(string.IsNullOrEmpty(config.rolePlayer))
          {
            PrintError("The role specified in the configuration file is missing");
            return;
          }
        }
        Puts("Discord Team initialized");
        _init = true;
        initializeTeam();
      }

      void Unload()
      {
        if(_init)
        {
          if(listTeamChannels.Count > 0)
          {
            foreach(var leaderGameId in listTeamChannels)
            {
              deleteChannel(listTeamChannels[leaderGameId.Key]);
            }
            listTeamChannels.Clear();
          }
        }
      }

      private void OnUserConnected(IPlayer player)
      {
        if(_init)
        {
          string info = GetDiscord(player.Id);
          if (info == null)
          {
            return;
          }
          else
          {
            BasePlayer basePlayer = player.Object as BasePlayer;
            var currentTeam = basePlayer.currentTeam;
            if(currentTeam != 0)
            {
              RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.FindTeam(currentTeam);
              string leaderId = team.teamLeader.ToString();
              if(listTeamChannels[leaderId] != null)
              {
                if(basePlayer.UserIDString != leaderId)
                {
                  addPlayerChannel(basePlayer, listTeamChannels[leaderId]);
                }
              }
              else
              {
                if(basePlayer.UserIDString == leaderId)
                {
                  CreateChannelGuild(basePlayer);
                }
              }
            }
          }
        }
      }

      object OnTeamCreate(BasePlayer player)
      {
        if(_init)
        {
          string info = GetDiscord(player.UserIDString);
          if(info != null)
          {
            CreateChannelGuild(player);
          }
        }
        return null;
      }

      object OnTeamPromote(RelationshipManager.PlayerTeam team, BasePlayer newLeader)
      {
        if(_init)
        {
          string info = GetDiscord(newLeader.UserIDString);
          if(info != null)
          {
            string newLeaderId = newLeader.UserIDString;
            string oldLeaderId = team.teamLeader.ToString();
            if(listTeamChannels[oldLeaderId] != null)
            {
              listTeamChannels[newLeaderId] = listTeamChannels[oldLeaderId];
              listTeamChannels.Remove(oldLeaderId);
              renameChannel(listTeamChannels[newLeaderId], newLeader);
            }
          }
        }
        return null;
      }

      object OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
      {
        if(_init)
        {
          string info = GetDiscord(player.UserIDString);
          if(info != null)
          {
            string leaderId = team.teamLeader.ToString();
            if(listTeamChannels[leaderId] != null)
            {
              if(leaderId != player.UserIDString)
              {
                removePlayerChannel(player, listTeamChannels[leaderId]);
              }
            }
          }
        }
        return null;
        //quit channel
      }

      object OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player)
      {
        if(_init)
        {
          string info = GetDiscord(player.UserIDString);
          if(info != null)
          {
            string leaderId = team.teamLeader.ToString();
            if(listTeamChannels[leaderId] != null)
            {
              removePlayerChannel(player, listTeamChannels[leaderId]);
            }
          }
        }
        return null;
      }

      object OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player)
      {
        if(_init)
        {
          string info = GetDiscord(player.UserIDString);
          if(info != null)
          {
            string leaderId = team.teamLeader.ToString();
            if(listTeamChannels[leaderId] != null)
            {
              addPlayerChannel(player, listTeamChannels[leaderId]);
            }
          }
        }
        return null;
      }

      void OnTeamDisbanded(RelationshipManager.PlayerTeam team)
      {
        if(_init)
        {
          string leaderId = team.teamLeader.ToString();
          var player = team.GetLeader();
          if(listTeamChannels[leaderId] != null)
          {
            deleteChannel(listTeamChannels[leaderId]);
            listTeamChannels.Remove(leaderId);
            if(player != null)
            {
              player.ChatMessage(GetMessage("messageChannelDeleted", leaderId));
            }
          }
        }
      }

      public void CreateChannelGuild(BasePlayer player)
      {
        Snowflake discordId = GetDiscord(player.UserIDString);
        if(discordId.IsValid())
        {
          string playerId = player.UserIDString;
          List<Overwrite> permissionList = new List<Overwrite>();
          DiscordRole rolePlayer;
          if(config.roleUsage)
          {
            rolePlayer = GetRoleByName(config.rolePlayer);
            DiscordRole roleEveryone = _guild.EveryoneRole;
            permissionList.Add(new Overwrite {Id = roleEveryone.Id,Type = PermissionType.Role ,Deny = (PermissionFlags)66061568});
          }
          else
          {
            rolePlayer = _guild.EveryoneRole;
          }
          if(config.seeOtherTeam)
          {
            permissionList.Add(new Overwrite {Id = rolePlayer.Id,Type = PermissionType.Role,Allow = (PermissionFlags)1024,Deny = (PermissionFlags)66060544});
          }
          else
          {
            permissionList.Add(new Overwrite {Id = rolePlayer.Id,Type = PermissionType.Role,Deny = (PermissionFlags)66060544});
          }
          
          permissionList.Add(new Overwrite {Id = discordId,Type =PermissionType.Member, Allow = (PermissionFlags)36701184});
          GuildMember guildMember = GetGuildMember(player.UserIDString);
          _guild.CreateGuildChannel(_client, new ChannelCreate
          {
            Name = string.Format(GetMessage("channelName", playerId), player.displayName),
            Type = ChannelType.GuildVoice,
            UserLimit = config.maxPlayersChannel,
            PermissionOverwrites = permissionList
            
          },
           channelCreated =>
          {
            listTeamChannels[playerId] = channelCreated;
            if(config.moveLeader)
            {
              _guild.ModifyGuildMember(_client, guildMember.Id, new GuildMemberUpdate
              {
                ChannelId = channelCreated.Id
              });
            }
            player.ChatMessage(GetMessage("messageChannelCreated", player.UserIDString));
          });
        }
      }

      public void addPlayerChannel(BasePlayer player, DiscordChannel channel)
      {
        Snowflake discordId = GetDiscord(player.UserIDString);
        if(discordId.IsValid())
        {
          channel.EditChannelPermissions(_client, discordId, (PermissionFlags)36701184, null, PermissionType.Member);
          player.ChatMessage(GetMessage("messageMemberJoin", player.UserIDString));
        }
      }

      public void removePlayerChannel(BasePlayer player, DiscordChannel channel)
      {
        Snowflake discordId = GetDiscord(player.UserIDString);
        if(discordId.IsValid())
        {
          string playerId = player.UserIDString;
          GuildMember guildMember = GetGuildMember(playerId);

          GuildMemberUpdate update = new GuildMemberUpdate();
          VoiceState playerVoice = _guild.VoiceStates[guildMember.Id];
          if (playerVoice?.ChannelId != null && playerVoice.ChannelId != channel.Id)
          {
            update.ChannelId = playerVoice.ChannelId;
          }
          
          _guild.ModifyGuildMember(_client, guildMember.Id, update);
          if(config.seeOtherTeam)
          {
            channel.EditChannelPermissions(_client, discordId, (PermissionFlags)1024, (PermissionFlags)66060544, PermissionType.Member);
          }
          else
          {
            channel.EditChannelPermissions(_client, discordId, null, (PermissionFlags)66060544, PermissionType.Member);
          }
          player.ChatMessage(GetMessage("messageMemberLeft", player.UserIDString));
        }
      }

      public void initializeTeam()
      {
        if(_init)
        {
          foreach (var player in BasePlayer.activePlayerList)
          {
            if(player.currentTeam != 0)
            {
              RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
              string leaderId = team.teamLeader.ToString();
              if(leaderId == player.UserIDString)
              {
                if(listTeamChannels[leaderId] != null)
                {
                  foreach (var teamMember in team.members)
                  {
                    if(teamMember.ToString() != leaderId)
                    {
                      string discordId = GetDiscord(player.UserIDString);
                      if(discordId != null)
                      {
                        BasePlayer member = RelationshipManager.FindByID(teamMember);
                        if(member != null)
                        {
                          addPlayerChannel(member, listTeamChannels[leaderId]);
                        }
                      }
                    }
                  }
                }
                else
                {
                  string discordId = GetDiscord(player.UserIDString);
                  if(discordId != null)
                  {
                    CreateChannelGuild(player);
                  }
                }
              }
            }
          }
        }
      }

      #region Discord functions
      public void deleteChannel(DiscordChannel channel)
      {
        channel.DeleteChannel(_client);
      }

      public void renameChannel(DiscordChannel channel, BasePlayer newLeader)
      {
        channel.ModifyGuildChannel(_client, new GuildChannelUpdate
        {
          Name = string.Format(GetMessage("channelName", newLeader.UserIDString), newLeader.displayName)
        });
      }

      public DiscordRole GetRoleByName(string roleName)
      {
        return _guild.GetRole(roleName);
      }

      private Snowflake GetDiscord(string steamId)
      {
        return _link.GetDiscordId(steamId) ?? default(Snowflake);
      }

      public GuildMember GetGuildMember(string steamId)
      {
        Snowflake discordId = GetDiscord(steamId);
        if(discordId.IsValid())
        {
          return _guild.Members[discordId];
        }
        return null;
      }
      #endregion
    }
}

// --- End of file: DiscordTeam.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/despawn-config ---
// --- Original File Path: D/DespawnConfig/DespawnConfig.cs ---

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Despawn Config", "Wulf", "2.2.3")]
    [Description("Configurable despawn times for dropped items and item containers")]
    class DespawnConfig : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Global despawn time")]
            public float GlobalDespawnTime = -1f;

            [JsonProperty("Item container despawn time")]
            public float ItemContainerDespawnTime = 30f;

            [JsonProperty("Despawn item container with items")]
            public bool DespawnContainerWithItems = false;

            [JsonProperty("Item despawn times", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SortedDictionary<string, float> ItemDespawnTimes = new SortedDictionary<string, float>();

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());

            public float GetItemDespawnTime(Item item)
            {
                if (item == null)
                {
                    return 0;
                }

                if (GlobalDespawnTime >= 0)
                {
                    return GlobalDespawnTime * 60f;
                }

                if (!ItemDespawnTimes.ContainsKey(item.info.shortname))
                {
                    _plugin.LogError($"Couldn't find despawn time for {item.info.shortname}; using default of 5 minutes");
                    return 5;
                }

                return ItemDespawnTimes[item.info.shortname] * 60f;
            }
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Initialization

        private static DespawnConfig _plugin;

        private void Init()
        {
            _plugin = this;

            Unsubscribe(nameof(OnEntitySpawned));
        }
        
        private void Unload()
        {
            _plugin = null;
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));

            int origDespawnTimes = config.ItemDespawnTimes.Count;
            foreach (ItemDefinition item in ItemManager.itemList)
            {
                if (!config.ItemDespawnTimes.ContainsKey(item.shortname))
                {
                    config.ItemDespawnTimes.Add(item.shortname, item.quickDespawn ? 30 : Mathf.Clamp(((int)item.rarity - 1) * 4, 1, 100) * 300 / 60);
                }
            }
            int newDespawnTimes = config.ItemDespawnTimes.Count;
            if (!origDespawnTimes.Equals(newDespawnTimes))
            {
                Log($"Saved {newDespawnTimes - origDespawnTimes} new items to configuration");
                SaveConfig();
            }

            foreach (BaseNetworkable networkable in BaseNetworkable.serverEntities)
            {
                SetDespawnTime(networkable);
            }

            if (config.GlobalDespawnTime > -1)
            {
                LogWarning($"Global respawn time is currently set to {config.GlobalDespawnTime}; individal item despawn times overridden");
            }
        }

        #endregion Initialization

        #region Despawn Handling

        private void OnDroppedItemCombined(DroppedItem item) => SetDespawnTime(item);

        private void OnEntitySpawned(DroppedItem item) => SetDespawnTime(item);

        private void OnEntitySpawned(DroppedItemContainer itemContainer) => SetDespawnTime(itemContainer);

        private void SetDespawnTime(BaseNetworkable itemOrContainer)
        {
            if (!(itemOrContainer is ItemPickup) && itemOrContainer is DroppedItem)
            {
                DroppedItem item = itemOrContainer as DroppedItem;
                
                if (item != null && !item.IsDestroyed)
                {
                    item.CancelInvoke(item.IdleDestroy);
                    item.Invoke(item.IdleDestroy, config.GetItemDespawnTime(item.item));
                }
            }
            
            if (itemOrContainer is DroppedItemContainer)
            {
                DroppedItemContainer container = itemOrContainer as DroppedItemContainer;
                
                if (!config.DespawnContainerWithItems || container.inventory == null)
                {
                    container.ResetRemovalTime(config.ItemContainerDespawnTime * 60f);
                    return;
                }
                
                List<Item> items = container.inventory.itemList;
                float despawnTime = 0;
                
                for (int i = 0; i < items.Count; i++)
                {
                    float time = config.GetItemDespawnTime(items[i]);

                    if (time <= despawnTime)
                    {
                        continue;
                    }

                    despawnTime = time;
                }

                timer.In(1f, () =>
                {
                    container.CancelInvoke(container.RemoveMe);
                    container?.ResetRemovalTime(despawnTime);
                });
            }
        }

        #endregion Despawn Handling
    }
}

// --- End of file: DespawnConfig.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-chat ---
// --- Original File Path: D/DiscordChat/DiscordChat.cs ---

using ConVar;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord.Cache;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.Types;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

//DiscordChat created with PluginMerge v(1.0.9.0) by MJSU @ https://github.com/dassjosh/Plugin.Merge
namespace Oxide.Plugins
{
    [Info("Discord Chat", "MJSU", "3.0.5")]
    [Description("Allows chatting between discord and game server")]
    public partial class DiscordChat : CovalencePlugin, IDiscordPlugin, IDiscordPool
    {
        #region Plugins\DiscordChat.AdminChat.cs
        private AdminChatSettings _adminChatSettings;
        
        private const string AdminChatPermission = "adminchat.use";
        
        //Hook called from AdminChat Plugin
        [HookMethod(nameof(OnAdminChat))]
        public void OnAdminChat(IPlayer player, string message)
        {
            if (IsAdminChatEnabled())
            {
                HandleMessage(message, player, player.GetDiscordUser(), MessageSource.PluginAdminChat, null);
            }
        }
        
        //Message sent in admin chat channel. Process bot replace and sending to server
        public void HandleAdminChatDiscordMessage(DiscordMessage message)
        {
            IPlayer player = message.Author.Player;
            if (player == null)
            {
                message.ReplyWithGlobalTemplate(Client, TemplateKeys.Error.AdminChat.NotLinked, null, GetDefault().AddMessage(message));
                return;
            }
            
            if (!CanPlayerAdminChat(player))
            {
                message.ReplyWithGlobalTemplate(Client, TemplateKeys.Error.AdminChat.NoPermission, null, GetDefault().AddPlayer(player).AddMessage(message));
                return;
            }
            
            HandleMessage(message.Content, player, player.GetDiscordUser(), MessageSource.PluginAdminChat, message);
        }
        
        public bool IsAdminChatEnabled() => _adminChatSettings.Enabled && Sends.ContainsKey(MessageSource.PluginAdminChat);
        public bool CanPlayerAdminChat(IPlayer player) => player != null && _adminChatSettings.Enabled && player.HasPermission(AdminChatPermission);
        #endregion

        #region Plugins\DiscordChat.BetterChat.cs
        public bool SendBetterChatMessage(IPlayer player, string message, MessageSource source)
        {
            if (!IsPluginLoaded(BetterChat))
            {
                return false;
            }
            
            Dictionary<string, object> data = GetBetterChatMessageData(player, message);
            if (source == MessageSource.Discord && !string.IsNullOrEmpty(_pluginConfig.ChatSettings.DiscordTag))
            {
                BetterChatSettings settings = _pluginConfig.PluginSupport.BetterChat;
                List<string> titles = GetBetterChatTags(data);
                if (titles != null)
                {
                    titles.Add(_pluginConfig.ChatSettings.DiscordTag);
                    while (titles.Count > settings.ServerMaxTags)
                    {
                        titles.RemoveAt(0);
                    }
                }
            }
            BetterChat.Call("API_SendMessage", data);
            return true;
        }
        
        public Dictionary<string, object> GetBetterChatMessageData(IPlayer player, string message)
        {
            return BetterChat.Call<Dictionary<string, object>>("API_GetMessageData", player, message);
        }
        
        public List<string> GetBetterChatTags(Dictionary<string, object> data)
        {
            if (data["Titles"] is List<string> titles)
            {
                titles.RemoveAll(string.IsNullOrWhiteSpace);
                for (int index = 0; index < titles.Count; index++)
                {
                    string title = titles[index];
                }
                
                return titles;
            }
            
            return null;
        }
        #endregion

        #region Plugins\DiscordChat.Clans.cs
        private void OnClanChat(IPlayer player, string message)
        {
            Sends[MessageSource.PluginClan]?.QueueMessage(Lang(LangKeys.Discord.PluginClans.ClanMessage, GetClanPlaceholders(player, message)));
        }
        
        private void OnAllianceChat(IPlayer player, string message)
        {
            Sends[MessageSource.PluginAlliance]?.QueueMessage(Lang(LangKeys.Discord.PluginClans.AllianceMessage, GetClanPlaceholders(player, message)));
        }
        
        public PlaceholderData GetClanPlaceholders(IPlayer player, string message)
        {
            return GetDefault().AddPlayer(player).Add(PlaceholderDataKeys.PlayerMessage, message);
        }
        #endregion

        #region Plugins\DiscordChat.DiscordHooks.cs
        [HookMethod(DiscordExtHooks.OnDiscordClientCreated)]
        private void OnDiscordClientCreated()
        {
            if (!string.IsNullOrEmpty(_pluginConfig.DiscordApiKey))
            {
                RegisterPlaceholders();
                RegisterTemplates();
                Client.Connect(new BotConnection
                {
                    Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers | GatewayIntents.GuildMessages | GatewayIntents.MessageContent,
                    ApiToken = _pluginConfig.DiscordApiKey,
                    LogLevel = _pluginConfig.ExtensionDebugging
                });
            }
        }
        
        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            if (ready.Guilds.Count == 0)
            {
                PrintError("Your bot was not found in any discord servers. Please invite it to a server and reload the plugin.");
                return;
            }
            
            DiscordApplication app = Client.Bot.Application;
            if (!app.HasApplicationFlag(ApplicationFlags.GatewayMessageContentLimited))
            {
                PrintWarning($"You will need to enable \"Message Content Intent\" for {Client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n by April 2022" +
                $"{Name} will stop function correctly after that date until that is fixed. Once updated please reload {Name}.");
            }
            
            Puts($"{Title} Ready");
        }
        
        [HookMethod(DiscordExtHooks.OnDiscordGuildCreated)]
        private void OnDiscordGuildCreated(DiscordGuild guild)
        {
            if (_pluginConfig.ChatSettings.DiscordToServer)
            {
                SetupChannel(guild, MessageSource.Server, _pluginConfig.ChatSettings.ChatChannel, _pluginConfig.ChatSettings.UseBotToDisplayChat, HandleDiscordChatMessage);
            }
            else
            {
                SetupChannel(guild, MessageSource.Server, _pluginConfig.ChatSettings.ChatChannel, _pluginConfig.ChatSettings.UseBotToDisplayChat);
            }
            
            SetupChannel(guild, MessageSource.Discord, _pluginConfig.ChatSettings.ChatChannel, _pluginConfig.ChatSettings.UseBotToDisplayChat);
            
            SetupChannel(guild, MessageSource.Connecting, _pluginConfig.PlayerStateSettings.PlayerStateChannel);
            SetupChannel(guild, MessageSource.Connected, _pluginConfig.PlayerStateSettings.PlayerStateChannel);
            SetupChannel(guild, MessageSource.Disconnected, _pluginConfig.PlayerStateSettings.PlayerStateChannel);
            SetupChannel(guild, MessageSource.PluginAdminChat, _pluginConfig.PluginSupport.AdminChat.ChatChannel, _pluginConfig.ChatSettings.UseBotToDisplayChat, HandleAdminChatDiscordMessage);
            SetupChannel(guild, MessageSource.PluginClan, _pluginConfig.PluginSupport.Clans.ClansChatChannel, _pluginConfig.ChatSettings.UseBotToDisplayChat);
            SetupChannel(guild, MessageSource.PluginAlliance, _pluginConfig.PluginSupport.Clans.AllianceChatChannel, _pluginConfig.ChatSettings.UseBotToDisplayChat);
            
            #if RUST
            SetupChannel(guild, MessageSource.Team, _pluginConfig.ChatSettings.TeamChannel);
            SetupChannel(guild, MessageSource.Cards, _pluginConfig.ChatSettings.CardsChannel);
            SetupChannel(guild, MessageSource.Clan, _pluginConfig.ChatSettings.ClansChannel);
            #endif
            
            if (_pluginConfig.ChatSettings.ChatChannel.IsValid()
            #if RUST
            || _pluginConfig.ChatSettings.TeamChannel.IsValid()
            || _pluginConfig.ChatSettings.CardsChannel.IsValid()
            #endif
            )
            {
                #if RUST
                Subscribe(nameof(OnPlayerChat));
                #else
                Subscribe(nameof(OnUserChat));
                #endif
            }
            
            if (_pluginConfig.PlayerStateSettings.PlayerStateChannel.IsValid())
            {
                if (_pluginConfig.PlayerStateSettings.SendConnectingMessage)
                {
                    Subscribe(nameof(OnUserApproved));
                }
                
                if (_pluginConfig.PlayerStateSettings.SendConnectedMessage)
                {
                    Subscribe(nameof(OnUserConnected));
                }
                
                if (_pluginConfig.PlayerStateSettings.SendDisconnectedMessage)
                {
                    Subscribe(nameof(OnUserDisconnected));
                }
            }
            
            if (_pluginConfig.ServerStateSettings.ServerStateChannel.IsValid())
            {
                Subscribe(nameof(OnServerShutdown));
            }
            
            if (_pluginConfig.PluginSupport.Clans.ClansChatChannel.IsValid())
            {
                Subscribe(nameof(OnClanChat));
            }
            
            if (_pluginConfig.PluginSupport.Clans.AllianceChatChannel.IsValid())
            {
                Subscribe(nameof(OnAllianceChat));
            }
            
            timer.In(0.1f, () =>
            {
                if (!_serverInitCalled && _pluginConfig.ServerStateSettings.SendBootingMessage)
                {
                    SendGlobalTemplateMessage(TemplateKeys.Server.Booting, FindChannel(_pluginConfig.ServerStateSettings.ServerStateChannel), GetDefault());
                }
            });
        }
        
        public void SetupChannel(DiscordGuild guild, MessageSource source, Snowflake id, bool wipeNonBotMessages = false, Action<DiscordMessage> callback = null)
        {
            if (!id.IsValid())
            {
                return;
            }
            
            DiscordChannel channel = guild.Channels[id];
            if (channel == null)
            {
                //PrintWarning($"Channel with ID: '{id}' not found in guild");
                return;
            }
            
            if (callback != null)
            {
                _subscriptions.AddChannelSubscription(Client, id, callback);
            }
            
            if (wipeNonBotMessages)
            {
                channel.GetMessages(Client, new ChannelMessagesRequest{Limit = 100})
                .Then(messages =>
                {
                    OnGetChannelMessages(messages, callback);
                });
            }
            
            Sends[source] = new DiscordSendQueue(channel, GetTemplateName(source), timer);;
            Puts($"Setup Channel {source} With ID: {id}");
        }
        
        private void OnGetChannelMessages(List<DiscordMessage> messages, Action<DiscordMessage> callback)
        {
            if (messages.Count == 0 || callback == null)
            {
                return;
            }
            
            foreach (DiscordMessage message in messages
            .Where(m => !m.Author.IsBot
            && (DateTimeOffset.UtcNow - m.Id.GetCreationDate()).TotalDays < 14
            && CanSendMessage(m.Content, m.Author.Player, m.Author, MessageSource.Discord, m)))
            {
                callback.Invoke(message);
            }
        }
        
        public void HandleDiscordChatMessage(DiscordMessage message)
        {
            IPlayer player = message.Author.Player;
            if (Interface.Oxide.CallHook("OnDiscordChatMessage", player, message.Content, message.Author) != null)
            {
                return;
            }
            
            HandleMessage(message.Content, player, message.Author, MessageSource.Discord, message);
            
            if (_pluginConfig.ChatSettings.UseBotToDisplayChat)
            {
                message.Delete(Client).Catch<ResponseError>(error =>
                {
                    if (error.DiscordError is { Code: 50013 })
                    {
                        PrintError($"ChatSettings.UseBotToDisplayChat is enabled but the bot doesn't have permission to delete messages in channel {Client.Bot.Servers[message.GuildId ?? default]?.Channels[message.ChannelId]?.Name ?? message.ChannelId}");
                        error.SuppressErrorMessage();
                    }
                });
            }
        }
        #endregion

        #region Plugins\DiscordChat.Fields.cs
        [PluginReference]
        private Plugin BetterChat;
        
        public DiscordClient Client { get; set; }
        public DiscordPluginPool Pool { get; set; }
        
        private PluginConfig _pluginConfig;
        
        private readonly DiscordSubscriptions _subscriptions = GetLibrary<DiscordSubscriptions>();
        private readonly DiscordPlaceholders _placeholders = GetLibrary<DiscordPlaceholders>();
        private readonly DiscordMessageTemplates _templates = GetLibrary<DiscordMessageTemplates>();
        
        private bool _serverInitCalled;
        
        public readonly Hash<MessageSource, DiscordSendQueue> Sends = new();
        private readonly List<IPluginHandler> _plugins = new();
        
        public static DiscordChat Instance;
        
        private readonly object _true = true;
        #endregion

        #region Plugins\DiscordChat.Helpers.cs
        public MessageSource GetSourceFromServerChannel(int channel)
        {
            switch (channel)
            {
                case 1:
                return MessageSource.Team;
                case 3:
                return MessageSource.Cards;
                case 5:
                return MessageSource.Clan;
            }
            
            return MessageSource.Server;
        }
        
        public DiscordChannel FindChannel(Snowflake channelId)
        {
            if (!channelId.IsValid())
            {
                return null;
            }
            
            foreach (DiscordGuild guild in Client.Bot.Servers.Values)
            {
                DiscordChannel channel = guild.Channels[channelId];
                if (channel != null)
                {
                    return channel;
                }
            }
            
            return null;
        }
        
        public bool IsPluginLoaded(Plugin plugin) => plugin != null && plugin.IsLoaded;
        
        public new void Subscribe(string hook)
        {
            base.Subscribe(hook);
        }
        
        public new void Unsubscribe(string hook)
        {
            base.Unsubscribe(hook);
        }
        
        public void Puts(string message)
        {
            base.Puts(message);
        }
        #endregion

        #region Plugins\DiscordChat.Hooks.cs
        private void OnUserApproved(string name, string id, string ip)
        {
            IPlayer player = players.FindPlayerById(id) ?? PlayerExt.CreateDummyPlayer(id, name, ip);
            if (_pluginConfig.PlayerStateSettings.ShowAdmins || !player.IsAdmin)
            {
                PlaceholderData placeholders = GetDefault().AddPlayer(player).AddIp(ip);
                ProcessPlayerState(MessageSource.Connecting, LangKeys.Discord.Player.Connecting, placeholders);
            }
        }
        
        private void OnUserConnected(IPlayer player)
        {
            if (_pluginConfig.PlayerStateSettings.ShowAdmins || !player.IsAdmin)
            {
                PlaceholderData placeholders = GetDefault().AddPlayer(player);
                ProcessPlayerState(MessageSource.Connected, LangKeys.Discord.Player.Connected, placeholders);
            }
        }
        
        private void OnUserDisconnected(IPlayer player, string reason)
        {
            if (_pluginConfig.PlayerStateSettings.ShowAdmins || !player.IsAdmin)
            {
                PlaceholderData placeholders = GetDefault().AddPlayer(player).Add(PlaceholderDataKeys.DisconnectReason, reason);
                ProcessPlayerState(MessageSource.Disconnected, LangKeys.Discord.Player.Disconnected, placeholders);
            }
        }
        
        public void ProcessPlayerState(MessageSource source, string langKey, PlaceholderData data)
        {
            string message = Lang(langKey, data);
            Sends[source]?.QueueMessage(message);
        }
        
        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin == null)
            {
                return;
            }
            
            OnPluginUnloaded(plugin);
            
            switch (plugin.Name)
            {
                case "AdminChat":
                AddHandler(new AdminChatHandler(Client, this, _pluginConfig.PluginSupport.AdminChat, plugin));
                break;
                
                case "AdminDeepCover":
                AddHandler(new AdminDeepCoverHandler(this, plugin));
                break;
                
                case "AntiSpam":
                if (plugin.Version < new VersionNumber(2, 0, 0))
                {
                    PrintError("AntiSpam plugin must be version 2.0.0 or higher");
                    break;
                }
                
                AddHandler(new AntiSpamHandler(this, _pluginConfig.PluginSupport.AntiSpam, plugin));
                break;
                
                case "BetterChatMute":
                BetterChatMuteSettings muteSettings = _pluginConfig.PluginSupport.BetterChatMute;
                if (muteSettings.IgnoreMuted)
                {
                    AddHandler(new BetterChatMuteHandler(this, muteSettings, plugin));
                }
                break;
                
                case "BetterChat":
                AddHandler(new BetterChatHandler(this, _pluginConfig.PluginSupport.BetterChat, plugin));
                break;
                
                case "TranslationAPI":
                AddHandler(new TranslationApiHandler(this, _pluginConfig.PluginSupport.ChatTranslator, plugin));
                break;
                
                case "UFilter":
                AddHandler(new UFilterHandler(this, _pluginConfig.PluginSupport.UFilter, plugin));
                break;
            }
        }
        
        public void AddHandler(IPluginHandler handler)
        {
            _plugins.Add(handler);
        }
        
        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin.Name != Name)
            {
                _plugins.RemoveAll(h => h.GetPluginName() == plugin.Name);
            }
        }
        
        #if RUST
        private void OnPlayerChat(BasePlayer rustPlayer, string message, Chat.ChatChannel chatChannel)
        {
            HandleChat(rustPlayer.IPlayer, message, (int)chatChannel);
        }
        #else
        private void OnUserChat(IPlayer player, string message)
        {
            HandleChat(player, message, 0);
        }
        #endif
        
        public void HandleChat(IPlayer player, string message, int channel)
        {
            DiscordUser user = player.GetDiscordUser();
            MessageSource source = GetSourceFromServerChannel(channel);
            
            if (Sends.ContainsKey(source))
            {
                HandleMessage(message, player, user, source, null);
            }
        }
        #endregion

        #region Plugins\DiscordChat.Lang.cs
        public string Lang(string key, PlaceholderData data)
        {
            string message = lang.GetMessage(key, this);
            message = _placeholders.ProcessPlaceholders(message, data);
            return message;
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Discord.Player.Connecting] = $":yellow_circle: {DefaultKeys.TimestampNow.ShortTime} {DefaultKeys.Ip.CountryEmoji} **{PlaceholderKeys.PlayerName}** is connecting",
                [LangKeys.Discord.Player.Connected] = $":white_check_mark: {DefaultKeys.TimestampNow.ShortTime} {DefaultKeys.Player.CountryEmoji} **{PlaceholderKeys.PlayerName}** has joined.",
                [LangKeys.Discord.Player.Disconnected] = $":x: {DefaultKeys.TimestampNow.ShortTime} **{PlaceholderKeys.PlayerName}** has disconnected. ({PlaceholderKeys.DisconnectReason})",
                [LangKeys.Discord.Chat.Server] = $":desktop: {DefaultKeys.TimestampNow.ShortTime} **{PlaceholderKeys.PlayerName}**: {PlaceholderKeys.PlayerMessage}",
                [LangKeys.Discord.Chat.LinkedMessage] = $":speech_left: {DefaultKeys.TimestampNow.ShortTime} **{PlaceholderKeys.PlayerName}**: {PlaceholderKeys.PlayerMessage}",
                [LangKeys.Discord.Chat.UnlinkedMessage] = $":chains: {DefaultKeys.TimestampNow.ShortTime} {DefaultKeys.User.Mention}: {PlaceholderKeys.PlayerMessage}",
                [LangKeys.Discord.Chat.PlayerName] = $"{DefaultKeys.Player.Name}",
                [LangKeys.Discord.Team.Message] = $":busts_in_silhouette: {DefaultKeys.TimestampNow.ShortTime} **{PlaceholderKeys.PlayerName}**: {PlaceholderKeys.PlayerMessage}",
                [LangKeys.Discord.Cards.Message] = $":black_joker: {DefaultKeys.TimestampNow.ShortTime} **{PlaceholderKeys.PlayerName}**: {PlaceholderKeys.PlayerMessage}",
                [LangKeys.Discord.Clans.Message] = $":shield: {DefaultKeys.TimestampNow.ShortTime} **{PlaceholderKeys.PlayerName}**: {PlaceholderKeys.PlayerMessage}",
                [LangKeys.Discord.AdminChat.ServerMessage] = $":mechanic: {DefaultKeys.TimestampNow.ShortTime} **{PlaceholderKeys.PlayerName}**: {PlaceholderKeys.PlayerMessage}",
                [LangKeys.Discord.AdminChat.DiscordMessage] = $":mechanic: {DefaultKeys.TimestampNow.ShortTime} **{PlaceholderKeys.PlayerName}**: {PlaceholderKeys.PlayerMessage}",
                [LangKeys.Discord.PluginClans.ClanMessage] = $"{DefaultKeys.TimestampNow.ShortTime} [Clan] **{PlaceholderKeys.PlayerName}**: {PlaceholderKeys.PlayerMessage}",
                [LangKeys.Discord.PluginClans.AllianceMessage] = $"{DefaultKeys.TimestampNow.ShortTime} [Alliance] **{PlaceholderKeys.PlayerName}**: {PlaceholderKeys.PlayerMessage}",
                [LangKeys.Server.UnlinkedMessage] = $"{PlaceholderKeys.DiscordTag} [#5f79d6]{DefaultKeys.Member.Name}[/#]: {PlaceholderKeys.PlayerMessage}",
                [LangKeys.Server.LinkedMessage] = $"{PlaceholderKeys.DiscordTag} [#5f79d6]{PlaceholderKeys.PlayerName}[/#]: {PlaceholderKeys.PlayerMessage}"
            }, this);
        }
        #endregion

        #region Plugins\DiscordChat.MessageHandling.cs
        private readonly Regex _channelMention = new(@"(<#\d+>)", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        private readonly Regex _emojiRegex = new(@"(\u00a9|\u00ae|[\u2000-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])", RegexOptions.Compiled);
        private readonly MatchEvaluator _emojiEvaluator = match => EmojiCache.Instance.EmojiToText(match.Value) ?? match.Value;
        
        public void HandleMessage(string content, IPlayer player, DiscordUser user, MessageSource source, DiscordMessage sourceMessage)
        {
            if (!CanSendMessage(content, player, user, source, sourceMessage))
            {
                return;
            }
            
            #if RUST
            content = ProcessEmojis(content);
            #endif
            
            ProcessCallbackMessages(content, player, user, source, processedMessage =>
            {
                StringBuilder sb = Pool.GetStringBuilder(processedMessage);
                
                if (sourceMessage != null)
                {
                    ProcessMentions(sourceMessage, sb);
                }
                
                ProcessMessage(sb, player, user, source);
                SendMessage(Pool.ToStringAndFree(sb), player, user, source, sourceMessage);
            });
        }
        
        public string ProcessEmojis(string message) => _emojiRegex.Replace(message, _emojiEvaluator);
        
        public void ProcessMentions(DiscordMessage message, StringBuilder sb)
        {
            DiscordGuild guild = Client.Bot.GetGuild(message.GuildId);
            if (message.Mentions != null)
            {
                foreach (KeyValuePair<Snowflake, DiscordUser> mention in message.Mentions)
                {
                    GuildMember member = guild.Members[mention.Key];
                    sb.Replace($"<@{mention.Key.ToString()}>", $"@{member?.DisplayName ?? mention.Value.DisplayName}");
                }
                
                foreach (KeyValuePair<Snowflake, DiscordUser> mention in message.Mentions)
                {
                    GuildMember member = guild.Members[mention.Key];
                    sb.Replace($"<@!{mention.Key.ToString()}>", $"@{member?.DisplayName ?? mention.Value.DisplayName}");
                }
            }
            
            if (message.MentionsChannels != null)
            {
                foreach (KeyValuePair<Snowflake, ChannelMention> mention in message.MentionsChannels)
                {
                    sb.Replace($"<#{mention.Key.ToString()}>", $"#{mention.Value.Name}");
                }
            }
            
            foreach (Match match in _channelMention.Matches(message.Content))
            {
                string value = match.Value;
                Snowflake id = new(value.AsSpan().Slice(2, value.Length - 3));
                DiscordChannel channel = guild.Channels[id];
                if (channel != null)
                {
                    sb.Replace(value, $"#{channel.Name}");
                }
            }
            
            if (message.MentionRoles != null)
            {
                foreach (Snowflake roleId in message.MentionRoles)
                {
                    DiscordRole role = guild.Roles[roleId];
                    sb.Replace($"<@&{roleId.ToString()}>", $"@{role.Name ?? roleId}");
                }
            }
        }
        
        public bool CanSendMessage(string message, IPlayer player, DiscordUser user, MessageSource source, DiscordMessage sourceMessage)
        {
            for (int index = 0; index < _plugins.Count; index++)
            {
                if (!_plugins[index].CanSendMessage(message, player, user, source, sourceMessage))
                {
                    return false;
                }
            }
            
            return true;
        }
        
        public void ProcessCallbackMessages(string message, IPlayer player, DiscordUser user, MessageSource source, Action<string> completed, int index = 0)
        {
            for (; index < _plugins.Count; index++)
            {
                IPluginHandler handler = _plugins[index];
                if (handler.HasCallbackMessage())
                {
                    handler.ProcessCallbackMessage(message, player, user, source, callbackMessage =>
                    {
                        ProcessCallbackMessages(callbackMessage, player, user, source, completed, index + 1);
                    });
                    return;
                }
            }
            
            completed.Invoke(message);
        }
        
        public void ProcessMessage(StringBuilder message, IPlayer player, DiscordUser user, MessageSource source)
        {
            for (int index = 0; index < _plugins.Count; index++)
            {
                _plugins[index].ProcessMessage(message, player, user, source);
            }
        }
        
        public void SendMessage(string message, IPlayer player, DiscordUser user, MessageSource source, DiscordMessage sourceMessage)
        {
            using PlaceholderData data = GetPlaceholders(message, player, user, sourceMessage);
            data.ManualPool();
            for (int index = 0; index < _plugins.Count; index++)
            {
                IPluginHandler plugin = _plugins[index];
                if (plugin.SendMessage(message, player, user, source, sourceMessage, data))
                {
                    return;
                }
            }
        }
        
        private PlaceholderData GetPlaceholders(string message, IPlayer player, DiscordUser user, DiscordMessage sourceMessage)
        {
            PlaceholderData placeholders = GetDefault().AddPlayer(player).AddUser(user).AddMessage(sourceMessage).Add(PlaceholderDataKeys.PlayerMessage, message);
            if (sourceMessage != null)
            {
                placeholders.AddGuildMember(Client.Bot.GetGuild(sourceMessage.GuildId)?.Members[sourceMessage.Author.Id]);
            }
            
            return placeholders;
        }
        #endregion

        #region Plugins\DiscordChat.Placeholders.cs
        public void RegisterPlaceholders()
        {
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.TemplateMessage, PlaceholderDataKeys.TemplateMessage);
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.PlayerMessage, PlaceholderDataKeys.PlayerMessage);
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.DisconnectReason, PlaceholderDataKeys.DisconnectReason);
            _placeholders.RegisterPlaceholder<IPlayer, string>(this, PlaceholderKeys.PlayerName, GetPlayerName);
            _placeholders.RegisterPlaceholder(this, PlaceholderKeys.DiscordTag, _pluginConfig.ChatSettings.DiscordTag);
        }
        
        public string GetPlayerName(IPlayer player)
        {
            string name = Lang(LangKeys.Discord.Chat.PlayerName, GetDefault().AddPlayer(player));
            StringBuilder sb = Pool.GetStringBuilder(name);
            for (int index = 0; index < _plugins.Count; index++)
            {
                _plugins[index].ProcessPlayerName(sb, player);
            }
            
            return Pool.ToStringAndFree(sb);
        }
        
        public PlaceholderData GetDefault()
        {
            return _placeholders.CreateData(this);
        }
        #endregion

        #region Plugins\DiscordChat.Setup.cs
        private void Init()
        {
            Instance = this;
            
            _adminChatSettings = _pluginConfig.PluginSupport.AdminChat;
            
            #if RUST
            Unsubscribe(nameof(OnPlayerChat));
            #else
            Unsubscribe(nameof(OnUserChat));
            #endif
            
            Unsubscribe(nameof(OnUserApproved));
            Unsubscribe(nameof(OnUserConnected));
            Unsubscribe(nameof(OnUserDisconnected));
            Unsubscribe(nameof(OnServerShutdown));
            Unsubscribe(nameof(OnClanChat));
            Unsubscribe(nameof(OnAllianceChat));
            
            _plugins.Add(new DiscordChatHandler(this, _pluginConfig.ChatSettings, this, server));
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }
        
        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.ChatSettings = new ChatSettings(config.ChatSettings);
            config.PlayerStateSettings = new PlayerStateSettings(config.PlayerStateSettings);
            config.ServerStateSettings = new ServerStateSettings(config.ServerStateSettings);
            config.PluginSupport = new PluginSupport(config.PluginSupport);
            return config;
        }
        
        private void OnServerInitialized(bool startup)
        {
            _serverInitCalled = true;
            if (IsPluginLoaded(BetterChat))
            {
                if (BetterChat.Version < new VersionNumber(5, 2, 7))
                {
                    PrintWarning("Please update your version of BetterChat to version >= 5.2.7");
                }
            }
            
            if (string.IsNullOrEmpty(_pluginConfig.DiscordApiKey))
            {
                PrintWarning("Please set the Discord Bot Token and reload the plugin");
                return;
            }
            
            OnPluginLoaded(plugins.Find("AdminChat"));
            OnPluginLoaded(plugins.Find("AdminDeepCover"));
            OnPluginLoaded(plugins.Find("AntiSpam"));
            OnPluginLoaded(plugins.Find("BetterChatMute"));
            OnPluginLoaded(plugins.Find("TranslationAPI"));
            OnPluginLoaded(plugins.Find("UFilter"));
            OnPluginLoaded(plugins.Find("BetterChat"));
            
            if (startup && _pluginConfig.ServerStateSettings.SendOnlineMessage)
            {
                SendGlobalTemplateMessage(TemplateKeys.Server.Online, FindChannel(_pluginConfig.ServerStateSettings.ServerStateChannel), GetDefault());
            }
        }
        
        private void OnServerShutdown()
        {
            if(_pluginConfig.ServerStateSettings.SendShutdownMessage)
            {
                SendGlobalTemplateMessage(TemplateKeys.Server.Shutdown, FindChannel(_pluginConfig.ServerStateSettings.ServerStateChannel), GetDefault());
            }
        }
        
        private void Unload()
        {
            Instance = null;
        }
        #endregion

        #region Plugins\DiscordChat.Templates.cs
        public void RegisterTemplates()
        {
            DiscordMessageTemplate connecting = CreateTemplateEmbed($"{PlaceholderKeys.TemplateMessage}",  DiscordColor.Warning);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Player.Connecting, connecting, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate connected = CreateTemplateEmbed($"{PlaceholderKeys.TemplateMessage}",  DiscordColor.Success);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Player.Connected, connected, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate disconnected = CreateTemplateEmbed($"{PlaceholderKeys.TemplateMessage}",  DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Player.Disconnected, disconnected, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate online = CreateTemplateEmbed($":green_circle: {DefaultKeys.TimestampNow.ShortTime} The server is now online", DiscordColor.Success);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Server.Online, online, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate shutdown = CreateTemplateEmbed($":red_circle: {DefaultKeys.TimestampNow.ShortTime} The server has shutdown", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Server.Shutdown, shutdown, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate booting = CreateTemplateEmbed($":yellow_circle: {DefaultKeys.TimestampNow.ShortTime} The server is now booting", DiscordColor.Warning);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Server.Booting, booting, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate serverChat = CreateTemplateEmbed($"{PlaceholderKeys.TemplateMessage}", DiscordColor.Blurple);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Chat.General, serverChat, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate teamChat = CreateTemplateEmbed($"{PlaceholderKeys.TemplateMessage}", DiscordColor.Success);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Chat.Teams, teamChat, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate clanChat = CreateTemplateEmbed($"{PlaceholderKeys.TemplateMessage}", DiscordColor.Success);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Chat.Clan, clanChat, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate cardsChat = CreateTemplateEmbed($"{PlaceholderKeys.TemplateMessage}", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Chat.Cards, cardsChat, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate pluginClanChat = CreateTemplateEmbed($"{PlaceholderKeys.TemplateMessage}", new DiscordColor("a1ff46"));
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Chat.Clans.Clan, pluginClanChat, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate pluginAllianceChat = CreateTemplateEmbed($"{PlaceholderKeys.TemplateMessage}",  new DiscordColor("80cc38"));
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Chat.Clans.Alliance, pluginAllianceChat, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate errorNotLinked = CreatePrefixedTemplateEmbed("You're not allowed to chat with the server unless you are linked.", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Error.NotLinked, errorNotLinked, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate errorAdminChatNotLinked = CreatePrefixedTemplateEmbed("You're not allowed to use admin chat because you have not linked your Discord and game server accounts", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Error.AdminChat.NotLinked, errorAdminChatNotLinked, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate errorAdminChatNotPermission = CreatePrefixedTemplateEmbed(":no_entry: You're not allowed to use admin chat channel because you do not have permission.", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Error.AdminChat.NoPermission, errorAdminChatNotPermission, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            DiscordMessageTemplate errorBetterChatMuteMuted = CreatePrefixedTemplateEmbed(":no_entry: You're not allowed to chat with the server because you are muted.", DiscordColor.Danger);
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Error.BetterChatMute.Muted, errorBetterChatMuteMuted, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
        }
        
        public DiscordMessageTemplate CreateTemplateEmbed(string description, DiscordColor color)
        {
            return new DiscordMessageTemplate
            {
                Embeds = new List<DiscordEmbedTemplate>
                {
                    new()
                    {
                        Description = description,
                        Color = color.ToHex()
                    }
                }
            };
        }
        
        public DiscordMessageTemplate CreatePrefixedTemplateEmbed(string description, DiscordColor color)
        {
            return new DiscordMessageTemplate
            {
                Embeds = new List<DiscordEmbedTemplate>
                {
                    new()
                    {
                        Description = $"[{DefaultKeys.Plugin.Name}] {description}",
                        Color = color.ToHex()
                    }
                }
            };
        }
        
        public void SendGlobalTemplateMessage(TemplateKey templateName, DiscordChannel channel, PlaceholderData placeholders)
        {
            if (channel == null)
            {
                return;
            }
            
            MessageCreate create = new()
            {
                AllowedMentions = AllowedMentions.None
            };
            channel.CreateGlobalTemplateMessage(Client, templateName, create, placeholders);
        }
        
        public TemplateKey GetTemplateName(MessageSource source)
        {
            switch (source)
            {
                case MessageSource.Discord:
                case MessageSource.Server:
                return TemplateKeys.Chat.General;
                case MessageSource.Team:
                return TemplateKeys.Chat.Teams;
                case MessageSource.Cards:
                return TemplateKeys.Chat.Cards;
                case MessageSource.Clan:
                return TemplateKeys.Chat.Clan;
                case MessageSource.Connecting:
                return TemplateKeys.Player.Connecting;
                case MessageSource.Connected:
                return TemplateKeys.Player.Connected;
                case MessageSource.Disconnected:
                return TemplateKeys.Player.Disconnected;
                case MessageSource.PluginAdminChat:
                return TemplateKeys.Chat.AdminChat.Message;
                case MessageSource.PluginClan:
                return TemplateKeys.Chat.Clans.Clan;
                case MessageSource.PluginAlliance:
                return TemplateKeys.Chat.Clans.Alliance;
            }
            
            return default;
        }
        #endregion

        #region Configuration\ChatSettings.cs
        public class ChatSettings
        {
            [JsonProperty("Chat Channel ID")]
            public Snowflake ChatChannel { get; set; }
            
            #if RUST
            [JsonProperty("Team Channel ID")]
            public Snowflake TeamChannel { get; set; }
            
            [JsonProperty("Cards Channel ID")]
            public Snowflake CardsChannel { get; set; }
            
            [JsonProperty("Clans Channel ID")]
            public Snowflake ClansChannel { get; set; }
            #endif
            
            [JsonProperty("Replace Discord User Message With Bot Message")]
            public bool UseBotToDisplayChat { get; set; }
            
            [JsonProperty("Send Messages From Server Chat To Discord Channel")]
            public bool ServerToDiscord { get; set; }
            
            [JsonProperty("Send Messages From Discord Channel To Server Chat")]
            public bool DiscordToServer { get; set; }
            
            [JsonProperty("Add Discord Tag To In Game Messages When Sent From Discord")]
            public string DiscordTag { get; set; }
            
            [JsonProperty("Allow plugins to process Discord to Server Chat Messages")]
            public bool AllowPluginProcessing { get; set; }
            
            [JsonProperty("Text Replacements")]
            public Hash<string, string> TextReplacements { get; set; }
            
            [JsonProperty("Unlinked Settings")]
            public UnlinkedSettings UnlinkedSettings { get; set; }
            
            [JsonProperty("Message Filter Settings")]
            public MessageFilterSettings Filter { get; set; }
            
            public ChatSettings(ChatSettings settings)
            {
                ChatChannel = settings?.ChatChannel ?? default(Snowflake);
                #if RUST
                TeamChannel = settings?.TeamChannel ?? default(Snowflake);
                CardsChannel = settings?.CardsChannel ?? default(Snowflake);
                #endif
                UseBotToDisplayChat = settings?.UseBotToDisplayChat ?? true;
                ServerToDiscord = settings?.ServerToDiscord ?? true;
                DiscordToServer = settings?.DiscordToServer ?? true;
                DiscordTag = settings?.DiscordTag ?? "[#5f79d6][Discord][/#]";
                AllowPluginProcessing = settings?.AllowPluginProcessing ?? true;
                TextReplacements = settings?.TextReplacements ?? new Hash<string, string> { ["TextToBeReplaced"] = "ReplacedText" };
                UnlinkedSettings = new UnlinkedSettings(settings?.UnlinkedSettings);
                Filter = new MessageFilterSettings(settings?.Filter);
            }
        }
        #endregion

        #region Configuration\MessageFilterSettings.cs
        public class MessageFilterSettings
        {
            [JsonProperty("Ignore messages from users in this list (Discord ID)")]
            public List<Snowflake> IgnoreUsers { get; set; }
            
            [JsonProperty("Ignore messages from users in this role (Role ID)")]
            public List<Snowflake> IgnoreRoles { get; set; }
            
            [JsonProperty("Ignored Prefixes")]
            public List<string> IgnoredPrefixes { get; set; }
            
            public MessageFilterSettings(MessageFilterSettings settings)
            {
                IgnoreUsers = settings?.IgnoreUsers ?? new List<Snowflake>();
                IgnoreRoles = settings?.IgnoreRoles ?? new List<Snowflake>();
                IgnoredPrefixes = settings?.IgnoredPrefixes ?? new List<string>();
            }
            
            public bool IgnoreMessage(DiscordMessage message, GuildMember member)
            {
                return IsIgnoredUser(message.Author, member) || IsIgnoredPrefix(message.Content);
            }
            
            public bool IsIgnoredUser(DiscordUser user, GuildMember member)
            {
                if (user.IsBot)
                {
                    return true;
                }
                
                if (IgnoreUsers.Contains(user.Id))
                {
                    return true;
                }
                
                return member != null && IsRoleIgnoredMember(member);
            }
            
            public bool IsRoleIgnoredMember(GuildMember member)
            {
                for (int index = 0; index < IgnoreRoles.Count; index++)
                {
                    Snowflake role = IgnoreRoles[index];
                    if (member.Roles.Contains(role))
                    {
                        return true;
                    }
                }
                
                return false;
            }
            
            public bool IsIgnoredPrefix(string content)
            {
                for (int index = 0; index < IgnoredPrefixes.Count; index++)
                {
                    string prefix = IgnoredPrefixes[index];
                    if (content.StartsWith(prefix))
                    {
                        return true;
                    }
                }
                
                return false;
            }
        }
        #endregion

        #region Configuration\PlayerStateSettings.cs
        public class PlayerStateSettings
        {
            [JsonProperty("Player State Channel ID")]
            public Snowflake PlayerStateChannel { get; set; }
            
            [JsonProperty("Show Admins")]
            public bool ShowAdmins { get; set; }
            
            [JsonProperty("Send Connecting Message")]
            public bool SendConnectingMessage { get; set; }
            
            [JsonProperty("Send Connected Message")]
            public bool SendConnectedMessage { get; set; }
            
            [JsonProperty("Send Disconnected Message")]
            public bool SendDisconnectedMessage { get; set; }
            
            public PlayerStateSettings(PlayerStateSettings settings)
            {
                PlayerStateChannel = settings?.PlayerStateChannel ?? default(Snowflake);
                ShowAdmins = settings?.ShowAdmins ?? true;
                SendConnectingMessage = settings?.SendConnectingMessage ?? true;
                SendConnectedMessage = settings?.SendConnectedMessage ?? true;
                SendDisconnectedMessage = settings?.SendDisconnectedMessage ?? true;
            }
        }
        #endregion

        #region Configuration\PluginConfig.cs
        public class PluginConfig
        {
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string DiscordApiKey { get; set; } = string.Empty;
            
            [JsonProperty("Chat Settings")]
            public ChatSettings ChatSettings { get; set; }
            
            [JsonProperty("Player State Settings")]
            public PlayerStateSettings PlayerStateSettings { get; set; }
            
            [JsonProperty("Server State Settings")]
            public ServerStateSettings ServerStateSettings { get; set; }
            
            [JsonProperty("Plugin Support")]
            public PluginSupport PluginSupport { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; } = DiscordLogLevel.Info;
        }
        #endregion

        #region Configuration\ServerStateSettings.cs
        public class ServerStateSettings
        {
            [JsonProperty("Server State Channel ID")]
            public Snowflake ServerStateChannel { get; set; }
            
            [JsonProperty("Send Booting Message")]
            public bool SendBootingMessage { get; set; }
            
            [JsonProperty("Send Online Message")]
            public bool SendOnlineMessage { get; set; }
            
            [JsonProperty("Send Shutdown Message")]
            public bool SendShutdownMessage { get; set; }
            
            public ServerStateSettings(ServerStateSettings settings)
            {
                ServerStateChannel = settings?.ServerStateChannel ?? default(Snowflake);
                SendBootingMessage = settings?.SendBootingMessage ?? true;
                SendOnlineMessage = settings?.SendOnlineMessage ?? true;
                SendShutdownMessage = settings?.SendShutdownMessage ?? true;
            }
        }
        #endregion

        #region Configuration\UnlinkedSettings.cs
        public class UnlinkedSettings
        {
            [JsonProperty("Allow Unlinked Players To Chat With Server")]
            public bool AllowedUnlinked { get; set; }
            
            #if RUST
            [JsonProperty("Steam Icon ID")]
            public ulong SteamIcon { get; set; }
            #endif
            
            public UnlinkedSettings(UnlinkedSettings settings)
            {
                AllowedUnlinked = settings?.AllowedUnlinked ?? true;
                #if RUST
                SteamIcon = settings?.SteamIcon ?? 76561199144296099;
                #endif
            }
        }
        #endregion

        #region Enums\MessageSource.cs
        public enum MessageSource : byte
        {
            Connecting,
            Connected,
            Disconnected,
            Server,
            Discord,
            Team,
            Cards,
            Clan,
            PluginClan,
            PluginAlliance,
            PluginAdminChat
        }
        #endregion

        #region Helpers\DiscordSendQueue.cs
        public class DiscordSendQueue
        {
            private readonly StringBuilder _message = new();
            private Timer _sendTimer;
            private readonly DiscordChannel _channel;
            private readonly TemplateKey _templateId;
            private readonly Action _callback;
            private readonly PluginTimers _timer;
            
            public DiscordSendQueue(DiscordChannel channel, TemplateKey templateId, PluginTimers timers)
            {
                _channel = channel;
                _templateId = templateId;
                _callback = Send;
                _timer = timers;
            }
            
            public void QueueMessage(string message)
            {
                if (string.IsNullOrWhiteSpace(message))
                {
                    return;
                }
                
                if (_message.Length + message.Length > 2000)
                {
                    Send();
                }
                
                _sendTimer ??= _timer.In(1f, _callback);
                
                _message.AppendLine(message);
            }
            
            public void Send()
            {
                if (_message.Length > 2000)
                {
                    _message.Length = 2000;
                }
                
                PlaceholderData placeholders = DiscordChat.Instance.GetDefault().Add(PlaceholderDataKeys.TemplateMessage, _message.ToString());
                _message.Length = 0;
                DiscordChat.Instance.SendGlobalTemplateMessage(_templateId, _channel, placeholders);
                _sendTimer?.Destroy();
                _sendTimer = null;
            }
        }
        #endregion

        #region Localization\LangKeys.cs
        public static class LangKeys
        {
            public const string Root = "V3.";
            
            public static class Discord
            {
                private const string Base = Root + nameof(Discord) + ".";
                
                public static class Chat
                {
                    private const string Base = Discord.Base + nameof(Chat) + ".";
                    
                    public const string Server = Base + nameof(Server);
                    public const string LinkedMessage = Base + nameof(LinkedMessage);
                    public const string UnlinkedMessage = Base + nameof(UnlinkedMessage);
                    public const string PlayerName = Base + nameof(PlayerName) + ".V1";
                }
                
                public static class Team
                {
                    private const string Base = Discord.Base + nameof(Team) + ".";
                    
                    public const string Message = Base + nameof(Message);
                }
                
                public static class Cards
                {
                    private const string Base = Discord.Base + nameof(Cards) + ".";
                    
                    public const string Message = Base + nameof(Message);
                }
                
                public static class Clans
                {
                    private const string Base = Discord.Base + nameof(Clans) + ".";
                    
                    public const string Message = Base + nameof(Message);
                }
                
                public static class Player
                {
                    private const string Base = Discord.Base + nameof(Player) + ".";
                    
                    public const string Connecting = Base + nameof(Connecting);
                    public const string Connected = Base + nameof(Connected);
                    public const string Disconnected = Base + nameof(Disconnected);
                }
                
                public static class AdminChat
                {
                    private const string Base = Discord.Base + nameof(AdminChat) + ".";
                    
                    public const string ServerMessage = Base + nameof(ServerMessage);
                    public const string DiscordMessage = Base + nameof(DiscordMessage);
                }
                
                public static class PluginClans
                {
                    private const string Base = Discord.Base + nameof(PluginClans) + ".";
                    
                    public const string ClanMessage = Base + nameof(ClanMessage);
                    public const string AllianceMessage = Base + nameof(AllianceMessage);
                }
            }
            
            public static class Server
            {
                private const string Base = Root + nameof(Server) + ".";
                
                public const string LinkedMessage = Base + nameof(LinkedMessage);
                public const string UnlinkedMessage = Base + nameof(UnlinkedMessage);
            }
        }
        #endregion

        #region Placeholders\PlaceholderDataKeys.cs
        public class PlaceholderDataKeys
        {
            public static readonly PlaceholderDataKey TemplateMessage = new("message");
            public static readonly PlaceholderDataKey PlayerMessage = new("player.message");
            public static readonly PlaceholderDataKey DisconnectReason = new("reason");
        }
        #endregion

        #region Placeholders\PlaceholderKeys.cs
        public class PlaceholderKeys
        {
            public static readonly PlaceholderKey TemplateMessage = new(nameof(DiscordChat), "message");
            public static readonly PlaceholderKey PlayerMessage = new(nameof(DiscordChat), "player.message");
            public static readonly PlaceholderKey DisconnectReason = new(nameof(DiscordChat), "disconnect.reason");
            public static readonly PlaceholderKey PlayerName = new(nameof(DiscordChat), "player.name");
            public static readonly PlaceholderKey DiscordTag = new(nameof(DiscordChat), "discord.tag");
        }
        #endregion

        #region PluginHandlers\AdminChatHandler.cs
        public class AdminChatHandler : BasePluginHandler
        {
            private readonly AdminChatSettings _settings;
            private readonly DiscordClient _client;
            
            public AdminChatHandler(DiscordClient client, DiscordChat chat, AdminChatSettings settings, Plugin plugin) : base(chat, plugin)
            {
                _client = client;
                _settings = settings;
            }
            
            public override bool CanSendMessage(string message, IPlayer player, DiscordUser user, MessageSource source, DiscordMessage sourceMessage)
            {
                return source == MessageSource.PluginAdminChat ? !_settings.Enabled : !IsAdminChatMessage(player, message);
            }
            
            public override bool SendMessage(string message, IPlayer player, DiscordUser user, MessageSource source, DiscordMessage sourceMessage, PlaceholderData data)
            {
                if (source != MessageSource.PluginAdminChat)
                {
                    return false;
                }
                
                if (sourceMessage != null)
                {
                    if (_settings.ReplaceWithBot)
                    {
                        sourceMessage.Delete(_client);
                        Chat.Sends[source]?.QueueMessage(Chat.Lang(LangKeys.Discord.AdminChat.DiscordMessage, data));
                    }
                    
                    Plugin.Call("SendAdminMessage", player, message);
                }
                else
                {
                    Chat.Sends[source]?.QueueMessage(Chat.Lang(LangKeys.Discord.AdminChat.ServerMessage, data));
                }
                
                return true;
            }
            
            private bool IsAdminChatMessage(IPlayer player, string message) => Chat.CanPlayerAdminChat(player) && (message.StartsWith(_settings.AdminChatPrefix) || Plugin.Call<bool>("HasAdminChatEnabled", player));
        }
        #endregion

        #region PluginHandlers\AdminDeepCoverHandler.cs
        public class AdminDeepCoverHandler : BasePluginHandler
        {
            public AdminDeepCoverHandler(DiscordChat chat, Plugin plugin) : base(chat, plugin) { }
            
            public override bool CanSendMessage(string message, IPlayer player, DiscordUser user, MessageSource type, DiscordMessage sourceMessage)
            {
                return player?.Object == null || (player.Object != null
                && type is MessageSource.Discord or MessageSource.Server
                && !Plugin.Call<bool>("API_IsDeepCovered", player.Object));
            }
        }
        #endregion

        #region PluginHandlers\AntiSpamHandler.cs
        public class AntiSpamHandler : BasePluginHandler
        {
            private readonly AntiSpamSettings _settings;
            
            public AntiSpamHandler(DiscordChat chat, AntiSpamSettings settings, Plugin plugin) : base(chat, plugin)
            {
                _settings = settings;
            }
            
            public override void ProcessPlayerName(StringBuilder name, IPlayer player)
            {
                if (!_settings.PlayerName || player == null)
                {
                    return;
                }
                
                string builtName = name.ToString();
                builtName = Plugin.Call<string>("GetSpamFreeText", builtName);
                builtName = Plugin.Call<string>("GetImpersonationFreeText", builtName);
                name.Length = 0;
                name.Append(builtName);
            }
            
            public override void ProcessMessage(StringBuilder message, IPlayer player, DiscordUser user, MessageSource source)
            {
                if (CanFilterMessage(source))
                {
                    string clearMessage = Plugin.Call<string>("GetSpamFreeText", message.ToString());
                    message.Length = 0;
                    message.Append(clearMessage);
                }
            }
            
            private bool CanFilterMessage(MessageSource source)
            {
                switch (source)
                {
                    case MessageSource.Discord:
                    return _settings.DiscordMessage;
                    case MessageSource.Server:
                    return _settings.ServerMessage;
                    #if RUST
                    case MessageSource.Team:
                    return _settings.TeamMessage;
                    case MessageSource.Cards:
                    return _settings.CardMessages;
                    case MessageSource.Clan:
                    return _settings.ClanMessages;
                    #endif
                    case MessageSource.PluginClan:
                    case MessageSource.PluginAlliance:
                    return _settings.PluginMessage;
                }
                
                return false;
            }
        }
        #endregion

        #region PluginHandlers\BasePluginHandler.cs
        public abstract class BasePluginHandler : IPluginHandler
        {
            protected readonly DiscordChat Chat;
            protected readonly Plugin Plugin;
            private readonly string _pluginName;
            
            protected BasePluginHandler(DiscordChat chat, Plugin plugin)
            {
                Chat = chat;
                Plugin = plugin;
                _pluginName = plugin.Name;
            }
            
            public virtual bool CanSendMessage(string message, IPlayer player, DiscordUser user, MessageSource source, DiscordMessage sourceMessage) => true;
            
            public virtual void ProcessPlayerName(StringBuilder name, IPlayer player) { }
            
            public virtual bool HasCallbackMessage() => false;
            
            public virtual void ProcessCallbackMessage(string message, IPlayer player, DiscordUser user, MessageSource source, Action<string> callback) { }
            
            public virtual void ProcessMessage(StringBuilder message, IPlayer player, DiscordUser user, MessageSource source) { }
            
            public virtual bool SendMessage(string message, IPlayer player, DiscordUser user, MessageSource source, DiscordMessage sourceMessage, PlaceholderData data) => false;
            
            public string GetPluginName() => _pluginName;
        }
        #endregion

        #region PluginHandlers\BetterChatHandler.cs
        public class BetterChatHandler : BasePluginHandler
        {
            private readonly BetterChatSettings _settings;
            
            private readonly Regex _rustRegex = new(@"<b>|<\/b>|<i>|<\/i>|<\/size>|<\/color>|<color=.+?>|<size=.+?>", RegexOptions.Compiled | RegexOptions.IgnoreCase);
            
            public BetterChatHandler(DiscordChat chat, BetterChatSettings settings, Plugin plugin) : base(chat, plugin)
            {
                _settings = settings;
            }
            
            public override void ProcessPlayerName(StringBuilder name, IPlayer player)
            {
                Dictionary<string, object> data = Chat.GetBetterChatMessageData(player, string.Empty);
                List<string> titles = Chat.GetBetterChatTags(data);
                
                int addedTitles = 0;
                for (int i = titles.Count - 1; i >= 0; i--)
                {
                    if (addedTitles >= _settings.DiscordMaxTags)
                    {
                        return;
                    }
                    
                    string title = titles[i];
                    title = Formatter.ToPlaintext(title);
                    #if RUST
                    title = _rustRegex.Replace(title, string.Empty);
                    #endif
                    name.Insert(0, ' ');
                    name.Insert(0, title);
                    addedTitles++;
                }
            }
        }
        #endregion

        #region PluginHandlers\BetterChatMuteHandler.cs
        public class BetterChatMuteHandler : BasePluginHandler
        {
            private readonly BetterChatMuteSettings _settings;
            
            public BetterChatMuteHandler(DiscordChat chat, BetterChatMuteSettings settings, Plugin plugin) : base(chat, plugin)
            {
                _settings = settings;
            }
            
            public override bool CanSendMessage(string message, IPlayer player, DiscordUser user, MessageSource source, DiscordMessage sourceMessage)
            {
                if (player == null)
                {
                    return true;
                }
                
                if (!_settings.IgnoreMuted)
                {
                    return true;
                }
                
                if (Plugin.Call("API_IsMuted", player) is false)
                {
                    return true;
                }
                
                if (_settings.SendMutedNotification)
                {
                    sourceMessage?.Author.SendTemplateDirectMessage(Chat.Client, TemplateKeys.Error.BetterChatMute.Muted);
                }
                
                return false;
            }
        }
        #endregion

        #region PluginHandlers\DiscordChatHandler.cs
        public class DiscordChatHandler : BasePluginHandler
        {
            private readonly ChatSettings _settings;
            private readonly IServer _server;
            #if RUST
            private readonly object[] _unlinkedArgs = new object[3];
            #endif
            
            public DiscordChatHandler(DiscordChat chat, ChatSettings settings, Plugin plugin, IServer server) : base(chat, plugin)
            {
                _settings = settings;
                _server = server;
                #if RUST
                _unlinkedArgs[0] = 2;
                _unlinkedArgs[1] = settings.UnlinkedSettings.SteamIcon;
                #endif
            }
            
            public override bool CanSendMessage(string message, IPlayer player, DiscordUser user, MessageSource source, DiscordMessage sourceMessage)
            {
                if (sourceMessage != null)
                {
                    if (_settings.Filter.IgnoreMessage(sourceMessage, Chat.Client.Bot.GetGuild(sourceMessage.GuildId)?.Members[sourceMessage.Author.Id]))
                    {
                        return false;
                    }
                }
                
                switch (source)
                {
                    case MessageSource.Discord:
                    return _settings.DiscordToServer && (_settings.UnlinkedSettings.AllowedUnlinked || (player != null && player.IsLinked()));
                    
                    case MessageSource.Server:
                    return _settings.ServerToDiscord;
                }
                
                return true;
            }
            
            public override bool SendMessage(string message, IPlayer player, DiscordUser user, MessageSource source, DiscordMessage sourceMessage, PlaceholderData data)
            {
                switch (source)
                {
                    case MessageSource.Discord:
                    if (_settings.UseBotToDisplayChat)
                    {
                        if (player.IsLinked())
                        {
                            Chat.Sends[MessageSource.Discord]?.QueueMessage(Chat.Lang(LangKeys.Discord.Chat.LinkedMessage, data));
                        }
                        else
                        {
                            Chat.Sends[MessageSource.Discord]?.QueueMessage(Chat.Lang(LangKeys.Discord.Chat.UnlinkedMessage, data));
                        }
                    }
                    
                    if (player.IsLinked())
                    {
                        SendLinkedToServer(player, message, data, source);
                    }
                    else
                    {
                        SendUnlinkedToServer(data);
                    }
                    
                    return true;
                    
                    case MessageSource.Server:
                    Chat.Sends[MessageSource.Discord]?.QueueMessage(Chat.Lang(LangKeys.Discord.Chat.Server, data));
                    return true;
                    case MessageSource.Team:
                    Chat.Sends[MessageSource.Team]?.QueueMessage(Chat.Lang(LangKeys.Discord.Team.Message, data));
                    return true;
                    case MessageSource.Cards:
                    Chat.Sends[MessageSource.Cards]?.QueueMessage(Chat.Lang(LangKeys.Discord.Cards.Message, data));
                    return true;
                    case MessageSource.Clan:
                    Chat.Sends[MessageSource.Clan]?.QueueMessage(Chat.Lang(LangKeys.Discord.Clans.Message, data));
                    return true;
                    case MessageSource.PluginAdminChat:
                    Chat.Sends[MessageSource.PluginAdminChat]?.QueueMessage(Chat.Lang(LangKeys.Discord.AdminChat.DiscordMessage, data));
                    return true;
                    case MessageSource.PluginClan:
                    Chat.Sends[MessageSource.PluginClan]?.QueueMessage(Chat.Lang(LangKeys.Discord.PluginClans.ClanMessage, data));
                    return true;
                    case MessageSource.PluginAlliance:
                    Chat.Sends[MessageSource.PluginAlliance]?.QueueMessage(Chat.Lang(LangKeys.Discord.PluginClans.AllianceMessage, data));
                    return true;
                }
                
                return false;
            }
            
            public void SendLinkedToServer(IPlayer player, string message, PlaceholderData placeholders, MessageSource source)
            {
                if (_settings.AllowPluginProcessing)
                {
                    if (Chat.SendBetterChatMessage(player, message, source))
                    {
                        return;
                    }
                    
                    bool playerReturn = false;
                    #if RUST
                    //Let other chat plugins process first
                    if (player.Object != null)
                    {
                        Chat.Unsubscribe("OnPlayerChat");
                        playerReturn = Interface.Call("OnPlayerChat", player.Object, message, ConVar.Chat.ChatChannel.Global) != null;
                        Chat.Subscribe("OnPlayerChat");
                    }
                    #endif
                    
                    //Let other chat plugins process first
                    Chat.Unsubscribe("OnUserChat");
                    bool userReturn = Interface.Call("OnUserChat", player, message) != null;
                    Chat.Subscribe("OnUserChat");
                    
                    if (playerReturn || userReturn)
                    {
                        return;
                    }
                }
                
                message = Chat.Lang(LangKeys.Server.LinkedMessage, placeholders);
                _server.Broadcast(message);
                Chat.Puts(Formatter.ToPlaintext(message));
            }
            
            public void SendUnlinkedToServer(PlaceholderData placeholders)
            {
                string serverMessage = Chat.Lang(LangKeys.Server.UnlinkedMessage, placeholders);
                #if RUST
                _unlinkedArgs[2] = Formatter.ToUnity(serverMessage);
                ConsoleNetwork.BroadcastToAllClients("chat.add", _unlinkedArgs);
                #else
                _server.Broadcast(serverMessage);
                #endif
                
                Chat.Puts(Formatter.ToPlaintext(serverMessage));
            }
            
            public override void ProcessMessage(StringBuilder message, IPlayer player, DiscordUser user, MessageSource source)
            {
                foreach (KeyValuePair<string, string> replacement in _settings.TextReplacements)
                {
                    message.Replace(replacement.Key, replacement.Value);
                }
            }
        }
        #endregion

        #region PluginHandlers\IPluginHandler.cs
        public interface IPluginHandler
        {
            bool CanSendMessage(string message, IPlayer player, DiscordUser user, MessageSource source, DiscordMessage sourceMessage);
            void ProcessPlayerName(StringBuilder name, IPlayer player);
            bool HasCallbackMessage();
            void ProcessCallbackMessage(string message, IPlayer player, DiscordUser user, MessageSource source, Action<string> callback);
            void ProcessMessage(StringBuilder message, IPlayer player, DiscordUser user, MessageSource source);
            bool SendMessage(string message, IPlayer player, DiscordUser user, MessageSource source, DiscordMessage sourceMessage, PlaceholderData data);
            string GetPluginName();
        }
        #endregion

        #region PluginHandlers\TranslationApiHandler.cs
        public class TranslationApiHandler : BasePluginHandler
        {
            private readonly ChatTranslatorSettings _settings;
            
            public TranslationApiHandler(DiscordChat chat, ChatTranslatorSettings settings, Plugin plugin) : base(chat, plugin)
            {
                _settings = settings;
            }
            
            public override bool HasCallbackMessage() => true;
            
            public override void ProcessCallbackMessage(string message, IPlayer player, DiscordUser user, MessageSource source, Action<string> callback)
            {
                if (CanChatTranslatorSource(source))
                {
                    Plugin.Call("Translate", message, _settings.DiscordServerLanguage, "auto", callback);
                    return;
                }
                
                callback.Invoke(message);
            }
            
            public bool CanChatTranslatorSource(MessageSource source)
            {
                if (!_settings.Enabled)
                {
                    return false;
                }
                
                switch (source)
                {
                    case MessageSource.Server:
                    return _settings.ServerMessage;
                    
                    case MessageSource.Discord:
                    return _settings.DiscordMessage;
                    
                    case MessageSource.PluginClan:
                    case MessageSource.PluginAlliance:
                    return _settings.PluginMessage;
                    
                    #if RUST
                    case MessageSource.Team:
                    return _settings.TeamMessage;
                    
                    case MessageSource.Cards:
                    return _settings.CardMessages;
                    
                    case MessageSource.Clan:
                    return _settings.ClanMessages;
                    #endif
                }
                
                return false;
            }
        }
        #endregion

        #region PluginHandlers\UFilterHandler.cs
        public class UFilterHandler : BasePluginHandler
        {
            private readonly UFilterSettings _settings;
            private readonly List<string> _replacements = new();
            
            public UFilterHandler(DiscordChat chat, UFilterSettings settings, Plugin plugin) : base(chat, plugin)
            {
                _settings = settings;
            }
            
            public override void ProcessPlayerName(StringBuilder name, IPlayer player)
            {
                if (_settings.PlayerNames)
                {
                    UFilterText(name);
                }
            }
            
            public override void ProcessMessage(StringBuilder message, IPlayer player, DiscordUser user, MessageSource source)
            {
                if (CanFilterMessage(source))
                {
                    UFilterText(message);
                }
            }
            
            private bool CanFilterMessage(MessageSource source)
            {
                switch (source)
                {
                    case MessageSource.Discord:
                    return _settings.DiscordMessages;
                    case MessageSource.Server:
                    return _settings.ServerMessage;
                    #if RUST
                    case MessageSource.Team:
                    return _settings.TeamMessage;
                    case MessageSource.Cards:
                    return _settings.CardMessage;
                    case MessageSource.Clan:
                    return _settings.ClanMessage;
                    #endif
                    case MessageSource.PluginClan:
                    case MessageSource.PluginAlliance:
                    return _settings.PluginMessages;
                }
                
                return false;
            }
            
            private void UFilterText(StringBuilder text)
            {
                string[] profanities = Plugin.Call<string[]>("Profanities", text.ToString());
                for (int index = 0; index < profanities.Length; index++)
                {
                    string profanity = profanities[index];
                    text.Replace(profanity, GetProfanityReplacement(profanity));
                }
            }
            
            private string GetProfanityReplacement(string profanity)
            {
                if (string.IsNullOrEmpty(profanity))
                {
                    return string.Empty;
                }
                
                for (int i = _replacements.Count; i <= profanity.Length; i++)
                {
                    _replacements.Add(new string(_settings.ReplacementCharacter, i));
                }
                
                return _replacements[profanity.Length];
            }
        }
        #endregion

        #region Templates\TemplateKeys.cs
        public static class TemplateKeys
        {
            public static class Player
            {
                private const string Base = nameof(Player) + ".";
                
                public static readonly TemplateKey Connecting = new(Base + nameof(Connecting));
                public static readonly TemplateKey Connected = new(Base + nameof(Connected));
                public static readonly TemplateKey Disconnected = new(Base + nameof(Disconnected));
            }
            
            public static class Server
            {
                private const string Base = nameof(Server) + ".";
                
                public static readonly TemplateKey Online = new(Base + nameof(Online));
                public static readonly TemplateKey Shutdown = new(Base + nameof(Shutdown));
                public static readonly TemplateKey Booting = new(Base + nameof(Booting));
            }
            
            public static class Chat
            {
                private const string Base = nameof(Chat) + ".";
                
                public static readonly TemplateKey General = new(Base + nameof(General));
                public static readonly TemplateKey Teams = new(Base + nameof(Teams));
                public static readonly TemplateKey Cards = new(Base + nameof(Cards));
                public static readonly TemplateKey Clan = new(Base + nameof(Clan));
                
                public static class Clans
                {
                    private const string Base = Chat.Base + nameof(Clans) + ".";
                    
                    public static readonly TemplateKey Clan = new(Base + nameof(Clan));
                    public static readonly TemplateKey Alliance = new(Base + nameof(Alliance));
                }
                
                public static class AdminChat
                {
                    private const string Base = Chat.Base + nameof(AdminChat) + ".";
                    
                    public static readonly TemplateKey Message = new(Base + nameof(Message));
                }
            }
            
            public static class Error
            {
                private const string Base = nameof(Error) + ".";
                
                public static readonly TemplateKey NotLinked = new(Base + nameof(NotLinked));
                
                public static class AdminChat
                {
                    private const string Base = Error.Base + nameof(AdminChat) + ".";
                    
                    public static readonly TemplateKey NotLinked = new(Base + nameof(NotLinked));
                    public static readonly TemplateKey NoPermission = new(Base + nameof(NoPermission));
                }
                
                public static class BetterChatMute
                {
                    private const string Base = Error.Base + nameof(BetterChatMute) + ".";
                    
                    public static readonly TemplateKey Muted = new(Base + nameof(Muted));
                }
            }
        }
        #endregion

        #region Configuration\Plugins\AdminChatSettings.cs
        public class AdminChatSettings
        {
            [JsonProperty("Enable AdminChat Plugin Support")]
            public bool Enabled { get; set; }
            
            [JsonProperty("Chat Channel ID")]
            public Snowflake ChatChannel { get; set; }
            
            [JsonProperty("Chat Prefix")]
            public string AdminChatPrefix { get; set; }
            
            [JsonProperty("Replace Discord Message With Bot")]
            public bool ReplaceWithBot { get; set; }
            
            public AdminChatSettings(AdminChatSettings settings)
            {
                Enabled = settings?.Enabled ?? false;
                ChatChannel = settings?.ChatChannel ?? default(Snowflake);
                AdminChatPrefix = settings?.AdminChatPrefix ?? "@";
                ReplaceWithBot = settings?.ReplaceWithBot ?? true;
            }
        }
        #endregion

        #region Configuration\Plugins\AntiSpamSettings.cs
        public class AntiSpamSettings
        {
            [JsonProperty("Use AntiSpam On Player Names")]
            public bool PlayerName { get; set; }
            
            [JsonProperty("Use AntiSpam On Server Messages")]
            public bool ServerMessage { get; set; }
            
            [JsonProperty("Use AntiSpam On Chat Messages")]
            public bool DiscordMessage { get; set; }
            
            [JsonProperty("Use AntiSpam On Plugin Messages")]
            public bool PluginMessage { get; set; }
            
            #if RUST
            [JsonProperty("Use AntiSpam On Team Messages")]
            public bool TeamMessage { get; set; }
            
            [JsonProperty("Use AntiSpam On Card Messages")]
            public bool CardMessages { get; set; }
            
            [JsonProperty("Use AntiSpam On Clan Messages")]
            public bool ClanMessages { get; set; }
            #endif
            
            public AntiSpamSettings(AntiSpamSettings settings)
            {
                PlayerName = settings?.PlayerName ?? false;
                ServerMessage = settings?.ServerMessage ?? false;
                DiscordMessage = settings?.DiscordMessage ?? false;
                PluginMessage = settings?.PluginMessage ?? false;
                #if RUST
                TeamMessage = settings?.TeamMessage ?? false;
                CardMessages = settings?.CardMessages ?? false;
                ClanMessages = settings?.ClanMessages ?? false;
                #endif
            }
        }
        #endregion

        #region Configuration\Plugins\BetterChatMuteSettings.cs
        public class BetterChatMuteSettings
        {
            [JsonProperty("Ignore Muted Players")]
            public bool IgnoreMuted { get; set; }
            
            [JsonProperty("Send Muted Notification")]
            public bool SendMutedNotification { get; set; }
            
            public BetterChatMuteSettings(BetterChatMuteSettings settings)
            {
                IgnoreMuted = settings?.IgnoreMuted ?? true;
                SendMutedNotification = settings?.SendMutedNotification ?? true;
            }
        }
        #endregion

        #region Configuration\Plugins\BetterChatSettings.cs
        public class BetterChatSettings
        {
            [JsonProperty("Max BetterChat Tags To Show When Sent From Discord")]
            public byte ServerMaxTags { get; set; }
            
            [JsonProperty("Max BetterChat Tags To Show When Sent From Server")]
            public byte DiscordMaxTags { get; set; }
            
            public BetterChatSettings(BetterChatSettings settings)
            {
                ServerMaxTags = settings?.ServerMaxTags ?? 10;
                DiscordMaxTags = settings?.DiscordMaxTags ?? 10;
            }
        }
        #endregion

        #region Configuration\Plugins\ChatTranslatorSettings.cs
        public class ChatTranslatorSettings
        {
            [JsonProperty("Enable Chat Translator")]
            public bool Enabled { get; set; }
            
            [JsonProperty("Use ChatTranslator On Server Messages")]
            public bool ServerMessage { get; set; }
            
            [JsonProperty("Use ChatTranslator On Chat Messages")]
            public bool DiscordMessage { get; set; }
            
            [JsonProperty("Use ChatTranslator On Plugin Messages")]
            public bool PluginMessage { get; set; }
            
            #if RUST
            [JsonProperty("Use ChatTranslator On Team Messages")]
            public bool TeamMessage { get; set; }
            
            [JsonProperty("Use ChatTranslator On Card Messages")]
            public bool CardMessages { get; set; }
            
            [JsonProperty("Use ChatTranslator On Clan Messages")]
            public bool ClanMessages { get; set; }
            #endif
            
            [JsonProperty("Discord Server Chat Language")]
            public string DiscordServerLanguage { get; set; }
            
            public ChatTranslatorSettings(ChatTranslatorSettings settings)
            {
                Enabled = settings?.Enabled ?? false;
                ServerMessage = settings?.ServerMessage ?? false;
                DiscordMessage = settings?.DiscordMessage ?? false;
                #if RUST
                TeamMessage = settings?.TeamMessage ?? false;
                CardMessages = settings?.CardMessages ?? false;
                ClanMessages = settings?.ClanMessages ?? false;
                #endif
                DiscordServerLanguage = settings?.DiscordServerLanguage ?? Interface.Oxide.GetLibrary<Lang>().GetServerLanguage();
            }
        }
        #endregion

        #region Configuration\Plugins\ClansSettings.cs
        public class ClansSettings
        {
            [JsonProperty("Clans Chat Channel ID")]
            public Snowflake ClansChatChannel { get; set; }
            
            [JsonProperty("Alliance Chat Channel ID")]
            public Snowflake AllianceChatChannel { get; set; }
            
            public ClansSettings(ClansSettings settings)
            {
                ClansChatChannel = settings?.ClansChatChannel ?? default(Snowflake);
                AllianceChatChannel = settings?.AllianceChatChannel ?? default(Snowflake);
            }
        }
        #endregion

        #region Configuration\Plugins\PluginSupport.cs
        public class PluginSupport
        {
            [JsonProperty("AdminChat Settings")]
            public AdminChatSettings AdminChat { get; set; }
            
            [JsonProperty("AntiSpam Settings")]
            public AntiSpamSettings AntiSpam { get; set; }
            
            [JsonProperty("BetterChat Settings")]
            public BetterChatSettings BetterChat { get; set; }
            
            [JsonProperty("BetterChatMute Settings")]
            public BetterChatMuteSettings BetterChatMute { get; set; }
            
            [JsonProperty("ChatTranslator Settings")]
            public ChatTranslatorSettings ChatTranslator { get; set; }
            
            [JsonProperty("Clan Settings")]
            public ClansSettings Clans { get; set; }
            
            [JsonProperty("UFilter Settings")]
            public UFilterSettings UFilter { get; set; }
            
            public PluginSupport(PluginSupport settings)
            {
                AdminChat = new AdminChatSettings(settings?.AdminChat);
                AntiSpam = new AntiSpamSettings(settings?.AntiSpam);
                BetterChat = new BetterChatSettings(settings?.BetterChat);
                BetterChatMute = new BetterChatMuteSettings(settings?.BetterChatMute);
                ChatTranslator = new ChatTranslatorSettings(settings?.ChatTranslator);
                Clans = new ClansSettings(settings?.Clans);
                UFilter = new UFilterSettings(settings?.UFilter);
            }
        }
        #endregion

        #region Configuration\Plugins\UFilterSettings.cs
        public class UFilterSettings
        {
            [JsonProperty("Use UFilter On Player Names")]
            public bool PlayerNames { get; set; }
            
            [JsonProperty("Use UFilter On Server Messages")]
            public bool ServerMessage { get; set; }
            
            [JsonProperty("Use UFilter On Discord Messages")]
            public bool DiscordMessages { get; set; }
            
            [JsonProperty("Use UFilter On Plugin Messages")]
            public bool PluginMessages { get; set; }
            
            #if RUST
            [JsonProperty("Use UFilter On Team Messages")]
            public bool TeamMessage { get; set; }
            
            [JsonProperty("Use UFilter On Card Messages")]
            public bool CardMessage { get; set; }
            
            [JsonProperty("Use UFilter On Clan Messages")]
            public bool ClanMessage { get; set; }
            #endif
            
            [JsonProperty("Replacement Character")]
            public char ReplacementCharacter { get; set; }
            
            public UFilterSettings(UFilterSettings settings)
            {
                PlayerNames = settings?.PlayerNames ?? false;
                ServerMessage = settings?.ServerMessage ?? false;
                DiscordMessages = settings?.DiscordMessages ?? false;
                PluginMessages = settings?.PluginMessages ?? false;
                #if RUST
                TeamMessage = settings?.TeamMessage ?? false;
                CardMessage = settings?.CardMessage ?? false;
                ClanMessage = settings?.ClanMessage ?? false;
                #endif
                
                ReplacementCharacter = settings?.ReplacementCharacter ?? '＊';
            }
        }
        #endregion

    }

}


// --- End of file: DiscordChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-connect-commands ---
// --- Original File Path: D/DiscordConnectCommands/DiscordConnectCommands.cs ---

using System;
using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Discord Connect Commands", "Iv Misticos", "1.0.4")]
    [Description("Execute commands on Discord Connect events")]
    class DiscordConnectCommands : CovalencePlugin
    {
        #region Variables

        private StringBuilder _builder = new StringBuilder();
        
        #endregion
        
        #region Configuration

        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Commands On Connect",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> CommandsConnect = new List<string>
            {
                "exampleCommand {gameId} {discordId}"
            };

            [JsonProperty(PropertyName = "Commands On Overwrite",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> CommandsOverwrite = new List<string>
            {
                "exampleCommand {oldGameId} {newGameId} {oldDiscordId} {newDiscordId}"
            };

            [JsonProperty(PropertyName = "Commands On Server Leave",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> CommandsLeave = new List<string>
            {
                "exampleCommand {gameId} {discordId}"
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Methods

        private string FormatCommand(string command, string gameId, string discordId)
        {
            _builder.Length = 0;
            return _builder.Append(command).Replace("{gameId}", gameId).Replace("{discordId}", discordId).ToString();
        }
        private string FormatCommand(string command, string oldGameId, string newGameId, string oldDiscordId,
            string newDiscordId)
        {
            _builder.Length = 0;
            return _builder.Append(command).Replace("{oldGameId}", oldGameId)
                    .Replace("{newGameId}", newGameId).Replace("{oldDiscordId}", oldDiscordId)
                    .Replace("{newDiscordId}", newDiscordId).ToString();
        }
        private void ExecuteCommand(string command) => server.Command(command);

        #endregion

        #region Hooks

        private void OnDiscordAuthenticate(string gameId, string discordId)
        {
            foreach (var command in _config.CommandsConnect)
                ExecuteCommand(FormatCommand(command, gameId, discordId));
        }

        private void OnDiscordAuthOverwrite(string oldGameId, string newGameId, string oldDiscordId,
            string newDiscordId)
        {
            foreach (var command in _config.CommandsOverwrite)
                ExecuteCommand(FormatCommand(command, oldGameId, newGameId, oldDiscordId, newDiscordId));
        }

        private void OnDiscordAuthLeave(string gameId, string discordId)
        {
            foreach (var command in _config.CommandsLeave)
                ExecuteCommand(FormatCommand(command, gameId, discordId));
        }
        
        #endregion
    }
}

// --- End of file: DiscordConnectCommands.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/draggable-corpses ---
// --- Original File Path: D/DraggableCorpses/DraggableCorpses.cs ---

﻿using Newtonsoft.Json;
using UnityEngine;
using System.Collections.Generic;
using System;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Draggable Corpses", "Dana", "2.0.0")]
    [Description("Bring corpses to life and take them for a walk.")]

    public class DraggableCorpses : RustPlugin
    {
        #region Fields

        private static DraggableCorpses _instance;
        private static Configuration _config;
        private CorpseDragController _corpseDragController;

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Drag Button")]
            public string DragButton { get; set; }

            [JsonIgnore]
            public BUTTON Button
            {
                get
                {
                    return (BUTTON)Enum.Parse(typeof(BUTTON), DragButton);
                }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Detected changes in configuration! Updating...");
            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Configuration update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                DragButton = "FIRE_THIRD",
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Init()
        {
            _instance = this;
            _corpseDragController = new CorpseDragController();

            PermissionUtils.Register();
        }

        private void Unload()
        {
            _config = null;
            _instance = null;

            _corpseDragController.StopDraggingForAll();
        }

        private object CanLootEntity(BasePlayer player, PlayerCorpse corpse)
        {
            if (!player.IsValid())
                return null;

            if (corpse == null)
                return null;

            if (!PermissionUtils.Verify(player))
                return null;

            if (!player.serverInput.IsDown(_config.Button))
                return null;

            _corpseDragController.StartDragging(corpse, player);
            return false;
        }

        #endregion Oxide Hooks

        #region Corpse Drag Controller

        private class CorpseDragController
        {
            private Dictionary<BasePlayer, CorpseDragComponent> _components = new Dictionary<BasePlayer, CorpseDragComponent>();

            public void RegisterDragger(CorpseDragComponent component)
            {
                _components[component.Dragger] = component;
            }

            public void UnregisterDragger(CorpseDragComponent component)
            {
                _components.Remove(component.Dragger);
            }

            public bool StartDragging(PlayerCorpse corpse, BasePlayer player)
            {
                if (PlayerIsDraggingCorpse(player))
                    return false;

                CorpseDragComponent.InstallComponent(corpse, player, this);
                return true;
            }

            public bool CorpseBeingDragged(PlayerCorpse corpse)
            {
                if (!corpse.IsValid() || corpse.IsDestroyed)
                    return false;

                return CorpseDragComponent.GetComponent(corpse) != null;
            }

            public bool PlayerIsDraggingCorpse(BasePlayer player)
            {
                return GetComponentForPlayer(player) != null;
            }

            public CorpseDragComponent GetComponentForPlayer(BasePlayer player)
            {
                CorpseDragComponent component;
                return _components.TryGetValue(player, out component) ? component : null;
            }

            public void StopDraggingForPlayer(BasePlayer player)
            {
                GetComponentForPlayer(player)?.DestroyComponent();
            }

            public void StopDraggingForCorpse(PlayerCorpse corpse)
            {
                CorpseDragComponent.GetComponent(corpse)?.DestroyComponent();
            }

            public void StopDraggingForAll()
            {
                foreach (CorpseDragComponent component in _components.Values.ToArray())
                {
                    component.DestroyComponent();
                }
            }
        }

        #endregion Corpse Drag Controller

        #region Corpse Drag Component

        private class CorpseDragComponent : FacepunchBehaviour
        {
            private CorpseDragController _corpseDragController;
            private static int _raycastLayers = LayerMask.GetMask("Construction", "Deployed", "Default", "Debris", "Terrain", "Tree", "World");

            public BasePlayer Dragger { get; set; }
            public PlayerCorpse Corpse { get; set; }

            #region Corpse Functions

            private void StopDraggingCorpse()
            {
                _corpseDragController.UnregisterDragger(this);
                DestroyComponent();
            }

            private void UpdateCorpsePosition()
            {
                Vector3 targetPosition = Dragger.eyes.position + Dragger.eyes.BodyForward() * 2f + Vector3.up * 1f;

                RaycastHit raycastHit;
                if (Physics.Raycast(Dragger.eyes.BodyRay(), out raycastHit, 3f, _raycastLayers))
                    targetPosition = raycastHit.point - Dragger.eyes.BodyForward();

                Corpse.transform.position = targetPosition;
            }

            #endregion Corpse Function

            #region Component Lifecycle

            private void Update()
            {
                if (!Dragger || Dragger.IsDead() || !Dragger.IsConnected || !Corpse || Corpse.IsDestroyed)
                {
                    DestroyComponent();
                    return;
                }

                if (!Dragger.serverInput.IsDown(_config.Button))
                    StopDraggingCorpse();

                UpdateCorpsePosition();
            }

            private void OnDestroy()
            {
                _corpseDragController.UnregisterDragger(this);
            }

            public static void InstallComponent(PlayerCorpse corpse, BasePlayer player, CorpseDragController corpseDragController)
            {
                corpse.gameObject.AddComponent<CorpseDragComponent>().InitializeComponent(player, corpseDragController);
            }

            public CorpseDragComponent InitializeComponent(BasePlayer player, CorpseDragController corpseDragController)
            {
                Corpse = GetComponent<PlayerCorpse>();
                Dragger = player;

                _corpseDragController = corpseDragController;
                _corpseDragController.RegisterDragger(this);

                return this;
            }

            public static CorpseDragComponent GetComponent(PlayerCorpse corpse)
            {
                return corpse.gameObject.GetComponent<CorpseDragComponent>();
            }

            public void DestroyComponent()
            {
                DestroyImmediate(this);
            }

            #endregion Component Lifecycle
        }

        #endregion Corpse Drag Component

        #region Helper Classes

        private static class PermissionUtils
        {
            public const string USE = "draggablecorpses.use";

            public static void Register()
            {
                _instance.permission.RegisterPermission(USE, _instance);
            }

            public static bool Verify(BasePlayer player, string permissionName = USE)
            {
                if (_instance.permission.UserHasPermission(player.UserIDString, permissionName))
                    return true;

                return false;
            }
        }

        #endregion Helper Classes
    }
}

// --- End of file: DraggableCorpses.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-logger ---
// --- Original File Path: D/DiscordLogger/DiscordLogger.cs ---

﻿using System;
using System.Collections.Generic;
using System.Net;
using System.Text.RegularExpressions;
using System.Text;

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Discord Logger", "MON@H", "2.0.20")]
    [Description("Logs events to Discord channels using webhooks")]
    public class DiscordLogger : RustPlugin
    {
        #region Variables

        [PluginReference] private readonly Plugin AntiSpam, BetterChatMute, CallHeli, PersonalHeli, UFilter;

        private readonly Hash<ulong, CargoShip> _cargoShips = new();
        private readonly List<ulong> _listBadCargoShips = new();
        private readonly List<ulong> _listSupplyDrops = new();
        private readonly Queue<QueuedMessage> _queue = new();
        private readonly StringBuilder _sb = new();

        private EventSettings _eventSettings;
        private int _retryCount = 0;
        private object _resultCall;
        private QueuedMessage _nextMessage;
        private QueuedMessage _queuedMessage;
        private string _langKey;
        private string[] _profanities;
        private Timer _timerQueue;
        private Timer _timerQueueCooldown;
        private ulong _entityID;
        private Vector3 _locationLargeOilRig;
        private Vector3 _locationOilRig;

        private readonly List<Regex> _regexTags = new()

        {
            new("<color=.+?>", RegexOptions.Compiled),
            new("<size=.+?>", RegexOptions.Compiled)
        };

        private readonly List<string> _tags = new()

        {
            "</color>",
            "</size>",
            "<i>",
            "</i>",
            "<b>",
            "</b>"
        };

        private class QueuedMessage
        {
            public string WebhookUrl {set; get;}
            public string Message {set; get;}
        }

        public enum TeamEventType
        {
            Created,
            Disbanded,
            Updated,
        }

        private class Response {
            [JsonProperty("country")]
            public string Country { get; set; }

            [JsonProperty("countryCode")]
            public string CountryCode { get; set; }
        }

        #endregion Variables

        #region Initialization

        private void Init()
        {
            UnsubscribeHooks();
        }

        private void Unload()
        {
            Application.logMessageReceivedThreaded -= HandleLog;
        }

        private void OnServerInitialized(bool isStartup)
        {
            if (isStartup && _configData.ServerStateSettings.Enabled)
            {
                LogToConsole("Server is online again!");

                DiscordSendMessage(Lang(LangKeys.Event.Initialized), _configData.ServerStateSettings.WebhookURL);
            }

            CacheOilRigsLocation();
            SubscribeHooks();
        }

        private void OnServerShutdown()
        {
            if (_configData.ServerStateSettings.Enabled)
            {
                LogToConsole("Server is shutting down!");

                string url = GetWebhookURL(_configData.ServerStateSettings.WebhookURL);

                if (!string.IsNullOrEmpty(url))
                {
                    webrequest.Enqueue(url, new DiscordMessage(Lang(LangKeys.Event.Shutdown)).ToJson(), DiscordSendMessageCallback, null, RequestMethod.POST, _headers);
                }
            }
        }

        #endregion Initialization

        #region Configuration

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Global settings")]
            public GlobalSettings GlobalSettings = new();

            [JsonProperty(PropertyName = "Admin Hammer settings")]
            public EventSettings AdminHammerSettings = new();

            [JsonProperty(PropertyName = "Admin Radar settings")]
            public EventSettings AdminRadarSettings = new();

            [JsonProperty(PropertyName = "Bradley settings")]
            public EventSettings BradleySettings = new();

            [JsonProperty(PropertyName = "Cargo Ship settings")]
            public EventSettings CargoShipSettings = new();

            [JsonProperty(PropertyName = "Cargo Plane settings")]
            public EventSettings CargoPlaneSettings = new();

            [JsonProperty(PropertyName = "Chat settings")]
            public EventSettings ChatSettings = new();

            [JsonProperty(PropertyName = "Chat (Team) settings")]
            public EventSettings ChatTeamSettings = new();

            [JsonProperty(PropertyName = "CH47 Helicopter settings")]
            public EventSettings ChinookSettings = new();

            [JsonProperty(PropertyName = "Christmas settings")]
            public EventSettings ChristmasSettings = new();

            [JsonProperty(PropertyName = "Clan settings")]
            public EventSettings ClanSettings = new();

            [JsonProperty(PropertyName = "Dangerous Treasures settings")]
            public EventSettings DangerousTreasuresSettings = new();

            [JsonProperty(PropertyName = "Duel settings")]
            public EventSettings DuelSettings = new();

            [JsonProperty(PropertyName = "Godmode settings")]
            public EventSettings GodmodeSettings = new();

            [JsonProperty(PropertyName = "Easter settings")]
            public EventSettings EasterSettings = new();

            [JsonProperty(PropertyName = "Error settings")]
            public EventSettings ErrorSettings = new();

            [JsonProperty(PropertyName = "Hackable Locked Crate settings")]
            public EventSettings LockedCrateSettings = new();

            [JsonProperty(PropertyName = "Halloween settings")]
            public EventSettings HalloweenSettings = new();

            [JsonProperty(PropertyName = "Helicopter settings")]
            public EventSettings HelicopterSettings = new();

            [JsonProperty(PropertyName = "NTeleportation settings")]
            public EventSettings NTeleportationSettings = new();

            [JsonProperty(PropertyName = "Permissions settings")]
            public EventSettings PermissionsSettings = new();

            [JsonProperty(PropertyName = "Player death settings")]
            public EventSettings PlayerDeathSettings = new();

            [JsonProperty(PropertyName = "Player DeathNotes settings")]
            public EventSettings PlayerDeathNotesSettings = new();

            [JsonProperty(PropertyName = "Player connect advanced info settings")]
            public EventSettings PlayerConnectedInfoSettings = new();

            [JsonProperty(PropertyName = "Player connect settings")]
            public EventSettings PlayerConnectedSettings = new();

            [JsonProperty(PropertyName = "Player disconnect settings")]
            public EventSettings PlayerDisconnectedSettings = new();

            [JsonProperty(PropertyName = "Player Respawned settings")]
            public EventSettings PlayerRespawnedSettings = new();

            [JsonProperty(PropertyName = "Private Messages settings")]
            public EventSettings PrivateMessagesSettings = new();

            [JsonProperty(PropertyName = "Raidable Bases settings")]
            public EventSettings RaidableBasesSettings = new();

            [JsonProperty(PropertyName = "Rcon command settings")]
            public EventSettings RconCommandSettings = new();

            [JsonProperty(PropertyName = "Rcon connection settings")]
            public EventSettings RconConnectionSettings = new();

            [JsonProperty(PropertyName = "Rust Kits settings")]
            public EventSettings RustKitsSettings = new();

            [JsonProperty(PropertyName = "SantaSleigh settings")]
            public EventSettings SantaSleighSettings = new();

            [JsonProperty(PropertyName = "Server messages settings")]
            public EventSettings ServerMessagesSettings = new();

            [JsonProperty(PropertyName = "Server state settings")]
            public EventSettings ServerStateSettings = new();

            [JsonProperty(PropertyName = "Supply Drop settings")]
            public EventSettings SupplyDropSettings = new();

            [JsonProperty(PropertyName = "Teams settings")]
            public EventSettings TeamsSettings = new();

            [JsonProperty(PropertyName = "User Banned settings")]
            public EventSettings UserBannedSettings = new();

            [JsonProperty(PropertyName = "User Kicked settings")]
            public EventSettings UserKickedSettings = new();

            [JsonProperty(PropertyName = "User Muted settings")]
            public EventSettings UserMutedSettings = new();

            [JsonProperty(PropertyName = "User Name Updated settings")]
            public EventSettings UserNameUpdateSettings = new();

            [JsonProperty(PropertyName = "Vanish settings")]
            public EventSettings VanishSettings = new();
        }

        private class GlobalSettings
        {
            [JsonProperty(PropertyName = "Log to console?")]
            public bool LoggingEnabled = false;

            [JsonProperty(PropertyName = "Use AntiSpam plugin on chat messages")]
            public bool UseAntiSpam = false;

            [JsonProperty(PropertyName = "Use UFilter plugin on chat messages")]
            public bool UseUFilter = false;

            [JsonProperty(PropertyName = "Hide admin connect/disconnect messages")]
            public bool HideAdmin = false;

            [JsonProperty(PropertyName = "Hide NPC death messages")]
            public bool HideNPC = false;

            [JsonProperty(PropertyName = "Replacement string for tags")]
            public string TagsReplacement = "`";

            [JsonProperty(PropertyName = "Queue interval (1 message per ? seconds)")]
            public float QueueInterval = 1f;

            [JsonProperty(PropertyName = "Queue cooldown if connection error (seconds)")]
            public float QueueCooldown = 60f;

            [JsonProperty(PropertyName = "Default WebhookURL")]
            public string DefaultWebhookURL = string.Empty;

            [JsonProperty(PropertyName = "RCON command blacklist", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> RCONCommandBlacklist = new()
            {
                "playerlist",
                "status"
            };
        }

        private class EventSettings
        {
            [JsonProperty(PropertyName = "WebhookURL")]
            public string WebhookURL = "";

            [JsonProperty(PropertyName = "Enabled?")]
            public bool Enabled = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration

        #region Localization

        public string Lang(string key, string userIDString = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, userIDString).Replace("{time}", $"<t:{DateTimeOffset.Now.ToUnixTimeSeconds()}:t>"), args);
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception:\n{ex}");
                throw;
            }
        }

        private static class LangKeys
        {
            public static class Event
            {
                private const string Base = nameof(Event) + ".";
                public const string Bradley = Base + nameof(Bradley);
                public const string CargoPlane = Base + nameof(CargoPlane);
                public const string CargoShip = Base + nameof(CargoShip);
                public const string Chat = Base + nameof(Chat);
                public const string ChatTeam = Base + nameof(ChatTeam);
                public const string Chinook = Base + nameof(Chinook);
                public const string Christmas = Base + nameof(Christmas);
                public const string Death = Base + nameof(Death);
                public const string Easter = Base + nameof(Easter);
                public const string EasterWinner = Base + nameof(EasterWinner);
                public const string Error = Base + nameof(Error);
                public const string Halloween = Base + nameof(Halloween);
                public const string HalloweenWinner = Base + nameof(HalloweenWinner);
                public const string Helicopter = Base + nameof(Helicopter);
                public const string Initialized = Base + nameof(Initialized);
                public const string LockedCrate = Base + nameof(LockedCrate);
                public const string PlayerConnected = Base + nameof(PlayerConnected);
                public const string PlayerConnectedInfo = Base + nameof(PlayerConnectedInfo);
                public const string PlayerDisconnected = Base + nameof(PlayerDisconnected);
                public const string PlayerRespawned = Base + nameof(PlayerRespawned);
                public const string RconCommand = Base + nameof(RconCommand);
                public const string RconConnection = Base + nameof(RconConnection);
                public const string SantaSleigh = Base + nameof(SantaSleigh);
                public const string ServerMessage = Base + nameof(ServerMessage);
                public const string Shutdown = Base + nameof(Shutdown);
                public const string SupplyDrop = Base + nameof(SupplyDrop);
                public const string SupplyDropLanded = Base + nameof(SupplyDropLanded);
                public const string SupplySignal = Base + nameof(SupplySignal);
                public const string Team = Base + nameof(Team);
                public const string UserBanned = Base + nameof(UserBanned);
                public const string UserKicked = Base + nameof(UserKicked);
                public const string UserMuted = Base + nameof(UserMuted);
                public const string UserNameUpdated = Base + nameof(UserNameUpdated);
                public const string UserUnbanned = Base + nameof(UserUnbanned);
                public const string UserUnmuted = Base + nameof(UserUnmuted);
            }

            public static class Permission
            {
                private const string Base = nameof(Permission) + ".";
                public const string GroupCreated = Base + nameof(GroupCreated);
                public const string GroupDeleted = Base + nameof(GroupDeleted);
                public const string UserGroupAdded = Base + nameof(UserGroupAdded);
                public const string UserGroupRemoved = Base + nameof(UserGroupRemoved);
                public const string UserPermissionGranted = Base + nameof(UserPermissionGranted);
                public const string UserPermissionRevoked = Base + nameof(UserPermissionRevoked);
            }

            public static class Plugin
            {
                private const string Base = nameof(Plugin) + ".";
                public const string AdminHammerOff = Base + nameof(AdminHammerOff);
                public const string AdminHammerOn = Base + nameof(AdminHammerOn);
                public const string AdminRadarOff = Base + nameof(AdminRadarOff);
                public const string AdminRadarOn = Base + nameof(AdminRadarOn);
                public const string ClanCreated = Base + nameof(ClanCreated);
                public const string ClanDisbanded = Base + nameof(ClanDisbanded);
                public const string DangerousTreasuresEnded = Base + nameof(DangerousTreasuresEnded);
                public const string DangerousTreasuresStarted = Base + nameof(DangerousTreasuresStarted);
                public const string DeathNotes = Base + nameof(DeathNotes);
                public const string Duel = Base + nameof(Duel);
                public const string GodmodeOff = Base + nameof(GodmodeOff);
                public const string GodmodeOn = Base + nameof(GodmodeOn);
                public const string NTeleportation = Base + nameof(NTeleportation);
                public const string PersonalHelicopter = Base + nameof(PersonalHelicopter);
                public const string PrivateMessage = Base + nameof(PrivateMessage);
                public const string RaidableBaseCompleted = Base + nameof(RaidableBaseCompleted);
                public const string RaidableBaseEnded = Base + nameof(RaidableBaseEnded);
                public const string RaidableBaseStarted = Base + nameof(RaidableBaseStarted);
                public const string RustKits = Base + nameof(RustKits);
                public const string TimedGroupAdded = Base + nameof(TimedGroupAdded);
                public const string TimedGroupExtended = Base + nameof(TimedGroupExtended);
                public const string TimedPermissionExtended = Base + nameof(TimedPermissionExtended);
                public const string TimedPermissionGranted = Base + nameof(TimedPermissionGranted);
                public const string VanishOff = Base + nameof(VanishOff);
                public const string VanishOn = Base + nameof(VanishOn);
            }

            public static class Format
            {
                private const string Base = nameof(Format) + ".";
                public const string CargoShip = Base + nameof(CargoShip);
                public const string Created = Base + nameof(Created);
                public const string Day = Base + nameof(Day);
                public const string Days = Base + nameof(Days);
                public const string Disbanded = Base + nameof(Disbanded);
                public const string Easy = Base + nameof(Easy);
                public const string Expert = Base + nameof(Expert);
                public const string Hard = Base + nameof(Hard);
                public const string Hour = Base + nameof(Hour);
                public const string Hours = Base + nameof(Hours);
                public const string LargeOilRig = Base + nameof(LargeOilRig);
                public const string Medium = Base + nameof(Medium);
                public const string Minute = Base + nameof(Minute);
                public const string Minutes = Base + nameof(Minutes);
                public const string Nightmare = Base + nameof(Nightmare);
                public const string OilRig = Base + nameof(OilRig);
                public const string Second = Base + nameof(Second);
                public const string Seconds = Base + nameof(Seconds);
                public const string Updated = Base + nameof(Updated);
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new()
            {
                [LangKeys.Event.Bradley] = ":dagger: {time} Bradley spawned `{0}`",
                [LangKeys.Event.CargoPlane] = ":airplane: {time} Cargo Plane incoming `{0}`",
                [LangKeys.Event.CargoShip] = ":ship: {time} Cargo Ship incoming `{0}`",
                [LangKeys.Event.Chat] = ":speech_left: {time} **{0}**: {1}",
                [LangKeys.Event.ChatTeam] = ":busts_in_silhouette: {time} **{0}**: {1}",
                [LangKeys.Event.Chinook] = ":helicopter: {time} Chinook 47 incoming `{0}`",
                [LangKeys.Event.Christmas] = ":christmas_tree: {time} Christmas event started",
                [LangKeys.Event.Death] = ":skull: {time} `{0}` died",
                [LangKeys.Event.Easter] = ":egg: {time} Easter event started",
                [LangKeys.Event.EasterWinner] = ":egg: {time} Easter event ended. The winner is `{0}`",
                [LangKeys.Event.Error] = ":octagonal_sign: {time}\n{0}",
                [LangKeys.Event.Halloween] = ":jack_o_lantern: {time} Halloween event started",
                [LangKeys.Event.HalloweenWinner] = ":jack_o_lantern: {time} Halloween event ended. The winner is `{0}`",
                [LangKeys.Event.Helicopter] = ":dagger: {time} Helicopter incoming `{0}`",
                [LangKeys.Event.Initialized] = ":ballot_box_with_check: {time} Server is online again!",
                [LangKeys.Event.LockedCrate] = ":package: {time} Codelocked crate is here `{0}`",
                [LangKeys.Event.PlayerConnected] = ":white_check_mark: {time} {0} connected",
                [LangKeys.Event.PlayerConnectedInfo] = ":detective: {time} {0} connected. SteamID: `{1}` IP: `{2}`",
                [LangKeys.Event.PlayerDisconnected] = ":x: {time} {0} disconnected ({1})",
                [LangKeys.Event.PlayerRespawned] = ":baby_symbol: {time} `{0}` has been spawned at `{1}`",
                [LangKeys.Event.RconCommand] = ":satellite: {time} RCON command `{0}` is run from `{1}`",
                [LangKeys.Event.RconConnection] = ":satellite: {time} RCON connection is opened from `{0}`",
                [LangKeys.Event.Team] = ":family_man_girl_boy: {time} Team was `{0}`\n{1}",
                [LangKeys.Event.SantaSleigh] = ":santa: {time} SantaSleigh Event started",
                [LangKeys.Event.ServerMessage] = ":desktop: {time} `{0}`",
                [LangKeys.Event.Shutdown] = ":stop_sign: {time} Server is shutting down!",
                [LangKeys.Event.SupplyDrop] = ":parachute: {time} SupplyDrop incoming at `{0}`",
                [LangKeys.Event.SupplyDropLanded] = ":gift: {time} SupplyDrop landed at `{0}`",
                [LangKeys.Event.SupplySignal] = ":firecracker: {time} SupplySignal was thrown by `{0}` at `{1}`",
                [LangKeys.Event.UserBanned] = ":no_entry: {time} Player `{0}` SteamID: `{1}` IP: `{2}` was banned: `{3}`",
                [LangKeys.Event.UserKicked] = ":hiking_boot: {time} Player `{0}` SteamID: `{1}` was kicked: `{2}`",
                [LangKeys.Event.UserMuted] = ":mute: {time} `{0}` was muted by `{1}` for `{2}` (`{3}`)",
                [LangKeys.Event.UserNameUpdated] = ":label: {time} `{0}` changed name to `{1}` SteamID: `{2}`",
                [LangKeys.Event.UserUnbanned] = ":ok: {time} Player `{0}` SteamID: `{1}` IP: `{2}` was unbanned",
                [LangKeys.Event.UserUnmuted] = ":speaker: {time} `{0}` was unmuted `{1}`",
                [LangKeys.Format.CargoShip] = "Cargo Ship",
                [LangKeys.Format.Created] = "created",
                [LangKeys.Format.Day] = "day",
                [LangKeys.Format.Days] = "days",
                [LangKeys.Format.Disbanded] = "disbanded",
                [LangKeys.Format.Easy] = "Easy",
                [LangKeys.Format.Expert] = "Expert",
                [LangKeys.Format.Hard] = "Hard",
                [LangKeys.Format.Hour] = "hour",
                [LangKeys.Format.Hours] = "hours",
                [LangKeys.Format.LargeOilRig] = "Large Oil Rig",
                [LangKeys.Format.Medium] = "Medium",
                [LangKeys.Format.Minute] = "minute",
                [LangKeys.Format.Minutes] = "minutes",
                [LangKeys.Format.Nightmare] = "Nightmare",
                [LangKeys.Format.OilRig] = "Oil Rig",
                [LangKeys.Format.Second] = "second",
                [LangKeys.Format.Seconds] = "seconds",
                [LangKeys.Format.Updated] = "updated",
                [LangKeys.Permission.GroupCreated] = ":family: {time} Group `{0}` has been created",
                [LangKeys.Permission.GroupDeleted] = ":family: {time} Group `{0}` has been deleted",
                [LangKeys.Permission.UserGroupAdded] = ":family: {time} `{0}` `{1}` is added to group `{2}`",
                [LangKeys.Permission.UserGroupRemoved] = ":family: {time} `{0}` `{1}` is removed from group `{2}`",
                [LangKeys.Permission.UserPermissionGranted] = ":key: {time} `{0}` `{1}` is granted `{2}`",
                [LangKeys.Permission.UserPermissionRevoked] = ":key: {time} `{0}` `{1}` is revoked `{2}`",
                [LangKeys.Plugin.AdminHammerOff] = ":hammer: {time} AdminHammer enabled by `{0}`",
                [LangKeys.Plugin.AdminHammerOn] = ":hammer: {time} AdminHammer disabled by `{0}`",
                [LangKeys.Plugin.AdminRadarOff] = ":compass: {time} Admin Radar enabled by `{0}`",
                [LangKeys.Plugin.AdminRadarOn] = ":compass: {time} Admin Radar disabled by `{0}`",
                [LangKeys.Plugin.ClanCreated] = ":family_mwgb: {time} **{0}** clan was created",
                [LangKeys.Plugin.ClanDisbanded] = ":family_mwgb: {time} **{0}** clan was disbanded",
                [LangKeys.Plugin.DangerousTreasuresEnded] = ":pirate_flag: {time} Dangerous Treasures event at `{0}` is ended",
                [LangKeys.Plugin.DangerousTreasuresStarted] = ":pirate_flag: {time} Dangerous Treasures started at `{0}`",
                [LangKeys.Plugin.DeathNotes] = ":skull_crossbones: {time} {0}",
                [LangKeys.Plugin.Duel] = ":crossed_swords: {time} `{0}` has defeated `{1}` in a duel",
                [LangKeys.Plugin.GodmodeOff] = ":angel: {time} Godmode disabled for `{0}`",
                [LangKeys.Plugin.GodmodeOn] = ":angel: {time} Godmode enabled for `{0}`",
                [LangKeys.Plugin.NTeleportation] = ":cyclone: {time} `{0}` teleported from `{1}` `{2}` to `{3}` `{4}`",
                [LangKeys.Plugin.PersonalHelicopter] = ":dagger: {time} Personal Helicopter incoming `{0}`",
                [LangKeys.Plugin.PrivateMessage] = ":envelope: {time} PM from `{0}` to `{1}`: {2}",
                [LangKeys.Plugin.RaidableBaseCompleted] = ":homes: {time} {1} Raidable Base owned by {2} at `{0}` has been raided by **{3}**",
                [LangKeys.Plugin.RaidableBaseEnded] = ":homes: {time} {1} Raidable Base at `{0}` has ended",
                [LangKeys.Plugin.RaidableBaseStarted] = ":homes: {time} {1} Raidable Base spawned at `{0}`",
                [LangKeys.Plugin.RustKits] = ":shopping_bags: {time} `{0}` redeemed a kit `{1}`",
                [LangKeys.Plugin.TimedGroupAdded] = ":timer: {time} `{0}` `{1}` is added to `{2}` for {3}",
                [LangKeys.Plugin.TimedGroupExtended] = ":timer: {time} `{0}` `{1}` timed group `{2}` is extended to {3}",
                [LangKeys.Plugin.TimedPermissionExtended] = ":timer: {time} `{0}` `{1}` timed permission `{2}` is extended to {3}",
                [LangKeys.Plugin.TimedPermissionGranted] = ":timer: {time} `{0}` `{1}` is granted `{2}` for {3}",
                [LangKeys.Plugin.VanishOff] = ":ghost: {time} Vanish: Disabled for `{0}`",
                [LangKeys.Plugin.VanishOn] = ":ghost: {time} Vanish: Enabled for `{0}`",
            }, this);
        }

        #endregion Localization

        #region Events Hooks

        private void OnAdminHammerEnabled(BasePlayer player)
        {
            LogToConsole($"AdminHammer enabled by {player.UserIDString} {player.displayName}");

            DiscordSendMessage(Lang(LangKeys.Plugin.AdminHammerOff, null, ReplaceChars(player.displayName)), _configData.AdminHammerSettings.WebhookURL);
        }

        private void OnAdminHammerDisabled(BasePlayer player)
        {
            LogToConsole($"AdminHammer disabled by {player.UserIDString} {player.displayName}");

            DiscordSendMessage(Lang(LangKeys.Plugin.AdminHammerOn, null, ReplaceChars(player.displayName)), _configData.AdminHammerSettings.WebhookURL);
        }

        private void OnBetterChatMuted(IPlayer target, IPlayer initiator, string reason)
        {
            LogToConsole($"{target.Name} was muted by {initiator.Name} for ever ({reason})");

            DiscordSendMessage(Lang(LangKeys.Event.UserMuted, null, ReplaceChars(target.Name), ReplaceChars(initiator.Name), "ever", ReplaceChars(reason)), _configData.UserMutedSettings.WebhookURL);
        }

        private void OnBetterChatMuteExpired(IPlayer player)
        {
            LogToConsole($"{player.Name} was unmuted by SERVER");

            DiscordSendMessage(Lang(LangKeys.Event.UserUnmuted, null, ReplaceChars(player.Name), "SERVER"), _configData.UserMutedSettings.WebhookURL);
        }

        private void OnBetterChatTimeMuted(IPlayer target, IPlayer initiator, TimeSpan time, string reason)
        {
            LogToConsole($"{target.Name} was muted by {initiator.Name} for {time.ToShortString()} ({reason})");

            DiscordSendMessage(Lang(LangKeys.Event.UserMuted, null, ReplaceChars(target.Name), ReplaceChars(initiator.Name), time.ToShortString(), ReplaceChars(reason)), _configData.UserMutedSettings.WebhookURL);
        }

        private void OnBetterChatUnmuted(IPlayer target, IPlayer initiator)
        {
            LogToConsole($"{target.Name} was unmuted by {initiator.Name}");

            DiscordSendMessage(Lang(LangKeys.Event.UserUnmuted, null, ReplaceChars(target.Name), ReplaceChars(initiator.Name)), _configData.UserMutedSettings.WebhookURL);
        }

        private void OnClanCreate(string tag)
        {
            LogToConsole($"{tag} clan was created");

            DiscordSendMessage(Lang(LangKeys.Plugin.ClanCreated, null, ReplaceChars(tag)), _configData.ClanSettings.WebhookURL);
        }

        private void OnClanDisbanded(string tag)
        {
            LogToConsole($"{tag} clan was disbanded");

            DiscordSendMessage(Lang(LangKeys.Plugin.ClanDisbanded, null, ReplaceChars(tag)), _configData.ClanSettings.WebhookURL);
        }

        private void OnDangerousEventStarted(Vector3 containerPos)
        {
            HandleDangerousTreasures(containerPos, LangKeys.Plugin.DangerousTreasuresStarted);
        }

        private void OnDangerousEventEnded(Vector3 containerPos)
        {
            HandleDangerousTreasures(containerPos, LangKeys.Plugin.DangerousTreasuresEnded);
        }

        private void OnDeathNotice(Dictionary<string, object> data, string message)
        {
            DiscordSendMessage(Lang(LangKeys.Plugin.DeathNotes, null, StripRustTags(Formatter.ToPlaintext(message))), _configData.PlayerDeathNotesSettings.WebhookURL);
        }

        private void OnDuelistDefeated(BasePlayer attacker, BasePlayer victim)
        {
            if (!attacker.IsValid() || !victim.IsValid())
            {
                return;
            }

            LogToConsole($"{attacker.displayName} has defeated {victim.displayName} in a duel");

            DiscordSendMessage(Lang(LangKeys.Plugin.Duel, null, ReplaceChars(attacker.displayName), ReplaceChars(victim.displayName)), _configData.DuelSettings.WebhookURL);
        }

        private void OnEntitySpawned(PatrolHelicopter entity)
        {
            NextTick(() => HandleEntity(entity));
        }

        private void OnEntitySpawned(BradleyAPC entity) => HandleEntity(entity);

        private void OnEntitySpawned(CargoPlane entity) => HandleEntity(entity);

        private void OnEntitySpawned(CargoShip entity) => HandleEntity(entity);

        private void OnEntitySpawned(CH47HelicopterAIController entity) => HandleEntity(entity);

        private void OnEntitySpawned(EggHuntEvent entity) => HandleEntity(entity);

        private void OnEntitySpawned(HackableLockedCrate entity) => HandleEntity(entity);

        private void OnEntitySpawned(SantaSleigh entity) => HandleEntity(entity);

        private void OnEntitySpawned(SupplyDrop entity) => HandleEntity(entity);

        private void OnEntitySpawned(XMasRefill entity) => HandleEntity(entity);

        private void OnEntityDeath(BasePlayer player, HitInfo info)
        {
            if (!player.IsValid() || info == null)
            {
                return;
            }

            if (_configData.GlobalSettings.HideNPC && (player.IsNpc || !player.userID.IsSteamId()))
            {
                return;
            }

            LogToConsole($"{player.displayName} died.");

            DiscordSendMessage(Lang(LangKeys.Event.Death, null, ReplaceChars(player.displayName)), _configData.PlayerDeathSettings.WebhookURL);
        }

        private void OnEntityKill(EggHuntEvent entity)
        {
            if (!entity.IsValid())
            {
                return;
            }

            List<EggHuntEvent.EggHunter> topHunters = Facepunch.Pool.Get<List<EggHuntEvent.EggHunter>>();
            foreach (KeyValuePair<ulong, EggHuntEvent.EggHunter> eggHunter in entity._eggHunters)
            {
                topHunters.Add(eggHunter.Value);
            }

            topHunters.Sort((EggHuntEvent.EggHunter a, EggHuntEvent.EggHunter b) => b.numEggs.CompareTo(a.numEggs));

            string winner;
            if (topHunters.Count > 0)
            {
                winner = ReplaceChars(topHunters[0].displayName);
            }
            else
            {
                winner = "No winner";
            }

            Facepunch.Pool.FreeUnmanaged(ref topHunters);

            bool isHalloween = entity is HalloweenHunt;
            if (isHalloween)
            {
                if (_configData.HalloweenSettings.Enabled)
                {
                    LogToConsole("Halloween Hunt Event has ended. The winner is " + winner);

                    DiscordSendMessage(Lang(LangKeys.Event.HalloweenWinner, null, winner), _configData.HalloweenSettings.WebhookURL);
                }
            }
            else
            {
                if (_configData.EasterSettings.Enabled)
                {
                    LogToConsole("Egg Hunt Event has ended. The winner is " + winner);

                    DiscordSendMessage(Lang(LangKeys.Event.EasterWinner, null, winner), _configData.EasterSettings.WebhookURL);
                }
            }
        }

        private void OnEntityKill(CargoShip cargoShip)
        {
            if (cargoShip.IsValid())
            {
                _cargoShips.Remove(cargoShip.net.ID.Value);
            }
        }

        private void OnExplosiveThrown(BasePlayer player, SupplySignal entity) => HandleSupplySignal(player, entity);

        private void OnExplosiveDropped(BasePlayer player, SupplySignal entity) => HandleSupplySignal(player, entity);

        private void OnGodmodeToggled(string playerID, bool enabled)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            if (enabled)
            {
                LogToConsole($"Godmode disabled for {player.Id} {player.Name}");

                DiscordSendMessage(Lang(LangKeys.Plugin.GodmodeOn, null, ReplaceChars(player.Name)), _configData.GodmodeSettings.WebhookURL);

                return;
            }

            LogToConsole($"Godmode enabled for {player.Id} {player.Name}");

            DiscordSendMessage(Lang(LangKeys.Plugin.GodmodeOff, null, ReplaceChars(player.Name)), _configData.GodmodeSettings.WebhookURL);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (_configData.PlayerConnectedSettings.Enabled)
            {
                LogToConsole($"Player {player.displayName} connected.");

                if (!_configData.GlobalSettings.HideAdmin || !player.IsAdmin)
                {
                    DiscordSendMessage(Lang(LangKeys.Event.PlayerConnected, null, ReplaceChars(player.displayName)), _configData.PlayerConnectedSettings.WebhookURL);
                }
            }

            if (_configData.PlayerConnectedInfoSettings.Enabled)
            {
                DiscordSendMessage(Lang(LangKeys.Event.PlayerConnectedInfo, null, ReplaceChars(player.displayName), player.UserIDString, player.net.connection.ipaddress.Split(':')[0]), _configData.PlayerConnectedInfoSettings.WebhookURL);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!player.IsValid())
            {
                return;
            }

            LogToConsole($"Player {player.displayName} disconnected ({reason}).");

            if (!_configData.GlobalSettings.HideAdmin || !player.IsAdmin)
            {
                DiscordSendMessage(Lang(LangKeys.Event.PlayerDisconnected, null, ReplaceChars(player.displayName), ReplaceChars(reason)), _configData.PlayerDisconnectedSettings.WebhookURL);
            }
        }

        private void OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            if (!player.IsValid() || string.IsNullOrWhiteSpace(message))
            {
                return;
            }

            if (IsPluginLoaded(BetterChatMute))
            {
                _resultCall = BetterChatMute.Call("API_IsMuted", player.IPlayer);

                if (_resultCall is bool && (bool)_resultCall)
                {
                    return;
                }
            }

            if (_configData.GlobalSettings.UseAntiSpam && IsPluginLoaded(AntiSpam))
            {
                _resultCall = AntiSpam.Call("GetSpamFreeText", message);

                message = (_resultCall as string);

                if (string.IsNullOrWhiteSpace(message))
                {
                    return;
                }
            }

            if (_configData.GlobalSettings.UseUFilter && IsPluginLoaded(UFilter))
            {
                _sb.Clear();
                _sb.Append(message);

                _resultCall = UFilter.Call("Profanities", message);

                if (_resultCall is string[])
                {
                    _profanities = _resultCall as string[];
                }

                foreach (string profanity in _profanities)
                {
                    _sb.Replace(profanity, new('＊', profanity.Length));
                }

                message = _sb.ToString();

                if (string.IsNullOrWhiteSpace(message))
                {
                    return;
                }
            }

            message = ReplaceChars(message);

            switch (channel)
            {
                case ConVar.Chat.ChatChannel.Global:
                case ConVar.Chat.ChatChannel.Local:
                    if (_configData.ChatSettings.Enabled)
                    {
                        DiscordSendMessage(Lang(LangKeys.Event.Chat, null, ReplaceChars(player.displayName), message), _configData.ChatSettings.WebhookURL);
                    }
                    break;
                case ConVar.Chat.ChatChannel.Team:
                    if (_configData.ChatTeamSettings.Enabled)
                    {
                        DiscordSendMessage(Lang(LangKeys.Event.ChatTeam, null, ReplaceChars(player.displayName), message), _configData.ChatTeamSettings.WebhookURL);
                    }
                    break;
            }
        }

        private void OnPlayerTeleported(BasePlayer player, Vector3 oldPosition, Vector3 newPosition)
        {
            LogToConsole($"NTeleportation {player.UserIDString} {player.displayName} from {oldPosition} to {newPosition}");

            DiscordSendMessage(Lang(LangKeys.Plugin.NTeleportation, null, ReplaceChars(player.displayName), GetGridPosition(oldPosition), oldPosition, GetGridPosition(newPosition), newPosition), _configData.NTeleportationSettings.WebhookURL);
        }

        private void OnPMProcessed(IPlayer sender, IPlayer target, string message)
        {
            LogToConsole($"PM from `{sender.Name}` to `{target.Name}`: {message}");

            DiscordSendMessage(Lang(LangKeys.Plugin.PrivateMessage, null, ReplaceChars(sender.Name), ReplaceChars(target.Name), ReplaceChars(message)), _configData.PrivateMessagesSettings.WebhookURL);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (string.IsNullOrWhiteSpace(player?.displayName))
            {
                return;
            }

            LogToConsole($"{player.displayName} has been spawned at {GetGridPosition(player.transform.position)}");

            DiscordSendMessage(Lang(LangKeys.Event.PlayerRespawned, null, ReplaceChars(player.displayName), GetGridPosition(player.transform.position)), _configData.PlayerRespawnedSettings.WebhookURL);
        }

        private void OnRadarActivated(BasePlayer player)
        {
            LogToConsole($"Admin Radar enabled by {player.UserIDString} {player.displayName}");

            DiscordSendMessage(Lang(LangKeys.Plugin.AdminRadarOn, null, ReplaceChars(player.displayName)), _configData.AdminRadarSettings.WebhookURL);
        }

        private void OnRadarDeactivated(BasePlayer player)
        {
            LogToConsole($"Admin Radar disabled by {player.UserIDString} {player.displayName}");

            DiscordSendMessage(Lang(LangKeys.Plugin.AdminRadarOff, null, ReplaceChars(player.displayName)), _configData.AdminRadarSettings.WebhookURL);
        }

        private void OnRaidableBaseStarted(Vector3 raidPos, int difficulty)
        {
            HandleRaidableBase(raidPos, difficulty, LangKeys.Plugin.RaidableBaseStarted);
        }

        private void OnRaidableBaseEnded(Vector3 raidPos, int difficulty)
        {
            HandleRaidableBase(raidPos, difficulty, LangKeys.Plugin.RaidableBaseEnded);
        }

        private void OnRaidableBaseCompleted(Vector3 raidPos, int difficulty, bool allowPVP, string id, float spawnTime, float despawnTime, float loadTime, ulong ownerId, BasePlayer owner, List<BasePlayer> raiders)
        {
            HandleRaidableBase(raidPos, difficulty, LangKeys.Plugin.RaidableBaseCompleted, owner, raiders);
        }

        private void OnRconConnection(IPAddress ip)
        {
            LogToConsole($"RCON connection is opened from {ip}");

            DiscordSendMessage(Lang(LangKeys.Event.RconConnection, null, ip.ToString()), _configData.RconConnectionSettings.WebhookURL);
        }

        private void OnRconCommand(IPAddress ip, string command, string[] args)
        {
            foreach (string rconCommand in _configData.GlobalSettings.RCONCommandBlacklist)
            {
                if (command.ToLower().Equals(rconCommand.ToLower()))
                {
                    return;
                }
            }

            for (int i = 0; i < args.Length; i++)
            {
                command += $" {args[i]}";
            }

            LogToConsole($"RCON command {command} is run from {ip}");

            DiscordSendMessage(Lang(LangKeys.Event.RconCommand, null, command, ip), _configData.RconCommandSettings.WebhookURL);
        }

        private void OnSupplyDropLanded(SupplyDrop entity)
        {
            if (!entity.IsValid() || _listSupplyDrops.Contains(entity.net.ID.Value))
            {
                return;
            }

            LogToConsole($"SupplyDrop landed at {GetGridPosition(entity.transform.position)}");

            DiscordSendMessage(Lang(LangKeys.Event.SupplyDropLanded, null, GetGridPosition(entity.transform.position)), _configData.SupplyDropSettings.WebhookURL);

            _entityID = entity.net.ID.Value;

            _listSupplyDrops.Add(_entityID);

            timer.Once(60f, () => _listSupplyDrops.Remove(_entityID));
        }

        private void OnUserBanned(string name, string id, string ipAddress, string reason)
        {
            LogToConsole($"Player {name} ({id}) at {ipAddress} was banned: {reason}");

            DiscordSendMessage(Lang(LangKeys.Event.UserBanned, null, ReplaceChars(name), id, ipAddress, ReplaceChars(reason)), _configData.UserBannedSettings.WebhookURL);
        }

        private void OnUserKicked(IPlayer player, string reason)
        {
            LogToConsole($"Player {player.Name} ({player.Id}) was kicked ({reason})");

            DiscordSendMessage(Lang(LangKeys.Event.UserKicked, null, ReplaceChars(player.Name), player.Id, ReplaceChars(reason)), _configData.UserKickedSettings.WebhookURL);
        }

        private void OnUserUnbanned(string name, string id, string ipAddress)
        {
            LogToConsole($"Player {name} ({id}) at {ipAddress} was unbanned");

            DiscordSendMessage(Lang(LangKeys.Event.UserUnbanned, null, ReplaceChars(name), id, ipAddress), _configData.UserBannedSettings.WebhookURL);
        }

        private void OnUserNameUpdated(string id, string oldName, string newName)
        {
            if (oldName.Equals(newName) || oldName.Equals("Unnamed"))
            {
                return;
            }
            
            LogToConsole($"Player name changed from {oldName} to {newName} for ID {id}");

            DiscordSendMessage(Lang(LangKeys.Event.UserNameUpdated, null, ReplaceChars(oldName), ReplaceChars(newName), id), _configData.UserNameUpdateSettings.WebhookURL);
        }

        private void OnServerMessage(string message, string name, string color, ulong id)
        {
            LogToConsole($"ServerMessage: {message}");

            DiscordSendMessage(Lang(LangKeys.Event.ServerMessage, null, message), _configData.ServerMessagesSettings.WebhookURL);
        }

        private void OnKitRedeemed(BasePlayer player, string kitName)
        {
            LogToConsole($"{player.UserIDString} {player.displayName} redeemed a kit {kitName}");

            DiscordSendMessage(Lang(LangKeys.Plugin.RustKits, null, ReplaceChars(player.displayName), ReplaceChars(kitName)), _configData.RustKitsSettings.WebhookURL);
        }

        private void OnVanishDisappear(BasePlayer player)
        {
            LogToConsole($"Vanish: Enabled ({player.UserIDString} {player.displayName})");

            DiscordSendMessage(Lang(LangKeys.Plugin.VanishOn, null, ReplaceChars(player.displayName)), _configData.VanishSettings.WebhookURL);
        }

        private void OnVanishReappear(BasePlayer player)
        {
            LogToConsole($"Vanish: Disabled ({player.UserIDString} {player.displayName})");

            DiscordSendMessage(Lang(LangKeys.Plugin.VanishOff, null, ReplaceChars(player.displayName)), _configData.VanishSettings.WebhookURL);
        }

        #region Team Hooks

        private void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team) => HandleTeam(team, TeamEventType.Created);

        private void OnTeamDisbanded(RelationshipManager.PlayerTeam team) => HandleTeam(team, TeamEventType.Disbanded);

        private void OnTeamUpdated(ulong currentTeam, RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            NextTick( () => {
                if (team.members.Count > 0)
                {
                    HandleTeam(team, TeamEventType.Updated);
                }
            });
        }

        private void OnTeamPromote(RelationshipManager.PlayerTeam team, BasePlayer newLeader)
        {
            NextTick( () => { HandleTeam(team, TeamEventType.Updated); });
        }

        private void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            NextTick( () => {
                if (team?.members?.Count > 0)
                {
                    HandleTeam(team, TeamEventType.Updated);
                }
            });
        }

        private void OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong target)
        {
            NextTick( () => { HandleTeam(team, TeamEventType.Updated); });
        }

        private void OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            NextTick( () => { HandleTeam(team, TeamEventType.Updated); });
        }

        #endregion Team Hooks

        #region Permissions

        private void OnGroupCreated(string name)
        {
            LogToConsole($"Group {name} has been created");

            DiscordSendMessage(Lang(LangKeys.Permission.GroupCreated, null, name), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnGroupDeleted(string name)
        {
            LogToConsole($"Group {name} has been deleted");

            DiscordSendMessage(Lang(LangKeys.Permission.GroupDeleted, null, name), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnTimedPermissionGranted(string playerID, string permission, TimeSpan duration)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} is granted {permission} for {duration}");

            DiscordSendMessage(Lang(LangKeys.Plugin.TimedPermissionGranted, null, playerID, ReplaceChars(player.Name), permission, GetFormattedDurationTime(duration)), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnTimedPermissionExtended(string playerID, string permission, TimeSpan duration)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} timed permission {permission} is extended for {duration}");

            DiscordSendMessage(Lang(LangKeys.Plugin.TimedPermissionExtended, null, playerID, ReplaceChars(player.Name), permission, GetFormattedDurationTime(duration)), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnTimedGroupAdded(string playerID, string group, TimeSpan duration)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} is added to {group} for {duration}");

            DiscordSendMessage(Lang(LangKeys.Plugin.TimedGroupAdded, null, playerID, ReplaceChars(player.Name), group, GetFormattedDurationTime(duration)), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnTimedGroupExtended(string playerID, string group, TimeSpan duration)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} timed group {group} is extended for {duration}");

            DiscordSendMessage(Lang(LangKeys.Plugin.TimedGroupExtended, null, playerID, ReplaceChars(player.Name), group, GetFormattedDurationTime(duration)), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnUserGroupAdded(string playerID, string groupName)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} is added to group {groupName}");

            DiscordSendMessage(Lang(LangKeys.Permission.UserGroupAdded, null, playerID, ReplaceChars(player.Name), groupName), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnUserGroupRemoved(string playerID, string groupName)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} is removed from group {groupName}");

            DiscordSendMessage(Lang(LangKeys.Permission.UserGroupRemoved, null, playerID, ReplaceChars(player.Name), groupName), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnUserPermissionGranted(string playerID, string permName)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} is granted permission {permName}");

            DiscordSendMessage(Lang(LangKeys.Permission.UserPermissionGranted, null, playerID, ReplaceChars(player.Name), permName), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnUserPermissionRevoked(string playerID, string permName)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} is revoked permission {permName}");

            DiscordSendMessage(Lang(LangKeys.Permission.UserPermissionRevoked, null, playerID, ReplaceChars(player.Name), permName), _configData.PermissionsSettings.WebhookURL);
        }

        #endregion

        #endregion Events Hooks

        #region Core Methods

        public string ReplaceChars(string text)
        {
            if (string.IsNullOrWhiteSpace(text))
            {
                return string.Empty;
            }

            _sb.Clear();
            _sb.Append(text);
            _sb.Replace("*", "＊");
            _sb.Replace("`", "'");
            _sb.Replace("_", "＿");
            _sb.Replace("~", "～");
            _sb.Replace(">", "＞");
            _sb.Replace("@here", "here");
            _sb.Replace("@everyone", "everyone");

            return _sb.ToString();
        }

        public void HandleQueue()
        {
            if (_retryCount > 0)
            {
                if (_timerQueueCooldown == null)
                {
                    float timeout = _configData.GlobalSettings.QueueCooldown * Math.Min(_retryCount, 10);
                    PrintWarning($"HandleQueue: connection problem detected! Retry # {_retryCount}. Next try in {timeout} seconds. Messages in queue: {_queue.Count}");

                    _timerQueueCooldown = timer.Once(timeout, () =>
                    {
                        DiscordSendMessage(_queuedMessage.WebhookUrl, new(_queuedMessage.Message));

                        QueueCooldownDisable();

                        HandleQueue();
                    });
                }

                return;
            }

            if (_timerQueueCooldown == null && _timerQueue == null && _queue.Count > 0)
            {
                _queuedMessage = _queue.Dequeue();

                _sb.Clear();

                if (_queuedMessage.Message.Length > 1990)
                {
                    _queuedMessage.Message = $"{_queuedMessage.Message[..1990]}\n```";
                }

                _sb.AppendLine(_queuedMessage.Message);

                for (int i = 0; i < _queue.Count; i++)
                {
                    _nextMessage = _queue.Peek();

                    if (_sb.Length + _nextMessage.Message.Length > 1990
                     || _queuedMessage.WebhookUrl != _nextMessage.WebhookUrl)
                    {
                        break;
                    }

                    _nextMessage = _queue.Dequeue();
                    _sb.AppendLine(_nextMessage.Message);
                }

                _queuedMessage.Message = _sb.ToString();

                DiscordSendMessage(_queuedMessage.WebhookUrl, new(_queuedMessage.Message));

                _timerQueue = timer.Once(_configData.GlobalSettings.QueueInterval, () => {
                    _timerQueue?.Destroy();
                    _timerQueue = null;

                    HandleQueue();
                });
            }
        }

        public void QueueCooldownDisable()
        {
            _timerQueueCooldown?.Destroy();
            _timerQueueCooldown = null;
        }

        public void HandleEntity(BaseEntity baseEntity)
        {
            if (!baseEntity.IsValid())
            {
                return;
            }

            Vector3 position = baseEntity.transform.position;

            if (baseEntity is PatrolHelicopter)
            {
                _langKey = LangKeys.Event.Helicopter;
                _eventSettings = _configData.HelicopterSettings;
            }
            else if (baseEntity is BradleyAPC)
            {
                _langKey = LangKeys.Event.Bradley;
                _eventSettings = _configData.BradleySettings;
                LogToConsole($"BradleyAPC spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is CargoPlane)
            {
                _langKey = LangKeys.Event.CargoPlane;
                _eventSettings = _configData.CargoPlaneSettings;
                LogToConsole($"CargoPlane spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is CargoShip)
            {
                _langKey = LangKeys.Event.CargoShip;
                _eventSettings = _configData.CargoShipSettings;
                LogToConsole($"CargoShip spawned at {GetGridPosition(position)}");

                NextTick( () => {
                    if (baseEntity.IsValid() && !_cargoShips.ContainsKey(baseEntity.net.ID.Value))
                    {
                        _cargoShips[baseEntity.net.ID.Value] = (CargoShip)baseEntity;
                    }
                });
            }
            else if (baseEntity is CH47HelicopterAIController)
            {
                _langKey = LangKeys.Event.Chinook;
                _eventSettings = _configData.ChinookSettings;
                LogToConsole($"CH47Helicopter spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is HalloweenHunt)
            {
                _langKey = LangKeys.Event.Halloween;
                _eventSettings = _configData.HalloweenSettings;
                LogToConsole($"HalloweenHunt spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is EggHuntEvent)
            {
                _langKey = LangKeys.Event.Easter;
                _eventSettings = _configData.EasterSettings;
                LogToConsole("Easter event has started");
            }
            else if (baseEntity is HackableLockedCrate)
            {
                _langKey = LangKeys.Event.LockedCrate;
                _eventSettings = _configData.LockedCrateSettings;
                LogToConsole($"HackableLockedCrate spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is SantaSleigh)
            {
                _langKey = LangKeys.Event.SantaSleigh;
                _eventSettings = _configData.SantaSleighSettings;
                LogToConsole($"SantaSleigh spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is SupplyDrop)
            {
                _langKey = LangKeys.Event.SupplyDrop;
                _eventSettings = _configData.SupplyDropSettings;
                LogToConsole($"SupplyDrop spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is SupplySignal)
            {
                _langKey = LangKeys.Event.SupplySignal;
                _eventSettings = _configData.SupplyDropSettings;
                LogToConsole($"SupplySignal dropped at {GetGridPosition(position)}");
            }
            else if (baseEntity is XMasRefill)
            {
                _langKey = LangKeys.Event.Christmas;
                _eventSettings = _configData.ChristmasSettings;
                LogToConsole("Christmas event has started");
            }

            if (_eventSettings.Enabled)
            {
                if (baseEntity is PatrolHelicopter)
                {
                    if (IsPluginLoaded(CallHeli))
                    {
                        _resultCall = CallHeli.Call("IsPersonal", baseEntity);

                        if (_resultCall is bool && (bool)_resultCall)
                        {
                            LogToConsole("Personal Helicopter spawned at " + GetGridPosition(position));

                            DiscordSendMessage(Lang(LangKeys.Plugin.PersonalHelicopter, null, GetGridPosition(position)), _eventSettings.WebhookURL);
                            return;
                        }
                    }

                    if (IsPluginLoaded(PersonalHeli))
                    {
                        _resultCall = PersonalHeli.Call("IsPersonal", baseEntity);

                        if (_resultCall is bool && (bool)_resultCall)
                        {
                            LogToConsole("Personal Helicopter spawned at " + GetGridPosition(position));

                            DiscordSendMessage(Lang(LangKeys.Plugin.PersonalHelicopter, null, GetGridPosition(position)), _eventSettings.WebhookURL);
                            return;
                        }
                    }

                    LogToConsole("PatrolHelicopter spawned at " + GetGridPosition(position));
                }

                if (baseEntity is HackableLockedCrate)
                {
                    DiscordSendMessage(Lang(_langKey, null, GetHackableLockedCratePosition(position)), _eventSettings.WebhookURL);
                    return;
                }

                DiscordSendMessage(Lang(_langKey, null, GetGridPosition(position)), _eventSettings.WebhookURL);
            }
        }

        public void HandleSupplySignal(BasePlayer player, SupplySignal entity)
        {
            if (_configData.SupplyDropSettings.Enabled)
            {
                NextTick(() => {
                    if (player != null && entity != null)
                    {
                        LogToConsole($"SupplySignal was thrown by {player.displayName} at {GetGridPosition(entity.transform.position)}");

                        DiscordSendMessage(Lang(LangKeys.Event.SupplySignal, null, ReplaceChars(player.displayName), GetGridPosition(entity.transform.position)), _configData.SupplyDropSettings.WebhookURL);
                    }
                });
            }
        }

        public void HandleRaidableBase(Vector3 raidPos, int difficulty, string langKey, BasePlayer owner = null, List<BasePlayer> raiders = null)
        {
            if (raidPos == null)
            {
                PrintError($"{langKey}: raidPos == null");
                return;
            }

            string difficultyString;
            switch (difficulty)
            {
                case 0:
                    difficultyString = LangKeys.Format.Easy;
                    break;
                case 1:
                    difficultyString = LangKeys.Format.Medium;
                    break;
                case 2:
                    difficultyString = LangKeys.Format.Hard;
                    break;
                case 3:
                    difficultyString = LangKeys.Format.Expert;
                    break;
                case 4:
                    difficultyString = LangKeys.Format.Nightmare;
                    break;
                case 512:
                    difficultyString = string.Empty;
                    break;
                default:
                    PrintError($"{langKey}: Unknown difficulty: {difficulty}");
                    return;
            }

            switch (langKey)
            {
                case LangKeys.Plugin.RaidableBaseCompleted:
                    _sb.Clear();
                    for (int i = 0; i < raiders?.Count; i++)
                    {
                        if (i > 0)
                        {
                            _sb.Append(", ");
                        }
                        _sb.Append(ReplaceChars(raiders[i].displayName));
                    }
                    LogToConsole($"{difficultyString} Raidable Base owned by {owner?.displayName} at {GetGridPosition(raidPos)} has been raided by {_sb.ToString()}");
                    DiscordSendMessage(Lang(langKey, null, GetGridPosition(raidPos), Lang(difficultyString), ReplaceChars(owner?.displayName), _sb.ToString()), _configData.RaidableBasesSettings.WebhookURL);
                    break;
                case LangKeys.Plugin.RaidableBaseEnded:
                case LangKeys.Plugin.RaidableBaseStarted:
                    LogToConsole(difficultyString + " Raidable Base at " + GetGridPosition(raidPos) + " has " + (langKey == LangKeys.Plugin.RaidableBaseStarted ? "spawned" : "ended"));
                    DiscordSendMessage(Lang(langKey, null, GetGridPosition(raidPos), Lang(difficultyString)), _configData.RaidableBasesSettings.WebhookURL);
                    break;
            }
        }

        public void HandleDangerousTreasures(Vector3 containerPos, string langKey)
        {
            if (containerPos == null)
            {
                PrintError($"{langKey}: containerPos == null");
                return;
            }

            LogToConsole("Dangerous Treasures at " + GetGridPosition(containerPos) + " is " + (langKey == LangKeys.Plugin.DangerousTreasuresStarted ? "spawned" : "ended"));

            DiscordSendMessage(Lang(langKey, null, GetGridPosition(containerPos)), _configData.DangerousTreasuresSettings.WebhookURL);
        }

        public void HandleLog(string logString, string stackTrace, LogType type)
        {
            if (_configData.ErrorSettings.Enabled && type == LogType.Error)
            {
                _sb.Clear();

                _sb.AppendLine("```cs");
                _sb.AppendLine(logString);
                _sb.AppendLine("```");

                if (!string.IsNullOrEmpty(stackTrace))
                {
                    _sb.AppendLine("```cs");
                    _sb.AppendLine(stackTrace);
                    _sb.AppendLine("```");
                }

                DiscordSendMessage(Lang(LangKeys.Event.Error, null, _sb), _configData.ErrorSettings.WebhookURL);
            }
        }

        public void HandleTeam(RelationshipManager.PlayerTeam team, TeamEventType teamEventType)
        {
            _sb.Clear();

            BasePlayer player = RelationshipManager.FindByID(team.teamLeader);

            if (!player.IsValid())
            {
                return;
            }

            _sb.AppendLine("```cs");
            _sb.AppendLine();
            _sb.Append("TeamID: ");
            _sb.Append(team.teamID);
            _sb.AppendLine();
            _sb.Append("TeamLeader: ");
            _sb.Append(player.userID);
            _sb.Append(" (");
            _sb.Append(player.displayName);
            _sb.Append(")");
            if (team.members.Count > 0)
            {
                _sb.AppendLine();
                _sb.Append("Members:");
            }

            foreach (ulong userID in team.members)
            {
                player = RelationshipManager.FindByID(userID);

                if (!player.IsValid())
                {
                    continue;
                }

                _sb.AppendLine();
                _sb.Append(player.userID);
                _sb.Append(" (");
                _sb.Append(player.displayName);
                _sb.Append(")");
            }

            _sb.AppendLine("```");

            string eventType = string.Empty;

            switch (teamEventType)
            {
                case TeamEventType.Created:
                    eventType = Lang(LangKeys.Format.Created);
                    break;
                case TeamEventType.Disbanded:
                    eventType = Lang(LangKeys.Format.Disbanded);
                    break;
                case TeamEventType.Updated:
                    eventType = Lang(LangKeys.Format.Updated);
                    break;
            }

            LogToConsole($"Team was {eventType}\n{_sb.ToString()}");

            DiscordSendMessage(Lang(LangKeys.Event.Team, null, eventType, _sb.ToString()), _configData.TeamsSettings.WebhookURL);
        }

        public void CacheOilRigsLocation()
        {
            foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
            {
                if (!monument.shouldDisplayOnMap)
                {
                    continue;
                }

                switch (monument.displayPhrase.english)
                {
                    case "Large Oil Rig":
                        _locationLargeOilRig = monument.transform.position;
                        break;
                    case "Oil Rig":
                        _locationOilRig = monument.transform.position;
                        break;
                }
            }
        }

        public string GetHackableLockedCratePosition(Vector3 position)
        {
            if (Vector3.Distance(position, _locationOilRig) < 51f)
            {
                return Lang(LangKeys.Format.OilRig);
            }

            if (Vector3.Distance(position, _locationLargeOilRig) < 51f)
            {
                return Lang(LangKeys.Format.LargeOilRig);
            }

            try
            {
                foreach (KeyValuePair<ulong, CargoShip> cargoShip in _cargoShips)
                {
                    if (!cargoShip.Value.IsValid() || cargoShip.Value.IsDestroyed)
                    {
                        _listBadCargoShips.Add(cargoShip.Key);
                        continue;
                    }

                    if (Vector3.Distance(position, cargoShip.Value.transform.position) < 85f)
                    {
                        return Lang(LangKeys.Format.CargoShip);
                    }
                }
            }
            finally
            {
                for (int i = 0; i < _listBadCargoShips.Count; i++)
                {
                    _cargoShips.Remove(_listBadCargoShips[i]);
                }
                _listBadCargoShips.Clear();
            }

            return GetGridPosition(position);
        }

        private void DiscordSendMessage(string message, string webhookUrl, bool stripTags = false)
        {
            webhookUrl = GetWebhookURL(webhookUrl);

            if (string.IsNullOrWhiteSpace(webhookUrl))
            {
                PrintError("DiscordSendMessage: webhookUrl is null or empty!");
                return;
            }

            if (stripTags)
            {
                message = StripRustTags(message);
            }

            if (string.IsNullOrWhiteSpace(message))
            {
                PrintError("DiscordSendMessage: message is null or empty!");
                return;
            }

            _queue.Enqueue(new() {
                Message = message,
                WebhookUrl = webhookUrl
            });

            HandleQueue();
        }

        #endregion Core Methods

        #region Helpers

        public void UnsubscribeHooks()
        {
            Unsubscribe(nameof(OnAdminHammerDisabled));
            Unsubscribe(nameof(OnAdminHammerEnabled));
            Unsubscribe(nameof(OnBetterChatMuted));
            Unsubscribe(nameof(OnBetterChatMuteExpired));
            Unsubscribe(nameof(OnBetterChatTimeMuted));
            Unsubscribe(nameof(OnBetterChatUnmuted));
            Unsubscribe(nameof(OnClanCreate));
            Unsubscribe(nameof(OnClanDisbanded));
            Unsubscribe(nameof(OnDangerousEventEnded));
            Unsubscribe(nameof(OnDangerousEventStarted));
            Unsubscribe(nameof(OnDeathNotice));
            Unsubscribe(nameof(OnDuelistDefeated));
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(OnEntityKill));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnExplosiveDropped));
            Unsubscribe(nameof(OnExplosiveThrown));
            Unsubscribe(nameof(OnGodmodeToggled));
            Unsubscribe(nameof(OnGroupCreated));
            Unsubscribe(nameof(OnGroupDeleted));
            Unsubscribe(nameof(OnKitRedeemed));
            Unsubscribe(nameof(OnPlayerChat));
            Unsubscribe(nameof(OnPlayerConnected));
            Unsubscribe(nameof(OnPlayerDisconnected));
            Unsubscribe(nameof(OnPlayerRespawned));
            Unsubscribe(nameof(OnPlayerTeleported));
            Unsubscribe(nameof(OnPMProcessed));
            Unsubscribe(nameof(OnRadarActivated));
            Unsubscribe(nameof(OnRadarDeactivated));
            Unsubscribe(nameof(OnRaidableBaseCompleted));
            Unsubscribe(nameof(OnRaidableBaseEnded));
            Unsubscribe(nameof(OnRaidableBaseStarted));
            Unsubscribe(nameof(OnRconCommand));
            Unsubscribe(nameof(OnRconConnection));
            Unsubscribe(nameof(OnServerMessage));
            Unsubscribe(nameof(OnSupplyDropLanded));
            Unsubscribe(nameof(OnTeamAcceptInvite));
            Unsubscribe(nameof(OnTeamCreated));
            Unsubscribe(nameof(OnTeamDisbanded));
            Unsubscribe(nameof(OnTeamKick));
            Unsubscribe(nameof(OnTeamLeave));
            Unsubscribe(nameof(OnTeamPromote));
            Unsubscribe(nameof(OnTeamUpdated));
            Unsubscribe(nameof(OnTimedGroupAdded));
            Unsubscribe(nameof(OnTimedGroupExtended));
            Unsubscribe(nameof(OnTimedPermissionExtended));
            Unsubscribe(nameof(OnTimedPermissionGranted));
            Unsubscribe(nameof(OnUserBanned));
            Unsubscribe(nameof(OnUserGroupAdded));
            Unsubscribe(nameof(OnUserGroupRemoved));
            Unsubscribe(nameof(OnUserKicked));
            Unsubscribe(nameof(OnUserNameUpdated));
            Unsubscribe(nameof(OnUserPermissionGranted));
            Unsubscribe(nameof(OnUserPermissionRevoked));
            Unsubscribe(nameof(OnUserUnbanned));
            Unsubscribe(nameof(OnVanishDisappear));
            Unsubscribe(nameof(OnVanishReappear));
        }

        public void SubscribeHooks()
        {
            if (_configData.AdminHammerSettings.Enabled)
            {
                Subscribe(nameof(OnAdminHammerDisabled));
                Subscribe(nameof(OnAdminHammerEnabled));
            }

            if (_configData.UserMutedSettings.Enabled)
            {
                Subscribe(nameof(OnBetterChatMuted));
                Subscribe(nameof(OnBetterChatMuteExpired));
                Subscribe(nameof(OnBetterChatTimeMuted));
                Subscribe(nameof(OnBetterChatUnmuted));
            }

            if (_configData.ClanSettings.Enabled)
            {
                Subscribe(nameof(OnClanCreate));
                Subscribe(nameof(OnClanDisbanded));
            }

            if (_configData.DangerousTreasuresSettings.Enabled)
            {
                Subscribe(nameof(OnDangerousEventEnded));
                Subscribe(nameof(OnDangerousEventStarted));
            }

            if (_configData.PlayerDeathNotesSettings.Enabled)
            {
                Subscribe(nameof(OnDeathNotice));
            }

            if (_configData.DuelSettings.Enabled)
            {
                Subscribe(nameof(OnDuelistDefeated));
            }

            if (_configData.PlayerDeathSettings.Enabled)
            {
                Subscribe(nameof(OnEntityDeath));
            }

            if (_configData.EasterSettings.Enabled
             || _configData.HalloweenSettings.Enabled
             || _configData.LockedCrateSettings.Enabled)
            {
                Subscribe(nameof(OnEntityKill));
            }

            if (_configData.BradleySettings.Enabled
             || _configData.CargoPlaneSettings.Enabled
             || _configData.CargoShipSettings.Enabled
             || _configData.ChinookSettings.Enabled
             || _configData.ChristmasSettings.Enabled
             || _configData.EasterSettings.Enabled
             || _configData.HalloweenSettings.Enabled
             || _configData.HelicopterSettings.Enabled
             || _configData.LockedCrateSettings.Enabled
             || _configData.SantaSleighSettings.Enabled
             || _configData.SupplyDropSettings.Enabled)
            {
                Subscribe(nameof(OnEntitySpawned));
            }

            if (_configData.SupplyDropSettings.Enabled)
            {
                Subscribe(nameof(OnExplosiveDropped));
                Subscribe(nameof(OnExplosiveThrown));
                Subscribe(nameof(OnSupplyDropLanded));
            }

            if (_configData.GodmodeSettings.Enabled)
            {
                Subscribe(nameof(OnGodmodeToggled));
            }

            if (_configData.RustKitsSettings.Enabled)
            {
                Subscribe(nameof(OnKitRedeemed));
            }

            if (_configData.PermissionsSettings.Enabled)
            {
                Subscribe(nameof(OnGroupCreated));
                Subscribe(nameof(OnGroupDeleted));
                Subscribe(nameof(OnTimedGroupAdded));
                Subscribe(nameof(OnTimedGroupExtended));
                Subscribe(nameof(OnTimedPermissionExtended));
                Subscribe(nameof(OnTimedPermissionGranted));
                Subscribe(nameof(OnUserGroupAdded));
                Subscribe(nameof(OnUserGroupRemoved));
                Subscribe(nameof(OnUserPermissionGranted));
                Subscribe(nameof(OnUserPermissionRevoked));
            }

            if (_configData.PlayerConnectedSettings.Enabled
             || _configData.PlayerConnectedInfoSettings.Enabled)
            {
                Subscribe(nameof(OnPlayerConnected));
            }

            if (_configData.ChatSettings.Enabled
             || _configData.ChatTeamSettings.Enabled)
            {
                Subscribe(nameof(OnPlayerChat));
            }

            if (_configData.PlayerDisconnectedSettings.Enabled)
            {
                Subscribe(nameof(OnPlayerDisconnected));
            }

            if (_configData.PlayerRespawnedSettings.Enabled)
            {
                Subscribe(nameof(OnPlayerRespawned));
            }

            if (_configData.NTeleportationSettings.Enabled)
            {
                Subscribe(nameof(OnPlayerTeleported));
            }

            if (_configData.PrivateMessagesSettings.Enabled)
            {
                Subscribe(nameof(OnPMProcessed));
            }

            if (_configData.AdminRadarSettings.Enabled)
            {
                Subscribe(nameof(OnRadarActivated));
                Subscribe(nameof(OnRadarDeactivated));
            }

            if (_configData.RaidableBasesSettings.Enabled)
            {
                Subscribe(nameof(OnRaidableBaseCompleted));
                Subscribe(nameof(OnRaidableBaseEnded));
                Subscribe(nameof(OnRaidableBaseStarted));
            }

            if (_configData.RconCommandSettings.Enabled)
            {
                Subscribe(nameof(OnRconCommand));
            }

            if (_configData.RconConnectionSettings.Enabled)
            {
                Subscribe(nameof(OnRconConnection));
            }

            if (_configData.ServerMessagesSettings.Enabled)
            {
                Subscribe(nameof(OnServerMessage));
            }

            if (_configData.UserBannedSettings.Enabled)
            {
                Subscribe(nameof(OnUserBanned));
                Subscribe(nameof(OnUserUnbanned));
            }

            if (_configData.UserKickedSettings.Enabled)
            {
                Subscribe(nameof(OnUserKicked));
            }

            if (_configData.UserNameUpdateSettings.Enabled)
            {
                Subscribe(nameof(OnUserNameUpdated));
            }

            if (_configData.VanishSettings.Enabled)
            {
                Subscribe(nameof(OnVanishDisappear));
                Subscribe(nameof(OnVanishReappear));
            }

            if (_configData.ErrorSettings.Enabled)
            {
                Application.logMessageReceivedThreaded += HandleLog;
            }

            if (_configData.TeamsSettings.Enabled)
            {
                Subscribe(nameof(OnTeamAcceptInvite));
                Subscribe(nameof(OnTeamCreated));
                Subscribe(nameof(OnTeamDisbanded));
                Subscribe(nameof(OnTeamKick));
                Subscribe(nameof(OnTeamLeave));
                Subscribe(nameof(OnTeamPromote));
                Subscribe(nameof(OnTeamUpdated));
            }
        }

        public string StripRustTags(string text)
        {
            if (string.IsNullOrEmpty(text))
            {
                return string.Empty;
            }

            foreach (string tag in _tags)
            {
                text = text.Replace(tag, _configData.GlobalSettings.TagsReplacement);
            }

            foreach (Regex regexTag in _regexTags)
            {
                text = regexTag.Replace(text, _configData.GlobalSettings.TagsReplacement);
            }

            return text;
        }

        public string GetWebhookURL(string url)
        {
            if (string.IsNullOrEmpty(url))
            {
                return _configData.GlobalSettings.DefaultWebhookURL;
            }

            return url;
        }

        public string GetGridPosition(Vector3 position) => MapHelper.PositionToString(position);

        public string GetFormattedDurationTime(TimeSpan time, string id = null)
        {
            _sb.Clear();

            if (time.Days > 0)
            {
                BuildTime(_sb, time.Days == 1 ? LangKeys.Format.Day : LangKeys.Format.Days, id, time.Days);
            }

            if (time.Hours > 0)
            {
                BuildTime(_sb, time.Hours == 1 ? LangKeys.Format.Hour : LangKeys.Format.Hours, id, time.Hours);
            }

            if (time.Minutes > 0)
            {
                BuildTime(_sb, time.Minutes == 1 ? LangKeys.Format.Minute : LangKeys.Format.Minutes, id, time.Minutes);
            }

            BuildTime(_sb, time.Seconds == 1 ? LangKeys.Format.Second : LangKeys.Format.Seconds, id, time.Seconds);

            return _sb.ToString();
        }

        public void BuildTime(StringBuilder sb, string lang, string playerID, int value)
        {
            sb.Append(_configData.GlobalSettings.TagsReplacement);
            sb.Append(value);
            sb.Append(_configData.GlobalSettings.TagsReplacement);
            sb.Append(" ");
            sb.Append(Lang(lang, playerID));
            sb.Append(" ");
        }

        public bool IsPluginLoaded(Plugin plugin) => plugin != null && plugin.IsLoaded;

        public void LogToConsole(string text)
        {
            if (_configData.GlobalSettings.LoggingEnabled)
            {
                Puts(text);
            }
        }

        #endregion Helpers

        #region Discord Embed

        #region Send Embed Methods
        /// <summary>
        /// Headers when sending an embeded message
        /// </summary>
        private readonly Dictionary<string, string> _headers = new()
        {
            {"Content-Type", "application/json"}
        };

        /// <summary>
        /// Sends the DiscordMessage to the specified webhook url
        /// </summary>
        /// <param name="url">Webhook url</param>
        /// <param name="message">Message being sent</param>
        public void DiscordSendMessage(string url, DiscordMessage message)
        {
            webrequest.Enqueue(url, message.ToJson(), DiscordSendMessageCallback, this, RequestMethod.POST, _headers);
        }

        /// <summary>
        /// Callback when sending the embed if any errors occured
        /// </summary>
        /// <param name="code">HTTP response code</param>
        /// <param name="message">Response message</param>
        public void DiscordSendMessageCallback(int code, string message)
        {
            switch (code)
            {
                case 204:
                    _retryCount = 0;
                    QueueCooldownDisable();
                    return;
                case 401:
                    Dictionary<string, object> objectJson = JsonConvert.DeserializeObject<Dictionary<string, object>>(message);
                    int messageCode = 0;
                    if (objectJson["code"] != null && int.TryParse(objectJson["code"].ToString(), out messageCode))
                    {
                        if (messageCode == 50027)
                        {
                            PrintError($"Invalid Webhook Token: '{_queuedMessage.WebhookUrl}'");
                            return;
                        }
                    }
                    break;
                case 404:
                    PrintError($"Invalid Webhook (404: Not Found): '{_queuedMessage.WebhookUrl}'");
                    return;
                case 405:
                    PrintError($"Invalid Webhook (405: Method Not Allowed): '{_queuedMessage.WebhookUrl}'");
                    return;
                case 429:
                    message = "You are being rate limited. To avoid this try to increase queue interval in your config file.";
                    break;
                case 500:
                    message = "There are some issues with Discord server (500 Internal Server Error)";
                    break;
                case 502:
                    message = "There are some issues with Discord server (502 Bad Gateway)";
                    break;
                default:
                    message = $"DiscordSendMessageCallback: code = {code} message = {message}";
                    break;
            }

            _retryCount++;
            PrintError(message);
        }
        #endregion Send Embed Methods

        #region Embed Classes

        public class DiscordMessage
        {
            /// <summary>
            /// String only content to be sent
            /// </summary>
            [JsonProperty("content")]
            private string Content { get; set; }

            public DiscordMessage(string content)
            {
                Content = content;
            }

            /// <summary>
            /// Adds string content to the message
            /// </summary>
            /// <param name="content"></param>
            /// <returns></returns>
            public DiscordMessage AddContent(string content)
            {
                Content = content;
                return this;
            }

            /// <summary>
            /// Returns string content of the message
            /// </summary>
            /// <param name="content"></param>
            /// <returns></returns>
            public string GetContent()
            {
                return Content;
            }

            /// <summary>
            /// Returns message as JSON to be sent in the web request
            /// </summary>
            /// <returns></returns>
            public string ToJson() => JsonConvert.SerializeObject(this, Formatting.None,
                new JsonSerializerSettings {NullValueHandling = NullValueHandling.Ignore});
        }
        #endregion Embed Classes

        #endregion Discord Embed
    }
}

// --- End of file: DiscordLogger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/death-history ---
// --- Original File Path: D/DeathHistory/DeathHistory.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Death History", "MadKingCraig", "1.2.1")]
    [Description("Get the locations of previous deaths.")]
    class DeathHistory : RustPlugin
	{
        #region Fields

        private const string CanUsePermission = "deathhistory.use";
        private const string AdminPermission = "deathhistory.admin";

        private PluginConfiguration _configuration;
        private DynamicConfigFile _data;

        DeathHistoryData dhData;

        private Dictionary<string, List<List<float>>> _deaths = new Dictionary<string, List<List<float>>>();
        private float _worldSize = (ConVar.Server.worldsize);
        private bool _newSaveDetected;

        #endregion

        #region Commands

        [Command("deaths")]
        private void CommandDeaths(IPlayer user, string command, string[] args)
        {
            if (args.Length > 1 || user.IsServer)
                return;

            var player = user.Object as BasePlayer;

            if (!permission.UserHasPermission(player.UserIDString, CanUsePermission))
            {
                user.Reply(lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                if (_deaths.ContainsKey(player.UserIDString))
                {
                    List<string> deathLocations = SendCorpseLocations(player);
                    if (deathLocations.Count > _configuration.MaxNumberOfDeaths)
                        deathLocations.RemoveRange(0, (deathLocations.Count - _configuration.MaxNumberOfDeaths));
                    string order = "Oldest Death";
                    if (!_configuration.OldestFirst)
                    {
                        deathLocations.Reverse();
                        order = "Most Recent Death";
                    }
                    string message = string.Join("\n", deathLocations);
                    user.Reply(string.Format(lang.GetMessage("DeathLocation", this, player.UserIDString), player.displayName, order, message));
                }
                else
                    user.Reply(string.Format(lang.GetMessage("UnknownLocation", this, player.UserIDString), player.displayName));
                return;
            }

            if (args.Length >= 1 && !permission.UserHasPermission(player.UserIDString, AdminPermission))
            {
                user.Reply(lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }

            if (args[0] == "wipe_data")
            {
                NewData();
                user.Reply(string.Format(lang.GetMessage("DataWiped", this, player.UserIDString)));
                return;
            }

            var target = BasePlayer.FindAwakeOrSleeping(args[0]);
            if (target == null)
            {
                user.Reply(string.Format(lang.GetMessage("PlayerNotFound", this, player.UserIDString), args[0]));
                return;
            }

            if (_deaths.ContainsKey(target.UserIDString))
            {
                List<string> deathLocations = SendCorpseLocations(target);
                if (deathLocations.Count > _configuration.MaxNumberOfDeaths)
                    deathLocations.RemoveRange(0, (deathLocations.Count - _configuration.MaxNumberOfDeaths));
                string order = "Oldest Death";
                if (!_configuration.OldestFirst)
                {
                    deathLocations.Reverse();
                    order = "Most Recent Death";
                }
                string message = string.Join("\n", deathLocations);
                user.Reply(string.Format(lang.GetMessage("DeathLocation", this, player.UserIDString), target.displayName, order, message));
            }
            else
                user.Reply(string.Format(lang.GetMessage("UnknownLocation", this, player.UserIDString), target.displayName));
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(CanUsePermission, this);
            permission.RegisterPermission(AdminPermission, this);
        }

        private void Loaded()
        {
            _data = Interface.Oxide.DataFileSystem.GetFile("death_history_data");
        }

        private void OnServerInitialized()
        {
            try
            {
                _configuration = Config.ReadObject<PluginConfiguration>();
                Config.WriteObject(_configuration);
            }
            catch
            {
                Puts("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
            

            AddCovalenceCommand("deaths", nameof(CommandDeaths));

            LoadData();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["DeathLocation"] = "{0}'s Death Locations ({1} First)\n{2}",
                ["UnknownLocation"] = "{0}'s last death location is unknown.",
                ["NoPermission"] = "You do not have permission to use this command.",
                ["PlayerNotFound"] = "{0} not found.",
                ["DataWiped"] = "Data has been wiped."
            }, this);
        }

        private void OnNewSave(string filename)
        {
            _newSaveDetected = true;
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null) return;

            if (entity.gameObject == null) return;

            var player = entity as BasePlayer;

            if (player == null || entity.IsNpc || !player.userID.IsSteamId()) return;

            string userID = player.UserIDString;
            Vector3 deathPosition = entity.transform.position;
            List<float> shortDeathPosition = new List<float> { deathPosition.x, deathPosition.y, deathPosition.z };

            if (!_deaths.ContainsKey(userID))
                _deaths.Add(userID, new List<List<float>>());

            if (_deaths[userID].Count >= _configuration.MaxNumberOfDeaths)
                _deaths[userID].RemoveRange(0, (_deaths[userID].Count - _configuration.MaxNumberOfDeaths) + 1);

            _deaths[userID].Add(shortDeathPosition);

            SaveData();
        }

        #endregion

        #region Configuration

        protected override void LoadDefaultConfig() => _configuration = new PluginConfiguration();

        private sealed class PluginConfiguration
        {
            [JsonProperty(PropertyName = "Number of Deaths to Keep")]
            public int MaxNumberOfDeaths = 5;
            [JsonProperty(PropertyName = "Oldest Death First (false = Most Recent Death First)")]
            public bool OldestFirst = true;
            [JsonProperty(PropertyName = "Display Grid (false = Coordinates)")]
            public bool DisplayGrid = true;
        }

        #endregion

        #region Functions

        private string CalculateGridPosition(Vector3 position)
        {
            int maxGridSize = Mathf.FloorToInt(World.Size / 146.3f) - 1;
            int xGrid = Mathf.Clamp(Mathf.FloorToInt((position.x + (World.Size / 2f)) / 146.3f), 0, maxGridSize);
            string extraA = string.Empty;
            if (xGrid > 26) extraA = $"{(char)('A' + (xGrid / 26 - 1))}";
            return $"{extraA}{(char)('A' + xGrid % 26)}{Mathf.Clamp(maxGridSize - Mathf.FloorToInt((position.z + (World.Size / 2f)) / 146.3f), 0, maxGridSize).ToString()}";
        }

        private List<string> GetGrids(List<Vector3> deathLocations)
        {
            List<string> deathGrids = new List<string>();
            
            foreach (var location in deathLocations)
            {
                deathGrids.Add(CalculateGridPosition(location));
            }
            
            return deathGrids;
        }

        private List<string> GetCoordinates(List<Vector3> deathLocations)
        {
            List<string> deathGrids = new List<string>();

            foreach (var location in deathLocations)
            {
                deathGrids.Add($"({Mathf.Round(location[0])}, {Mathf.Round(location[1])}, {Mathf.Round(location[2])})");
            }

            return deathGrids;
        }

        private List<string> SendCorpseLocations(BasePlayer player)
        {
            List<List<float>> shortDeathLocations = _deaths[player.UserIDString];
            List<Vector3> allDeathLocations = new List<Vector3>();
            foreach (var location in shortDeathLocations)
            {
                allDeathLocations.Add(new Vector3(location[0], location[1], location[2]));
            }

            return _configuration.DisplayGrid ? GetGrids(allDeathLocations) : GetCoordinates(allDeathLocations);
        }

        #endregion

        #region Data Management

        private void SaveData()
        {
            dhData.Deaths = _deaths;
            _data.WriteObject(dhData);
        }

        private void LoadData()
        {
            try
            {
                if (_newSaveDetected)
                {
                    dhData = new DeathHistoryData();
                    _deaths = new Dictionary<string, List<List<float>>>();
                }
                else
                {
                    dhData = _data.ReadObject<DeathHistoryData>();
                    _deaths = dhData.Deaths;
                }
            }
            catch
            {
                dhData = new DeathHistoryData();
            }
        }

        private void NewData()
        {
            dhData = new DeathHistoryData();
            _deaths = new Dictionary<string, List<List<float>>>();
        }

        public class DeathHistoryData
        {
            public Dictionary<string, List<List<float>>> Deaths = new Dictionary<string, List<List<float>>>();
        }

        #endregion
    }
}


// --- End of file: DeathHistory.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dont-target-me ---
// --- Original File Path: D/DontTargetMe/DontTargetMe.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Don't Target Me", "Quantum/Arainrr", "1.1.4")]
    [Description("Makes turrets, player npcs and normal npcs ignore you.")]
    public class DontTargetMe : RustPlugin
    {
        #region Fields

        private const string PERMISSION_ALL = "donttargetme.all";
        private const string PERMISSION_NPC = "donttargetme.npc";
        private const string PERMISSION_APC = "donttargetme.apc";
        private const string PERMISSION_SAM = "donttargetme.sam";
        private const string PERMISSION_HELI = "donttargetme.heli";
        private const string PERMISSION_TURRETS = "donttargetme.turrets";
        private const string PERMISSION_HBHF = "donttargetme.hbhf";

        //Reduce boxing
        private static object True, False;

        private readonly Dictionary<ulong, TargetFlags> playerFlags = new Dictionary<ulong, TargetFlags>();

        [Flags]
        private enum TargetFlags
        {
            None = 0,
            Npc = 1,
            Sam = 1 << 1,
            Turret = 1 << 2,
            Bradley = 1 << 3,
            Helicopter = 1 << 4,
            HBHF = 1 << 5,
        }

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            True = true;
            False = false;
            permission.RegisterPermission(PERMISSION_ALL, this);
            permission.RegisterPermission(PERMISSION_NPC, this);
            permission.RegisterPermission(PERMISSION_APC, this);
            permission.RegisterPermission(PERMISSION_SAM, this);
            permission.RegisterPermission(PERMISSION_HELI, this);
            permission.RegisterPermission(PERMISSION_TURRETS, this);
            permission.RegisterPermission(PERMISSION_HBHF, this);

            cmd.AddChatCommand(configData.chatS.command, this, nameof(CmdToggle));
        }

        private void OnServerInitialized()
        {
            if (!configData.disableWhenDis)
            {
                Unsubscribe(nameof(OnPlayerDisconnected));
            }
            if (!configData.enableWhenCon)
            {
                Unsubscribe(nameof(OnPlayerConnected));
            }
            foreach (var player in BasePlayer.activePlayerList)
            {
                PlayerFlagsInit(player);
            }
            CheckHooks();
        }

        private void Unload()
        {
            True = False = null;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId()) return;
            if (PlayerFlagsInit(player))
            {
                CheckHooks();
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (player == null || !player.userID.IsSteamId()) return;
            if (playerFlags.Remove(player.userID))
            {
                CheckHooks();
            }
        }

        private object CanBeTargeted(BasePlayer player, MonoBehaviour behaviour) => HasTargetFlags(player, TargetFlags.Turret) ? False : null;

        private object OnNpcTarget(BaseEntity npc, BasePlayer player) => HasTargetFlags(player, TargetFlags.Npc) ? True : null;

        private object CanBradleyApcTarget(BradleyAPC apc, BasePlayer player) => HasTargetFlags(player, TargetFlags.Bradley) ? False : null;

        private object CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer player) => HasTargetFlags(player, TargetFlags.Helicopter) ? False : null;

        private object CanHelicopterStrafeTarget(PatrolHelicopterAI heli, BasePlayer player) => HasTargetFlags(player, TargetFlags.Helicopter) ? False : null;

        private object OnSamSiteTarget(SamSite samSite, BaseCombatEntity baseCombatEntity) => AnyHasTargetFlags(baseCombatEntity, TargetFlags.Sam) ? False : null;

        private object OnSensorDetect(HBHFSensor hbhf, BasePlayer player) => HasTargetFlags(player, TargetFlags.HBHF) ? False : null;

        #endregion Oxide Hooks

        #region Methods

        private bool AnyHasTargetFlags(BaseCombatEntity baseCombatEntity, TargetFlags flag)
        {
            var baseVehicle = baseCombatEntity as BaseVehicle;
            if (baseVehicle != null)
            {
                var mountedPlayers = GetMountedPlayers(baseVehicle);
                foreach (var mountedPlayer in mountedPlayers)
                {
                    if (HasTargetFlags(mountedPlayer, flag))
                    {
                        return true;
                    }
                }
                return false;
            }
            var children = baseCombatEntity.GetComponentsInChildren<BasePlayer>();
            if (children != null && children.Length > 0)
            {
                foreach (var child in children)
                {
                    if (HasTargetFlags(child, flag))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        private static IEnumerable<BasePlayer> GetMountedPlayers(BaseVehicle baseVehicle)
        {
            if (!baseVehicle.HasMountPoints())
            {
                var mountedPlayer = baseVehicle.GetMounted();
                if (mountedPlayer != null)
                {
                    yield return mountedPlayer;
                }
            }

            foreach (var mountPointInfo in baseVehicle.mountPoints)
            {
                if (mountPointInfo.mountable != null)
                {
                    var mountedPlayer = mountPointInfo.mountable.GetMounted();
                    if (mountedPlayer != null)
                    {
                        yield return mountedPlayer;
                    }
                }
            }
        }

        private bool HasTargetFlags(BasePlayer player, TargetFlags flag)
        {
            if (player == null || !player.userID.IsSteamId()) return false;
            TargetFlags flags;
            if (playerFlags.TryGetValue(player.userID, out flags))
            {
                return flags.HasFlag(flag);
            }
            return false;
        }

        private bool PlayerFlagsInit(BasePlayer player)
        {
            playerFlags.Remove(player.userID);
            TargetFlags flags = TargetFlags.None;
            if (permission.UserHasPermission(player.UserIDString, PERMISSION_ALL))
            {
                foreach (TargetFlags flag in Enum.GetValues(typeof(TargetFlags)))
                    flags |= flag;
            }
            else
            {
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_TURRETS))
                    flags |= TargetFlags.Turret;
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_APC))
                    flags |= TargetFlags.Bradley;
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_NPC))
                    flags |= TargetFlags.Npc;
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_SAM))
                    flags |= TargetFlags.Sam;
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_HELI))
                    flags |= TargetFlags.Helicopter;
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_HBHF))
                    flags |= TargetFlags.HBHF;
            }
            if (flags != TargetFlags.None)
            {
                playerFlags.Add(player.userID, flags);
                return true;
            }
            return false;
        }

        private void CheckHooks()
        {
            if (playerFlags.Count <= 0)
            {
                Unsubscribe(nameof(OnNpcTarget));
                Unsubscribe(nameof(CanBeTargeted));
                Unsubscribe(nameof(OnSamSiteTarget));
                Unsubscribe(nameof(CanBradleyApcTarget));
                Unsubscribe(nameof(CanHelicopterTarget));
                Unsubscribe(nameof(CanHelicopterStrafeTarget));
                Unsubscribe(nameof(OnSensorDetect));
                return;
            }

            bool turret = false, npc = false, apc = false, heli = false, sam = false, hbhf = false;
            foreach (var flags in playerFlags.Values)
            {
                if (flags.HasFlag(TargetFlags.Turret)) turret = true;
                if (flags.HasFlag(TargetFlags.Npc)) npc = true;
                if (flags.HasFlag(TargetFlags.Bradley)) apc = true;
                if (flags.HasFlag(TargetFlags.Helicopter)) heli = true;
                if (flags.HasFlag(TargetFlags.Sam)) sam = true;
                if (flags.HasFlag(TargetFlags.HBHF)) hbhf = true;
            }

            if (!turret) Unsubscribe(nameof(CanBeTargeted));
            else Subscribe(nameof(CanBeTargeted));

            if (!npc) Unsubscribe(nameof(OnNpcTarget));
            else Subscribe(nameof(OnNpcTarget));

            if (!apc) Unsubscribe(nameof(CanBradleyApcTarget));
            else Subscribe(nameof(CanBradleyApcTarget));

            if (!sam) Unsubscribe(nameof(OnSamSiteTarget));
            else Subscribe(nameof(OnSamSiteTarget));

            if (!heli)
            {
                Unsubscribe(nameof(CanHelicopterTarget));
                Unsubscribe(nameof(CanHelicopterStrafeTarget));
            }
            else
            {
                Subscribe(nameof(CanHelicopterTarget));
                Subscribe(nameof(CanHelicopterStrafeTarget));
            }

            if (!hbhf)
            {
                Unsubscribe(nameof(OnSensorDetect));
            }
            else
            {
                Subscribe(nameof(OnSensorDetect));
            }
        }

        #endregion Methods

        #region Commands

        private void CmdToggle(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (playerFlags.Remove(player.userID))
            {
                Print(player, Lang("Toggle", player.UserIDString, Lang("Disabled", player.UserIDString)));
            }
            else
            {
                if (PlayerFlagsInit(player))
                {
                    Print(player, Lang("Toggle", player.UserIDString, Lang("Enabled", player.UserIDString)));
                }
                else
                {
                    Print(player, Lang("NotAllowed", player.UserIDString));
                    return;
                }
            }
            CheckHooks();
        }

        #endregion Commands

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Disable when player disconnected")]
            public bool disableWhenDis = true;

            [JsonProperty(PropertyName = "Enable when player connected")]
            public bool enableWhenCon = false;

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings chatS = new ChatSettings();

            public class ChatSettings
            {
                [JsonProperty(PropertyName = "Chat Command")]
                public string command = "dtm";

                [JsonProperty(PropertyName = "Chat Prefix")]
                public string prefix = "<color=#00FFFF>[DontTargetMe]</color>: ";

                [JsonProperty(PropertyName = "Chat SteamID Icon")]
                public ulong steamIDIcon = 0;
            }

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber version;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
            configData.version = Version;
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        private void UpdateConfigValues()
        {
            if (configData.version < Version)
            {
                if (configData.version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat Settings", "Chat Prefix") && GetConfigValue(out prefixColor, "Chat Settings", "Chat Prefix Color"))
                    {
                        configData.chatS.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }
                }
                configData.version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue == null)
            {
                value = default(T);
                return false;
            }
            value = Config.ConvertValue<T>(configValue);
            return true;
        }

        #endregion ConfigurationFile

        #region LanguageFile

        private void Print(BasePlayer player, string message) => Player.Message(player, message, configData.chatS.prefix, configData.chatS.steamIDIcon);

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You do not have permission to use this command",
                ["Toggle"] = "Don't Target Me is {0}",
                ["Enabled"] = "<color=#8ee700>Enabled</color>",
                ["Disabled"] = "<color=#ce422b>Disabled</color>",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "您没有使用该命令的权限",
                ["Toggle"] = "不要瞄准我 {0}",
                ["Enabled"] = "<color=#8ee700>已启用</color>",
                ["Disabled"] = "<color=#ce422b>已禁用</color>",
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: DontTargetMe.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/drone-storage ---
// --- Original File Path: D/DroneStorage/DroneStorage.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Drone Storage", "WhiteThunder", "1.3.1")]
    [Description("Allows players to deploy a small stash to RC drones.")]
    internal class DroneStorage : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin DroneSettings;

        private Configuration _config;

        private const string PermissionDeploy = "dronestorage.deploy";
        private const string PermissionDeployFree = "dronestorage.deploy.free";
        private const string PermissionAutoDeploy = "dronestorage.autodeploy";
        private const string PermissionLockable = "dronestorage.lockable";
        private const string PermissionViewItems = "dronestorage.viewitems";
        private const string PermissionDropItems = "dronestorage.dropitems";
        private const string PermissionToggleLock = "dronestorage.togglelock";
        private const string PermissionCapacityPrefix = "dronestorage.capacity";

        // HAB storage is the best since it has an accurate collider, decent rendering distance and is a StorageContainer.
        private const string StoragePrefab = "assets/prefabs/deployable/hot air balloon/subents/hab_storage.prefab";
        private const string StorageDeployEffectPrefab = "assets/prefabs/deployable/small stash/effects/small-stash-deploy.prefab";
        private const string DropBagPrefab = "assets/prefabs/misc/item drop/item_drop.prefab";
        private const string LockEffectPrefab = "assets/prefabs/locks/keypad/effects/lock.code.lock.prefab";
        private const string UnlockEffectPrefab = "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab";

        private const int StashItemId = -369760990;

        private const BaseEntity.Slot StorageSlot = BaseEntity.Slot.UpperModifier;

        private const string ResizableLootPanelName = "generic_resizable";

        private static readonly Vector3 StorageLockPosition = new Vector3(0, 0, 0.21f);
        private static readonly Quaternion StorageLockRotation = Quaternion.Euler(0, 90, 0);

        private static readonly Vector3 StorageLocalPosition = new Vector3(0, 0.12f, 0);
        private static readonly Quaternion StorageLocalRotation = Quaternion.Euler(-90, 0, 0);

        private static readonly Vector3 StorageDropForwardLocation = new Vector3(0, 0, 0.7f);
        private static readonly Quaternion StorageDropRotation = Quaternion.Euler(90, 0, 0);

        private readonly object True = true;
        private readonly object False = false;

        private readonly Func<Item, int, bool> StashItemFilter;

        private readonly Dictionary<string, object> _removeInfo = new Dictionary<string, object>();
        private readonly Dictionary<string, object> _refundInfo = new Dictionary<string, object>
        {
            ["stash.small"] = new Dictionary<string, object>
            {
                ["Amount"] = 1,
            },
        };

        private readonly object[] NoteInvTakeOneArguments = { StashItemId, -1 };

        private readonly StorageCapacityManager _storageCapacityManager;
        private readonly DynamicHookHashSet<StorageContainer> _droneStorageTracker;
        private readonly DynamicHookHashSet<ulong> _remoteStashViewerTracker;
        private readonly HashSet<BasePlayer> _uiViewers = new HashSet<BasePlayer>();

        public DroneStorage()
        {
            StashItemFilter = CanStashAcceptItem;

            _storageCapacityManager = new StorageCapacityManager(this);

            _droneStorageTracker = new DynamicHookHashSet<StorageContainer>(this,
                nameof(OnEntityDeath),
                nameof(OnEntityTakeDamage),
                nameof(OnBookmarkControlStarted),
                nameof(OnBookmarkControlEnded),
                nameof(CanPickupEntity),
                nameof(OnItemDeployed)
            );

            _remoteStashViewerTracker = new DynamicHookHashSet<ulong>(this,
                nameof(CanMoveItem),
                nameof(OnItemAction)
            );
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionDeploy, this);
            permission.RegisterPermission(PermissionDeployFree, this);
            permission.RegisterPermission(PermissionAutoDeploy, this);
            permission.RegisterPermission(PermissionLockable, this);
            permission.RegisterPermission(PermissionViewItems, this);
            permission.RegisterPermission(PermissionDropItems, this);
            permission.RegisterPermission(PermissionToggleLock, this);

            _storageCapacityManager.Init();

            _droneStorageTracker.Unsubscribe();
            _remoteStashViewerTracker.Unsubscribe();
        }

        private void Unload()
        {
            foreach (var player in _uiViewers)
            {
                UI.DestroyForPlayer(player);
            }

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null || !IsDroneEligible(drone))
                    continue;

                var stash = GetDroneStorage(drone);
                if (stash == null)
                    continue;

                DroneStorageComponent.RemoveFromStorage(stash);
            }
        }

        private void OnServerInitialized()
        {
            foreach (var drone in BaseNetworkable.serverEntities.OfType<Drone>().ToArray())
            {
                if (!IsDroneEligible(drone))
                    continue;

                RefreshStorage(drone);
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                ComputerStation computerStation;
                var drone = RCUtils.GetControlledEntity<Drone>(player, out computerStation);
                if (drone == null)
                    continue;

                var storage = GetDroneStorage(drone);
                if (storage == null)
                    continue;

                if (storage.inventory != null && storage.inventory == player.inventory?.loot?.containers?.FirstOrDefault())
                {
                    _remoteStashViewerTracker.Add(player.userID);
                }

                OnBookmarkControlStarted(computerStation, player, string.Empty, drone);
            }
        }

        private void OnEntityBuilt(Planner planner, GameObject go)
        {
            if (planner == null || go == null)
                return;

            var drone = go.ToBaseEntity() as Drone;
            if (drone == null || !IsDroneEligible(drone))
                return;

            var player = planner.GetOwnerPlayer();
            if (player == null)
                return;

            var drone2 = drone;
            var player2 = player;

            NextTick(() =>
            {
                // Delay this check to allow time for other plugins to deploy an entity to this slot.
                if (drone2 == null || player2 == null || drone2.GetSlot(StorageSlot) != null)
                    return;

                var capacity = _storageCapacityManager.DetermineCapacityForUser(drone2.OwnerID);
                if (capacity <= 0)
                    return;

                if (permission.UserHasPermission(player2.UserIDString, PermissionAutoDeploy))
                {
                    TryDeployStorage(drone2, capacity);
                }
                else if (permission.UserHasPermission(player2.UserIDString, PermissionDeploy)
                    && UnityEngine.Random.Range(0, 100) < _config.TipChance)
                {
                    ChatMessage(player2, Lang.TipDeployCommand);
                }
            });
        }

        private void OnEntityDeath(Drone drone)
        {
            var storage = GetDroneStorage(drone);
            if (storage == null)
                return;

            DropItems(drone, storage);
        }

        private object OnEntityTakeDamage(StorageContainer storage, HitInfo info)
        {
            Drone drone;
            if (!IsDroneStorage(storage, out drone))
                return null;

            drone.Hurt(info);
            HitNotify(drone, info);

            return True;
        }

        private void OnBookmarkControlStarted(ComputerStation computerStation, BasePlayer player, string bookmarkName, Drone drone)
        {
            if (!RCUtils.HasController(drone, player))
                return;

            if (_uiViewers.Contains(player))
                return;

            var storage = GetDroneStorage(drone);
            if (storage == null)
                return;

            UI.CreateForPlayer(this, player, storage);
            _uiViewers.Add(player);
        }

        private void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, Drone drone)
        {
            if (!_uiViewers.Contains(player))
                return;

            UI.DestroyForPlayer(player);
            _uiViewers.Remove(player);

            if (_remoteStashViewerTracker.Contains(player.userID))
            {
                EndLooting(player);
            }
        }

        private object CanPickupEntity(BasePlayer player, Drone drone)
        {
            if (CanPickupInternal(player, drone))
                return null;

            ChatMessage(player, Lang.ErrorCannotPickupDroneWithItems);
            return False;
        }

        private void OnItemDeployed(Deployer deployer, StorageContainer storage, BaseLock baseLock)
        {
            if (!IsDroneStorage(storage))
                return;

            baseLock.transform.localPosition = StorageLockPosition;
            baseLock.transform.localRotation = StorageLockRotation;
            baseLock.SendNetworkUpdateImmediate();
        }

        // Prevent the drone controller from moving items while remotely viewing a drone stash.
        private object CanMoveItem(Item item, PlayerInventory playerInventory)
        {
            if (item.parent == null)
                return null;

            var player = playerInventory.baseEntity;
            if (player == null)
                return null;

            var drone = RCUtils.GetControlledEntity<Drone>(player);
            if (drone == null)
                return null;

            // For simplicity, block all item moves while the player is looting a drone stash.
            var storage = playerInventory.loot.entitySource as StorageContainer;
            if (storage != null && IsDroneStorage(storage))
                return False;

            return null;
        }

        // Prevent the drone controller from dropping items (or any item action) while remotely viewing a drone stash.
        private object OnItemAction(Item item, string text, BasePlayer player)
        {
            var drone = RCUtils.GetControlledEntity<Drone>(player);
            if (drone == null)
                return null;

            var storage = GetDroneStorage(drone);
            if (storage != null && storage == player.inventory.loot.entitySource)
                return False;

            return null;
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        private Dictionary<string, object> OnRemovableEntityInfo(StorageContainer storage, BasePlayer player)
        {
            if (!IsDroneStorage(storage))
                return null;

            _removeInfo["DisplayName"] = GetMessage(player, Lang.InfoStashName);

            if (storage.pickup.enabled)
            {
                _removeInfo["Refund"] = _refundInfo;
            }
            else
            {
                _removeInfo.Remove("Refund");
            }

            return _removeInfo;
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        private string canRemove(BasePlayer player, Drone drone)
        {
            if (CanPickupInternal(player, drone))
                return null;

            return GetMessage(player, Lang.ErrorCannotPickupDroneWithItems);
        }

        // This hook is exposed by plugin: Drone Settings (DroneSettings).
        private string OnDroneTypeDetermine(Drone drone)
        {
            return GetDroneStorage(drone) != null ? Name : null;
        }

        #endregion

        #region Commands

        [Command("dronestash")]
        private void DroneStashCommand(IPlayer player)
        {
            if (player.IsServer)
                return;

            if (!player.HasPermission(PermissionDeploy))
            {
                ReplyToPlayer(player, Lang.ErrorNoPermission);
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            var drone = GetLookEntity(basePlayer, 3) as Drone;
            if (drone == null || !IsDroneEligible(drone))
            {
                ReplyToPlayer(player, Lang.ErrorNoDroneFound);
                return;
            }

            if (!basePlayer.CanBuild() || !basePlayer.CanBuild(drone.WorldSpaceBounds()))
            {
                ReplyToPlayer(player, Lang.ErrorBuildingBlocked);
                return;
            }

            var allowedCapacity = _storageCapacityManager.DetermineCapacityForUser(basePlayer.userID);
            if (allowedCapacity <= 0)
            {
                ReplyToPlayer(player, Lang.ErrorNoPermission);
                return;
            }

            if (GetDroneStorage(drone) != null)
            {
                ReplyToPlayer(player, Lang.ErrorAlreadyHasStorage);
                return;
            }

            if (drone.GetSlot(StorageSlot) != null)
            {
                ReplyToPlayer(player, Lang.ErrorIncompatibleAttachment);
                return;
            }

            var isFree = player.HasPermission(PermissionDeployFree);
            if (!isFree && basePlayer.inventory.FindItemByItemID(StashItemId) == null)
            {
                ReplyToPlayer(player, Lang.ErrorNoStashItem);
                return;
            }

            if (TryDeployStorage(drone, allowedCapacity, allowRefund: !isFree, deployer: basePlayer) == null)
            {
                ReplyToPlayer(player, Lang.ErrorDeployFailed);
            }
            else if (!isFree)
            {
                basePlayer.inventory.Take(null, StashItemId, 1);
                basePlayer.Command("note.inv", NoteInvTakeOneArguments);
            }
        }

        [Command("dronestorage.ui.viewitems")]
        private void UICommandViewItems(IPlayer player)
        {
            BasePlayer basePlayer;
            Drone drone;
            StorageContainer storage;
            if (!TryGetControlledStorage(player, PermissionViewItems, out basePlayer, out drone, out storage)
                || !RCUtils.HasController(drone, basePlayer))
                return;

            if (basePlayer.inventory.loot.IsLooting() && basePlayer.inventory.loot.entitySource == storage)
            {
                EndLooting(basePlayer);
                return;
            }

            var baseLock = GetLock(storage);
            var isLocked = baseLock != null && baseLock.IsLocked();

            // Temporarily unlock the container so that the player can view the contents without authorization.
            if (isLocked)
            {
                baseLock.SetFlag(BaseEntity.Flags.Locked, false, recursive: false, networkupdate: false);
            }

            // Temporarily remove the stash owner, to bypass plugins such as PreventLooting.
            var ownerId = storage.OwnerID;
            storage.OwnerID = 0;
            if (storage.PlayerOpenLoot(basePlayer, storage.panelName, doPositionChecks: false))
            {
                _remoteStashViewerTracker.Add(basePlayer.userID);
            }

            storage.OwnerID = ownerId;

            if (isLocked)
            {
                baseLock.SetFlag(BaseEntity.Flags.Locked, true, recursive: false, networkupdate: false);
            }
        }

        [Command("dronestorage.ui.dropitems")]
        private void UICommandDropItems(IPlayer player)
        {
            BasePlayer basePlayer;
            Drone drone;
            StorageContainer storage;
            if (!TryGetControlledStorage(player, PermissionDropItems, out basePlayer, out drone, out storage)
                || !RCUtils.HasController(drone, basePlayer))
                return;

            DropItems(drone, storage, basePlayer);
        }

        [Command("dronestorage.ui.togglelock")]
        private void UICommandLockStorage(IPlayer player)
        {
            BasePlayer basePlayer;
            Drone drone;
            StorageContainer storage;
            if (!TryGetControlledStorage(player, PermissionToggleLock, out basePlayer, out drone, out storage)
                || !RCUtils.HasController(drone, basePlayer))
                return;

            if (!_uiViewers.Contains(basePlayer))
                return;

            var baseLock = GetLock(storage);
            if (baseLock == null)
                return;

            var wasLocked = baseLock.IsLocked();
            baseLock.SetFlag(BaseEntity.Flags.Locked, !wasLocked);
            Effect.server.Run(wasLocked ? UnlockEffectPrefab : LockEffectPrefab, baseLock, 0, Vector3.zero, Vector3.zero);
            UI.CreateForPlayer(this, basePlayer, storage);
        }

        #endregion

        #region UI

        private static class UI
        {
            private const string Name = "DroneStorage";

            private static float GetButtonOffsetX(DroneStorage plugin, int index, int totalButtons)
            {
                var buttonSettings = plugin._config.UISettings.Buttons;
                var panelWidth = buttonSettings.Width * totalButtons + buttonSettings.Spacing * (totalButtons - 1);
                var offsetXMin = -panelWidth / 2 + (buttonSettings.Width + buttonSettings.Spacing) * index;
                return offsetXMin;
            }

            public static void CreateForPlayer(DroneStorage plugin, BasePlayer player, StorageContainer storage)
            {
                var baseLock = GetLock(storage);

                var iPlayer = player.IPlayer;
                var showViewItemsButton = iPlayer.HasPermission(PermissionViewItems);
                var showDropItemsButton = iPlayer.HasPermission(PermissionDropItems);
                var showToggleLockButton = baseLock != null && iPlayer.HasPermission(PermissionToggleLock);

                var totalButtons = Convert.ToInt32(showViewItemsButton)
                    + Convert.ToInt32(showDropItemsButton)
                    + Convert.ToInt32(showToggleLockButton);

                if (totalButtons == 0)
                    return;

                var config = plugin._config;

                var cuiElements = new CuiElementContainer
                {
                    new CuiElement
                    {
                        Parent = "Overlay",
                        Name = Name,
                        DestroyUi = Name,
                        Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = config.UISettings.AnchorMin,
                                AnchorMax = config.UISettings.AnchorMax,
                                OffsetMin = config.UISettings.OffsetMin,
                                OffsetMax = config.UISettings.OffsetMax,
                            },
                        }
                    }
                };

                var currentButtonIndex = 0;
                var buttonSettings = config.UISettings.Buttons;

                if (showViewItemsButton)
                {
                    var offsetXMin = GetButtonOffsetX(plugin, currentButtonIndex++, totalButtons);

                    cuiElements.Add(
                        new CuiButton
                        {
                            Text =
                            {
                                Text = plugin.GetMessage(player.UserIDString, Lang.UIButtonViewItems),
                                Align = TextAnchor.MiddleCenter,
                                Color = buttonSettings.ViewButtonTextColor,
                                FontSize = buttonSettings.TextSize
                            },
                            Button =
                            {
                                Color = buttonSettings.ViewButtonColor,
                                Command = "dronestorage.ui.viewitems",
                            },
                            RectTransform =
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "0 0",
                                OffsetMin = $"{offsetXMin.ToString()} 0",
                                OffsetMax = $"{(offsetXMin + buttonSettings.Width).ToString()} {buttonSettings.Height.ToString()}"
                            }
                        },
                        Name
                    );
                }

                if (showDropItemsButton)
                {
                    var offsetXMin = GetButtonOffsetX(plugin, currentButtonIndex++, totalButtons);

                    cuiElements.Add(
                        new CuiButton
                        {
                            Text =
                            {
                                Text = plugin.GetMessage(player.UserIDString, Lang.UIButtonDropItems),
                                Align = TextAnchor.MiddleCenter,
                                Color = buttonSettings.DropButtonTextColor,
                                FontSize = buttonSettings.TextSize
                            },
                            Button =
                            {
                                Color = buttonSettings.DropButtonColor,
                                Command = "dronestorage.ui.dropitems",
                            },
                            RectTransform =
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "0 0",
                                OffsetMin = $"{offsetXMin.ToString()} 0",
                                OffsetMax = $"{(offsetXMin + buttonSettings.Width).ToString()} {buttonSettings.Height.ToString()}"
                            }
                        },
                        Name
                    );
                }

                if (showToggleLockButton)
                {
                    var isLocked = baseLock.IsLocked();
                    var offsetXMin = GetButtonOffsetX(plugin, currentButtonIndex++, totalButtons);

                    cuiElements.Add(new CuiButton
                    {
                        Text =
                        {
                            Text = plugin.GetMessage(player.UserIDString, isLocked ? Lang.UIButtonUnlockStorage : Lang.UIButtonLockStorage),
                            Align = TextAnchor.MiddleCenter,
                            Color = isLocked ? buttonSettings.UnlockButtonTextColor : buttonSettings.LockButtonTextColor,
                            FontSize = buttonSettings.TextSize
                        },
                        Button =
                        {
                            Color = isLocked ? buttonSettings.UnlockButtonColor : buttonSettings.LockButtonColor,
                            Command = "dronestorage.ui.togglelock",
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{offsetXMin.ToString()} 0",
                            OffsetMax = $"{(offsetXMin + buttonSettings.Width).ToString()} {buttonSettings.Height.ToString()}"
                        }
                    }, Name);
                }

                CuiHelper.AddUi(player, cuiElements);
            }

            public static void DestroyForPlayer(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, Name);
            }
        }

        #endregion

        #region Helpers

        private static class RCUtils
        {
            public static bool IsRCDrone(Drone drone)
            {
                return !(drone is DeliveryDrone);
            }

            public static bool HasController(IRemoteControllable controllable, BasePlayer player)
            {
                return controllable.ControllingViewerId?.SteamId == player.userID;
            }

            public static T GetControlledEntity<T>(BasePlayer player, out ComputerStation station) where T : class
            {
                station = player.GetMounted() as ComputerStation;
                if ((object)station == null)
                    return null;

                return station.currentlyControllingEnt.Get(serverside: true) as T;
            }

            public static T GetControlledEntity<T>(BasePlayer player) where T : class
            {
                ComputerStation station;
                return GetControlledEntity<T>(player, out station);
            }
        }

        private static bool DeployStorageWasBlocked(Drone drone, BasePlayer deployer)
        {
            var hookResult = Interface.CallHook("OnDroneStorageDeploy", drone, deployer);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool DropStorageWasBlocked(Drone drone, StorageContainer storage, BasePlayer pilot)
        {
            var hookResult = Interface.CallHook("OnDroneStorageDrop", drone, storage, pilot);
            return hookResult is bool && (bool)hookResult == false;
        }

        private void RefreshDroneSettingsProfile(Drone drone)
        {
            DroneSettings?.Call("API_RefreshDroneProfile", drone);
        }

        private static bool IsDroneEligible(Drone drone)
        {
            return drone.skinID == 0 && RCUtils.IsRCDrone(drone);
        }

        private static bool IsDroneStorage(StorageContainer storage, out Drone drone)
        {
            drone = storage.GetParentEntity() as Drone;
            if (drone == null)
                return false;

            return storage.PrefabName == StoragePrefab;
        }

        private static bool IsDroneStorage(StorageContainer storage)
        {
            Drone drone;
            return IsDroneStorage(storage, out drone);
        }

        private static bool CanPickupInternal(BasePlayer player, Drone drone)
        {
            if (!IsDroneEligible(drone))
                return true;

            var storage = GetDroneStorage(drone);
            if (storage == null)
                return true;

            // Prevent drone pickup while it has a non-empty storage (the storage must be emptied first).
            if (storage != null && !storage.inventory.IsEmpty())
                return false;

            return true;
        }

        private static StorageContainer GetDroneStorage(Drone drone)
        {
            return drone.GetSlot(StorageSlot) as StorageContainer;
        }

        private static BaseLock GetLock(StorageContainer storage)
        {
            return storage.GetSlot(BaseEntity.Slot.Lock) as BaseLock;
        }

        private static void HitNotify(BaseEntity entity, HitInfo info)
        {
            var player = info.Initiator as BasePlayer;
            if (player == null)
                return;

            entity.ClientRPCPlayer(null, player, "HitNotify");
        }

        private static void RemoveProblemComponents(BaseEntity ent)
        {
            foreach (var meshCollider in ent.GetComponentsInChildren<MeshCollider>())
            {
                UnityEngine.Object.DestroyImmediate(meshCollider);
            }

            UnityEngine.Object.DestroyImmediate(ent.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(ent.GetComponent<GroundWatch>());
        }

        private static void DropItems(Drone drone, StorageContainer storage, BasePlayer pilot = null)
        {
            var itemList = storage.inventory.itemList;
            if (itemList == null || itemList.Count <= 0)
                return;

            if (DropStorageWasBlocked(drone, storage, pilot))
                return;

            var dropPosition = pilot == null
                ? drone.transform.position
                : drone.transform.TransformPoint(StorageDropForwardLocation);

            if (pilot != null)
            {
                EndLooting(pilot);
            }

            Effect.server.Run(StorageDeployEffectPrefab, storage.transform.position);
            var dropContainer = storage.inventory.Drop(DropBagPrefab, dropPosition, storage.transform.rotation * StorageDropRotation, 0);
            Interface.Call("OnDroneStorageDropped", drone, storage, dropContainer, pilot);
        }

        private static BaseEntity GetLookEntity(BasePlayer basePlayer, float maxDistance = 3)
        {
            RaycastHit hit;
            return Physics.Raycast(basePlayer.eyes.HeadRay(), out hit, maxDistance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore)
                ? hit.GetEntity()
                : null;
        }

        private static void EndLooting(BasePlayer player)
        {
            player.EndLooting();

            // HACK: Send empty respawn information to fully close the player inventory (close the storage).
            player.ClientRPCPlayer(null, player, "OnRespawnInformation");
        }

        private bool CanStashAcceptItem(Item item, int position)
        {
            if (_config.DisallowedItems != null
                && _config.DisallowedItems.Contains(item.info.shortname))
                return false;

            if (item.skin != 0
                && _config.DisallowedSkins != null
                && _config.DisallowedSkins.Contains(item.skin))
                return false;

            return true;
        }

        private bool TryGetControlledStorage(IPlayer player, string perm, out BasePlayer basePlayer, out Drone drone, out StorageContainer storage)
        {
            basePlayer = null;
            drone = null;
            storage = null;

            if (player.IsServer || !player.HasPermission(perm))
                return false;

            basePlayer = player.Object as BasePlayer;
            drone = RCUtils.GetControlledEntity<Drone>(basePlayer);
            if (drone == null)
                return false;

            storage = GetDroneStorage(drone);
            return storage != null;
        }

        private void SetupDroneStorage(Drone drone, StorageContainer storage, int capacity)
        {
            if (!_config.AssignStorageOwnership)
            {
                storage.OwnerID = 0;
            }
            else if (storage.OwnerID == 0)
            {
                storage.OwnerID = drone.OwnerID;
            }

            var storageOwnerId = _config.AssignStorageOwnership ? storage.OwnerID : drone.OwnerID;
            storage.isLockable = storageOwnerId != 0 && permission.UserHasPermission(storageOwnerId.ToString(), PermissionLockable);

            storage.inventory.canAcceptItem = StashItemFilter;

            // Damage will be processed by the drone.
            storage.baseProtection = null;

            storage.inventory.capacity = capacity;
            storage.panelName = ResizableLootPanelName;

            DroneStorageComponent.AddToStorage(this, drone, storage);
            RefreshDroneSettingsProfile(drone);
        }

        private StorageContainer TryDeployStorage(Drone drone, int capacity, bool allowRefund = false, BasePlayer deployer = null)
        {
            if (DeployStorageWasBlocked(drone, deployer))
                return null;

            var storage = GameManager.server.CreateEntity(StoragePrefab, StorageLocalPosition, StorageLocalRotation) as StorageContainer;
            if (storage == null)
                return null;

            if (_config.AssignStorageOwnership)
            {
                storage.OwnerID = deployer?.userID ?? drone.OwnerID;
            }

            storage.SetParent(drone);
            storage.Spawn();

            SetupDroneStorage(drone, storage, capacity);
            drone.SetSlot(StorageSlot, storage);

            // This flag is used to remember whether the stash should be refundable.
            // This information is lost on restart but that's a minor concern.
            storage.pickup.enabled = allowRefund;

            Effect.server.Run(StorageDeployEffectPrefab, storage.transform.position);
            Interface.CallHook("OnDroneStorageDeployed", drone, storage, deployer);

            return storage;
        }

        private void RefreshStorage(Drone drone)
        {
            var storage = GetDroneStorage(drone);
            if (storage == null)
                return;

            // Possibly increase capacity, but do not decrease it because that could hide items.
            var capacity = Math.Max(storage.inventory.capacity, _storageCapacityManager.DetermineCapacityForUser(drone.OwnerID));
            SetupDroneStorage(drone, storage, capacity);
        }

        #endregion

        #region Drone Storage Component

        private class DroneStorageComponent : MonoBehaviour
        {
            public static void AddToStorage(DroneStorage plugin, Drone drone, StorageContainer storageContainer)
            {
                var component = storageContainer.gameObject.AddComponent<DroneStorageComponent>();
                component._plugin = plugin;
                component._drone = drone;
                component._storage = storageContainer;
                plugin._droneStorageTracker.Add(storageContainer);
            }

            public static void RemoveFromStorage(StorageContainer storageContainer)
            {
                DestroyImmediate(storageContainer.GetComponent<DroneStorageComponent>());
            }

            private DroneStorage _plugin;
            private Drone _drone;
            private StorageContainer _storage;

            // Called via `entity.SendMessage("PlayerStoppedLooting", player)` in PlayerLoot.Clear().
            private void PlayerStoppedLooting(BasePlayer looter)
            {
                _plugin._remoteStashViewerTracker.Remove(looter.userID);
            }

            private void OnDestroy()
            {
                if (_drone != null && !_drone.IsDestroyed)
                {
                    _drone.Invoke(() => _plugin.RefreshDroneSettingsProfile(_drone), 0);
                }

                _plugin._droneStorageTracker.Remove(_storage);
            }
        }

        #endregion

        #region Dynamic Hooks

        private class HookCollection
        {
            public bool IsSubscribed { get; private set; } = true;
            private readonly DroneStorage _plugin;
            private readonly string[] _hookNames;
            private readonly Func<bool> _shouldSubscribe;

            public HookCollection(DroneStorage plugin, Func<bool> shouldSubscribe, params string[] hookNames)
            {
                _plugin = plugin;
                _hookNames = hookNames;
                _shouldSubscribe = shouldSubscribe;
            }

            public void Subscribe()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Subscribe(hookName);
                }

                IsSubscribed = true;
            }

            public void Unsubscribe()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Unsubscribe(hookName);
                }

                IsSubscribed = false;
            }

            public void Refresh()
            {
                if (_shouldSubscribe())
                {
                    if (!IsSubscribed)
                    {
                        Subscribe();
                    }
                }
                else if (IsSubscribed)
                {
                    Unsubscribe();
                }
            }
        }

        private class DynamicHookHashSet<T> : HashSet<T>
        {
            private readonly HookCollection _hookCollection;

            public DynamicHookHashSet(DroneStorage plugin, params string[] hookNames)
            {
                _hookCollection = new HookCollection(plugin, () => Count > 0, hookNames);
            }

            public new bool Add(T item)
            {
                var result = base.Add(item);
                if (result)
                {
                    _hookCollection.Refresh();
                }
                return result;
            }

            public new bool Remove(T item)
            {
                var result = base.Remove(item);
                if (result)
                {
                    _hookCollection.Refresh();
                }
                return result;
            }

            public void Unsubscribe() => _hookCollection.Unsubscribe();
        }

        #endregion

        #region Configuration

        private class StorageCapacityManager
        {
            private class StorageSize
            {
                public readonly int Capacity;
                public readonly string Permission;

                public StorageSize(int capacity, string permission)
                {
                    Capacity = capacity;
                    Permission = permission;
                }
            }

            private readonly DroneStorage _plugin;
            private StorageSize[] _sortedStorageSizes;

            public StorageCapacityManager(DroneStorage plugin)
            {
                _plugin = plugin;
            }

            public void Init()
            {
                var storageSizeList = new List<StorageSize>();

                foreach (var capacity in new HashSet<int>(_plugin._config.CapacityAmounts).OrderBy(capacity => capacity))
                {
                    var storageSize = new StorageSize(capacity, $"{PermissionCapacityPrefix}.{capacity.ToString()}");
                    _plugin.permission.RegisterPermission(storageSize.Permission, _plugin);
                    storageSizeList.Add(storageSize);
                }

                _sortedStorageSizes = storageSizeList.ToArray();
            }

            public int DetermineCapacityForUser(ulong userId)
            {
                if (userId == 0)
                    return 0;

                var userIdString = userId.ToString();

                for (var i = _sortedStorageSizes.Length - 1; i >= 0; i--)
                {
                    var storageSize = _sortedStorageSizes[i];
                    if (_plugin.permission.UserHasPermission(userIdString, storageSize.Permission))
                        return storageSize.Capacity;
                }

                return 0;
            }
        }

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("TipChance")]
            public int TipChance = 25;

            [JsonProperty("AssignStorageOwnership")]
            public bool AssignStorageOwnership = true;

            [JsonProperty("CapacityAmounts")]
            public int[] CapacityAmounts = { 6, 12, 18, 24, 30, 36, 42, 48 };

            [JsonProperty("DisallowedItems")]
            public string[] DisallowedItems = new string[0];

            [JsonProperty("DisallowedSkins")]
            public ulong[] DisallowedSkins = new ulong[0];

            [JsonProperty("UISettings")]
            public UISettings UISettings = new UISettings();
        }

        private class UISettings
        {
            [JsonProperty("AnchorMin")]
            public string AnchorMin = "0.5 1";

            [JsonProperty("AnchorMax")]
            public string AnchorMax = "0.5 1";

            [JsonProperty("OffsetMin")]
            public string OffsetMin = "0 -75";

            [JsonProperty("OffsetMax")]
            public string OffsetMax = "0 -75";

            [JsonProperty("Buttons")]
            public UIButtons Buttons = new UIButtons();
        }

        private class UIButtons
        {
            [JsonProperty("Spacing")]
            public int Spacing = 25;

            [JsonProperty("Width")]
            public int Width = 85;

            [JsonProperty("Height")]
            public int Height = 26;

            [JsonProperty("TextSize")]
            public int TextSize = 13;

            [JsonProperty("ViewButtonColor")]
            public string ViewButtonColor = "0.44 0.54 0.26 1";

            [JsonProperty("ViewButtonTextColor")]
            public string ViewButtonTextColor = "0.97 0.92 0.88 1";

            [JsonProperty("DropButtonColor")]
            public string DropButtonColor = "0.77 0.24 0.16 1";

            [JsonProperty("DropButtonTextColor")]
            public string DropButtonTextColor = "0.97 0.92 0.88 1";

            [JsonProperty("LockButtonColor")]
            public string LockButtonColor = "0.8 0.4 0 1";

            [JsonProperty("LockButtonTextColor")]
            public string LockButtonTextColor = "0.97 0.92 0.88 1";

            [JsonProperty("UnlockButtonColor")]
            public string UnlockButtonColor = "0.8 0.4 0 1";

            [JsonProperty("UnlockButtonTextColor")]
            public string UnlockButtonTextColor = "0.97 0.92 0.88 1";
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Localization

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(BasePlayer player, string messageName, params object[] args) =>
            GetMessage(player.UserIDString, messageName, args);

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player.UserIDString, messageName), args));

        private class Lang
        {
            public const string UIButtonViewItems = "UI.Button.ViewItems";
            public const string UIButtonDropItems = "UI.Button.DropItems";
            public const string UIButtonLockStorage = "UI.Button.LockStorage";
            public const string UIButtonUnlockStorage = "UI.Button.UnlockStorage";
            public const string TipDeployCommand = "Tip.DeployCommand";
            public const string InfoStashName = "Info.StashName";
            public const string ErrorNoPermission = "Error.NoPermission";
            public const string ErrorBuildingBlocked = "Error.BuildingBlocked";
            public const string ErrorNoDroneFound = "Error.NoDroneFound";
            public const string ErrorNoStashItem = "Error.NoStashItem";
            public const string ErrorAlreadyHasStorage = "Error.AlreadyHasStorage";
            public const string ErrorIncompatibleAttachment = "Error.IncompatibleAttachment";
            public const string ErrorDeployFailed = "Error.DeployFailed";
            public const string ErrorCannotPickupDroneWithItems = "Error.CannotPickupDroneWithItems";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.UIButtonViewItems] = "View Items",
                [Lang.UIButtonDropItems] = "Drop Items",
                [Lang.UIButtonLockStorage] = "Lock",
                [Lang.UIButtonUnlockStorage] = "Unlock",
                [Lang.TipDeployCommand] = "Tip: Look at the drone and run <color=yellow>/dronestash</color> to deploy a stash.",
                [Lang.InfoStashName] = "Drone Stash",
                [Lang.ErrorNoPermission] = "You don't have permission to do that.",
                [Lang.ErrorBuildingBlocked] = "Error: Cannot do that while building blocked.",
                [Lang.ErrorNoDroneFound] = "Error: No drone found.",
                [Lang.ErrorNoStashItem] = "Error: You need a stash to do that.",
                [Lang.ErrorAlreadyHasStorage] = "Error: That drone already has a stash.",
                [Lang.ErrorIncompatibleAttachment] = "Error: That drone has an incompatible attachment.",
                [Lang.ErrorDeployFailed] = "Error: Failed to deploy stash.",
                [Lang.ErrorCannotPickupDroneWithItems] = "Cannot pick up that drone while its stash contains items.",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: DroneStorage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/drone-hover ---
// --- Original File Path: D/DroneHover/DroneHover.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Drone Hover", "WhiteThunder", "1.0.5")]
    [Description("Allows RC drones to hover in place when a player disconnects control at a computer station.")]
    internal class DroneHover : CovalencePlugin
    {
        #region Fields

        private const string PermissionUse = "dronehover.use";

        private readonly object False = false;

        private StoredData _pluginData;

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginData = StoredData.Load();

            permission.RegisterPermission(PermissionUse, this);
        }

        private void Unload()
        {
            OnServerSave();
        }

        private void OnServerInitialized()
        {
            if (_pluginData.HoveringDrones == null)
                return;

            foreach (var entity in RemoteControlEntity.allControllables)
            {
                var drone = entity as Drone;
                if (drone != null && _pluginData.HoveringDrones.Contains(drone.net.ID.Value))
                {
                    MaybeStartDroneHover(drone, null);
                }
            }
        }

        private void OnServerSave()
        {
            _pluginData.Save();
        }

        private void OnNewSave()
        {
            _pluginData = StoredData.Clear();
        }

        private void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string bookmarkName, Drone drone)
        {
            if (!RCUtils.HasFakeController(drone))
                return;

            RCUtils.RemoveController(drone);
            RCUtils.RemoveViewer(drone, player);
            RCUtils.AddViewer(drone, player);
            station.SetFlag(ComputerStation.Flag_HasFullControl, true, networkupdate: false);
            station.SendNetworkUpdateImmediate();
        }

        private void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, Drone drone)
        {
            OnDroneControlEnded(drone, player);
        }

        private void OnEntityKill(Drone drone)
        {
            _pluginData.HoveringDrones.Remove(drone.net.ID.Value);
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        private object canRemove(BasePlayer player, Drone drone)
        {
            // Null check since somebody reported this method was somehow throwing NREs.
            if (drone == null)
                return null;

            if (drone.IsBeingControlled)
                return False;

            return null;
        }

        // This hook is exposed by plugin: Ridable Drones (RidableDrones).
        private void OnDroneControlEnded(Drone drone, BasePlayer player)
        {
            if (drone == null)
                return;

            MaybeStartDroneHover(drone, player);
        }

        #endregion

        #region Helpers

        private static class RCUtils
        {
            public static bool HasFakeController(IRemoteControllable controllable)
            {
                return controllable.ControllingViewerId?.SteamId == 0;
            }

            public static void RemoveController(IRemoteControllable controllable)
            {
                var controllerId = controllable.ControllingViewerId;
                if (controllerId.HasValue)
                {
                    controllable.StopControl(controllerId.Value);
                }
            }

            public static bool AddViewer(IRemoteControllable controllable, BasePlayer player)
            {
                return controllable.InitializeControl(new CameraViewerId(player.userID, 0));
            }

            public static void RemoveViewer(IRemoteControllable controllable, BasePlayer player)
            {
                controllable.StopControl(new CameraViewerId(player.userID, 0));
            }

            public static bool AddFakeViewer(IRemoteControllable controllable)
            {
                return controllable.InitializeControl(new CameraViewerId());
            }
        }

        private bool HoverWasBlocked(Drone drone, BasePlayer formerPilot)
        {
            var hookResult = Interface.CallHook("OnDroneHoverStart", drone, formerPilot);
            return hookResult is bool && (bool)hookResult == false;
        }

        private bool ShouldHover(Drone drone, BasePlayer formerPilot)
        {
            if (drone.IsBeingControlled || drone.isGrounded)
                return false;

            if (formerPilot != null && !permission.UserHasPermission(formerPilot.UserIDString, PermissionUse))
                return false;

            if (HoverWasBlocked(drone, formerPilot))
                return false;

            return true;
        }

        private void MaybeStartDroneHover(Drone drone, BasePlayer formerPilot)
        {
            if (!ShouldHover(drone, formerPilot))
            {
                _pluginData.HoveringDrones.Remove(drone.net.ID.Value);
                return;
            }

            RCUtils.AddFakeViewer(drone);
            drone.currentInput.Reset();
            _pluginData.HoveringDrones.Add(drone.net.ID.Value);
            Interface.CallHook("OnDroneHoverStarted", drone, formerPilot);
        }

        #endregion

        #region Data

        private class StoredData
        {
            [JsonProperty("HoveringDrones")]
            public HashSet<ulong> HoveringDrones = new HashSet<ulong>();

            public static StoredData Load() =>
                Interface.Oxide.DataFileSystem.ReadObject<StoredData>(nameof(DroneHover)) ?? new StoredData();

            public static StoredData Clear() => new StoredData().Save();

            public StoredData Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject(nameof(DroneHover), this);
                return this;
            }
        }

        #endregion
    }
}


// --- End of file: DroneHover.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/death-chat ---
// --- Original File Path: D/DeathChat/DeathChat.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Death Chat", "Tricky", "1.1.2")]
    [Description("Provides ability to customize prefix for someone who has just died")]
    public class DeathChat : RustPlugin
    {
        #region PluginReferences
        [PluginReference]
        private Plugin BetterChat;
        #endregion

        #region Config
        Configuration config;

        class Configuration
        {
            [JsonProperty(PropertyName = "Track Player Kills Only")]
            public bool PlayerKills = true;

            [JsonProperty(PropertyName = "Time Until Prefix will show (seconds)")]
            public int Time = 60;

            [JsonProperty(PropertyName = "Prefix")]
            public string Prefix = "[RIP]";

            [JsonProperty(PropertyName = "Prefix Color")]
            public string PrefixColor = "#EE3B3B";

            [JsonProperty(PropertyName = "Prefix Size")]
            public int PrefixSize = 14;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                Config.WriteObject(config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonError");
                PrintError("The configuration file contains an error and has been replaced with a default config.\n" +
                           "The error configuration file was saved in the .jsonError extension");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Collection
        List<string> _players = new List<string>();
        #endregion

        #region Oxide Hooks
        private void OnServerInitialized()
        {
            if (BetterChat != null)
                Unsubscribe(nameof(OnPlayerChat));
        }
        #endregion

        #region Work with Data
        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (!config.PlayerKills && !(info.HitEntity is BasePlayer))
                return;

            _players.Add(player.UserIDString);

            timer.In(config.Time, () =>
            {
                _players.Remove(player.UserIDString);
            });
        }
        #endregion

        #region Chat Hooks
        private object OnPlayerChat(BasePlayer player, string message)
        {
            if (!_players.Contains(player.UserIDString))
                return null;

            var title = $"<color={config.PrefixColor}><size={config.PrefixSize}>{config.Prefix}</size></color> <color=#5af>{player.displayName}</color>";

            Server.Broadcast(message, title, player.userID);
            return true;
        }

        private object OnBetterChat(Dictionary<string, object> data)
        {
            var player = (IPlayer)data["Player"];

            if (!_players.Contains(player.Id))
                return null;

            var titles = (List<string>)data["Titles"];
            var deathtitle = $"<color={config.PrefixColor}><size={config.PrefixSize}>{config.Prefix}</size></color>";

            titles.Add(deathtitle);
            data["Titles"] = titles;
            return data;
        }
        #endregion
    }
}


// --- End of file: DeathChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-wipe-announcement ---
// --- Original File Path: D/DiscordWipeAnnouncement/DiscordWipeAnnouncement.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Discord Wipe Announcement", "MisterPixie", "1.1.0")]
    [Description("Post to discord when server wipes")]
    class DiscordWipeAnnouncement : RustPlugin
    {
        [PluginReference] Plugin DiscordMessages;

        #region Hooks
        private void Init()
        {
            LoadVariables();
            if (configData.Enable == false)
            {
                Unsubscribe("OnNewSave");
            }
        }

        [ChatCommand("dwatest")]
        void DisCommand(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin)
            {
                if(configData.UsingEmbedText == false)
                {
                    SendDiscordMessage();
                }
                else
                {
                    SendEmbedDiscordMessage();
                }
            }
        }

        void SendDiscordMessage()
        {
            string seed = ConVar.Server.seed.ToString();
            string hostname = ConVar.Server.hostname;
            string ip = covalence.Server.Address.ToString();
            string port = covalence.Server.Port.ToString();
            string worldsize = ConVar.Server.worldsize.ToString();

            string Message = string.Join("\n", configData.WipeMessage.ToArray());

            DiscordMessages?.Call("API_SendTextMessage", configData.WebhookURL, string.Format(Message, hostname, ip, port, seed, worldsize));
        }

        public class EmbedFieldList
        {
            public string name { get; set;}
            public string value { get; set; }
            public bool inline { get; set; }
        }

        void SendEmbedDiscordMessage()
        {
            string seed = ConVar.Server.seed.ToString();
            string hostname = ConVar.Server.hostname;
            string ip = covalence.Server.Address.ToString();
            string port = covalence.Server.Port.ToString();
            string worldsize = ConVar.Server.worldsize.ToString();

            List<EmbedFieldList> fields = new List<EmbedFieldList>();

            foreach (var i in configData.EmbedText)
            {
                fields.Add(new EmbedFieldList()
                {
                    name = string.Format(i.Value.name, hostname, ip, port, seed, worldsize),
                    inline = i.Value.inline,
                    value = string.Format(i.Value.value, hostname, ip, port, seed, worldsize)
                });
            }

            var fieldsObject = fields.Cast<object>().ToArray();

            string json = JsonConvert.SerializeObject(fieldsObject);

            DiscordMessages?.Call("API_SendFancyMessage", configData.WebhookURL, string.Format(configData.EmbedTextTitle, hostname, ip, port, seed, worldsize), configData.EmbedColor, json);

        }

        void OnNewSave(string filename)
        {
            if (configData.UsingEmbedText == false)
            {
                SendDiscordMessage();
            }
            else
            {
                SendEmbedDiscordMessage();
            }
        }
        #endregion


        #region Config
        public class EmbedList
        {
            public string name;
            public string value;
            public bool inline;
        }

        private ConfigData configData;
        private class ConfigData
        {
            public string WebhookURL;
            public bool Enable;
            public bool UsingEmbedText;
            public string EmbedTextTitle;
            public int EmbedColor;
            public List<string> WipeMessage;
            public Dictionary<int, EmbedList> EmbedText;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                WebhookURL = "Webhook URL Here",
                Enable = false,
                EmbedColor = 9044189,
                UsingEmbedText = false,
                EmbedTextTitle = "Your Embeded Title",
                WipeMessage = new List<string>
                {
                    "First Line",
                    "Second Line",
                    "Third Line..."
                },
                EmbedText = new Dictionary<int, EmbedList>
                {
                    [1] = new EmbedList()
                    {
                        name = "First Embed Name",
                        value = "First Value",
                        inline = false
                    },
                    [2] = new EmbedList()
                    {
                        name = "Second Embed Name",
                        value = "Second Value",
                        inline = false
                    }
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}

// --- End of file: DiscordWipeAnnouncement.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/drone-scale-manager ---
// --- Original File Path: D/DroneScaleManager/DroneScaleManager.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Drone Scale Manager", "WhiteThunder", "1.0.1")]
    [Description("Utilities for resizing RC drones.")]
    internal class DroneScaleManager : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        Plugin DroneEffects, EntityScaleManager;

        private static DroneScaleManager _pluginInstance;
        private static StoredData _pluginData;

        private const string PermissionScaleUnrestricted = "dronescalemanager.unrestricted";

        private const string SpherePrefab = "assets/prefabs/visualization/sphere.prefab";

        private const float VanillaDroneGroundTraceDistance = 0.1f;
        private const float VanillaDroneYawSpeed = 2;
        private const float RootEntityLocalY = 0.2f;

        private static readonly Vector3 RootEntityPosition = new Vector3(0, RootEntityLocalY, 0);

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginInstance = this;
            _pluginData = StoredData.Load();

            permission.RegisterPermission(PermissionScaleUnrestricted, this);
        }

        private void OnServerInitialized()
        {
            if (!VerifyDependencies())
                return;

            RefreshAllScaledDrones();
        }

        private void Unload()
        {
            _pluginData.Save();

            DroneCollisionProxy.DestroyAll();

            _pluginData = null;
            _pluginInstance = null;
        }

        private void OnServerSave()
        {
            _pluginData.Save();
        }

        private void OnNewSave()
        {
            _pluginData = StoredData.Clear();
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin == EntityScaleManager)
                RefreshAllScaledDrones();
        }

        private void OnEntityKill(Drone drone)
        {
            if (!_pluginData.ScaledDrones.Remove(drone.net.ID.Value))
                return;

            var rootEntity = GetRootEntity(drone);
            if (rootEntity == null)
                return;

            rootEntity.Invoke(() =>
            {
                if (!rootEntity.IsDestroyed)
                    rootEntity.Kill();
            }, 0);
        }

        // This hook is exposed by plugin: Drone Effects (DroneEffects).
        private bool? OnDroneAnimationStart(Drone drone)
        {
            // Prevent the animated delivery drone from spawning, since it may be normal size.
            if (IsScaledDrone(drone))
                return false;

            return null;
        }

        #endregion

        #region API

        private bool API_ScaleDrone(Drone drone, float scale)
        {
            return TryScaleDrone(drone, scale);
        }

        private bool API_ParentEntity(Drone drone, BaseEntity childEntity)
        {
            if (!IsDroneEligible(drone) || !IsScaledDrone(drone))
                return false;

            var rootEntity = GetRootEntityOrParentSphere(drone);
            if (rootEntity == null)
                return false;

            PositionChildTransform(rootEntity.transform, drone.transform, childEntity.transform);
            childEntity.SetParent(rootEntity, worldPositionStays: false, sendImmediate: true);

            if (!childEntity.isSpawned)
                childEntity.Spawn();

            return true;
        }

        private bool API_ParentTransform(Drone drone, Transform childTransform)
        {
            if (!IsDroneEligible(drone) || !IsScaledDrone(drone))
                return false;

            var rootEntity = GetRootEntityOrParentSphere(drone);
            if (rootEntity == null)
                return false;

            var rootTransform = rootEntity.transform;
            PositionChildTransform(rootTransform, drone.transform, childTransform);
            childTransform.parent = rootTransform;

            return true;
        }

        private Drone API_GetParentDrone(BaseEntity entity)
        {
            var possibleRootEntity = GetParentSphere(entity);
            if (possibleRootEntity == null)
                return null;

            var drone = GetGrandChildOfType<Drone>(possibleRootEntity);
            if (drone == null || !IsScaledDrone(drone))
                return null;

            return drone;
        }

        private SphereEntity API_GetRootEntity(Drone drone)
        {
            return GetRootEntity(drone);
        }

        #endregion

        #region Commands

        [Command("scaledrone", "dronescale")]
        private void CommandDroneScale(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer)
                return;

            if (!player.HasPermission(PermissionScaleUnrestricted))
            {
                ReplyToPlayer(player, Lang.ErrorNoPermission);
                return;
            }

            float scale;
            if (args.Length == 0 || !float.TryParse(args[0], out scale))
            {
                ReplyToPlayer(player, Lang.ErrorSyntax, cmd);
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            var drone = GetLookEntity(basePlayer) as Drone;
            if (drone == null || !IsDroneEligible(drone))
            {
                ReplyToPlayer(player, Lang.ErrorNoDroneFound);
                return;
            }

            if (TryScaleDrone(drone, scale))
                ReplyToPlayer(player, Lang.ScaleSuccess, scale);
            else
                ReplyToPlayer(player, Lang.ScaleError);
        }

        #endregion

        #region Helper Methods

        private static bool DroneScaleWasBlocked(Drone drone, float scale)
        {
            object hookResult = Interface.CallHook("OnDroneScale", drone, scale);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool VerifyDependencies()
        {
            if (_pluginInstance.EntityScaleManager == null)
            {
                _pluginInstance.LogError("EntityScaleManager is not loaded, get it at https://umod.org");
                return false;
            }

            return true;
        }

        private static bool IsScaledDrone(Drone drone) =>
            _pluginData.ScaledDrones.Contains(drone.net.ID.Value);

        private static float GetDroneScale(Drone drone)
        {
            if (!VerifyDependencies())
                return 1;

            return Convert.ToSingle(_pluginInstance.EntityScaleManager.Call("API_GetScale", drone));
        }

        private static bool IsDroneEligible(Drone drone) => !(drone is DeliveryDrone);

        private static BaseEntity GetLookEntity(BasePlayer basePlayer, float maxDistance = 20)
        {
            RaycastHit hit;
            return Physics.Raycast(basePlayer.eyes.HeadRay(), out hit, maxDistance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore)
                ? hit.GetEntity()
                : null;
        }

        private static T GetGrandChildOfType<T>(BaseEntity entity) where T : BaseEntity
        {
            foreach (var child in entity.children)
            {
                foreach (var grandChild in child.children)
                {
                    var grandChildOfType = grandChild as T;
                    if (grandChildOfType != null)
                        return grandChildOfType;
                }
            }
            return null;
        }

        private static void CopyRigidBodySettings(Rigidbody sourceBody, Rigidbody destinationBody)
        {
            // Copy everything except rotation since we are handling that at the transform level instead.
            destinationBody.angularDrag = sourceBody.angularDrag;
            destinationBody.centerOfMass = sourceBody.centerOfMass;
            destinationBody.collisionDetectionMode = sourceBody.collisionDetectionMode;
            destinationBody.constraints = sourceBody.constraints;
            destinationBody.detectCollisions = sourceBody.detectCollisions;
            destinationBody.drag = sourceBody.drag;
            destinationBody.freezeRotation = sourceBody.freezeRotation;
            destinationBody.inertiaTensorRotation = sourceBody.inertiaTensorRotation;
            destinationBody.interpolation = sourceBody.interpolation;
            destinationBody.isKinematic = sourceBody.isKinematic;
            destinationBody.mass = sourceBody.mass;
            destinationBody.maxAngularVelocity = sourceBody.maxAngularVelocity;
            destinationBody.maxDepenetrationVelocity = sourceBody.maxDepenetrationVelocity;
            destinationBody.sleepThreshold = sourceBody.sleepThreshold;
            destinationBody.solverIterations = sourceBody.solverIterations;
            destinationBody.solverVelocityIterations = sourceBody.solverVelocityIterations;
            destinationBody.useGravity = sourceBody.useGravity;
        }

        private static void MaybeSetupRootRigidBody(Drone scaledDrone, SphereEntity rootEntity)
        {
            var rootRigidBody = rootEntity.GetOrAddComponent<Rigidbody>();
            if (rootRigidBody == scaledDrone.body)
                return;

            CopyRigidBodySettings(scaledDrone.body, rootRigidBody);
            UnityEngine.Object.DestroyImmediate(scaledDrone.body);
            scaledDrone.body = rootRigidBody;
        }

        private static void RestoreRigidBody(Drone scaledDrone, SphereEntity rootEntity)
        {
            var rootRigidBody = rootEntity.GetComponent<Rigidbody>();
            if (rootRigidBody == null)
                return;

            scaledDrone.body = scaledDrone.GetOrAddComponent<Rigidbody>();
            CopyRigidBodySettings(rootRigidBody, scaledDrone.body);
        }

        private static void EnableGlobalBroadcastFixed(BaseEntity entity, bool wants)
        {
            entity.globalBroadcast = wants;

            if (wants)
            {
                entity.UpdateNetworkGroup();
            }
            else if (entity.net?.group?.ID == 0)
            {
                // Fix vanilla bug that prevents leaving the global network group.
                var group = entity.net.sv.visibility.GetGroup(entity.transform.position);
                entity.net.SwitchGroup(group);
            }
        }

        private static void SetupRootEntity(Drone drone, SphereEntity rootEntity)
        {
            rootEntity.gameObject.layer = drone.gameObject.layer;

            // SphereEntity has enableSaving off by default.
            // This fixes an issue where the resized child gets orphaned on restart and spams console errors every 2 seconds.
            rootEntity.EnableSaving(true);

            // SphereEntity has globalBroadcast on by default.
            // This fixes an issue where clients who resubscribe do not recreate the sphere or its children.
            EnableGlobalBroadcastFixed(rootEntity, false);

            // Move rigid body to the root entity.
            MaybeSetupRootRigidBody(drone, rootEntity);

            // Proxy collisions from the root entity to the drone.
            rootEntity.GetOrAddComponent<DroneCollisionProxy>().OwnerDrone = drone;
        }

        private static void SetupRootEntityAfterSpawn(Drone drone, SphereEntity rootEntity)
        {
            // Cancel the default position network updates since we will use fixed time updates instead.
            rootEntity.CancelInvoke(rootEntity.NetworkPositionTick);

            if (!rootEntity.IsInvokingFixedTime(rootEntity.NetworkPositionTick))
                rootEntity.InvokeRepeatingFixedTime(rootEntity.NetworkPositionTick);
        }

        private static void SetupScaledDrone(Drone drone, float scale)
        {
            // Without changing yaw speed, large drones turn faster and small drones turn slower.
            drone.yawSpeed = VanillaDroneYawSpeed / scale;
            drone.groundTraceDist = Math.Min(RootEntityLocalY, VanillaDroneGroundTraceDistance * scale + RootEntityLocalY);

            // Cancel position network updates since the root entity will be moved instead.
            if (scale != 1)
                drone.CancelInvokeFixedTime(drone.NetworkPositionTick);
        }

        private static void RefreshScaledDrone(Drone drone)
        {
            SphereEntity parentSphere;
            var rootEntity = GetRootEntity(drone, out parentSphere);
            if (rootEntity == null)
                return;

            SetupRootEntity(drone, rootEntity);
            SetupRootEntityAfterSpawn(drone, rootEntity);
            SetupScaledDrone(drone, parentSphere.currentRadius);
        }

        private void RefreshAllScaledDrones()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null || !IsDroneEligible(drone))
                    continue;

                if (IsScaledDrone(drone))
                    RefreshScaledDrone(drone);
            }
        }

        private static void PositionChildTransform(Transform rootTransform, Transform droneTransform, Transform childTransform)
        {
            var scaledWorldPosition = droneTransform.TransformPoint(childTransform.localPosition);
            childTransform.localPosition = rootTransform.InverseTransformPoint(scaledWorldPosition);
            childTransform.localRotation = droneTransform.localRotation * childTransform.localRotation;
        }

        private static SphereEntity GetParentSphere(BaseEntity entity) =>
            entity.GetParentEntity() as SphereEntity;

        private static SphereEntity GetRootEntity(Drone drone, out SphereEntity parentSphere)
        {
            parentSphere = GetParentSphere(drone);
            if (parentSphere == null)
                return null;

            return parentSphere.GetParentEntity() as SphereEntity;
        }

        private static SphereEntity GetRootEntity(Drone drone)
        {
            SphereEntity parentSphere;
            return GetRootEntity(drone, out parentSphere);
        }

        private static SphereEntity GetRootEntityOrParentSphere(Drone drone)
        {
            SphereEntity parentSphere;
            var rootEntity = GetRootEntity(drone, out parentSphere);
            if (rootEntity != null)
                return rootEntity;

            // Assume the parent sphere is the root entity, in case this was called during the OnDroneScaleBegin hook.
            if (parentSphere != null)
                return parentSphere;

            return null;
        }

        private static SphereEntity AddRootEntity(Drone drone)
        {
            var rootEntity = GameManager.server.CreateEntity(SpherePrefab, drone.transform.TransformPoint(RootEntityPosition)) as SphereEntity;
            if (rootEntity == null)
                return null;

            SetupRootEntity(drone, rootEntity);
            rootEntity.Spawn();
            SetupRootEntityAfterSpawn(drone, rootEntity);
            drone.SetParent(rootEntity, worldPositionStays: true, sendImmediate: true);

            return rootEntity;
        }

        private static void RemoveRootEntity(Drone scaledDrone)
        {
            SphereEntity parentSphere;
            var rootEntity = GetRootEntity(scaledDrone, out parentSphere);
            if (rootEntity == null)
                return;

            // Restore the movement updates since they were disabled while resized.
            if (!scaledDrone.IsInvokingFixedTime(scaledDrone.NetworkPositionTick))
                scaledDrone.InvokeRepeatingFixedTime(scaledDrone.NetworkPositionTick);

            parentSphere.SetParent(null, worldPositionStays: true, sendImmediate: true);

            RestoreRigidBody(scaledDrone, rootEntity);
            rootEntity.Kill();

            _pluginData.ScaledDrones.Remove(scaledDrone.net.ID.Value);
        }

        private static bool ScaleDrone(Drone drone, SphereEntity rootEntity, float scale, float currentScale)
        {
            SetupScaledDrone(drone, scale);

            // Notify other plugins before removing the root entity.
            // This allows plugins to move or remove attachments from the root entity if needed.
            Interface.CallHook("OnDroneScaleBegin", drone, rootEntity, scale, currentScale);

            if (scale == 1)
                RemoveRootEntity(drone);

            var result = _pluginInstance.EntityScaleManager.CallHook("API_ScaleEntity", drone, scale);
            var success = result is bool && (bool)result;

            // Reposition existing attachments if the drone is already resized.
            if (IsScaledDrone(drone))
            {
                var rootTransform = rootEntity.transform;
                var droneTransform = drone.transform;
                var droneParentSphere = GetParentSphere(drone);

                foreach (var child in rootEntity.children)
                {
                    if (child == droneParentSphere)
                        continue;

                    var childTransform = child.transform;
                    var baseLocalPosition = droneTransform.InverseTransformPoint(childTransform.position) / currentScale;
                    var newWorldPosition = droneTransform.TransformPoint(baseLocalPosition * scale);
                    childTransform.localPosition = rootTransform.InverseTransformPoint(newWorldPosition);

                    child.InvalidateNetworkCache();
                    child.SendNetworkUpdate_Position();
                }
            }

            return success;
        }

        private static bool TryScaleDrone(Drone drone, float desiredScale)
        {
            if (!VerifyDependencies())
                return false;

            if (DroneScaleWasBlocked(drone, desiredScale))
                return false;

            var currentScale = GetDroneScale(drone);
            var isCurrentlyScaled = currentScale != 1 && IsScaledDrone(drone);

            bool success = false;
            SphereEntity rootEntity;

            if (isCurrentlyScaled)
            {
                if (desiredScale == currentScale)
                    return true;

                rootEntity = GetRootEntity(drone);
                success = ScaleDrone(drone, rootEntity, desiredScale, currentScale);
            }
            else if (desiredScale == 1)
            {
                return true;
            }
            else
            {
                _pluginData.ScaledDrones.Add(drone.net.ID.Value);
                rootEntity = AddRootEntity(drone);
                success = ScaleDrone(drone, rootEntity, desiredScale, currentScale);
                _pluginInstance.DroneEffects?.Call("API_StopAnimating", drone);
            }

            Interface.CallHook("OnDroneScaled", drone, rootEntity, desiredScale, currentScale);
            return success;
        }

        #endregion

        #region Collision Detection

        private class DroneCollisionProxy : MonoBehaviour
        {
            private const string OnCollisionEnterMethodName = "OnCollisionEnter";
            private const string OnCollisionStayMethodName = "OnCollisionStay";

            public static void DestroyAll()
            {
                foreach (var entity in BaseNetworkable.serverEntities)
                {
                    var sphereEntity = entity as SphereEntity;
                    if (sphereEntity == null)
                        continue;

                    var component = sphereEntity.GetComponent<DroneCollisionProxy>();
                    if (component == null)
                        continue;

                    DestroyImmediate(component);
                }
            }

            public Drone OwnerDrone;

            private void OnCollisionEnter(Collision collision)
            {
                if (OwnerDrone != null)
                    OwnerDrone.BroadcastMessage(OnCollisionEnterMethodName, collision, SendMessageOptions.DontRequireReceiver);
            }

            private void OnCollisionStay()
            {
                if (OwnerDrone != null)
                    OwnerDrone.BroadcastMessage(OnCollisionStayMethodName, SendMessageOptions.DontRequireReceiver);
            }
        }

        #endregion

        #region Data

        private class StoredData
        {
            [JsonProperty("ScaledDrones")]
            public HashSet<ulong> ScaledDrones = new HashSet<ulong>();

            public static StoredData Load() =>
                Interface.Oxide.DataFileSystem.ReadObject<StoredData>(_pluginInstance.Name) ?? new StoredData();

            public static StoredData Clear() => new StoredData().Save();

            public StoredData Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject(_pluginInstance.Name, this);
                return this;
            }
        }

        #endregion

        #region Localization

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private class Lang
        {
            public const string ErrorNoPermission = "Error.NoPermission";
            public const string ErrorSyntax = "Error.Syntax";
            public const string ErrorNoDroneFound = "Error.NoDroneFound";
            public const string ScaleSuccess = "Scale.Success";
            public const string ScaleError = "Error.ScalePrevented";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ErrorNoPermission] = "You don't have permission to do that.",
                [Lang.ErrorSyntax] = "Syntax: {0} <size>",
                [Lang.ErrorNoDroneFound] = "Error: No drone found.",
                [Lang.ScaleSuccess] = "Drone was scaled to: {0}",
                [Lang.ScaleError] = "An error occurred while attempting to resize that drone.",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: DroneScaleManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/drone-pilot ---
// --- Original File Path: D/DronePilot/DronePilot.cs ---

using System;
using System.Collections.Generic;
using System.Linq;

using Network;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DronePilot", "k1lly0u", "1.0.7")]
    [Description("Allow players with permission to fly drones")]
    class DronePilot : RustPlugin
    {
        #region Fields  
        private Hash<ulong, double> _cooldownTimes = new Hash<ulong, double>();

        private const string USE_PERMISSION = "dronepilot.use";
        private const string CREATE_PERMISSION = "dronepilot.create";
        private const string IGNORE_COOLDOWN_PERMISSION = "dronepilot.nocooldown";
        private const string IGNORE_COST_PERMISSION = "dronepilot.nocost";

        private const float DRONE_DISABLE_HEALTH_FRACTION = 0.1f;
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission(USE_PERMISSION, this);
            permission.RegisterPermission(CREATE_PERMISSION, this);
            permission.RegisterPermission(IGNORE_COOLDOWN_PERMISSION, this);
            permission.RegisterPermission(IGNORE_COST_PERMISSION, this);

            GetMessage = Message;
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private object CanBuild(Planner planner, Construction prefab)
        {
            BasePlayer player = planner?.GetOwnerPlayer();
            if (player == null)
            {
                return null;
            }

            if (prefab.fullName == "assets/prefabs/deployable/drone/drone.deployed.prefab")
            {
                if (player.GetMountedVehicle() != null || player.GetParentEntity() != null)
                {
                    player.ChatMessage(Message("Error.HasMountedOrParented", player.userID));
                    return false;
                }
            }
            return null;
        }

        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            BasePlayer player = planner?.GetOwnerPlayer();
            if (player == null)
                return;

            Drone drone = gameObject.ToBaseEntity() as Drone;
            if (drone != null)
            {
                if (permission.UserHasPermission(player.UserIDString, USE_PERMISSION))
                {
                    if (drone.healthFraction < DRONE_DISABLE_HEALTH_FRACTION)
                    {
                        player.ChatMessage(Message("Notification.TooMuchDamage", player.userID));
                        return;
                    }

                    DroneController droneController = gameObject.AddComponent<DroneController>();
                    droneController.StartPiloting(player);

                    player.ChatMessage(Message("Notification.Controls", player.userID));
                }
                else player.ChatMessage(Message("Error.NoFlyPermissions", player.userID));
            }
        }

        private void OnEntityTakeDamage(Drone drone, HitInfo hitInfo)
        {
            DroneController droneController = drone.GetComponent<DroneController>();
            if (droneController != null)
            {
                Rust.DamageType damageType = hitInfo.damageTypes.GetMajorityDamageType();
                if (damageType == Rust.DamageType.Generic) // Disable damage from Drone.OnCollisionEnter because its a stupid amount
                {
                    hitInfo.damageTypes.Clear();
                    hitInfo.HitEntity = null;
                    hitInfo.HitMaterial = 0;
                    hitInfo.PointStart = Vector3.zero;
                    return;
                }

                if (damageType != Rust.DamageType.Collision) // Dont do anything is its collision damage because we are managing that in DroneController.OnCollisionEnter
                {
                    hitInfo.damageTypes.ScaleAll(Configuration.DamageScale);

                    BasePlayer player = droneController.Controller;

                    float healthFraction = (drone.Health() - hitInfo.damageTypes.Total()) / drone.MaxHealth();
                    if (healthFraction < 0)
                    {
                        player.ChatMessage(Message("Notification.Destroyed", player.userID));

                        droneController._killOnDestroy = true;

                        UnityEngine.Object.Destroy(droneController);
                    }
                    if (healthFraction < DRONE_DISABLE_HEALTH_FRACTION)
                    {
                        player.ChatMessage(Message("Notification.TooMuchDamage", player.userID));

                        UnityEngine.Object.Destroy(droneController);
                    }
                }
            }
        }

        private void OnPlayerWound(BasePlayer player, HitInfo hitInfo)
        {
            for (int i = 0; i < DroneController._allDroneControllers.Count; i++)
            {
                DroneController droneController = DroneController._allDroneControllers[i];

                if (droneController.Dummy == player)
                {
                    BasePlayer actualPlayer = droneController.Controller;
                    UnityEngine.Object.Destroy(droneController);

                    actualPlayer.BecomeWounded(hitInfo);
                    return;
                }
            }
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
        {
            for (int i = 0; i < DroneController._allDroneControllers.Count; i++)
            {
                DroneController droneController = DroneController._allDroneControllers[i];

                if (droneController.Dummy == player)
                {
                    droneController.OnPlayerDeath(hitInfo);
                    return;
                }
            }
        }

        private void OnEntityDeath(Drone drone, HitInfo hitInfo)
        {
            DroneController droneController = drone.GetComponent<DroneController>();
            if (droneController != null)
            {
                BasePlayer player = droneController.Controller;
                if (player != null)
                    player.ChatMessage(Message("Notification.Destroyed", player.userID));

                droneController._killOnDestroy = true;

                UnityEngine.Object.Destroy(droneController);
            }
        }

        private object CanPickupEntity(BasePlayer player, Drone drone)
        {
            DroneController droneController = drone.GetComponent<DroneController>();
            if (droneController != null && droneController.Controller != null)
                return false;
            return null;
        }

        private object CanSpectateTarget(BasePlayer player, string name)
        {
            DroneController droneController = player.GetMounted()?.GetComponentInParent<DroneController>();
            if (droneController)            
                return false;            
            return null;
        }

        private object CanBeTargeted(BasePlayer player)
        {
            for (int i = 0; i < DroneController._allDroneControllers.Count; i++)
            {
                DroneController droneController = DroneController._allDroneControllers[i];

                if (droneController.Controller.userID == player.userID)
                {
                    return false;
                }
            }
            return null;
        }

        private object CanBradleyApcTarget(BasePlayer player)
        {
            for (int i = 0; i < DroneController._allDroneControllers.Count; i++)
            {
                DroneController droneController = DroneController._allDroneControllers[i];

                if (droneController.Controller.userID == player.userID)
                {
                    return false;
                }
            }
            return null;
        }

        private object CanHelicopterTarget(BasePlayer player)
        {
            for (int i = 0; i < DroneController._allDroneControllers.Count; i++)
            {
                DroneController droneController = DroneController._allDroneControllers[i];

                if (droneController.Controller.userID == player.userID)
                {
                    return false;
                }
            }
            return null;
        }

        private void Unload()
        {
            for (int i = DroneController._allDroneControllers.Count - 1; i >= 0; i--)            
                UnityEngine.Object.Destroy(DroneController._allDroneControllers[i]);            

            Configuration = null;
            GetMessage = null;
        }
        #endregion

        #region Functions
        private static void MoveInventoryTo(PlayerInventory from, PlayerInventory to)
        {
            for (int i = from.containerBelt.itemList.Count - 1; i >= 0; i--)
            {
                Item item = from.containerBelt.itemList[i];
                item.MoveToContainer(to.containerBelt, item.position, false);
            }

            for (int i = from.containerMain.itemList.Count - 1; i >= 0; i--)
            {
                Item item = from.containerMain.itemList[i];
                item.MoveToContainer(to.containerMain, item.position, false);
            }

            for (int i = from.containerWear.itemList.Count - 1; i >= 0; i--)
            {
                Item item = from.containerWear.itemList[i];
                item.MoveToContainer(to.containerWear, item.position, false);
            }
        }

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds(time);
            int days = dateDifference.Days;
            int hours = dateDifference.Hours;
            int mins = dateDifference.Minutes;
            int secs = dateDifference.Seconds;

            if (days > 0)
                return string.Format("~{0:00}d:{1:00}h", days, hours);
            else if (hours > 0)
                return string.Format("~{0:00}h:{1:00}m", hours, mins, secs);
            else if (mins > 0)
                return string.Format("{0:00}m:{1:00}s", mins, secs);
            else return string.Format("{0}s", secs);
        }

        private object CanTeleport(BasePlayer player)
        {
            if (player.GetMounted()?.GetComponentInParent<DroneController>() != null)
                return Message("Error.NoTP", player.userID);
            return null;
        }
        #endregion

        #region Controller
        private class DroneController : MonoBehaviour
        {
            public static List<DroneController> _allDroneControllers = new List<DroneController>();


            public Drone Drone { get; private set; }

            public BasePlayer Controller { get; private set; }

            public BasePlayer Dummy { get; private set; }

            public bool IsBeingControlled => Controller != null;


            private DroneInputState _currentInput;

            private float _lastInputTime;

            private double _lastCollision = -1000.0;

            private bool _isGrounded;

            private Transform _tr;

            private Rigidbody _rb;

            private BaseMountable _mountPoint;


            private float _avgTerrainHeight;

            internal bool _killOnDestroy = false;

            private void Awake()
            {
                Drone = GetComponent<Drone>();
                Drone.enabled = false;

                _tr = Drone.transform;
                _rb = Drone.GetComponent<Rigidbody>();

                _allDroneControllers.Add(this);
            }

            private void OnDestroy()
            {
                if (Controller != null)
                {
                    StopControllingDrone();
                    RestorePlayer();                    
                }

                if (_mountPoint != null && !_mountPoint.IsDestroyed)
                    _mountPoint.Kill(BaseNetworkable.DestroyMode.None);

                _allDroneControllers.Remove(this);

                if (_killOnDestroy && Drone != null && !Drone.IsDead())
                    Drone.Kill();
            }

            internal void StartPiloting(BasePlayer player)
            {
                CreateMountPoint();

                Controller = player;
                CreateDummyPlayer();

                Controller.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
                Controller.MountObject(_mountPoint);

                NetWrite write = Net.sv.StartWrite();

                write.PacketID(Network.Message.Type.EntityDestroy);
                write.EntityID(player.net.ID);
                write.UInt8((byte)BaseNetworkable.DestroyMode.None);
                write.Send(new SendInfo(player.net.group.subscribers.Where(x => x.userid != player.userID).ToList()));

                Controller.limitNetworking = true;
                Controller.syncPosition = false;
            }

            internal void OnPlayerDeath(HitInfo hitInfo)
            {
                StopControllingDrone();

                Controller.Die(hitInfo);

                Controller = null;

                Destroy(this);
            }

            private void StopControllingDrone()
            {
                Controller.PauseFlyHackDetection(3f);

                Controller.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
                Controller.limitNetworking = false;
                Controller.syncPosition = true;

                Controller.DismountObject();
                Controller.EnsureDismounted();
            }

            private void RestorePlayer()
            {
                Controller.transform.position = Dummy.transform.position;

                if (Dummy != null && !Dummy.IsDead())
                {
                    MoveInventoryTo(Dummy.inventory, Controller.inventory);
                    Dummy.Kill(BaseNetworkable.DestroyMode.None);
                }

                Controller = null;
            }

            private void CreateDummyPlayer()
            {
                Dummy = (BasePlayer)GameManager.server.CreateEntity(Controller.PrefabName, Controller.transform.position, Controller.transform.rotation);
                Dummy.enableSaving = false;
                Dummy.Spawn();

                Dummy.displayName = Controller.displayName;
                Dummy.SetFlag(BaseEntity.Flags.Reserved8, true);

                Dummy.inventory.Strip();

                MoveInventoryTo(Controller.inventory, Dummy.inventory);                
            }

            private void CreateMountPoint()
            {
                const string CHAIR_PREFAB = "assets/prefabs/deployable/chair/chair.deployed.prefab";

                _mountPoint = GameManager.server.CreateEntity(CHAIR_PREFAB, _tr.position) as BaseMountable;
                _mountPoint.enableSaving = false;
                _mountPoint.skinID = (ulong)1169930802;
                _mountPoint.isMobile = true;
                _mountPoint.Spawn();

                Destroy(_mountPoint.GetComponent<DestroyOnGroundMissing>());
                Destroy(_mountPoint.GetComponent<GroundWatch>());
                Destroy(_mountPoint.GetComponent<MeshCollider>());

                _mountPoint.SetParent(Drone);
                _mountPoint.transform.localPosition = new Vector3(0f, -0.5f, -1f);
            }

            private void UserInput(InputState inputState)
            {
                _currentInput.Reset();

                float forward = (inputState.IsDown(BUTTON.FORWARD) ? 1 : 0) + (inputState.IsDown(BUTTON.BACKWARD) ? -1 : 0);
                float sideways = (inputState.IsDown(BUTTON.RIGHT) ? 1 : 0) + (inputState.IsDown(BUTTON.LEFT) ? -1 : 0);

                _currentInput.movement = new Vector3(sideways, 0f, forward).normalized;
                _currentInput.throttle = ((inputState.IsDown(BUTTON.SPRINT) ? 1 : 0) + (inputState.IsDown(BUTTON.DUCK) ? -1 : 0));

                _lastInputTime = UnityEngine.Time.time;
            }

            private void FixedUpdate()
            {
                if (Drone.IsDead() || !IsBeingControlled)                
                    return;

                float num = Drone.WaterFactor();
                if (Drone.killInWater && num > 0.1f)
                {
                    if (num > 0.75f)
                    {
                        Controller.ChatMessage(GetMessage("Notification.WaterDamage", Controller.userID));

                        _killOnDestroy = true;
                        Destroy(this);
                    }

                    Controller.ChatMessage(GetMessage("Notification.WaterLogged", Controller.userID));
                    Destroy(this);
                    return;
                }

                if (Controller.serverInput.WasJustPressed(BUTTON.JUMP))
                {
                    Destroy(this);
                    return;
                }

                UserInput(Controller.serverInput);
                
                bool isCollisionDisabled = _lastCollision > 0.0 && TimeEx.currentTimestamp - _lastCollision < (double)Configuration.CollisionDisableTime;

                RaycastHit raycastHit;
                _isGrounded = (Drone.enableGrounding && _rb.SweepTest(-_tr.up, out raycastHit, Drone.groundTraceDist));

                Vector3 localToWorld = _tr.TransformDirection(_currentInput.movement);
                Vector3 direction;
                float magnitude;
                _rb.velocity.WithY(0f).ToDirectionAndMagnitude(out direction, out magnitude);

                float leanMagnitude = Mathf.Clamp01(magnitude / Configuration.LeanMaxVelocity);
                Vector3 worldLeanVelocity = Mathf.Approximately(localToWorld.sqrMagnitude, 0f) ? (-leanMagnitude * direction) : localToWorld;
                Vector3 normalizedLean = (Vector3.up + worldLeanVelocity * Configuration.LeanWeight * leanMagnitude).normalized;

                float leanForce = Mathf.Max(Vector3.Dot(normalizedLean, _tr.up), 0f);
                
                if (!isCollisionDisabled || _isGrounded)
                {
                    Vector3 descendVector = (_isGrounded && _currentInput.throttle <= 0f) ? Vector3.zero : (-1f * _tr.up * Physics.gravity.y);
                    Vector3 movementVector = _isGrounded ? Vector3.zero : (localToWorld * Configuration.MovementAcceleration);
                    Vector3 ascendVector = _tr.up * _currentInput.throttle * Configuration.AltitudeAcceleration;
                    Vector3 force = descendVector + movementVector + ascendVector;

                    _rb.AddForce(force * leanForce, ForceMode.Acceleration);
                }

                if (!isCollisionDisabled && !_isGrounded)
                {
                    Vector3 worldYaw = _tr.TransformVector(0f, _currentInput.movement.x * Configuration.YawSpeed, 0f);
                    Vector3 lean = Vector3.Cross(Quaternion.Euler(_rb.angularVelocity * Drone.uprightPrediction) * _tr.up, normalizedLean) * Configuration.UprightSpeed;
                    float leanMultiplier = (leanForce < Drone.uprightDot) ? 0f : leanForce;

                    Vector3 force = worldYaw * leanForce + lean * leanMultiplier;
                                       
                    _rb.AddTorque(force * leanForce, ForceMode.Acceleration);

                    if (!Configuration.AutoHover && _currentInput.throttle == 0 && _currentInput.movement == Vector3.zero)
                        _rb.AddForce((Physics.gravity * 2f) * Time.fixedDeltaTime, ForceMode.Acceleration);
                }

                _avgTerrainHeight = Mathf.Lerp(_avgTerrainHeight, TerrainMeta.HeightMap.GetHeight(_tr.position), Time.fixedDeltaTime * 20f);
                if (_tr.position.y > _avgTerrainHeight + Configuration.MaximumCruiseHeight)
                {
                    if (_rb.velocity.y > 0)
                    {
                        Vector3 velocity = _rb.velocity;
                        velocity.y = 0;
                        _rb.velocity = velocity;
                    }
                }

                UpdateNetworkGroup();
            }

            private void OnCollisionEnter(Collision collision)
            {
                _lastCollision = TimeEx.currentTimestamp;
                float magnitude = collision.relativeVelocity.magnitude;
                if (magnitude > Configuration.HurtVelocityThreshold)
                {
                    float damageAmount = (magnitude / Configuration.HurtVelocityThreshold) * Configuration.HurtDamagePower;

                    float healthFraction = (Drone.Health() - damageAmount) / Drone.MaxHealth();
                    if (healthFraction < 0)
                    {
                        Controller.ChatMessage(GetMessage("Notification.Destroyed", Controller.userID));

                        _killOnDestroy = true;

                        Destroy(this);
                        return;
                    }
                    else if (healthFraction < DRONE_DISABLE_HEALTH_FRACTION)
                    {
                        Controller.ChatMessage(GetMessage("Notification.TooMuchDamage", Controller.userID));
                        Destroy(this);
                        return;
                    }
                    else Drone.Hurt(damageAmount, Rust.DamageType.Collision);
                }

                _rb.velocity = Vector3.Reflect(_rb.velocity, collision.contacts[0].normal);
            }

            private void OnCollisionStay()
            {
                _lastCollision = TimeEx.currentTimestamp;
            }

            private void UpdateNetworkGroup()
            {
                Network.Visibility.Group group = Net.sv.visibility.GetGroup(_tr.position);
                if (_mountPoint.net.group != group)
                    _mountPoint.net.SwitchGroup(group);

                if (Controller.net.group != group)
                    Controller.net.SwitchGroup(group);
            }

            private struct DroneInputState
            {
                public Vector3 movement;

                public float throttle;

                public void Reset()
                {
                    movement = Vector3.zero;                    
                }
            }
        }
        #endregion

        #region Chat Commands
        [ChatCommand("drone")]
        private void GiveDrone(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, CREATE_PERMISSION))
            {
                player.ChatMessage(Message("Error.NoPermission", player.userID));
                return;
            }            
            
            double nextUse;
            if (_cooldownTimes.TryGetValue(player.userID, out nextUse) && nextUse > Time.time)
            {
                player.ChatMessage(string.Format(Message("Error.Cooldown", player.userID), FormatTime(nextUse - Time.time)));
                return;
            }

            if (Configuration.Cost > 0 && !permission.UserHasPermission(player.UserIDString, IGNORE_COST_PERMISSION))
            {
                const int SCRAP_ID = -932201673;

                if (player.inventory.GetAmount(SCRAP_ID) < Configuration.Cost)
                {
                    player.ChatMessage(string.Format(Message("Error.InsufficientFunds", player.userID), Configuration.Cost));
                    return;
                }

                player.inventory.Take(null, SCRAP_ID, Configuration.Cost);
            }

            if (!permission.UserHasPermission(player.UserIDString, IGNORE_COOLDOWN_PERMISSION))
                _cooldownTimes[player.userID] = Time.time + Configuration.CooldownTime;

            const string DRONE_ITEM = "drone";            
            player.GiveItem(ItemManager.CreateByName(DRONE_ITEM), BaseEntity.GiveItemReason.PickedUp);
        }
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Vertical acceleration speed")]
            public float AltitudeAcceleration { get; set; }

            [JsonProperty(PropertyName = "Horizontal acceleration speed")]
            public float MovementAcceleration { get; set; }

            [JsonProperty(PropertyName = "Yaw speed")]
            public float YawSpeed { get; set; }

            [JsonProperty(PropertyName = "The speed that the drone will return to a levelled rotation after leaning")]
            public float UprightSpeed { get; set; }

            [JsonProperty(PropertyName = "Lean weight (how much the drone leans in to movement) (0.0 -> 1.0)")]
            public float LeanWeight { get; set; }

            [JsonProperty(PropertyName = "Lean max velocity (the maximum velocity for full lean)")]
            public float LeanMaxVelocity { get; set; }

            [JsonProperty(PropertyName = "The impact speed before damage is applied")]
            public float HurtVelocityThreshold { get; set; }

            [JsonProperty(PropertyName = "The amount of damage to apply from impacts (scales depending on speed)")]
            public float HurtDamagePower { get; set; }

            [JsonProperty(PropertyName = "The amount of time to disable the drone controls after a collision (seconds)")]
            public float CollisionDisableTime { get; set; }

            [JsonProperty(PropertyName = "Maximum cruising height above terrain")]
            public float MaximumCruiseHeight { get; set; }

            [JsonProperty(PropertyName = "Drone should autohover and not be affected by gravity when no user input is detected")]
            public bool AutoHover { get; set; }

            [JsonProperty(PropertyName = "Drone damage scaler (does not affect collision damage)")]
            public float DamageScale { get; set; }

            [JsonProperty(PropertyName = "The cooldown time on using the /drone command (seconds)")]
            public int CooldownTime { get; set; }

            [JsonProperty(PropertyName = "The scrap cost associated with using the /drone command")]
            public int Cost { get; set; }

            public Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                AltitudeAcceleration = 20f,
                MovementAcceleration = 15f,
                YawSpeed = 6f,
                UprightSpeed = 2f,
                LeanWeight = 0.35f,
                LeanMaxVelocity = 6f,
                HurtVelocityThreshold = 3f,
                HurtDamagePower = 3f,
                CollisionDisableTime = 0.25f,
                MaximumCruiseHeight = 30f,
                AutoHover = false,
                DamageScale = 5f,
                CooldownTime = 3600,
                Cost = 0,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (Configuration.Version < new Core.VersionNumber(1, 0, 1))
            {
                Configuration.AutoHover = false;
                Configuration.DamageScale = 5f;
                Configuration.CooldownTime = 3600;
                Configuration.Cost = 0;
            }

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Localization
        public string Message(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId != 0U ? playerId.ToString() : null);

        private static Func<string, ulong, string> GetMessage;

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Notification.TooMuchDamage"] = "This drone is too damaged to fly. Repair it to continue use",
            ["Notification.WaterDamage"] = "Drones can't swim... n00b",
            ["Notification.WaterLogged"] = "Your drone is water logged and is unable to fly",
            ["Notification.Destroyed"] = "Your drone has been destroyed",
            ["Notification.Controls"] = "<size=18><color=#ffa500>COBALT DRONE</color></size><size=14> - <color=#ce422b>Controls</color></size>\nForward/BackwardLeft/Right - Movement\nSprint/Duck - Ascend/Descend\nJump - Exit controls",
            ["Error.HasMountedOrParented"] = "You can't place drone while mounted or parented",
            ["Error.NoFlyPermissions"] = "You do not have permission to fly drones",
            ["Error.NoPermission"] = "You do not have permission to use this command",
            ["Error.NoTP"] = "Teleportation is disabled while flying drones",
            ["Error.Cooldown"] = "You have a cooldown period of <color=#ce422b>{0}</color> remaining before you can use this ocmmand again",
            ["Error.InsufficientFunds"] = "This command costs <color=#ce422b>{0} scrap</color> to use"
        };
        #endregion
    }
}

// --- End of file: DronePilot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/devils-island ---
// --- Original File Path: D/DevilsIsland/DevilsIsland.cs ---

﻿using DevilsIsland;
using JetStream;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Devil's Island", "Nick Holmes/Default", "0.8.0", ResourceId = 1372)]
    [Description("Devil's Island Game Mode")]
    public class DevilsIsland : GameModePlugin<DevilsIslandConfig, DevilsIslandState>
    {
        private ILocator liveLocator = null;
        private ILocator locator = null;
        private bool Changed = false;

        protected override void Initialize()
        {

            LoadMessages();
            LoadVariables();

            int worldSize = ConVar.Server.worldsize;

            liveLocator = new RustIOLocator(worldSize);
            locator = new LocatorWithDelay(liveLocator, 60);
            
            if(GameConfig.IsBossPositionNotifierEnabled)
                Timers.Add("AdviseBossPosition", timer.Repeat(GameConfig.BossPositionNotifierInterval, 0, () => AdviseBossPosition()));
            
            if(GameConfig.IsHelpNotiferEnabled)
                Timers.Add("HelpNotifier", timer.Repeat(GameConfig.HelpNotifierInverval, 0, () => AdviseRules()));

            Timers.Add("BossPromote", timer.Repeat(30, 0, () => TryForceBoss()));
        }

        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [""] = "",
                [""] = "",
                [""] = "",
                [""] = "",
                [""] = ""
            }, this);
        }

        void LoadVariables()
        {
            

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        #region Timers and Events

        // AdviceBossPosition is called every n seconds, and updates all played on the current
        // location of the Boss.This is intended to be a negative aspect of being the Boss.
        // If there is no Boss, players are reminded how to become the Boss.
        // TODO: If there is no Boss, after x minutes, just promote someone.
        void AdviseBossPosition()
        {
            if (State.BossExists())
            {
                bool moved;
                string bossCoords = locator.GridReference(State.Boss, out moved);

                if (moved)
                    PrintToChat(Text.Broadcast_BossLocation_Moved, State.BossName, bossCoords);
                else
                    PrintToChat(Text.Broadcast_BossLocation_Static, State.BossName, bossCoords);
            }
            else
                PrintToChat(Text.Broadcast_ClaimAvailable);
        }

        // AdviseRules is called every m seconds, and reminds players where they can find the
        // Game Mode rules. Useful at the moment, but probably a bit annoying in the long term
        public void AdviseRules()
        {
            PrintToChat(Text.Broadcast_HelpAdvice);
        }

        public void TryForceBoss()
        {
            if (State.NoBoss() && State.TryForceNewBoss())
                PrintToChat("{0} has been made the new Boss. Kill him!", State.BossName);
        }

        #endregion

        #region Player Commands
        [ChatCommand("rules")]
        void RulesCommand(BasePlayer player, string command, string[] args)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine(Text.Synopsis);
            sb.AppendLine();
            sb.AppendLine(Text.PlayerCommandSection);
            sb.AppendLine(Text.StatusCommandHint);
            sb.AppendLine(Text.ClaimCommandHint);
            sb.AppendLine(Text.RebelCommandHint);
            sb.AppendLine(Text.WhereCommandHint);
            sb.AppendLine();
            sb.AppendLine(Text.BossCommandSection);
            sb.AppendLine(Text.TaxCommandHint);
            sb.AppendLine(Text.LootCommandHint);
            sb.AppendLine(Text.RecruitCommandHint);
            sb.AppendFormat(Text.heliStrikeCommandHint, GameConfig.HeliStrikePrice_Quantity, GameConfig.heliStrikePrice_ItemDef.displayName.english);
            sb.AppendLine();
            sb.AppendLine();
            sb.AppendLine("Outlaw Commands:");
            sb.AppendFormat("<color=lime>/decoy <i>player</i></color> For a few minutes, the Boss sees <i>player</i>'s location, instead of yours. Costs {0} {1}", GameConfig.DecoyPrice_Quantity, GameConfig.heliStrikePrice_ItemDef.displayName.english);
            PrintToChat(player, sb.ToString());
        }

        // StatusCommand implements the "/status" player command. The purpose of this
        // command is simple to show users their current status, and some global status that
        // is relevent to them. Also, it should remind players of any other commands they can
        // currently use.
        [ChatCommand("status")]
        void StatusCommand(BasePlayer player, string command, string[] args)
        {
            StringBuilder sb = new StringBuilder();
            bool moved;

            string bossName = State.NoBoss() ? Text.NoBoss : State.BossName;
            string bossCoords = State.NoBoss() ? "err, nowhere!" : locator.GridReference(State.Boss, out moved);

            if (State.IsBoss(player))
            {
                sb.AppendLine(Text.YouAreTheBoss);
                sb.AppendFormat(Text.TaxRate, State.TaxRate * 100f);

                sb.AppendLine();
                if (State.Outlaws.Any())
                {
                    sb.AppendLine("Outlaws:");
                    foreach (Outlaw outlaw in State.Outlaws.All())
                    {
                        string location = locator.GridReference(outlaw.GetEffectiveTarget(), out moved);
                        sb.AppendFormat("{0}", outlaw.Player.displayName);
                        if(moved)
                            sb.AppendFormat(" on the move at {0}\n", location);
                        else
                            sb.AppendFormat(" loitering at {0}\n", location);
                    }
                }
                else
                    sb.AppendLine("There are currenly no Outlaws");

                sb.AppendLine();
                if (State.Henchmen.Any())
                {
                    sb.AppendLine("Henchmen:");
                    foreach (Henchman henchman in State.Henchmen.All())
                    {
                        string location = locator.GridReference(henchman.Player, out moved);
                        sb.AppendFormat("{0}", henchman.Player.displayName);
                        if (moved)
                            sb.AppendFormat(" on the move at {0}\n", location);
                        else
                            sb.AppendFormat(" loitering at {0}\n", location);
                    }
                }
                else
                    sb.AppendLine("You have no henchmen, you can /recruit some");
            }
            else if (State.Henchmen.Contains(player))
            {
                sb.AppendLine("<color=red><size=17>You are a Henchman</size></color>");

                sb.AppendLine();
                if (State.Outlaws.Any())
                {
                    sb.AppendLine("Outlaws:");
                    foreach (Outlaw outlaw in State.Outlaws.All())
                    {
                        string location = locator.GridReference(outlaw.GetEffectiveTarget(), out moved);
                        sb.AppendFormat("{0}", outlaw.Player.displayName);
                        if (moved)
                            sb.AppendFormat(" on the move at {0}\n", location);
                        else
                            sb.AppendFormat(" loitering at {0}\n", location);
                    }
                }
                else
                    sb.AppendLine("There are currenly no Outlaws");

                sb.AppendLine();
                if (State.Henchmen.All().Where(h => h.Player != player).Any())
                {
                    sb.AppendLine("Follow Henchmen:");
                    foreach (Henchman henchman in State.Henchmen.All().Where(h => h.Player != player))
                    {
                        string location = locator.GridReference(henchman.Player, out moved);
                        sb.AppendFormat("{0}", henchman.Player.displayName);
                        if (moved)
                            sb.AppendFormat(" on the move at {0}\n", location);
                        else
                            sb.AppendFormat(" loitering at {0}\n", location);
                    }
                }
                else
                    sb.AppendLine("You are the only henchman");
            }
            else
            {
                if (State.Outlaws.Contains(player))
                    sb.AppendLine(Text.YouAreAnOutlaw);

                sb.AppendFormat(Text.TaxRate, State.TaxRate * 100f);
                sb.AppendLine();

                if (State.BossExists())
                {
                    
                    sb.AppendFormat(Text.CurrentBoss, bossName, bossCoords);
                    if (State.LootContainer != null)
                    {
                        sb.AppendFormat(Text.CurrentTaxBox, locator.GridReference(State.LootContainer, out moved));
                        sb.AppendLine();
                    }

                    if (State.Henchmen.Any())
                    {
                        sb.AppendLine("Henchmen:");
                        foreach (Henchman henchman in State.Henchmen.All())
                        {
                            string location = locator.GridReference(henchman.Player, out moved);
                            sb.AppendFormat("{0}", henchman.Player.displayName);
                            if (moved)
                                sb.AppendFormat(" on the move at {0}\n", location);
                            else
                                sb.AppendFormat(" up to no good at {0}\n", location);
                        }
                    }
                    else
                        sb.AppendLine("There are currenly no Henchmen");

                }
                else
                    sb.AppendFormat(Text.NoBoss);               
            }

            PrintToChat(player, sb.ToString());
        }

        // ClaimCommon implements the "/claim" player command. This allows any player to become
        // the Boss, if there currently is none. Command has no effect if is already a Boss.
        [ChatCommand("claim")]
        void ClaimCommand(BasePlayer player, string command, string[] args)
        {
            if (GuardAgainst(() => State.IsBoss(player), player, Text.Error_YourAreBoss)
            || GuardAgainst(() => State.BossExists(), player, Text.Error_OtherIsBoss, State.BossName))
                return;

            State.SetBoss(player);  
            PrintToChat(player, Text.Success_WelcomeNewBoss);
            PrintToChat(Text.Broadcast_FirstBoss, State.BossName);
        }

        // LootCommand implements the "/loot" player command. This command allows the Boss
        // to designate which storage box he wants his taxes paying into. 
        [ChatCommand("loot")]
        void LootCommand(BasePlayer player, string command, string[] args)
        {
            if(GuardAgainst(() => State.NoBoss(), player, Text.Error_Loot_NoBoss)
            || GuardAgainst(() => State.IsNotBoss(player), player, Text.Error_Loot_NotBoss, State.BossName))
                return;

            RaycastHit hit;
            StorageContainer targetBox = null;
            if (Physics.Raycast(player.eyes.HeadRay(), out hit, 10f))
                targetBox = hit.GetEntity().GetComponent<StorageContainer>();

            if (targetBox != null && targetBox.GetType() == typeof(BoxStorage))
            {
                State.LootContainer = targetBox;
                PrintToChat(player, Text.Success_Looting);
                return;
            }

            if (targetBox != null && targetBox.GetType() == typeof(StorageContainer))
            {
                State.LootContainer = targetBox;
                PrintToChat(player, Text.Success_Looting);
            }
            else
                PrintToChat(player, "Stand close to, and look directly at, the storage box you want your taxes paying into.");
        }

        [ChatCommand("heli")]
        void HeliCommmand(BasePlayer player, string command, string[] args)
        {
            if (GuardAgainst(() => State.IsNotBoss(player), player, "You aren't the boss")
             || GuardAgainst(() => args.Length != 1, player, "Usage '/heli player' where player can also be partial name")
             || GuardAgainst(() => !State.Outlaws.HasMatchByPartialName(args[0]), player, "player \"{0}\" not found, or ambiguous", args[0])
             || GuardAgainst(() => State.CanNotAffordheliStrike(player), player, "Ordering a heli strike costs {0} {1}", GameConfig.HeliStrikePrice_Quantity, GameConfig.heliStrikePrice_ItemDef.displayName.english))
                return;

            int heliCount = UnityEngine.Object.FindObjectsOfType<BaseHelicopter>().Count();
            if(heliCount >= GameConfig.Maxhelis)
            {
                PrintToChat(player, "Insufficient airspace for more than {0} helicopters, please wait for existing patrols to complete", GameConfig.Maxhelis);
                return;
            }

            State.OrderheliStrike(args[0]);
            PrintToChat(player, "The heli is inbound");
        }

        [ChatCommand("decoy")]
        void DecoyCommmand(BasePlayer player, string command, string[] args)
        {
            if (GuardAgainst(() => !State.Outlaws.Contains(player), player, "You aren't an outlaw")
             || GuardAgainst(() => args.Length != 1, player, "Usage '/decoy player' where player can also be partial name")
             || GuardAgainst(() => State.PlayerGoodMatch(args[0]), player, "player \"{0}\" not found, or ambiguous", args[0])
             || GuardAgainst(() => !State.CanAffordDecoy(player), player, "Decoying costs {0} {1}", GameConfig.DecoyPrice_Quantity, GameConfig.DecoyPrice_ItemId.displayName.english))
                return;

            State.Decoy(player, args[0]);
            PrintToChat(player, "You now have a decoy. Only you know this");
        }

        [ChatCommand("tax")]
        void SetTaxCommmand(BasePlayer player, string command, string[] args)
        {
            if (GuardAgainst(() => State.NoBoss(), player, Text.Error_TaxChange_NoBoss)
             || GuardAgainst(() => State.IsNotBoss(player), player, Text.Error_TaxChange_NotBoss, State.BossName)
             || GuardAgainst(() => args.Length != 1, player, Text.Error_TaxChange_BadArgs))
                return;

            float newTaxRate = 0;

            if (float.TryParse(args[0], out newTaxRate))
            {
                newTaxRate /= 100;
                newTaxRate = Math.Max(0.03f, Math.Min(0.45f, newTaxRate));

                bool increased = (newTaxRate > State.TaxRate);

                State.TaxRate = newTaxRate;

                if (increased)
                    PrintToChat(Text.Broadcast_TaxIncrease, State.BossName, State.TaxRate * 100);
                else
                    PrintToChat(Text.Broadcast_TaxDecrease, State.BossName, State.TaxRate * 100);
            }
            else
                PrintToChat(player, Text.Error_TaxChange_BadArgs);
        }

        [ChatCommand("where")]
        void WhereCommand(BasePlayer player, string command, string[] args)
        {
            bool moved;
            PrintToChat(player, Text.YourLocation, liveLocator.GridReference(player, out moved));
        }

        [ChatCommand("rebel")]
        void RebelCommand(BasePlayer player, string command, string[] args)
        {
            if(GuardAgainst(() => State.IsBoss(player), player, Text.Error_Rebel_IsTheBoss)
            || GuardAgainst(() => State.Outlaws.Contains(player), player, Text.Error_Rebel_IsAlreadyOutlaw))
                return;

            State.Outlaws.Add(player);
            PrintToChat(Text.Broadcast_NewOutlaw, player.displayName);
        }

        [ChatCommand("recruit")]
        void RecruitCommand(BasePlayer player, string command, string[] args)
        {
            if(GuardAgainst(() => !State.IsBoss(player), player, "You need to be the Boss to recruit henchmen")
             || GuardAgainst(() => args.Length != 1, player, "Usage '/recruit player' where player can also be partial name")
             || GuardAgainst(() => State.PlayerGoodMatch(args[0]), player, "player \"{0}\" not found, or ambiguous", args[0]))
                return;

            BasePlayer recruit = State.TryRecruit(args[0]);
            if(recruit != null)
            {
                PrintToChat(State.Boss, "You have invited {0} to undergo recruitment.", recruit.displayName);
                PrintToChat(recruit, "Boss {0} offers you employment, it's up to you to <color=lime>/accept</color> it", State.BossName);
            }
        }

        [ChatCommand("accept")]
        void AcceptCommand(BasePlayer player, string command, string[] args)
        {
            if (GuardAgainst(() => !State.PendingRequest.Contains(player), player, "You have no pending recruitment requests"))
                return;

            if(State.TryPromote(player))
                PrintToChat(
                    "{0} passed the recruitment, and is now a henchman for {1}.", player.displayName, State.Boss.displayName);
        }

        #endregion

        #region Console Commands
        [ConsoleCommand("devilsisland.diagnostic")]
        private void DiagnosticCommand(ConsoleSystem.Arg arg)
        {
            PrintToConsole(arg.Player(), "Devil's Island version 0.7 ({0}.{1}.{2})", Version.Major, Version.Minor, Version.Patch);

            PrintToConsole(arg.Player(), "\nHenchmen:");
            foreach (Henchman h in State.Henchmen.All())
                PrintToConsole(arg.Player(), "\t{0}", h.Player.displayName);

            PrintToConsole(arg.Player(), "\n\nOutlaws:");
            foreach (Outlaw h in State.Outlaws.All())
                PrintToConsole(arg.Player(), "\t{0}", h.Player.displayName);
        }

        [ConsoleCommand("devilsisland.reset")]
        private void ResetCommand(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin)
            {
                PrintToConsole(arg.Player(), "Resetting Devil's Island Game State");
                State.SetBoss(null);
            }
        }
        #endregion

        #region Tax Resource Gathering
        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (player == null || State.IsBoss(player) || State.Outlaws.Contains(player) || State.Henchmen.Contains(player))
                return;

            State.CollectTaxFrom(item);
        }

        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            State.CollectTaxFrom(item);
        }

        #endregion

        #region Player Death

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            // Check to see if the LootContainer got destroyed
            StorageContainer container = entity as StorageContainer;
            if (container != null && State.LootContainer == container)
            {
                State.LootContainer = null;
                return;
            }
            
            BasePlayer victim = entity.ToPlayer();
            if (victim == null)
                return;

            BasePlayer attacker = null;
            if (info != null && info.Initiator != null)
                attacker = info.Initiator.ToPlayer();

            // Handle Boss Death
            if (State.IsBoss(victim))
            {
                // Killed by Player?
                if (attacker != null)
                {
                    if (State.IsBoss(attacker))
                    {
                        State.SetBoss(null);
                        PrintToChat(Text.Broadcast_BossSuicide, attacker.displayName);
                    }
                    else
                    {
                        State.SetBoss(attacker);
                        PrintToChat(Text.Broadcast_NewBoss, State.BossName, victim.displayName);
                    }
                }
                else
                {
                    PrintToChat("Boss {0} died foolishly. You can /claim the title.", State.BossName);
                    State.SetBoss(null);
                }
                return;
            }

            // Handle Outlaw Death
            if(State.Outlaws.Contains(victim) && State.IsBoss(attacker))
            {
                State.Outlaws.Remove(victim);
                PrintToChat("Boss {0} executed outlaw {1}. He died like the rebel dog he was.", State.BossName, victim.displayName);
                return;
            }

            // Handle Outlaw Death
            if (State.Outlaws.Contains(victim) && State.Henchmen.Contains(attacker))
            {
                State.Outlaws.Remove(victim);
                PrintToChat("Henchman {0} made the world a better place: outlaw {1} is worm food.", attacker.displayName, victim.displayName);
                return;
            }

            // Spice up murder, a little bit
            if(!State.Outlaws.Contains(victim) && !State.IsBoss(victim) && !State.Henchmen.Contains(victim)
                && attacker != null && !State.IsBoss(attacker) && !State.Outlaws.Contains(attacker) && !State.Henchmen.Contains(attacker)
                && attacker != victim)
            {
                State.Outlaws.Add(attacker);
                PrintToChat("{0} has embarked on a life of crime, and is now an Outlaw.", attacker.displayName);
                return;
            }
        }

        #endregion

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if(player == State.Boss && !GameConfig.AllowBossDisconnect)
            {
                PrintToChat("The Boss has been sacked for sleeping on the job, feel free to /claim it");
                State.SetBoss(null);
            }
        }

        #region Integration Point
        public BasePlayer Boss
        {
            get { return State.Boss; }
        }
        #endregion
    }
}

namespace DevilsIsland
{    
    public class DevilsIslandState : IGameState
    {
        public DevilsIslandState()
        {
            Outlaws = new Outlaws();
            Henchmen = new Henchmen();
            PendingRequest = new List<BasePlayer>();
        }
        
        public void AttachConfig(IGameConfig configFile)
        {
            this.config = (DevilsIslandConfig)configFile;
        }

        private DevilsIslandConfig config = null;
        
        private BasePlayer currentBoss = null;
        internal DateTime noBossSince = DateTime.Now;

        private float taxRate = 0.1f;
        private Dictionary<ItemDefinition, float> coffers = new Dictionary<ItemDefinition, float>();

        // Some of the method here might seem redundant (i.e. IsBoss, IsNotBoss), but their
        // purpose is to make the code more readable.

        #region Boss

        public bool NoBoss()
        {
            return currentBoss == null;
        }

        public bool BossExists()
        {
            return currentBoss != null;
        }

        public bool IsBoss(BasePlayer player)
        {
            return player == currentBoss;
        }

        public bool IsNotBoss(BasePlayer player)
        {
            return player != currentBoss;
        }

        public BasePlayer Boss { get { return currentBoss; } }

        public string BossName { get { return currentBoss == null ? "no boss" : currentBoss.displayName;  } }

        public void SetBoss(BasePlayer newBoss)
        {
            if(currentBoss != newBoss)
            {
                currentBoss = newBoss;
                if (currentBoss == null)
                    noBossSince = DateTime.Now;
                Outlaws.Clear();

                PendingRequest.Clear();

                foreach (Henchman hench in Henchmen.All())
                    hench.Player.inventory.Strip();

                Henchmen.Clear();
                LootContainer = null;
            }
        }

        public bool TryForceNewBoss()
        {
            if (BossExists() || BasePlayer.activePlayerList.Count() < config.AutoBossPromoteMinPlayers)
                return false;

            if(DateTime.Now > noBossSince.AddSeconds(config.AutoBossPromoteDelay))
            {                
                int newBossIndex = Oxide.Core.Random.Range(BasePlayer.activePlayerList.Count());
                SetBoss(BasePlayer.activePlayerList.Skip(newBossIndex).First());
                return true;
            }

            return false;
        }

        #endregion

        #region Tax

        public float TaxRate { get { return taxRate; } set { taxRate = value; } }

        public StorageContainer LootContainer { get; set; }

        public IEnumerable<ItemDefinition> CofferItems { get { return coffers.Keys.Where(k => coffers[k] >= 1); } }

        public float CofferAmount(ItemDefinition key)
        {
            return coffers[key];
        }

        public void CollectTaxFrom(Item item)
        {
            // Calculate the tax as floats, so we still get something when item amount is low.
            float taxAmount = ((float)item.amount * taxRate);

            item.amount -= (int)taxAmount;

            if (!coffers.ContainsKey(item.info))
                coffers.Add(item.info, 0);

            coffers[item.info] += taxAmount;

            int intAmount = (int)coffers[item.info];
            if(intAmount >= 1 && LootContainer != null)
            {
                Item taxItem = ItemManager.CreateByItemID(item.info.itemid, intAmount, 0);
                taxItem.MoveToContainer(LootContainer.inventory);
                coffers[item.info] -= (float)intAmount;
            }

        }
        #endregion

        #region heli Strikes

        public bool CanNotAffordheliStrike(BasePlayer player)
        {
            return player.inventory.GetAmount(config.heliStrikePrice_ItemDef.itemid) < config.HeliStrikePrice_Quantity;
        }

        public void  OrderheliStrike(string targetPartialName)
        {
            // Deduct the cost
            List<Item> collector = new List<Item>();
            currentBoss.inventory.Take(collector, config.heliStrikePrice_ItemDef.itemid, config.HeliStrikePrice_Quantity);

            // Call in the whirlibird
            Outlaw target;
            BaseEntity ent = GameManager.server.CreateEntity("assets/bundled/prefabs/npc/patrol_helicopter/PatrolHelicopter.prefab", new Vector3(), new Quaternion(), true);
            if (ent != null && Outlaws.TryResolveByPartialName(targetPartialName, out target))
            {
                ent.GetComponent<PatrolHelicopterAI>().SetInitialDestination(target.GetEffectiveTarget().transform.position + new Vector3(0.0f, 10f, 0.0f), 0.25f);
                ent.Spawn();
            }
        }

        #endregion

        #region Outlaws

        public Outlaws Outlaws { get; private set; }

        public bool CanAffordDecoy(BasePlayer player)
        {
            return player.inventory.GetAmount(config.DecoyPrice_ItemId.itemid) >= config.DecoyPrice_Quantity;
        }

        public void Decoy(BasePlayer player, string targetPartialName)
        {
            // Deduct the cost
            List<Item> collector = new List<Item>();
            player.inventory.Take(collector, config.DecoyPrice_ItemId.itemid, config.DecoyPrice_Quantity);

            // Set up the decoy
            BasePlayer target = BasePlayer.activePlayerList.Single(p => p.displayName.IndexOf(targetPartialName, StringComparison.InvariantCultureIgnoreCase) != -1);

            Outlaw source;
            if(Outlaws.TryResovleByPlayer(player, out source))
                source.SetDecoy(target, DateTime.Now.AddSeconds(300));
        }
        #endregion

        #region Henchmen

        public Henchmen Henchmen { get; private set; }
        public List<BasePlayer> PendingRequest { get; private set; }

        public BasePlayer TryRecruit(string playerPartialName)
        {
            if (BasePlayer.activePlayerList.Count(p => p.displayName.IndexOf(playerPartialName, StringComparison.InvariantCultureIgnoreCase) != -1) != 1)
                return null;

            BasePlayer recruit = BasePlayer.activePlayerList.Single(p => p.displayName.IndexOf(playerPartialName, StringComparison.InvariantCultureIgnoreCase) != -1);

            if (recruit == Boss || PendingRequest.Contains(recruit) || Henchmen.Contains(recruit))
                return null;

            PendingRequest.Add(recruit);
            return recruit;
        }

        public bool TryPromote(BasePlayer player)
        {
            if (PendingRequest.Contains(player))
                PendingRequest.Remove(player);

            if (Outlaws.Contains(player))
                Outlaws.Remove(player);

            if (!Henchmen.Contains(player))
            {
                Henchmen.Add(player);
                return true;
            }
            return false;
        }

        #endregion

        public bool PlayerGoodMatch(string playerPartialName)
        {
            return BasePlayer.activePlayerList.Count(p => p.displayName.IndexOf(playerPartialName, StringComparison.InvariantCultureIgnoreCase) != -1) != 1;
        }
    }

    #region Outlaws
    public class Outlaws
    {
        List<Outlaw> outlaws = new List<Outlaw>();

        public void Clear()
        {
            outlaws.Clear();
        }

        public void Add(BasePlayer newOutlaw)
        {
            outlaws.Add(new Outlaw(newOutlaw));
        }
        
        public void Remove(BasePlayer oldOutlaw)
        {
            Outlaw itemToRemove = outlaws.SingleOrDefault(o => o.Player == oldOutlaw);
            if (itemToRemove != null)
                outlaws.Remove(itemToRemove);
        }

        public bool Contains(BasePlayer player)
        {
            return outlaws.Any(o => o.Player == player);
        }

        public bool Any()
        {
            return outlaws.Any();
        }

        public IEnumerable<Outlaw> All()
        {
            return outlaws.AsReadOnly();
        }

        public bool TryResovleByPlayer(BasePlayer player, out Outlaw matchingOutlaw)
        {
            matchingOutlaw = outlaws.SingleOrDefault(o => o.Player == player);
            return (matchingOutlaw != null);
        }

        public bool HasMatchByPartialName(string partialName)
        {
            Outlaw match;
            return TryResolveByPartialName(partialName, out match);
        }

        public bool TryResolveByPartialName(string partialName, out Outlaw matchingOutlaw)
        {
            matchingOutlaw = outlaws.SingleOrDefault(o => o.Player.displayName.IndexOf(partialName, StringComparison.InvariantCultureIgnoreCase) != -1);
            return (matchingOutlaw != null);
        }
    }

    public class Outlaw
    {
        public Outlaw(BasePlayer player)
        {
            Player = player;
            decoyTarget = null;
            decoyUntil = DateTime.MinValue;
        }

        public BasePlayer Player { get; private set; }

        private BasePlayer decoyTarget;
        private DateTime decoyUntil;
        
        public void SetDecoy(BasePlayer player, DateTime until)
        {
            decoyTarget = player;
            decoyUntil = until;
        }

        public BasePlayer GetEffectiveTarget()
        {
            if (decoyTarget != null && decoyUntil >= DateTime.Now)
            {
                return decoyTarget;
            }
            else
                return Player;
        }
    }
    #endregion

    #region Henchmen
    public class Henchmen
    {
        List<Henchman> henchmen = new List<Henchman>();

        public void Clear()
        {
            henchmen.Clear();
        }

        public void Add(BasePlayer newHenchman)
        {
            henchmen.Add(new Henchman(newHenchman));
        }

        public void Remove(BasePlayer oldHenchman)
        {
            Henchman itemToRemove = henchmen.SingleOrDefault(o => o.Player == oldHenchman);
            if (itemToRemove != null)
                henchmen.Remove(itemToRemove);
        }

        public bool Contains(BasePlayer player)
        {
            return henchmen.Any(o => o.Player == player);
        }

        public bool Any()
        {
            return henchmen.Any();
        }

        public IEnumerable<Henchman> All()
        {
            return henchmen.AsReadOnly();
        }

        public bool TryResovleByPlayer(BasePlayer player, out Henchman matchingHenchman)
        {
            matchingHenchman = henchmen.SingleOrDefault(o => o.Player == player);
            return (matchingHenchman != null);
        }

        public bool HasMatchByPartialName(string partialName)
        {
            Henchman match;
            return TryResolveByPartialName(partialName, out match);
        }

        public bool TryResolveByPartialName(string partialName, out Henchman matchingHenchman)
        {
            matchingHenchman = henchmen.SingleOrDefault(o => o.Player.displayName.IndexOf(partialName, StringComparison.InvariantCultureIgnoreCase) != -1);
            return (matchingHenchman != null);
        }
    }

    public class Henchman
    {
        public Henchman(BasePlayer player)
        {
            Player = player;
        }

        public BasePlayer Player { get; private set; }
    }

    #endregion

    public class DevilsIslandConfig : IGameConfig
    {
        public void AttachConfigFile(DynamicConfigFile configFile)
        {
            this.configFile = configFile;
        }
        
        private DynamicConfigFile configFile;

        public void UpdateConfigFile()   //TODO Migrate to new/better configuration file method.
        {
            bool changed = false;
            changed |= DefaultValue("HelpNotifierEnabled", true);
            changed |= DefaultValue("HelpNotifierInverval", 300);
            changed |= DefaultValue("BossPositionNotifierEnabled", true);
            changed |= DefaultValue("BossPositionNotifierInterval", 90);
            changed |= DefaultValue("AutoBossPromoteDelay", 300);
            changed |= DefaultValue("AutoBossPromoteMinPlayers", 5);
            changed |= DefaultValue("HeliStrikePrice_Quantity", 25);
            changed |= DefaultValue("HeliStrikePrice_Item", "metal.refined");
            changed |= DefaultValue("MaxHelis", 2);
            changed |= DefaultValue("DecoyPrice_Quantity", 5);
            changed |= DefaultValue("DecoyPrice_Item", "metal.refined");
            changed |= DefaultValue("EvadePrice_Quantity", 100);
            changed |= DefaultValue("EvadePrice_Item", "leather");
            changed |= DefaultValue("FallbackWorldSize", 4000);
            changed |= DefaultValue("AllowBossDisconnect", false);

            if (changed)
                configFile.Save();
        }

        private bool DefaultValue(string key, object defaultValue)
        {
            if (configFile[key] == null)
            {
                configFile[key] = defaultValue;
                return true;
            }
            else
                return false;
        }

        public bool IsHelpNotiferEnabled { get { return (bool)configFile["HelpNotifierEnabled"]; } }
        public int HelpNotifierInverval { get { return (int)configFile["HelpNotifierInverval"]; } }
        
        public bool IsBossPositionNotifierEnabled { get { return (bool)configFile["BossPositionNotifierEnabled"]; } }
        public int BossPositionNotifierInterval { get { return (int)configFile["BossPositionNotifierInterval"]; } }
        
        public int AutoBossPromoteDelay { get { return (int)configFile["AutoBossPromoteDelay"]; } }
        public int AutoBossPromoteMinPlayers { get { return (int)configFile["AutoBossPromoteMinPlayers"]; } }

        private ItemDefinition heliStrikePriceItemDef;
        public ItemDefinition heliStrikePrice_ItemDef
        {
            get
            {
                if (heliStrikePriceItemDef == null) heliStrikePriceItemDef = FindOrDefault((string)configFile["heliStrikePrice_Item"], "metal.refined");
                return heliStrikePriceItemDef;
            }
        }
        public int HeliStrikePrice_Quantity { get { return (int)configFile["HeliStrikePrice_Quantity"]; } }

        public int Maxhelis { get { return (int)configFile["Maxhelis"]; } }

        private ItemDefinition decoyPriceItemDef;
        public ItemDefinition DecoyPrice_ItemId
        {
            get
            {
                if (decoyPriceItemDef == null) decoyPriceItemDef = FindOrDefault((string)configFile["DecoyPrice_Item"], "metal.refined");
                return decoyPriceItemDef;
            }
        }
        public int DecoyPrice_Quantity { get { return (int)configFile["DecoyPrice_Quantity"]; } }

        private ItemDefinition evadePriceItemDef;
        public ItemDefinition EvadePrice_ItemId
        {
            get
            {
                if (evadePriceItemDef == null) evadePriceItemDef = FindOrDefault((string)configFile["EvadePrice_Item"], "leather");
                return evadePriceItemDef;
            }
        }
        public int EvadePrice_Quantity { get { return (int)configFile["EvadePrice_Quantity"]; } }

        public int FallbackWorldSize { get { return (int)configFile["FallbackWorldSize"]; } }

        private static ItemDefinition FindOrDefault(string itemName, string fallbackName)
        {
            ItemDefinition def = ItemManager.FindItemDefinition(itemName);
            if (def == null) def = ItemManager.FindItemDefinition(fallbackName);
            return def;
        }

        public bool AllowBossDisconnect { get { return (bool)configFile["AllowBossDisconnect"];  } }
    }

    #region Player Grid Coordinates and Locators
    public interface ILocator
    {
        string GridReference(Component component, out bool moved);
    }

    public class RustIOLocator : ILocator
    {
        public RustIOLocator(int worldSize)
        {
            translate = worldSize / 2f;
            scale = worldSize / 26f;
        }

        private readonly float translate;
        private readonly float scale;

        public string GridReference(Component component, out bool moved)
        {
            var pos = component.transform.position;
            float x = pos.x + translate;
            float z = pos.z + translate;

            int lat = (int)Math.Floor(x / scale);
            char latChar = (char)('A' + lat);
            int lon = 26 - (int)Math.Floor(z / scale);

            moved = false; // We dont know, so just return false
            return string.Format("{0}{1}", latChar, lon);
        }
    }

    public class LocatorWithDelay : ILocator
    {
        public LocatorWithDelay(ILocator liveLocator, int updateInterval)
        {
            this.liveLocator = liveLocator;
            this.updateInterval = updateInterval;
        }

        private readonly ILocator liveLocator;
        private readonly int updateInterval;
        private readonly Dictionary<Component, ExpiringCoordinates> locations = new Dictionary<Component, ExpiringCoordinates>();

        public string GridReference(Component component, out bool moved)
        {
            ExpiringCoordinates item = null;
            bool m;

            if(locations.ContainsKey(component))
            {
                item = locations[component];
                if (item.Expires < DateTime.Now)
                {
                    string location = liveLocator.GridReference(component, out m);
                    item.GridChanged = item.Location != location;
                    item.Location = location;
                    item.Expires = DateTime.Now.AddSeconds(updateInterval);
                }
            }
            else
            {
                item = new ExpiringCoordinates();
                item.Location = liveLocator.GridReference(component, out m);
                item.GridChanged = true;
                item.Expires = DateTime.Now.AddSeconds(updateInterval);
                locations.Add(component, item);
            }

            moved = item.GridChanged;
            return item.Location;
        }
        
        class ExpiringCoordinates
        {
            public string Location { get; set; }
            public bool GridChanged { get; set; }
            public DateTime Expires { get; set; }
        }
    }
    #endregion

    public static class Text
    {
        public const string NoBoss = "There is no Boss - you can <color=lime>/claim</color> it\n";
        public const string YouAreTheBoss = "<color=red><size=17>You are the Boss</size></color>";
        public const string YouAreAnOutlaw = "<color=red><size=17>You are an Outlaw</size></color>";
        public const string CurrentBoss = "Current Boss: {0} at {1}\n";
        public const string CurrentTaxBox = "You can raid his tax box at {0}";
        public const string TaxRate = "Tax Rate: {0}%\n";
        public const string CofferItem = "\t{0}: {1}\n";
        public const string YourLocation = "You are at {0}";

        public const string Synopsis = "Devil's Island is controlled by one Boss. The Boss taxes gathering of resources, and everyone either pays up or kills him, or becomes an Outlaw";
        public const string PlayerCommandSection = "Player Commands:";
        public const string StatusCommandHint = "<color=lime>/status</color> displays your current status";
        public const string ClaimCommandHint = "<color=lime>/claim</color> if there is no Boss, you can take the job";
        public const string RebelCommandHint = "<color=lime>/rebel</color> makes you an outlaw - you don't pay tax, but the Boss can find you";
        public const string WhereCommandHint = "<color=lime>/where</color> displays your coordinates using RustIO coordinates";
        public const string BossCommandSection = "Boss Commands:";
        public const string TaxCommandHint = "<color=lime>/tax n</color> sets the tax rate";
        public const string LootCommandHint = "<color=lime>/loot</color> while looking at a box. Collected taxes will then be paid into this box.";
        public const string heliStrikeCommandHint = "<color=lime>/heli <i>player</i></color> send a heli to <i>player</i>'s location. Costs {0} {1}";
        public const string RecruitCommandHint = "<color=lime>/recruit <i>player</i></color> invite <i>player</i> to be one of your henchmen";

        public const string Broadcast_ClaimAvailable = "No one is the Boss, use <color=lime>/claim</color> to become the Boss.";
        public const string Broadcast_HelpAdvice = "Confused? Type <color=lime>/rules</color> for help.";

        public const string Error_YourAreBoss = "You're already the Boss, dumbass";
        public const string Error_OtherIsBoss = "Kill the Boss ({0}) to become the Boss...";
        public const string Success_WelcomeNewBoss = "You are the Boss, for now. Use <color=lime>/loot</color> set set your tax storage box, and /tax to set the tax rate.";
        public const string Broadcast_FirstBoss = "{0} is now the new Boss. Kill him to become the Boss";

        public const string Error_Loot_NoBoss = "If you want the loot, use <color=lime>/claim</color> to become the Boss.";
        public const string Error_Loot_NotBoss = "You aren't the Boss. Kill {0} if you want the loot.";
        public const string Success_Looting = "Taxes will now be paid into this storage box.";

        public const string Error_TaxChange_NoBoss = "If you want to change the tax rate, use <color=lime>/claim</color> to become the Boss";
        public const string Error_TaxChange_NotBoss = "You aren't the Boss. Kill {0} if you want to change the tax rate";
        public const string Error_TaxChange_BadArgs = "usage: <color=lime>/tax n</color>, where n is between 3 and 45 percent.";
        public const string Broadcast_TaxIncrease = "The evil bastard {0} has increased your taxes to {1}%";
        public const string Broadcast_TaxDecrease = "{0} has lowered your taxes to {1}%";

        public const string Error_Rebel_IsTheBoss = "You're the Boss - you can't rebel against yourself!";
        public const string Error_Rebel_IsAlreadyOutlaw = "You're already on the Boss's shit list.";
        public const string Broadcast_NewOutlaw = "{0} no longer tolerates the Boss's greed, and refuses to pay tax. You can <color=lime>/rebel</color> too.";

        public const string Broadcast_BossSuicide = "Boss {0} could not take it any more. Use <color=lime>/claim</color> to become the new Boss";
        public const string Broadcast_NewBoss = "{0} killed {1} and is now the Boss. Kill him to become the Boss";

        public const string Broadcast_BossLocation_Moved = "Boss {0} is on the move, now at {1}.";
        public const string Broadcast_BossLocation_Static = "Boss {0} is camping out at {1}";
    }
}

namespace JetStream
{
    public class GameModePlugin<TConfig, TState> : RustPlugin
        where TConfig : IGameConfig, new()
        where TState : IGameState, new()
    {
        private Dictionary<string, Timer> timers = new Dictionary<string, Timer>();
        protected Dictionary<string, Timer> Timers { get { return timers;  } }

        protected TConfig GameConfig { get; private set; }
        protected TState State { get; private set; }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating default configuration file");
            GameConfig = new TConfig();
            GameConfig.AttachConfigFile(this.Config);
            GameConfig.UpdateConfigFile();
        }

        [HookMethod("OnServerInitialized")]
        void base_OnServerInitialized()
        {
            if (GameConfig == null)
            {
                GameConfig = new TConfig();
                GameConfig.AttachConfigFile(this.Config);
                GameConfig.UpdateConfigFile();
            }

            State = new TState();  
            State.AttachConfig(GameConfig);

            Initialize();
        }

        [HookMethod("Unload")]
        void base_Unload()
        {
            Puts("Unload called");
            
            foreach (Timer t in timers.Values)
                t.Destroy();

            timers.Clear();
        }

        protected virtual void Initialize()
        { }

        protected bool GuardAgainst(Func<bool> condition, BasePlayer player, string errorMsgFormat, params object[] args)
        {
            if (condition())
            {
                PrintToChat(player, errorMsgFormat, args);
                return true;
            }
            else
                return false;
        }
    }

    public interface IGameConfig
    {
        void AttachConfigFile(DynamicConfigFile configFile);
        void UpdateConfigFile();
    }

    public interface IGameState
    {
        void AttachConfig(IGameConfig configFile);
    }

}

// --- End of file: DevilsIsland.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-messages-chat ---
// --- Original File Path: D/DiscordMessagesChat/DiscordMessagesChat.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Discord Messages Chat", "Slut", "1.0.4")]
    [Description("Relay global / team chat to Discord!")]
    public class DiscordMessagesChat  : RustPlugin
    {
        #region Variables
        [PluginReference]
        private Plugin DiscordMessages, BetterChatMute;

        private bool _teamChatEnabled;
        private bool _globalChatEnabled;
        private readonly object _falseObject = false;
        

        #endregion

        #region Configuration
        
        private Configuration _configuration;
        private class Configuration
        {
            public string GlobalChatWebhook;
            public string TeamChatWebhook;
            public bool AllowMutedPlayers;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _configuration = Config.ReadObject<Configuration>();
            
            CheckWebhook(_configuration.GlobalChatWebhook, success =>
            {
                _globalChatEnabled = success;
                if (!_globalChatEnabled)
                {
                    PrintWarning("Global Chat Webhook is not correct!");
                }
            });
            CheckWebhook(_configuration.TeamChatWebhook, success =>
            {
                _teamChatEnabled = success;
                if (!_teamChatEnabled)
                {
                    PrintWarning("Team Chat Webhook is not correct!");
                }
            });
            
            SaveConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_configuration);
        }

        protected override void LoadDefaultConfig()
        {
            _configuration = new Configuration();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GlobalChatFormat"] = "[{time}] {username}: {message}",
                ["TeamChatFormat"] = "[TEAM] [{time}] {username}: {message}"
            }, this);
        }
        
        #endregion

        #region Hooks

        private void OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            if ((BetterChatMute?.Call<bool>("API_IsMuted", player.IPlayer) ?? false) && !_configuration.AllowMutedPlayers)
            {
                return;
            }
            if (channel == ConVar.Chat.ChatChannel.Team && !_teamChatEnabled)
            {
                return;
            }

            if (channel == ConVar.Chat.ChatChannel.Global && !_globalChatEnabled)
            {
                return;
            }

            message = message.Replace("@here", "@.here").Replace("@everyone", "@.everyone");
            string formattedMessage = lang.GetMessage(channel == ConVar.Chat.ChatChannel.Team ? "TeamChatFormat" : "GlobalChatFormat", this).Replace("{time}", DateTime.Now.ToShortTimeString()).Replace("{username}", player.displayName).Replace("{message}", message);
            
            DiscordMessages?.Call("API_SendTextMessage", channel == ConVar.Chat.ChatChannel.Team ? _configuration.TeamChatWebhook : _configuration.GlobalChatWebhook, formattedMessage, _falseObject, this);
        }        

        #endregion

        #region Functions

        private void CheckWebhook(string webhookUrl, Action<bool> success)
        {
            if (string.IsNullOrEmpty(webhookUrl))
            {
                success?.Invoke(false);
                return;
            }

            webrequest.Enqueue(webhookUrl, null, (code, response) =>
            {
                success?.Invoke(code == 200);
            }, this);
        }

        #endregion
    }
}

// --- End of file: DiscordMessagesChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/donation-credits ---
// --- Original File Path: D/DonateCredits/DonateCredits.cs ---

﻿using UnityEngine;
using System.Collections.Generic;
using System;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using System.Linq;
using Rust;
using System.Text;

using Oxide.Ext.SQLite;

namespace Oxide.Plugins
{
    [Info("DonateCredits", "OldeTobeh", "1.1.0")]
    [Description("Web based donation rewards, players can purchase rewards on website or in-game.")]
    
    class DonateCredits : RustPlugin
    {
        [PluginReference]
        private Plugin Economics;
        private Dictionary<ulong, double> Balances = new Dictionary<ulong, double>();
        private readonly Core.MySql.Libraries.MySql _mySql = Interface.Oxide.GetLibrary<Core.MySql.Libraries.MySql>();
        private Core.Database.Connection _mySqlConnection;
        //private Ext.MySql.Connection _mySqlConnection = null;
        public Dictionary<ulong, Dictionary<string, long>> playerList = new Dictionary<ulong, Dictionary<string, long>>();
        bool packetSent = false;
        private Timer _timer;
        
        // Do NOT edit this file, instead edit DonateCredits.json in oxide/config and DonateCredits.en.json in oxide/lang,
        // or create a language file for another language using the 'en' file as a default.
        //Add support for non-sql??
        
        #region Localization

        void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                {"CreditInfoChatCommand", "credits"},
                {"CreditRefreshChatCommand", "refreshcredits"},
                {"CreditGetChatCommand", "getcredits"},
                {"LoadAllPlayerCreditChatCommand", "loadcredits"},
                {"SaveAllPlayerCreditChatCommand", "savecredits"},
                {"CommandUsage", "<color=green>Donation Reward Commands:</color>\n<color=orange>/credits</color> - Displays your current donation rewards.\n<color=orange>/getcredits</color> - Gives you your current donation reward.\n<color=orange>/refreshcredits</color> - Reloads your donation rewards or you can simply reconnect."},
                {"RefreshCredits", "Shop Credits have been reloaded, type <color=orange>/credits</color> to see your Credit summary."},
                {"CreditAddFail", "You currently have no donation rewards.\nDonate today for Shop Credits on our website: <color=yellow>my.website.com</color>"},
                {"CreditAddSuccess", "You have been awarded <color=lime>${amount}.00</color> Shop Credits!!\nThank you so much for donating {playername}!!"},
                {"CreditInfo", "Donation Info for player: <color=cyan>{playername}</color>\n-> Donation Credits available: <color=lime>${amount}.00</color>\n-> Total Credits Claimed: <color=lime>${total_amount}.00</color>"},
                {"CreditInfoNoCredits", "Sorry, you don't seem to have any available donation rewards. Visit <color=yellow>my.website.com</color> to make a donation."},
                {"CreditInfoCreditsAvailable", "You have a donation reward waiting for you!\nType <color=orange>/getcredits</color> to claim your reward!"},
                {"LoadAllPlayers", "All players donation credits have been reloaded."},
                {"SaveAllPlayers", "All players donation credits have been saved."}
            };
            lang.RegisterMessages(messages, this);
        }

        #endregion
        
        #region Configuration
        
        string Address => GetConfig("address", "127.0.0.1");
        int Port => GetConfig("port", 3306);
        string dbName => GetConfig("db_name", "my_dbname");
        string User => GetConfig("user", "username");
        string Password => GetConfig("password", "password");
        
        protected override void LoadDefaultConfig()
        {
            Config["address"] = Address;
            Config["port"] = Port;
            Config["db_name"] = dbName;
            Config["user"] = User;
            Config["password"] = Password;
            SaveConfig();
        }
        
        #endregion
        
        #region Initialization
        
        private void StartConnection()
        {
            if (usingMySQL() && _mySqlConnection == null)
            {
                _mySqlConnection = _mySql.OpenDb(
                    Address, 
                    Port,
                    dbName, 
                    User,
                    Password, 
                    this);
                Puts("Connection opened.(MySQL)");
            }
        }
        
        #endregion


        #region Player Hooks

        public void loadUser(BasePlayer player)
        {
            packetSent = false;
            Dictionary<string, long> statsInit = new Dictionary<string, long>();
            statsInit.Add("amount", 0);
            statsInit.Add("total_amount", 0);

            if(usingMySQL())
            {
                var sql = Core.Database.Sql.Builder.Append("SELECT * FROM Donations WHERE steam_id = @0", player.userID);
                _mySql.Query(sql, _mySqlConnection, list =>
                {
                    initPlayer(player, statsInit, list);
                });
            }
            packetSent = true;
        }

        void initPlayer(BasePlayer player, Dictionary<string, long> statsInit, List<Dictionary<string, object>> sqlData)
        {

            bool needToSave = true;
            Dictionary<string, long> tempElement = new Dictionary<string, long>();
            if (sqlData.Count > 0)
            {
                
                foreach (string key in statsInit.Keys)
                {
                    if(sqlData[0][key] != DBNull.Value)
                        tempElement.Add(key, Convert.ToInt64(sqlData[0][key]));
                }
                needToSave = false;
            }
            
            foreach (var tempItem in tempElement){
              statsInit[tempItem.Key] = tempItem.Value;
            }
                
            
            initPlayerData(player, statsInit);
            
            if (needToSave)
            {
                saveUser(player);
                Puts(player.displayName +" Saved");
            }

            //RenderUI(player);
        }

        public void setPointsAndLevel(ulong steam_id, string skill, long quantity)
        {
            if (!playerList.ContainsKey(steam_id))
                playerList.Add(steam_id, new Dictionary<string, long>());
              
            setPlayerData(steam_id, skill, quantity);  //1200 BPs = 1 Library + 800 for donating (not yet functioning, 400 is default) (300 BPs = 1 Book)
              
        }
        
        void setPlayerData(ulong steam_id, string key, long value)
        {
            if (playerList[steam_id].ContainsKey(key))
                playerList[steam_id][key] = value;
            else
                playerList[steam_id].Add(key, value);
        }
        
        
        void initPlayerData(BasePlayer player, Dictionary<string, long> playerData)
        {
            foreach (var dataItem in playerData)
            {
              setPointsAndLevel(player.userID, dataItem.Key, dataItem.Value);
            }
        }
        
        public void saveUser(BasePlayer player)
        {
            if (!playerList.ContainsKey(player.userID))
            {
                Puts("Trying to save player, who haven't been loaded yet? Player name: " + player.displayName);
                return;
            }

            Dictionary<string, long> statsInit = getConnectedPlayerDetailsData(player.userID);

            string user = EncodeNonAsciiCharacters(player.displayName);
            //string user = player.displayName;
            string sqlText =
                "REPLACE INTO Donations (steam_id, user, amount, total_amount) " +
                "VALUES (@0, @1, @2, @3)";

            if (usingMySQL())
            {
                var sql = Core.Database.Sql.Builder.Append(sqlText, 
                    player.userID, //0
                    user, //1
                    statsInit["amount"], //2
                    statsInit["total_amount"]); //3
                _mySql.Insert(sql, _mySqlConnection, list =>
                {
                    if (list == 0) // Save to DB failed.
                        Puts("OMG WE DIDN'T SAVED IT!: " + sql.SQL);
                });
            }
        }
        
        public void rewardUser(BasePlayer player)
        {
            if (!playerList.ContainsKey(player.userID))
            {
                Puts("Trying to reward player, who haven't been loaded yet? Player name: " + player.displayName);
                return;
            }

            Dictionary<string, long> statsInit = getConnectedPlayerDetailsData(player.userID);

            string user = EncodeNonAsciiCharacters(player.displayName);
            string sqlText =
                "REPLACE INTO Donations (steam_id, user, amount, total_amount) " +
                "VALUES (@0, @1, 0, @2+@3)";
                
            //Econ Reward
            DepositPlayerMoney(player, statsInit["amount"]);
            
            if (usingMySQL())
            {
                var sql = Core.Database.Sql.Builder.Append(sqlText, 
                    player.userID, //0
                    user, //1
                    statsInit["amount"], //2
                    statsInit["total_amount"]); //3
                _mySql.Insert(sql, _mySqlConnection, list =>
                {
                    if (list == 0) // Save to DB failed.
                        Puts("OMG WE DIDN'T SAVED IT!: " + sql.SQL);
                });
            }
            
            //Reload Player
            reloadUser(player);
        }

        public void loadUsers()
        {
            foreach (var user in BasePlayer.activePlayerList)
            {
                reloadUser(user);
            }
            packetSent = false;
        }

        public void saveUsers()
        {
            foreach (var user in BasePlayer.activePlayerList)
            {
                saveUser(user);
            }
        }

        void reloadUser(BasePlayer player) {
            if (inPlayerList(player.userID))
            {
                if (playerList.ContainsKey(player.userID))
                    playerList.Remove(player.userID);
            }
            loadUser(player);
        }

        #endregion

        
        #region Commands

        void LoadCommand(BasePlayer player, string command, string[] args)
        {
            if (HasAccess(player) || HasPermission(player.UserIDString, "donatecredits.save"))
            {
                loadUsers();
                PrintToChat(player, GetMessage("LoadAllPlayers", player.UserIDString));
            } else {
                SendReply(player, "NoPermission");
                return;
            }
        }
        
        void SaveCommand(BasePlayer player, string command, string[] args)
        {
            if (HasAccess(player) || HasPermission(player.UserIDString, "donatecredits.save"))
            {
                saveUsers();
                PrintToChat(player, GetMessage("SaveAllPlayers", player.UserIDString));
            } else {
                SendReply(player, "NoPermission");
                return;
            }
        }
        
        void RefreshCommand(BasePlayer player, string command, string[] args)
        {
            reloadUser(player);
            PrintToChat(player, GetMessage("RefreshCredits", player.UserIDString));
            packetSent = false;
        }
        
        void DonationRewardCommand(BasePlayer player, string command, string[] args)
        {
            Puts("PacketInit." + packetSent);
            reloadUser(player);
            
            _timer = timer.Repeat(1, 0, () => {
                Puts("PacketSent." + packetSent);
                if (player != null && packetSent == true) {
                    var playername = player.displayName;
                    var playerData = getConnectedPlayerDetailsData(player.userID);
                    int amount = (int)playerData["amount"];
                    
                    packetSent = false;
                    
                    if(amount == 0){
                      PrintToChat(player, GetMessage("CreditAddFail", player.UserIDString));
                      _timer.Destroy();
                      return;
                    } else {
                      PrintToChat(player, GetMessage("CreditAddSuccess", player.UserIDString).Replace("{amount}", amount.ToString()).Replace("{playername}", playername.ToString()));
                      rewardUser(player);
                      _timer.Destroy();
                    }
                }
            });
        }
        
        void DonationsCommand(BasePlayer player, string command, string[] args)
        {
            Puts("PacketInit." + packetSent);
            reloadUser(player);
            
            _timer = timer.Repeat(1, 0, () => {
                Puts("PacketSent." + packetSent);
                if (player != null && packetSent == true)
                {
                    var playername = player.displayName;
                    var playerData = getConnectedPlayerDetailsData(player.userID);
                    int amount = (int)playerData["amount"];
                    int total_amount = (int)playerData["total_amount"];
                    
                    packetSent = false;
                    
                    if(playerData == null)
                        Puts("PlayerData IS NULL!!!");
                    
                    PrintToChat(player, GetMessage("CreditInfo", player.UserIDString).Replace("{amount}", amount.ToString()).Replace("{total_amount}", total_amount.ToString()).Replace("{playername}", playername.ToString()));
                    
                    if (amount > 0)
                        PrintToChat(player, GetMessage("CreditInfoCreditsAvailable", player.UserIDString));
                    if (amount == 0)
                        PrintToChat(player, GetMessage("CreditInfoNoCredits", player.UserIDString));
                    
                    _timer.Destroy();
                }
            });
        }
        
        #endregion
        
        #region Helper Methods
        
        bool usingMySQL()
        {
            return Convert.ToBoolean("True");
        }
        
        public Dictionary<string, long> getConnectedPlayerDetailsData(ulong steam_id)
        {
            if (!playerList.ContainsKey(steam_id))
                return null;
              
            Dictionary<string, long> statsInit = new Dictionary<string, long>();
            statsInit.Add("amount", playerList[steam_id]["amount"]);
            statsInit.Add("total_amount", playerList[steam_id]["total_amount"]);
            return statsInit;
        }
        
        static string EncodeNonAsciiCharacters(string value)
        {
            StringBuilder sb = new StringBuilder();
            foreach (char c in value)
            {
                if (c > 127)
                {
                    // This character is too big for ASCII
                    string encodedValue = "";
                    sb.Append(encodedValue);
                }
                else {
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }
        
        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            PrintToChat(player, GetMessage("CommandUsage", player.UserIDString));
        }
        
        private bool HasAccess(BasePlayer player)
        {
            return player.net?.connection?.authLevel >= 2;
        }
        
        bool HasPermission(string userId, string perm) => permission.UserHasPermission(userId, perm);

        string GetFormattedMoney(BasePlayer player)
        {
            string s = string.Format("{0:C}", (double)Economics?.Call("GetPlayerMoney", player.userID));
            s = s.Substring(1);
            s = s.Remove(s.Length - 3);
            return s;
        }
        
        private void DepositPlayerMoney(BasePlayer player, double money)
        {
            Economics?.Call("Deposit", player.userID, money);
        }
        
        private bool inPlayerList(UInt64 userID)
        {
            return playerList.ContainsKey(userID);

        }
        
        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
        
        string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);
        
        #endregion
        
        
        #region Server Hooks

        private void Loaded()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();
            StartConnection();
            loadUsers();
            
            cmd.AddChatCommand(GetMessage("CreditInfoChatCommand"), this, "DonationsCommand");
            cmd.AddChatCommand(GetMessage("CreditRefreshChatCommand"), this, "RefreshCommand");
            cmd.AddChatCommand(GetMessage("CreditGetChatCommand"), this, "DonationRewardCommand");
            cmd.AddChatCommand(GetMessage("LoadAllPlayerCreditChatCommand"), this, "LoadCommand");
            cmd.AddChatCommand(GetMessage("SaveAllPlayerCreditChatCommand"), this, "SaveCommand");
            
            permission.RegisterPermission("donatecredits.load", this);
            permission.RegisterPermission("donatecredits.save", this);
        }
        
        private void Unload()
        {
            if (_mySqlConnection != null)
                _mySqlConnection = null;
        }
        
        void OnPlayerInit(BasePlayer player)
        {
            loadUser(player);
            Puts("Loaded Credits for "+ player.displayName +"!!");
            packetSent = false;
        }
        
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (inPlayerList(player.userID))
            {
                if (playerList.ContainsKey(player.userID))
                    playerList.Remove(player.userID);
            }
            Puts(player.displayName +" Unloaded.");
        }

        void OnTimer()
        {
            Puts("Tick tock!");
            _timer.Destroy();
        }

        #endregion
        
    }
}

// --- End of file: DonateCredits.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/deforestation ---
// --- Original File Path: D/Deforestation/Deforestation.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System;
using UnityEngine;
using System.Collections.Generic;
using Newtonsoft.Json;
using static ConsoleSystem;

namespace Oxide.Plugins
{
    [Info("Deforestation", "Lincoln & redBDGR", "1.0.5")]
    [Description("Make trees fall over like a boss.")]

    class Deforestation : RustPlugin
    {
        private const string permUse = "deforestation.use";
        private const string permRadiusBypass = "deforestation.radiusbypass";
        private float radius;

        #region PluginConfig
        //Creating a config file
        private static PluginConfig config;
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Max Radius: ")] public int maxRadius { get; set; }
            [JsonProperty(PropertyName = "Number Of Tree Spawns: ")] public int numberOfTreesToSpawn { get; set; }


            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                maxRadius = 25,
                numberOfTreesToSpawn = 15
            };

        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created.");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        #endregion

        #region Helpers

        bool ValidationChecks(BasePlayer player, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permUse))
            {
                ChatMessage(player, "NoPerm");
                return true;
            }
            if (args.Length != 1)
            {
                ChatMessage(player, "Syntax");
                return true;
            }
            try
            {
                radius = Convert.ToSingle(args[0]);
            }
            catch
            {
                ChatMessage(player, "InvalidArg");
                return true;
            }
            if (!permission.UserHasPermission(player.UserIDString, permRadiusBypass))
            {
                if (radius > config.maxRadius || radius <= 0)
                {
                    ChatMessage(player, "Radius", config.maxRadius);
                    return true;
                }
            }
            return false;
        }

        #endregion

        #region Permissions
        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permRadiusBypass, this);
        }
        #endregion

        #region Commands

        [ChatCommand("counttrees")]
        private void CountTreesCMD(BasePlayer player, string command, string[] args)
        {
            if (ValidationChecks(player, args)) return;

            int treeCount = 0;
            RaycastHit[] hits = UnityEngine.Physics.SphereCastAll(player.transform.position, radius, Vector3.up);
            foreach (RaycastHit hit in hits)
            {
                TreeEntity tree = hit.GetEntity()?.GetComponent<TreeEntity>();
                if (tree) treeCount++;
            }

            ChatMessage(player, "TreeCount", treeCount, radius);
        }

        [ChatCommand("killtree")]
        private void TreeDeforestationCMD(BasePlayer player, string command, string[] args)
        {
            if (ValidationChecks(player, args)) return;


            RaycastHit[] hits = UnityEngine.Physics.SphereCastAll(player.transform.position, radius, Vector3.up);
            foreach (RaycastHit hit in hits)
            {
                TreeEntity tree = hit.GetEntity()?.GetComponent<TreeEntity>();
                if (!tree) continue;
                tree.OnDied(new HitInfo() { PointStart = player.transform.position, PointEnd = tree.transform.position });
            }
        }
        [ChatCommand("killbush")]
        private void BushDeforestationCMD(BasePlayer player, string command, string[] args)
        {

            if (ValidationChecks(player, args)) return;

            RaycastHit[] hits = UnityEngine.Physics.SphereCastAll(player.transform.position, radius, Vector3.up);
            foreach (RaycastHit hit in hits)
            {
                BushEntity bush = hit.GetEntity()?.GetComponent<BushEntity>();
                if (bush) bush.Kill();
            }
        }

        [ChatCommand("growtree")]
        private void TreeGrowCMD(BasePlayer player, string command, string[] args)
        {
            if (ValidationChecks(player, args)) return;

            float radius;
            if (!float.TryParse(args[0], out radius))
            {
                player.ChatMessage("Invalid radius value.");
                return;
            }

            int numberOfTrees = config.numberOfTreesToSpawn;
            List<Vector3> treePositions = new List<Vector3>();

            for (int i = 0; i < numberOfTrees; i++)
            {
                Vector3 randomPosition = GetRandomPositionWithinRadius(player.transform.position, radius);
                float terrainHeight = TerrainMeta.HeightMap.GetHeight(randomPosition);
                randomPosition.y = terrainHeight + 100f; // Cast the ray from a higher position
                RaycastHit[] hits = UnityEngine.Physics.RaycastAll(randomPosition, Vector3.down, 200f);
                bool suitablePosition = false;

                foreach (RaycastHit hit in hits)
                {
                    if (hit.collider.gameObject.layer == LayerMask.NameToLayer("Terrain"))
                    {
                        //get terrain type at position
                        TerrainBiome.Enum biome = (TerrainBiome.Enum)TerrainMeta.BiomeMap.GetBiome(randomPosition, 3);
                        player.ChatMessage(biome.ToString());

                        randomPosition.y = hit.point.y;
                        suitablePosition = true;
                        break;
                    }
                }

                if (suitablePosition)
                {
                    treePositions.Add(randomPosition);
                }
                else
                {
                    i--;
                }
            }

            foreach (Vector3 position in treePositions)
            {
                SpawnTree(position);
            }
        }

        private Vector3 GetRandomPositionWithinRadius(Vector3 center, float radius)
        {
            float randomAngle = UnityEngine.Random.Range(0f, 360f);
            float randomDistance = UnityEngine.Random.Range(0f, radius);

            Vector3 direction = new Vector3(Mathf.Sin(randomAngle), 0f, Mathf.Cos(randomAngle));
            Vector3 position = center + direction * randomDistance;

            return position;
        }

        private void SpawnTree(Vector3 position)
        {
            string treePrefab = "assets/bundled/prefabs/autospawn/resource/v3_tundra_forestside/pine_b.prefab";
            TreeEntity tree = GameManager.server.CreateEntity(treePrefab, position, new Quaternion(), true) as TreeEntity;
            tree.Spawn();
        }

        #endregion

        #region Localization
        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TreeCount"] = "<color=#ffc34d>Deforestation</color>: There are {0} trees within a {1} meter radius of you.",
                ["Radius"] = "<color=#ffc34d>Deforestation</color>: Invalid radius. Please choose a radius between 1 and {0}",
                ["NoPerm"] = "<color=#ffc34d>Deforestation</color>: You don't have permission to use that.",
                ["Syntax"] = "<color=#ffc34d>Deforestation</color>: Invalid syntax! Type /killtree or /killbush <radius>",
                ["InvalidArg"] = "<color=#ffc34d>Deforestation</color>: Invalid argument! Make sure the radius is a whole number!",

            }, this, "en");
        }
        #endregion

        private void Unload()
        {
            config = null;
        }
    }
}


// --- End of file: Deforestation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/drone-effects ---
// --- Original File Path: D/DroneEffects/DroneEffects.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Drone Effects", "WhiteThunder", "1.0.3")]
    [Description("Adds collision effects and propeller animations to RC drones.")]
    internal class DroneEffects : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private Plugin BetterDroneCollision;

        private static DroneEffects _pluginInstance;
        private static Configuration _pluginConfig;

        private const string DeliveryDronePrefab = "assets/prefabs/misc/marketplace/drone.delivery.prefab";

        private const float CollisionDistanceFraction = 0.25f;

        private bool _usingCustomCollisionListener = false;

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginInstance = this;

            if (!_pluginConfig.DeathEffect.Enabled
                || string.IsNullOrEmpty(_pluginConfig.DeathEffect.EffectPrefab))
            {
                Unsubscribe(nameof(OnEntityDeath));
            }

            if (!_pluginConfig.Animation.Enabled)
            {
                Unsubscribe(nameof(OnBookmarkControlStarted));
                Unsubscribe(nameof(OnBookmarkControlEnded));
                Unsubscribe(nameof(OnDroneControlStarted));
                Unsubscribe(nameof(OnDroneCon