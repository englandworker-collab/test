ll type due to path components: {cellName}");
        Pool.FreeUnmanaged(ref stringBuilder);
        return "";
      }
      var upwards = "tunnel-upwards" == slashSplit[4];
      var dashSplit = slashSplit[5].Split("-");
      if (dashSplit.Length < 2)
      {
        PrintDebug($"Skipping unsupported DungeonGridCell type due to name components: {cellName}");
        Pool.FreeUnmanaged(ref stringBuilder);
        return "";
      }
      // extract feature part of name
      var feature = slashSplit[5];
      if (upwards)
      {
        stringBuilder.Append(" Upwards");
      }
      else if (feature.StartsWith("curve"))
      {
        stringBuilder.Append(" Curve");
      }
      else if (feature.StartsWith("intersection"))
      {
        stringBuilder.Append(" Intersection");
      }
      else if (feature.StartsWith("station"))
      {
        stringBuilder.Append(" Station");
      }
      else if (feature.StartsWith("straight"))
      {
        stringBuilder.Append(" Straight");
      }
      else if (feature.StartsWith("transition"))
      {
        stringBuilder.Append(" Transition");
      }
      else
      {
        PrintDebug($"Skipping unsupported DungeonGridCell type due to feature component '{feature}': {cellName}");
        Pool.FreeUnmanaged(ref stringBuilder);
        return "";
      }
      // extract direction part of name
      var direction =
        dashSplit[upwards ? dashSplit.Length - 1 : 1].Split(".")[0];
      switch (direction)
      {
        case "e":  stringBuilder.Append(" East");        break;
        case "n":  stringBuilder.Append(" North");       break;
        case "ne": stringBuilder.Append(" North-East");  break;
        case "nw": stringBuilder.Append(" North-West");  break;
        case "s":  stringBuilder.Append(" South");       break;
        case "se": stringBuilder.Append(" South-East");  break;
        case "sn": stringBuilder.Append(" North-South"); break;
        case "sw": stringBuilder.Append(" South-West");  break;
        case "w":  stringBuilder.Append(" West");        break;
        case "we": stringBuilder.Append(" East-West");   break;
        default:
        {
          PrintDebug($"Skipping unsupported DungeonGridCell type due to unknown direction '{direction}': {cellName}");
          Pool.FreeUnmanaged(ref stringBuilder);
          return "";
        }
      }
      var eventName = stringBuilder.ToString();
      Pool.FreeUnmanaged(ref stringBuilder);
      return eventName;
    }

    // sub-coroutine to create Train Tunnel section based monument events
    private IEnumerator CreateTunnelSectionMonumentEvents(
      List<string> addedEvents, List<string> createdEvents)
    {
      foreach (DungeonGridCell cell in TerrainMeta.Path.DungeonGridCells)
      {
        var eventName = ToTunnelSectionEventName(cell.name);
        if (string.IsNullOrEmpty(eventName)) continue;
        yield return CreateMonumentEvent(
          eventName, cell.transform, addedEvents, createdEvents);
      }
      // wait for logging to catch up
      yield return CoroutineEx.waitForSeconds(0.5f);
    }

    // get index of centermost section in Train Tunnel Dwelling area
    // returns negative number on failure
    private int GetTunnelDwellingCenterIndex(string name, List<GameObject> links)
    {
      if (links.Count <= 0)
      {
        PrintDebug($"Skipping DungeonGridInfo type with empty Links list: {name}");
        return -1;
      }
      Bounds linkBounds = new(Vector3.zero, Vector3.zero);
      foreach (GameObject link in links)
      {
        if (!link.name.StartsWith("assets/bundled/prefabs/autospawn/tunnel-link/"))
        {
          // skip silently because this isn't a problem - we want to skip
          //  surface entrances and stations because they're endpoints that
          //  are covered by other zone types
          continue;
        }
        if (Vector3.zero == linkBounds.center &&
            Vector3.zero == linkBounds.size)
        {
          // this is the first valid entry; record its position and extents
          linkBounds.center = link.transform.position;
          linkBounds.extents = link.transform.GetBounds().extents;
        }
        else
        {
          // get link's bounds, but use world coordinate center
          var tempBounds = link.transform.GetBounds();
          tempBounds.center = link.transform.position;
          linkBounds.Encapsulate(tempBounds);
        }
      }
      if (linkBounds.size == Vector3.zero)
      {
        PrintDebug($"Skipping DungeonGridInfo type with empty bounds: {name}");
        return -2;
      }
      // find the link closest to the center of the bounding box
      // this is done in 2D, because most of the links are at the bottom of
      //  the volume, and we want to pick one of those for consistency
      var boundsCenter = linkBounds.center.XZ2D();
      int transformIndex = -3;
      float transformDistance = 0.0f;
      for (int i = 0; i < links.Count; ++i)
      {
        var link = links[i];
        // list includes the surface entrance and station section, so skip those
        if (!link.name.StartsWith("assets/bundled/prefabs/autospawn/tunnel-link/"))
        {
          continue;
        }
        var distance =
          Vector3.Distance(boundsCenter, link.transform.position.XZ2D());
        if (transformIndex >= 0 && distance > transformDistance) continue;
        transformIndex = i;
        transformDistance = distance;
      }
      return transformIndex;
    }

    // sub-coroutine to create Train Tunnel dweller area monument events
    private IEnumerator CreateTunnelDwellingMonumentEvents(
      List<string> addedEvents, List<string> createdEvents)
    {
      foreach (DungeonGridInfo entrance in TerrainMeta.Path.DungeonGridEntrances)
      {
        var transformIndex = GetTunnelDwellingCenterIndex(
          entrance.name, entrance.Links);
        if (transformIndex < 0) continue;
        // NOTE: the name is meant to avoid confusion with "Train Tunnel Link",
        //  which is used for linkages between above and below ground rail lines
        yield return CreateMonumentEvent(
          "Train Tunnel Dwelling", entrance.Links[transformIndex].transform,
          addedEvents, createdEvents);
      }
      // wait for logging to catch up
      yield return CoroutineEx.waitForSeconds(0.5f);
    }

    // coroutine to orchestrate creation of all mounment event types
    private IEnumerator CreateMonumentEvents()
    {
      var addedEvents = Pool.Get<List<string>>();
      var createdEvents = Pool.Get<List<string>>();

      yield return CreateLandmarkMonumentEvents(addedEvents, createdEvents);
      yield return CreateTunnelSectionMonumentEvents(
        addedEvents, createdEvents);
      yield return CreateTunnelDwellingMonumentEvents(
        addedEvents, createdEvents);

      if (addedEvents.Count > 0)
      {
        PrintDebug($"{addedEvents.Count} new monument event(s) added to config: {string.Join(", ", addedEvents)}");
        SaveConfig();
      }
      if (createdEvents.Count > 0)
      {
        PrintDebug($"{createdEvents.Count} monument event(s) successfully created: {string.Join(", ", createdEvents)}");
      }

      Pool.FreeUnmanaged(ref addedEvents);
      Pool.FreeUnmanaged(ref createdEvents);

      yield return null;
    }

    #endregion Monument Event

    #region Auto Event

    // coroutine to create user-defined auto events
    private IEnumerator CreateAutoEvents()
    {
      var createdEvents = Pool.Get<List<string>>();

      // create auto events from data file
      foreach (var entry in storedData.autoEvents)
      {
        if (!entry.Value.AutoStart || !CreateDynamicZone(
            entry.Key, entry.Value.Position, entry.Value.ZoneId))
        {
          continue;
        }
        createdEvents.Add(entry.Key);
        yield return CoroutineEx.waitForFixedUpdate;
      }
      if (createdEvents.Count > 0)
      {
        PrintDebug($"{createdEvents.Count} auto event(s) successfully created: {string.Join(", ", createdEvents)}");
      }

      Pool.FreeUnmanaged(ref createdEvents);

      yield return null;
    }

    #endregion Auto Event

    #region Chat/Console Command Handler

    private object OnPlayerCommand(
      BasePlayer player, string command, string[] args) =>
      CheckCommand(player, command, true);

    private object OnServerCommand(ConsoleSystem.Arg arg) =>
      CheckCommand(arg?.Player(), arg?.cmd?.FullName, false);

    private object CheckCommand(BasePlayer player, string command, bool isChat)
    {
      if (!player || string.IsNullOrEmpty(command))
      {
        return null;
      }
      command = command.ToLower().TrimStart('/');
      if (string.IsNullOrEmpty(command))
      {
        return null;
      }

      if (_pvpDelays.TryGetValue(player.userID, out var leftZone))
      {
        var baseEvent = GetBaseEvent(leftZone.eventName);
        if (baseEvent?.CommandWorksForPVPDelay == true &&
            IsBlockedCommand(baseEvent, command, isChat))
        {
          return false;
        }
      }

      var result = ZM_GetPlayerZoneIDs(player);
      if (result == null ||
          result.Length == 0 ||
          (result.Length == 1 && string.IsNullOrEmpty(result[0])))
      {
        return null;
      }

      foreach (var zoneId in result)
      {
        if (!_activeDynamicZones.TryGetValue(zoneId, out var eventName))
        {
          continue;
        }
        PrintDebug($"Checking command: {command} , zoneId: {zoneId}");
        var baseEvent = GetBaseEvent(eventName);
        if (null != baseEvent && IsBlockedCommand(baseEvent, command, isChat))
        {
          return false;
        }
      }
      return null;
    }

    private bool IsBlockedCommand(
      BaseEvent baseEvent, string command, bool isChat)
    {
      if (null == baseEvent || baseEvent.CommandList.Count <= 0) return false;
      var commandExist = baseEvent.CommandList.Exists(entry =>
        entry.StartsWith('/') && isChat ?
          entry.Substring(1).Equals(command) : command.Contains(entry));
      if (baseEvent.UseBlacklistCommands != commandExist) return false;
      PrintDebug($"Use {(baseEvent.UseBlacklistCommands ? "blacklist" : "whitelist")}, Blocked command: {command}");
      return true;
    }

    #endregion Chat/Console Command Handler

    #endregion Events

    #region DynamicZone Handler

    // create a zone that is parented to an entity, such that they move together
    // NOTE: caller is responsible for calling CheckEntityOwner() and
    //  CanCreateDynamicPVP() first, because this method can't easily implement
    //  calling them exactly once
    private void HandleParentedEntityEvent(
      string eventName, BaseEntity parentEntity, bool parentOnCreate,
      bool delay = true)
    {
      if (!parentEntity || null == parentEntity.net)
      {
        return;
      }
      var baseEvent = GetBaseEvent(eventName);
      if (baseEvent == null)
      {
        return;
      }
      if (delay && baseEvent.EventStartDelay > 0f)
      {
        timer.Once(baseEvent.EventStartDelay, () => HandleParentedEntityEvent(
          eventName, parentEntity, parentOnCreate, false));
        return;
      }
      PrintDebug($"Trying to create parented entity eventName={eventName} on parentEntity={parentEntity}.");
      var zonePosition = parentEntity.transform.position;
      if (!parentOnCreate)
      {
        var groundY = TerrainMeta.HeightMap.GetHeight(zonePosition);
        if (Math.Abs(zonePosition.y - groundY) < 10.0f)
        {
          // entity is already near the ground; force enable immediate parenting
          // this catches the case that e.g. a Supply Drop landed during the
          //  event start delay
          parentOnCreate = true;
        }
        else
        {
          // entity is not near the ground yet; start the zone on the ground
          zonePosition.y = groundY;
        }
      }
      var zoneId = parentEntity.net.ID.ToString();
      if (!CreateDynamicZone(eventName, zonePosition, zoneId, delay: false))
      {
        return;
      }
      if (parentOnCreate)
      {
        // attach the event (zone, plus domes if applicable) to the parent
        //  entity, so that they move together
        ParentEventToEntity(
          zoneId, baseEvent, parentEntity, deleteOnFailure: true);
      }
      // else something will attach it later
    }

    private bool HandleMonumentEvent(
      string eventName, Transform transform, MonumentEvent monumentEvent)
    {
      var position = monumentEvent.TransformPosition == Vector3.zero ?
        transform.position :
        transform.TransformPoint(monumentEvent.TransformPosition);
      return CreateDynamicZone(
        eventName, position, monumentEvent.ZoneId,
        monumentEvent.GetDynamicZone().ZoneSettings(transform));
    }

    private void HandleGeneralEvent(
      GeneralEventType generalEventType, BaseEntity baseEntity, bool useEntityId)
    {
      var eventName = generalEventType.ToString();
      if (useEntityId)
      {
        if (!baseEntity || null == baseEntity.net)
        {
          PrintDebug($"Aborting creation of eventName={eventName}, because entity is null", DebugLevel.Warning);
          return;
        }
        if (_activeDynamicZones.ContainsKey(baseEntity.net.ID.ToString()))
        {
          PrintDebug($"Aborting creation of redundant eventName={eventName} for baseEntity={baseEntity} with baseEntity.net.ID={baseEntity.net.ID}", DebugLevel.Warning);
          return;
        }
      }
      if (!CanCreateDynamicPVP(eventName, baseEntity))
      {
        return;
      }
      var baseEvent = GetBaseEvent(eventName);
      if (baseEvent == null)
      {
        return;
      }
      var position = baseEntity.transform.position;
      position.y = TerrainMeta.HeightMap.GetHeight(position);
      CreateDynamicZone(
        eventName, position,
        useEntityId ? baseEntity.net.ID.ToString() : null,
        baseEvent.GetDynamicZone().ZoneSettings(baseEntity.transform));
    }

    private bool CreateDynamicZone(
      string eventName, Vector3 position, string zoneId = "",
      string[] zoneSettings = null, bool delay = true)
    {
      if (position == Vector3.zero)
      {
        PrintDebug($"CreateDynamicZone(): ERROR: Invalid location, zone creation failed for eventName={eventName}.", DebugLevel.Error);
        return false;
      }
      var baseEvent = GetBaseEvent(eventName);
      if (baseEvent == null)
      {
        PrintDebug($"CreateDynamicZone(): ERROR: No baseEvent for eventName={eventName}.", DebugLevel.Error);
        return false;
      }
      if (delay && baseEvent.EventStartDelay > 0f)
      {
        timer.Once(baseEvent.EventStartDelay, () =>
          CreateDynamicZone(eventName, position, zoneId, zoneSettings, false));
        PrintDebug($"CreateDynamicZone(): Delaying zone creation for eventName={eventName} by {baseEvent.EventStartDelay}s.");
        return false;
      }

      float duration = -1;
      if (baseEvent is BaseTimedEvent timedEvent &&
          (baseEvent is not ITimedDisable timedDisable ||
           !timedDisable.IsTimedDisabled()))
      {
        duration = timedEvent.Duration;
      }

      if (string.IsNullOrEmpty(zoneId))
      {
        // TODO: prefix with plugin name or event type?
        zoneId = DateTime.Now.ToString("HHmmssffff");
      }

      var dynamicZone = baseEvent.GetDynamicZone();
      zoneSettings ??= dynamicZone.ZoneSettings();

      PrintDebug($"Trying to create zoneId={zoneId} for eventName={eventName} at position={position}{(dynamicZone is ISphereZone zone ? $", radius={zone.Radius}m" : null)}{(dynamicZone is ICubeZone cubeZone ? $", size={cubeZone.Size}" : null)}{(dynamicZone is IParentZone parentZone ? $", center={parentZone.Center}" : null)}, duration={duration}s.");
      var zoneRadius = dynamicZone is ISphereZone sz ? sz.Radius : 0;
      var zoneSize = dynamicZone is ICubeZone cz ? cz.Size.magnitude : 0;
      if (zoneRadius <= 0 && zoneSize <= 0)
      {
        PrintError($"ERROR: Cannot create zone for eventName={eventName} because both radius and size are less than or equal to zero");
        return false;
      }
      if (!ZM_CreateOrUpdateZone(zoneId, zoneSettings, position))
      {
        PrintDebug($"ERROR: Zone NOT created for eventName={eventName}.", DebugLevel.Error);
        return false;
      }

      if (_activeDynamicZones.TryAdd(zoneId, eventName))
      {
        CheckHooks(HookCheckReasons.ZoneAdded);
      }

      var stringBuilder = Pool.Get<StringBuilder>();
      stringBuilder.Clear();
      if (baseEvent is DomeEvent domeEvent &&
          dynamicZone is ISphereZone sphereZone &&
          DomeCreateAllowed(domeEvent, sphereZone))
      {
        if (CreateDome(
          zoneId, position, sphereZone.Radius, domeEvent.DomesDarkness))
        {
          stringBuilder.Append("Dome,");
        }
        else
        {
          PrintDebug($"ERROR: Dome NOT created for zoneId={zoneId}.", DebugLevel.Error);
        }
      }

      if (baseEvent is BotDomeEvent botEvent &&
          BotReSpawnAllowed(botEvent))
      {
        if (SpawnBots(position, botEvent.BotProfileName, zoneId))
        {
          stringBuilder.Append("Bots,");
        }
        else
        {
          PrintDebug($"ERROR: Bot(s) NOT spawned for zoneId={zoneId}.", DebugLevel.Error);
        }
      }

      if (TP_AddOrUpdateMapping(zoneId, baseEvent.Mapping))
      {
        stringBuilder.Append("Mapping,");
      }
      else
      {
        PrintDebug($"ERROR: Mapping NOT created for zoneId={zoneId}.", DebugLevel.Error);
      }

      PrintDebug($"Created zoneId={zoneId} for eventName={eventName} with properties: {stringBuilder.ToString().TrimEnd(',')}.");
      HandleDeleteDynamicZone(zoneId, duration, eventName);

      stringBuilder.Clear();
      Pool.FreeUnmanaged(ref stringBuilder);
      Interface.CallHook("OnCreatedDynamicPVP",
        zoneId, eventName, position, duration);
      return true;
    }

    private void HandleDeleteDynamicZone(
      string zoneId, float duration, string eventName)
    {
      if (duration <= 0f) return;
      TryRemoveEventTimer(zoneId);
      PrintDebug($"Scheduling deletion of zoneId={zoneId} for eventName={eventName} in {duration} second(s).");
      _eventTimers.Add(
        zoneId, timer.Once(duration, () => HandleDeleteDynamicZone(zoneId)));
    }

    private void HandleDeleteDynamicZone(string zoneId)
    {
      if (string.IsNullOrEmpty(zoneId) ||
          !_activeDynamicZones.TryGetValue(zoneId, out var eventName))
      {
        // this isn't an error, because sometimes a delete is requested "just in
        //  case", and/or because multiple delete stimuli occurred
        PrintDebug($"HandleDeleteDynamicZone(): Skipping delete for unknown zoneId={zoneId}.");
        return;
      }
      if (Interface.CallHook("OnDeleteDynamicPVP", zoneId, eventName) != null)
      {
        return;
      }
      var baseEvent = GetBaseEvent(eventName);
      if (null == baseEvent)
      {
        return;
      }
      if (baseEvent.EventStopDelay > 0f)
      {
        TryRemoveEventTimer(zoneId);
        if (baseEvent.GetDynamicZone() is IParentZone)
        {
          // untether zone from parent entity
          ZM_GetZoneByID(zoneId)?.transform.SetParent(null, true);
          // also untether any domes
          ParentDome(zoneId, Vector3.zero, null);
        }
        _eventTimers.Add(zoneId, timer.Once(
          baseEvent.EventStopDelay, () => DeleteDynamicZone(zoneId)));
      }
      else
      {
        DeleteDynamicZone(zoneId);
      }
    }

    private bool DeleteDynamicZone(string zoneId)
    {
      if (string.IsNullOrEmpty(zoneId) ||
          !_activeDynamicZones.TryGetValue(zoneId, out var eventName))
      {
        // this isn't an error, because sometimes a delete is requested "just in
        //  case", and/or because multiple delete stimuli occurred
        PrintDebug($"DeleteDynamicZone(): Skipping delete for unknown zoneId={zoneId}.");
        return false;
      }

      TryRemoveEventTimer(zoneId);
      var baseEvent = GetBaseEvent(eventName);
      if (baseEvent == null)
      {
        return false;
      }

      var stringBuilder = Pool.Get<StringBuilder>();
      stringBuilder.Clear();
      if (DomeCreateAllowed(
        baseEvent as DomeEvent, baseEvent.GetDynamicZone() as ISphereZone))
      {
        if (RemoveDome(zoneId))
        {
          stringBuilder.Append("Dome,");
        }
        else
        {
          PrintDebug($"ERROR: Dome NOT removed for zoneId={zoneId} with eventName={eventName}.", DebugLevel.Error);
        }
      }

      if (BotReSpawnAllowed(baseEvent as BotDomeEvent))
      {
        if (KillBots(zoneId))
        {
          stringBuilder.Append("Bots,");
        }
        else
        {
          PrintDebug($"ERROR: Bot(s) NOT killed for zoneId={zoneId} with eventName={eventName}.", DebugLevel.Error);
        }
      }

      if (TP_RemoveMapping(zoneId))
      {
        stringBuilder.Append("Mapping,");
      }
      else
      {
        PrintDebug($"ERROR: Mapping NOT removed for zoneId={zoneId} with eventName={eventName}.", DebugLevel.Error);
      }

      var players = ZM_GetPlayersInZone(zoneId);
      var zoneRemoved = ZM_EraseZone(zoneId, eventName);
      if (zoneRemoved)
      {
        // Release zone players immediately
        PrintDebug($"Releasing zone players: {string.Join(",", players.Select(x => x.displayName))}");
        foreach (var player in players)
        {
          OnExitZone(zoneId, player);
        }
        if (_activeDynamicZones.Remove(zoneId))
        {
          CheckHooks(HookCheckReasons.ZoneRemoved);
        }
        PrintDebug($"Deleted zoneId={zoneId} with eventName={eventName} and properties: {stringBuilder.ToString().TrimEnd(',')}.");
        Interface.CallHook("OnDeletedDynamicPVP", zoneId, eventName);
      }
      else
      {
        PrintDebug($"ERROR: Zone NOT removed for zoneId={zoneId} with eventName={eventName} and properties: {stringBuilder.ToString().TrimEnd(',')}.", DebugLevel.Error);
      }

      stringBuilder.Clear();
      Pool.FreeUnmanaged(ref stringBuilder);
      return zoneRemoved;
    }

    private void DeleteOldDynamicZones()
    {
      var zoneIds = ZM_GetZoneIDs();
      if (zoneIds is not { Length: > 0 }) return;
      int attempts = 0, successes = 0;
      foreach (var zoneId in zoneIds)
      {
        if (ZM_GetZoneName(zoneId) != ZoneName) continue;
        attempts++;
        if (ZM_EraseZone(zoneId)) successes++;
        TP_RemoveMapping(zoneId);
      }
      PrintDebug($"Deleted {successes} of {attempts} obsolete DynamicPVP zone(s)", DebugLevel.Warning);
    }

    #endregion DynamicZone Handler

    #region Domes

    private readonly Dictionary<string, List<SphereEntity>> _zoneSpheres = new();

    private static bool DomeCreateAllowed(
      DomeEvent domeEvent, ISphereZone sphereZone) =>
      domeEvent?.DomesEnabled == true && sphereZone?.Radius > 0f;

    private bool CreateDome(
      string zoneId, Vector3 position, float radius, int darkness)
    {
      // Method for spherical dome creation
      if (radius <= 0) return false;

      var sphereEntities = Pool.Get<List<SphereEntity>>();
      for (var i = 0; i < darkness; ++i)
      {
        var sphereEntity = GameManager.server.CreateEntity(
          PrefabSphere, position) as SphereEntity;
        if (!sphereEntity)
        {
          PrintDebug("ERROR: Failed to create SphereEntity", DebugLevel.Error);
          return false;
        }
        sphereEntity.enableSaving = false;
        sphereEntity.Spawn();
        sphereEntity.LerpRadiusTo(radius * 2f, radius);
        sphereEntities.Add(sphereEntity);
      }
      _zoneSpheres.Add(zoneId, sphereEntities);
      return true;
    }

    private void ParentDome(
      string zoneId, Vector3 position, BaseEntity parentEntity = null)
    {
      if (string.IsNullOrEmpty(zoneId) ||
          !_zoneSpheres.TryGetValue(zoneId, out var sphereEntities))
      {
        return;
      }
      foreach (var sphereEntity in sphereEntities)
      {
        if (!parentEntity)
        {
          // un-tethering dome from parent entity
          sphereEntity.SetParent(null, true);
        }
        else
        {
          // tethering dome to parent entity
          sphereEntity.SetParent(parentEntity);
          sphereEntity.transform.position = position;
          sphereEntity.EnableGlobalBroadcast(parentEntity.globalBroadcast);
        }
      }
    }

    private bool RemoveDome(string zoneId)
    {
      if (!_zoneSpheres.TryGetValue(zoneId, out var sphereEntities))
      {
        return false;
      }
      foreach (var sphereEntity in sphereEntities)
      {
        sphereEntity.LerpRadiusTo(0, sphereEntity.currentRadius);
      }
      timer.Once(5f, () =>
      {
        foreach (var sphereEntity in sphereEntities)
        {
          if (sphereEntity && !sphereEntity.IsDestroyed)
          {
            sphereEntity.KillMessage();
          }
        }
        _zoneSpheres.Remove(zoneId);
        Pool.FreeUnmanaged(ref sphereEntities);
      });
      return true;
    }

    #endregion ZoneDome Integration

    #region TruePVE/NextGenPVE Integration

    private object CanEntityTakeDamage(BasePlayer victim, HitInfo info)
    {
      if (null == info || !victim || !victim.userID.IsSteamId())
      {
        return null;
      }
      var attacker = info.InitiatorPlayer ??
        (info.Initiator && info.Initiator.OwnerID.IsSteamId() ?
          BasePlayer.FindByID(info.Initiator.OwnerID) : null);
      if (!attacker || !attacker.userID.IsSteamId())
      {
        //The attacker cannot be fully captured
        return null;
      }
      if (_pvpDelays.TryGetValue(victim.userID, out var victimLeftZone))
      {
        if (configData.Global.PvpDelayFlags.HasFlag(
              PvpDelayTypes.ZonePlayersCanDamageDelayedPlayers) &&
            !string.IsNullOrEmpty(victimLeftZone.zoneId) &&
            ZM_IsPlayerInZone(victimLeftZone, attacker))
        {
          //ZonePlayer attack DelayedPlayer
          return true;
        }
        if (configData.Global.PvpDelayFlags.HasFlag(
              PvpDelayTypes.DelayedPlayersCanDamageDelayedPlayers) &&
            _pvpDelays.TryGetValue(attacker.userID, out var attackerLeftZone) &&
            victimLeftZone.zoneId == attackerLeftZone.zoneId)
        {
          //DelayedPlayer attack DelayedPlayer
          return true;
        }
        return null;
      }
      if (_pvpDelays.TryGetValue(attacker.userID, out var attackerLeftZone2) &&
          configData.Global.PvpDelayFlags.HasFlag(
            PvpDelayTypes.DelayedPlayersCanDamageZonePlayers) &&
          !string.IsNullOrEmpty(attackerLeftZone2.zoneId) &&
          ZM_IsPlayerInZone(attackerLeftZone2, victim))
      {
        //DelayedPlayer attack ZonePlayer
        return true;
      }
      return null;
    }

    private static bool TP_AddOrUpdateMapping(string zoneId, string mapping) =>
      Convert.ToBoolean(
        Interface.CallHook("AddOrUpdateMapping", zoneId, mapping));

    private static bool TP_RemoveMapping(string zoneId) =>
      Convert.ToBoolean(Interface.CallHook("RemoveMapping", zoneId));

    #endregion TruePVE/NextGenPVE Integration

    #region BotReSpawn/MonBots Integration

    private bool BotReSpawnAllowed(BotDomeEvent botEvent) =>
      BotReSpawn != null &&
      botEvent is { BotsEnabled: true } &&
      !string.IsNullOrEmpty(botEvent.BotProfileName);

    private bool SpawnBots(Vector3 location, string profileName, string groupId)
    {
      if (BotReSpawn == null)
      {
        return false;
      }
      var result = BS_AddGroupSpawn(location, profileName, groupId);
      if (result == null || result.Length < 2)
      {
        PrintDebug("AddGroupSpawn returned invalid response.");
        return false;
      }
      switch (result[0])
      {
        case "true":
          return true;
        case "false":
          return false;
        case "error":
          PrintDebug($"ERROR: AddGroupSpawn failed: {result[1]}", DebugLevel.Error);
          return false;
      }
      PrintDebug($"AddGroupSpawn returned unknown response: {result[0]}.");
      return false;
    }

    private bool KillBots(string groupId)
    {
      if (BotReSpawn == null)
      {
        return true;
      }
      var result = BS_RemoveGroupSpawn(groupId);
      if (result == null || result.Length < 2)
      {
        PrintDebug("RemoveGroupSpawn returned invalid response.");
        return false;
      }
      if (result[0] == "error")
      {
        PrintDebug($"ERROR: RemoveGroupSpawn failed: {result[1]}", DebugLevel.Error);
        return false;
      }
      return true;
    }

    private string[] BS_AddGroupSpawn(
      Vector3 location, string profileName, string groupId, int quantity = 0) =>
      BotReSpawn?.Call(
        "AddGroupSpawn", location, profileName, groupId, quantity) as string[];

    private string[] BS_RemoveGroupSpawn(string groupId) =>
      BotReSpawn?.Call("RemoveGroupSpawn", groupId) as string[];

    #endregion BotReSpawn/MonBots Integration

    #region ZoneManager Integration

    private void OnEnterZone(string zoneId, BasePlayer player)
    {
      if (!player || !player.userID.IsSteamId())
      {
        return;
      }
      if (!_activeDynamicZones.TryGetValue(zoneId, out var eventName))
      {
        return;
      }
      Interface.CallHook("OnPlayerEnterPVP", player, zoneId);
      PrintDebug($"{player.displayName} has entered PVP zoneId={zoneId} with eventName={eventName}.");

      if (TryRemovePVPDelay(player)) return;
      // if player is not re-entering zone while in PVP delay, check for
      //  weapon holster
      var baseEvent = GetBaseEvent(eventName);
      if (null == baseEvent || baseEvent.HolsterTime <= 0)
      {
        return;
      }
      player.equippingBlocked = true;
      player.UpdateActiveItem(default);
      player.Invoke(
        () => { player.equippingBlocked = false; }, baseEvent.HolsterTime);
      Print(player, Lang("Holster", player.UserIDString));
    }

    private void OnExitZone(string zoneId, BasePlayer player)
    {
      if (!player || !player.userID.IsSteamId())
      {
        return;
      }
      if (!_activeDynamicZones.TryGetValue(zoneId, out var eventName))
      {
        return;
      }
      PrintDebug($"{player.displayName} has left PVP zoneId={zoneId} with eventName={eventName}.");

      var baseEvent = GetBaseEvent(eventName);
      if (baseEvent is not { PvpDelayEnabled: true } ||
          baseEvent.PvpDelayTime <= 0)
      {
        Interface.CallHook("OnPlayerExitPVP", player, zoneId);
        return;
      }
      Interface.CallHook("OnPlayerExitPVP",
        player, zoneId, baseEvent.PvpDelayTime);

      var leftZone = GetOrAddPVPDelay(player, zoneId, eventName);
      leftZone.zoneTimer = timer.Once(baseEvent.PvpDelayTime, () =>
      {
        TryRemovePVPDelay(player);
      });
      var playerID = player.userID.Get();
      Interface.CallHook("OnPlayerAddedToPVPDelay",
        playerID, zoneId, baseEvent.PvpDelayTime, player);
      // also notify TruePVE if we're using its API to implement the delay
      if (_useExcludePlayer)
      {
        Interface.CallHook("ExcludePlayer",
          playerID, baseEvent.PvpDelayTime, this);
      }
    }

    private bool ZM_CreateOrUpdateZone(
      string zoneId, string[] zoneArgs, Vector3 location) =>
      Convert.ToBoolean(ZoneManager.Call("CreateOrUpdateZone", zoneId, zoneArgs, location));

    private bool ZM_EraseZone(string zoneId, string eventName = "")
    {
      try
      {
        return Convert.ToBoolean(ZoneManager.Call("EraseZone", zoneId));
      }
      catch (Exception exception)
      {
        PrintDebug($"ERROR: EraseZone(zoneId={zoneId}) for eventName={eventName} failed: {exception}");
        return true;
      }
    }

    private string[] ZM_GetZoneIDs() => ZoneManager.Call("GetZoneIDs") as string[];

    private string ZM_GetZoneName(string zoneId) =>
      Convert.ToString(ZoneManager.Call("GetZoneName", zoneId));

    private ZoneManager.Zone ZM_GetZoneByID(string zoneId) =>
      ZoneManager.Call("GetZoneByID", zoneId) as ZoneManager.Zone;

    private string[] ZM_GetPlayerZoneIDs(BasePlayer player) =>
      ZoneManager.Call("GetPlayerZoneIDs", player) as string[];

    private bool ZM_IsPlayerInZone(LeftZone leftZone, BasePlayer player) =>
      Convert.ToBoolean(
        ZoneManager.Call("IsPlayerInZone", leftZone.zoneId, player));

    private List<BasePlayer> ZM_GetPlayersInZone(string zoneId) =>
      ZoneManager.Call("GetPlayersInZone", zoneId) as List<BasePlayer>;

    // parent event's zone and (if applicable) domes to a given entity, so that
    //  they move together
    private void ParentEventToEntity(
      string zoneId, BaseEvent baseEvent, BaseEntity parentEntity,
      bool deleteOnFailure, bool delay = true)
    {
      if (delay)
      {
        timer.Once(0.25f, () => ParentEventToEntity(
          zoneId, baseEvent, parentEntity, deleteOnFailure, false));
        return;
      }
      var zone = ZM_GetZoneByID(zoneId);
      if (!parentEntity || !zone)
      {
        PrintDebug($"ERROR: The zoneId={zoneId} has null zone={zone} and/or parentEntity={parentEntity}.", DebugLevel.Error);
        if (deleteOnFailure) DeleteDynamicZone(zoneId);
        return;
      }
      // only support parenting if event implements IParentZone
      if (baseEvent.GetDynamicZone() is not IParentZone parentZone)
      {
        PrintDebug($"ERROR: Not parenting zoneId={zoneId} to parentEntity={parentEntity} because event's DynamicZone does not implement IParentZone.", DebugLevel.Error);
        if (deleteOnFailure) DeleteDynamicZone(zoneId);
        return;
      }
      var zoneTransform = zone.transform;
      var position = parentEntity.transform.TransformPoint(parentZone.Center);
      zoneTransform.SetParent(parentEntity.transform);
      zoneTransform.rotation = parentEntity.transform.rotation;
      zoneTransform.position = position;
      PrintDebug($"Parented zoneId={zoneId} to parentEntity={parentEntity}.");
      // also parent any domes
      ParentDome(zoneId, position, parentEntity);
    }

    #endregion ZoneManager Integration

    #region Debug

    private StringBuilder _debugStringBuilder;

    private enum DebugLevel { Error, Warning, Info };

    private void PrintDebug(string message, DebugLevel level = DebugLevel.Info)
    {
      if (configData.Global.DebugEnabled)
      {
        switch (level)
        {
          case DebugLevel.Error:   PrintError(message);   break;
          case DebugLevel.Warning: PrintWarning(message); break;
          case DebugLevel.Info:    Puts(message);         break;
        }
      }

      if (configData.Global.LogToFile)
      {
        _debugStringBuilder.AppendLine($"[{DateTime.Now.ToString(CultureInfo.InstalledUICulture)}] | {message}");
      }
    }

    private void SaveDebug()
    {
      if (!configData.Global.LogToFile)
      {
        return;
      }
      var debugText = _debugStringBuilder.ToString().Trim();
      _debugStringBuilder.Clear();
      if (!string.IsNullOrEmpty(debugText))
      {
        LogToFile("debug", debugText, this);
      }
    }

    #endregion Debug

    #region API

    private string[] AllDynamicPVPZones() => _activeDynamicZones.Keys.ToArray();

    private bool IsDynamicPVPZone(string zoneId) =>
      _activeDynamicZones.ContainsKey(zoneId);

    private bool EventDataExists(string eventName) =>
      storedData.EventDataExists(eventName);

    private bool IsPlayerInPVPDelay(ulong playerId) =>
      _pvpDelays.ContainsKey(playerId);

    private string GetPlayerPVPDelayedZoneID(ulong playerId) =>
      _pvpDelays.TryGetValue(playerId, out var leftZone) ?
        leftZone.zoneId : null;

    private string GetEventName(string zoneId) =>
      _activeDynamicZones.GetValueOrDefault(zoneId);

    private bool CreateOrUpdateEventData(
      string eventName, string eventData, bool isTimed = false)
    {
      if (string.IsNullOrEmpty(eventName) || string.IsNullOrEmpty(eventData))
      {
        return false;
      }
      if (EventDataExists(eventName))
      {
        RemoveEventData(eventName);
      }
      if (isTimed)
      {
        TimedEvent timedEvent;
        try
        {
          timedEvent = JsonConvert.DeserializeObject<TimedEvent>(eventData);
        }
        catch
        {
          return false;
        }
        storedData.timedEvents.Add(eventName, timedEvent);
      }
      else
      {
        AutoEvent autoEvent;
        try
        {
          autoEvent = JsonConvert.DeserializeObject<AutoEvent>(eventData);
        }
        catch
        {
          return false;
        }
        storedData.autoEvents.Add(eventName, autoEvent);
        if (autoEvent.AutoStart)
        {
          CreateDynamicZone(eventName, autoEvent.Position, autoEvent.ZoneId);
        }
      }
      _dataChanged = true;
      return true;
    }

    private bool CreateEventData(
      string eventName, Vector3 position, bool isTimed)
    {
      if (EventDataExists(eventName))
      {
        return false;
      }
      if (isTimed)
      {
        storedData.timedEvents.Add(eventName, new TimedEvent());
      }
      else
      {
        storedData.autoEvents.Add(
          eventName, new AutoEvent { Position = position });
      }
      _dataChanged = true;
      return true;
    }

    private bool RemoveEventData(string eventName, bool forceClose = true)
    {
      if (!EventDataExists(eventName))
      {
        return false;
      }
      storedData.RemoveEventData(eventName);
      if (forceClose)
      {
        ForceCloseZones(eventName);
      }
      _dataChanged = true;
      return true;
    }

    private bool StartEvent(string eventName, Vector3 position)
    {
      if (!EventDataExists(eventName))
      {
        return false;
      }
      var baseEvent = GetBaseEvent(eventName);
      return baseEvent switch
      {
        AutoEvent autoEvent => CreateDynamicZone(
          eventName, position == default ? autoEvent.Position : position,
          autoEvent.ZoneId),
        BaseTimedEvent => CreateDynamicZone(eventName, position),
        _ => false
      };
    }

    private bool StopEvent(string eventName) =>
      EventDataExists(eventName) && ForceCloseZones(eventName);

    private bool ForceCloseZones(string eventName)
    {
      var closed = false;
      foreach (var entry in _activeDynamicZones.ToArray())
      {
        if (entry.Value == eventName && DeleteDynamicZone(entry.Key))
        {
          closed = true;
        }
      }
      return closed;
    }

    private bool IsUsingExcludePlayer() => _useExcludePlayer;

    #endregion API

    #region Commands

    private static void DrawCube(
      BasePlayer player, float duration, Color color,
      Vector3 pos, Vector3 size, float rotation)
    {
      // this is complicated because ddraw doesn't have a rectangular prism
      //  rendering option, so we need to figure out where all the rotated
      //  vertices are and then draw all the edges
      var halfSize = size / 2;
      Vector3[] vertices =
      {
        // corners
        new(pos.x + halfSize.x, pos.y + halfSize.y, pos.z + halfSize.z),
        new(pos.x + halfSize.x, pos.y + halfSize.y, pos.z - halfSize.z),
        new(pos.x + halfSize.x, pos.y - halfSize.y, pos.z + halfSize.z),
        new(pos.x + halfSize.x, pos.y - halfSize.y, pos.z - halfSize.z),
        new(pos.x - halfSize.x, pos.y + halfSize.y, pos.z + halfSize.z),
        new(pos.x - halfSize.x, pos.y + halfSize.y, pos.z - halfSize.z),
        new(pos.x - halfSize.x, pos.y - halfSize.y, pos.z + halfSize.z),
        new(pos.x - halfSize.x, pos.y - halfSize.y, pos.z - halfSize.z),
        // axes
        new(pos.x, pos.y, pos.z),
        new(pos.x + halfSize.x, pos.y, pos.z),
        new(pos.x, pos.y + halfSize.y, pos.z),
        new(pos.x, pos.y, pos.z + halfSize.z)
      };

      // rotate all the points
      var rotQ = Quaternion.Euler(0, rotation, 0);
      for (int i = 0; i < vertices.Length; ++i)
      {
        vertices[i] = (rotQ * (vertices[i] - pos)) + pos;
      }

      // corners
      player.SendConsoleCommand(
        "ddraw.line",  duration, color, vertices[0], vertices[1]);
      player.SendConsoleCommand(
        "ddraw.line",  duration, color, vertices[0], vertices[2]);
      player.SendConsoleCommand(
        "ddraw.line",  duration, color, vertices[0], vertices[4]);
      player.SendConsoleCommand(
        "ddraw.line",  duration, color, vertices[1], vertices[3]);
      player.SendConsoleCommand(
        "ddraw.line",  duration, color, vertices[1], vertices[5]);
      player.SendConsoleCommand(
        "ddraw.line",  duration, color, vertices[2], vertices[3]);
      player.SendConsoleCommand(
        "ddraw.line",  duration, color, vertices[2], vertices[6]);
      player.SendConsoleCommand(
        "ddraw.line",  duration, color, vertices[3], vertices[7]);
      player.SendConsoleCommand(
        "ddraw.line",  duration, color, vertices[4], vertices[5]);
      player.SendConsoleCommand(
        "ddraw.line",  duration, color, vertices[4], vertices[6]);
      player.SendConsoleCommand(
        "ddraw.line",  duration, color, vertices[5], vertices[7]);
      player.SendConsoleCommand(
        "ddraw.line",  duration, color, vertices[6], vertices[7]);
      // axes
      player.SendConsoleCommand(
        "ddraw.arrow", duration, Color.red,   vertices[8], vertices[9],  5);
      player.SendConsoleCommand(
        "ddraw.arrow", duration, Color.green, vertices[8], vertices[10], 5);
      player.SendConsoleCommand(
        "ddraw.arrow", duration, Color.blue,  vertices[8], vertices[11], 5);
      player.SendConsoleCommand(
        "ddraw.text",  duration, Color.red,   vertices[9],  "+x");
      player.SendConsoleCommand(
        "ddraw.text",  duration, Color.green, vertices[10], "+y");
      player.SendConsoleCommand(
        "ddraw.text",  duration, Color.blue,  vertices[11], "+z");
    }

    private static void DrawSphere(
      BasePlayer player, float duration, Color color,
      Vector3 pos, float radius, float rotation)
    {
      player.SendConsoleCommand(
        "ddraw.sphere", duration, color, pos, radius);

      // axes
      Vector3[] vertices =
      {
        new(pos.x,          pos.y,          pos.z),
        new(pos.x + radius, pos.y,          pos.z),
        new(pos.x,          pos.y + radius, pos.z),
        new(pos.x,          pos.y,          pos.z + radius)
      };

      // rotate all the points
      var rotQ = Quaternion.Euler(0, rotation, 0);
      for (int i = 0; i < vertices.Length; ++i)
      {
        vertices[i] = (rotQ * (vertices[i] - pos)) + pos;
      }

      player.SendConsoleCommand(
        "ddraw.arrow", duration, Color.red,   vertices[0], vertices[1], 5);
      player.SendConsoleCommand(
        "ddraw.arrow", duration, Color.green, vertices[0], vertices[2], 5);
      player.SendConsoleCommand(
        "ddraw.arrow", duration, Color.blue,  vertices[0], vertices[3], 5);
      player.SendConsoleCommand(
        "ddraw.text", duration, Color.red,    vertices[1], "+x");
      player.SendConsoleCommand(
        "ddraw.text", duration, Color.green,  vertices[2], "+y");
      player.SendConsoleCommand(
        "ddraw.text", duration, Color.blue,   vertices[3], "+z");
    }

    private void CommandHelp(IPlayer iPlayer)
    {
      var stringBuilder = Pool.Get<StringBuilder>();
      var result = stringBuilder
        .Clear()
        .AppendLine()
        .AppendLine(Lang("Syntax",  iPlayer.Id, configData.Chat.Command))
        .AppendLine(Lang("Syntax1", iPlayer.Id, configData.Chat.Command))
        .AppendLine(Lang("Syntax2", iPlayer.Id, configData.Chat.Command))
        .AppendLine(Lang("Syntax3", iPlayer.Id, configData.Chat.Command))
        .AppendLine(Lang("Syntax4", iPlayer.Id, configData.Chat.Command))
        .AppendLine(Lang("Syntax5", iPlayer.Id, configData.Chat.Command))
        .AppendLine(Lang("Syntax6", iPlayer.Id, configData.Chat.Command))
        .AppendLine(Lang("Syntax7", iPlayer.Id, configData.Chat.Command))
        .AppendLine(Lang("Syntax8", iPlayer.Id, configData.Chat.Command))
        .ToString()
      ;
      stringBuilder.Clear();
      Pool.FreeUnmanaged(ref stringBuilder);
      Print(iPlayer, result);
    }

    private void CommandList(IPlayer iPlayer)
    {
      var customEventCount = storedData.CustomEventsCount;
      if (customEventCount <= 0)
      {
        Print(iPlayer, Lang("NoCustomEvent", iPlayer.Id));
        return;
      }
      var i = 0;
      var stringBuilder = Pool.Get<StringBuilder>();
      stringBuilder.Clear();
      stringBuilder.AppendLine(Lang("CustomEvents",
        iPlayer.Id, customEventCount));
      foreach (var entry in storedData.autoEvents)
      {
        i++;
        stringBuilder.AppendLine(Lang("AutoEvent",
          iPlayer.Id, i,
          entry.Key, entry.Value.AutoStart, entry.Value.Position));
      }
      foreach (var entry in storedData.timedEvents)
      {
        i++;
        stringBuilder.AppendLine(Lang("TimedEvent",
          iPlayer.Id, i, entry.Key, entry.Value.Duration));
      }
      Print(iPlayer, stringBuilder.ToString());
      stringBuilder.Clear();
      Pool.FreeUnmanaged(ref stringBuilder);
    }

    private void CommandShow(BasePlayer player)
    {
      if (!player)
      {
        PrintDebug("CommandShow(): Got null player; aborting", DebugLevel.Error);
        return;
      }

      Print(player, Lang("Showing", player.UserIDString, configData.Chat.ShowDuration));

      foreach (var activeEvent in _activeDynamicZones)
      {
        var zoneData = ZM_GetZoneByID(activeEvent.Key);
        if (null == zoneData) continue;
        var zonePosition = zoneData.transform.position;
        var baseZone = GetBaseEvent(activeEvent.Value)?.GetDynamicZone();
        var zoneColor = Color.red;
        switch (baseZone)
        {
          case SphereCubeDynamicZone scdZone:
          {
            zoneColor = Color.yellow;
            var rotation = scdZone.Rotation;
            if (!scdZone.FixedRotation)
            {
              rotation += zoneData.transform.eulerAngles.y;
            }
            if (scdZone.Radius > 0)
            {
              DrawSphere(
                player, configData.Chat.ShowDuration,zoneColor,
                zonePosition, scdZone.Radius, rotation);
            }
            else if (scdZone.Size.sqrMagnitude > 0)
            {
              DrawCube(
                player, configData.Chat.ShowDuration, zoneColor,
                zonePosition, scdZone.Size, rotation);
            }
            break;
          }

          case SphereCubeParentDynamicZone scpdZone:
          {
            zoneColor = Color.blue;
            var rotation = zoneData.transform.eulerAngles.y;
            if (scpdZone.Radius > 0)
            {
              DrawSphere(
                player, configData.Chat.ShowDuration,zoneColor,
                zonePosition, scpdZone.Radius, rotation);
            }
            else if (scpdZone.Size.sqrMagnitude > 0)
            {
              DrawCube(
                player, configData.Chat.ShowDuration, zoneColor,
                zonePosition, scpdZone.Size, rotation);
            }
            break;
          }
        }
        player.SendConsoleCommand(
          "ddraw.text", configData.Chat.ShowDuration, zoneColor,
          zonePosition, $"{activeEvent.Key}\n{activeEvent.Value}");
      }
    }

    private void CommandEdit(
      IPlayer iPlayer, string eventName, Vector3 position, string arg)
    {
      if (storedData.autoEvents.TryGetValue(eventName, out var autoEvent))
      {
        switch (arg.ToLower())
        {
          case "0":
          case "false":
          {
            autoEvent.AutoStart = false;
            Print(iPlayer, Lang("AutoEventAutoStart",
              iPlayer.Id, eventName, false));
            _dataChanged = true;
            return;
          }

          case "1":
          case "true":
          {
            autoEvent.AutoStart = true;
            Print(iPlayer, Lang("AutoEventAutoStart",
              iPlayer.Id, eventName, true));
            _dataChanged = true;
            return;
          }

          case "move":
          {
            autoEvent.Position = position;
            Print(iPlayer, Lang("AutoEventMove", iPlayer.Id, eventName));
            _dataChanged = true;
            return;
          }
        }
      }
      else if (storedData.timedEvents.TryGetValue(eventName, out var timedEvent)
                && float.TryParse(arg, out var duration))
      {
        timedEvent.Duration = duration;
        Print(iPlayer, Lang("TimedEventDuration",
          iPlayer.Id, eventName, duration));
        _dataChanged = true;
        return;
      }
      Print(iPlayer, Lang("SyntaxError", iPlayer.Id, configData.Chat.Command));
    }

    private void CmdDynamicPVP(IPlayer iPlayer, string command, string[] args)
    {
      if (!iPlayer.IsAdmin && !iPlayer.HasPermission(PermissionAdmin))
      {
        Print(iPlayer, Lang("NotAllowed", iPlayer.Id));
        return;
      }
      if (args == null || args.Length < 1)
      {
        Print(iPlayer, Lang("SyntaxError", iPlayer.Id, configData.Chat.Command));
        return;
      }
      var commandName = args[0].ToLower();
      // check command and dispatch to appropriate handler
      switch (commandName)
      {
        case "?":
        case "h":
        case "help":
        {
          CommandHelp(iPlayer);
          return;
        }

        case "list":
        {
          CommandList(iPlayer);
          return;
        }

        case "show":
        {
          CommandShow(iPlayer.Object as BasePlayer);
          return;
        }
      }
      // handle commands that take additional parameters
      var eventName = args[1];
      var position =
        (iPlayer.Object as BasePlayer)?.transform.position ?? Vector3.zero;
      switch (commandName)
      {
        case "add":
        {
          var isTimed = args.Length >= 3;
          Print(iPlayer, CreateEventData(eventName, position, isTimed) ?
            Lang("EventDataAdded", iPlayer.Id, eventName) :
            Lang("EventNameExist", iPlayer.Id, eventName));
          return;
        }

        case "remove":
        {
          Print(iPlayer, RemoveEventData(eventName) ?
            Lang("EventDataRemoved", iPlayer.Id, eventName) :
            Lang("EventNameNotExist", iPlayer.Id, eventName));
          return;
        }

        case "start":
        {
          Print(iPlayer, StartEvent(eventName, position) ?
            Lang("EventStarted", iPlayer.Id, eventName) :
            Lang("EventNameNotExist", iPlayer.Id, eventName));
          return;
        }

        case "stop":
        {
          Print(iPlayer, StopEvent(eventName) ?
            Lang("EventStopped", iPlayer.Id, eventName) :
            Lang("EventNameNotExist", iPlayer.Id, eventName));
          return;
        }

        case "edit":
        {
          if (args.Length >= 3)
          {
            CommandEdit(iPlayer, eventName, position, args[2]);
            return;
          }
          break;
        }
      }
      Print(iPlayer, Lang("SyntaxError", iPlayer.Id, configData.Chat.Command));
    }

    #endregion Commands

    #region ConfigurationFile

    private ConfigData configData;

    private sealed class ConfigData
    {
      [JsonProperty(PropertyName = "Global Settings")]
      public GlobalSettings Global { get; set; } = new();

      [JsonProperty(PropertyName = "Chat Settings")]
      public ChatSettings Chat { get; set; } = new();

      [JsonProperty(PropertyName = "General Event Settings")]
      public GeneralEventSettings GeneralEvents { get; set; } = new();

      [JsonProperty(PropertyName = "Monument Event Settings")]
      public SortedDictionary<string, MonumentEvent>
        MonumentEvents { get; set; } = new();

      [JsonProperty(PropertyName = "Version")]
      public VersionNumber Version { get; set; }
    }

    private sealed class GlobalSettings
    {
      [JsonProperty(PropertyName = "Enable Debug Mode")]
      public bool DebugEnabled { get; set; }

      [JsonProperty(PropertyName = "Log Debug To File")]
      public bool LogToFile { get; set; }

      [JsonProperty(PropertyName = "Compare Radius (Used to determine if it is a SupplySignal)")]
      public float CompareRadius { get; set; } = 2f;

      [JsonProperty(PropertyName = "If the entity has an owner, don't create a PVP zone")]
      public bool CheckEntityOwner { get; set; } = true;

      [JsonProperty(PropertyName = "Use TruePVE PVP Delay API (more efficient and cross-plugin, but supersedes PVP Delay Flags)")]
      public bool UseExcludePlayer { get; set; }

      [JsonProperty(PropertyName = "PVP Delay Flags")]
      public PvpDelayTypes PvpDelayFlags { get; set; } =
        PvpDelayTypes.ZonePlayersCanDamageDelayedPlayers |
        PvpDelayTypes.DelayedPlayersCanDamageDelayedPlayers |
        PvpDelayTypes.DelayedPlayersCanDamageZonePlayers;
    }

    private sealed class ChatSettings
    {
      [JsonProperty(PropertyName = "Command")]
      public string Command { get; set; } = "dynpvp";

      [JsonProperty(PropertyName = "Chat Prefix")]
      public string Prefix { get; set; } = "[DynamicPVP]: ";

      [JsonProperty(PropertyName = "Chat Prefix Color")]
      public string PrefixColor { get; set; } = "#00FFFF";

      [JsonProperty(PropertyName = "Chat SteamID Icon")]
      public ulong SteamIdIcon { get; set; }

      [JsonProperty(PropertyName = "Zone Show Duration (in seconds)")]
      public float ShowDuration { get; set; } = 15f;
    }

    private sealed class GeneralEventSettings
    {
      [JsonProperty(PropertyName = "Bradley Event")]
      public TimedEvent BradleyApc { get; set; } = new();

      [JsonProperty(PropertyName = "Patrol Helicopter Event")]
      public TimedEvent PatrolHelicopter { get; set; } = new();

      [JsonProperty(PropertyName = "Supply Signal Event")]
      public SupplyDropEvent SupplySignal { get; set; } = new();

      [JsonProperty(PropertyName = "Timed Supply Event")]
      public SupplyDropEvent TimedSupply { get; set; } = new();

      [JsonProperty(PropertyName = "Hackable Crate Event")]
      public HackableCrateEvent HackableCrate { get; set; } = new();

      [JsonProperty(PropertyName = "Excavator Ignition Event")]
      public MonumentEvent ExcavatorIgnition { get; set; } = new();

      [JsonProperty(PropertyName = "Cargo Ship Event")]
      public CargoShipEvent CargoShip { get; set; } = new();
    }

    #region Event

    // NOTE: reserve order 1-19
    public abstract class BaseEvent
    {
      [JsonProperty(PropertyName = "Enable Event", Order = 1)]
      public bool Enabled { get; set; }

      [JsonProperty(PropertyName = "Delay In Starting Event", Order = 2)]
      public float EventStartDelay { get; set; }

      [JsonProperty(PropertyName = "Delay In Stopping Event", Order = 3)]
      public float EventStopDelay { get; set; }

      [JsonProperty(PropertyName = "Holster Time On Enter (In seconds, or 0 to disable)", Order = 4)]
      public float HolsterTime { get; set; }

      [JsonProperty(PropertyName = "Enable PVP Delay", Order = 5)]
      public bool PvpDelayEnabled { get; set; }

      [JsonProperty(PropertyName = "PVP Delay Time", Order = 6)]
      public float PvpDelayTime { get; set; } = 10f;

      [JsonProperty(PropertyName = "TruePVE Mapping", Order = 7)]
      public string Mapping { get; set; } = "exclude";

      [JsonProperty(PropertyName = "Use Blacklist Commands (If false, a whitelist is used)", Order = 8)]
      public bool UseBlacklistCommands { get; set; } = true;

      [JsonProperty(PropertyName = "Command works for PVP delayed players", Order = 9)]
      public bool CommandWorksForPVPDelay { get; set; }

      [JsonProperty(PropertyName = "Command List (If there is a '/' at the front, it is a chat command)", Order = 10)]
      public List<string> CommandList { get; set; } = new();

      public abstract BaseDynamicZone GetDynamicZone();
    }

    // NOTE: reserve order 20-29
    public abstract class DomeEvent : BaseEvent
    {
      [JsonProperty(PropertyName = "Enable Domes", Order = 20)]
      public bool DomesEnabled { get; set; } = true;

      [JsonProperty(PropertyName = "Domes Darkness", Order = 21)]
      public int DomesDarkness { get; set; } = 8;
    }

    // NOTE: reserve order 30-39
    public abstract class BotDomeEvent : DomeEvent
    {
      [JsonProperty(PropertyName = "Enable Bots (Need BotSpawn Plugin)", Order = 30)]
      public bool BotsEnabled { get; set; }

      [JsonProperty(PropertyName = "BotSpawn Profile Name", Order = 31)]
      public string BotProfileName { get; set; } = string.Empty;
    }

    // NOTE: reserve order 40-49
    public class MonumentEvent : DomeEvent
    {
      [JsonProperty(PropertyName = "Dynamic PVP Zone Settings", Order = 40)]
      public SphereCubeDynamicZone DynamicZone { get; set; } = new();

      [JsonProperty(PropertyName = "Zone ID", Order = 41)]
      public string ZoneId { get; set; } = string.Empty;

      [JsonProperty(PropertyName = "Transform Position", Order = 42)]
      public Vector3 TransformPosition { get; set; }

      public override BaseDynamicZone GetDynamicZone()
      {
        return DynamicZone;
      }
    }

    // NOTE: reserve order 50-59
    public class AutoEvent : BotDomeEvent
    {
      [JsonProperty(PropertyName = "Dynamic PVP Zone Settings", Order = 50)]
      public SphereCubeDynamicZone DynamicZone { get; set; } = new();

      [JsonProperty(PropertyName = "Auto Start", Order = 51)]
      public bool AutoStart { get; set; }

      [JsonProperty(PropertyName = "Zone ID", Order = 52)]
      public string ZoneId { get; set; } = string.Empty;

      [JsonProperty(PropertyName = "Position", Order = 53)]
      public Vector3 Position { get; set; }

      public override BaseDynamicZone GetDynamicZone()
      {
        return DynamicZone;
      }
    }

    // NOTE: reserve order 60-64
    public abstract class BaseTimedEvent : BotDomeEvent
    {
      [JsonProperty(PropertyName = "Event Duration", Order = 60)]
      public float Duration { get; set; } = 600f;
    }

    // NOTE: reserve order 65-69
    public class TimedEvent : BaseTimedEvent
    {
      [JsonProperty(PropertyName = "Dynamic PVP Zone Settings", Order = 65)]
      public SphereCubeDynamicZone DynamicZone { get; set; } = new();

      public override BaseDynamicZone GetDynamicZone()
      {
        return DynamicZone;
      }
    }

    // NOTE: reserve order 70-79
    public class HackableCrateEvent : BaseTimedEvent, ITimedDisable
    {
      [JsonProperty(PropertyName = "Dynamic PVP Zone Settings", Order = 70)]
      public SphereCubeParentDynamicZone DynamicZone { get; set; } = new();

      [JsonProperty(PropertyName = "Start Event When Spawned (If false, the event starts when unlocking)", Order = 71)]
      public bool StartWhenSpawned { get; set; } = true;

      [JsonProperty(PropertyName = "Stop Event When Killed", Order = 72)]
      public bool StopWhenKilled { get; set; }

      [JsonProperty(PropertyName = "Event Timer Starts When Looted", Order = 73)]
      public bool TimerStartWhenLooted { get; set; }

      [JsonProperty(PropertyName = "Event Timer Starts When Unlocked", Order = 74)]
      public bool TimerStartWhenUnlocked { get; set; }

      [JsonProperty(PropertyName = "Excluding Hackable Crate On OilRig", Order = 75)]
      public bool ExcludeOilRig { get; set; } = true;

      [JsonProperty(PropertyName = "Excluding Hackable Crate on Cargo Ship", Order = 76)]
      public bool ExcludeCargoShip { get; set; } = true;

      public override BaseDynamicZone GetDynamicZone()
      {
        return DynamicZone;
      }

      public bool IsTimedDisabled()
      {
        return StopWhenKilled || TimerStartWhenLooted || TimerStartWhenUnlocked;
      }
    }

    // NOTE: reserve order 80-89
    public class SupplyDropEvent : BaseTimedEvent, ITimedDisable
    {
      [JsonProperty(PropertyName = "Dynamic PVP Zone Settings", Order = 80)]
      public SphereCubeParentDynamicZone DynamicZone { get; set; } = new();

      [JsonProperty(PropertyName = "Start Event When Spawned (If false, the event starts when landed)", Order = 81)]
      public bool StartWhenSpawned { get; set; } = true;

      [JsonProperty(PropertyName = "Stop Event When Killed", Order = 82)]
      public bool StopWhenKilled { get; set; }

      [JsonProperty(PropertyName = "Event Timer Starts When Looted", Order = 83)]
      public bool TimerStartWhenLooted { get; set; }

      public override BaseDynamicZone GetDynamicZone()
      {
        return DynamicZone;
      }

      public bool IsTimedDisabled()
      {
        return StopWhenKilled || TimerStartWhenLooted;
      }
    }

    // NOTE: reserve order 90-99
    public class CargoShipEvent : DomeEvent
    {
      [JsonProperty(PropertyName = "Event State On Spawn (true=enabled, false=disabled)", Order = 90)]
      public bool SpawnState { get; set; } = true;

      [JsonProperty(PropertyName = "Event State On Harbor Approach", Order = 91)]
      public bool ApproachState { get; set; } = true;

      [JsonProperty(PropertyName = "Event State On Harbor Docking", Order = 92)]
      public bool DockState { get; set; } = true;

      [JsonProperty(PropertyName = "Event State On Harbor Departure", Order = 93)]
      public bool DepartState { get; set; } = true;

      [JsonProperty(PropertyName = "Event State On Map Egress", Order = 94)]
      public bool EgressState { get; set; } = true;

      [JsonProperty(PropertyName = "Dynamic PVP Zone Settings", Order = 95)]
      public SphereCubeParentDynamicZone DynamicZone { get; set; } = new()
      {
        Size = new Vector3(25.9f, 43.3f, 152.8f),
        Center = new Vector3(0f, 21.6f, 6.6f)
      };

      public override BaseDynamicZone GetDynamicZone() => DynamicZone;
    }

    #region Interface

    public interface ITimedDisable
    {
      bool IsTimedDisabled();
    }

    #endregion Interface

    #endregion Event

    #region Zone

    // NOTE: reserve order 100-119
    public abstract class BaseDynamicZone
    {
      [JsonProperty(PropertyName = "Zone Comfort", Order = 100)]
      public float Comfort { get; set; }

      [JsonProperty(PropertyName = "Zone Radiation", Order = 101)]
      public float Radiation { get; set; }

      [JsonProperty(PropertyName = "Zone Temperature", Order = 102)]
      public float Temperature { get; set; }

      [JsonProperty(PropertyName = "Enable Safe Zone", Order = 103)]
      public bool SafeZone { get; set; }

      [JsonProperty(PropertyName = "Eject Spawns", Order = 104)]
      public string EjectSpawns { get; set; } = string.Empty;

      [JsonProperty(PropertyName = "Zone Parent ID", Order = 105)]
      public string ParentId { get; set; } = string.Empty;

      [JsonProperty(PropertyName = "Enter Message", Order = 106)]
      public string EnterMessage { get; set; } = "Entering a PVP area!";

      [JsonProperty(PropertyName = "Leave Message", Order = 107)]
      public string LeaveMessage { get; set; } = "Leaving a PVP area.";

      [JsonProperty(PropertyName = "Permission Required To Enter Zone", Order = 108)]
      public string Permission { get; set; } = string.Empty;

      [JsonProperty(PropertyName = "Extra Zone Flags", Order = 109)]
      public List<string> ExtraZoneFlags { get; set; } = new();

      private string[] _zoneSettings;

      public virtual string[] ZoneSettings(Transform transform = null) =>
        _zoneSettings ??= GetZoneSettings();

      protected void GetBaseZoneSettings(List<string> zoneSettings)
      {
        zoneSettings.Add("name");
        zoneSettings.Add(ZoneName);
        if (Comfort > 0f)
        {
          zoneSettings.Add("comfort");
          zoneSettings.Add(Comfort.ToString(CultureInfo.InvariantCulture));
        }
        if (Radiation > 0f)
        {
          zoneSettings.Add("radiation");
          zoneSettings.Add(Radiation.ToString(CultureInfo.InvariantCulture));
        }
        if (Math.Abs(Temperature) < 1e-8f)
        {
          zoneSettings.Add("temperature");
          zoneSettings.Add(Temperature.ToString(CultureInfo.InvariantCulture));
        }
        if (SafeZone)
        {
          zoneSettings.Add("safezone");
          zoneSettings.Add(SafeZone.ToString());
        }
        if (!string.IsNullOrEmpty(EnterMessage))
        {
          zoneSettings.Add("enter_message");
          zoneSettings.Add(EnterMessage);
        }
        if (!string.IsNullOrEmpty(LeaveMessage))
        {
          zoneSettings.Add("leave_message");
          zoneSettings.Add(LeaveMessage);
        }
        if (!string.IsNullOrEmpty(EjectSpawns))
        {
          zoneSettings.Add("ejectspawns");
          zoneSettings.Add(EjectSpawns);
        }
        if (!string.IsNullOrEmpty(Permission))
        {
          zoneSettings.Add("permission");
          zoneSettings.Add(Permission);
        }
        if (!string.IsNullOrEmpty(ParentId))
        {
          zoneSettings.Add("parentid");
          zoneSettings.Add(ParentId);
        }
        foreach (var flag in ExtraZoneFlags)
        {
          if (string.IsNullOrEmpty(flag)) continue;
          zoneSettings.Add(flag);
          zoneSettings.Add("true");
        }
      }

      protected abstract string[] GetZoneSettings(Transform transform = null);
    }

    // NOTE: reserve order 140-149
    public class SphereCubeDynamicZone : BaseDynamicZone, ISphereZone, ICubeZone, IRotateZone
    {
      [JsonProperty(PropertyName = "Zone Radius", Order = 140)]
      public float Radius { get; set; }

      [JsonProperty(PropertyName = "Zone Size", Order = 141)]
      public Vector3 Size { get; set; }

      [JsonProperty(PropertyName = "Zone Rotation", Order = 142)]
      public float Rotation { get; set; }

      [JsonProperty(PropertyName = "Fixed Rotation", Order = 143)]
      public bool FixedRotation { get; set; }

      public override string[] ZoneSettings(Transform transform = null) =>
        GetZoneSettings(transform);

      protected override string[] GetZoneSettings(Transform transform = null)
      {
        var zoneSettings = new List<string>();
        if (Radius > 0f)
        {
          zoneSettings.Add("radius");
          zoneSettings.Add(Radius.ToString(CultureInfo.InvariantCulture));
        }
        else
        {
          zoneSettings.Add("size");
          zoneSettings.Add($"{Size.x} {Size.y} {Size.z}");
        }
        zoneSettings.Add("rotation");
        var transformedRotation = Rotation;
        if (transform && !FixedRotation)
        {
          transformedRotation += transform.rotation.eulerAngles.y;
        }
        zoneSettings.Add(transformedRotation.ToString(CultureInfo.InvariantCulture));
        GetBaseZoneSettings(zoneSettings);
        return zoneSettings.ToArray();
      }
    }

    // NOTE: EXPERIMENTAL order 200-249
    public class SphereCubeParentDynamicZone : BaseDynamicZone, ISphereZone, ICubeZone, IParentZone
    {
      [JsonProperty(PropertyName = "Zone Radius", Order = 200)]
      public float Radius { get; set; }

      [JsonProperty(PropertyName = "Zone Size", Order = 201)]
      public Vector3 Size { get; set; }

      [JsonProperty(PropertyName = "Transform Position", Order = 202)]
      public Vector3 Center { get; set; }

      public override string[] ZoneSettings(Transform transform = null) =>
        GetZoneSettings(transform);

      protected override string[] GetZoneSettings(Transform transform = null)
      {
        var zoneSettings = new List<string>();
        if (Radius > 0f)
        {
          zoneSettings.Add("radius");
          zoneSettings.Add(Radius.ToString(CultureInfo.InvariantCulture));
        }
        else
        {
          zoneSettings.Add("size");
          zoneSettings.Add($"{Size.x} {Size.y} {Size.z}");
        }
        GetBaseZoneSettings(zoneSettings);
        return zoneSettings.ToArray();
      }
    }

    #region Interface

    public interface ISphereZone
    {
      float Radius { get; set; }
    }

    public interface ICubeZone
    {
      Vector3 Size { get; set; }
    }

    public interface IParentZone
    {
      Vector3 Center { get; set; }
    }

    public interface IRotateZone
    {
      float Rotation { get; set; }

      bool FixedRotation { get; set; }
    }

    #endregion Interface

    #endregion Zone

    protected override void LoadConfig()
    {
      base.LoadConfig();
      try
      {
        configData = Config.ReadObject<ConfigData>();
        if (configData == null)
        {
          LoadDefaultConfig();
        }
        else
        {
          UpdateConfigValues();
        }
      }
      catch (Exception ex)
      {
        PrintError($"The configuration file is corrupted. \n{ex}");
        LoadDefaultConfig();
      }
      SaveConfig();
    }

    protected override void LoadDefaultConfig()
    {
      PrintWarning("Creating a new configuration file");
      configData = new ConfigData
      {
        Version = Version
      };
    }

    protected override void SaveConfig()
    {
      Config.WriteObject(configData);
    }

    private void UpdateConfigValues()
    {
      if (configData.Version >= Version) return;

      if (configData.Version <= new VersionNumber(4, 2, 0))
      {
        configData.Global.CompareRadius = 2f;
      }

      if (configData.Version <= new VersionNumber(4, 2, 4))
      {
        LoadData();
        SaveData();
      }

      if (configData.Version <= new VersionNumber(4, 2, 6))
      {
        if (GetConfigValue(out bool value, "General Event Settings", "Supply Signal Event", "Supply Drop Event Start When Spawned (If false, the event starts when landed)"))
        {
          configData.GeneralEvents.SupplySignal.StartWhenSpawned = value;
        }
        if (GetConfigValue(out value, "General Event Settings", "Timed Supply Event", "Supply Drop Event Start When Spawned (If false, the event starts when landed)"))
        {
          configData.GeneralEvents.TimedSupply.StartWhenSpawned = value;
        }
        if (GetConfigValue(out value, "General Event Settings", "Hackable Crate Event", "Hackable Crate Event Start When Spawned (If false, the event starts when unlocking)"))
        {
          configData.GeneralEvents.HackableCrate.StartWhenSpawned = value;
        }
      }

      configData.Version = Version;
    }

    private bool GetConfigValue<T>(out T value, params string[] path)
    {
      var configValue = Config.Get(path);
      if (configValue != null)
      {
        if (configValue is T t)
        {
          value = t;
          return true;
        }
        try
        {
          value = Config.ConvertValue<T>(configValue);
          return true;
        }
        catch (Exception ex)
        {
          PrintError($"GetConfigValue ERROR: path: {string.Join("\\", path)}\n{ex}");
        }
      }

      value = default;
      return false;
    }

    #endregion ConfigurationFile

    #region DataFile

    private StoredData storedData;

    private sealed class StoredData
    {
      public readonly Dictionary<string, TimedEvent> timedEvents = new();
      public readonly Dictionary<string, AutoEvent> autoEvents = new();

      public bool EventDataExists(string eventName) =>
        timedEvents.ContainsKey(eventName) || autoEvents.ContainsKey(eventName);

      public void RemoveEventData(string eventName)
      {
        if (!timedEvents.Remove(eventName)) autoEvents.Remove(eventName);
      }

      [JsonIgnore]
      public int CustomEventsCount => timedEvents.Count + autoEvents.Count;
    }

    private void LoadData()
    {
      try
      {
        storedData =
          Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
      }
      catch
      {
        storedData = null;
      }
      if (storedData == null)
      {
        ClearData();
      }
    }

    private void ClearData()
    {
      storedData = new StoredData();
      SaveData();
    }

    private void SaveData() =>
      Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

    #endregion DataFile

    #region LanguageFile

    private void Print(IPlayer iPlayer, string message)
    {
      if (iPlayer == null)
      {
        return;
      }
      if (iPlayer.Id == "server_console")
      {
        iPlayer.Reply(message, configData.Chat.Prefix);
        return;
      }
      var player = iPlayer.Object as BasePlayer;
      if (player != null)
      {
        Player.Message(player, message, $"<color={configData.Chat.PrefixColor}>{configData.Chat.Prefix}</color>", configData.Chat.SteamIdIcon);
        return;
      }
      iPlayer.Reply(message, $"<color={configData.Chat.PrefixColor}>{configData.Chat.Prefix}</color>");
    }

    private void Print(BasePlayer player, string message)
    {
      if (string.IsNullOrEmpty(message))
      {
        return;
      }
      Player.Message(player, message, string.IsNullOrEmpty(configData.Chat.Prefix) ?
          null : $"<color={configData.Chat.PrefixColor}>{configData.Chat.Prefix}</color>", configData.Chat.SteamIdIcon);
    }

    private string Lang(string key, string id = null, params object[] args)
    {
      try
      {
        return string.Format(lang.GetMessage(key, this, id), args);
      }
      catch (Exception)
      {
        PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
        throw;
      }
    }

    protected override void LoadDefaultMessages()
    {
      lang.RegisterMessages(new Dictionary<string, string>
      {
        ["NotAllowed"] = "You do not have permission to use this command",
        ["NoCustomEvent"] = "There is no custom event data",
        ["CustomEvents"] = "There are {0} custom event data",
        ["AutoEvent"] = "{0}.[AutoEvent]: '{1}'. AutoStart: {2}. Position: {3}",
        ["TimedEvent"] = "{0}.[TimedEvent]: '{1}'. Duration: {2}",
        ["NoEventName"] = "Please type event name",
        ["EventNameExist"] = "The event name {0} already exists",
        ["EventNameNotExist"] = "The event name {0} does not exist",
        ["EventDataAdded"] = "'{0}' event data was added successfully",
        ["EventDataRemoved"] = "'{0}' event data was removed successfully",
        ["EventStarted"] = "'{0}' event started successfully",
        ["EventStopped"] = "'{0}' event stopped successfully",
        ["Holster"] = "Ready your weapons!",
        ["Showing"] = "Showing active zones for {0} second(s)",

        ["AutoEventAutoStart"] = "'{0}' event auto start is {1}",
        ["AutoEventMove"] = "'{0}' event moves to your current location",
        ["TimedEventDuration"] = "'{0}' event duration is changed to {1} seconds",

        ["SyntaxError"] = "Syntax error, please type '<color=#ce422b>/{0} <help | h></color>' to view help",
        ["Syntax"] = "<color=#ce422b>/{0} add <eventName> [timed]</color> - Add event data. If added 'timed', it will be a timed event",
        ["Syntax1"] = "<color=#ce422b>/{0} remove <eventName></color> - Remove event data",
        ["Syntax2"] = "<color=#ce422b>/{0} start <eventName></color> - Start event",
        ["Syntax3"] = "<color=#ce422b>/{0} stop <eventName></color> - Stop event",
        ["Syntax4"] = "<color=#ce422b>/{0} edit <eventName> <true/false></color> - Changes auto start state of auto event",
        ["Syntax5"] = "<color=#ce422b>/{0} edit <eventName> <move></color> - Move auto event to your current location",
        ["Syntax6"] = "<color=#ce422b>/{0} edit <eventName> <time(seconds)></color> - Changes the duration of a timed event",
        ["Syntax7"] = "<color=#ce422b>/{0} list</color> - Display all custom events",
        ["Syntax8"] = "<color=#ce422b>/{0} show</color> - Show geometries for all active zones"
      }, this);

      lang.RegisterMessages(new Dictionary<string, string>
      {
        ["NotAllowed"] = "您没有权限使用该命令",
        ["NoCustomEvent"] = "您没有创建任何自定义事件数据",
        ["CustomEvents"] = "当前自定义事件数有 {0}个",
        ["AutoEvent"] = "{0}.[自动事件]: '{1}'. 自动启用: {2}. 位置: {3}",
        ["TimedEvent"] = "{0}.[定时事件]: '{1}'. 持续时间: {2}",
        ["NoEventName"] = "请输入事件名字",
        ["EventNameExist"] = "'{0}' 事件名字已存在",
        ["EventNameNotExist"] = "'{0}' 事件名字不存在",
        ["EventDataAdded"] = "'{0}' 事件数据添加成功",
        ["EventDataRemoved"] = "'{0}' 事件数据删除成功",
        ["EventStarted"] = "'{0}' 事件成功开启",
        ["EventStopped"] = "'{0}' 事件成功停止",
        ["Holster"] = "准备好武器!",
        ["Showing"] = "显示活动区域 {0} 秒",

        ["AutoEventAutoStart"] = "'{0}' 事件自动开启状态为 {1}",
        ["AutoEventMove"] = "'{0}' 事件移到了您的当前位置",
        ["TimedEventDuration"] = "'{0}' 事件的持续时间改为了 {1}秒",

        ["SyntaxError"] = "语法错误, 输入 '<color=#ce422b>/{0} <help | h></color>' 查看帮助",
        ["Syntax"] = "<color=#ce422b>/{0} add <eventName> [timed]</color> - 添加事件数据。如果后面加上'timed'，将添加定时事件数据",
        ["Syntax1"] = "<color=#ce422b>/{0} remove <eventName></color> - 删除事件数据",
        ["Syntax2"] = "<color=#ce422b>/{0} start <eventName></color> - 开启事件",
        ["Syntax3"] = "<color=#ce422b>/{0} stop <eventName></color> - 停止事件",
        ["Syntax4"] = "<color=#ce422b>/{0} edit <eventName> <true/false></color> - 改变自动事件的自动启动状态",
        ["Syntax5"] = "<color=#ce422b>/{0} edit <eventName> <move></color> - 移动自动事件的位置到您的当前位置",
        ["Syntax6"] = "<color=#ce422b>/{0} edit <eventName> <time(seconds)></color> - 修改定时事件的持续时间",
        ["Syntax7"] = "<color=#ce422b>/{0} list</color> - 显示所有自定义事件",
        ["Syntax8"] = "<color=#ce422b>/{0} show</color> - 显示所有活动区域的几何形"
      }, this, "zh-CN");
    }

    #endregion LanguageFile
  }
}


// --- End of file: DynamicPVP.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/damage-control ---
// --- Original File Path: D/DamageControl/DamageControl.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System.Reflection;
using Oxide.Core.Plugins;
using Oxide.Core.CSharp;
using UnityEngine.UI;
using System.Collections;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Rust;
using System.IO;
using UnityEngine;

namespace Oxide.Plugins {
 [Info("Damage Control", "MSpeedie", "2.5.14")]
 [Description("Allows authorized users to control damage settings for Time, animals, apc, minicopter, scrapcopter, balloons, barrels, buildings, bgrades, heli, npcs, players and zombies")]
 class DamageControl: CovalencePlugin {
  // note we check isAdmin as well so Admins get this by default
  readonly string permAdmin = "damagecontrol.admin";

  // zero = damage immuned  1 = no modifier 0.5 half damage 2 double damage
  public float ModifyDeployed;
  public float ModifyDoor;
  public float ModifyFloor;
  public float ModifyFoundation;
  public float ModifyHighExternal;
  public float ModifyOther;
  public float ModifyRoof;
  public float ModifyStairs;
  public float ModifyTC;
  public float ModifyBarrel;
  public float ModifyWall;
  public bool  AllowDecay;

  // these are to make checking look cleaner
  // action
  readonly List < string > dcaction = new List < string > {
   "help",
   "list",
   "set"
  };

	readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("DamageControl");
	private Dictionary<string, float> EntityModifier = new Dictionary<string, float>();


  // Class
  // note the code does some mapping as well:
  // bradley = apc
  // scientist = npc
  // heli = helicopter
  // scarecrows, murderer = zombie  (I know they are different but how often to do use both at the same time?)
  readonly List < string > dclass = new List < string > {
   "chicken",
   "bear",
   "wolf",
   "boar",
   "ridablehorse",
   "horse",
   "stag",
   "buildingblock",
   "npc",
   "player",
   "GlobalTime",
   "PlayerTime",
   "AnimalTime",
   "NPCTime",
   "OtherTime",
   "HeliTime",
   "BradleyTime",
   "BuildingTime",
   "zombie",
   "apc",
   "helicopter",
   "building",
   "bgrade",
   "ballon",
   "minicopter",
   "scrapcopter",
   "samsite"
  };

  // Time types
  readonly List < string > ttype = new List < string > {
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25"
  };

  // bgrade types
  readonly List < string > bgtype = new List < string > {
  "Twigs",
  "Wood",
  "Stone",
  "Metal",
  "TopTier"
  };

  // building material types
  readonly List < string > btype = new List < string > {
   "allowdecay",
   "deployed",
   "door",
   "floor",
   "foundation",
   "highexternal",
   "other",
   "roof",
   "stairs",
   "toolcupboard",
   "wall",
   "barrel"
  };

  // damage types (some seem rather redundant, go FacePunch)
  // this order matched the HitInfo, do not touch or it will break the list command
  readonly List < string > dtype = new List < string > {
    "generic",
	"hunger",
	"thirst",
	"cold",
	"drowned",
	"heat",
	"bleeding",
	"poison",
	"suicide",
	"bullet",
	"slash",
	"blunt",
	"fall",
	"radiation",
	"bite",
	"stab",
	"explosion",
	"radiationexposure",
	"coldexposure",
	"decay",
	"electricshock",
	"arrow",
	"antivehicle",
	"collision",
	"fun_water"

  };

  // deployables list
  List < string > deployable_list = new List< string >();

  // max size of damage types, if this changed the dtype above needs to be updated
  private
  const int DamageTypeMax = (int) DamageType.LAST;

  // arrays of multipliers by class and one with zero to make buidlings immuned
  float[] _Zeromultipliers = new float[DamageTypeMax]; // immuned, zero damage
  float[] _Onemultipliers = new float[DamageTypeMax]; // normal damage

  // Animals
  float[] _Bearmultipliers = new float[DamageTypeMax]; // Bear
  float[] _Boarmultipliers = new float[DamageTypeMax]; // Boar
  float[] _Chickenmultipliers = new float[DamageTypeMax]; // Chicken
  float[] _Horsemultipliers = new float[DamageTypeMax]; // Horse
  float[] _RidableHorsemultipliers = new float[DamageTypeMax]; // RidableHorse
  float[] _Stagmultipliers = new float[DamageTypeMax]; // Stag
  float[] _Wolfmultipliers = new float[DamageTypeMax]; // Wolf

  float[] _Balloonmultipliers = new float[DamageTypeMax]; // Balloon
  float[] _Minicoptermultipliers = new float[DamageTypeMax]; // Minicopter
  float[] _Scrapcoptermultipliers = new float[DamageTypeMax]; // Scrap Helicopter
  float[] _SAMSitemultipliers = new float[DamageTypeMax]; // SAMSite
  float[] _Buildingmultipliers = new float[DamageTypeMax]; // Buildings
  float[] _Zombiemultipliers = new float[DamageTypeMax]; // Scarecrow, Murderer (Halloween) and Zombies
  float[] _Playermultipliers = new float[DamageTypeMax]; // Players
  float[] _NPCmultipliers = new float[DamageTypeMax]; // Scientists and NPCs
  float[] _APCmultipliers = new float[DamageTypeMax]; // APC aka Bradley
  float[] _Helimultipliers = new float[DamageTypeMax]; // Helicopter

  // Time multiplier
  string _time_type = "game";                       // Set to game or real
  float[] _GlobalTimemultipliers = new float[24];   // Global Per Hour Multiplier
  float[] _PlayerTimemultipliers = new float[24];   // Player Per Hour Multiplier
  float[] _AnimalTimemultipliers = new float[24];   // Animal Per Hour Multiplier
  float[] _NPCTimemultipliers = new float[24];      // NPC Per Hour Multiplier
  float[] _HeliTimemultipliers = new float[24];     // Heli Per Hour Multiplier
  float[] _BradleyTimemultipliers = new float[24];  // Bradley Per Hour Multiplier
  float[] _OtherTimemultipliers = new float[24];    // Other Per Hour Multiplier
  float[] _BuildingTimemultipliers = new float[24]; // Buildings Per Hour Multiplier

  // bgrade multipliers
  float _TwigsMultiplier  = 1.0F; // Twigs Multiplier
  float _WoodMultiplier  = 1.0F; // Wood Multiplier
  float _StoneMultiplier = 1.0F; // Stone Multiplier
  float _MetalMultiplier = 1.0F; // Metal Multiplier
  float _TopTierMultiplier = 1.0F; // TopTier Multiplier

  // bypasses if set these set damage to minimum of 1 times even if the prior settings set it below that
  // bypasses, warning these could be used to grief bases in PVE
  // note these apply the bgrade multipler after this one so you could for example make twigs take massive damage from the heli (cackle)
  bool Heli_bypass     = false; // Heli bypass


  // to indicate I need to update the json file
  bool _didConfigChange;

  void Init() {
   permission.RegisterPermission(permAdmin, this);
   LoadConfigValues();
   build_dep_list();
   EntityModifier = dataFile.ReadObject<Dictionary<string, float>>();
  }

  protected override void LoadDefaultMessages() {
   // English
   lang.RegisterMessages(new Dictionary < string, string > {
    // general messages
    ["help"] = "You can use list to show a setting and set to set setting.  For example /dc list building door or /dc set npc arrow 2 .",
    ["nopermission"] = "You do not have permission to use that command.",
    ["wrongsyntax"] = "Incorrect Syntax used, please specify help, list or set and then the parameters for those actions.",
    ["wrongsyntaxList"] = "Incorrect Syntax used for action List. Parameters are optionally: Class, Type.",
    ["wrongsyntaxSet"] = "Incorrect Syntax used for action Set. Parameters are: Class, Type, Value.",
    ["wrongaction"] = "Action can be Help, List or Set.",
    ["wrongclass"] = "Class can only be set to one of SAMSite, Minicopter, Scrapcopter, Balloon, Bear, Boar, Chicken, Horse, Ridable Horse, Stag, Wolf, APC (or Bradley), BGrade, Building, BuildingBlock, Player, Heli, NPC (which includes scientists) , Zombie (which includes Scarecrows, Murderers).",
    ["wrongbtype"] = "That is not a supported type: allowdecay, foundation, wall, floor, door, stair, roof, highexternal, barrel, other.",
    ["wrongttype"] = "That is not a supported type: 0 through 25.",
    ["wrongbgtype"] = "That is not a supported type: twigs, wood, stone, metal, toptier. (or 0-4)",
    ["wrongtype"] = "That is not a supported type: Arrow, Bite, Bleeding, Blunt, Bullet, Cold, ColdExposure, Decay, Drowned, ElectricShock, Explosion, Fall, Generic, Heat, Hunger, Poison, Radiation, RadiationExposure, Slash, Stab, Suicide, Thirst.",
    ["wrongbvalues"] = "Building Values can only be set to true or false.",
    ["wrongnvalues"] = "Multiplier Values can only be set from 0 to 100.00.",
    ["frontmess"] = "You have set",
    ["bmiddlemess"] = "protection to",
    ["middlemess"] = "to",
    ["endmess"] = ".",
    // Building Types
    ["door"] = "Doors",
    ["floor"] = "Floors",
    ["foundation"] = "Foundations",
    ["other"] = "Other Building Materials",
    ["roof"] = "Roofs",
    ["stairs"] = "Stairs",
    ["wall"] = "Walls",
	["toolcupboard"] = "ToolCupboard",
	["deployed"] = "Deployable",
	["highexternal"] = "High External",
    // Class
    ["apc"] = "APC aka Bradley",
    ["bear"] = "bear",
    ["boar"] = "boar",
    ["balloon"] = "Balloon",
    ["building"] = "Building",
    ["buildingblock"] = "Building Block",
    ["chicken"] = "Chicken",
    ["heli"] = "Helicopter",
    ["horse"] = "Horse",
	["minicopter"] = "Minicopter",
	["scrapcopter"] = "Scrapcopter",
	["samsite"] = "SAMSite",
    ["npc"] = "NPC aka Scientist",
    ["player"] = "Player",
    ["ridablehorse"] = "Ridable Horse",
    ["stag"] = "Stag",
	["GlobalTime"] = "Global Time",
	["PlayerTime"] = "PLayer Time",
	["AnimalTime"] = "Animal Time",
	["NPCTime"] = "NPC Time",
	["HeliTime"] = "Heli Time",
	["BradleyTime"] = "Bradley Time",
	["OtherTime"] = "Other Time",
	["BuildingTime"] = "Buidling Time",
	["bgrade"] = "Build Grade",
    ["wolf"] = "Wolf",
    ["zombie"] = "Zombie, Murderer and Scarecrows",
    ["murderer"] = "Zombie, Murderer and Scarecrows",
    ["scientist"] = "NPC aka Scientist",
    // Damage Types
    ["arrow"] = "Arrow",
    ["bite"] = "Bite",
    ["bleeding"] = "Bleeding",
    ["blunt"] = "Blunt",
    ["bullet"] = "Bullet",
    ["cold"] = "Cold",
    ["coldexposure"] = "Cold Exposure",
    ["decay"] = "Decay",
    ["drowned"] = "Drowned",
    ["electricshock"] = "Electric Shock",
    ["explosion"] = "Explosion",
    ["fall"] = "Fall",
    ["generic"] = "Generic",
    ["heat"] = "Heat",
    ["hunger"] = "Hunger",
    ["poison"] = "Poison",
    ["radiation"] = "Radiation",
    ["radiationexposure"] = "Radiation Exposure",
    ["slash"] = "Slash",
    ["stab"] = "Stab",
    ["suicide"] = "Suicide",
    ["thirst"] = "Thirst",
    // Multiplier headings
    ["multipliers"] = "Multipliers"
   }, this);
  }

	void build_dep_list()
    {
        foreach (var itemDef in ItemManager.GetItemDefinitions().ToList())
             {
                var mod = itemDef.GetComponent<ItemModDeployable>();
                if (mod != null)
				{
					if (itemDef.name.LastIndexOf(".item") > 0)
					{
						deployable_list.Add(itemDef.name.Substring(0,itemDef.name.LastIndexOf(".item")).Replace("_",".").ToLower());
						deployable_list.Add(itemDef.name.Substring(0,itemDef.name.LastIndexOf(".item")).Replace("_",".").ToLower()+".deployed"); // hack to deal with some having deployed and some not
					}
					else
					{
						deployable_list.Add(itemDef.name.Replace("_",".").ToLower());
						deployable_list.Add(itemDef.name.Replace("_",".").ToLower()+".deployed");  // hack to deal with some having deployed and some not
					}
				}
             }
		// deal with messed up repair_bench losing its "_" to become repairbench
		deployable_list.Add("repairbench.deployed");
		deployable_list.Add("refinery.small.deployed");

		// debugging dump
		//foreach (string p in deployable_list)
        //{
        //    PrintWarning(p);
        //}
    }


  void Loaded() => LoadConfigValues();
  protected override void LoadDefaultConfig() => Puts("New configuration file created.");

  void LoadConfigValues() {
   foreach(DamageType val in Enum.GetValues(typeof(DamageType))) {
    if (val == DamageType.LAST) continue;
    _APCmultipliers[(int) val] = Convert.ToSingle(GetConfigValue("APC_Multipliers", val.ToString().ToLower(), 1.0));
    _Balloonmultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Balloon_Multipliers", val.ToString().ToLower(), 1.0));
    _Bearmultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Bear_Multipliers", val.ToString().ToLower(), 1.0));
    _Boarmultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Boar_Multipliers", val.ToString().ToLower(), 1.0));
    _Buildingmultipliers[(int) val] = Convert.ToSingle(GetConfigValue("BuildingBlock_Multipliers", val.ToString().ToLower(), 1.0));
    _Chickenmultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Chicken_Multipliers", val.ToString().ToLower(), 1.0));
    _Helimultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Heli_Multipliers", val.ToString().ToLower(), 1.0));
    _Horsemultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Horse_Multipliers", val.ToString().ToLower(), 1.0));
    _RidableHorsemultipliers[(int) val] = Convert.ToSingle(GetConfigValue("RidableHorse_Multipliers", val.ToString().ToLower(), 1.0));
    _SAMSitemultipliers[(int) val] = Convert.ToSingle(GetConfigValue("SAMSite_Multipliers", val.ToString().ToLower(), 1.0));
    _Minicoptermultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Minicopter_Multipliers", val.ToString().ToLower(), 1.0));
    _Scrapcoptermultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Scrapcopter_Multipliers", val.ToString().ToLower(), 1.0));
    _NPCmultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Scientist_Multipliers", val.ToString().ToLower(), 1.0));
    _Playermultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Player_Multipliers", val.ToString().ToLower(), 1.0));
    _Stagmultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Stag_Multipliers", val.ToString().ToLower(), 1.0));
    _Wolfmultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Wolf_Multipliers", val.ToString().ToLower(), 1.0));
    _Zombiemultipliers[(int) val] = Convert.ToSingle(GetConfigValue("Zombie_Multipliers", val.ToString().ToLower(), 1.0)); // also murderers and scarecrows
    _Zeromultipliers[(int) val] = 0;
    _Onemultipliers[(int) val] = 1;
	}
   for (var i = 0; i < 24; i++) {
	   // Puts(i.ToString());
       _GlobalTimemultipliers[(int) i] = Convert.ToSingle(GetConfigValue("Global_Time_Multipliers", i.ToString().PadLeft(2,' '), 1.0)); // Time in hours
   }

   for (var i = 0; i < 24; i++) {
	   // Puts(i.ToString());
       _PlayerTimemultipliers[(int) i] = Convert.ToSingle(GetConfigValue("Player_Time_Multipliers", i.ToString().PadLeft(2,' '), 1.0)); // Time in hours
   }

   for (var i = 0; i < 24; i++) {
	   // Puts(i.ToString());
       _AnimalTimemultipliers[(int) i] = Convert.ToSingle(GetConfigValue("Animal_Time_Multipliers", i.ToString().PadLeft(2,' '), 1.0)); // Time in hours
   }

   for (var i = 0; i < 24; i++) {
	   // Puts(i.ToString());
       _NPCTimemultipliers[(int) i] = Convert.ToSingle(GetConfigValue("NPC_Time_Multipliers", i.ToString().PadLeft(2,' '), 1.0)); // Time in hours
   }

   for (var i = 0; i < 24; i++) {
	   // Puts(i.ToString());
       _HeliTimemultipliers[(int) i] = Convert.ToSingle(GetConfigValue("Heli_Time_Multipliers", i.ToString().PadLeft(2,' '), 1.0)); // Time in hours
   }

   for (var i = 0; i < 24; i++) {
	   // Puts(i.ToString());
       _BradleyTimemultipliers[(int) i] = Convert.ToSingle(GetConfigValue("Bradley_Time_Multipliers", i.ToString().PadLeft(2,' '), 1.0)); // Time in hours
   }

   for (var i = 0; i < 24; i++) {
	   // Puts(i.ToString());
       _OtherTimemultipliers[(int) i] = Convert.ToSingle(GetConfigValue("Other_Time_Multipliers", i.ToString().PadLeft(2,' '), 1.0)); // Time in hours
   }

   for (var i = 0; i < 24; i++) {
	   // Puts(i.ToString());
       _BuildingTimemultipliers[(int) i] = Convert.ToSingle(GetConfigValue("Building_Time_Multipliers", i.ToString().PadLeft(2,' '), 1.0)); // Time in hours
   }

   ModifyFoundation = Convert.ToSingle(GetConfigValue("Building", "ModifyFoundation",  1.0));
   ModifyFloor = Convert.ToSingle(GetConfigValue("Building", "ModifyFloor",  1.0));
   ModifyRoof = Convert.ToSingle(GetConfigValue("Building", "ModifyRoof",  1.0));
   ModifyWall = Convert.ToSingle(GetConfigValue("Building", "ModifyWall",  1.0));
   ModifyStairs = Convert.ToSingle(GetConfigValue("Building", "ModifyStairs",  1.0));
   ModifyDoor = Convert.ToSingle(GetConfigValue("Building", "ModifyDoor",  1.0));
   ModifyOther = Convert.ToSingle(GetConfigValue("Building", "ModifyOther",  1.0));
   ModifyDeployed = Convert.ToSingle(GetConfigValue("Building", "ModifyDeployed",  1.0));
   ModifyTC = Convert.ToSingle(GetConfigValue("Building", "ModifyToolCupboard",  1.0));
   ModifyBarrel= Convert.ToSingle(GetConfigValue("Building", "ModifyBarrel",  1.0));
   ModifyHighExternal = Convert.ToSingle(GetConfigValue("Building", "ModifyHighExternal",  1.0));

   AllowDecay = Convert.ToBoolean(GetConfigValue("Building", "AllowDecay", "true"));

   _TwigsMultiplier   = Convert.ToSingle(GetConfigValue("Building_Grade_Multipliers", "Twigs",   1.0));
   _WoodMultiplier    = Convert.ToSingle(GetConfigValue("Building_Grade_Multipliers", "Wood",    1.0));
   _StoneMultiplier   = Convert.ToSingle(GetConfigValue("Building_Grade_Multipliers", "Stone",   1.0));
   _MetalMultiplier   = Convert.ToSingle(GetConfigValue("Building_Grade_Multipliers", "Metal",   1.0));
   _TopTierMultiplier = Convert.ToSingle(GetConfigValue("Building_Grade_Multipliers", "TopTier", 1.0));

   Heli_bypass    = Convert.ToBoolean(GetConfigValue("Bypasses", "Heli_bypass", "false"));
   _time_type     = Convert.ToString(GetConfigValue("Time", "Time_Type", "game"));

   if (!_didConfigChange) return;
   Puts("Configuration file updated.");
   SaveConfig();
  }

	object GetConfigValue(string category, string setting, object defaultValue)
	{
		var data = Config[category] as Dictionary < string, object > ;
		object value;
		if (data == null)
		{
			data = new Dictionary < string, object > ();
			Config[category] = data;
			_didConfigChange = true;
		}

		if (data.TryGetValue(setting, out value)) return value;
		value = defaultValue;
		data[setting] = value;
		_didConfigChange = true;
		return value;
	}

	object SetConfigValue(string category, string setting, object defaultValue)
	{
		var data = Config[category] as Dictionary < string, object > ;
		object value;

		if (data == null)
		{
		data = new Dictionary < string, object > ();
		Config[category] = data;
		_didConfigChange = true;
		}

		value = defaultValue;
		data[setting] = value;
		_didConfigChange = true;
		return value;
	}

  [Command("damagecontrol", "damcon", "dc")]
  void chatCommand_DamageControl(IPlayer iplayer, string command, string[] args) {

   string paramaaction = null;
   string paramaclass = null;
   string paramatype = null;
   string paramavalue = null;
   Boolean newbool = false;
   float newnumber = -1;

   if (!IsAllowed(iplayer))
   {
    iplayer.Reply(Lang("nopermission", iplayer.Id));
   }
   else
   {
    if (args == null || args.Length < 1)
	{
     iplayer.Reply(Lang("wrongsyntax", iplayer.Id));
     return;
    }
	else
	{
     paramaaction = args[0].ToLower();
     if (!dcaction.Contains(paramaaction))
	 {
      iplayer.Reply(Lang("wrongaction", iplayer.Id, args[0]));
      return;
     }
	 if (paramaaction == "help")
	 {
      iplayer.Reply(Lang("help", iplayer.Id, args[0]));
      return;
     }
     else if (paramaaction == "set" && args.Length != 4)
	 {
	  iplayer.Reply(Lang("wrongsyntaxSet", iplayer.Id));
      return;
	 }
     else if (paramaaction == "list" && args.Length < 2 )
	 {
      iplayer.Reply(Lang("wrongsyntaxList", iplayer.Id));
      return;
     }
	 else
	 {
      if (args.Length > 1)
	  {
		paramaclass = args[1].ToLower();
		if (paramaclass == "build")
		   paramaclass = "building";
	   else if (paramaclass.Contains("brad"))
		   paramaclass = "apc";
	   else if (paramaclass.Contains("murder"))
		   paramaclass = "zombie";
	   else if (paramaclass.Contains("heli"))
		   paramaclass = "helicopter";
	   else if (paramaclass == "science")
		   paramaclass = "npc";
	   }
      else
       paramaclass = null;
      if (args.Length > 2)
	  {
		paramatype = args[2].ToLower();
		if (paramatype == "stair")
			paramatype = "stairs";
		if (paramatype.Length > 6 && paramatype.Substring(0,6) == "modify")
			paramatype = paramatype.Substring(6);
	  }
      else
       paramatype = null;
      if (args.Length > 3)
       paramavalue = args[3].ToLower();
      else
       paramavalue = null;
     }

     if (paramaaction == "set" && paramaclass == null) {
      iplayer.Reply(Lang("wrongclass", iplayer.Id, args[1]));
      return;
     }
     if (paramaclass != null && paramaclass != "" && !dclass.Contains(paramaclass)) {
      iplayer.Reply(Lang("wrongclass", iplayer.Id, args[1]));
      return;
     }
     if (paramavalue == "1" && paramaclass.Contains("build") && paramatype.Contains("decay")) {
      paramavalue = "true";
     } else if (paramavalue == "0" && paramaclass.Contains("build") && paramatype.Contains("decay")) {
      paramavalue = "false";
     }
     if (paramavalue != "true" && paramavalue != "false" && paramavalue != null)
      try {
       newnumber = Convert.ToSingle(paramavalue);
      } catch (FormatException) {
       iplayer.Reply(Lang("wrongnvalues", iplayer.Id, args[3]));
       return;
      } catch (OverflowException) {
       iplayer.Reply(Lang("wrongnvalues", iplayer.Id, args[3]));
       return;
      }
     if (paramaclass.Contains("build") && paramatype.Contains("decay"))
	 {
		if (paramavalue != "true" && paramavalue != "false" && paramaaction == "set")
		{
			iplayer.Reply(Lang("wrongbvalues", iplayer.Id, args[3]));
			return;
		}
     } else if ((newnumber < 0 || newnumber > 100) && paramaaction == "set") {
      iplayer.Reply(Lang("wrongnvalues", iplayer.Id, args[3]));
      return;
     }
     if (paramaaction == "set" || paramatype != null) {
		// change text to boolean
		if (paramavalue == "true")
			newbool = true;
		else if (paramavalue == "false")
			newbool = false;

		if (paramaclass.Contains("Time")) {
			// check type values
			if (!ttype.Contains(paramatype)) {
				iplayer.Reply(Lang("wrongttype", iplayer.Id, args[2]));
				return;
			}
		} else if (paramaclass.Contains("bgrade")) {
			// Puts("before paramatype: " + paramatype);
			// convert numbers to names
			if (paramatype == "0" || paramatype.Contains("twig"))
				paramatype = "Twigs";
			else if (paramatype == "1" || paramatype.Contains("wood"))
				paramatype = "Wood";
			else if (paramatype == "2" || paramatype.Contains("stone"))
				paramatype = "Stone";
			else if (paramatype == "3" || paramatype.Contains("metal"))
				paramatype = "Metal";
			else if (paramatype == "4" || paramatype.Contains("toptier"))
				paramatype = "TopTier";
			// Puts("After paramatype: " + paramatype);

			// check type values
			if (!bgtype.Contains(paramatype)) {
				iplayer.Reply(Lang("wrongbgtype", iplayer.Id, args[2]));
				return;
			}
		} else if (!paramaclass.Contains("bgrade")  && (!paramaclass.Contains("build") || paramaclass.Contains("block"))) {
			// check type values
			if (!dtype.Contains(paramatype)) {
				iplayer.Reply(Lang("wrongtype", iplayer.Id, args[2]));
				return;
			}
		} else {
			// check type values
			if (!btype.Contains(paramatype)) {
				iplayer.Reply(Lang("wrongbtype", iplayer.Id, args[2]));
				return;
			}
		}
	 }

	 if (paramaaction == "set")
	 {
		if (paramaclass.Contains("bgrade"))
		{
			SetConfigValue("Building_Grade_Multipliers", paramatype, newnumber);
		}
		else if (paramaclass.Contains("bypasses")) 
		{
			if (paramatype.Contains("heli_bypass")) 
			{
				Heli_bypass = newbool;
				SetConfigValue("Bypasses", "Heli_bypass", newbool);
			}
		}
		else if (paramaclass.Contains("time")) 
		{
			if (paramatype.Contains("Time_Type")) 
			{
				_time_type = paramavalue;
				SetConfigValue("time", "Time_Type", paramavalue);
			}
		}
		else if (paramaclass.Contains("build") && !paramaclass.Contains("block")) {
		if (paramatype.Contains("decay")) {
			AllowDecay = newbool;
			SetConfigValue("Building", "AllowDecay", newbool);
		}else if (paramatype.Contains("found")) {
			ModifyFoundation = newnumber;
			SetConfigValue("Building", "ModifyFoundation", newnumber);
		} else if (paramatype.Contains("floor")) {
			ModifyFloor = newnumber;
			SetConfigValue("Building", "ModifyFloor", newnumber);
		} else if (paramatype.Contains("door")) {
			ModifyDoor = newnumber;
			SetConfigValue("Building", "ModifyDoor", newnumber);
		} else if (paramatype.Contains("highexternal")) {
			ModifyHighExternal = newnumber;
			SetConfigValue("Building", "ModifyHighExternal", newnumber);
		} else if (paramatype.Contains("wall")) {
			ModifyWall = newnumber;
			SetConfigValue("Building", "ModifyWall", newnumber);
		} else if (paramatype.Contains("stair")) {
			ModifyStairs = newnumber;
			SetConfigValue("Building", "ModifyStairs", newnumber);
		} else if (paramatype.Contains("roof")) {
			ModifyRoof = newnumber;
			SetConfigValue("Building", "ModifyRoof", newnumber);
		} else if (paramatype.Contains("other")) {
			ModifyOther = newnumber;
			SetConfigValue("Building", "ModifyOther", newnumber);
		} else if (paramatype.Contains("deploy")) {
			ModifyDeployed = newnumber;
			SetConfigValue("Building", "ModifyDeployed", newnumber);
		} else if (paramatype.Contains("cupboard")) {
			ModifyTC = newnumber;
			SetConfigValue("Building", "ModifyToolCupboard", newnumber);
		} else if (paramatype.Contains("barrel")) {
			ModifyBarrel = newnumber;
			SetConfigValue("Building", "ModifyBarrel", newnumber);
		}

		} else if (paramaclass.Contains("build") && paramaclass.Contains("block")) {
		SetConfigValue("BuildingBlock_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("apc") || paramaclass.Contains("bradley")) {
		SetConfigValue("APC_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("heli")) {
		SetConfigValue("Heli_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("balloon")) {
		SetConfigValue("Balloon_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("minicopter")) {
		SetConfigValue("Minicopter_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("scrapcopter")) {
		SetConfigValue("Scrapcopter_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("samsite")) {
		SetConfigValue("SAMSite_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("npc") || paramaclass.Contains("scientist")) {
		SetConfigValue("Scientist_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("zombie") || paramaclass.Contains("murderer") || paramaclass.Contains("scarecrow")) {
		SetConfigValue("Zombie_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("player")) {
		SetConfigValue("Player_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("bear")) {
		SetConfigValue("Bear_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("boar")) {
		SetConfigValue("Boar_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("chicken")) {
		SetConfigValue("Chicken_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("ridablehorse")) {
		SetConfigValue("RidableHorse_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("horse")) {
		SetConfigValue("Horse_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("stag")) {
		SetConfigValue("Stag_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("GlobalTime")) {
		SetConfigValue("GlobalTime_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("PlayerTime")) {
		SetConfigValue("PlayerTime_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("AnimalTime")) {
		SetConfigValue("AnimalTime_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("NPCTime")) {
		SetConfigValue("NPCTime_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("BuildingTime")) {
		SetConfigValue("BuildingTime_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("OtherTime")) {
		SetConfigValue("OtherTime_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("HeliTime")) {
		SetConfigValue("HeliTime_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("BradleyTime")) {
		SetConfigValue("BradleyTime_Multipliers", paramatype, newnumber);
		} else if (paramaclass.Contains("wolf")) {
		SetConfigValue("Wolf_Multipliers", paramatype, newnumber);
		}
		SaveConfig();
		if (paramavalue != "true" && paramavalue != "false") {
		iplayer.Reply(Lang("frontmess", iplayer.Id) + " " + Lang(paramaclass, iplayer.Id) + " " + Lang(paramatype, iplayer.Id) + " " + Lang("multipliers", iplayer.Id) + " " +
			Lang("middlemess", iplayer.Id) + " " + newnumber.ToString("G4") + " " + Lang("endmess"));
		} else {
		iplayer.Reply(Lang("frontmess", iplayer.Id) + " " + Lang(paramaclass, iplayer.Id) + " " + Lang(paramatype, iplayer.Id) + " " +
						Lang("bmiddlemess", iplayer.Id) + " " + paramavalue + " " + Lang("endmess", iplayer.Id));
		}

     } else // list
     {
		if (paramaclass != null && paramatype != null) // dump a type per class
		{
		 printvalue(iplayer, paramaclass, paramatype, getHitScale(paramaclass,paramatype.ToLower()));
		}
		else if (paramaclass != null) // dump a class
		{
			if (paramaclass.Contains("bgrade"))
				for (var i = 0; i < bgtype.Count; i++) {
					printvalue(iplayer, paramaclass, bgtype[i], getHitScale(paramaclass,bgtype[i].ToLower()));
				}
			else if (paramaclass.Contains("build") && !paramaclass.Contains("block"))
				for (var i = 0; i < btype.Count; i++) {
					printvalue(iplayer, paramaclass, btype[i], getHitScale(paramaclass,btype[i].ToLower()));
				}
			else
				for (var i = 0; i < DamageTypeMax; i++) {
					printvalue(iplayer, paramaclass, dtype[i], getHitScale(paramaclass,dtype[i].ToLower()));
				}
		}
		// this is just too long to read in game so I have removed it
		//else // dump all
		//{
		//	// Buildings
		//	for (var k = 0; k < btype.Count; k++) {
		//			printvalue(player, paramaclass, btype[k], getHitScale(paramaclass,btype[k]));
		//		}
		//	// all other types
		//	for (var i = 0; i < dclass.Count-1; i++) {
		//		for (var j = 0; j < DamageTypeMax; j++) {
		//			printvalue(player, dclass[i], dtype[j], getHitScale(paramaclass,dtype[j]));
		//		}
		//	}
		//}
     }
    }
   }
   return;
  }

    void printvalue(IPlayer player, string paramaclass, string paramatype, string paravalue) {
	if (paramaclass.Contains("build") && !paramaclass.Contains("block"))
		 {
			player.Reply(Lang("frontmess", player.Id) + " " + Lang(paramaclass, player.Id) + " " + Lang(paramatype, player.Id) + " " +
	                Lang("bmiddlemess", player.Id) + " " + paravalue + " " + Lang("endmess", player.Id));
		 }
		else
		 {
			 player.Reply(Lang("frontmess", player.Id) + " " + Lang(paramaclass, player.Id) + " " + Lang(paramatype, player.Id) + " " + Lang("multipliers", player.Id) + " " +
								Lang("middlemess", player.Id) + " " + paravalue + " " + Lang("endmess"));
		 }
	}


    string getHitScale(string paramaclass, string paramatype) {

	float  tempnumber = -1;
	string tempstring = "Undefined";

	if (paramaclass.Contains("build") && !paramaclass.Contains("block")) {
       if (paramatype.Contains("found")) {
			tempstring = Convert.ToString(ModifyFoundation);
       } else if (paramatype.Contains("floor")) {
			tempstring = Convert.ToString(ModifyFloor);
       } else if (paramatype.Contains("door")) {
			tempstring = Convert.ToString(ModifyDoor);
       } else if (paramatype.Contains("wall")) {
			tempstring = Convert.ToString(ModifyWall);
       } else if (paramatype.Contains("stair")) {
			tempstring = Convert.ToString(ModifyStairs);
       } else if (paramatype.Contains("roof")) {
			tempstring = Convert.ToString(ModifyRoof);
       } else if (paramatype.Contains("other")) {
			tempstring = Convert.ToString(ModifyOther);
       } else if (paramatype.Contains("deployed")) {
			tempstring = Convert.ToString(ModifyDeployed);
       }  else if (paramatype.Contains("highexternal")) {
			tempstring = Convert.ToString(ModifyHighExternal);
       }  else if (paramatype.Contains("cupboard")) {
			tempstring = Convert.ToString(ModifyTC);
       } else if (paramatype.Contains("barrel")) {
			tempstring = Convert.ToString(ModifyBarrel);
       }
	}
	else
	{
		if (paramaclass.Contains("build") && paramaclass.Contains("block")) {
			tempnumber = _Buildingmultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("apc") || paramaclass.Contains("bradley")) {
			tempnumber = _APCmultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("heli")) {
			tempnumber = _Helimultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("balloon")) {
			tempnumber = _Balloonmultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("minicopter")) {
			tempnumber = _Minicoptermultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("scrapcopter")) {
			tempnumber = _Scrapcoptermultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("samsite")) {
			tempnumber = _SAMSitemultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("npc") || paramaclass.Contains("scientist")) {
			tempnumber = _NPCmultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("zombie") || paramaclass.Contains("murderer") || (paramaclass.Contains("scarecrow") && !paramaclass.Contains("deployed"))) {
			tempnumber = _Zombiemultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("player")) {
			tempnumber = _Playermultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("bear")) {
			tempnumber = _Bearmultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("boar")) {
			tempnumber = _Boarmultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("chicken")) {
			tempnumber = _Chickenmultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("ridablehorse")) {
			tempnumber = _RidableHorsemultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("horse")) {
			tempnumber = _Horsemultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("stag")) {
			tempnumber = _Stagmultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("GlobalTime")) {
			tempnumber = _GlobalTimemultipliers[ttype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("PlayerTime")) {
			tempnumber = _PlayerTimemultipliers[ttype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("AnimalTime")) {
			tempnumber = _AnimalTimemultipliers[ttype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("NPCTime")) {
			tempnumber = _NPCTimemultipliers[ttype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("OtherTime")) {
			tempnumber = _OtherTimemultipliers[ttype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("BuildingTime")) {
			tempnumber = _BuildingTimemultipliers[ttype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("HeliTime")) {
			tempnumber = _HeliTimemultipliers[ttype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("BradleyTime")) {
			tempnumber = _BradleyTimemultipliers[ttype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("wolf")) {
			tempnumber = _Wolfmultipliers[dtype.IndexOf(paramatype)];
		} else if (paramaclass.Contains("bgrade")) {
			if (paramatype == "twigs" || paramatype == "0")
				tempnumber = _TwigsMultiplier;
			else if (paramatype == "wood" || paramatype == "1")
				tempnumber = _WoodMultiplier;
			else if (paramatype == "stone" || paramatype == "2")
				tempnumber = _StoneMultiplier;
			else if (paramatype == "metal" || paramatype == "3")
				tempnumber = _MetalMultiplier;
			else if (paramatype == "toptier" || paramatype == "4")
				tempnumber = _TopTierMultiplier;
		}
		tempstring = tempnumber.ToString();
	}
	return tempstring;
  }

  void setHitScale(HitInfo hitInfo, float[] _multipliers, float addlnmod) {

	//Puts ("addlnmod: " + addlnmod.ToString());

	// added logic to apply decay
	for (var i = 0; i < DamageTypeMax; i++)
	{
		if (AllowDecay == true &&
		   ((DamageType) i == Rust.DamageType.Decay || (DamageType) i == Rust.DamageType.Generic ) &&
		   _multipliers[i] * addlnmod < 0.01F &&
		   !(hitInfo.Initiator is BaseCombatEntity) &&
			hitInfo?.Weapon?.GetItem()?.info?.displayName?.english == null)
		{
			if (_multipliers[i] == 0)
				_multipliers[i] = 1;
			if (addlnmod == 0)
				addlnmod = 1;

			hitInfo.damageTypes.Scale((DamageType) i, _multipliers[i] * addlnmod);
		}
		else
			hitInfo.damageTypes.Scale((DamageType) i, _multipliers[i] * addlnmod);
		// Puts (_multipliers[i].ToString());
	}

  }

  void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo) {

	float modifier       = 1.0F;
	int   Time           = 0;
	BuildingBlock buildingBlock = null;

	if (entity == null || hitInfo == null)
		{
			return; // Nothing to process
		}

	try
		{
			if (EntityModifier.ContainsKey(entity.ShortPrefabName))
				try
				{
					EntityModifier.TryGetValue(entity.ShortPrefabName, out modifier);
				}
				catch
				{
					modifier  = 1.0F;
				}
		}
	catch
		{
			modifier = 1.0F;
		}

	// determine the time
	if (_time_type.ToLower() == "real")
		Time = Convert.ToInt32(System.DateTime.Now.ToString("HH"));
	else
		Time = Convert.ToInt32(Math.Floor(TOD_Sky.Instance.Cycle.Hour));

	// make sure the time is in range
	if (Time > 24 || Time < 0)
		Time = 0;

	// Apply the Global Time Mod
	modifier =  modifier * _GlobalTimemultipliers[Time];

	// debugging
	//if (entity.ShortPrefabName.Contains("horse"))
	//{
	//	PrintWarning("0 " + entity.ShortPrefabName);
	//	PrintWarning("0.1 " + entity.PrefabName);
	//}

	if(entity is LootContainer && entity.ShortPrefabName.Contains("barrel"))  // barrel
	{
		modifier = modifier * ModifyBarrel * _OtherTimemultipliers[Time];

		setHitScale(hitInfo, _Onemultipliers,modifier);
	}
	else if (entity.ShortPrefabName.Contains("scarecrow") && !entity.ShortPrefabName.Contains("deployed")) // Scarecrows and Murderer (treated the same as zombies)
		{

			// Apply the NPC Time Mod
			modifier =  modifier * _NPCTimemultipliers[Time];
			setHitScale(hitInfo, _Zombiemultipliers,modifier);
			return;
		}
	else if (entity.ShortPrefabName.Contains("hotairballoon"))
	{
		setHitScale(hitInfo, _Balloonmultipliers,modifier);
		return;
	}
	else if (entity.ShortPrefabName.Contains("minicopter"))
	{
		setHitScale(hitInfo, _Minicoptermultipliers,modifier);
		return;
	}
	else if (entity.ShortPrefabName.Contains("scraptransporthelicopter"))
	{
		setHitScale(hitInfo, _Scrapcoptermultipliers,modifier);
		return;
	}
	else if (entity.ShortPrefabName.Contains("sam_site") || entity.ShortPrefabName.Contains("sam_static"))
	{
		setHitScale(hitInfo, _SAMSitemultipliers,modifier);
		return;
	}
	else if (entity is NPCPlayer || (entity is BasePlayer && (entity as BasePlayer).IsNpc) ||
			        (entity.PrefabName.Contains("assets/rust.ai/agents/npcplayer") &&
					  (entity.PrefabName.Contains("scientist") || entity.PrefabName.Contains("human")))
			         ) // BotSpawn type Scientists, etc.
		{
			// Apply the NPC Time Mod
			modifier =  modifier * _NPCTimemultipliers[Time];
			setHitScale(hitInfo, _NPCmultipliers,modifier);
			return;
		}
	else if (!entity.ShortPrefabName.Contains("corpse") && (entity is BaseNpc || entity.PrefabName.Contains("assets/rust.ai/")))
		{
			// Apply the Animal Time Mod
			modifier =  modifier * _AnimalTimemultipliers[Time];
			if (entity.ShortPrefabName.Contains("zombie")) // Zombie
				{
				setHitScale(hitInfo, _Zombiemultipliers,modifier);
				}
			else if (entity.ShortPrefabName.Contains("bear")) // Bear
				{
				setHitScale(hitInfo, _Bearmultipliers,modifier);
				}
			else if (entity.ShortPrefabName.Contains("boar")) // Boar
				{
				setHitScale(hitInfo, _Boarmultipliers,modifier);
				}
			else if (entity.ShortPrefabName.Contains("chicken")) // Chicken
				{
				setHitScale(hitInfo, _Chickenmultipliers,modifier);
				}
			else if (entity.ShortPrefabName.Contains("ridablehorse")) // Test Ridablehorse
				{
				setHitScale(hitInfo, _RidableHorsemultipliers,modifier);
				}
			else if (entity.ShortPrefabName.Contains("horse")) // Horse
				{
				setHitScale(hitInfo, _Horsemultipliers,modifier);
				}
			else if (entity.ShortPrefabName.Contains("stag")) // Stag
				{
				setHitScale(hitInfo, _Stagmultipliers,modifier);
				}
			else if (entity.ShortPrefabName.Contains("wolf")) // Wolf
				{
				setHitScale(hitInfo, _Wolfmultipliers,modifier);
				}
			else // Animal not found
				{
				Puts ("Animal not found in Damage Control: " + entity.ShortPrefabName + " using Bear");
				setHitScale(hitInfo, _Bearmultipliers,modifier);
				}
			return;
		}
	else if (entity is BradleyAPC) // APC
		{
			// Apply the Bradley Time Mod
			modifier =  modifier * _BradleyTimemultipliers[Time];
			setHitScale(hitInfo, _APCmultipliers,modifier);
			return;
		}
	else if (entity is BaseHelicopter) // Heli
		{
			// Apply the Heli Time Mod
			modifier =  modifier * _HeliTimemultipliers[Time];
			setHitScale(hitInfo, _Helimultipliers,modifier);
			return;
		}
	else if (entity is BasePlayer)
	{
		// Apply the Player Time Mod
		modifier =  modifier * _PlayerTimemultipliers[Time];
		setHitScale(hitInfo, _Playermultipliers,modifier);
		return;
	}
	else if (entity.ShortPrefabName.Contains("cupboard.tool.deployed")) // TC
	{
		// Apply the Building Time Mod
		modifier = modifier * ModifyTC * _BuildingTimemultipliers[Time];
		setHitScale(hitInfo, _Buildingmultipliers,modifier);
	}
	// special overrides for building
	else if (entity is BuildingBlock || entity is Door || entity.ShortPrefabName.Contains("external") || entity.ShortPrefabName.Contains("hatch"))
	{
		// Apply the Building Time Mod
		modifier =  modifier * _BuildingTimemultipliers[Time];

		if (entity.ShortPrefabName.Contains("foundation"))
			modifier = modifier * ModifyFoundation;
		else if (entity.ShortPrefabName.Contains("external"))
			modifier = modifier * ModifyHighExternal;
		else if (entity.ShortPrefabName.Contains("wall") && !(entity is Door) && !(entity.ShortPrefabName.Contains("external")))
			modifier = modifier * ModifyWall;
		else if (entity.ShortPrefabName.Contains("floor") && !entity.ShortPrefabName.Contains("hatch"))
			modifier = modifier * ModifyFloor;
		else if (entity.ShortPrefabName.Contains("roof"))
			modifier = modifier * ModifyRoof;
		else if ((entity is Door || entity.ShortPrefabName.Contains("hatch")) && !entity.ShortPrefabName.Contains("external"))
			modifier = modifier * ModifyDoor;
		else if (entity.ShortPrefabName.Contains("stairs"))
			modifier = modifier * ModifyStairs;
		else if (entity is BuildingBlock)
			modifier = modifier * ModifyOther;
		else if (deployable_list.Contains(entity.ShortPrefabName.Replace("_",".").ToLower()))  // this deal with high walls etc.
			modifier = modifier * ModifyDeployed;
			
		if (entity is BuildingBlock)
		{
			buildingBlock = entity as BuildingBlock;

			if (modifier == 0 && Heli_bypass && ((hitInfo.Initiator != null && hitInfo.Initiator is BaseHelicopter) ||
				(hitInfo.WeaponPrefab != null && hitInfo.WeaponPrefab.ShortPrefabName.StartsWith("rocket_heli"))))
			{
				if (buildingBlock.grade == BuildingGrade.Enum.Twigs)
					modifier = _TwigsMultiplier;
				else if (buildingBlock.grade == BuildingGrade.Enum.Wood )
					modifier = _WoodMultiplier;
				else if (buildingBlock.grade == BuildingGrade.Enum.Stone )
					modifier = _StoneMultiplier;
				else if (buildingBlock.grade == BuildingGrade.Enum.Metal )
					modifier = _MetalMultiplier;
				else if (buildingBlock.grade == BuildingGrade.Enum.TopTier )
					modifier = _TopTierMultiplier;
			}			
			else
			{
				if (buildingBlock.grade == BuildingGrade.Enum.Twigs)
					modifier = _TwigsMultiplier * modifier;
				else if (buildingBlock.grade == BuildingGrade.Enum.Wood )
					modifier = _WoodMultiplier * modifier;
				else if (buildingBlock.grade == BuildingGrade.Enum.Stone )
					modifier = _StoneMultiplier * modifier;
				else if (buildingBlock.grade == BuildingGrade.Enum.Metal )
					modifier = _MetalMultiplier * modifier;
				else if (buildingBlock.grade == BuildingGrade.Enum.TopTier )
					modifier = _TopTierMultiplier * modifier;
			}
		}

		// bypasses, warning these could be used to grief bases in PVE
		if (modifier == 0 || !(entity is BuildingBlock))
			setHitScale(hitInfo, _Buildingmultipliers, modifier);
		else if (Heli_bypass && ((hitInfo.Initiator != null && hitInfo.Initiator is BaseHelicopter) ||
				(hitInfo.WeaponPrefab != null && hitInfo.WeaponPrefab.ShortPrefabName.StartsWith("rocket_heli"))))
			setHitScale(hitInfo, _Onemultipliers, modifier);
		else
			setHitScale(hitInfo, _Buildingmultipliers, modifier);
	}
	else if (deployable_list.Contains(entity.ShortPrefabName.Replace("_",".").ToLower())) // Deployed
	{
		// Apply the Other Time Mod
		modifier = modifier * ModifyDeployed * _BuildingTimemultipliers[Time];

		setHitScale(hitInfo, _Buildingmultipliers,modifier);
	}

	//Puts("modifier: " + modifier);
    return; // any processing is completed
  }

  bool IsAllowed(IPlayer iplayer) {
   return iplayer != null && (iplayer.IsAdmin || iplayer.HasPermission(permAdmin));
  }

  T GetConfig < T > (string name, T value) => Config[name] == null ? value : (T) Convert.ChangeType(Config[name], typeof(T));
  string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

 }
}

// --- End of file: DamageControl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/death-kick ---
// --- Original File Path: D/DeathKick/DeathKick.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Death Kick", "Wulf", "1.0.1")]
    [Description("Kicks players for a specified amount of time upon death")]
    class DeathKick : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Death by animals")]
            public bool DeathByAnimals = true;

            [JsonProperty("Death by autoturrets")]
            public bool DeathByAutoturrets = true;

            [JsonProperty("Death by barricades")]
            public bool DeathByBarricades = true;

            [JsonProperty("Death by beartraps")]
            public bool DeathByBeartraps = true;

            [JsonProperty("Death by fall")]
            public bool DeathByFall = true;

            [JsonProperty("Death by floorspikes")]
            public bool DeathByFloorspikes = true;

            [JsonProperty("Death by helicopters")]
            public bool DeathByHelicopters = true;

            [JsonProperty("Death by landmines")]
            public bool DeathByLandmines = true;

            [JsonProperty("Death by players")]
            public bool DeathByPlayers = true;

            [JsonProperty("Death by suicide")]
            public bool DeathBySuicide = true;

            [JsonProperty("Deaths a player is limited to")]
            public int DeathLimit = 1;

            [JsonProperty("Time before reconnection (minutes)")]
            public int KickCooldown = 30;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Minutes"] = "minutes",
                ["Seconds"] = "seconds",
                ["YouDied"] = "You died and must wait {0} {1} before reconnecting",
                ["YouMustWait"] = "You must wait another {0} {1} before reconnecting"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private readonly Dictionary<string, double> deadPlayers = new Dictionary<string, double>();
        private readonly Dictionary<string, int> deathCounts = new Dictionary<string, int>();
        private readonly List<Timer> cooldowns = new List<Timer>();

        private const string permExempt = "deathkick.exempt";

        private void Init()
        {
            permission.RegisterPermission(permExempt, this);
        }

        private void Unload() => ClearData();

        #endregion Initialization

        #region Death Handling

        private void OnEntityDeath(BasePlayer player, HitInfo hitInfo)
        {
            ProcessDeath(player.IPlayer, hitInfo);
        }

        private void ProcessDeath(IPlayer player, HitInfo hitInfo)
        {
            if (permission.UserHasPermission(player.Id, permExempt) || !GetDeathType(hitInfo))
            {
                return;
            }

            if (!deathCounts.ContainsKey(player.Id))
            {
                deathCounts.Add(player.Id, 0);
            }
            deathCounts[player.Id]++;

            if (deathCounts[player.Id] >= config.DeathLimit)
            {
                deadPlayers.Add(player.Id, GetCurrentTime() + (config.KickCooldown * 60));
                cooldowns.Add(timer.Once(config.KickCooldown * 60, () => deadPlayers.Remove(player.Id)));

                if (player.IsConnected)
                {
                    player.Kick(GetLang("YouDied", player.Id, config.KickCooldown, GetLang("Minutes", player.Id)));
                }

                deathCounts.Remove(player.Id);
            }
        }

        private bool GetDeathType(HitInfo hitInfo)
        {
            if (hitInfo == null || config.DeathByFall)
            {
                return true;
            }

            BaseEntity attacker = hitInfo.Initiator;
            if (attacker == null)
            {
                return false;
            }

            if (attacker.ToPlayer() != null)
            {
                if (hitInfo.damageTypes.GetMajorityDamageType().ToString() == "Suicide" && config.DeathBySuicide)
                {
                    return true;
                }

                if (config.DeathByPlayers)
                {
                    return true;
                }
            }
            else if (attacker.name.Contains("patrolhelicopter.pr") && config.DeathByHelicopters)
            {
                return true;
            }
            else if (attacker.name.Contains("animals/") && config.DeathByAnimals)
            {
                return true;
            }
            else if (attacker.name.Contains("beartrap.prefab") && config.DeathByBeartraps)
            {
                return true;
            }
            else if (attacker.name.Contains("landmine.prefab") && config.DeathByLandmines)
            {
                return true;
            }
            else if (attacker.name.Contains("spikes.floor.prefab") && config.DeathByFloorspikes)
            {
                return true;
            }
            else if (attacker.name.Contains("autoturret_deployed.prefab") && config.DeathByAutoturrets)
            {
                return true;
            }
            else if ((attacker.name.Contains("deployable/barricades") || attacker.name.Contains("wall.external.high")) && config.DeathByBarricades)
            {
                return true;
            }

            return false;
        }

        private object CanUserLogin(string playerName, string playerId)
        {
            if (deadPlayers.ContainsKey(playerId))
            {
                int remaining = (int)deadPlayers[playerId] - (int)GetCurrentTime();
                int timeLeft = remaining / 60;
                string timeFormat = GetLang("Minutes", playerId);

                if (remaining <= 90)
                {
                    timeLeft = remaining;
                    timeFormat = GetLang("Seconds", playerId);
                }

                return GetLang("YouMustWait", playerId, timeLeft, timeFormat);
            }

            return null;
        }

        private void ClearData()
        {
            foreach (Timer cooldown in cooldowns)
            {
                cooldown.Destroy();
            }
            deadPlayers.Clear();
        }

        #endregion Death Handling

        #region Helpers

        private static double GetCurrentTime()
        {
            return DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: DeathKick.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/death-notes-gui ---
// --- Original File Path: D/DeathNotesGui/DeathNotesGui.cs ---

﻿// Requires: PopupNotifications
// Requires: DeathNotes

using Oxide.Core.Plugins;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Death Notes GUI", "LaserHydra", "1.0.0")]
    [Description("Provides an GUI output option for Death Notes")]
    public class DeathNotesGui : RustPlugin
    {
        [PluginReference("PopupNotifications")]
        Plugin _popupNotifications;
        
        private void OnDeathNotice(Dictionary<string, object> data, string message)
        {
            _popupNotifications?.Call("CreatePopupNotification", message);
        }
    }
}

// --- End of file: DeathNotesGui.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dice ---
// --- Original File Path: D/Dice/Dice.cs ---

﻿﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Dice", "Wulf/lukespragg", "0.3.0", ResourceId = 655)]
    [Description("Feeling lucky? Roll dice to get a random number")]
    public class Dice : CovalencePlugin
    {
        #region Initialization

        private static System.Random random = new System.Random();

        private const string permUse = "dice.use";

        private void Init()
        {
            AddCommandAliases("CommandAlias", "DiceCommand");
            AddCovalenceCommand("dice", "DiceCommand");
            permission.RegisterPermission(permUse, this);
        }

        #endregion

        #region Localization

        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandAliasDice"] = "roll",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PlayerRolled"] = "{0} rolled {1}",
                ["UsageDice"] = "Usage: '{0} #' to roll dice (# being optional number of dice)",
            }, this);
        }

        #endregion

        #region Dice Command

        private void DiceCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            var arg = args.Length > 0 ? args[0] : "1";

            int dice;
            if (int.TryParse(arg, out dice))
            {
                if (dice >= 1000) dice = 1;
                var roll = random.Next(1, dice * 7);
                Broadcast("PlayerRolled", player.Name, roll);
            }
            else if (arg == "help")
                Message(player, "UsageDice", command);
        }

        #endregion

        #region Helpers

        private void AddCommandAliases(string key, string command)
        {
            foreach (var language in lang.GetLanguages(this))
            {
                var messages = lang.GetMessages(language, this);
                foreach (var message in messages.Where(m => m.Key.StartsWith(key))) AddCovalenceCommand(message.Value, command);
            }
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void Broadcast(string key, params object[] args)
        {
            foreach (var player in players.Connected.Where(p => p.IsConnected)) player.Message(Lang(key, player.Id, args));
        }

        private void Message(IPlayer player, string key, params object[] args) => player.Message(Lang(key, player.Id, args));

        #endregion
    }
}

// --- End of file: Dice.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/damage-mod-buildings ---
// --- Original File Path: D/DMBuildings/DMBuildings.cs ---

﻿using Rust;
using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("DMBuildings", "ColonBlow", "1.2.6")]
    internal class DMBuildings : CovalencePlugin
    {
        private const int DamageTypeMax = (int)DamageType.LAST;
        private readonly float[] _modifiers = new float[DamageTypeMax];
        private bool _didConfigChange;

        private void Loaded() => LoadConfigValues();
        protected override void LoadDefaultConfig() => Puts("New configuration file created.");

        private void LoadConfigValues()
        {
            foreach (DamageType val in Enum.GetValues(typeof(DamageType)))
            {
                if (val == DamageType.LAST) continue;
                _modifiers[(int)val] = Convert.ToSingle(GetConfigValue("Building_Multipliers", val.ToString(), 1.0));
            }

            if (!_didConfigChange) return;
            Puts("Configuration file updated.");
            SaveConfig();
        }

        private object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                _didConfigChange = true;
            }

            if (data.TryGetValue(setting, out value)) return value;
            value = defaultValue;
            data[setting] = value;
            _didConfigChange = true;
            return value;
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity is BuildingBlock)
                for (var i = 0; i < DamageTypeMax; i++)
                {
                    hitInfo.damageTypes.Scale((DamageType)i, _modifiers[i]);
                }

            if (entity is Door)
                for (var i = 0; i < DamageTypeMax; i++)
                {
                    hitInfo.damageTypes.Scale((DamageType)i, _modifiers[i]);
                }
            else return;
        }
    }
}

// --- End of file: DMBuildings.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/duelist ---
// --- Original File Path: D/Duelist/Duelist.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Game.Rust.Libraries;
using Oxide.Plugins.DuelistExtensionMethods;
using Rust;
using Rust.Workshop;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Duelist", "nivex", "1.3.5")]
    [Description("1v1 and team deathmatch event.")]
    public class Duelist : RustPlugin
    {
        [PluginReference] Plugin Kits, ZoneManager, Economics, ServerRewards, Clans, AimTrain, LustyMap;

        private static Duelist Instance;

        public enum Team { Good = 0, Evil = 1, None = 2 }
        private const string hewwPrefab = "assets/prefabs/building/wall.external.high.wood/wall.external.high.wood.prefab";
        private const string heswPrefab = "assets/prefabs/building/wall.external.high.stone/wall.external.high.stone.prefab";
        private const bool debugMode = false;
        private List<string> readyUiList = new List<string>();
        private List<string> spectators = new List<string>();
        private List<Rematch> rematches = new List<Rematch>();
        private Dictionary<string, AttackerInfo> tdmAttackers = new Dictionary<string, AttackerInfo>();
        private Dictionary<string, string> tdmKits = new Dictionary<string, string>();
        private HashSet<GoodVersusEvilMatch> tdmMatches = new HashSet<GoodVersusEvilMatch>();
        private List<DuelingZone> duelingZones = new List<DuelingZone>(); // where all the fun is at
        private StoredData duelsData = new StoredData();
        private Dictionary<string, string> dataDuelists = new Dictionary<string, string>(); // active duelers
        private Dictionary<string, long> dataImmunity = new Dictionary<string, long>(); // players immune to damage
        private Dictionary<string, Vector3> dataImmunitySpawns = new Dictionary<string, Vector3>(); // players spawn points
        private int blockedMask = LayerMask.GetMask("Player (Server)", "Prevent Building", "Construction", "Deployed", "Trigger"); // layers we won't be setting a zone within 50 meters of
        private int constructionMask = LayerMask.GetMask("Construction", "Deployed");
        private bool matchUpdateRequired;
        private int groundMask = LayerMask.GetMask("Terrain", "World", "Default"); // used to find dueling zone/set custom zone and create spawn points
        private int wallMask = LayerMask.GetMask("Terrain", "World", "Default", "Construction", "Deployed");
        private int waterMask = LayerMask.GetMask("Water"); // used to count water colliders when finding a random dueling zone on the map
        private int worldMask = LayerMask.GetMask("World");
        private Timer announceTimer;
        private SortedDictionary<string, string> boneTags = new SortedDictionary<string, string> { ["r_"] = "Right ", ["l_"] = "Left ", [".prefab"] = string.Empty, ["1"] = string.Empty, ["2"] = string.Empty, ["3"] = string.Empty, ["4"] = string.Empty, ["END"] = string.Empty, ["_"] = " ", ["."] = " " };
        private Dictionary<string, string> announcements = new Dictionary<string, string>(); // users id and announcement
        private Dictionary<string, long> dataDeath = new Dictionary<string, long>(); // users id and timestamp of when they're to be executed
        private Dictionary<string, string> dataRequests = new Dictionary<string, string>(); // users requesting a duel and to whom
        private Dictionary<string, bool> deployables = new Dictionary<string, bool>();
        private Dictionary<ulong, List<BaseEntity>> duelEntities = new Dictionary<ulong, List<BaseEntity>>();
        private DynamicConfigFile duelsFile;
        private Timer eventTimer; // timer to check for immunity and auto death time of duelers
        private Timer matchTimer; // timer to check for updates to the match ui
        private SpawnFilter filter = new SpawnFilter(); // RandomDropPosition()
        private Dictionary<Vector3, float> managedZones = new Dictionary<Vector3, float>(); // blocked zones from zonemanager plugin
        private List<Vector3> monuments = new List<Vector3>(); // positions of monuments on the server
        private Dictionary<string, string> prefabs = new Dictionary<string, string>();
        private bool resetDuelists; // if wipe is detected then assign awards and wipe VictoriesSeed / LossesSeed
        private Dictionary<string, List<ulong>> skinsCache = new Dictionary<string, List<ulong>>(); // used to randomize custom kit skins which skin id values are 0
        private Dictionary<string, string> tdmRequests = new Dictionary<string, string>(); // users requesting a deathmatch and to whom
        private Dictionary<string, List<ulong>> workshopskinsCache = new Dictionary<string, List<ulong>>();
        private List<string> dcsBlock = new List<string>(); // users blocked from 1v1 for 60 seconds after suiciding or disconnecting
        private Dictionary<string, string> playerZones = new Dictionary<string, string>(); // id, set zone name

        public class StoredData
        {
            public List<string> Allowed = new List<string>(); // list of users that allow duel requests
            public Dictionary<string, List<string>> AutoGeneratedSpawns = new Dictionary<string, List<string>>();
            public Dictionary<string, string> Bans = new Dictionary<string, string>(); // users banned from dueling
            public Dictionary<string, BetInfo> Bets = new Dictionary<string, BetInfo>(); // active bets users have placed
            public Dictionary<string, List<string>> BlockedUsers = new Dictionary<string, List<string>>(); // users and the list of players they blocked from requesting duels with
            public List<string> Chat = new List<string>(); // user ids of those who opted out of seeing duel death messages
            public List<string> ChatEx = new List<string>(); // user ids of those who opted to see duel death messages when the config blocks them for all players
            public Dictionary<string, List<BetInfo>> ClaimBets = new Dictionary<string, List<BetInfo>>(); // active bets users need to claim after winning a bet
            public Dictionary<string, string> CustomKits = new Dictionary<string, string>(); // userid and custom kit
            public bool DuelsEnabled; // enable/disable dueling for all players (not admins)
            public Dictionary<string, string> Homes = new Dictionary<string, string>(); // user id and location of where they teleported from
            public Dictionary<string, string> Kits = new Dictionary<string, string>(); // userid and kit. give kit when they wake up inside of the dueling zone
            public Dictionary<string, int> Losses = new Dictionary<string, int>(); // user id / losses for lifetime
            public Dictionary<string, int> LossesSeed = new Dictionary<string, int>(); // user id / losses for seed
            public SortedDictionary<long, string> Queued = new SortedDictionary<long, string>(); // queued duelers sorted by timestamp and user id. first come first serve
            public List<string> Restricted = new List<string>(); // list of users blocked from requesting a duel for 60 seconds
            public List<string> Spawns = new List<string>(); // custom spawn points
            public List<string> AutoReady = new List<string>();
            public Dictionary<string, int> MatchVictories = new Dictionary<string, int>(); // player name & total wins
            public Dictionary<string, int> MatchVictoriesSeed = new Dictionary<string, int>(); // player name & wins for current seed
            public Dictionary<string, int> MatchLosses = new Dictionary<string, int>(); // player name & total losses
            public Dictionary<string, int> MatchLossesSeed = new Dictionary<string, int>(); // player name & losses for current seed
            public Dictionary<string, int> MatchDeaths = new Dictionary<string, int>(); // player name & total deaths
            public Dictionary<string, int> MatchDeathsSeed = new Dictionary<string, int>(); // player name & deaths for the seed
            public Dictionary<string, int> MatchKills = new Dictionary<string, int>(); // player name & total kills
            public Dictionary<string, int> MatchKillsSeed = new Dictionary<string, int>(); // player name & kills for current seed
            public Dictionary<string, Dictionary<string, int>> MatchSizesVictories = new Dictionary<string, Dictionary<string, int>>(); // size, id, wins
            public Dictionary<string, Dictionary<string, int>> MatchSizesVictoriesSeed = new Dictionary<string, Dictionary<string, int>>(); // size, id, wins seed
            public Dictionary<string, Dictionary<string, int>> MatchSizesLosses = new Dictionary<string, Dictionary<string, int>>(); // size, id, losses
            public Dictionary<string, Dictionary<string, int>> MatchSizesLossesSeed = new Dictionary<string, Dictionary<string, int>>(); // size, id, losses seed
            public int TotalDuels; // the total amount of duels ever played on the server
            public Dictionary<string, int> Victories = new Dictionary<string, int>(); // user id / wins for lifetime
            public Dictionary<string, int> VictoriesSeed = new Dictionary<string, int>(); // user id / wins for seed
            public List<string> ZoneIds = new List<string>(); // the locations of each dueling zone
            public Dictionary<string, string> DuelZones = new Dictionary<string, string>(); // location, name
        }

        private class Tracker : FacepunchBehaviour
        {
            public BasePlayer player;
            private Duelist _;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
            }

            public void Init(Duelist _)
            {
                this._ = _;
                InvokeRepeating(Track, 0f, 0.5f);
            }

            private void Track()
            {
                if (player == null || player.transform == null)
                {
                    Destroy(this);
                    return;
                }

                if (_.dataDuelists.ContainsKey(player.UserIDString) || _.tdmMatches.Exists(team => team.GetTeam(player) != Team.None))
                {
                    if (!_.DuelTerritory(player.transform.position))
                    {
                        player.inventory.Strip();
                        Destroy(this);
                    }
                }
            }

            private void OnDestroy()
            {
                try { CancelInvoke(); } catch { }
                Destroy(this);
            }
        }

        public class Rematch
        {
            public Rematch(Duelist _)
            {
                this._ = _;
            }
            private Duelist _;
            public List<BasePlayer> Duelists = new List<BasePlayer>();
            public List<BasePlayer> Ready = new List<BasePlayer>();
            private List<BasePlayer> Evil = new List<BasePlayer>();
            private List<BasePlayer> Good = new List<BasePlayer>();
            public GoodVersusEvilMatch match;
            private Timer _notify;

            public List<BasePlayer> Players
            {
                get
                {
                    Duelists.RemoveAll(IsNotConnected);
                    Good.RemoveAll(IsNotConnected);
                    Evil.RemoveAll(IsNotConnected);
                    Ready.RemoveAll(IsNotConnected);

                    if (match == null)
                        return Duelists;

                    var _list = new List<BasePlayer>();

                    _list.AddRange(Good);
                    _list.AddRange(Evil);

                    return _list;
                }
            }

            public bool HasPlayer(BasePlayer player)
            {
                return Players.Contains(player);
            }

            public bool AddRange(List<BasePlayer> players, Team team)
            {
                foreach (var player in players)
                {
                    if (IsNotConnected(player) || _.InEvent(player) || Good.Contains(player) || Evil.Contains(player))
                        break;

                    if (team == Team.Evil)
                        Evil.Add(player);
                    else
                        Good.Add(player);
                }

                return (team == Team.Evil ? Evil.Count : Good.Count) == players.Count;
            }

            public bool IsReady(BasePlayer player)
            {
                if (_.InEvent(player) || !_.IsNewman(player) || _.duelsData.Bans.ContainsKey(player.UserIDString))
                    return false;

                return true;
            }

            public bool IsReady()
            {
                if (Players.Exists(player => !IsReady(player)))
                {
                    Reset("RematchFailed2");
                    return false;
                }

                return Ready.Count == (match == null ? 2 : match.TeamSize * 2);
            }

            private void Reset(string key)
            {
                _.tdmMatches.Remove(match);
                MessageAll(key);
                Duelists.Clear();
                Good.Clear();
                Evil.Clear();
                Ready.Clear();
                _notify?.Destroy();
                _.rematches.Remove(this);
                _.matchUpdateRequired = true;
            }

            public void MessageAll(string key, params object[] args)
            {
                foreach (var player in Players)
                {
                    Message(player, _.msg(key, player.UserIDString, args));
                }
            }

            public void Notify()
            {
                MessageAll("RematchNotify", 60f, match == null ? _.szDuelChatCommand : _.szMatchChatCommand);

                foreach (var player in Players)
                    if (_.duelsData.AutoReady.Contains(player.UserIDString))
                        Ready.Add(player);

                if (IsReady())
                {
                    Start();
                    _.rematches.Remove(this);
                }
                else if (match == null || !match.IsPublic)
                    _notify = _.timer.Once(60f, Cancel);
            }

            private void Cancel()
            {
                if (match != null && match.IsPublic)
                    return;

                if (_.rematches.Contains(this))
                {
                    if (_.sendHomeSpectatorWhenRematchTimesOut)
                    {
                        foreach (var player in Players)
                        {
                            if (_.IsSpectator(player))
                            {
                                _.EndSpectate(player);
                                _.SendHome(player);
                            }
                        }
                    }

                    if (match != null)
                    {
                        match.Reuse();
                    }

                    _.tdmMatches.Remove(match);
                    Reset("RematchTimedOut");
                }
            }

            public void Start()
            {
                if (match == null)
                {
                    var player = Ready[0];
                    var target = Ready[1];

                    if (!_.SelectZone(player, target))
                    {
                        Message(player, _.msg("AllZonesFull", player.UserIDString, _.duelingZones.Count, _.playersPerZone));
                        Message(target, _.msg("AllZonesFull", target.UserIDString, _.duelingZones.Count, _.playersPerZone));
                    }
                }
                else
                {
                    match.Reuse();
                    _.tdmMatches.Add(match);

                    if (!AddMatchPlayers(Good, Team.Good) || !AddMatchPlayers(Evil, Team.Evil))
                    {
                        Reset("RematchFailed");
                        match.Reuse();
                    }
                }

                _notify?.Destroy();
                _.rematches.Remove(this);
            }

            private bool AddMatchPlayers(List<BasePlayer> players, Team team)
            {
                foreach (var player in players)
                    if (!match.AddMatchPlayer(player, team))
                        return false;

                return true;
            }
        }

        public class AttackerInfo
        {
            public string AttackerName = "";
            public string AttackerId = "";
            public string BoneName = "";
            public string Distance = "";
            public string Weapon = "";
        }

        public class GoodVersusEvilMatch
        {
            public GoodVersusEvilMatch(Duelist _)
            {
                this._ = _;
            }
            private Duelist _;
            private HashSet<ulong> _banned = new HashSet<ulong>();
            private HashSet<BasePlayer> _evil = new HashSet<BasePlayer>();
            private HashSet<ulong> _evilKIA = new HashSet<ulong>();
            private List<BasePlayer> _evilRematch = new List<BasePlayer>();
            private HashSet<BasePlayer> _good = new HashSet<BasePlayer>();
            private HashSet<ulong> _goodKIA = new HashSet<ulong>();
            private List<BasePlayer> _goodRematch = new List<BasePlayer>();
            private string _goodHostName = "";
            private string _evilHostName = "";
            private string _goodHostId = "";
            private string _evilHostId = "";
            private string _goodCode = "";
            private string _evilCode = "";
            private int _teamSize = 2;
            private bool _started;
            private bool _ended;
            private string _kit = "";
            private DuelingZone _zone;
            private Timer _queueTimer;
            private bool _enteredQueue;
            private bool _public;
            public bool CanRematch = true;

            public string Id
            {
                get
                {
                    return _goodHostId + _evilHostId;
                }
            }

            public string Versus
            {
                get
                {
                    return string.Format("{0} / {1} {2}v{2}", _goodHostName, _evilHostName, _teamSize);
                }
            }

            public bool IsPublic
            {
                get
                {
                    return _public;
                }
                set
                {
                    _public = value;
                    _.matchUpdateRequired = true;
                    MessageAll(_public ? "MatchPublic" : "MatchPrivate");
                }
            }

            public int TeamSize
            {
                get
                {
                    return _teamSize;
                }
                set
                {
                    if (IsStarted)
                        return;

                    _teamSize = value;
                    _.matchUpdateRequired = true;
                    MessageAll("MatchSizeChanged", _teamSize);
                }
            }

            public DuelingZone Zone
            {
                get
                {
                    return _zone;
                }
            }

            public bool EitherEmpty
            {
                get
                {
                    return _good.Count == 0 || _evil.Count == 0;
                }
            }

            public bool IsStarted
            {
                get
                {
                    return _started;
                }
                set
                {
                    _started = value;
                    _.matchUpdateRequired = true;
                }
            }

            public bool IsOver
            {
                get
                {
                    return _ended;
                }
                set
                {
                    _ended = value;
                    _.matchUpdateRequired = true;
                }
            }

            public string Kit
            {
                get
                {
                    return _kit;
                }
                set
                {
                    _kit = value;

                    if (!EitherEmpty)
                    {
                        _good.RemoveWhere(IsNotConnected);
                        _evil.RemoveWhere(IsNotConnected);

                        _good.ToList().ForEach(player => _.duelsData.Kits[player.UserIDString] = _kit);
                        _evil.ToList().ForEach(player => _.duelsData.Kits[player.UserIDString] = _kit);

                        MessageAll("MatchKitSet", _kit);
                    }
                }
            }

            public void Reuse()
            {
                if (_zone != null)
                    _zone.IsLocked = false;

                _evilRematch.Clear();
                _goodRematch.Clear();
                _good.Clear();
                _evil.Clear();
                _goodKIA.Clear();
                _evilKIA.Clear();
                _started = false;
                _ended = false;
                _enteredQueue = false;
                _kit = _.GetRandomKit();
                _goodHostId = BasePlayer.activePlayerList.FirstOrDefault(x => x.displayName == _goodHostName)?.UserIDString ?? _goodHostId;
                _evilHostId = BasePlayer.activePlayerList.FirstOrDefault(x => x.displayName == _evilHostName)?.UserIDString ?? _evilHostId;
                _.matchUpdateRequired = true;
            }

            public void Setup(BasePlayer player, BasePlayer target)
            {
                _.tdmMatches.Add(this);
                _goodHostName = player.displayName;
                _goodHostId = player.UserIDString;
                _evilHostName = target.displayName;
                _evilHostId = target.UserIDString;
                _goodCode = Random.Range(10000, 99999).ToString();
                _evilCode = Random.Range(10000, 99999).ToString();

                if (_teamSize < _.minDeathmatchSize)
                    _teamSize = _.minDeathmatchSize;

                AddMatchPlayer(player, Team.Good);
                AddMatchPlayer(target, Team.Evil);

                if (_.tdmKits.ContainsKey(player.UserIDString))
                {
                    Kit = _.tdmKits[player.UserIDString];
                    _.tdmKits.Remove(player.UserIDString);
                }
                else if (_.tdmKits.ContainsKey(target.UserIDString))
                {
                    Kit = _.tdmKits[target.UserIDString];
                    _.tdmKits.Remove(target.UserIDString);
                }
                else
                    Kit = _.GetRandomKit();

                if (TeamSize > 1)
                {
                    Message(player, _.msg("MatchOpened", player.UserIDString, _.szMatchChatCommand, _goodCode));
                    Message(target, _.msg("MatchOpened", target.UserIDString, _.szMatchChatCommand, _evilCode));
                }

                _.matchUpdateRequired = true;
            }

            public bool IsFull()
            {
                return _good.Count == _teamSize && _evil.Count == _teamSize;
            }

            public bool IsFull(Team team)
            {
                return team == Team.Good ? _good.Count == _teamSize : _evil.Count == _teamSize;
            }

            public void MessageAll(string key, params object[] args)
            {
                _.Message(_good, key, args);
                _.Message(_evil, key, args);
            }

            public Team GetTeam(BasePlayer player)
            {
                return _good.Contains(player) ? Team.Good : _evil.Contains(player) ? Team.Evil : Team.None;
            }

            public bool IsHost(BasePlayer player)
            {
                return player.UserIDString == _goodHostId || player.UserIDString == _evilHostId;
            }

            public void SetCode(BasePlayer player, string code)
            {
                if (GetTeam(player) == Team.Evil)
                    _evilCode = code;
                else if (GetTeam(player) == Team.Good)
                    _goodCode = code;
            }

            public string Code(Team team)
            {
                return team == Team.Good ? _goodCode : _evilCode;
            }

            public bool AlliedTo(BasePlayer player, Team team)
            {
                return _.IsAllied(player.UserIDString, team == Team.Good ? _goodHostId : _evilHostId);
            }

            public bool IsBanned(ulong targetId)
            {
                return _banned.Contains(targetId);
            }

            public bool Ban(BasePlayer target)
            {
                if (target.UserIDString == _goodHostId || target.UserIDString == _evilHostId || IsBanned(target.userID))
                    return false;

                _banned.Add(target.userID);
                RemoveMatchPlayer(target);
                return true;
            }

            public bool Equals(GoodVersusEvilMatch match)
            {
                return match._good.Equals(_good) && match._evil.Equals(_evil);
            }

            public string GetNames(Team team)
            {
                return string.Join(", ", team == Team.Good ? _good.ToList().Select(player => player.displayName) : _evil.ToList().Select(player => player.displayName));
            }

            public void GiveShirt(BasePlayer player)
            {
                Item item = ItemManager.CreateByName(_.teamShirt, 1, GetTeam(player) == Team.Evil ? _.teamEvilShirt : _.teamGoodShirt);

                if (item == null)
                    return;

                if (item.info.category != ItemCategory.Attire)
                {
                    item.Remove(0.01f);
                    return;
                }

                foreach (Item wear in player.inventory.containerWear.itemList)
                {
                    if (wear.info.shortname.Contains("shirt"))
                    {
                        wear.RemoveFromContainer();
                        wear.Remove(0.01f);
                        break;
                    }
                }

                item.MoveToContainer(player.inventory.containerWear, -1, false);

                if (!player.inventory.containerWear.HasFlag(ItemContainer.Flag.IsLocked))
                    player.inventory.containerWear.SetFlag(ItemContainer.Flag.IsLocked, true);
            }

            public bool AddMatchPlayer(BasePlayer player, Team team)
            {
                if (_started)
                {
                    Message(player, _.msg("MatchStartedAlready", player.UserIDString));
                    return false;
                }

                _good.RemoveWhere(IsNotConnected);
                _evil.RemoveWhere(IsNotConnected);

                if (_banned.Contains(player.userID))
                    return false;

                if (!_.IsNewman(player))
                {
                    Message(player, _.msg("MustBeNaked", player.UserIDString));
                    return false;
                }

                switch (team)
                {
                    case Team.Good:
                        if (_good.Count == _teamSize)
                        {
                            Message(player, _.msg("MatchTeamFull", player.UserIDString, _teamSize));
                            return false;
                        }

                        _good.Add(player);
                        MessageAll("MatchJoinedTeam", player.displayName, _goodHostName, _good.Count, _teamSize, _evilHostName, _evil.Count);
                        break;
                    case Team.Evil:
                        if (_evil.Count == _teamSize)
                        {
                            Message(player, _.msg("MatchTeamFull", player.UserIDString, _teamSize));
                            return false;
                        }

                        _evil.Add(player);
                        MessageAll("MatchJoinedTeam", player.displayName, _evilHostName, _evil.Count, _teamSize, _goodHostName, _good.Count);
                        break;
                }

                if (_good.Count == _teamSize && _evil.Count == _teamSize)
                    Queue();

                return true;
            }

            public bool RemoveMatchPlayer(BasePlayer player)
            {
                if (player == null)
                    return false;

                if (player.inventory.containerWear.HasFlag(ItemContainer.Flag.IsLocked))
                    player.inventory.containerWear.SetFlag(ItemContainer.Flag.IsLocked, false);

                _.Metabolize(player, false);
                _.Track(player, false);
                _.RemoveEntities(player.userID);
                Interface.Oxide.CallHook("DisableBypass", player.userID);

                if (_.DuelTerritory(player.transform.position))
                {
                    if (_.sendDefeatedHome)
                        _.SendHome(player);
                    else
                        _.StartSpectate(player);
                }

                if (IsOver)
                {
                    _good.Remove(player);
                    _evil.Remove(player);
                    return true;
                }

                if (_good.Remove(player))
                {
                    if (_good.Count == 0)
                    {
                        if (_started)
                        {
                            _goodKIA.Add(player.userID);
                            _goodRematch.Add(player);
                        }
                        else
                            MessageAll("MatchNoPlayersLeft");

                        EndMatch(Team.Evil);
                        return true;
                    }
                    if (_started)
                    {
                        _goodKIA.Add(player.userID);
                        _goodRematch.Add(player);
                    }

                    if (player.UserIDString == _goodHostId)
                        AssignGoodHostId();

                    return true;
                }

                if (_evil.Remove(player))
                {
                    if (_evil.Count == 0)
                    {
                        if (_started)
                        {
                            _evilKIA.Add(player.userID);
                            _evilRematch.Add(player);
                        }
                        else
                            MessageAll("MatchNoPlayersLeft");

                        EndMatch(Team.Good);
                        return true;
                    }
                    if (_started)
                    {
                        _evilKIA.Add(player.userID);
                        _evilRematch.Add(player);
                    }

                    if (player.UserIDString == _evilHostId)
                        AssignEvilHostId();

                    return true;
                }

                return false;
            }

            private void AssignGoodHostId()
            {
                _good.RemoveWhere(IsNotConnected);

                if (_good.Count > 0)
                {
                    _goodHostId = _good.FirstOrDefault().UserIDString;
                    _.matchUpdateRequired = true;
                }
                else
                    EndMatch(Team.Evil);
            }

            private void AssignEvilHostId()
            {
                _evil.RemoveWhere(IsNotConnected);

                if (_evil.Count > 0)
                {
                    _evilHostId = _evil.FirstOrDefault().UserIDString;
                    _.matchUpdateRequired = true;
                }
                else
                    EndMatch(Team.Good);
            }

            private void Finalize(Team team)
            {
                Interface.CallHook("OnDuelistFinalized", team == Team.Good ? _goodKIA : _evilKIA);

                switch (team)
                {
                    case Team.Evil:
                        {
                            foreach (ulong playerId in _goodKIA)
                            {
                                _.UpdateMatchStats(playerId.ToString(), false, true, false, false);
                                _.UpdateMatchSizeStats(playerId.ToString(), true, false, _teamSize);
                            }

                            foreach (ulong playerId in _evilKIA)
                            {
                                _.AwardPlayer(playerId, _.teamEconomicsMoney, _.teamServerRewardsPoints);
                                _.UpdateMatchStats(playerId.ToString(), true, false, false, false);
                                _.UpdateMatchSizeStats(playerId.ToString(), false, true, _teamSize);
                            }

                            break;
                        }
                    case Team.Good:
                        {
                            foreach (ulong playerId in _evilKIA)
                            {
                                _.UpdateMatchStats(playerId.ToString(), false, true, false, false);
                                _.UpdateMatchSizeStats(playerId.ToString(), true, false, _teamSize);
                            }

                            foreach (ulong playerId in _goodKIA)
                            {
                                _.AwardPlayer(playerId, _.teamEconomicsMoney, _.teamServerRewardsPoints);
                                _.UpdateMatchStats(playerId.ToString(), true, false, false, false);
                                _.UpdateMatchSizeStats(playerId.ToString(), false, true, _teamSize);
                            }

                            break;
                        }
                }

                _goodKIA.Clear();
                _evilKIA.Clear();
            }

            private bool SetupRematch()
            {
                if (!CanRematch || _goodRematch.Exists(IsNotConnected) || _evilRematch.Exists(IsNotConnected))
                    return false;

                var rematch = new Rematch(_);

                if (rematch.AddRange(_evilRematch, Team.Evil) && rematch.AddRange(_goodRematch, Team.Good))
                {
                    rematch.match = this;
                    rematch.Notify();
                    _.rematches.Add(rematch);
                    return true;
                }

                return false;
            }

            private void EndMatch(Team team)
            {
                if (!_ended && _started)
                {
                    Finalize(team);
                    _.Puts(_.msg("MatchDefeat", null, team == Team.Evil ? _evilHostName : _goodHostName, team == Team.Evil ? _goodHostName : _evilHostName, _teamSize));
                    IsOver = true;
                    IsStarted = false;

                    foreach (var player in _evil.ToList())
                    {
                        RemoveMatchPlayer(player);

                        if (player != null && player.IsConnected && !_evilRematch.Contains(player))
                            _evilRematch.Add(player);
                    }

                    foreach (var player in _good.ToList())
                    {
                        RemoveMatchPlayer(player);

                        if (player != null && player.IsConnected && !_goodRematch.Contains(player))
                            _goodRematch.Add(player);
                    }

                    foreach (var target in BasePlayer.activePlayerList.Where(p => p?.displayName != null))
                    {
                        if (_.guiAnnounceUITime > 0f && (_goodKIA.Contains(target.userID) || _evilKIA.Contains(target.userID)))
                            _.CreateAnnouncementUI(target, _.msg("MatchDefeat", target.UserIDString, team == Team.Evil ? _evilHostName : _goodHostName, team == Team.Evil ? _goodHostName : _evilHostName, _teamSize));

                        if (_.duelsData.Chat.Contains(target.UserIDString) && !_goodKIA.Contains(target.userID) && !_evilKIA.Contains(target.userID))
                            continue;

                        Message(target, _.msg("MatchDefeat", target.UserIDString, team == Team.Evil ? _evilHostName : _goodHostName, team == Team.Evil ? _goodHostName : _evilHostName, _teamSize));
                    }

                    if (!SetupRematch())
                    {
                        var _list = new List<BasePlayer>();

                        _list.AddRange(_evilRematch);
                        _list.AddRange(_goodRematch);

                        foreach (var player in _list)
                        {
                            if (IsNotConnected(player)) continue;
                            Message(player, _.msg("RematchFailed2", player.UserIDString));
                        }

                        Reuse();
                    }
                }

                End();
            }

            public void End(bool forced = false)
            {
                if (_zone != null)
                    _zone.IsLocked = false;

                _queueTimer?.Destroy();
                _good.RemoveWhere(IsNull);
                _evil.RemoveWhere(IsNull);

                var _list = new List<BasePlayer>();

                _list.AddRange(_good);
                _list.AddRange(_evil);

                foreach (var player in _list)
                {
                    if (player.inventory.containerWear.HasFlag(ItemContainer.Flag.IsLocked))
                        player.inventory.containerWear.SetFlag(ItemContainer.Flag.IsLocked, false);

                    if (IsStarted || IsOver)
                    {
                        if (_.DuelTerritory(player.transform.position))
                        {
                            player.inventory.Strip();
                            _.SendHome(player);
                        }

                        _.Metabolize(player, false);
                        _.Track(player, false);
                    }
                }

                _good.Clear();
                _evil.Clear();
                _.tdmMatches.Remove(this);
                _.matchUpdateRequired = true;

                if (_.dataDuelists.Count == 0 && _.tdmMatches.Count == 0)
                    _.Unsubscribe(nameof(OnPlayerHealthChange));
            }

            private void Queue()
            {
                DuelingZone zone = null;

                var _list = new List<BasePlayer>();

                _list.AddRange(_good);
                _list.AddRange(_evil);

                foreach (var player in _list)
                {
                    if (player == null)
                        continue;

                    if (!_.IsNewman(player))
                    {
                        Message(player, _.msg("MustBeNaked", player.UserIDString));
                        MessageAll("MatchIsNotNaked", player.displayName);
                        _queueTimer = _.timer.Once(30f, Queue);
                        return;
                    }

                    if (zone == null)
                        zone = _.GetPlayerZone(player, TeamSize);
                }

                var zones = _.duelingZones.Where(x => x.TotalPlayers == 0 && !x.IsLocked && x.Spawns.Count >= (_.requireTeamSize ? TeamSize * 2 : 2)).ToList();

                if (zones == null || zones.Count == 0)
                {
                    if (!_enteredQueue)
                    {
                        MessageAll("MatchQueued");
                        _enteredQueue = true;
                    }

                    _queueTimer = _.timer.Once(2f, Queue);
                    return;
                }

                _zone = zone ?? LastZone ?? zones.GetRandom();
                _queueTimer?.Destroy();
                Start();
            }

            public DuelingZone LastZone
            {
                get
                {
                    DuelingZone zone = null;

                    if (_good.Exists(player => _.DuelTerritory(player.transform.position)))
                        zone = _.GetDuelZone(_good.FirstOrDefault(player => _.DuelTerritory(player.transform.position)).transform.position);

                    if (_evil.Exists(player => _.DuelTerritory(player.transform.position)))
                        zone = _.GetDuelZone(_evil.FirstOrDefault(player => _.DuelTerritory(player.transform.position)).transform.position);

                    return zone == null || zone.TotalPlayers > 0 || zone.IsLocked ? null : zone;
                }
            }

            private void Start()
            {
                _.SubscribeHooks(true);

                var goodSpawn = _zone.Spawns.GetRandom();
                var evilSpawn = goodSpawn;
                float dist = -100f;

                foreach (var spawn in _zone.Spawns) // get the furthest spawn point away from the good team and assign it to the evil team
                {
                    float distance = Vector3.Distance(spawn, goodSpawn);

                    if (distance > dist)
                    {
                        dist = distance;
                        evilSpawn = spawn;
                    }
                }

                _.Message(_good, "MatchStarted", GetNames(Team.Evil));
                _.Message(_evil, "MatchStarted", GetNames(Team.Good));
                _zone.IsLocked = true;
                IsStarted = true;

                Spawn(_good, goodSpawn);
                Spawn(_evil, evilSpawn);
            }

            private void Spawn(HashSet<BasePlayer> players, Vector3 spawn)
            {
                foreach (var player in players)
                {
                    _.duelsData.Kits[player.UserIDString] = _kit;

                    if (!_.DuelTerritory(player.transform.position) || !_.duelsData.Homes.ContainsKey(player.UserIDString))
                    {
                        var ppos = player.transform.position;
                        if (_.IsOnConstruction(ppos)) ppos.y += 1; // prevent player from becoming stuck or dying when teleported home
                        _.duelsData.Homes[player.UserIDString] = ppos.ToString();
                    }

                    _.RemoveFromQueue(player.UserIDString);
                    _.Teleport(player, spawn);

                    if (_.immunityTime >= 1)
                    {
                        _.dataImmunity[player.UserIDString] = TimeStamp() + _.immunityTime;
                        _.dataImmunitySpawns[player.UserIDString] = spawn;
                    }
                }
            }
        }

        public class DuelKitItem
        {
            public string ammo;
            public int amount;
            public string container;
            public List<string> mods;
            public string shortname;
            public ulong skin;
            public int slot;
        }

        public class BetInfo
        {
            public string trigger; // the trigger used to request this as a bet
            public int amount; // amount the player bet
            public int itemid; // the unique identifier of the item
            public int max; // the maximum amount allowed to bet on this item

            public bool Equals(BetInfo bet)
            {
                return bet.amount == amount && bet.itemid == itemid;
            }
        }

        public class DuelingZone : FacepunchBehaviour // Thanks @Jake_Rich for helping me get this started!
        {
            private Duelist _ => Instance;
            private HashSet<BasePlayer> _players = new HashSet<BasePlayer>();
            private HashSet<BasePlayer> _waiting = new HashSet<BasePlayer>();
            private Vector3 _zonePos;
            private List<Vector3> _duelSpawns = new List<Vector3>(); // spawn points generated on the fly
            private List<SphereEntity> spheres = new List<SphereEntity>();
            public bool IsLocked;
            public int Kills;

            public int TotalPlayers
            {
                get
                {
                    return _players.Count;
                }
            }

            public List<BasePlayer> Players
            {
                get
                {
                    return _players.ToList();
                }
            }

            public List<Vector3> Spawns
            {
                get
                {
                    var spawns = _.GetSpawnPoints(this); // get custom spawn points if any exist

                    return spawns == null || spawns.Count < 2 ? _duelSpawns : spawns;
                }
            }

            public bool IsFull
            {
                get
                {
                    return TotalPlayers + _waiting.Count + 2 > _.playersPerZone || IsLocked;
                }
            }

            public Vector3 Position
            {
                get
                {
                    return _zonePos;
                }
            }

            private void OnDestroy()
            {
                Destroy(gameObject);
                Destroy(this);
            }

            private void OnTriggerEnter(Collider col)
            {
                if (col == null) return;
                var entity = col.ToBaseEntity();

                if (entity is BaseMountable)
                {
                    var m = entity as BaseMountable;

                    if (m.GetParentEntity() is TrainCar)
                    {
                        return;
                    }

                    RemoveMountable(m, GetMountedPlayers(m));
                }
                else if (entity is BasePlayer)
                {
                    var p = entity as BasePlayer;

                    if (_.InEvent(p) || _.IsSpectator(p))
                    {
                        return;
                    }

                    RemovePlayer(p);
                }
            }


            public Vector3 GetEjectLocation(Vector3 a, float distance)
            {
                var position = ((a.XZ3D() - _zonePos.XZ3D()).normalized * (_.zoneRadius + distance)) + _zonePos; // credits ZoneManager
                float y = TerrainMeta.HighestPoint.y + 250f;

                RaycastHit hit;
                if (Physics.Raycast(position + new Vector3(0f, y, 0f), Vector3.down, out hit, Mathf.Infinity, targetLayer, QueryTriggerInteraction.Ignore))
                {
                    position.y = hit.point.y + 0.75f;
                }
                else position.y = Mathf.Max(TerrainMeta.HeightMap.GetHeight(position), TerrainMeta.WaterMap.GetHeight(position)) + 0.75f;

                return position;
            }

            public bool RemovePlayer(BasePlayer player)
            {
                if (!player.IsHuman() || player.IsAdmin)
                {
                    return false;
                }

                var m = player.GetMounted();

                if (m.IsValid())
                {
                    var players = GetMountedPlayers(m);

                    players.RemoveAll(x => x == null || !x.IsHuman());

                    if (RemoveMountable(m, players))
                    {
                        return true;
                    }
                }

                var position = GetEjectLocation(player.transform.position, 10f);

                if (player.IsFlying)
                {
                    position.y = player.transform.position.y;
                }

                player.Teleport(position);
                player.SendNetworkUpdateImmediate();

                return true;
            }

            public void DismountAllPlayers(BaseMountable m)
            {
                foreach (var target in GetMountedPlayers(m))
                {
                    if (target == null) continue;

                    m.DismountPlayer(target, false);

                    target.EnsureDismounted();
                }
            }

            private List<BasePlayer> GetMountedPlayers(BaseMountable m)
            {
                BaseVehicle vehicle = m.HasParent() ? m.VehicleParent() : m as BaseVehicle;

                if (vehicle.IsValid())
                {
                    return GetMountedPlayers(vehicle);
                }

                List<BasePlayer> players = new List<BasePlayer>();

                var player = m.GetMounted();

                if (player.IsValid() && player.IsHuman())
                {
                    players.Add(player);
                }

                return players;
            }

            private List<BasePlayer> GetMountedPlayers(BaseVehicle vehicle)
            {
                List<BasePlayer> players = new List<BasePlayer>();

                if (!vehicle.HasMountPoints())
                {
                    var player = vehicle.GetMounted();

                    if (player.IsValid() && player.IsHuman())
                    {
                        players.Add(player);
                    }

                    return players;
                }

                for (int i = 0; i < vehicle.mountPoints.Count; i++)
                {
                    var mountPoint = vehicle.mountPoints[i];

                    if (mountPoint.mountable == null)
                    {
                        continue;
                    }

                    var player = mountPoint.mountable.GetMounted();

                    if (player.IsValid() && player.IsHuman())
                    {
                        players.Add(player);
                    }
                }

                return players;
            }

            private bool RemoveMountable(BaseMountable m, List<BasePlayer> players)
            {
                if (players.Count == 0)
                {
                    return EjectMountable(m, 10f, players);
                }

                BaseVehicle vehicle = m.HasParent() ? m.VehicleParent() : m as BaseVehicle;

                if (!vehicle.IsKilled())
                {
                    var e = vehicle.transform.eulerAngles; // credits k1lly0u

                    vehicle.transform.rotation = Quaternion.Euler(e.x, e.y - 180f, e.z);

                    if (vehicle.rigidBody != null)
                    {
                        vehicle.rigidBody.velocity *= -1f;
                    }

                    return true;
                }

                return EjectMountable(m, 2f, players);
            }

            private bool IsFlying(BasePlayer player)
            {
                return player?.modelState?.onground == false && TerrainMeta.HeightMap.GetHeight(player.transform.position) < player.transform.position.y - 1f;
            }

            private bool EjectMountable(BaseMountable m, float distance, List<BasePlayer> players)
            {
                if (m is BaseVehicle)
                {
                    var vehicle = m as BaseVehicle;

                    foreach (var mp in vehicle.mountPoints)
                    {
                        if (mp.mountable.IsValid() && mp.mountable.GetMounted().IsValid())
                        {
                            if (mp.mountable.GetMounted().IsAdmin)
                            {
                                return false;
                            }
                        }
                    }
                }
                else if (m.GetMounted().IsValid())
                {
                    if (m.GetMounted().IsAdmin)
                    {
                        return false;
                    }
                }

                var j = TerrainMeta.HeightMap.GetHeight(m.transform.position) - m.transform.position.y;

                if (j > 5f)
                {
                    distance += j;
                }

                var position = ((m.transform.position.XZ3D() - _zonePos.XZ3D()).normalized * (_.zoneRadius + distance)) + _zonePos;
                var e = m.transform.eulerAngles;

                if (m is Minicopter || m is CH47Helicopter || players.Exists(player => IsFlying(player)))
                {
                    position.y = Mathf.Max(m.transform.position.y + 5f, GetSpawnHeight(position) + 1f);
                }
                else
                {
                    position.y = GetSpawnHeight(position) + 1f;
                }

                m.transform.rotation = Quaternion.Euler(e.x, e.y - 180f, e.z);

                Rigidbody rigidbody;
                if (m.TryGetComponent(out rigidbody))
                {
                    rigidbody.velocity *= -1f;
                }

                if (m.mountAnchor != null && m.mountAnchor.transform != null)
                {
                    m.transform.position = m.mountAnchor.transform.position = position;
                    m.mountAnchor.Rotate(m.transform.eulerAngles);
                }
                else m.transform.position = position;

                m.TransformChanged();

                return true;
            }

            private int targetLayer = ~(Layers.Mask.Invisible | Layers.Mask.Trigger | Layers.Mask.Prevent_Movement | Layers.Mask.Prevent_Building); // credits ZoneManager

            private static float GetSpawnHeight(Vector3 target)
            {
                float y = TerrainMeta.HeightMap.GetHeight(target);
                float w = TerrainMeta.WaterMap.GetHeight(target);
                float p = TerrainMeta.HighestPoint.y + 250f;
                RaycastHit hit;

                if (Physics.Raycast(new Vector3(target.x, w, target.z), Vector3.up, out hit, p, Layers.Mask.World))
                {
                    y = Mathf.Max(y, hit.point.y);

                    if (Physics.Raycast(new Vector3(target.x, hit.point.y + 0.5f, target.z), Vector3.up, out hit, p, Layers.Mask.World))
                    {
                        y = Mathf.Max(y, hit.point.y);
                    }
                }

                return Mathf.Max(y, w);
            }

            public void Setup(Vector3 position)
            {
                transform.position = _zonePos = position;
                _duelSpawns = _.GetAutoSpawns(this);

                if (_.removePlayers)
                {
                    var collider = gameObject.GetComponent<SphereCollider>() ?? gameObject.AddComponent<SphereCollider>();
                    collider.radius = _.zoneRadius + 1.5f;
                    collider.isTrigger = true;
                    collider.center = Vector3.zero;
                    gameObject.layer = (int)Layer.Trigger;
                }

                if (_.autoOvens || _.autoFlames || _.autoTurrets)
                {
                    var entities = new List<BaseCombatEntity>();
                    Vis.Entities(_zonePos, _.zoneRadius, entities);

                    foreach (var e in entities)
                    {
                        _.SetupPower(e);
                    }
                }

                CreateSpheres();
            }

            private void RemoveSpheres()
            {
                spheres.ForEach(sphere => sphere.SafelyKill());
            }

            private void CreateSpheres()
            {
                if (_.sphereAmount <= 0)
                {
                    return;
                }

                var prefab = StringPool.Get(3211242734);

                for (int i = 0; i < _.sphereAmount; i++)
                {
                    var sphere = GameManager.server.CreateEntity(prefab, _zonePos) as SphereEntity;

                    if (sphere == null)
                    {
                        break;
                    }

                    sphere.currentRadius = 1f;
                    sphere.Spawn();
                    sphere.LerpRadiusTo(_.zoneRadius * 2f, _.zoneRadius * 0.75f);
                    spheres.Add(sphere);
                }
            }

            public float Distance(Vector3 position)
            {
                position.y = 0f;
                return Vector3.Distance(new Vector3(_zonePos.x, 0f, _zonePos.z), position);
            }

            public bool? AddWaiting(BasePlayer player, BasePlayer target)
            {
                if (IsFull)
                    return false;

                double requiredDuelMoney = _.requiredDuelMoney;

                if (requiredDuelMoney > 0.0 && _.Economics.CanCall())
                {
                    double playerMoney = Convert.ToDouble(_.Economics.Call("Balance", player.userID));
                    double targetMoney = Convert.ToDouble(_.Economics.Call("Balance", target.userID));

                    if (playerMoney < _.requiredDuelMoney || targetMoney < requiredDuelMoney)
                    {
                        _.RemoveFromQueue(player.UserIDString);
                        _.RemoveFromQueue(target.UserIDString);
                        Message(player, _.msg("MoneyRequired", player.UserIDString, requiredDuelMoney));
                        Message(target, _.msg("MoneyRequired", target.UserIDString, requiredDuelMoney));
                        return null;
                    }

                    bool playerWithdrawn = Convert.ToBoolean(_.Economics.Call("Withdraw", player.userID, requiredDuelMoney));
                    bool targetWithdrawn = Convert.ToBoolean(_.Economics.Call("Withdraw", target.userID, requiredDuelMoney));

                    if (!playerWithdrawn || !targetWithdrawn)
                    {
                        _.RemoveFromQueue(player.UserIDString);
                        _.RemoveFromQueue(target.UserIDString);
                        return null;
                    }
                }

                _waiting.Add(player);
                _waiting.Add(target);

                return true;
            }

            public bool IsWaiting(BasePlayer player)
            {
                return _waiting.Contains(player);
            }

            public void AddPlayer(BasePlayer player)
            {
                _waiting.Remove(player);
                _players.Add(player);
            }

            public void RemovePlayer(string playerId)
            {
                _players.RemoveWhere(IsNull);

                foreach (var player in _players)
                {
                    if (player.UserIDString == playerId)
                    {
                        _players.Remove(player);
                        _waiting.Remove(player);
                        break;
                    }
                }
            }

            public bool HasPlayer(string playerId)
            {
                return _players.Exists(player => player.UserIDString == playerId);
            }

            public void Kill()
            {
                foreach (var player in _players.ToList())
                    _.EjectPlayer(player);

                foreach (var player in BasePlayer.allPlayerList)
                {
                    if (Distance(player.transform.position) <= _.zoneRadius)
                    {
                        _.EndSpectate(player);
                        _.SendHome(player);
                    }
                }

                _.duelingZones.Remove(this);
                _players.Clear();
                RemoveSpheres();
                Destroy(gameObject);
                Destroy(this);
            }
        }

        private object OnDangerousOpen(Vector3 treasurePos)
        {
            return DuelTerritory(treasurePos) ? (object)false : null;
        }

        private object OnPlayerDeathMessage(BasePlayer victim, HitInfo info) // private plugin hook
        {
            return DuelTerritory(victim.transform.position) ? (object)false : null;
        }

        private void Init()
        {
            Instance = this;
            SubscribeHooks(false); // turn off all hooks immediately
        }

        private void OnServerInitialized()
        {
            LoadVariables();
            SetupDefinitions();

            monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>().Select(monument => monument.transform.position).ToList();
            duelsFile = Interface.Oxide.DataFileSystem.GetFile(Name);

            try
            {
                duelsData = duelsFile.ReadObject<StoredData>();
            }
            catch { }

            if (duelsData == null)
                duelsData = new StoredData();

            foreach (var bet in duelingBets.ToList()) // 0.1.5 fix - check itemList after server has initialized
            {
                if (ItemManager.itemList.Find(def => def.itemid == bet.itemid) == null)
                {
                    Puts("Bet itemid {0} is invalid.", bet.itemid);
                    duelingBets.Remove(bet);
                }
            }

            if (useAnnouncement && announceTime > 0f)
                announceTimer = timer.Repeat(announceTime, 0, () => DuelAnnouncement(false));

            eventTimer = timer.Once(0.5f, CheckDuelistMortality); // kill players who haven't finished their duel in time. remove temporary immunity for duelers when it expires

            if (!resetDuelists && BuildingManager.server.buildingDictionary.Count == 0)
            {
                if (duelsData.VictoriesSeed.Count > 0 && duelsData.VictoriesSeed.Values.Exists(x => x > 0))
                {
                    resetDuelists = true;
                }
            }

            if (resetDuelists) // map wipe detected - award duelers and reset the data for the seed only
            {
                ResetDuelists();
                resetDuelists = false;
            }

            if (BasePlayer.activePlayerList.Count == 0)
            {
                RemoveZeroStats();
                ResetTemporaryData();
            }

            if (ZoneManager.CanCall())
                SetupZoneManager();

            SetupZones();

            if (duelingZones.Count > 0 && autoEnable)
                duelsData.DuelsEnabled = true;

            UpdateStability();
            CheckZoneHooks(true);

            if (guiAutoEnable)
            {
                Subscribe(nameof(OnPlayerConnected));

                foreach (var player in BasePlayer.activePlayerList)
                    OnPlayerConnected(player);
            }

            if (useWorkshopSkins)
                webrequest.Enqueue("http://s3.amazonaws.com/s3.playrust.com/icons/inventory/rust/schema.json", null, GetWorkshopIDs, this, Core.Libraries.RequestMethod.GET);
        }

        private void OnServerSave()
        {
            timer.Once(5f, SaveData);
        }

        private void OnNewSave(string filename)
        {
            resetDuelists = true;
        }

        public void SaveData()
        {
            if (duelsFile != null && duelsData != null)
            {
                duelsFile.WriteObject(duelsData);
            }
        }

        private void DestroyAll()
        {
            foreach (var zone in duelingZones.ToList())
            {
                UnityEngine.Object.Destroy(zone.gameObject);
            }
        }

        private void Unload()
        {
            var objects = UnityEngine.Object.FindObjectsOfType(typeof(Tracker));

            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);

            DestroyAll();
            announceTimer?.Destroy();
            eventTimer?.Destroy();

            foreach (var match in tdmMatches.ToList())
                match.End();

            foreach (var zone in duelingZones.ToList())
            {
                RemoveEntities(zone);
                zone.Kill();
            }

            tdmMatches.Clear();
            duelingZones.Clear();
            ResetTemporaryData();
            DestroyAllUI();
            Instance = null;
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var match = GetMatch(player);

            if (match != null && !match.IsStarted && match.EitherEmpty)
                match.End();

            if (dataDuelists.ContainsKey(player.UserIDString))
            {
                string uid = player.UserIDString;

                if (!dcsBlock.Contains(uid))
                {
                    dcsBlock.Add(uid);
                    timer.Once(60f, () => dcsBlock.Remove(uid));
                }

                duelsData.AutoReady.Remove(player.UserIDString);
                OnDuelistLost(player, true);
                RemoveDuelist(player.UserIDString);
                ResetDuelist(player.UserIDString, false);
            }
            else if (match != null && match.IsStarted && !match.IsOver)
            {
                string uid = player.UserIDString;

                if (!dcsBlock.Contains(uid))
                {
                    dcsBlock.Add(uid);
                    timer.Once(60f, () => dcsBlock.Remove(uid));
                }

                duelsData.AutoReady.Remove(player.UserIDString);
                player.inventory.Strip();
                DefeatMessage(player, match);
                match.CanRematch = false;
                match.RemoveMatchPlayer(player);
            }
            else if (IsSpectator(player))
            {
                EndSpectate(player);
                SendHome(player);
            }

            if (dataDuelists.Count == 0 && tdmMatches.Count == 0 && spectators.Count == 0)
                Unsubscribe(nameof(OnPlayerDisconnected)); // nothing else to do right now, unsubscribe the hook
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!player.IsValid())
                return;

            if (!player.CanInteract())
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }

            createUI.Remove(player.UserIDString);
            cmdDUI(player, szUIChatCommand, new string[0]);
        }

        private List<ulong> executes = new List<ulong>();

        private void OnPlayerSleepEnded(BasePlayer player) // setup the player
        {
            if (IsDueling(player))
            {
                if (IsExploiting(player, true))
                {
                    return;
                }

                foreach (var zone in duelingZones)
                {
                    if (zone.IsWaiting(player))
                    {
                        if (deathTime > 0)
                        {
                            if (!executes.Contains(player.userID))
                            {
                                Message(player, msg("ExecutionTime", player.UserIDString, deathTime));
                                executes.Add(player.userID);
                            }

                            dataDeath[player.UserIDString] = TimeStamp() + deathTime * 60;
                        }

                        EndSpectate(player);
                        GivePlayerKit(player);
                        Track(player, true);
                        Metabolize(player, true);

                        if (DestroyUI(player) && !createUI.Contains(player.UserIDString))
                            createUI.Add(player.UserIDString);

                        CheckAutoReady(player);
                        zone.AddPlayer(player);
                        Interface.Oxide.CallHook("EnableBypass", player.userID);
                    }
                }

                return;
            }
            else if (InDeathmatch(player))
            {
                if (IsExploiting(player, false))
                {
                    return;
                }

                var match = GetMatch(player);

                if (deathTime > 0)
                {
                    Message(player, msg("ExecutionTime", player.UserIDString, deathTime));
                    dataDeath[player.UserIDString] = TimeStamp() + deathTime * 60;
                }

                if (DestroyUI(player) && !createUI.Contains(player.UserIDString))
                {
                    createUI.Add(player.UserIDString);
                }

                EndSpectate(player);
                GivePlayerKit(player);
                Track(player, true);
                Metabolize(player, true);
                match.GiveShirt(player);
                CheckAutoReady(player);
                Interface.Oxide.CallHook("EnableBypass", player.userID);
                return;
            }
            else SetPlayerTime(player, false);

            if (announcements.ContainsKey(player.UserIDString))
            {
                CreateAnnouncementUI(player, announcements[player.UserIDString]);
                announcements.Remove(player.UserIDString);
            }

            if (dataDuelists.Count == 0 && tdmMatches.Count == 0 && announcements.Count == 0)
            {
                // nothing else to do right now, unsubscribe the hook
                Unsubscribe(nameof(OnPlayerSleepEnded));
            }
        }

        private bool IsExploiting(BasePlayer player, bool duel)
        {
            if (AimTrain.CanCall() && Convert.ToBoolean(AimTrain?.Call("IsAimTraining", player.userID)))
            {
                AimTrain?.Call("LeaveAimTrain", player);
                duelsData.AutoReady.Remove(player.UserIDString);
                DestroyUI(player);

                if (duel)
                {
                    OnDuelistLost(player, true);
                    RemoveDuelist(player.UserIDString);
                    ResetDuelist(player.UserIDString, false);
                    EndSpectate(player);
                    SendHome(player);
                }
                else
                {
                    var match = GetMatch(player);

                    if (match != null && !match.IsStarted && match.EitherEmpty)
                    {
                        match.End();
                    }

                    if (match != null && match.IsStarted && !match.IsOver)
                    {
                        DefeatMessage(player, match);
                        match.CanRematch = false;
                        match.RemoveMatchPlayer(player);
                    }
                }

                return true;
            }

            return false;
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (DuelTerritory(player.transform.position) && !InEvent(player) && !spectators.Contains(player.UserIDString))
            {
                var spawnPoint = ServerMgr.FindSpawnPoint();
                int retries = 25;

                while (DuelTerritory(spawnPoint.pos) && --retries > 0)
                    spawnPoint = ServerMgr.FindSpawnPoint();

                Teleport(player, spawnPoint.pos);
            }
        }

        private void OnEntityKill(SimpleBuildingBlock e)
        {
            if (respawnWalls)
            {
                if (e?.transform != null && e.ShortPrefabName.Contains("wall.external.high"))
                {
                    RecreateZoneWall(e.PrefabName, e.transform.position, e.transform.rotation, e.OwnerID);
                }
            }
        }

        public void SetupPower(BaseEntity e)
        {
            if (autoOvens && e is BaseOven)
            {
                e.SetFlag(BaseEntity.Flags.On, true);
            }
            else if (autoFlames && e is FlameTurret)
            {
                var ft = e as FlameTurret;

                if (!ft.HasFuel())
                {
                    ft.inventory.AddItem(ItemManager.FindItemDefinition("lowgradefuel"), 5);
                }

                ft.fuelPerSec = 0f;
            }
            else if (autoTurrets && e is AutoTurret)
            {
                var at = e as AutoTurret;

                at.InitiateStartup();
                at.SetPeacekeepermode(false);
            }
        }

        public void Track(BasePlayer player, bool enable)
        {
            Tracker tracker;
            if (enable && !player.TryGetComponent(out tracker))
            {
                tracker = player.gameObject.AddComponent<Tracker>();
                tracker.Init(this);
            }
            else if (!enable && player.TryGetComponent(out tracker))
            {
                UnityEngine.Object.Destroy(tracker);
            }
        }

        public void RecreateZoneWall(string prefab, Vector3 pos, Quaternion rot, ulong ownerId)
        {
            if (DuelTerritory(pos) && duelsData.DuelZones.Exists(entry => GetOwnerId(entry.Key) == ownerId))
                CreateZoneWall(prefab, pos, rot, ownerId);
        }

        public BaseEntity CreateZoneWall(string prefab, Vector3 pos, Quaternion rot, ulong ownerId)
        {
            var e = GameManager.server.CreateEntity(prefab, pos, rot, false);

            if (e != null)
            {
                e.OwnerID = ownerId;
                e.Spawn();
                e.gameObject.SetActive(true);
                return e;
            }

            return null;
        }

        private void OnEntityDeath(BaseEntity entity, HitInfo hitInfo) // 0.1.16 fix for player suiciding
        {
            if (entity == null)
                return;

            if (respawnWalls && entity.transform != null && entity.ShortPrefabName.Contains("wall.external.high"))
            {
                RecreateZoneWall(entity.PrefabName, entity.transform.position, entity.transform.rotation, entity.OwnerID);
                return;
            }

            var victim = entity as BasePlayer;

            if (victim == null)
                return;

            if (spectators.Contains(victim.UserIDString))
                EndSpectate(victim);

            if (IsDueling(victim))
            {
                victim.inventory.Strip();
                OnDuelistLost(victim, true);
            }
            else if (InDeathmatch(victim))
            {
                victim.inventory.Strip();
                var match = GetMatch(victim);

                DefeatMessage(victim, match);
                match.RemoveMatchPlayer(victim);
            }
        }

        private void OnPlayerHealthChange(BasePlayer player, float oldValue, float newValue)
        {
            if (newValue < 6f && player.IsHuman())
            {
                if (IsDueling(player))
                {
                    player.health = 6f;
                    player.inventory.Strip();
                    OnDuelistLost(player, false);
                }
                else if (InDeathmatch(player))
                {
                    player.health = 6f;
                    player.inventory.Strip();

                    var match = GetMatch(player);
                    DefeatMessage(player, match);
                    match.RemoveMatchPlayer(player);
                }
            }
        }

        private void DefeatMessage(BasePlayer victim, GoodVersusEvilMatch match)
        {
            if (tdmAttackers.ContainsKey(victim.UserIDString))
            {
                var info = tdmAttackers[victim.UserIDString];

                if (tdmServerDeaths || duelsData.ChatEx.Count > 0)
                {
                    foreach (var target in BasePlayer.activePlayerList.Where(p => p?.displayName != null))
                    {
                        if (duelsData.Chat.Contains(target.UserIDString) && target != victim)
                            continue;

                        Message(target, msg("MatchPlayerDefeated", target.UserIDString, victim.displayName, info.AttackerName, info.Weapon, info.BoneName, info.Distance));
                    }
                }
                else if (tdmMatchDeaths)
                    match.MessageAll("MatchPlayerDefeated", victim.displayName, info.AttackerName, info.Weapon, info.BoneName, info.Distance);

                if (guiAnnounceUITime > 0f)
                {
                    if (sendDefeatedHome)
                        announcements[victim.UserIDString] = msg("MatchPlayerDefeated", victim.UserIDString, victim.displayName, info.AttackerName, info.Weapon, info.BoneName, info.Distance);
                    else
                        CreateAnnouncementUI(victim, msg("MatchPlayerDefeated", victim.UserIDString, victim.displayName, info.AttackerName, info.Weapon, info.BoneName, info.Distance));
                }

                tdmAttackers.Remove(victim.UserIDString);
                UpdateMatchStats(victim.UserIDString, false, false, true, false);
                UpdateMatchStats(info.AttackerId, false, false, false, true);
            }
        }

        private void OnDuelistLost(BasePlayer victim, bool sendHome)
        {
            RemoveEntities(victim.userID);

            if (!dataDuelists.ContainsKey(victim.UserIDString))
            {
                NextTick(() => SendHome(victim));
                return;
            }

            string attackerId = dataDuelists[victim.UserIDString];
            var attacker = BasePlayer.Find(attackerId);
            string attackerName = attacker?.displayName ?? GetDisplayName(attackerId); // get the attackers name. null check for self inflicted

            dataDeath.Remove(victim.UserIDString); // remove them from automatic deaths
            dataDeath.Remove(attackerId);
            dataDuelists.Remove(victim.UserIDString); // unset their status as duelers
            dataDuelists.Remove(attackerId);
            victim.inventory.Strip();
            Metabolize(victim, false);
            Track(victim, false);

            if (!duelsData.LossesSeed.ContainsKey(victim.UserIDString)) duelsData.LossesSeed.Add(victim.UserIDString, 1);
            else duelsData.LossesSeed[victim.UserIDString]++;
            if (!duelsData.Losses.ContainsKey(victim.UserIDString)) duelsData.Losses.Add(victim.UserIDString, 1);
            else duelsData.Losses[victim.UserIDString]++;
            if (!duelsData.VictoriesSeed.ContainsKey(attackerId)) duelsData.VictoriesSeed.Add(attackerId, 1);
            else duelsData.VictoriesSeed[attackerId]++;
            if (!duelsData.Victories.ContainsKey(attackerId)) duelsData.Victories.Add(attackerId, 1);
            else duelsData.Victories[attackerId]++;
            duelsData.TotalDuels++;

            int victimLossesSeed = duelsData.LossesSeed[victim.UserIDString];
            int victimVictoriesSeed = duelsData.VictoriesSeed.ContainsKey(victim.UserIDString) ? duelsData.VictoriesSeed[victim.UserIDString] : 0;
            int attackerLossesSeed = duelsData.LossesSeed.ContainsKey(attackerId) ? duelsData.LossesSeed[attackerId] : 0;
            int attackerVictoriesSeed = duelsData.VictoriesSeed[attackerId];
            var bet = duelsData.Bets.ContainsKey(attackerId) && duelsData.Bets.ContainsKey(victim.UserIDString) && duelsData.Bets[attackerId].Equals(duelsData.Bets[victim.UserIDString]) && !IsAllied(victim, attacker) ? duelsData.Bets[attackerId] : null; // victim bet his attacker and lost, use later to add a claim for the attacker

            Puts(RemoveFormatting(msg("DuelDeathMessage", null, attackerName, attackerVictoriesSeed, attackerLossesSeed, victim.displayName, victimVictoriesSeed, victimLossesSeed, Math.Round(attacker?.health ?? 0f, 2), bet != null ? msg("BetWon", null, bet.trigger, bet.amount) : ""))); // send message to console
            Interface.CallHook("OnDuelistDefeated", attacker, victim);

            if (guiAnnounceUITime > 0f)
            {
                if (sendDefeatedHome)
                {
                    announcements[victim.UserIDString] = msg("DuelDeathMessage", victim.UserIDString, attackerName, attackerVictoriesSeed, attackerLossesSeed, victim.displayName, victimVictoriesSeed, victimLossesSeed, Math.Round(attacker?.health ?? 0f, 2), bet != null ? msg("BetWon", null, bet.trigger, bet.amount) : "");
                    announcements[attackerId] = msg("DuelDeathMessage", attackerId, attackerName, attackerVictoriesSeed, attackerLossesSeed, victim.displayName, victimVictoriesSeed, victimLossesSeed, Math.Round(attacker?.health ?? 0f, 2), bet != null ? msg("BetWon", null, bet.trigger, bet.amount) : "");
                }
                else
                {
                    CreateAnnouncementUI(victim, msg("DuelDeathMessage", victim.UserIDString, attackerName, attackerVictoriesSeed, attackerLossesSeed, victim.displayName, victimVictoriesSeed, victimLossesSeed, Math.Round(attacker?.health ?? 0f, 2), bet != null ? msg("BetWon", null, bet.trigger, bet.amount) : ""));
                    CreateAnnouncementUI(attacker, msg("DuelDeathMessage", attackerId, attackerName, attackerVictoriesSeed, attackerLossesSeed, victim.displayName, victimVictoriesSeed, victimLossesSeed, Math.Round(attacker?.health ?? 0f, 2), bet != null ? msg("BetWon", null, bet.trigger, bet.amount) : ""));
                }
            }

            foreach (var target in BasePlayer.activePlayerList.Where(p => p?.displayName != null))
            {
                if (duelsData.Chat.Contains(target.UserIDString) && target != victim && target != attacker)
                    continue;

                if (!broadcastDefeat && !duelsData.ChatEx.Contains(target.UserIDString) && target != victim && target != attacker)
                    continue;

                string betWon = bet != null ? msg("BetWon", target.UserIDString, bet.trigger, bet.amount) : "";
                Message(target, msg("DuelDeathMessage", target.UserIDString, attackerName, attackerVictoriesSeed, attackerLossesSeed, victim.displayName, victimVictoriesSeed, victimLossesSeed, Math.Round(attacker?.health ?? 0f, 2), betWon));
            }

            if (bet != null && attacker != null) // award the bet to the attacker
            {
                var claimBet = new BetInfo
                {
                    itemid = bet.itemid,
                    amount = bet.amount * 2,
                    trigger = bet.trigger
                };

                if (!duelsData.ClaimBets.ContainsKey(attackerId))
                    duelsData.ClaimBets.Add(attackerId, new List<BetInfo>());

                duelsData.ClaimBets[attackerId].Add(claimBet);
                duelsData.Bets.Remove(attackerId);
                duelsData.Bets.Remove(victim.UserIDString);
                Puts(msg("ConsoleBetWon", null, attacker.displayName, attacker.UserIDString, victim.displayName, victim.UserIDString));
                Message(attacker, msg("NotifyBetWon", attacker.UserIDString, szDuelChatCommand));
            }

            ulong attackeruId = Convert.ToUInt64(attackerId);

            RemoveDuelist(attackerId);
            RemoveEntities(attackeruId);
            AwardPlayer(attackeruId, economicsMoney, serverRewardsPoints);

            Interface.Oxide.CallHook("DisableBypass", victim.userID);
            Interface.Oxide.CallHook("DisableBypass", attackeruId);

            if (attacker != null)
            {
                attacker.inventory.Strip();
                Metabolize(attacker, false);
                Track(attacker, false);
            }

            var zone = RemoveDuelist(victim.UserIDString);

            if (zoneCounter > 0 && zone != null) // if new zones are set to spawn every X duels then increment by 1
            {
                if (++zone.Kills >= zoneCounter && zone.TotalPlayers == 0)
                {
                    RemoveDuelZone(zone);
                    SetupDuelZone(null, GetZoneName()); // x amount of duels completed. time to relocate and start all over! changing the dueling zones location keeps things mixed up and entertaining for everyone. especially when there's issues with terrain
                    SaveData();
                }
            }

            if (dataDuelists.Count == 0 && tdmMatches.Count == 0)
                Unsubscribe(nameof(OnPlayerHealthChange));

            if (sendHome || dcsBlock.Contains(victim.UserIDString))
            {
                NextTick(() =>
                {
                    SendHome(attacker);
                    SendHome(victim);
                });

                if (dcsBlock.Contains(victim.UserIDString))
                    return;
            }

            if (attacker != null)
            {
                if (victim.IsConnected && attacker.IsConnected)
                {
                    var rematch = new Rematch(this);
                    rematches.Add(rematch);
                    rematch.Duelists.Add(attacker);
                    rematch.Duelists.Add(victim);
                    rematch.Notify();
                }

                if (!InEvent(attacker) && !InEvent(victim) && !sendHome)
                {
                    StartSpectate(attacker);
                    StartSpectate(victim);
                }
            }
        }

        public string GetZoneName()
        {
            return (duelsData.DuelZones.Count + 1).ToString();
        }

        public void SendDuelistsHome()
        {
            foreach (var entry in dataDuelists.ToList())
            {
                if (duelsData.Homes.ContainsKey(entry.Key))
                {
                    var target = BasePlayer.Find(entry.Key);

                    if (target != null && DuelTerritory(target.transform.position))
                    {
                        target.inventory.Strip();
                        SendHome(target);
                    }
                }

                ResetDuelist(entry.Key);
            }
        }

        public void SendSpectatorsHome()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (IsSpectator(player))
                {
                    EndSpectate(player);
                }
            }
        }

        private void StartSpectate(BasePlayer player)
        {
            if (IsNotConnected(player))
                return;

            if (GetDuelZone(player.transform.position) == null)
            {
                SendHome(player);
                return;
            }

            if (!player.CanInteract())
            {
                if (player.IsDead())
                    player.RespawnAt(player.transform.position, default(Quaternion));

                timer.Once(1f, () => StartSpectate(player));
                return;
            }

            spectators.Add(player.UserIDString);
            Message(player, msg("BeginSpectating", player.UserIDString));
            player.inventory.Strip();
            player.health = 100f;
            player.metabolism.bleeding.value = 0f;
            player.StopWounded();
            CreateDefeatUI(player);
        }

        private void EndSpectate(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "DuelistUI_Defeat");

            if (spectators.Contains(player.UserIDString))
            {
                if (playerHealth > 0f && player.IsAlive())
                    player.health = playerHealth;

                spectators.Remove(player.UserIDString);
                player.SendNetworkUpdate();
                Message(player, msg("EndSpectating", player.UserIDString));
            }
        }

        private static bool IsNull(BaseNetworkable a) => a == null || a.IsDestroyed;

        private static bool IsNotConnected(BasePlayer a) => a == null || a.IsDestroyed || !a.IsConnected;

        public void HealDamage(BaseCombatEntity entity)
        {
            timer.Once(1f, () =>
            {
                if (!entity.IsKilled() && entity.health < entity.MaxHealth())
                {
                    entity.health = entity.MaxHealth();
                    entity.SendNetworkUpdate();
                }
            });
        }

        public void CancelDamage(HitInfo hitInfo)
        {
            if (hitInfo != null)
            {
                hitInfo.damageTypes = new DamageTypeList();
                hitInfo.DidHit = false;
                hitInfo.HitEntity = null;
                hitInfo.Initiator = null;
                hitInfo.DoHitEffects = false;
                hitInfo.HitMaterial = 0;
            }
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity.IsKilled() || entity.net == null || entity is BaseNpc)
                return null;

            if (DuelTerritory(entity.transform.position, 1f))
            {
                if (entity is BuildingBlock || entity.name.Contains("deploy") || entity.name.Contains("wall.external.high") || entity.name.Contains("building"))
                {
                    CancelDamage(hitInfo);
                    HealDamage(entity);
                    return true;
                }
            }

            if (hitInfo == null || hitInfo.Initiator.IsKilled() || !hitInfo.hasDamage)
                return null;

            var victim = entity as BasePlayer;
            var attacker = hitInfo.Initiator as BasePlayer;
            var pointStart = hitInfo.Initiator?.transform?.position ?? hitInfo.PointStart; // 0.1.6 border fix
            var pointEnd = entity.transform.position;
            bool adt = DuelTerritory(pointStart);
            bool vdt = DuelTerritory(pointEnd);

            if (adt && entity is PatrolHelicopter)
                return true;

            if (vdt && victim?.transform != null && hitInfo.Initiator != null && hitInfo.Initiator.ShortPrefabName.Contains("wall.external.high")) // 1.0.2 - exploit fix
                return true;

            if (victim != null && victim.transform != null && attacker != null && victim == attacker) // allow player to suicide and self inflict
            {
                if (hitInfo.damageTypes.Has(DamageType.Suicide) && InEvent(victim))
                {
                    string uid = victim.UserIDString;

                    if (!dcsBlock.Contains(uid))
                    {
                        dcsBlock.Add(uid);
                        timer.Once(60f, () => dcsBlock.Remove(uid));
                    }
                }

                return null;
            }

            if (victim != null && hitInfo.damageTypes.GetMajorityDamageType() == DamageType.Fall && !dataImmunity.ContainsKey(victim.UserIDString))
                return null;

            if (attacker?.transform != null && spectators.Contains(attacker.UserIDString)) // 0.1.27: someone will find a way to abuse spectate mode so we'll prevent that now
            {
                if (!adt)
                {
                    EndSpectate(attacker);
                    SendHome(attacker);
                }

                CancelDamage(hitInfo);
                return true;
            }

            if ((adt || vdt) && !hitInfo.Initiator.IsKilled() && hitInfo.Initiator.IsNpc) // 1.2.0
            {
                if (hitInfo.Initiator is BaseNpc)
                {
                    var npc = hitInfo.Initiator as BaseNpc;

                    if (npc != null)
                    {
                        if (putToSleep)
                        {
                            npc.SetAiFlag(BaseNpc.AiFlags.Sleeping, true);
                            npc.CurrentBehaviour = BaseNpc.Behaviour.Sleep;
                        }
                        else if (killNpc)
                        {
                            npc.Kill();
                        }

                        return true;
                    }
                }
                else if (hitInfo.Initiator is BasePlayer)
                {
                    var npc = hitInfo.Initiator as BasePlayer;

                    if (npc != null)
                    {
                        if (npc is global::HumanNPC)
                        {
                            (npc as global::HumanNPC).LootSpawnSlots = new LootContainer.LootSpawnSlot[0];
                        }

                        npc.Kill();
                        CancelDamage(hitInfo);
                        return true;
                    }
                }
            }

            if (dataDuelists.Count > 0)
            {
                if (attacker?.transform != null && IsDueling(attacker) && victim != null && dataDuelists[attacker.UserIDString] != victim.UserIDString) // 0.1.8 check attacker then victim
                    return true; // prevent attacker from doing damage to others

                if (victim?.transform != null && IsDueling(victim)) // 1.2.0 NRE get_transform
                {
                    if (victim.health == 6f)
                        return true;

                    if (dataImmunity.ContainsKey(victim.UserIDString))
                        return true; // immunity timer

                    if (hitInfo.Initiator is PatrolHelicopter)
                        return true; // protect duelers from helicopters

                    if (attacker?.transform != null && dataDuelists[victim.UserIDString] != attacker.UserIDString)
                        return true; // prevent attacker from doing damage to others

                    hitInfo.damageTypes.ScaleAll(damageScaleAmount);
                    return null;
                }
            }

            if (tdmMatches.Count > 0)
            {
                if (victim != null && attacker?.transform != null && InDeathmatch(attacker))
                {
                    var match = GetMatch(attacker);

                    if (match.GetTeam(victim) == Team.None)
                        return true;

                    if (!dmFF && match.GetTeam(victim) == match.GetTeam(attacker))
                        return true; // FF
                }

                if (victim?.transform != null && InDeathmatch(victim))
                {
                    if (dataImmunity.ContainsKey(victim.UserIDString))
                        return true;

                    if (hitInfo.Initiator is PatrolHelicopter)
                        return true;

                    if (attacker?.transform != null)
                    {
                        if (GetMatch(attacker) == null)
                            return true;

                        if (victim.health == 6f)
                            return true;

                        if (tdmAttackers.ContainsKey(victim.UserIDString))
                            tdmAttackers.Remove(victim.UserIDString);

                        string weapon = attacker.GetActiveItem()?.info?.displayName?.english ?? hitInfo?.WeaponPrefab?.ShortPrefabName ?? "??";

                        if (weapon.EndsWith(".entity"))
                        {
                            var def = ItemManager.FindItemDefinition(weapon.Replace(".entity", "").Replace("_", "."));
                            weapon = def?.displayName.translated ?? weapon.Replace(".entity", "").Replace("_", "").SentenceCase();
                        }

                        tdmAttackers.Add(victim.UserIDString, new AttackerInfo());
                        tdmAttackers[victim.UserIDString].AttackerName = attacker.displayName;
                        tdmAttackers[victim.UserIDString].AttackerId = attacker.UserIDString;
                        tdmAttackers[victim.UserIDString].Distance = Math.Round(Vector3.Distance(attacker.transform.position, victim.transform.position), 2).ToString();
                        tdmAttackers[victim.UserIDString].BoneName = FormatBone(hitInfo.boneName).TrimEnd(); //StringPool.Get(hitInfo.boneName)
                        tdmAttackers[victim.UserIDString].Weapon = weapon;
                    }

                    hitInfo.damageTypes.ScaleAll(damageScaleAmount);
                    return null;
                }
            }

            if (victim?.transform != null && attacker?.transform != null) // 1.1.1 - fix for players standing on the edge of a zone for protection
            {
                if (vdt && !InEvent(victim))
                    return null;

                if (adt && !InEvent(attacker))
                    return null;
            }

            if (adt && !vdt)
                return true; // block all damage to the outside

            if (!adt && vdt)
                return true; // block all damage to the inside

            return null;
        }

        private object OnRestoreUponDeath(BasePlayer player)
        {
            if (DuelTerritory(player.transform.position))
            {
                return InEvent(player) ? true : (object)null;
            }
            return null;
        }

        class Explosives : FacepunchBehaviour
        {
            WorldItem worldItem;
            float minExplosionRadius = 1f;
            float explosionRadius = 5f;
            int layers = 141568;

            void Awake()
            {
                worldItem = GetComponent<WorldItem>();
            }

            void OnDestroy()
            {
                var damageTypes = new List<DamageTypeEntry>
                {
                    new DamageTypeEntry()
                    {
                        amount = 25f,
                        type = DamageType.Explosion
                    }
                };

                Effect.server.Run("some resource", worldItem.PivotPoint(), worldItem.transform.forward, null, true);
                DamageUtil.RadiusDamage(worldItem, worldItem.LookupPrefab(), worldItem.CenterPoint(), minExplosionRadius, explosionRadius, damageTypes, layers, true);
                Destroy(this);
            }
        }

        void OnEntitySpawned(WorldItem worldItem)
        {
            NextTick(() =>
            {
                if (!worldItem.IsKilled() && worldItem.item != null && worldItem.item.info.shortname == "arrow.bone")
                {
                    worldItem.gameObject.AddComponent<Explosives>();
                }
            });
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            if (entity == null || entity.IsDestroyed || !DuelTerritory(entity.transform.position))
                return;

            if (entity.IsNpc)
            {
                NextTick(entity.SafelyKill);
                return;
            }

            if (autoOvens && entity is BaseOven || autoTurrets && entity is AutoTurret || autoFlames && entity is FlameTurret)
            {
                SetupPower(entity);
                return;
            }

            if (noStability && entity is BuildingBlock block)
            {
                if (block.OwnerID == 0 || permission.UserHasGroup(block.OwnerID.ToString(), "admin"))
                {
                    block.grounded = true;
                    return;
                }
            }

            if (dataDuelists.Count == 0 && tdmMatches.Count == 0)
                return;

            if (prefabs.ContainsKey(entity.PrefabName))
            {
                if (entity.name.Contains("barricade."))
                {
                    if (morphBarricadesStoneWalls || morphBarricadesWoodenWalls)
                    {
                        var wall = CreateZoneWall(morphBarricadesStoneWalls ? heswPrefab : hewwPrefab, entity.transform.position, entity.transform.rotation, entity.OwnerID);

                        if (wall != null)
                        {
                            entity.SafelyKill();

                            if (!duelEntities.TryGetValue(wall.OwnerID, out var entities))
                                duelEntities.Add(wall.OwnerID, entities = new());

                            entities.Add(wall);

                            return;
                        }
                    }
                }

                if (!duelEntities.TryGetValue(entity.OwnerID, out var entities2))
                    duelEntities.Add(entity.OwnerID, entities2 = new());
                
                entities2.Add(entity);
            }

            if (entity is PlayerCorpse || entity.name.Contains("item_drop_backpack"))
            {
                NextTick(entity.SafelyKill);
            }
            else if (entity is WorldItem)
            {
                if (duelsData.Homes.Count > 0)
                {
                    NextTick(() => // prevent rpc kick by using NextTick since we're also hooking OnItemDropped
                    {
                        if (!entity.IsKilled()) // we must check this or you will still be rpc kicked
                        {
                            var worldItem = entity as WorldItem; // allow thrown weapons / destroy items which are dropped by players and on death

                            if (worldItem != null && worldItem.item != null && !IsThrownWeapon(worldItem.item))
                                entity.Kill();
                        }
                    });

                    if (!entity.IsKilled())
                    {
                        timer.Repeat(0.1f, 20, () => // track the item to make sure it wasn't thrown out of the dueling zone
                        {
                            if (!entity.IsKilled() && !DuelTerritory(entity.transform.position))
                                entity.Kill(); // destroy items which are dropped from inside to outside of the zone
                        });
                    }
                }
            }
        }

        object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            var player = planner.GetOwnerPlayer();

            if (player.IsAdmin)
                return null;

            var position = player.transform.position;
            var buildPos = position + player.eyes.BodyForward() * 4f; // get the estimated position of where the player is trying to build at
            var up = buildPos + Vector3.up + new Vector3(0f, 0.6f, 0f);

            buildPos.y = Mathf.Max(position.y, up.y); // adjust the cursor position to our best estimate

            if (DuelTerritory(buildPos, buildingBlockExtensionRadius)) // extend the distance slightly
            {
                if (deployables.Count > 0)
                {
                    var kvp = prefabs.FirstOrDefault(x => x.Key == prefab.fullName);

                    if (!string.IsNullOrEmpty(kvp.Value) && deployables.ContainsKey(kvp.Value) && deployables[kvp.Value])
                    {
                        if (dataDuelists.ContainsKey(player.UserIDString) || InMatch(player))
                        {
                            return null;
                        }
                    }
                }

                Message(player, msg("Building is blocked!", player.UserIDString));
                return false;
            }

            return null;
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity) // stop all players from looting anything inside of dueling zones. this allows server owners to setup duels anywhere without worry.
        {
            if (player != null && (IsDueling(player) || InDeathmatch(player) || IsSpectator(player)))
                timer.Once(0.01f, player.EndLooting);

            if (dataDuelists.Count == 0 && tdmMatches.Count == 0 && spectators.Count == 0)
                Unsubscribe(nameof(OnLootEntity));
        }

        private object OnCreateWorldProjectile(HitInfo info, Item item) // prevents thrown items from becoming stuck in players when they respawn and requiring them to relog to remove them
        {
            if (info == null)
                return null;

            if (dataDuelists.Count == 0 && tdmMatches.Count == 0)
            {
                Unsubscribe(nameof(OnCreateWorldProjectile));
                return null;
            }

            var victim = info.HitEntity as BasePlayer;
            var attacker = info.Initiator as BasePlayer;

            if (victim != null && (IsDueling(victim) || InDeathmatch(victim)))
                return false; // block it

            if (attacker != null && (IsDueling(attacker) || InDeathmatch(attacker)))
                return false;

            return null;
        }

        private void OnItemDropped(Item item, BaseEntity entity)
        {
            if (dataDuelists.Count == 0 && tdmMatches.Count == 0) // nothing left to do here, unsubscribe the hook
            {
                Unsubscribe(nameof(OnItemDropped));
                return;
            }

            if (item.GetOwnerPlayer() == null)
                return;

            var player = item.GetOwnerPlayer();

            if (!IsThrownWeapon(item) && (IsDueling(player) || InDeathmatch(player)))
                item.Remove(0.01f); // do NOT allow players to drop items
        }

        private object IsPrisoner(BasePlayer player) // Random Warps
        {
            return IsDueling(player) || InDeathmatch(player) ? (object)true : null;
        }

        private object CanEventJoin(BasePlayer player) // EventManager
        {
            return IsDueling(player) || InDeathmatch(player) ? msg("CannotEventJoin", player.UserIDString) : null;
        }

        private object canRemove(BasePlayer player) // RemoverTool
        {
            return DuelTerritory(player.transform.position) ? (object)false : null;
        }

        private object CanTrade(BasePlayer player) // Trade
        {
            return DuelTerritory(player.transform.position) ? (object)false : null;
        }

        private object CanBank(BasePlayer player)
        {
            return DuelTerritory(player.transform.position) ? msg("CannotBank", player.UserIDString) : null;
        }

        private object CanOpenBackpack(BasePlayer player)
        {
            return DuelTerritory(player.transform.position) ? msg("CommandNotAllowed", player.UserIDString) : null;
        }

        private object canShop(BasePlayer player) // Shop and ServerRewards
        {
            return DuelTerritory(player.transform.position) ? msg("CannotShop", player.UserIDString) : null;
        }

        private object CanShop(BasePlayer player)
        {
            return DuelTerritory(player.transform.position) ? msg("CannotShop", player.UserIDString) : null;
        }

        private object CanBePenalized(BasePlayer player) // ZLevels Remastered
        {
            return DuelTerritory(player.transform.position) || dataDuelists.ContainsKey(player.UserIDString) ? (object)false : null;
        }

        private object canTeleport(BasePlayer player) // 0.1.2: block teleport from NTeleportation plugin
        {
            return DuelTerritory(player.transform.position) ? msg("CannotTeleport", player.UserIDString) : null;
        }

        private object CanTeleport(BasePlayer player) // 0.1.2: block teleport from MagicTeleportation plugin
        {
            return DuelTerritory(player.transform.position) ? msg("CannotTeleport", player.UserIDString) : null;
        }

        private object CanJoinTDMEvent(BasePlayer player)
        {
            return DuelTerritory(player.transform.position) ? (object)false : null;
        }

        private object CanEntityTakeDamage(BaseEntity entity, HitInfo hitinfo) // TruePVE!!!! <3 @ignignokt84
        {
            return entity is BasePlayer && DuelTerritory(entity.transform.position) ? (object)true : null;
        }

        private object CanJoinAimTrain(BasePlayer player)
        {
            if (InQueue(player.UserIDString) || InEvent(player) || DuelTerritory(player.transform.position))
            {
                return false;
            }

            return null;
        }

        private bool InQueue(string userid)
        {
            foreach (var element in duelsData.Queued)
            {
                if (element.Value == userid)
                {
                    return true;
                }
            }

            return false;
        }

        object OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (!player.IsValid() || player.transform == null || InQueue(player.UserIDString))
            {
                return null;
            }

            if (DuelTerritory(player.transform.position))
            {
                if (useBlacklistCommands && blacklistCommands.Exists(entry => entry.Replace("/", "").Equals(command, StringComparison.OrdinalIgnoreCase)))
                {
                    Message(player, msg("CommandNotAllowed", player.UserIDString));
                    return true;
                }

                if (useWhitelistCommands && !whitelistCommands.Exists(entry => entry.Replace("/", "").Equals(command, StringComparison.OrdinalIgnoreCase)))
                {
                    Message(player, msg("CommandNotAllowed", player.UserIDString));
                    return true;
                }
            }

            return null;
        }

        object OnServerCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();

            if (!player.IsValid() || InQueue(player.UserIDString))
            {
                return null;
            }

            if (DuelTerritory(player.transform.position))
            {
                string command = arg.cmd.FullName;

                if (useBlacklistCommands && blacklistCommands.Exists(entry => entry.Replace("/", "").Equals(command, StringComparison.OrdinalIgnoreCase)))
                {
                    Message(player, msg("CommandNotAllowed", player.UserIDString));
                    return true;
                }

                if (useWhitelistCommands && !whitelistCommands.Exists(entry => entry.Replace("/", "").Equals(command, StringComparison.OrdinalIgnoreCase)))
                {
                    Message(player, msg("CommandNotAllowed", player.UserIDString));
                    return true;
                }
            }

            return null;
        }

        public void CheckAutoReady(BasePlayer player)
        {
            if (duelsData.AutoReady.Contains(player.UserIDString))
            {
                if (!readyUiList.Contains(player.UserIDString))
                {
                    ToggleReadyUI(player);
                }
            }
            else if (readyUiList.Contains(player.UserIDString))
            {
                CuiHelper.DestroyUi(player, "DuelistUI_Ready");
                readyUiList.Remove(player.UserIDString);
            }
        }

        public void ToggleAutoReady(BasePlayer player)
        {
            if (duelsData.AutoReady.Contains(player.UserIDString))
                duelsData.AutoReady.Remove(player.UserIDString);
            else
                duelsData.AutoReady.Add(player.UserIDString);

            Message(player, msg(duelsData.AutoReady.Contains(player.UserIDString) ? "RematchAutoOn" : "RematchAutoOff", player.UserIDString));

            if (DuelTerritory(player.transform.position))
                CreateDefeatUI(player);

            if (duelistUI.Contains(player.UserIDString))
                RefreshUI(player);
        }

        public void ReadyUp(BasePlayer player)
        {
            var rematch = rematches.FirstOrDefault(x => x.HasPlayer(player));

            if (rematch == null)
            {
                ToggleAutoReady(player);
                Message(player, msg("RematchNone", player.UserIDString));
                return;
            }

            if (rematch.Ready.Contains(player))
            {
                Message(player, msg("RematchAcceptedAlready", player.UserIDString));
                ToggleAutoReady(player);
            }
            else
            {
                Message(player, msg("RematchAccepted", player.UserIDString));
                rematch.Ready.Add(player);
            }

            if (rematch.IsReady())
            {
                rematch.Start();
                rematches.Remove(rematch);
            }
        }

        public void cmdTDM(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin && args.Length == 1 && args[0] == "showall" && tdmMatches.Count > 0)
            {
                foreach (var match in tdmMatches)
                {
                    Message(player, msg("InMatchListGood", player.UserIDString, match.GetNames(Team.Good)));
                    Message(player, msg("InMatchListEvil", player.UserIDString, match.GetNames(Team.Evil)));
                }

                return;
            }

            if (!autoAllowAll && !duelsData.Allowed.Contains(player.UserIDString))
            {
                Message(player, msg("MustAllowDuels", player.UserIDString, szDuelChatCommand));
                return;
            }

            if (IsDueling(player))
            {
                Message(player, msg("AlreadyInADuel", player.UserIDString));
                return;
            }

            var deathmatch = tdmMatches.FirstOrDefault(x => x.GetTeam(player) != Team.None);

            if (deathmatch != null && deathmatch.IsStarted)
            {
                Message(player, msg("MatchStartedAlready", player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                if (deathmatch == null)
                {
                    if (!autoAllowAll)
                        Message(player, msg("HelpAllow", player.UserIDString, szDuelChatCommand));

                    Message(player, msg("MatchChallenge0", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchChallenge2", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchChallenge3", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchAccept", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchCancel", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchLeave", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchSize", player.UserIDString, szMatchChatCommand, minDeathmatchSize));
                    Message(player, msg("MatchKickBan", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchSetCode", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchTogglePublic", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchKit", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("UI_Help", player.UserIDString, szUIChatCommand));
                }
                else
                {
                    Message(player, msg("MatchLeave", player.UserIDString, szMatchChatCommand));

                    if (!deathmatch.IsHost(player))
                        return;

                    Message(player, msg("MatchCancel", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchSize", player.UserIDString, szMatchChatCommand, minDeathmatchSize));
                    Message(player, msg("MatchKickBan", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchSetCode", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchTogglePublic", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("MatchKit", player.UserIDString, szMatchChatCommand));
                    Message(player, msg("InMatchListGood", player.UserIDString, deathmatch.GetNames(Team.Good)));
                    Message(player, msg("InMatchListEvil", player.UserIDString, deathmatch.GetNames(Team.Evil)));
                }

                return;
            }

            RemoveRequests(player);

            switch (args[0].ToLower())
            {
                case "autoready":
                    {
                        ToggleAutoReady(player);
                        return;
                    }
                case "rematch":
                case "ready":
                    {
                        ReadyUp(player);
                        return;
                    }
                case "kit":
                    {
                        if (deathmatch != null)
                        {
                            if (!deathmatch.IsHost(player))
                            {
                                Message(player, msg("MatchKitSet", player.UserIDString, deathmatch.Kit));
                                return;
                            }

                            if (args.Length == 2)
                            {
                                string kit = GetVerifiedKit(args[1]);

                                if (string.IsNullOrEmpty(kit))
                                {
                                    Message(player, msg("MatchChallenge0", player.UserIDString, szMatchChatCommand));
                                    Message(player, msg("KitDoesntExist", player.UserIDString, args[1]));

                                    string kits = string.Join(", ", VerifiedKits.ToArray());

                                    if (!string.IsNullOrEmpty(kits))
                                        Message(player, "Kits: " + kits);
                                }
                                else
                                    deathmatch.Kit = kit;
                            }
                            else
                                Message(player, msg("MatchKit", player.UserIDString));
                        }
                        else
                            Message(player, msg("MatchDoesntExist", player.UserIDString, szMatchChatCommand));

                        return;
                    }
                case "kickban":
                    {
                        if (deathmatch != null)
                        {
                            if (!deathmatch.IsHost(player))
                            {
                                Message(player, msg("MatchNotAHost", player.UserIDString));
                                return;
                            }

                            if (args.Length == 2)
                            {
                                var target = BasePlayer.Find(args[1]);

                                if (target != null)
                                {
                                    if (deathmatch.GetTeam(target) == deathmatch.GetTeam(player))
                                    {
                                        if (deathmatch.Ban(target))
                                            Message(player, msg("MatchBannedUser", player.UserIDString, target.displayName));
                                        else
                                            Message(player, msg("MatchCannotBan", player.UserIDString));
                                    }
                                    else
                                        Message(player, msg("MatchPlayerNotFound", player.UserIDString, target.displayName));
                                }
                                else
                                    Message(player, msg("PlayerNotFound", player.UserIDString, args[1]));
                            }
                            else
                                Message(player, msg("MatchKickBan", player.UserIDString));
                        }
                        else
                            Message(player, msg("MatchDoesntExist", player.UserIDString, szMatchChatCommand));

                        break;
                    }
                case "setcode":
                    {
                        if (deathmatch != null)
                        {
                            if (deathmatch.IsHost(player))
                            {
                                if (args.Length == 2)
                                    deathmatch.SetCode(player, args[1]);

                                Message(player, msg("MatchCodeIs", player.UserIDString, deathmatch.GetTeam(player) == Team.Evil ? deathmatch.Code(Team.Evil) : deathmatch.Code(Team.Good)));
                            }
                            else
                                Message(player, msg("MatchNotAHost", player.UserIDString));
                        }
                        else
                            Message(player, msg("MatchDoesntExist", player.UserIDString, szMatchChatCommand));

                        break;
                    }
                case "cancel":
                case "decline":
                    {
                        if (deathmatch != null)
                        {
                            if (deathmatch.IsHost(player))
                            {
                                deathmatch.MessageAll("MatchCancelled", player.displayName);
                                deathmatch.End();

                                if (tdmMatches.Contains(deathmatch))
                                {
                                    tdmMatches.Remove(deathmatch);
                                    matchUpdateRequired = true;
                                }
                            }
                            else
                                Message(player, msg("MatchNotAHost", player.UserIDString));
                        }
                        else // also handle cancelling a match request
                        {
                            if (tdmRequests.ContainsValue(player.UserIDString))
                            {
                                var entry = tdmRequests.FirstOrDefault(kvp => kvp.Value == player.UserIDString);
                                var target = BasePlayer.Find(entry.Key);

                                if (target != null)
                                    Message(target, msg("MatchCancelled", target.UserIDString, player.displayName));

                                Message(player, msg("MatchCancelled", player.UserIDString, player.displayName));
                                tdmRequests.Remove(entry.Key);
                                return;
                            }

                            if (tdmRequests.ContainsKey(player.UserIDString))
                            {
                                var target = BasePlayer.Find(tdmRequests[player.UserIDString]);

                                if (target != null)
                                    Message(target, msg("MatchCancelled", player.UserIDString, player.displayName));

                                Message(player, msg("MatchCancelled", player.UserIDString, player.displayName));
                                tdmRequests.Remove(player.UserIDString);
                                return;
                            }

                            Message(player, msg("MatchDoesntExist", player.UserIDString, szMatchChatCommand));
                        }

                        break;
                    }
                case "size":
                    {
                        if (deathmatch != null)
                        {
                            if (args.Length == 2)
                            {
                                if (args[1].All(char.IsDigit))
                                {
                                    if (deathmatch.IsHost(player))
                                    {
                                        int size = Convert.ToInt32(args[1]);

                                        if (size < minDeathmatchSize)
                                            size = deathmatch.TeamSize;

                                        if (size > maxDeathmatchSize)
                                            size = maxDeathmatchSize;

                                        if (deathmatch.TeamSize != size)
                                            deathmatch.TeamSize = size; // sends message to all players in the match
                                    }
                                    else
                                        Message(player, msg("MatchNotAHost", player.UserIDString));
                                }
                                else
                                    Message(player, msg("InvalidNumber", player.UserIDString, args[1]));
                            }
                            else
                                Message(player, msg("MatchSizeSyntax", player.UserIDString, szMatchChatCommand));
                        }
                        else
                            Message(player, msg("MatchDoesntExist", player.UserIDString, szMatchChatCommand));

                        break;
                    }
                case "accept":
                    {
                        if (InEvent(player))
                        {
                            Message(player, msg("AlreadyDueling", player.UserIDString));
                            return;
                        }

                        if (!tdmRequests.ContainsValue(player.UserIDString))
                        {
                            Message(player, msg("MatchNoneRequested", player.UserIDString));
                            return;
                        }

                        var kvp = tdmRequests.FirstOrDefault(entry => entry.Value == player.UserIDString);
                        var target = BasePlayer.Find(kvp.Key);

                        tdmRequests.Remove(kvp.Key);

                        if (IsNotConnected(target))
                        {
                            Message(player, msg("MatchPlayerOffline", player.UserIDString));
                            break;
                        }

                        SetupTeams(player, target);
                        break;
                    }
                case "leave":
                    {
                        if (deathmatch != null)
                        {
                            deathmatch.RemoveMatchPlayer(player);
                            Message(player, msg("MatchPlayerLeft", player.UserIDString));
                        }
                        else
                            Message(player, msg("MatchDoesntExist", player.UserIDString, szMatchChatCommand));

                        break;
                    }
                case "any":
                    {
                        if (tdmMatches.Count == 0)
                        {
                            Message(player, msg("MatchNoMatchesExist", player.UserIDString, szMatchChatCommand));
                            return;
                        }

                        if (deathmatch != null)
                        {
                            deathmatch.RemoveMatchPlayer(player);
                            Message(player, msg("MatchPlayerLeft", player.UserIDString));
                        }

                        foreach (var match in tdmMatches)
                        {
                            if (match.IsBanned(player.userID) || match.IsFull())
                                continue;

                            if (!match.IsFull(Team.Good) && match.AlliedTo(player, Team.Good))
                            {
                                match.AddMatchPlayer(player, Team.Good);
                                return;
                            }

                            if (!match.IsFull(Team.Evil) && match.AlliedTo(player, Team.Evil))
                            {
                                match.AddMatchPlayer(player, Team.Evil);
                                return;
                            }

                            if (match.IsPublic)
                            {
                                if (!match.IsFull(Team.Good))
                                {
                                    match.AddMatchPlayer(player, Team.Good);
                                    return;
                                }

                                if (!match.IsFull(Team.Evil))
                                {
                                    match.AddMatchPlayer(player, Team.Evil);
                                    return;
                                }
                            }
                        }

                        Message(player, msg("MatchNoTeamFoundAny", player.UserIDString, args[0]));
                        break;
                    }
                case "public":
                    {
                        if (deathmatch != null)
                        {
                            if (!deathmatch.IsHost(player))
                            {
                                Message(player, msg("MatchNotAHost", player.UserIDString));
                                return;
                            }

                            deathmatch.IsPublic = !deathmatch.IsPublic;
                        }
                        else
                            Message(player, msg("MatchDoesntExist", player.UserIDString, szMatchChatCommand));

                        break;
                    }
                default:
                    {
                        if (args.Length > 1)
                        {
                            SetPlayerZone(player, args);

                            foreach (string arg in args)
                            {
                                string kit = GetVerifiedKit(arg);

                                if (!string.IsNullOrEmpty(kit))
                                {
                                    tdmKits[player.UserIDString] = kit;
                                    break;
                                }
                            }
                        }

                        var target = BasePlayer.Find(args[0]);

                        if (target != null)
                        {
                            if (target == player)
                            {
                                Message(player, msg("PlayerNotFound", player.UserIDString, args[0]));
                                return;
                            }

                            if (deathmatch != null)
                            {
                                Message(player, msg("MatchCannotChallengeAgain", player.UserIDString));
                                return;
                            }

                            if (InMatch(target) || tdmRequests.ContainsValue(target.UserIDString))
                            {
                                Message(player, msg("MatchCannotChallenge", player.UserIDString, target.displayName));
                                return;
                            }

                            if (!IsNewman(player))
                            {
                                Message(player, msg("MustBeNaked", player.UserIDString));
                                return;
                            }

                            if (!IsNewman(target))
                            {
                                Message(player, msg("TargetMustBeNaked", player.UserIDString));
                                return;
                            }

                            Message(player, msg("MatchRequestSent", player.UserIDString, target.displayName));
                            Message(target, msg("MatchRequested", target.UserIDString, player.displayName, szMatchChatCommand));

                            string uid = player.UserIDString;
                            tdmRequests.Remove(uid);
                            tdmRequests.Add(uid, target.UserIDString);
                            timer.Once(60f, () => tdmRequests.Remove(uid));
                            return;
                        }

                        if (tdmMatches.Count == 0)
                        {
                            Message(player, msg("MatchNoMatchesExist", player.UserIDString, szMatchChatCommand));
                            return;
                        }

                        if (deathmatch != null)
                        {
                            deathmatch.RemoveMatchPlayer(player);
                            Message(player, msg("MatchPlayerLeft", player.UserIDString));
                        }

                        foreach (var match in tdmMatches)
                        {
                            if (match.IsBanned(player.userID))
                                continue;

                            if (match.Code(Team.Good).Equals(args[0], StringComparison.OrdinalIgnoreCase))
                            {
                                match.AddMatchPlayer(player, Team.Good);
                                return;
                            }
                            else if (match.Code(Team.Evil).Equals(args[0], StringComparison.OrdinalIgnoreCase))
                            {
                                match.AddMatchPlayer(player, Team.Evil);
                                return;
                            }
                        }

                        Message(player, msg("MatchNoTeamFoundCode", player.UserIDString, args[0]));

                    }
                    break;
            }
        }

        public void cmdQueue(BasePlayer player, string command, string[] args)
        {
            if (IsNotConnected(player) || AimTrain.CanCall() && Convert.ToBoolean(AimTrain?.Call("IsAimTraining", player.userID)))
                return;

            if (!player.CanInteract())
            {
                timer.Once(1f, () => cmdQueue(player, command, args));
                return;
            }

            if (!autoAllowAll && !duelsData.Allowed.Contains(player.UserIDString))
            {
                Message(player, msg("MustAllowDuels", player.UserIDString, szDuelChatCommand));
                return;
            }

            if (InMatch(player))
            {
                Message(player, msg("MatchTeamed", player.UserIDString));
                return;
            }

            if (IsDueling(player))
            {
                Message(player, msg("AlreadyInADuel", player.UserIDString));
                return;
            }

            RemoveRequests(player);

            if (!IsNewman(player))
            {
                Message(player, msg("MustBeNaked", player.UserIDString));
                return;
            }

            if (player.IsAdmin)
            {
                Message(player, msg("InQueueList", player.UserIDString));
                Message(player, string.Join(", ", duelsData.Queued.ToList().Select(kvp => GetDisplayName(kvp.Value))));
            }

            if (!InQueue(player.UserIDString))
            {
                long stamp = TimeStamp();

                while (duelsData.Queued.ContainsKey(stamp))
                    stamp++;

                duelsData.Queued.Add(stamp, player.UserIDString);
                Message(player, msg("InQueueSuccess", player.UserIDString));
                CheckQueue();
                return;
            }

            if (RemoveFromQueue(player.UserIDString))
                Message(player, msg("NoLongerQueued", player.UserIDString));
        }

        private void cmdLadder(BasePlayer player, string command, string[] args)
        {
            bool onLadder = false;
            bool life = args.Exists(arg => arg.ToLower().Contains("life"));
            var sorted = life ? duelsData.Victories.ToList() : duelsData.VictoriesSeed.ToList();
            sorted.Sort((x, y) => y.Value.CompareTo(x.Value));

            Message(player, msg(life ? "TopAll" : "Top", player.UserIDString, sorted.Count));

            for (int i = 0; i < 10; i++)
            {
                if (i >= sorted.Count)
                    break;

                if (sorted[i].Key == player.UserIDString)
                    onLadder = true; // 0.1.2: fix for ranks showing user on ladder twice

                string name = GetDisplayName(sorted[i].Key);
                int losses = 0;

                if (life)
                    losses = duelsData.Losses.ContainsKey(sorted[i].Key) ? duelsData.Losses[sorted[i].Key] : 0;
                else
                    losses = duelsData.LossesSeed.ContainsKey(sorted[i].Key) ? duelsData.LossesSeed[sorted[i].Key] : 0;

                double ratio = losses > 0 ? Math.Round(sorted[i].Value / (double)losses, 2) : sorted[i].Value;
                string message = msg("TopFormat", player.UserIDString, (i + 1).ToString(), name, sorted[i].Value, losses, ratio);
                Player.Message(player, message, Convert.ToUInt64(sorted[i].Key));
            }

            if (!onLadder && !life && duelsData.VictoriesSeed.ContainsKey(player.UserIDString))
            {
                int index = sorted.FindIndex(kvp => kvp.Key == player.UserIDString);
                int losses = duelsData.LossesSeed.ContainsKey(player.UserIDString) ? duelsData.LossesSeed[player.UserIDString] : 0;
                double ratio = losses > 0 ? Math.Round(duelsData.VictoriesSeed[player.UserIDString] / (double)losses, 2) : duelsData.VictoriesSeed[player.UserIDString];
                string message = msg("TopFormat", player.UserIDString, index, player.displayName, duelsData.VictoriesSeed[player.UserIDString], losses, ratio);
                Player.Message(player, message, player.userID);
            }

            if (!onLadder && life && duelsData.Victories.ContainsKey(player.UserIDString))
            {
                int index = sorted.FindIndex(kvp => kvp.Key == player.UserIDString);
                int losses = duelsData.Losses.ContainsKey(player.UserIDString) ? duelsData.Losses[player.UserIDString] : 0;
                double ratio = losses > 0 ? Math.Round(duelsData.Victories[player.UserIDString] / (double)losses, 2) : duelsData.Victories[player.UserIDString];
                string message = msg("TopFormat", player.UserIDString, index, player.displayName, duelsData.Victories[player.UserIDString], losses, ratio);
                Player.Message(player, message, player.userID);
            }

            if (!life) Message(player, msg("LadderLife", player.UserIDString, szDuelChatCommand));
            sorted.Clear();
            sorted = null;
        }

        private void ccmdDuel(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
                return;

            string id = arg.Player()?.UserIDString ?? null;

            if (arg.HasArgs(1))
            {
                switch (arg.Args[0].ToLower())
                {
                    case "resetseed":
                        {
                            duelsData.VictoriesSeed.Clear();
                            duelsData.LossesSeed.Clear();
                            duelsData.MatchKillsSeed.Clear();
                            duelsData.MatchDeathsSeed.Clear();
                            duelsData.MatchLossesSeed.Clear();
                            duelsData.MatchVictoriesSeed.Clear();
                            duelsData.MatchSizesVictoriesSeed.Clear();
                            duelsData.MatchSizesVictoriesSeed.Clear();
                            arg.ReplyWith(msg("ResetSeed", arg.Player()?.UserIDString));
                            break;
                        }
                    case "removeall":
                        {
                            if (duelingZones.Count > 0)
                            {
                                foreach (var zone in duelingZones.ToList())
                                {
                                    EjectPlayers(zone);
                                    arg.ReplyWith(msg("RemovedZoneAt", id, zone.Position));
                                    RemoveDuelZone(zone);
                                }

                                duelsData.DuelZones.Clear();
                                SaveData();
                            }
                            else
                                arg.ReplyWith(msg("NoZoneExists", id));

                            break;
                        }
                    case "1":
                    case "enable":
                    case "on":
                        {
                            if (duelsData.DuelsEnabled)
                            {
                                arg.ReplyWith(msg("DuelsEnabledAlready", id));
                                return;
                            }

                            duelsData.DuelsEnabled = true;
                            arg.ReplyWith(msg("DuelsNowEnabled", id));
                            DuelAnnouncement(false);
                            SaveData();
                            return;
                        }
                    case "0":
                    case "disable":
                    case "off":
                        {
                            if (!duelsData.DuelsEnabled)
                            {
                                arg.ReplyWith(msg("DuelsDisabledAlready", id));
                                return;
                            }

                            duelsData.DuelsEnabled = false;
                            arg.ReplyWith(msg(dataDuelists.Count > 0 ? "DuelsNowDisabled" : "DuelsNowDisabledEmpty", id));
                            SendDuelistsHome();
                            SendSpectatorsHome();
                            SaveData();
                            return;
                        }
                    case "new":
                        {
                            if (duelsData.DuelZones.Count >= zoneAmount)
                            {
                                arg.ReplyWith(msg("ZoneLimit", id, zoneAmount));
                                return;
                            }

                            string zoneName = arg.Args.Length > 1 ? string.Join(" ", arg.Args.Skip(1)) : GetZoneName();

                            if (SetupDuelZone(null, zoneName) != Vector3.zero)
                                arg.ReplyWith(msg("ZoneCreated", id));

                            return;
                        }
                    default:
                        {
                            arg.ReplyWith(string.Format("{0} on|off|new|removeall|resetseed", szDuelChatCommand));
                            break;
                        }
                }
            }
            else
                arg.ReplyWith(string.Format("{0} on|off|new|removeall|resetseed", szDuelChatCommand));
        }

        private void CommandDuelist(IPlayer player, string command, string[] args)
        {
            switch (args[0])
            {
                case "kit":
                    {
                        string kits = string.Join(", ", VerifiedKits.ToArray());

                        player.Reply(string.IsNullOrEmpty(kits) ? msg("KitsNotConfigured", player.Id) : "Kits: " + kits);
                        return;
                    }
            }
        }

        private void cmdDuel(BasePlayer player, string command, string[] args)
        {
            if (AimTrain.CanCall() && Convert.ToBoolean(AimTrain?.Call("IsAimTraining", player.userID)))
                return;

            if (IsEventBanned(player.UserIDString))
            {
                Message(player, msg("Banned", player.UserIDString));
                return;
            }

            if (dcsBlock.Contains(player.UserIDString))
            {
                Message(player, msg("SuicideBlock", player.UserIDString));
                return;
            }

            if (args.Length >= 1 && args[0] == "ladder")
            {
                cmdLadder(player, command, args);
                return;
            }

            if (!duelsData.DuelsEnabled)
            {
                if (!args.Exists(arg => arg.ToLower() == "on"))
                    Message(player, msg("DuelsDisabled", player.UserIDString));

                if (!player.IsAdmin)
                    return;
            }

            bool noZone = duelsData.DuelZones.Count == 0 || duelingZones.Count == 0;

            if (noZone)
            {
                if (!args.Exists(arg => arg.ToLower() == "new") && !args.Exists(arg => arg.ToLower() == "removeall") && !args.Exists(arg => arg.ToLower() == "custom"))
                    Message(player, msg("NoZoneExists", player.UserIDString));

                if (!player.IsAdmin)
                    return;
            }

            if (!noZone && !duelsData.DuelsEnabled && !args.Exists(arg => arg.ToLower() == "on"))
                Message(player, msg("DuelsMustBeEnabled", player.UserIDString, szDuelChatCommand));

            if (IsDueling(player) && !player.IsAdmin)
                return;

            if (args.Length == 0)
            {
                Message(player, msg("HelpDuels", player.UserIDString, duelsData.TotalDuels.ToString("N0")));
                Message(player, msg("ZoneNames", player.UserIDString, duelsData.DuelZones.Count, string.Join(" ", duelsData.DuelZones.Values.ToList().Take(10).ToArray())));

                if (!autoAllowAll)
                    Message(player, msg("HelpAllow", player.UserIDString, szDuelChatCommand));

                Message(player, msg("HelpBlock", player.UserIDString, szDuelChatCommand));
                Message(player, msg("HelpChallenge", player.UserIDString, szDuelChatCommand));
                Message(player, msg("HelpAccept", player.UserIDString, szDuelChatCommand));
                Message(player, msg("HelpCancel", player.UserIDString, szDuelChatCommand));
                Message(player, msg("HelpChat", player.UserIDString, szDuelChatCommand));
                Message(player, msg("HelpQueue", player.UserIDString, szQueueChatCommand));
                Message(player, msg("HelpLadder", player.UserIDString, szDuelChatCommand));
                Message(player, msg("HelpKit", player.UserIDString, szDuelChatCommand));

                if (allowBets)
                    Message(player, msg("HelpBet", player.UserIDString, szDuelChatCommand));

                if (tdmEnabled)
                    Message(player, msg("HelpTDM", player.UserIDString, szMatchChatCommand));

                Message(player, msg("UI_Help", player.UserIDString, szUIChatCommand));

                if (player.IsAdmin)
                {
                    Message(player, msg("HelpDuelAdmin", player.UserIDString, szDuelChatCommand));
                    Message(player, msg("HelpDuelAdminRefundAll", player.UserIDString, szDuelChatCommand));
                }

                return;
            }

            switch (args[0].ToLower())
            {
                case "autoready":
                    {
                        ToggleAutoReady(player);
                        return;
                    }
                case "rematch":
                case "ready":
                    {
                        ReadyUp(player);
                        return;
                    }
                case "resetseed":
                    {
                        if (player.IsAdmin)
                        {
                            duelsData.VictoriesSeed.Clear();
                            duelsData.LossesSeed.Clear();
                            duelsData.MatchKillsSeed.Clear();
                            duelsData.MatchDeathsSeed.Clear();
                            duelsData.MatchLossesSeed.Clear();
                            duelsData.MatchVictoriesSeed.Clear();
                            duelsData.MatchSizesVictoriesSeed.Clear();
                            duelsData.MatchSizesVictoriesSeed.Clear();
                            Message(player, msg("ResetSeed", player.UserIDString));
                            Puts("{0] ({1}): {2}", player.displayName, player.UserIDString, msg("ResetSeed", player.UserIDString));
                        }
                        break;
                    }
                case "remove_all_walls":
                    {
                        if (player.IsAdmin)
                        {
                            int removed = 0;

                            if (respawnWalls)
                            {
                                Unsubscribe(nameof(OnEntityKill));
                            }

                            foreach (var entity in GetWallEntities().ToList())
                            {
                                if (entity.OwnerID > 0 && !entity.OwnerID.IsSteamId())
                                {
                                    entity.Kill();
                                    removed++;
                                }
                            }

                            if (respawnWalls)
                            {
                                Subscribe(nameof(OnEntityKill));
                            }

                            Message(player, msg("RemovedXWalls", player.UserIDString, removed));
                        }
                        break;
                    }
                case "remove_all":
                    {
                        if (player.IsAdmin && args.Length == 2 && args[1].All(char.IsDigit))
                        {
                            ulong ownerId = ulong.Parse(args[1]);
                            int removed = 0;

                            if (respawnWalls)
                            {
                                Unsubscribe(nameof(OnEntityKill));
                            }

                            foreach (var entity in GetWallEntities().ToList())
                            {
                                if (entity.OwnerID == ownerId)
                                {
                                    entity.Kill();
                                    removed++;
                                }
                            }

                            if (respawnWalls)
                            {
                                Subscribe(nameof(OnEntityKill));
                            }

                            Message(player, msg("RemovedXWalls", player.UserIDString, removed));
                        }
                        break;
                    }
                case "0":
                case "disable":
                case "off":
                    {
                        if (player.IsAdmin)
                        {
                            if (!duelsData.DuelsEnabled)
                            {
                                Message(player, msg("DuelsDisabledAlready", player.UserIDString));
                                return;
                            }

                            duelsData.DuelsEnabled = false;
                            Message(player, msg(dataDuelists.Count > 0 ? "DuelsNowDisabled" : "DuelsNowDisabledEmpty", player.UserIDString));
                            SendDuelistsHome();
                            SendSpectatorsHome();
                            SaveData();
                        }
                        break;
                    }
                case "1":
                case "enable":
                case "on":
                    {
                        if (player.IsAdmin)
                        {
                            if (duelsData.DuelsEnabled)
                            {
                                Message(player, msg("DuelsEnabledAlready", player.UserIDString));
                                return;
                            }

                            duelsData.DuelsEnabled = true;
                            Message(player, msg("DuelsNowEnabled", player.UserIDString));
                            DuelAnnouncement(false);
                            SaveData();
                        }
                        break;
                    }
                case "custom":
                case "me":
                    {
                        if (player.IsAdmin)
                        {
                            if (duelsData.DuelZones.Count >= zoneAmount)
                            {
                                Message(player, msg("ZoneLimit", player.UserIDString, zoneAmount));
                                return;
                            }

                            RaycastHit hit;
                            if (Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity, wallMask))
                            {
                                if (DuelTerritory(hit.point, 5f))
                                {
                                    Message(player, msg("ZoneExists", player.UserIDString));
                                    return;
                                }

                                string zoneName = args.Length > 1 ? string.Join(" ", args.Skip(1)) : GetZoneName();
                                var zone = SetupDuelZone(hit.point, null, zoneName);
                                int i = 0;

                                foreach (var spawn in zone.Spawns)
                                    player.SendConsoleCommand("ddraw.text", 30f, Color.yellow, spawn, ++i);

                                UpdateStability();

                                if (zoneCounter > 0) Message(player, $"Zone will reset after {zoneCounter} duels. Disable by setting `Create New Zone Every X Duels [0 = disabled]` to `0` in the config.");
                            }
                            else
                                Message(player, msg("FailedRaycast", player.UserIDString));
                        }
                        break;
                    }
                case "remove":
                    {
                        if (player.IsAdmin)
                        {
                            if (duelingZones.Count > 0)
                            {
                                var zone = GetDuelZone(player.transform.position);

                                if (zone == null)
                                {
                                    Message(player, msg("NoZoneFound", player.UserIDString));
                                    return;
                                }

                                EjectPlayers(zone);
                                RemoveDuelZone(zone);
                                Message(player, msg("RemovedZone", player.UserIDString));
                            }

                        }
                        break;
                    }
                case "removeall":
                    {
                        if (player.IsAdmin)
                        {
                            if (duelingZones.Count > 0)
                            {
                                foreach (var zone in duelingZones.ToList())
                                {
                                    EjectPlayers(zone);
                                    Message(player, msg("RemovedZoneAt", player.UserIDString, zone.Position));
                                    RemoveDuelZone(zone);
                                }

                                duelsData.DuelZones.Clear();
                                SaveData();
                            }
                            else
                                Message(player, msg("NoZoneExists", player.UserIDString));
                        }
                        break;
                    }
                case "spawns":
                    {
                        if (player.IsAdmin)
                        {
                            if (args.Length >= 2)
                            {
                                switch (args[1].ToLower())
                                {
                                    case "add":
                                        AddSpawnPoint(player, true);
                                        break;
                                    case "here":
                                        AddSpawnPoint(player, false);
                                        break;
                                    case "remove":
                                        RemoveSpawnPoint(player);
                                        break;
                                    case "removeall":
                                        RemoveSpawnPoints(player);
                                        break;
                                    case "wipe":
                                        WipeSpawnPoints(player);
                                        break;
                                    default:
                                        SendSpawnHelp(player);
                                        break;
                                }

                                return;
                            }

                            SendSpawnHelp(player);

                            int i = 0;
                            float dist = float.MaxValue;
                            DuelingZone destZone = null;

                            foreach (var zone in duelingZones)
                            {
                                if (zone.Distance(player.transform.position) > zoneRadius + 200f)
                                    continue;

                                float distance = zone.Distance(player.transform.position);

                                if (distance < dist)
                                {
                                    dist = distance;
                                    destZone = zone;
                                }
                            }

                            if (destZone != null)
                                foreach (var spawn in destZone.Spawns)
                                    player.SendConsoleCommand("ddraw.text", 30f, Color.yellow, spawn, ++i);
                        }
                        break;
                    }
                case "rename":
                    {
                        if (player.IsAdmin)
                        {
                            if (args.Length > 1)
                            {
                                var zone = GetDuelZone(player.transform.position);

                                if (zone == null)
                                {
                                    Message(player, msg("NoZoneFound", player.UserIDString));
                                    return;
                                }

                                string zoneName = string.Join(" ", args.Skip(1));
                                duelsData.DuelZones[zone.Position.ToString()] = zoneName;
                                Message(player, msg("ZoneRenamed", player.UserIDString, zoneName));
                            }
                            else
                                Message(player, msg("ZoneRename", player.UserIDString, szDuelChatCommand));

                            return;
                        }
                        break;
                    }
                case "new":
                    {
                        if (player.IsAdmin)
                        {
                            if (duelsData.DuelZones.Count >= zoneAmount)
                            {
                                Message(player, msg("ZoneLimit", player.UserIDString, zoneAmount));
                                return;
                            }

                            string zoneName = GetZoneName();
                            var _nameArgs = args.Where(arg => arg.ToLower() != "tp");

                            if (_nameArgs.ToList().Count > 0)
                                zoneName = string.Join(" ", _nameArgs);

                            var zonePos = SetupDuelZone(null, zoneName);

                            if (zonePos != Vector3.zero)
                            {
                                Message(player, msg("ZoneCreated", player.UserIDString));

                                if (args.Exists(arg => arg.ToLower() == "tp"))
                                {
                                    Player.Teleport(player, zonePos);
                                }
                            }

                        }
                        break;
                    }
                case "tpm":
                    {
                        if (player.IsAdmin)
                        {
                            float dist = float.MaxValue;
                            var dest = Vector3.zero;
                            var matches = tdmMatches.Exists(m => m.IsStarted) ? tdmMatches.Where(m => m.IsStarted).ToList() : tdmMatches.ToList(); // 0.1.17 if multiple zones then choose from active ones if any exist

                            foreach (var match in matches)
                            {
                                float distance = match.Zone.Distance(player.transform.position);

                                if (matches.Count > 1 && distance < zoneRadius * 4f) // move admin to the next nearest zone
                                    continue;

                                if (distance < dist)
                                {
                                    dist = distance;
                                    dest = match.Zone.Position;
                                }
                            }

                            if (dest != Vector3.zero)
                                Player.Teleport(player, dest);
                        }
                        break;
                    }
                case "tp":
                    {
                        if (player.IsAdmin)
                        {
                            float dist = float.MaxValue;
                            var dest = Vector3.zero;
                            var zones = duelingZones.Count > 3 && duelingZones.Exists(zone => zone.TotalPlayers > 0) ? duelingZones.Where(zone => zone.TotalPlayers > 0).ToList() : duelingZones; // 0.1.17 if multiple zones then choose from active ones if any exist

                            foreach (var zone in zones)
                            {
                                float distance = zone.Distance(player.transform.position);

                                if (zones.Count > 1 && distance < zoneRadius * 4f) // move admin to the next nearest zone
                                    continue;

                                if (distance < dist)
                                {
                                    dist = distance;
                                    dest = zone.Position;
                                }
                            }

                            if (dest != Vector3.zero)
                                Player.Teleport(player, dest);
                        }
                        break;
                    }
                case "save":
                    {
                        if (player.IsAdmin)
                        {
                            SaveData();
                            Message(player, msg("DataSaved", player.UserIDString));
                        }
                    }
                    break;
                case "ban":
                    {
                        if (player.IsAdmin && args.Length >= 2)
                        {
                            string targetId = args[1].IsSteamId() ? args[1] : BasePlayer.Find(args[1])?.UserIDString ?? null;

                            if (string.IsNullOrEmpty(targetId))
                            {
                                Message(player, msg("PlayerNotFound", player.UserIDString, args[1]));
                                return;
                            }

                            if (!duelsData.Bans.ContainsKey(targetId))
                            {
                                duelsData.Bans.Add(targetId, player.UserIDString);
                                Message(player, msg("AddedBan", player.UserIDString, targetId));
                            }
                            else
                            {
                                duelsData.Bans.Remove(targetId);
                                Message(player, msg("RemovedBan", player.UserIDString, targetId));
                            }

                            SaveData();
                        }
                        break;
                    }
                case "announce":
                    {
                        if (player.IsAdmin)
                            DuelAnnouncement(true);

                        break;
                    }
                case "claim":
                    {
                        if (!duelsData.ClaimBets.ContainsKey(player.UserIDString))
                        {
                            Message(player, msg("NoBetsToClaim", player.UserIDString));
                            return;
                        }

                        foreach (var bet in duelsData.ClaimBets[player.UserIDString].ToList())
                        {
                            var item = ItemManager.CreateByItemID(bet.itemid, bet.amount);

                            if (item == null)
                            {
                                continue;
                            }

                            if (!item.MoveToContainer(player.inventory.containerMain, -1))
                            {
                                var position = player.transform.position;
                                item.Drop(position + new Vector3(0f, 1f, 0f) + position / 2f, (position + new Vector3(0f, 0.2f, 0f)) * 8f); // Credit: Slack comment by @visagalis
                            }

                            string message = msg("PlayerClaimedBet", player.UserIDString, item.info.displayName.translated, item.amount);

                            Message(player, message);
                            Puts("{0} ({1}) - {2}", player.displayName, player.UserIDString, message);
                            duelsData.ClaimBets[player.UserIDString].Remove(bet);

                            if (duelsData.ClaimBets[player.UserIDString].Count == 0)
                            {
                                duelsData.ClaimBets.Remove(player.UserIDString);
                                Message(player, msg("AllBetsClaimed", player.UserIDString));
                            }
                        }
                        return;
                    }
                case "queue":
                case "que":
                case "q":
                    {
                        if (!string.IsNullOrEmpty(szQueueChatCommand))
                            cmdQueue(player, command, args);
                        return;
                    }
                case "chat":
                    {
                        if (broadcastDefeat)
                        {
                            if (!duelsData.Chat.Contains(player.UserIDString))
                                duelsData.Chat.Add(player.UserIDString);
                            else
                                duelsData.Chat.Remove(player.UserIDString);

                            Message(player, msg(duelsData.Chat.Contains(player.UserIDString) ? "DuelChatOff" : "DuelChatOn", player.UserIDString));
                        }
                        else
                        {
                            if (!duelsData.ChatEx.Contains(player.UserIDString))
                                duelsData.ChatEx.Add(player.UserIDString);
                            else
                                duelsData.ChatEx.Remove(player.UserIDString);

                            Message(player, msg(duelsData.ChatEx.Contains(player.UserIDString) ? "DuelChatOn" : "DuelChatOff", player.UserIDString));
                        }
                        return;
                    }
                case "kit":
                    {
                        string kits = string.Join(", ", VerifiedKits.ToArray());

                        if (args.Length == 2 && !string.IsNullOrEmpty(kits))
                        {
                            string kit = GetVerifiedKit(args[1]);

                            if (!string.IsNullOrEmpty(kit))
                            {
                                duelsData.CustomKits[player.UserIDString] = kit;
                                Message(player, msg("KitSet", player.UserIDString, kit));
                            }
                            else
                                Message(player, msg("KitDoesntExist", player.UserIDString, args[1]));

                            return;
                        }

                        if (duelsData.CustomKits.ContainsKey(player.UserIDString))
                        {
                            duelsData.CustomKits.Remove(player.UserIDString);
                            Message(player, msg("ResetKit", player.UserIDString));
                        }

                        Message(player, string.IsNullOrEmpty(kits) ? msg("KitsNotConfigured", player.UserIDString) : "Kits: " + kits);
                        return;
                    }
                case "allow":
                    {
                        if (!duelsData.Allowed.Contains(player.UserIDString))
                        {
                            duelsData.Allowed.Add(player.UserIDString);
                            Message(player, msg("PlayerRequestsOn", player.UserIDString));
                            return;
                        }

                        duelsData.Allowed.Remove(player.UserIDString);
                        Message(player, msg("PlayerRequestsOff", player.UserIDString));
                        RemoveRequests(player);
                        return;
                    }
                case "block":
                    {
                        if (args.Length >= 2)
                        {
                            var target = BasePlayer.Find(args[1]);

                            if (IsNull(target))
                            {
                                Message(player, msg("PlayerNotFound", player.UserIDString, args[1]));
                                return;
                            }

                            if (!duelsData.BlockedUsers.ContainsKey(player.UserIDString))
                            {
                                duelsData.BlockedUsers.Add(player.UserIDString, new List<string>());
                            }
                            else if (duelsData.BlockedUsers[player.UserIDString].Contains(target.UserIDString))
                            {
                                duelsData.BlockedUsers[player.UserIDString].Remove(target.UserIDString);

                                if (duelsData.BlockedUsers[player.UserIDString].Count == 0)
                                    duelsData.BlockedUsers.Remove(player.UserIDString);

                                Message(player, msg("UnblockedRequestsFrom", player.UserIDString, target.displayName));
                                return;
                            }

                            duelsData.BlockedUsers[player.UserIDString].Add(target.UserIDString);
                            Message(player, msg("BlockedRequestsFrom", player.UserIDString, target.displayName));
                            return;
                        }

                        if (duelsData.Allowed.Contains(player.UserIDString))
                        {
                            duelsData.Allowed.Remove(player.UserIDString);
                            Message(player, msg("PlayerRequestsOff", player.UserIDString));
                            RemoveRequests(player);
                            return;
                        }

                        Message(player, msg("AlreadyBlocked", player.UserIDString));
                        return;
                    }
                case "bet":
                    {
                        if (!allowBets)
                        {
                            Message(player, "Betting is disabled.");
                            break;
                        }

                        if (duelingBets.Count == 0)
                        {
                            Message(player, msg("NoBetsConfigured", player.UserIDString));
                            return;
                        }

                        if (args.Length == 2)
                        {
                            switch (args[1].ToLower())
                            {
                                case "refundall":
                                    {
                                        if (player.IsAdmin)
                                        {
                                            if (duelsData.Bets.Count == 0)
                                            {
                                                Message(player, msg("NoBetsToRefund", player.UserIDString));
                                                return;
                                            }

                                            foreach (var kvp in duelsData.Bets.ToList())
                                            {
                                                var target = BasePlayer.Find(kvp.Key);
                                                if (target == null) continue;

                                                Item item = ItemManager.CreateByItemID(kvp.Value.itemid, kvp.Value.amount);

                                                if (item == null)
                                                    continue;

                                                if (!item.MoveToContainer(target.inventory.containerMain, -1, true) && !item.MoveToContainer(target.inventory.containerBelt, -1, true))
                                                {
                                                    item.Remove(0.01f);
                                                    continue;
                                                }

                                                Message(target, msg("RefundAllPlayerNotice", target.UserIDString, item.info.displayName.translated, item.amount));
                                                Message(player, msg("RefundAllAdminNotice", player.UserIDString, target.displayName, target.UserIDString, item.info.displayName.english, item.amount));
                                                duelsData.Bets.Remove(kvp.Key);
                                            }

                                            if (duelsData.Bets.Count > 0) Message(player, msg("BetsRemaining", player.UserIDString, duelsData.Bets.Count));
                                            else Message(player, msg("AllBetsRefunded", player.UserIDString));
                                            SaveData();
                                            return;
                                        }

                                        break;
                                    }
                                case "forfeit":
                                    {
                                        if (allowBetRefund) // prevent operator error ;)
                                        {
                                            cmdDuel(player, command, new[] { "bet", "refund" });
                                            return;
                                        }

                                        if (!allowBetForfeit)
                                        {
                                            Message(player, msg("CannotForfeit", player.UserIDString));
                                            return;
                                        }

                                        if (duelsData.Bets.ContainsKey(player.UserIDString))
                                        {
                                            if (dataRequests.ContainsKey(player.UserIDString) || dataRequests.ContainsValue(player.UserIDString))
                                            {
                                                Message(player, msg("CannotForfeitRequestDuel", player.UserIDString));
                                                return;
                                            }

                                            if (dataDuelists.ContainsKey(player.UserIDString))
                                            {
                                                Message(player, msg("CannotForfeitInDuel", player.UserIDString));
                                                return;
                                            }

                                            duelsData.Bets.Remove(player.UserIDString);
                                            Message(player, msg("BetForfeit", player.UserIDString));
                                            SaveData();
                                        }
                                        else
                                            Message(player, msg("NoBetToForfeit", player.UserIDString));

                                        return;
                                    }
                                case "cancel":
                                case "refund":
                                    {
                                        if (!allowBetRefund && !player.IsAdmin)
                                        {
                                            Message(player, msg("CannotRefund", player.UserIDString));
                                            return;
                                        }

                                        if (duelsData.Bets.ContainsKey(player.UserIDString))
                                        {
                                            if (dataRequests.ContainsKey(player.UserIDString) || dataRequests.ContainsValue(player.UserIDString))
                                            {
                                                Message(player, msg("CannotRefundRequestDuel", player.UserIDString));
                                                return;
                                            }

                                            if (dataDuelists.ContainsKey(player.UserIDString))
                                            {
                                                Message(player, msg("CannotRefundInDuel", player.UserIDString));
                                                return;
                                            }

                                            var bet = duelsData.Bets[player.UserIDString];

                                            Item item = ItemManager.CreateByItemID(bet.itemid, bet.amount);

                                            if (!item.MoveToContainer(player.inventory.containerMain, -1, true))
                                            {
                                                if (!item.MoveToContainer(player.inventory.containerBelt, -1, true))
                                                {
                                                    var position = player.transform.position;
                                                    item.Drop(position + new Vector3(0f, 1f, 0f) + position / 2f, (position + new Vector3(0f, 0.2f, 0f)) * 8f); // Credit: Slack comment by @visagalis
                                                }
                                            }

                                            duelsData.Bets.Remove(player.UserIDString);
                                            Message(player, msg("BetRefunded", player.UserIDString));
                                            SaveData();
                                        }
                                        else
                                            Message(player, msg("NoBetToRefund", player.UserIDString));

                                        return;
                                    }
                                default:
                                    break;
                            }
                        }

                        if (duelsData.Bets.ContainsKey(player.UserIDString))
                        {
                            var bet = duelsData.Bets[player.UserIDString];

                            Message(player, msg("AlreadyBetting", player.UserIDString, bet.trigger, bet.amount));

                            if (allowBetRefund)
                                Message(player, msg("ToRefundUse", player.UserIDString, szDuelChatCommand));
                            else if (allowBetForfeit)
                                Message(player, msg("ToForfeitUse", player.UserIDString, szDuelChatCommand));

                            return;
                        }

                        if (args.Length < 3)
                        {
                            Message(player, msg("AvailableBets", player.UserIDString));

                            foreach (var betInfo in duelingBets)
                                Message(player, string.Format("{0} (max: {1})", betInfo.trigger, betInfo.max));

                            Message(player, msg("BetSyntax", player.UserIDString, szDuelChatCommand));
                            return;
                        }

                        int betAmount;
                        if (!int.TryParse(args[2], out betAmount))
                        {
                            Message(player, msg("InvalidNumber", player.UserIDString, args[2]));
                            return;
                        }

                        if (betAmount > 500 && betAmount % 500 != 0)
                        {
                            Message(player, msg("MultiplesOnly", player.UserIDString));
                            return;
                        }

                        foreach (var betInfo in duelingBets)
                        {
                            if (betInfo.trigger.ToLower() == args[1].ToLower())
                            {
                                CreateBet(player, betAmount, betInfo);
                                return;
                            }
                        }

                        Message(player, msg("InvalidBet", player.UserIDString, args[1]));
                        return;
                    }
                case "accept":
                case "a":
                case "y":
                case "yes":
                    {
                        if (!autoAllowAll && !duelsData.Allowed.Contains(player.UserIDString))
                        {
                            Message(player, msg("MustAllowDuels", player.UserIDString, szDuelChatCommand));
                            return;
                        }

                        if (InEvent(player))
                        {
                            Message(player, msg("AlreadyDueling", player.UserIDString));
                            return;
                        }

                        if (!dataRequests.ContainsValue(player.UserIDString))
                        {
                            Message(player, msg("NoRequestsReceived", player.UserIDString));
                            return;
                        }

                        if (!IsNewman(player))
                        {
                            Message(player, msg("MustBeNaked", player.UserIDString));
                            return;
                        }

                        BasePlayer target = null;

                        foreach (var kvp in dataRequests)
                        {
                            if (kvp.Value == player.UserIDString)
                            {
                                target = BasePlayer.Find(kvp.Key);

                                if (target == null || !target.IsConnected)
                                {
                                    Message(player, string.Format("DuelCancelledFor", player.UserIDString, GetDisplayName(kvp.Key)));
                                    dataRequests.Remove(kvp.Key);
                                    return;
                                }

                                break;
                            }
                        }

                        if (!IsNewman(target))
                        {
                            Message(player, msg("TargetMustBeNaked", player.UserIDString));
                            Message(target, msg("MustBeNaked", target.UserIDString));
                            return;
                        }

                        duelsData.Restricted.Remove(player.UserIDString);
                        duelsData.Restricted.Remove(target.UserIDString);

                        if (!SelectZone(player, target))
                        {
                            Message(player, msg("AllZonesFull", player.UserIDString, duelingZones.Count, playersPerZone));
                            Message(target, msg("AllZonesFull", target.UserIDString, duelingZones.Count, playersPerZone));
                        }

                        return;
                    }
                case "cancel":
                case "decline":
                    {
                        if (IsDueling(player))
                            return;

                        if (!autoAllowAll && !duelsData.Allowed.Contains(player.UserIDString))
                        {
                            Message(player, msg("MustAllowDuels", player.UserIDString, szDuelChatCommand));
                            return;
                        }

                        var entry = dataRequests.FirstOrDefault(kvp => dataRequests.ContainsKey(player.UserIDString) ? kvp.Key == player.UserIDString : kvp.Value == player.UserIDString);

                        if (!string.IsNullOrEmpty(entry.Key))
                        {
                            var target = BasePlayer.Find(entry.Key) ?? BasePlayer.Find(entry.Value);

                            if (target != null)
                                Message(target, msg("DuelCancelledWith", target.UserIDString, player.displayName));

                            Message(player, msg("DuelCancelComplete", player.UserIDString));
                            dataRequests.Remove(entry.Key);
                            return;
                        }

                        Message(player, msg("NoPendingRequests", player.UserIDString));
                        return;
                    }
                default:
                    {
                        if (!autoAllowAll && !duelsData.Allowed.Contains(player.UserIDString))
                        {
                            Message(player, msg("MustAllowDuels", player.UserIDString, szDuelChatCommand));
                            return;
                        }

                        if (IsDueling(player))
                        {
                            Message(player, msg("AlreadyDueling", player.UserIDString));
                            return;
                        }

                        if (duelsData.Restricted.Contains(player.UserIDString) && !player.IsAdmin)
                        {
                            Message(player, msg("MustWaitToRequestAgain", player.UserIDString, 1));
                            return;
                        }

                        if (!IsNewman(player))
                        {
                            Message(player, msg("MustBeNaked", player.UserIDString));
                            return;
                        }

                        var target = BasePlayer.Find(args[0]);

                        if (target == null || target == player) //if (target == null || (target == player && target.userID != 76561198212544308))
                        {
                            Message(player, msg("PlayerNotFound", player.UserIDString, args[0]));
                            return;
                        }

                        if (duelsData.BlockedUsers.ContainsKey(target.UserIDString) && duelsData.BlockedUsers[target.UserIDString].Contains(player.UserIDString))
                        {
                            Message(player, msg("CannotRequestThisPlayer", player.UserIDString));
                            return;
                        }

                        if (IsDueling(target))
                        {
                            Message(player, msg("TargetAlreadyDueling", player.UserIDString, target.displayName));
                            return;
                        }

                        if (!autoAllowAll && !duelsData.Allowed.Contains(target.UserIDString))
                        {
                            Message(player, msg("NotAllowedYet", player.UserIDString, target.displayName, szDuelChatCommand));
                            return;
                        }

                        if (dataRequests.ContainsKey(player.UserIDString))
                        {
                            Message(player, msg("MustWaitForAccept", player.UserIDString, GetDisplayName(dataRequests[player.UserIDString])));
                            return;
                        }

                        if (dataRequests.ContainsValue(target.UserIDString))
                        {
                            Message(player, msg("PendingRequestAlready", player.UserIDString));
                            return;
                        }

                        if (duelsData.Bets.ContainsKey(player.UserIDString) && !duelsData.Bets.ContainsKey(target.UserIDString))
                        {
                            var bet = duelsData.Bets[player.UserIDString];

                            Message(player, msg("TargetHasNoBet", player.UserIDString, target.displayName));
                            Message(player, msg("YourBet", player.UserIDString, bet.trigger, bet.amount));
                            return;
                        }

                        if (duelsData.Bets.ContainsKey(target.UserIDString) && !duelsData.Bets.ContainsKey(player.UserIDString))
                        {
                            var targetBet = duelsData.Bets[target.UserIDString];
                            Message(player, msg("MustHaveSameBet", player.UserIDString, target.displayName, targetBet.trigger, targetBet.amount));
                            return;
                        }

                        if (duelsData.Bets.ContainsKey(player.UserIDString) && duelsData.Bets.ContainsKey(target.UserIDString))
                        {
                            var playerBet = duelsData.Bets[player.UserIDString];
                            var targetBet = duelsData.Bets[target.UserIDString];

                            if (!playerBet.Equals(targetBet))
                            {
                                Message(player, msg("BetsDoNotMatch", player.UserIDString, playerBet.trigger, playerBet.amount, targetBet.trigger, targetBet.amount));
                                return;
                            }
                        }

                        if (args.Length > 1)
                            SetPlayerZone(player, args.Skip(1));

                        dataRequests.Add(player.UserIDString, target.UserIDString);
                        Message(target, msg("DuelRequestReceived", target.UserIDString, player.displayName, szDuelChatCommand));
                        Message(player, msg("DuelRequestSent", player.UserIDString, target.displayName, szDuelChatCommand));

                        if (RemoveFromQueue(player.UserIDString))
                            Message(player, msg("RemovedFromQueueRequest", player.UserIDString));

                        string targetName = target.displayName;
                        string playerId = player.UserIDString;

                        if (!duelsData.Restricted.Contains(playerId))
                            duelsData.Restricted.Add(playerId);

                        timer.In(60f, () =>
                        {
                            duelsData.Restricted.Remove(playerId);

                            if (dataRequests.ContainsKey(playerId))
                            {
                                if (player != null && !IsDueling(player))
                                    Message(player, msg("RequestTimedOut", playerId, targetName));

                                dataRequests.Remove(playerId);
                            }
                        });

                        break;
                    }
            } // end switch
        }

        public DuelingZone GetPlayerZone(BasePlayer player, int size)
        {
            if (playerZones.ContainsKey(player.UserIDString))
            {
                var kvp = duelsData.DuelZones.FirstOrDefault(entry => entry.Value.Equals(playerZones[player.UserIDString], StringComparison.OrdinalIgnoreCase));

                playerZones.Remove(player.UserIDString);

                if (!string.IsNullOrEmpty(kvp.Key))
                {
                    var zone = duelingZones.FirstOrDefault(x => x.Position.ToString() == kvp.Key);

                    if (size > 2)
                        return zone == null || zone.IsLocked || zone.Spawns.Count < (requireTeamSize ? size * 2 : 2) ? null : zone;

                    return zone == null || zone.IsLocked || zone.Spawns.Count < requiredMinSpawns || zone.Spawns.Count > requiredMaxSpawns ? null : zone;
                }
            }

            return null;
        }

        private List<ulong> _times = new List<ulong>();

        public void SetPlayerTime(BasePlayer player, bool set)
        {
            if (!setPlayerTime || !set && !_times.Remove(player.userID))
            {
                return;
            }

            var time = set ? "12" : "-1";

            ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"setenv {player.UserIDString} time {time}");

            if (set) _times.Add(player.userID);
        }

        public bool SetPlayerZone(BasePlayer player, string[] args)
        {
            foreach (string arg in args)
            {
                if (duelsData.DuelZones.Values.Exists(zoneName => zoneName.Equals(arg, StringComparison.OrdinalIgnoreCase)))
                {
                    string zoneName = duelsData.DuelZones.Values.FirstOrDefault(x => x.Equals(arg, StringComparison.OrdinalIgnoreCase));
                    Message(player, msg("ZoneSet", player.UserIDString, zoneName));
                    playerZones[player.UserIDString] = zoneName;
                    return true;
                }
            }

            return false;
        }

        public void SetupTeams(BasePlayer player, BasePlayer target)
        {
            if (!IsNewman(player))
            {
                Message(player, msg("MustBeNaked", player.UserIDString));
                Message(target, msg("DuelMustBeNaked", target.UserIDString, player.displayName));
                return;
            }

            if (!IsNewman(target))
            {
                Message(target, msg("MustBeNaked", target.UserIDString));
                Message(player, msg("DuelMustBeNaked", player.UserIDString, target.displayName));
                return;
            }

            RemoveFromQueue(player.UserIDString);
            RemoveFromQueue(target.UserIDString);

            var match = new GoodVersusEvilMatch(this);
            match.Setup(player, target);

            SubscribeHooks(true);
        }

        private void ResetTemporaryData() // keep our datafile cleaned up by removing entries which are temporary
        {
            if (duelsData == null)
                duelsData = new StoredData();

            dataDuelists.Clear();
            dataRequests.Clear();
            dataImmunity.Clear();
            dataImmunitySpawns.Clear();
            duelsData.Restricted.Clear();
            dataDeath.Clear();
            duelsData.Queued.Clear();
            duelsData.Homes.Clear();
            duelsData.Kits.Clear();
            SaveData();
        }

        public DuelingZone RemoveDuelist(string playerId)
        {
            foreach (var zone in duelingZones)
            {
                if (zone.HasPlayer(playerId))
                {
                    zone.RemovePlayer(playerId);
                    return zone;
                }
            }

            return null;
        }

        public void ResetDuelist(string targetId, bool removeHome = true) // remove a dueler from the datafile
        {
            duelsData.Kits.Remove(targetId);
            duelsData.Restricted.Remove(targetId);
            dataImmunity.Remove(targetId);
            dataImmunitySpawns.Remove(targetId);
            dataDuelists.Remove(targetId);
            dataRequests.Remove(targetId);
            dataDeath.Remove(targetId);

            if (removeHome)
                duelsData.Homes.Remove(targetId);

            if (duelingZones.Count > 0)
                RemoveDuelist(targetId);

            RemoveFromQueue(targetId);
        }

        private void RemoveZeroStats() // someone enabled duels but never joined one. remove them to keep the datafile cleaned up
        {
            foreach (string targetId in duelsData.Allowed.ToList())
            {
                if (!duelsData.Losses.ContainsKey(targetId) && !duelsData.Victories.ContainsKey(targetId)) // no permanent stats
                {
                    ResetDuelist(targetId);
                    duelsData.Allowed.Remove(targetId);
                }
            }
        }

        public void SetupZoneManager()
        {
            var zoneIds = ZoneManager?.Call("GetZoneIDs");

            if (zoneIds != null && zoneIds is string[])
            {
                foreach (var zoneId in (string[])zoneIds)
                {
                    var zoneLoc = ZoneManager?.Call("GetZoneLocation", zoneId);

                    if (zoneLoc is Vector3 && (Vector3)zoneLoc != Vector3.zero)
                    {
                        var position = (Vector3)zoneLoc;
                        var radius = ZoneManager?.Call("GetZoneRadius", zoneId);
                        float distance = 0f;

                        if (radius is float && (float)radius > 0f)
                        {
                            distance = (float)radius;
                        }
                        else
                        {
                            var zoneSize = ZoneManager?.Call("GetZoneSize", zoneId);

                            if (zoneSize is Vector3 && (Vector3)zoneSize != Vector3.zero)
                            {
                                var size = (Vector3)zoneSize;
                                distance = Mathf.Max(size.x, size.y);
                            }
                        }

                        if (distance > 0f)
                        {
                            distance += zoneRadius + 5f;
                            managedZones[position] = distance;
                        }
                    }
                }
            }
        }

        public void SetupZones()
        {
            if (duelsData.ZoneIds.Count > 0)
            {
                foreach (string id in duelsData.ZoneIds)
                {
                    duelsData.DuelZones[id] = GetZoneName();
                }

                duelsData.ZoneIds.Clear();
                SaveData();
            }

            if (duelsData.DuelZones.Count > zoneAmount) // zoneAmount was changed in the config file so remove existing zones until we're at the new cap
            {
                int removed = 0;

                do
                {
                    string zoneId = duelsData.DuelZones.FirstOrDefault().Key;
                    var zonePos = zoneId.ToVector3();

                    if (spAutoRemove && duelsData.Spawns.Count > 0)
                        foreach (string spawn in duelsData.Spawns.ToList())
                            if (Vector3.Distance(spawn.ToVector3(), zonePos) <= zoneRadius)
                                duelsData.Spawns.Remove(spawn);

                    duelsData.AutoGeneratedSpawns.Remove(zoneId);
                    duelsData.DuelZones.Remove(zoneId);
                    removed += RemoveZoneWalls(GetOwnerId(zoneId));
                } while (duelsData.DuelZones.Count > zoneAmount);

                if (removed > 0)
                    Puts(msg("RemovedXWallsCustom", null, removed));
            }

            var entities = autoSetup && (duelsData.DuelZones.Count < zoneAmount || duelsData.DuelZones.Count > 0) ? GetWallEntities() : null; // don't cache if we don't need to

            foreach (var entry in duelsData.DuelZones) // create all zones that don't already exist
                SetupDuelZone(entry.Key.ToVector3(), entities, entry.Value);

            if (autoSetup && duelsData.DuelZones.Count < zoneAmount) // create each dueling zone that is missing. if this fails then console will be notified
            {
                int attempts = Math.Max(zoneAmount, 5); // 0.1.10 fix - infinite loop fix for when zone radius is too large to fit on the map
                int created = 0;

                do
                {
                    if (SetupDuelZone(entities, GetZoneName()) != Vector3.zero)
                        created++;
                } while (duelsData.DuelZones.Count < zoneAmount && --attempts > 0);

                if (attempts <= 0)
                {
                    if (created > 0)
                        Puts(msg("SupportCreated", null, created));
                    else
                        Puts(msg("SupportInvalidConfig"));
                }
            }

            if (duelingZones.Count > 0)
                Puts(msg("ZonesSetup", null, duelingZones.Count));
        }

        public Vector3 SetupDuelZone(List<BaseEntity> entities, string zoneName) // starts the process of creating a new or existing zone and then setting up it's own spawn points around the circumference of the zone
        {
            var zonePos = FindDuelingZone(); // a complex process to search the map for a suitable area

            if (zonePos == Vector3.zero) // unfortunately we weren't able to find a location. this is likely due to an extremely high entity count. just try again.
                return Vector3.zero;

            SetupDuelZone(zonePos, entities, zoneName);
            return zonePos;
        }

        public DuelingZone SetupDuelZone(Vector3 zonePos, List<BaseEntity> entities, string zoneName)
        {
            if (!duelsData.DuelZones.ContainsKey(zonePos.ToString()))
                duelsData.DuelZones.Add(zonePos.ToString(), zoneName);

            var newZone = new GameObject().AddComponent<DuelingZone>();

            newZone.Setup(zonePos);
            duelingZones.Add(newZone);

            if (duelingZones.Count == 1)
            {
                if (blockSpawning) Subscribe(nameof(OnPlayerRespawned));
                Subscribe(nameof(OnEntityTakeDamage));
                Subscribe(nameof(OnEntitySpawned));
                Subscribe(nameof(CanBuild));
            }

            CreateZoneWalls(newZone.Position, zoneRadius, zoneUseWoodenWalls ? hewwPrefab : heswPrefab, entities);
            return newZone;
        }

        public List<BaseEntity> GetWallEntities()
        {
            var entities = new List<BaseEntity>();

            foreach (var e in BaseNetworkable.serverEntities)
            {
                if (e != null && e.ShortPrefabName.Contains("wall.external.high"))
                {
                    var entity = e as BaseEntity;

                    if (entity != null)
                    {
                        entities.Add(entity);
                    }
                }
            }

            return entities;
        }

        public int RemoveZoneWalls(ulong ownerId)
        {
            int removed = 0;

            foreach (var entity in GetWallEntities().ToList())
            {
                if (entity.OwnerID == ownerId)
                {
                    entity.Kill();
                    removed++;
                }
            }

            return removed;
        }

        public bool ZoneWallsExist(ulong ownerId, List<BaseEntity> entities)
        {
            if (entities == null || entities.Count < 3)
                entities = GetWallEntities();

            return entities.Exists(entity => entity.OwnerID == ownerId);
        }

        public void CreateZoneWalls(Vector3 center, float zoneRadius, string prefab, List<BaseEntity> entities, BasePlayer player = null)
        {
            if (!useZoneWalls)
                return;

            var tick = DateTime.Now;
            ulong ownerId = GetOwnerId(center.ToString());

            if (ZoneWallsExist(ownerId, entities))
                return;

            float maxHeight = -200f;
            float minHeight = 200f;
            int spawned = 0;
            int raycasts = Mathf.CeilToInt(360 / zoneRadius * 0.1375f);

            foreach (var position in GetCircumferencePositions(center, zoneRadius, raycasts, 0f)) // get our positions and perform the calculations for the highest and lowest points of terrain
            {
                RaycastHit hit;
                if (Physics.Raycast(new Vector3(position.x, position.y + 200f, position.z), Vector3.down, out hit, Mathf.Infinity, wallMask))
                {
                    maxHeight = Mathf.Max(hit.point.y, maxHeight); // calculate the highest point of terrain
                    minHeight = Mathf.Min(hit.point.y, minHeight); // calculate the lowest point of terrain
                    center.y = minHeight; // adjust the spawn point of our walls to that of the lowest point of terrain
                }
            }

            float gap = prefab == heswPrefab ? 0.3f : 0.5f; // the distance used so that each wall fits closer to the other so players cannot throw items between the walls
            int stacks = Mathf.CeilToInt((maxHeight - minHeight) / 6f) + extraWallStacks; // get the amount of walls to stack onto each other to go above the highest point
            float next = 360 / zoneRadius - gap; // the distance apart each wall will be from the other

            for (int i = 0; i < stacks; i++) // create our loop to spawn each stack
            {
                foreach (var position in GetCircumferencePositions(center, zoneRadius, next, center.y)) // get a list positions where each positions difference is the width of a high external stone wall. specify the height since we've already calculated what's required
                {
                    float groundHeight = TerrainMeta.HeightMap.GetHeight(new Vector3(position.x, position.y + 6f, position.z));

                    if (groundHeight > position.y + 9f) // 0.1.13 improved distance check underground
                        continue;

                    if (useLeastAmount && position.y - groundHeight > 6f + extraWallStacks * 6f)
                        continue;

                    var entity = GameManager.server.CreateEntity(prefab, position, default(Quaternion), false);

                    if (entity != null)
                    {
                        entity.OwnerID = ownerId; // set a unique identifier so the walls can be easily removed later
                        entity.transform.LookAt(center, Vector3.up); // have each wall look at the center of the zone
                        entity.Spawn(); // spawn into the game
                        entity.gameObject.SetActive(true); // 0.1.16: fix for animals and explosives passing through walls. set it active after it spawns otherwise AntiHack will throw ProjectileHack: Line of sight warnings each time the entity is hit
                        spawned++; // our counter
                    }
                    else
                        return; // invalid prefab, return or cause massive server lag

                    if (stacks == i - 1)
                    {
                        RaycastHit hit;
                        if (Physics.Raycast(new Vector3(position.x, position.y + 6f, position.z), Vector3.down, out hit, 12f, worldMask))
                            stacks++; // 0.1.16 fix where rocks could allow a boost in or out of the top of a zone
                    }
                }

                center.y += 6f; // increase the positions height by one high external stone wall's height
            }

            if (player == null)
                Puts(msg("GeneratedWalls", null, spawned, stacks, FormatPosition(center), (DateTime.Now - tick).TotalSeconds));
            else
                Message(player, msg("GeneratedWalls", player.UserIDString, spawned, stacks, FormatPosition(center), (DateTime.Now - tick).TotalSeconds));

            Subscribe(nameof(OnEntityTakeDamage));
        }

        public void EjectPlayers(DuelingZone zone)
        {
            foreach (var player in zone.Players)
            {
                EjectPlayer(player);
            }
        }

        public void EjectPlayer(BasePlayer player)
        {
            if (player == null)
                return;

            player.inventory.Strip();
            ResetDuelist(player.UserIDString, false);
            SendHome(player);
        }

        public void RemoveDuelZone(DuelingZone zone)
        {
            string uid = zone.Position.ToString();

            foreach (string playerId in spectators.ToList())
            {
                var player = BasePlayer.Find(playerId);

                if (player == null)
                {
                    spectators.Remove(playerId);
                    continue;
                }

                if (zone.Distance(player.transform.position) <= zoneRadius)
                {
                    EndSpectate(player);
                    SendHome(player);
                }
            }

            var match = tdmMatches.FirstOrDefault(x => x.Zone != null && x.Zone == zone);

            if (match != null)
                match.End();

            if (spAutoRemove && duelsData.Spawns.Count > 0)
                foreach (var spawn in zone.Spawns)
                    duelsData.Spawns.Remove(spawn.ToString());

            duelsData.DuelZones.Remove(uid);
            duelsData.AutoGeneratedSpawns.Remove(uid);
            RemoveEntities(zone);
            RemoveZoneWalls(GetOwnerId(uid));
            zone.Kill();

            if (duelingZones.Count == 0 && tdmMatches.Count == 0)
            {
                SubscribeHooks(false);
                CheckZoneHooks();
            }
        }

        public void RemoveEntities(ulong playerId)
        {
            if (duelEntities.ContainsKey(playerId))
            {
                foreach (var e in duelEntities[playerId].ToList())
                    e.SafelyKill();

                duelEntities.Remove(playerId);
            }
        }

        public void RemoveEntities(DuelingZone zone)
        {
            foreach (var entry in duelEntities.ToList())
            {
                foreach (var entity in entry.Value.ToList())
                {
                    if (entity.IsKilled())
                    {
                        duelEntities[entry.Key].Remove(entity);
                        continue;
                    }

                    if (zone.Distance(entity.transform.position) <= zoneRadius + 1f)
                    {
                        duelEntities[entry.Key].Remove(entity);
                        entity.Kill();
                    }
                }
            }
        }

        public DuelingZone GetDuelZone(Vector3 startPos, float offset = 1f)
        {
            return duelingZones.FirstOrDefault(zone => zone.Distance(startPos) <= zoneRadius + offset);
        }

        public void SendHome(BasePlayer player) // send a player home to the saved location that they joined from
        {
            if (player != null && duelsData.Homes.ContainsKey(player.UserIDString))
            {
                if (player.IsDead() && !player.IsConnected && !respawnDeadDisconnect)
                {
                    duelsData.Homes.Remove(player.UserIDString);
                    return;
                }

                if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
                {
                    timer.Once(2f, () => SendHome(player));
                    return;
                }

                RemoveEntities(player.userID);
                var homePos = duelsData.Homes[player.UserIDString].ToVector3();

                if (DuelTerritory(homePos) && !player.IsAdmin)
                {
                    var bags = SleepingBag.FindForPlayer(player.userID, true).ToList();

                    if (bags.Count > 0)
                    {
                        bags.Sort((x, y) => x.net.ID.Value.CompareTo(y.net.ID.Value));
                        homePos = bags[0].transform.position;
                        homePos.y += 0.25f;
                    }
                    else
                    {
                        homePos = ServerMgr.FindSpawnPoint().pos;
                    }
                }

                if (player.IsDead())
                {
                    if (sendDeadHome)
                        player.RespawnAt(homePos, default(Quaternion));
                    else player.Respawn();
                }
                else
                {
                    if (!sendDeadHome)
                    {
                        player.LifeStoryEnd();
                        player.Respawn();
                    }
                    else Teleport(player, homePos);
                }

                if (playerHealth > 0f)
                    player.health = playerHealth;

                GiveRespawnLoot(player);
                duelsData.Homes.Remove(player.UserIDString);

                if (guiAutoEnable || createUI.Contains(player.UserIDString))
                    OnPlayerConnected(player);

                if (readyUiList.Contains(player.UserIDString))
                    ToggleReadyUI(player);
            }
        }

        public void GiveRespawnLoot(BasePlayer player)
        {
            if (respawnLoot.Count > 0)
            {
                player.inventory.Strip();

                foreach (var entry in respawnLoot)
                {
                    Item item = ItemManager.CreateByName(entry.shortname, entry.amount, entry.skin);

                    if (item == null)
                        continue;

                    var container = entry.container == "wear" ? player.inventory.containerWear : entry.container == "belt" ? player.inventory.containerBelt : player.inventory.containerMain;

                    if (!item.MoveToContainer(container, entry.slot))
                    {
                        item.Remove(0f);
                    }
                }
            }
            else if (!string.IsNullOrEmpty(autoKitName) && Kits.CanCall() && IsKit(autoKitName))
            {
                player.inventory.Strip();
                Kits.Call("GiveKit", player, autoKitName);
            }
            else plugins.Find("Loadoutless")?.Call("OnPlayerRespawned", player);
        }

        private void UpdateStability()
        {
            if (noStability)
            {
                Subscribe(nameof(OnEntitySpawned));

                foreach (BuildingBlock block in BaseNetworkable.serverEntities.OfType<BuildingBlock>().Where(e => DuelTerritory(e.transform.position)).ToList())
                {
                    if (block.grounded)
                        continue;

                    if (block.OwnerID == 0 || permission.UserHasGroup(block.OwnerID.ToString(), "admin"))
                        block.grounded = true;
                }
            }
        }

        private void CheckZoneHooks(bool message = false)
        {
            if (respawnWalls && duelingZones.Count > 0)
            {
                Subscribe(nameof(OnEntityDeath));
                Subscribe(nameof(OnEntityKill));
            }
        }

        private void CheckDuelistMortality()
        {
            eventTimer = timer.Once(0.5f, CheckDuelistMortality);

            if (dataImmunity.Count > 0) // each player that spawns into a dueling zone is given immunity for X seconds. here we'll keep track of this and remove their immunities
            {
                var timeStamp = TimeStamp();

                foreach (var kvp in dataImmunity.ToList())
                {
                    var player = BasePlayer.Find(kvp.Key);
                    long time = kvp.Value - timeStamp;

                    if (time <= 0)
                    {
                        dataImmunity.Remove(kvp.Key);
                        dataImmunitySpawns.Remove(kvp.Key);

                        if (IsNotConnected(player))
                            continue;

                        CuiHelper.DestroyUi(player, "DuelistUI_Countdown");
                        Message(player, msg("ImmunityFaded", player.UserIDString));
                    }
                    else if (player != null && player.IsConnected)
                    {
                        if (noMovement && dataImmunitySpawns.ContainsKey(player.UserIDString))
                        {
                            var dest = dataImmunitySpawns[player.UserIDString];
                            player.Teleport(dest);
                        }

                        CreateCountdownUI(player, time.ToString());
                    }
                }
            }

            if (dataDeath.Count > 0) // keep track of how long the match has been going on for, and if it's been too long then kill the player off.
            {
                var timeStamp = TimeStamp();

                foreach (var kvp in dataDeath.ToList())
                {
                    if (kvp.Value - timeStamp <= 0)
                    {
                        var target = BasePlayer.Find(kvp.Key);
                        dataDeath.Remove(kvp.Key);

                        if (IsNotConnected(target) || (!IsDueling(target) && !InDeathmatch(target)))
                            continue;

                        target.inventory.Strip();
                        OnEntityDeath(target, null);
                    }
                }
            }

            UpdateMatchUI();
        }

        public void SubscribeHooks(bool flag) // we're using lots of temporary and permanent hooks so we'll turn off the temporary hooks when the plugin is loaded, and unsubscribe to others inside of their hooks when they're no longer in use
        {
            if (!flag)
            {
                Unsubscribe(nameof(OnPlayerDisconnected));
                //Unsubscribe(nameof(CanNetworkTo));
                Unsubscribe(nameof(OnItemDropped));
                Unsubscribe(nameof(OnPlayerSleepEnded));
                Unsubscribe(nameof(OnCreateWorldProjectile));
                Unsubscribe(nameof(OnLootEntity));
                Unsubscribe(nameof(OnPlayerRespawned));
                Unsubscribe(nameof(OnEntityTakeDamage));
                Unsubscribe(nameof(OnEntitySpawned));
                Unsubscribe(nameof(CanBuild));
                Unsubscribe(nameof(OnPlayerHealthChange));
                Unsubscribe(nameof(OnEntityDeath));
                Unsubscribe(nameof(OnEntityKill));
                //Unsubscribe(nameof(OnPlayerCommand));
                Unsubscribe(nameof(OnPlayerConnected));
                Unsubscribe(nameof(OnRestoreUponDeath));
                return;
            }

            Subscribe(nameof(OnPlayerDisconnected));
            Subscribe(nameof(OnItemDropped));
            Subscribe(nameof(OnPlayerSleepEnded));
            Subscribe(nameof(OnCreateWorldProjectile));
            Subscribe(nameof(OnLootEntity));
            Subscribe(nameof(OnEntitySpawned));
            Subscribe(nameof(OnRestoreUponDeath));

            if (!allowPlayerDeaths)
                Subscribe(nameof(OnPlayerHealthChange));

            Subscribe(nameof(OnEntityTakeDamage));
            Subscribe(nameof(OnEntityDeath));

            if (useBlacklistCommands || useWhitelistCommands)
            {
                Subscribe(nameof(OnPlayerCommand));
            }

            if (respawnWalls)
                Subscribe(nameof(OnEntityKill));
        }

        // Helper methods which are essential for the plugin to function. Do not modify these.

        [HookMethod("DuelistTerritory")]
        public bool DuelistTerritory(Vector3 position) // API
        {
            return DuelTerritory(position);
        }

        public bool DuelTerritory(Vector3 position, float offset = 5f) // 0.1.21: arena can be inside of the zone at any height
        {
            return duelingZones.Exists(zone => Vector3Ex.Distance2D(zone.Position, position) <= zoneRadius + offset);
        }

        public ulong GetOwnerId(string uid)
        {
            return Convert.ToUInt64(Math.Abs(uid.GetHashCode()));
        }

        [HookMethod("inEvent")]
        public bool inEvent(BasePlayer player)
        {
            return InEvent(player);
        }

        public bool InEvent(BasePlayer player)
        {
            return player != null && (dataDuelists.ContainsKey(player.UserIDString) || tdmMatches.Exists(match => match.GetTeam(player) != Team.None));
        }

        public bool IsDueling(BasePlayer player)
        {
            return player != null && duelsData != null && duelingZones.Count > 0 && player != null && dataDuelists.ContainsKey(player.UserIDString) && DuelTerritory(player.transform.position);
        }

        public bool InDeathmatch(BasePlayer player)
        {
            return player != null && tdmMatches.Exists(team => team.GetTeam(player) != Team.None) && DuelTerritory(player.transform.position);
        }

        public bool IsSpectator(BasePlayer player)
        {
            return player != null && spectators.Contains(player.UserIDString) && DuelTerritory(player.transform.position);
        }

        public bool IsEventBanned(string targetId)
        {
            return duelsData.Bans.ContainsKey(targetId);
        }

        public static long TimeStamp() => (DateTime.Now.Ticks - DateTime.Parse("01/01/1970 00:00:00").Ticks) / 10000000;

        public string GetDisplayName(string targetId)
        {
            return covalence.Players.FindPlayerById(targetId)?.Name ?? targetId;
        }

        public void Log(string file, string message, bool timestamp = false)
        {
            LogToFile(file, $"[{DateTime.Now}] {message}", this, timestamp);
        }

        public GoodVersusEvilMatch GetMatch(BasePlayer player)
        {
            return tdmMatches.FirstOrDefault(team => team.GetTeam(player) != Team.None);
        }

        public bool InMatch(BasePlayer target)
        {
            return tdmMatches.Exists(team => team.GetTeam(target) != Team.None);
        }

        public bool IsOnConstruction(Vector3 position)
        {
            position.y += 1f;
            RaycastHit hit;

            return Physics.Raycast(position, Vector3.down, out hit, 1.5f, constructionMask) && hit.GetEntity() != null;
        }

        public bool Teleport(BasePlayer player, Vector3 destination)
        {
            if (player == null || destination == Vector3.zero) // don't send a player to their death. this should never happen
                return false;

            player.Invoke(player.EndLooting, 0.01f);

            if (DuelTerritory(destination))
            {
                var rematch = rematches.FirstOrDefault(x => x.HasPlayer(player));

                if (rematch != null)
                    rematches.Remove(rematch);

                SetPlayerTime(player, true);
            }

            if (player.IsWounded())
                player.StopWounded();

            player.metabolism.bleeding.value = 0;

            if (playerHealth > 0f && player.health < playerHealth)
                player.health = playerHealth;

            if (player.IsConnected)
                player.StartSleeping();

            player.Teleport(destination);

            if (player.IsConnected && (Vector3.Distance(player.transform.position, destination) > 50f || !DuelTerritory(destination))) // 1.1.2 reduced from 150 to 100
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
                player.ClientRPCPlayer(null, player, "StartLoading");
                player.UpdateNetworkGroup();
                player.SendEntityUpdate();
            }

            player.SendNetworkUpdateImmediate(false);

            if (LustyMap.CanCall())
            {
                LustyMap?.Call(DuelTerritory(destination) ? "DisableMaps" : "EnableMaps", player);
            }

            return true;
        }

        public bool IsThrownWeapon(Item item)
        {
            if (item == null)
                return false;

            if (item.info.category == ItemCategory.Weapon || item.info.category == ItemCategory.Tool)
            {
                if (item.info.stackable > 1)
                    return false;

                var weapon = item?.GetHeldEntity() as BaseProjectile;

                if (weapon == null)
                    return true;

                if (weapon.primaryMagazine.capacity > 0)
                    return false;
            }

            return false;
        }

        public Vector3 RandomDropPosition() // CargoPlane.RandomDropPosition()
        {
            Vector3 vector;
            float num = 100f, x = TerrainMeta.Size.x / 3f;
            do
            {
                vector = Vector3Ex.Range(-x, x);
            } while (filter.GetFactor(vector) == 0f && --num > 0f);
            vector.y = 0f;
            return vector;
        }

        public Vector3 FindDuelingZone()
        {
            Vector3 position;
            DateTime tick = DateTime.Now; // create a timestamp to see how long this process takes
            int maxRetries = 500; // 0.1.9: increased due to rock collider detection. 0.1.10 rock collider detection removed but amount not changed
            int retries = maxRetries; // servers with high entity counts will require this

            if (managedZones.Count == 0 && ZoneManager.CanCall())
                SetupZoneManager();

            do
            {
                position = RandomDropPosition();

                foreach (var monument in monuments)
                {
                    if (Vector3.Distance(position, monument) < 150f) // don't put the dueling zone inside of a monument. players will throw a shit fit
                    {
                        position = Vector3.zero;
                        break;
                    }
                }

                if (position == Vector3.zero)
                    continue;

                if (managedZones.Count > 0)
                {
                    foreach (var zone in managedZones)
                    {
                        if (Vector3.Distance(zone.Key, position) <= zone.Value)
                        {
                            position = Vector3.zero; // blocked by zone manager
                            break;
                        }
                    }
                }

                if (position == Vector3.zero)
                    continue;

                position.y = TerrainMeta.HeightMap.GetHeight(position) + 100f; // setup the hit

                RaycastHit hit;
                if (Physics.Raycast(position, Vector3.down, out hit, position.y, groundMask))
                {
                    position.y = Mathf.Max(hit.point.y, TerrainMeta.HeightMap.GetHeight(position)); // get the max height

                    var colliders = Pool.Get<List<Collider>>();
                    Vis.Colliders(position, zoneRadius + 15f, colliders, blockedMask, QueryTriggerInteraction.Collide); // get all colliders using the provided layermask

                    if (colliders.Count > 0) // if any colliders were found from the blockedMask then we don't want this as our dueling zone. retry.
                        position = Vector3.zero;

                    Pool.FreeUnmanaged(ref colliders);

                    if (position != Vector3.zero) // so far so good, let's measure the highest and lowest points of the terrain, and count the amount of water colliders
                    {
                        var positions = GetCircumferencePositions(position, zoneRadius - 15f, 1f, 0f); // gather positions around the purposed zone
                        float min = 200f;
                        float max = -200f;
                        int water = 0;

                        foreach (var pos in positions)
                        {
                            if (Physics.Raycast(new Vector3(pos.x, pos.y + 100f, pos.z), Vector3.down, 100.5f, waterMask)) //look for water
                                water++; // count the amount of water colliders

                            min = Mathf.Min(pos.y, min); // set the lowest and highest points of the terrain
                            max = Mathf.Max(pos.y, max);
                        }

                        if (max - min > maxIncline || position.y - min > maxIncline) // the incline is too steep to be suitable for a dueling zone, retry.
                            position = Vector3.zero;

                        if (water > positions.Count / 4) // too many water colliders, retry.
                            position = Vector3.zero;

                        positions.Clear();
                    }
                }
                else
                    position = Vector3.zero; // found water instead of land

                if (position == Vector3.zero)
                    continue;

                if (DuelTerritory(position, zoneRadius + 15f)) // check if position overlaps an existing zone
                    position = Vector3.zero; // overlaps, retry.
            } while (position == Vector3.zero && --retries > 0); // prevent infinite loops

            if (position != Vector3.zero)
                Puts(msg("FoundZone", null, maxRetries - retries, (DateTime.Now - tick).TotalMilliseconds)); // we found a dueling zone! return the position to be assigned, spawn the zone and the spawn points!

            return position;
        }

        public List<Vector3> GetCircumferencePositions(Vector3 center, float radius, float next, float y) // as the name implies
        {
            var positions = new List<Vector3>();
            float degree = 0f;

            while (degree < 360)
            {
                float angle = (float)(2 * Math.PI / 360) * degree;
                float x = center.x + radius * (float)Math.Cos(angle);
                float z = center.z + radius * (float)Math.Sin(angle);
                var position = new Vector3(x, 0f, z);

                position.y = y == 0f ? TerrainMeta.HeightMap.GetHeight(position) : y;
                positions.Add(position);

                degree += next;
            }

            return positions;
        }

        public List<Vector3> GetAutoSpawns(DuelingZone zone)
        {
            var spawns = new List<Vector3>();
            string key = zone.Position.ToString();

            if (duelsData.AutoGeneratedSpawns.ContainsKey(key) && duelsData.AutoGeneratedSpawns[key].Count > 0)
                spawns.AddRange(duelsData.AutoGeneratedSpawns[key].Select(spawn => spawn.ToVector3())); // use cached spawn points

            if (!duelsData.AutoGeneratedSpawns.ContainsKey(key))
                duelsData.AutoGeneratedSpawns.Add(key, new List<string>());

            if (spawns.Count < 2)
                spawns = CreateSpawnPoints(zone.Position); // create spawn points on the fly

            duelsData.AutoGeneratedSpawns[key] = spawns.Select(spawn => spawn.ToString()).ToList();
            return spawns;
        }

        public List<Vector3> CreateSpawnPoints(Vector3 center)
        {
            var positions = new List<Vector3>(); // 0.1.1 bugfix: spawn point height (y) wasn't being modified when indexing the below foreach list. instead, create a copy of each position and return a new list (cause: can't modify members of value types without changing the collection and invalidating the enumerator. bug: index the value type and change the value. result: list did not propagate)

            // create spawn points slightly inside of the dueling zone so they don't spawn inside of walls
            foreach (var position in GetCircumferencePositions(center, zoneRadius - 15f, 10f, 0f))
            {
                var hits = Physics.RaycastAll(new Vector3(position.x, TerrainMeta.HighestPoint.y + 200f, position.z), Vector3.down, Mathf.Infinity);

                if (hits.Length > 0) // low failure rate
                {
                    float y = TerrainMeta.HeightMap.GetHeight(position);

                    if (avoidWaterSpawns && TerrainMeta.WaterMap.GetHeight(position) - y > 0.8f)
                        continue; // 0.1.16: better method to check water level

                    foreach (var hit in hits)
                    {
                        switch (LayerMask.LayerToName(hit.collider.gameObject.layer))
                        {
                            case "Construction":
                            case "Deployed":
                                if (!hit.GetEntity()) // 0.1.2 bugfix: spawn points floating when finding a collider with no entity
                                    continue;

                                y = Mathf.Max(hit.point.y, y);
                                break;
                            case "World":
                            case "Terrain":
                                y = Mathf.Max(hit.point.y, y);
                                break;
                        }
                    }

                    positions.Add(new Vector3(position.x, y, position.z));
                }
            }

            return positions;
        }

        public bool ResetDuelists() // reset all data for the wipe after assigning awards
        {
            if (AssignDuelists())
            {
                if (resetSeed)
                {
                    duelsData.VictoriesSeed.Clear();
                    duelsData.LossesSeed.Clear();
                    duelsData.MatchKillsSeed.Clear();
                    duelsData.MatchDeathsSeed.Clear();
                    duelsData.MatchLossesSeed.Clear();
                    duelsData.MatchVictoriesSeed.Clear();
                    duelsData.MatchSizesVictoriesSeed.Clear();
                    duelsData.MatchSizesVictoriesSeed.Clear();
                }

                if (wipeDuelZones)
                {
                    duelsData.DuelZones.Clear();
                    duelsData.Spawns.Clear();
                    duelsData.AutoGeneratedSpawns.Clear();
                }

                duelsData.Bets.Clear();
                duelsData.ClaimBets.Clear();
                ResetTemporaryData();
            }

            return true;
        }

        public bool AssignDuelists()
        {
            if (!recordStats || duelsData.VictoriesSeed.Count == 0)
                return true; // nothing to do here, return

            foreach (var target in covalence.Players.All) // remove player awards from previous wipe
            {
                if (permission.UserHasPermission(target.Id, duelistPerm))
                    permission.RevokeUserPermission(target.Id, duelistPerm);

                if (permission.UserHasGroup(target.Id, duelistGroup))
                    permission.RemoveUserGroup(target.Id, duelistGroup);
            }

            if (permsToGive <= 0) // check now incase the user disabled awards later on
                return true;

            var duelists = duelsData.VictoriesSeed.ToList(); // sort the data
            duelists.Sort((x, y) => y.Value.CompareTo(x.Value));

            int added = 0;

            for (int i = 0; i < duelists.Count; i++) // now assign it
            {
                var target = covalence.Players.FindPlayerById(duelists[i].Key);

                if (target == null || target.IsBanned || target.IsAdmin)
                    continue;

                permission.GrantUserPermission(target.Id, duelistPerm.ToLower(), this);
                permission.AddUserGroup(target.Id, duelistGroup.ToLower());

                Log("awards", msg("Awards", null, target.Name, target.Id, duelists[i].Value), true);
                Puts(msg("Granted", null, target.Name, target.Id, duelistPerm, duelistGroup));

                if (++added >= permsToGive)
                    break;
            }

            if (added > 0)
                Puts(msg("Logged", null, string.Format("{0}{1}{2}_{3}-{4}.txt", Interface.Oxide.LogDirectory, Path.DirectorySeparatorChar, Name.Replace(" ", "").ToLower(), "awards", DateTime.Now.ToString("yyyy-MM-dd"))));

            return true;
        }

        public bool IsNewman(BasePlayer player) // count the players items. exclude rocks and torchs
        {
            if (bypassNewmans || saveRestoreEnabled)
                return true;

            List<Item> itemList = Pool.Get<List<Item>>();
            int count = player.inventory.GetAllItems(itemList);
            Pool.FreeUnmanaged(ref itemList);

            if (permission.UserHasPermission(player.UserIDString, "permamap.use") && player.inventory.containerBelt.GetSlot(6) != null)
                count -= 1;

            count -= respawnLoot.Sum(entry => GetAmount(player, entry.shortname));

            return count == 0;
        }

        public int GetAmount(BasePlayer player, string shortname)
        {
            List<Item> itemList = Pool.Get<List<Item>>();
            player.inventory.GetAllItems(itemList);
            int count = itemList.Where(x => x.info.shortname.Equals(shortname, StringComparison.CurrentCultureIgnoreCase)).Sum(item => item.amount);
            Pool.FreeUnmanaged(ref itemList);
            return count;
        }

        public bool RemoveFromQueue(string targetId)
        {
            foreach (var kvp in duelsData.Queued)
            {
                if (kvp.Value == targetId)
                {
                    duelsData.Queued.Remove(kvp.Key);
                    return true;
                }
            }

            return false;
        }

        public void CheckQueue()
        {
            if (duelsData.Queued.Count < 2 || !duelsData.DuelsEnabled)
                return;

            string playerId = duelsData.Queued.Values.ElementAt(0);
            string targetId = duelsData.Queued.Values.ElementAt(1);
            var player = BasePlayer.Find(playerId);
            var target = BasePlayer.Find(targetId);

            if (player == null || !player.CanInteract() || InMatch(player))
            {
                if (RemoveFromQueue(playerId))
                    CheckQueue();

                return;
            }

            if (target == null || !player.CanInteract() || InMatch(player))
            {
                if (RemoveFromQueue(targetId))
                    CheckQueue();

                return;
            }

            if (!IsNewman(player))
            {
                if (RemoveFromQueue(player.UserIDString))
                    Message(player, msg("MustBeNaked", player.UserIDString));
                return;
            }

            if (!IsNewman(target))
            {
                if (RemoveFromQueue(target.UserIDString))
                    Message(target, msg("MustBeNaked", target.UserIDString));
                return;
            }

            SelectZone(player, target);
        }

        public bool SelectZone(BasePlayer player, BasePlayer target)
        {
            var lastZone = GetPlayerZone(player, 2) ?? GetPlayerZone(target, 2) ?? GetDuelZone(player.transform.position) ?? GetDuelZone(target.transform.position);

            if (lastZone != null)
            {
                var success = lastZone.AddWaiting(player, target);

                if (success != null && success is bool && (bool)success)
                {
                    Initiate(player, target, false, lastZone);
                    return true;
                }
            }

            var zones = duelingZones.Where(zone => !zone.IsFull && !zone.IsLocked && zone.Spawns.Count >= requiredMinSpawns && zone.Spawns.Count <= requiredMaxSpawns).ToList();

            while (zones.Count > 0)
            {
                var zone = zones.GetRandom();
                var success = zone.AddWaiting(player, target);

                if (success == null) // user must pay the duel entry fee first
                    return true;

                if (success is bool && (bool)success)
                {
                    Initiate(player, target, false, zone);
                    return true;
                }

                zones.Remove(zone);
            };

            return false;
        }

        public string GetKit(BasePlayer player, BasePlayer target)
        {
            string kit = GetRandomKit();

            if (duelsData.CustomKits.ContainsKey(player.UserIDString) && duelsData.CustomKits.ContainsKey(target.UserIDString))
            {
                string playerKit = duelsData.CustomKits[player.UserIDString];
                string targetKit = duelsData.CustomKits[target.UserIDString];

                if (playerKit.Equals(targetKit, StringComparison.CurrentCultureIgnoreCase))
                {
                    return GetVerifiedKit(playerKit) ?? kit;
                }
            }

            return kit;
        }

        public void VerifyKits()
        {
            if (Kits.CanCall())
            {
                foreach (string kit in lpDuelingKits.ToList())
                    if (!IsKit(kit))
                        lpDuelingKits.Remove(kit);

                foreach (string kit in hpDuelingKits.ToList())
                    if (!IsKit(kit))
                        hpDuelingKits.Remove(kit);
            }
        }

        public string GetRandomKit()
        {
            VerifyKits();

            if (Random.value < lesserKitChance && lpDuelingKits.Count > 0)
            {
                return lpDuelingKits.GetRandom();
            }

            if (hpDuelingKits.Count > 0)
            {
                return hpDuelingKits.GetRandom();
            }

            if (customKits.Count > 0)
            {
                return customKits.ElementAt(Random.Range(0, customKits.Count)).Key;
            }

            return null;
        }

        public void Initiate(BasePlayer player, BasePlayer target, bool checkInventory, DuelingZone destZone)
        {
            try
            {
                if (player == null || target == null || destZone == null)
                    return;

                dataRequests.Remove(player.UserIDString);
                dataRequests.Remove(target.UserIDString);

                if (checkInventory)
                {
                    if (!IsNewman(player))
                    {
                        Message(player, msg("MustBeNaked", player.UserIDString));
                        Message(target, msg("DuelMustBeNaked", target.UserIDString, player.displayName));
                        return;
                    }

                    if (!IsNewman(target))
                    {
                        Message(target, msg("MustBeNaked", player.UserIDString));
                        Message(player, msg("DuelMustBeNaked", player.UserIDString, target.displayName));
                        return;
                    }
                }

                if (!DuelTerritory(player.transform.position) || !duelsData.Homes.ContainsKey(player.UserIDString))
                {
                    var ppos = player.transform.position;
                    if (IsOnConstruction(ppos)) ppos.y += 1; // prevent player from becoming stuck or dying when teleported home
                    duelsData.Homes[player.UserIDString] = ppos.ToString();
                }

                if (!DuelTerritory(target.transform.position) || !duelsData.Homes.ContainsKey(target.UserIDString))
                {
                    var tpos = target.transform.position;
                    if (IsOnConstruction(tpos)) tpos.y += 1;
                    duelsData.Homes[target.UserIDString] = tpos.ToString();
                }

                var playerSpawn = destZone.Spawns.GetRandom();
                var targetSpawn = playerSpawn;
                float dist = -100f;

                foreach (var spawn in destZone.Spawns) // get the furthest spawn point away from the player and assign it to target
                {
                    float distance = Vector3.Distance(spawn, playerSpawn);

                    if (distance > dist)
                    {
                        dist = distance;
                        targetSpawn = spawn;
                    }
                }

                string kit = GetKit(player, target);
                duelsData.Kits[player.UserIDString] = kit;
                duelsData.Kits[target.UserIDString] = kit;

                Teleport(player, playerSpawn);
                Teleport(target, targetSpawn);

                if (debugMode)
                    Puts($"{player.displayName} and {target.displayName} have entered a duel.");

                RemoveFromQueue(player.UserIDString);
                RemoveFromQueue(target.UserIDString);

                if (immunityTime >= 1)
                {
                    dataImmunity[player.UserIDString] = TimeStamp() + immunityTime;
                    dataImmunity[target.UserIDString] = TimeStamp() + immunityTime;
                    dataImmunitySpawns[player.UserIDString] = playerSpawn;
                    dataImmunitySpawns[target.UserIDString] = targetSpawn;
                }

                dataDuelists[player.UserIDString] = target.UserIDString;
                dataDuelists[target.UserIDString] = player.UserIDString;
                SubscribeHooks(true);

                Message(player, msg("NowDueling", player.UserIDString, target.displayName));
                Message(target, msg("NowDueling", target.UserIDString, player.displayName));

            }
            catch (Exception ex)
            {
                SubscribeHooks(false);
                duelsData.DuelsEnabled = false;
                SaveData();

                Puts("---");
                Puts("Plugin disabled: {0} --- {1}", ex.Message, ex.StackTrace);
                Puts("---");

                ResetDuelist(player.UserIDString);
                ResetDuelist(target.UserIDString);
            }
        }

        // manually check as players may not be in a clan or on a friends list

        public bool IsAllied(string playerId, string targetId)
        {
            var player = BasePlayer.Find(playerId);
            var target = BasePlayer.Find(targetId);

            return player != null && target != null && IsAllied(player, target);
        }

        public bool IsAllied(BasePlayer player, BasePlayer target)
        {
            if (player.IsAdmin && target.IsAdmin)
                return false;

            return IsOnSameTeam(player, target) || IsInSameClan(player, target) || IsAuthorizing(player, target) || IsBunked(player, target) || IsCodeAuthed(player, target) || IsInSameBase(player, target);
        }

        public bool IsOnSameTeam(BasePlayer player, BasePlayer target)
        {
            return player.currentTeam != 0 && player.Team.members.Contains(target.userID);
        }

        public bool IsInSameClan(BasePlayer player, BasePlayer target) // 1st method.
        {
            return Clans.CanCall() && Convert.ToBoolean(Clans?.Call("IsMemberOrAlly", player.UserIDString, target.UserIDString));
        }

        private bool IsAuthorizing(BasePlayer player, BasePlayer target) // 2nd method.
        {
            var privs = BaseNetworkable.serverEntities.OfType<BuildingPrivlidge>();

            return privs.Exists(priv => priv.IsAuthed(player) && priv.IsAuthed(target));
        }

        private bool IsBunked(BasePlayer player, BasePlayer target) // 3rd method. thanks @i_love_code for helping with this too
        {
            var bags = SleepingBag.FindForPlayer(target.userID, true);

            if (bags.Length > 0)
            {
                foreach (var a in SleepingBag.FindForPlayer(player.userID, true))
                {
                    if (bags.Exists(b => a.buildingID == b.buildingID))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private bool IsCodeAuthed(BasePlayer player, BasePlayer target) // 4th method
        {
            foreach (CodeLock codelock in BaseNetworkable.serverEntities.OfType<CodeLock>())
            {
                if (codelock.whitelistPlayers.Contains(player.userID) && codelock.whitelistPlayers.Contains(target.userID))
                {
                    return true;
                }
            }

            return false;
        }

        private bool IsInSameBase(BasePlayer player, BasePlayer target) // 5th method
        {
            var privs = BaseNetworkable.serverEntities.OfType<BuildingPrivlidge>();

            foreach (var priv in privs.Where(p => p.IsAuthed(player)))
            {
                if (priv.GetBuilding()?.decayEntities?.Exists(entity => entity.OwnerID == target.userID) == true)
                {
                    return true;
                }
            }

            foreach (var priv in privs.Where(p => p.IsAuthed(target)))
            {
                if (priv.GetBuilding()?.decayEntities?.Exists(entity => entity.OwnerID == player.userID) == true)
                {
                    return true;
                }
            }

            return false;
        }

        public void Metabolize(BasePlayer player, bool set) // we don't want the elements to harm players since the zone can spawn anywhere on the map!
        {
            if (player == null)
                return;

            if (set)
            {
                player.health = 100f;
                player.metabolism.temperature.min = 32; // immune to cold
                player.metabolism.temperature.max = 32;
                player.metabolism.temperature.value = 32;
                player.metabolism.oxygen.min = 1; // immune to drowning
                player.metabolism.oxygen.value = 1;
                player.metabolism.poison.value = 0; // if they ate raw meat
                player.metabolism.calories.value = player.metabolism.calories.max;
                player.metabolism.hydration.value = player.metabolism.hydration.max;
                player.metabolism.wetness.max = 0;
                player.metabolism.wetness.value = 0;
                player.metabolism.radiation_level.max = 0;
                player.metabolism.radiation_poison.max = 0;
            }
            else
            {
                player.metabolism.oxygen.min = 0;
                player.metabolism.oxygen.max = 1;
                player.metabolism.temperature.min = -100;
                player.metabolism.temperature.max = 100;
                player.metabolism.wetness.min = 0;
                player.metabolism.wetness.max = 1;
                player.metabolism.radiation_level.Reset();
                player.metabolism.radiation_poison.Reset();
            }

            player.metabolism.SendChangesToClient();
        }

        public bool IsKit(string kit)
        {
            return Convert.ToBoolean(Kits?.Call("isKit", kit));
        }

        public void AwardPlayer(ulong playerId, double money, int points)
        {
            if (money == 0.0 && points == 0)
                return;

            var player = BasePlayer.FindByID(playerId);

            if (money > 0.0)
            {
                if (Economics.CanCall())
                {
                    Economics?.Call("Deposit", playerId, money);

                    if (player != null)
                        Message(player, msg("EconomicsDeposit", player.UserIDString, money));
                }
            }

            if (points > 0)
            {
                if (ServerRewards.CanCall())
                {
                    var success = ServerRewards?.Call("AddPoints", playerId, points);

                    if (player != null && success != null && success is bool && (bool)success)
                        Message(player, msg("ServerRewardPoints", player.UserIDString, points));
                }
            }
        }

        public void GivePlayerKit(BasePlayer player)
        {
            if (player == null)
                return;

            string kit = duelsData.Kits.ContainsKey(player.UserIDString) ? duelsData.Kits[player.UserIDString] : string.Empty;

            duelsData.Kits.Remove(player.UserIDString);
            player.inventory.Strip();

            if (!string.IsNullOrEmpty(kit))
            {
                if (Kits.CanCall() && IsKit(kit))
                {
                    object success = Kits.Call("GiveKit", player, kit);

                    if (success is bool && (bool)success)
                    {
                        return;
                    }
                }

                if (string.IsNullOrEmpty(kit))
                {
                    kit = duelsData.CustomKits.ContainsKey(player.UserIDString) ? duelsData.CustomKits[player.UserIDString] : null;
                }

                if (GiveCustomKit(player, kit))
                {
                    return;
                }
            }

            if (Kits.CanCall())
            {
                kit = GetRandomKit();

                if (!string.IsNullOrEmpty(kit))
                {
                    object success = Kits.Call("GiveKit", player, kit);

                    if (success is bool && (bool)success)
                    {
                        return;
                    }
                }
            }

            // give a basic kit when no kit is provided, or the provided kit is invalid
            player.inventory.GiveItem(ItemManager.CreateByItemID(1443579727, 1, 0)); // bow
            player.inventory.GiveItem(ItemManager.CreateByItemID(-1234735557, 50, 0)); // arrows
            player.inventory.GiveItem(ItemManager.CreateByItemID(1602646136, 1, 0)); // stone spear
            player.inventory.GiveItem(ItemManager.CreateByItemID(-2072273936, 5, 0)); // bandage
            player.inventory.GiveItem(ItemManager.CreateByItemID(254522515, 3, 0)); // medkit
            player.inventory.GiveItem(ItemManager.CreateByItemID(1079279582, 4, 0)); // syringe
        }

        public bool GiveCustomKit(BasePlayer player, string kit)
        {
            if (string.IsNullOrEmpty(kit) || customKits.Count == 0 || !customKits.ContainsKey(kit))
                return false;

            bool success = false;

            foreach (var dki in customKits[kit])
            {
                Item item = ItemManager.CreateByName(dki.shortname, dki.amount, dki.skin);

                if (item == null)
                {
                    Puts("Invalid shortname {0}", dki.shortname);
                    continue;
                }

                if (item.skin == 0 && useRandomSkins)
                {
                    var skins = GetItemSkins(item.info);

                    if (skins.Count > 0)
                        item.skin = skins.GetRandom();
                }

                if (dki.mods != null)
                {
                    foreach (string shortname in dki.mods)
                    {
                        Item mod = ItemManager.CreateByName(shortname, 1);

                        if (mod != null)
                            item.contents.AddItem(mod.info, 1);
                    }
                }

                var heldEntity = item.GetHeldEntity();

                if (heldEntity != null)
                {
                    if (item.skin != 0)
                        heldEntity.skinID = item.skin;

                    var weapon = heldEntity as BaseProjectile;

                    if (weapon != null)
                    {
                        if (!string.IsNullOrEmpty(dki.ammo))
                        {
                            var def = ItemManager.FindItemDefinition(dki.ammo);

                            if (def != null)
                                weapon.primaryMagazine.ammoType = def;
                        }

                        weapon.primaryMagazine.contents = 0; // unload the old ammo
                        weapon.SendNetworkUpdateImmediate(false); // update
                        weapon.primaryMagazine.contents = weapon.primaryMagazine.capacity; // load new ammo
                    }
                }

                var container = dki.container == "belt" ? player.inventory.containerBelt : dki.container == "wear" ? player.inventory.containerWear : player.inventory.containerMain;

                item.MarkDirty();
                if (item.MoveToContainer(container, dki.slot < 0 || dki.slot > container.capacity - 1 ? -1 : dki.slot, true))
                {
                    success = true;
                }
                else
                {
                    item.Remove(0f);
                }
            }

            return success;
        }

        private void DuelAnnouncement(bool bypass)
        {
            if (!bypass && (!duelsData.DuelsEnabled || !useAnnouncement))
                return;

            if (BasePlayer.activePlayerList.Count < 3)
                return;

            string console = msg("DuelAnnouncement");
            string disabled = msg("Disabled");

            console = console.Replace("{duelChatCommand}", !string.IsNullOrEmpty(szDuelChatCommand) ? szDuelChatCommand : disabled);
            console = console.Replace("{ladderCommand}", !string.IsNullOrEmpty(szDuelChatCommand) ? string.Format("{0} ladder", szDuelChatCommand) : disabled);
            console = console.Replace("{queueCommand}", !string.IsNullOrEmpty(szQueueChatCommand) ? szQueueChatCommand : disabled);

            if (allowBets)
                console += msg("DuelAnnouncementBetsSuffix", null, szDuelChatCommand);

            Puts(RemoveFormatting(console));

            foreach (var player in BasePlayer.activePlayerList.Where(p => p?.displayName != null))
            {
                string message = msg("DuelAnnouncement", player.UserIDString);

                message = message.Replace("{duelChatCommand}", !string.IsNullOrEmpty(szDuelChatCommand) ? szDuelChatCommand : disabled);
                message = message.Replace("{ladderCommand}", !string.IsNullOrEmpty(szDuelChatCommand) ? string.Format("{0} ladder", szDuelChatCommand) : disabled);
                message = message.Replace("{queueCommand}", !string.IsNullOrEmpty(szQueueChatCommand) ? szQueueChatCommand : disabled);

                if (allowBets)
                    message += msg("DuelAnnouncementBetsSuffix", player.UserIDString, szDuelChatCommand);

                Message(player, string.Format("{0} <color=#C0C0C0>{1}</color>", lang.GetMessage("Prefix", this, player.UserIDString), message));
            }
        }

        public bool CreateBet(BasePlayer player, int betAmount, BetInfo betInfo)
        {
            if (betAmount > betInfo.max) // adjust the bet to the maximum since they clearly want to do this
                betAmount = betInfo.max;

            int amount = player.inventory.GetAmount(betInfo.itemid);

            if (amount == 0)
            {
                Message(player, msg("BetZero", player.UserIDString));
                return false;
            }

            if (amount < betAmount) // obviously they're just trying to see how this works. we won't adjust it here.
            {
                Message(player, msg("BetNotEnough", player.UserIDString));
                return false;
            }

            var takenItems = new List<Item>();
            int takenAmount = player.inventory.Take(takenItems, betInfo.itemid, betAmount);

            if (takenAmount == betAmount)
            {
                var bet = new BetInfo
                {
                    itemid = betInfo.itemid,
                    amount = betAmount,
                    trigger = betInfo.trigger
                };

                duelsData.Bets.Add(player.UserIDString, bet);

                string message = msg("BetPlaced", player.UserIDString, betInfo.trigger, betAmount);

                if (allowBetRefund)
                    message += msg("BetRefundSuffix", player.UserIDString, szDuelChatCommand);
                else if (allowBetForfeit)
                    message += msg("BetForfeitSuffix", player.UserIDString, szDuelChatCommand);

                Message(player, message);
                Puts("{0} bet {1} ({2})", player.displayName, betInfo.trigger, betAmount);

                foreach (Item item in takenItems.ToList())
                    item.Remove(0.1f);

                return true;
            }

            if (takenItems.Count > 0)
            {
                foreach (Item item in takenItems.ToList())
                    player.GiveItem(item, BaseEntity.GiveItemReason.Generic);

                takenItems.Clear();
            }

            return false;
        }

        private void GetWorkshopIDs(int code, string response)
        {
            if (!string.IsNullOrEmpty(response) && code == 200)
            {
                var items = JsonConvert.DeserializeObject<ItemSchema>(response).items;

                foreach (var item in items)
                {
                    if (string.IsNullOrEmpty(item.itemshortname) || string.IsNullOrEmpty(item.workshopdownload))
                        continue;

                    if (!workshopskinsCache.ContainsKey(item.itemshortname))
                        workshopskinsCache.Add(item.itemshortname, new List<ulong>());

                    workshopskinsCache[item.itemshortname].Add(Convert.ToUInt64(item.workshopdownload));
                }
            }
        }

        public List<ulong> GetItemSkins(ItemDefinition def)
        {
            if (!skinsCache.ContainsKey(def.shortname))
            {
                var skins = new List<ulong>();

                skins.AddRange(def.skins.Select(skin => Convert.ToUInt64(skin.id)));

                if (useWorkshopSkins && workshopskinsCache.ContainsKey(def.shortname))
                {
                    skins.AddRange(workshopskinsCache[def.shortname]);
                    workshopskinsCache.Remove(def.shortname);
                }

                if (skins.Contains(0uL))
                    skins.Remove(0uL);

                skinsCache.Add(def.shortname, skins);
            }

            return skinsCache[def.shortname];
        }

        private void RemoveRequests(BasePlayer player)
        {
            foreach (var entry in dataRequests.ToList())
            {
                if (entry.Key == player.UserIDString || entry.Value == player.UserIDString)
                {
                    dataRequests.Remove(entry.Key);
                }
            }
        }

        private void UpdateMatchSizeStats(string playerId, bool winner, bool loser, int teamSize)
        {
            string key = teamSize.ToString();

            if (winner)
            {
                if (!duelsData.MatchSizesVictoriesSeed.ContainsKey(key)) duelsData.MatchSizesVictoriesSeed.Add(key, new Dictionary<string, int>());
                if (!duelsData.MatchSizesVictories.ContainsKey(key)) duelsData.MatchSizesVictories.Add(key, new Dictionary<string, int>());
                if (!duelsData.MatchSizesVictoriesSeed[key].ContainsKey(playerId)) duelsData.MatchSizesVictoriesSeed[key].Add(playerId, 1);
                else duelsData.MatchSizesVictoriesSeed[key][playerId]++;
                if (!duelsData.MatchSizesVictories[key].ContainsKey(playerId)) duelsData.MatchSizesVictories[key].Add(playerId, 1);
                else duelsData.MatchSizesVictories[key][playerId]++;
            }
            if (loser)
            {
                if (!duelsData.MatchSizesLossesSeed.ContainsKey(key)) duelsData.MatchSizesLossesSeed.Add(key, new Dictionary<string, int>());
                if (!duelsData.MatchSizesLosses.ContainsKey(key)) duelsData.MatchSizesLosses.Add(key, new Dictionary<string, int>());
                if (!duelsData.MatchSizesLossesSeed[key].ContainsKey(playerId)) duelsData.MatchSizesLossesSeed[key].Add(playerId, 1);
                else duelsData.MatchSizesLossesSeed[key][playerId]++;
                if (!duelsData.MatchSizesLosses[key].ContainsKey(playerId)) duelsData.MatchSizesLosses[key].Add(playerId, 1);
                else duelsData.MatchSizesLosses[key][playerId]++;
            }
        }

        private void UpdateMatchStats(string playerId, bool winner, bool loser, bool death, bool kill)
        {
            if (winner)
            {
                if (!duelsData.MatchVictories.ContainsKey(playerId)) duelsData.MatchVictories.Add(playerId, 1);
                else duelsData.MatchVictories[playerId]++;
                if (!duelsData.MatchVictoriesSeed.ContainsKey(playerId)) duelsData.MatchVictoriesSeed.Add(playerId, 1);
                else duelsData.MatchVictoriesSeed[playerId]++;
            }
            if (loser)
            {
                if (!duelsData.MatchLosses.ContainsKey(playerId)) duelsData.MatchLosses.Add(playerId, 1);
                else duelsData.MatchLosses[playerId]++;
                if (!duelsData.MatchLossesSeed.ContainsKey(playerId)) duelsData.MatchLossesSeed.Add(playerId, 1);
                else duelsData.MatchLossesSeed[playerId]++;
            }
            if (death)
            {
                if (!duelsData.MatchDeaths.ContainsKey(playerId)) duelsData.MatchDeaths.Add(playerId, 1);
                else duelsData.MatchDeaths[playerId]++;
                if (!duelsData.MatchDeathsSeed.ContainsKey(playerId)) duelsData.MatchDeathsSeed.Add(playerId, 1);
                else duelsData.MatchDeathsSeed[playerId]++;
            }
            if (kill)
            {
                if (!duelsData.MatchKills.ContainsKey(playerId)) duelsData.MatchKills.Add(playerId, 1);
                else duelsData.MatchKills[playerId]++;
                if (!duelsData.MatchKillsSeed.ContainsKey(playerId)) duelsData.MatchKillsSeed.Add(playerId, 1);
                else duelsData.MatchKillsSeed[playerId]++;
            }
        }

        #region SpawnPoints

        public void SendSpawnHelp(BasePlayer player)
        {
            Message(player, msg("SpawnCount", player.UserIDString, duelsData.Spawns.Count));
            Message(player, msg("SpawnAdd", player.UserIDString, szDuelChatCommand));
            Message(player, msg("SpawnHere", player.UserIDString, szDuelChatCommand));
            Message(player, msg("SpawnRemove", player.UserIDString, szDuelChatCommand, spRemoveOneMaxDistance));
            Message(player, msg("SpawnRemoveAll", player.UserIDString, szDuelChatCommand, spRemoveAllMaxDistance));
            Message(player, msg("SpawnWipe", player.UserIDString, szDuelChatCommand));
        }

        public void AddSpawnPoint(BasePlayer player, bool useHit)
        {
            var spawn = player.transform.position;

            if (useHit)
            {
                RaycastHit hit;
                if (!Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity, wallMask))
                {
                    Message(player, msg("FailedRaycast", player.UserIDString));
                    return;
                }

                spawn = hit.point;
            }

            if (duelsData.Spawns.Contains(spawn.ToString()))
            {
                Message(player, msg("SpawnExists", player.UserIDString));
                return;
            }

            duelsData.Spawns.Add(spawn.ToString());
            player.SendConsoleCommand("ddraw.text", spDrawTime, Color.green, spawn, "+S");
            Message(player, msg("SpawnAdded", player.UserIDString, FormatPosition(spawn)));
        }

        public void RemoveSpawnPoint(BasePlayer player)
        {
            float radius = spRemoveOneMaxDistance;
            var spawn = Vector3.zero;
            float dist = radius;

            foreach (var entry in duelsData.Spawns.ToList())
            {
                var _spawn = entry.ToVector3();
                float distance = Vector3.Distance(player.transform.position, _spawn);

                if (distance < dist)
                {
                    dist = distance;
                    spawn = _spawn;
                }
            }

            if (spawn != Vector3.zero)
            {
                duelsData.Spawns.Remove(spawn.ToString());
                player.SendConsoleCommand("ddraw.text", spDrawTime, Color.red, spawn, "-S");
                Message(player, msg("SpawnRemoved", player.UserIDString, 1));
            }
            else
                Message(player, msg("SpawnNoneFound", player.UserIDString, radius));
        }

        public void RemoveSpawnPoints(BasePlayer player)
        {
            int count = 0;

            foreach (var entry in duelsData.Spawns.ToList())
            {
                var spawn = entry.ToVector3();

                if (Vector3.Distance(player.transform.position, spawn) <= spRemoveAllMaxDistance)
                {
                    count++;
                    duelsData.Spawns.Remove(entry);
                    player.SendConsoleCommand("ddraw.text", spDrawTime, Color.red, spawn, "-S");
                }
            }

            if (count == 0)
                Message(player, msg("SpawnNoneFound", player.UserIDString, spRemoveAllMaxDistance));
            else
                Message(player, msg("SpawnRemoved", player.UserIDString, count));
        }

        public void WipeSpawnPoints(BasePlayer player)
        {
            if (duelsData.Spawns.Count == 0)
            {
                Message(player, msg("SpawnNoneExist", player.UserIDString));
                return;
            }

            var spawns = duelsData.Spawns.Select(spawn => spawn.ToVector3()).ToList();

            foreach (var spawn in spawns)
                player.SendConsoleCommand("ddraw.text", 30f, Color.red, spawn, "-S");

            int amount = duelsData.Spawns.Count;
            duelsData.Spawns.Clear();
            spawns.Clear();
            Message(player, msg("SpawnWiped", player.UserIDString, amount));
        }

        public List<Vector3> GetSpawnPoints(DuelingZone zone)
        {
            return duelsData.Spawns.Select(entry => entry.ToVector3()).Where(spawn => zone.Distance(spawn) < zoneRadius).ToList();
        }

        public string FormatBone(string source)
        {
            if (string.IsNullOrEmpty(source))
                return "Chest";

            foreach (var entry in boneTags)
                source = source.Replace(entry.Key, entry.Value);

            return string.Join(" ", source.Split(' ').Select(str => str.SentenceCase()));
        }

        public string FormatPosition(Vector3 position)
        {
            string x = position.x.ToString("N2");
            string y = position.y.ToString("N2");
            string z = position.z.ToString("N2");

            return $"{x} {y} {z}";
        }

        #endregion

        #region UI Creation 

        private readonly List<string> createUI = new List<string>();
        private readonly List<string> duelistUI = new List<string>();
        private readonly List<string> kitsUI = new List<string>();
        private readonly List<string> matchesUI = new List<string>();

        [ConsoleCommand("UI_DuelistCommand")]
        private void ccmdDuelistUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();

            if (IsNull(player) || !arg.HasArgs())
                return;

            switch (arg.Args[0].ToLower())
            {
                case "accept":
                    {
                        if (dataRequests.ContainsValue(player.UserIDString))
                        {
                            cmdDuel(player, szDuelChatCommand, new[] { "accept" });
                            break;
                        }
                        if (tdmRequests.ContainsValue(player.UserIDString))
                        {
                            cmdTDM(player, szMatchChatCommand, new[] { "accept" });
                            break;
                        }

                        Message(player, msg("NoPendingRequests2", player.UserIDString));
                        break;
                    }
                case "decline":
                    {
                        if (dataRequests.ContainsKey(player.UserIDString) || dataRequests.ContainsValue(player.UserIDString))
                        {
                            cmdDuel(player, szDuelChatCommand, new[] { "decline" });
                            break;
                        }

                        var deathmatch = tdmMatches.FirstOrDefault(x => x.GetTeam(player) != Team.None);

                        if (deathmatch != null || tdmRequests.ContainsValue(player.UserIDString) || tdmRequests.ContainsKey(player.UserIDString))
                        {
                            cmdTDM(player, szMatchChatCommand, new[] { "decline" });
                            break;
                        }

                        Message(player, msg("NoPendingRequests", player.UserIDString));
                        break;
                    }
                case "closeui":
                    {
                        DestroyUI(player);
                        return;
                    }
                case "kits":
                    {
                        ToggleKitUI(player);
                        break;
                    }
                case "public":
                    {
                        cmdTDM(player, szMatchChatCommand, new[] { "public" });
                        break;
                    }
                case "requeue":
                    {
                        if (IsDueling(player) || InDeathmatch(player))
                            return;

                        if (sendHomeRequeue)
                        {
                            CuiHelper.DestroyUi(player, "DuelistUI_Defeat");
                            SendHome(player);
                        }
                        else CreateDefeatUI(player);
                        cmdQueue(player, szQueueChatCommand, new string[0]);
                        return;
                    }
                case "queue":
                    {
                        if (IsDueling(player) || InDeathmatch(player))
                            break;

                        cmdQueue(player, szQueueChatCommand, new string[0]);
                        break;
                    }
                case "respawn":
                    {
                        CuiHelper.DestroyUi(player, "DuelistUI_Defeat");

                        if (!InEvent(player) && DuelTerritory(player.transform.position))
                            SendHome(player);

                        return;
                    }
                case "ready":
                case "readyon":
                case "readyoff":
                    {
                        ReadyUp(player);

                        if (DuelTerritory(player.transform.position))
                        {
                            CreateDefeatUI(player);
                            return;
                        }

                        break;
                    }
                case "tdm":
                    {
                        ToggleMatchUI(player);
                        break;
                    }
                case "kit":
                    {
                        if (arg.Args.Length != 2)
                            return;

                        var match = GetMatch(player);

                        if (match != null && match.IsHost(player))
                        {
                            if (!match.IsStarted)
                                match.Kit = GetVerifiedKit(arg.Args[1]);

                            break;
                        }

                        if (duelsData.CustomKits.ContainsKey(player.UserIDString) && duelsData.CustomKits[player.UserIDString] == arg.Args[1])
                        {
                            duelsData.CustomKits.Remove(player.UserIDString);
                            Message(player, msg("ResetKit", player.UserIDString));
                            break;
                        }

                        string kit = GetVerifiedKit(arg.Args[1]);

                        if (string.IsNullOrEmpty(kit))
                            break;

                        duelsData.CustomKits[player.UserIDString] = kit;
                        Message(player, msg("KitSet", player.UserIDString, kit));
                        break;
                    }
                case "joinmatch":
                    {
                        if (arg.Args.Length != 2)
                            return;

                        if (IsDueling(player))
                            break;

                        var match = GetMatch(player);

                        if (match != null)
                        {
                            if (match.IsStarted)
                                break;

                            match.RemoveMatchPlayer(player);
                        }

                        var newMatch = tdmMatches.FirstOrDefault(x => x.Id == arg.Args[1] && x.IsPublic);

                        if (newMatch == null || newMatch.IsFull() || newMatch.IsStarted || newMatch.IsOver)
                        {
                            Message(player, msg("MatchNoLongerValid", player.UserIDString));
                            break;
                        }

                        if (newMatch.GetTeam(player) != Team.None)
                            break;

                        newMatch.AddMatchPlayer(player, !newMatch.IsFull(Team.Good) ? Team.Good : Team.Evil);

                        if (matchesUI.Contains(player.UserIDString))
                        {
                            CuiHelper.DestroyUi(player, "DuelistUI_Matches");
                            matchesUI.Remove(player.UserIDString);
                        }

                        break;
                    }
                case "size":
                    {
                        if (arg.Args.Length != 2 || !arg.Args[1].All(char.IsDigit))
                            break;

                        cmdTDM(player, szMatchChatCommand, new[] { "size", arg.Args[1] });
                        break;
                    }
                case "any":
                    {
                        cmdTDM(player, szMatchChatCommand, new[] { "any" });
                        break;
                    }
            }

            RefreshUI(player);
        }

        public void DestroyAllUI()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
            }
        }

        public bool DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "DuelistUI_Options");
            CuiHelper.DestroyUi(player, "DuelistUI_Kits");
            CuiHelper.DestroyUi(player, "DuelistUI_Matches");
            CuiHelper.DestroyUi(player, "DuelistUI_Announcement");
            CuiHelper.DestroyUi(player, "DuelistUI_Defeat");
            CuiHelper.DestroyUi(player, "DuelistUI_Countdown");

            if (readyUiList.Contains(player.UserIDString))
            {
                CuiHelper.DestroyUi(player, "DuelistUI_Ready");
                readyUiList.Remove(player.UserIDString);
            }

            if (duelistUI.Contains(player.UserIDString))
            {
                duelistUI.Remove(player.UserIDString);
                return true;
            }

            return false;
        }

        public void ccmdDUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();

            if (IsNull(player))
                return;

            if (arg.HasArgs(1))
            {
                switch (arg.Args[0].ToLower())
                {
                    case "on":
                        {
                            cmdDUI(player, szUIChatCommand, new string[0]);
                            return;
                        }
                    case "off":
                        {
                            DestroyUI(player);
                            return;
                        }
                }
            }

            if (duelistUI.Contains(player.UserIDString))
                DestroyUI(player);
            else
                cmdDUI(player, szUIChatCommand, new string[0]);
        }

        public void cmdDUI(BasePlayer player, string command, string[] args)
        {
            DestroyUI(player);
            var buttons = new List<string>
            {
                "UI_Accept",
                "UI_Decline",
                "UI_Kits",
                "UI_Public",
                "UI_Queue",
                "UI_TDM",
                "UI_Any",
                duelsData.AutoReady.Contains(player.UserIDString) ? "UI_ReadyOn" : "UI_ReadyOff",
            };
            var element = UI.CreateElementContainer("DuelistUI_Options", "0 0 0 0.5", "0.915 0.148", "0.981 0.441", guiUseCursor);

            if (guiUseCloseButton)
                UI.CreateButton(ref element, "DuelistUI_Options", "0.29 0.49 0.69 0.5", "X", 14, "0.7 0.9", "0.961 0.98", "UI_DuelistCommand closeui");

            for (int number = 0; number < buttons.Count; number++)
            {
                var pos = UI.CalcButtonPos(number + 1, 2.075f);
                string uicommand = buttons[number].Replace("UI_", "").ToLower();
                string text = msg(buttons[number], player.UserIDString);
                UI.CreateButton(ref element, "DuelistUI_Options", "0.29 0.49 0.69 0.5", text, 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_DuelistCommand {uicommand}");
            }

            if (!duelistUI.Contains(player.UserIDString))
                duelistUI.Add(player.UserIDString);

            CuiHelper.AddUi(player, element);
        }

        public void RefreshUI(BasePlayer player)
        {
            cmdDUI(player, szUIChatCommand, new string[0]);

            if (kitsUI.Contains(player.UserIDString))
            {
                kitsUI.Remove(player.UserIDString);
                ToggleKitUI(player);
            }
            if (matchesUI.Contains(player.UserIDString))
            {
                matchesUI.Remove(player.UserIDString);
                ToggleMatchUI(player);
            }
        }

        public void ToggleMatchUI(BasePlayer player)
        {
            if (matchesUI.Contains(player.UserIDString))
            {
                CuiHelper.DestroyUi(player, "DuelistUI_Matches");
                matchesUI.Remove(player.UserIDString);
                return;
            }

            if (kitsUI.Contains(player.UserIDString))
            {
                CuiHelper.DestroyUi(player, "DuelistUI_Kits");
                kitsUI.Remove(player.UserIDString);
            }

            var element = UI.CreateElementContainer("DuelistUI_Matches", "0 0 0 0.5", "0.669 0.148", "0.903 0.541");
            var matches = tdmMatches.Where(x => x.IsPublic && !x.IsStarted && !x.IsFull()).ToList();

            for (int number = 0; number < matches.Count; number++)
            {
                var pos = UI.CalcButtonPos(number);
                UI.CreateButton(ref element, "DuelistUI_Matches", "0.29 0.49 0.69 0.5", matches[number].Versus, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_DuelistCommand joinmatch {matches[number].Id}");
            }

            var match = GetMatch(player);
            string teamSize = msg("UI_TeamSize", player.UserIDString);

            for (int size = Math.Max(2, minDeathmatchSize); size < maxDeathmatchSize + 1; size++)
            {
                var pos = UI.CalcButtonPos(size + matches.Count);
                string color = match != null && match.TeamSize == size || size == minDeathmatchSize ? "0.69 0.49 0.29 0.5" : "0.29 0.49 0.69 0.5";
                UI.CreateButton(ref element, "DuelistUI_Matches", color, teamSize + size, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_DuelistCommand size {size}");
            }

            if (matches.Count == 0)
                UI.CreateLabel(ref element, "DuelistUI_Matches", "1 1 1 1", msg("NoMatchesExistYet", player.UserIDString), 14, "0.047 0.73", "1 0.89");

            CuiHelper.AddUi(player, element);
            matchesUI.Add(player.UserIDString);
        }

        public void ToggleKitUI(BasePlayer player)
        {
            if (kitsUI.Contains(player.UserIDString))
            {
                CuiHelper.DestroyUi(player, "DuelistUI_Kits");
                kitsUI.Remove(player.UserIDString);
                return;
            }

            if (matchesUI.Contains(player.UserIDString))
            {
                CuiHelper.DestroyUi(player, "DuelistUI_Matches");
                matchesUI.Remove(player.UserIDString);
            }

            var element = UI.CreateElementContainer("DuelistUI_Kits", "0 0 0 0.5", "0.669 0.148", "0.903 0.541");
            var kits = VerifiedKits;
            string kit = duelsData.CustomKits.ContainsKey(player.UserIDString) ? duelsData.CustomKits[player.UserIDString] : null;

            for (int number = 0; number < kits.Count; number++)
            {
                var pos = UI.CalcButtonPos(number);
                UI.CreateButton(ref element, "DuelistUI_Kits", kits[number] == kit ? "0.69 0.49 0.29 0.5" : "0.29 0.49 0.69 0.5", kits[number], 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_DuelistCommand kit {kits[number]}");
            }

            CuiHelper.AddUi(player, element);
            kitsUI.Add(player.UserIDString);
        }

        public void CreateAnnouncementUI(BasePlayer player, string text)
        {
            if (guiAnnounceUITime <= 0f || IsNotConnected(player))
                return;

            var element = UI.CreateElementContainer("DuelistUI_Announcement", "0 0 0 0.5", "-0.027 0.92", "1.026 0.9643", false, "Hud");

            UI.CreateLabel(ref element, "DuelistUI_Announcement", "", text, 18, "0 0", "1 1");
            CuiHelper.DestroyUi(player, "DuelistUI_Announcement");
            CuiHelper.AddUi(player, element);

            timer.Once(guiAnnounceUITime, () => CuiHelper.DestroyUi(player, "DuelistUI_Announcement"));
        }

        public void CreateCountdownUI(BasePlayer player, string text)
        {
            var element = UI.CreateElementContainer("DuelistUI_Countdown", "0 0 0 0.5", "0.484 0.92", "0.527 0.9643", false, "Hud");

            UI.CreateLabel(ref element, "DuelistUI_Countdown", "1 0.1 0.1 1", text, 20, "0 0", "1 1");
            CuiHelper.DestroyUi(player, "DuelistUI_Countdown");
            CuiHelper.AddUi(player, element);
        }

        public void ToggleReadyUI(BasePlayer player)
        {
            if (IsNotConnected(player))
                return;

            if (readyUiList.Contains(player.UserIDString))
            {
                CuiHelper.DestroyUi(player, "DuelistUI_Ready");
                readyUiList.Remove(player.UserIDString);
                return;
            }

            var element = UI.CreateElementContainer("DuelistUI_Ready", "0 0 0 0.5", "0.475 0.158", "0.573 0.21");
            UI.CreateButton(ref element, "DuelistUI_Ready", "0.29 0.49 0.69 0.5", msg(duelsData.AutoReady.Contains(player.UserIDString) ? "UI_ReadyOn" : "UI_ReadyOff", player.UserIDString), 18, "0.016 0.081", "0.984 0.919", "UI_DuelistCommand ready");
            CuiHelper.AddUi(player, element);
            readyUiList.Add(player.UserIDString);
        }

        public void CreateDefeatUI(BasePlayer player)
        {
            if (IsNotConnected(player))
                return;

            var element = UI.CreateElementContainer("DuelistUI_Defeat", "0 0 0 0.5", "0.436 0.133", "0.534 0.307", guiUseCursor);

            UI.CreateButton(ref element, "DuelistUI_Defeat", "0.29 0.49 0.69 0.5", msg("UI_Respawn", player.UserIDString), 18, "0.016 0.679", "0.984 0.976", "UI_DuelistCommand respawn");
            UI.CreateButton(ref element, "DuelistUI_Defeat", "0.29 0.49 0.69 0.5", msg("UI_Requeue", player.UserIDString), 18, "0.016 0.357", "0.984 0.655", "UI_DuelistCommand requeue");
            UI.CreateButton(ref element, "DuelistUI_Defeat", "0.29 0.49 0.69 0.5", msg(duelsData.AutoReady.Contains(player.UserIDString) ? "UI_ReadyOn" : "UI_ReadyOff", player.UserIDString), 18, "0.016 0.024", "0.984 0.333", "UI_DuelistCommand ready");
            CuiHelper.DestroyUi(player, "DuelistUI_Defeat");
            CuiHelper.AddUi(player, element);

            if (readyUiList.Contains(player.UserIDString))
            {
                CuiHelper.DestroyUi(player, "DuelistUI_Ready");
                readyUiList.Remove(player.UserIDString);
            }
        }

        private void UpdateMatchUI()
        {
            if (!matchUpdateRequired)
                return;

            matchUpdateRequired = false;

            foreach (string userId in matchesUI.ToList())
            {
                matchesUI.Remove(userId);
                var player = BasePlayer.Find(userId);

                if (player != null && player.IsConnected)
                {
                    CuiHelper.DestroyUi(player, "DuelistUI_Matches");
                    ToggleMatchUI(player);
                }
            }
        }

        public class UI // Credit: Absolut
        {
            public static CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false, string parent = "Overlay")
            {
                var NewElement = new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            Image =
                            {
                                Color = color
                            },
                            RectTransform =
                            {
                                AnchorMin = aMin,
                                AnchorMax = aMax
                            },
                            CursorEnabled = cursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }

            public static void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text =
                    {
                        Color = color,
                        FontSize = size,
                        Align = align,
                        FadeIn = 1.0f,
                        Text = text
                    },
                    RectTransform =
                    {
                        AnchorMin = aMin,
                        AnchorMax = aMax
                    }
                },
                panel);
            }

            public static void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter, string labelColor = "")
            {
                container.Add(new CuiButton
                {
                    Button =
                        {
                            Color = color,
                            Command = command,
                            FadeIn = 1.0f
                        },
                    RectTransform =
                        {
                            AnchorMin = aMin,
                            AnchorMax = aMax
                        },
                    Text =
                        {
                            Text = text,
                            FontSize = size,
                            Align = align,
                            Color = labelColor
                        }
                },
                    panel);
            }

            public static float[] CalcButtonPos(int number, float dMinOffset = 1f)
            {
                Vector2 position = new Vector2(0.03f, 0.889f);
                Vector2 dimensions = new Vector2(0.45f * dMinOffset, 0.1f);
                float offsetY = 0;
                float offsetX = 0;
                if (number >= 0 && number < 9)
                {
                    offsetY = (-0.01f - dimensions.y) * number;
                }
                else if (number > 8 && number < 19)
                {
                    offsetY = (-0.01f - dimensions.y) * (number - 9);
                    offsetX = (0.04f + dimensions.x) * 1;
                }
                else if (number > 18 && number < 29)
                {
                    offsetY = (-0.01f - dimensions.y) * (number - 19);
                    offsetX = (0.08f + dimensions.x) * 1;
                }
                Vector2 offset = new Vector2(offsetX, offsetY);
                Vector2 posMin = position + offset;
                Vector2 posMax = posMin + dimensions;
                return new[] { posMin.x, posMin.y, posMax.x, posMax.y };
            }
        }

        #endregion

        #region Config

        private bool Changed;
        private string szMatchChatCommand;
        private string szDuelChatCommand;
        private string szQueueChatCommand;
        private const string duelistPerm = "duelist.dd";
        private const string duelistGroup = "duelist";
        private float zoneRadius;
        private int deathTime;
        private int immunityTime;
        private int zoneCounter;
        private List<string> _hpDuelingKits = new List<string>();
        private List<string> _lpDuelingKits = new List<string>();
        private List<string> hpDuelingKits = new List<string>();
        private List<string> lpDuelingKits = new List<string>();
        private List<BetInfo> duelingBets = new List<BetInfo>();
        private bool recordStats = true;
        private int permsToGive = 3;
        private float maxIncline;
        private bool allowBetForfeit;
        private bool allowBetRefund;
        private bool allowBets;
        private bool putToSleep;
        private bool blockSpawning;
        private bool killNpc;
        private float announceTime;
        private bool removePlayers;
        private bool useAnnouncement;
        private bool autoSetup;
        private bool broadcastDefeat;
        private double economicsMoney;
        private double requiredDuelMoney;
        private int serverRewardsPoints;
        private float damageScaleAmount;
        private int zoneAmount;
        private int playersPerZone;
        private bool visibleToAdmins;
        private float spDrawTime;
        private float spRemoveOneMaxDistance;
        private float spRemoveAllMaxDistance;
        private bool spAutoRemove;
        private bool avoidWaterSpawns;
        private int extraWallStacks;
        private bool useZoneWalls;
        private bool zoneUseWoodenWalls;
        private float buildingBlockExtensionRadius;
        private bool autoAllowAll;
        private bool useRandomSkins;
        private float playerHealth;
        private bool dmFF;
        private int minDeathmatchSize;
        private int maxDeathmatchSize;
        private bool autoEnable;
        private ulong teamGoodShirt;
        private ulong teamEvilShirt;
        private string teamShirt;
        private double teamEconomicsMoney;
        private int teamServerRewardsPoints;
        private float lesserKitChance;
        private bool tdmEnabled;
        private bool useLeastAmount;
        private bool tdmServerDeaths;
        private bool tdmMatchDeaths;
        private List<string> whitelistCommands = new List<string>();
        private bool useWhitelistCommands;
        private List<string> blacklistCommands = new List<string>();
        private bool useBlacklistCommands;
        private bool bypassNewmans;
        private bool saveRestoreEnabled;
        private List<DuelKitItem> respawnLoot = new List<DuelKitItem>();
        private bool respawnDeadDisconnect;
        private bool sendDeadHome;
        private bool resetSeed;
        private bool noStability;
        private bool noMovement;
        private bool requireTeamSize;
        private int requiredMinSpawns;
        private int requiredMaxSpawns;
        private bool guiAutoEnable;
        private bool guiUseCursor;
        private string szUIChatCommand;
        private bool useWorkshopSkins;
        private bool respawnWalls;
        private bool allowPlayerDeaths;
        private bool morphBarricadesStoneWalls;
        private bool morphBarricadesWoodenWalls;
        private bool guiUseCloseButton;
        private string autoKitName;
        private float guiAnnounceUITime;
        private bool sendDefeatedHome;
        private bool sendHomeRequeue;
        private bool sendHomeSpectatorWhenRematchTimesOut;
        private bool autoFlames;
        private bool autoOvens;
        private bool autoTurrets;
        private int sphereAmount;
        private bool wipeDuelZones;
        private bool setPlayerTime;
        private ulong chatSteamID;

        private List<object> RespawnLoot
        {
            get
            {
                return new List<object>
                {
                    new DuelKitItem
                    {
                        shortname = "rock",
                        amount = 1,
                        skin = 0,
                        container = "belt",
                        slot = -1
                    },
                    new DuelKitItem
                    {
                        shortname = "torch",
                        amount = 1,
                        skin = 0,
                        container = "belt",
                        slot = -1
                    }
                };
            }
        }

        private List<object> BlacklistedCommands
        {
            get
            {
                return new List<object>
                {
                    "/tp",
                    "/remove",
                    "/bank",
                    "/shop",
                    "/event",
                    "/rw",
                    "/home",
                    "/trade"
                };
            }
        }

        private List<object> WhitelistedCommands
        {
            get
            {
                return new List<object>
                {
                    "/report",
                    "/pm",
                    "/r",
                    "/help"
                };
            }
        }

        private List<object> DefaultBets
        {
            get
            {
                return new List<object>
                {
                    new Dictionary<string, object>
                    {
                        ["trigger"] = "stone",
                        ["max"] = 50000,
                        ["itemid"] = -2099697608
                    },
                    new Dictionary<string, object>
                    {
                        ["trigger"] = "sulfur",
                        ["max"] = 50000,
                        ["itemid"] = -1581843485
                    },
                    new Dictionary<string, object>
                    {
                        ["trigger"] = "fragment",
                        ["max"] = 50000,
                        ["itemid"] = 69511070
                    },
                    new Dictionary<string, object>
                    {
                        ["trigger"] = "charcoal",
                        ["max"] = 50000,
                        ["itemid"] = -1938052175
                    },
                    new Dictionary<string, object>
                    {
                        ["trigger"] = "gp",
                        ["max"] = 25000,
                        ["itemid"] = -265876753
                    },
                    new Dictionary<string, object>
                    {
                        ["trigger"] = "hqm",
                        ["max"] = 1000,
                        ["itemid"] = 317398316
                    },
                    new Dictionary<string, object>
                    {
                        ["trigger"] = "c4",
                        ["max"] = 10,
                        ["itemid"] = 1248356124
                    },
                    new Dictionary<string, object>
                    {
                        ["trigger"] = "rocket",
                        ["max"] = 6,
                        ["itemid"] = -742865266
                    }
                };
            }
        }

        private List<object> DefaultLesserKits
        {
            get
            {
                return new List<object>
                {
                    "kit_4",
                    "kit_5",
                    "kit_6"
                };
            }
        }

        private List<object> DefaultKits
        {
            get
            {
                return new List<object>
                {
                    "kit_1",
                    "kit_2",
                    "kit_3"
                };
            }
        }

        private static Dictionary<string, List<DuelKitItem>> customKits = new Dictionary<string, List<DuelKitItem>>();

        private Dictionary<string, object> DefaultCustomKits
        {
            get
            {
                return new Dictionary<string, object>
                {
                    ["Hunting Bow"] = new List<object>
                    {
                        new DuelKitItem
                        {
                            shortname = "bow.hunting",
                            amount = 1,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "arrow.wooden",
                            amount = 50,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "spear.stone",
                            amount = 1,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "bandage",
                            amount = 5,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "syringe.medical",
                            amount = 5,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "largemedkit",
                            amount = 5,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "burlap.gloves",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "burlap.headwrap",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "burlap.shirt",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "burlap.shoes",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "burlap.trousers",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        }
                    },
                    ["Assault Rifle and Bolt Action Rifle"] = new List<object>
                    {
                        new DuelKitItem
                        {
                            shortname = "rifle.ak",
                            amount = 1,
                            skin = 0,
                            container = "belt",
                            slot = -1,
                            ammo = "ammo.rifle",
                            mods = new List<string>
                            {
                                "weapon.mod.lasersight"
                            }
                        },
                        new DuelKitItem
                        {
                            shortname = "rifle.bolt",
                            amount = 1,
                            skin = 0,
                            container = "belt",
                            slot = -1,
                            ammo = "ammo.rifle",
                            mods = new List<string>
                            {
                                "weapon.mod.lasersight",
                                "weapon.mod.small.scope"
                            }
                        },
                        new DuelKitItem
                        {
                            shortname = "largemedkit",
                            amount = 5,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "bandage",
                            amount = 5,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "syringe.medical",
                            amount = 5,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "bearmeat.cooked",
                            amount = 10,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "hoodie",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "metal.facemask",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "metal.plate.torso",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "pants",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "burlap.gloves",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "shoes.boots",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "ammo.rifle",
                            amount = 200,
                            skin = 0,
                            container = "main",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "weapon.mod.flashlight",
                            amount = 1,
                            skin = 0,
                            container = "main",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "weapon.mod.small.scope",
                            amount = 1,
                            skin = 0,
                            container = "main",
                            slot = -1
                        }
                    },
                    ["Semi-Automatic Pistol"] = new List<object>
                    {
                        new DuelKitItem
                        {
                            shortname = "pistol.semiauto",
                            amount = 1,
                            skin = 0,
                            container = "belt",
                            slot = -1,
                            ammo = "ammo.pistol",
                            mods = new List<string>
                            {
                                "weapon.mod.lasersight"
                            }
                        },
                        new DuelKitItem
                        {
                            shortname = "largemedkit",
                            amount = 5,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "bandage",
                            amount = 5,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "syringe.medical",
                            amount = 5,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "bearmeat.cooked",
                            amount = 10,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "hoodie",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "metal.facemask",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "metal.plate.torso",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "pants",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "burlap.gloves",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "shoes.boots",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "ammo.pistol",
                            amount = 200,
                            skin = 0,
                            container = "main",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "weapon.mod.flashlight",
                            amount = 1,
                            skin = 0,
                            container = "main",
                            slot = -1
                        }
                    },
                    ["Pump Shotgun"] = new List<object>
                    {
                        new DuelKitItem
                        {
                            shortname = "shotgun.pump",
                            amount = 1,
                            skin = 0,
                            container = "belt",
                            slot = -1,
                            ammo = "ammo.shotgun.slug",
                            mods = new List<string>
                            {
                                "weapon.mod.lasersight"
                            }
                        },
                        new DuelKitItem
                        {
                            shortname = "largemedkit",
                            amount = 5,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "bandage",
                            amount = 5,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "syringe.medical",
                            amount = 5,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "bearmeat.cooked",
                            amount = 10,
                            skin = 0,
                            container = "belt",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "hoodie",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "metal.facemask",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "metal.plate.torso",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "pants",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "burlap.gloves",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "shoes.boots",
                            amount = 1,
                            skin = 0,
                            container = "wear",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "ammo.shotgun.slug",
                            amount = 200,
                            skin = 0,
                            container = "main",
                            slot = -1
                        },
                        new DuelKitItem
                        {
                            shortname = "weapon.mod.flashlight",
                            amount = 1,
                            skin = 0,
                            container = "main",
                            slot = -1
                        }
                    }
                };
            }
        }

        protected override void LoadDefaultMessages() // holy shit this took forever.
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Awards"] = "{0} ({1}) duels won {2}",
                ["Granted"] = "Granted {0} ({1}) permission {2} for group {3}",
                ["Logged"] = "Duelists have been logged to: {0}",
                ["Indestructible"] = "This object belongs to the server and is indestructible!",
                ["Building is blocked!"] = "<color=red>Building is blocked inside of dueling zones!</color>",
                ["TopAll"] = "[ <color=#ffff00>Top Duelists Of All Time ({0})</color> ]:",
                ["Top"] = "[ <color=#ffff00>Top Duelists ({0})</color> ]:",
                ["NoLongerQueued"] = "You are no longer in queue for a duel.",
                ["InQueueSuccess"] = "You are now in queue for a duel. You will teleport instantly when a match is available.",
                ["MustBeNaked"] = "<color=red>You must be naked before you can duel.</color>",
                ["AlreadyInADuel"] = "You cannot queue for a duel while already in a duel!",
                ["MustAllowDuels"] = "You must allow duels first! Type: <color=orange>/{0} allow</color>",
                ["DuelsDisabled"] = "Duels are disabled.",
                ["NoZoneExists"] = "No dueling zone exists.",
                ["Banned"] = "You are banned from duels.",
                ["FoundZone"] = "Took {0} tries ({1}ms) to get a dueling zone.",
                ["ImmunityFaded"] = "Your immunity has faded.",
                ["NotifyBetWon"] = "You have won your bet! To claim type <color=orange>/{0} claim</color>.",
                ["ConsoleBetWon"] = "{0} ({1}) won his bet against {2} ({3})!",
                ["DuelDeathMessage"] = "<color=silver><color=lime>{0}</color> (<color=lime>W</color>: <color=orange>{1}</color> / <color=red>L</color>: <color=orange>{2}</color>) has defeated <color=lime>{3}</color> (<color=lime>W</color>: <color=orange>{4}</color> / <color=red>L</color>: <color=orange>{5}</color>) in a duel with <color=green>{6}</color> health left.{7}</color>",
                ["BetWon"] = " Bet won: <color=lime>{0}</color> (<color=lime>{1}</color>)",
                ["ExecutionTime"] = "You have <color=red>{0} minutes</color> to win the duel before you are executed.",
                ["FailedZone"] = "Failed to create a dueling zone, please try again.",
                ["FailedSetup"] = "Failed to setup the zone, please try again.",
                ["FailedRaycast"] = "Look towards the ground, and try again.",
                ["BetPlaced"] = "Your bet {0} ({1}) has been placed.",
                ["BetForfeitSuffix"] = " Type <color=orange>/{0} bet forfeit</color> to forfeit your bet.",
                ["BetRefundSuffix"] = " Type <color=orange>/{0} bet refund</color> to refund your bet.",
                ["BetNotEnough"] = "Bet cancelled. You do not have enough to bet this amount!",
                ["BetZero"] = "Bet cancelled. You do not have this item in your inventory.",
                ["DuelAnnouncement"] = "Type <color=orange>/{duelChatCommand}</color> for information on the dueling system. See your standing on the leaderboard by using <color=orange>/{ladderCommand}</color>. Type <color=orange>/{queueCommand}</color> to enter the dueling queue now!",
                ["DuelAnnouncementBetsSuffix"] = " Feeling lucky? Use <color=orange>/{0} bet</color> to create a bet!",
                ["ZoneCreated"] = "Dueling zone created successfully.",
                ["RemovedZone"] = "Removed dueling zone.",
                ["RemovedBan"] = "Unbanned {0}",
                ["AddedBan"] = "Banned {0}",
                ["PlayerNotFound"] = "{0} not found. Try being more specific or use a steam id.",
                ["RequestTimedOut"] = "Request timed out to duel <color=lime>{0}</color>",
                ["RemovedFromQueueRequest"] = "You have been removed from the dueling queue since you have requested to duel another player.",
                ["RemovedFromDuel"] = "You have been removed from your duel.",
                ["BetsDoNotMatch"] = "Your bet {0} ({1}) does not match {2} ({3})",
                ["InvalidBet"] = "Invalid bet '{0}'",
                ["BetSyntax"] = "Syntax: /{0} bet <item> <amount> - resources must be refined",
                ["AvailableBets"] = "Available Bets:",
                ["MustHaveSameBet"] = "{0} is betting: {1} ({2}). You must have the same bet to duel this player.",
                ["NoBetsToRefund"] = "There are no bets to refund.",
                ["Disabled"] = "Disabled",
                ["HelpDuelBet"] = "<color=silver><color=orange>/{0} bet</color> - place a bet towards your next duel.</color>",
                ["HelpDuelAdmin"] = "<color=orange>Admin: /{0} on|off</color> - enable/disable duels",
                ["HelpDuelAdminRefundAll"] = "<color=orange>Admin: /{0} bet refundall</color> - refund all bets for all players",
                ["DuelsDisabledAlready"] = "Duels are already disabled!",
                ["DuelsNowDisabled"] = "Duels disabled. Sending duelers home.",
                ["DuelsEnabledAlready"] = "Duels are already enabled!",
                ["DuelsNowEnabled"] = "Duels enabled",
                ["NoBetsToClaim"] = "You have no bets to claim.",
                ["PlayerClaimedBet"] = "Claimed bet {0} ({1})",
                ["AllBetsClaimed"] = "You have claimed all of your bets.",
                ["DuelChatOff"] = "You will no longer see duel death messages.",
                ["DuelChatOn"] = "You will now see duel death messages.",
                ["PlayerRequestsOn"] = "Players may now request to duel you. You will be removed from this list if you do not duel.",
                ["PlayerRequestsOff"] = "Players may no longer request to duel you.",
                ["BlockedRequestsFrom"] = "Blocked duel requests from: <color=lime>{0}</color>",
                ["UnblockedRequestsFrom"] = "Removed block on duel requests from: <color=lime>{0}</color>",
                ["AlreadyBlocked"] = "You have already blocked players from requesting duels.",
                ["NoBetsConfigured"] = "No bets are configured.",
                ["RefundAllPlayerNotice"] = "Server administrator has refunded your bet: {0} ({1})",
                ["RefundAllAdminNotice"] = "Refunded {0} ({1}): {2} ({3})",
                ["BetsRemaining"] = "Bet items remaining in database: {0}",
                ["AllBetsRefunded"] = "All dueling bets refunded",
                ["CannotForfeit"] = "You cannot forfeit bets on this server.",
                ["CannotForfeitRequestDuel"] = "You cannot forfeit a bet while requesting a duel!",
                ["CannotForfeitInDuel"] = "You cannot forfeit a bet while dueling!",
                ["CannotRefundRequestDuel"] = "You cannot refund a bet while requesting a duel!",
                ["CannotRefundInDuel"] = "You cannot refund a bet while dueling!",
                ["BetForfeit"] = "You forfeit your bet!",
                ["NoBetToForfeit"] = "You do not have an active bet to forfeit.",
                ["NoBetToRefund"] = "You do not have an active bet to refund.",
                ["CannotRefund"] = "You cannot refund bets on this server.",
                ["BetRefunded"] = "You have refunded your bet.",
                ["AlreadyBetting"] = "You are already betting! Your bet: {0} ({1})",
                ["ToRefundUse"] = "To refund your bet, type: <color=orange>/{0} bet refund</color>",
                ["ToForfeitUse"] = "To forfeit your bet, type: <color=orange>/{0} bet forfeit</color>. Refunds are not allowed.",
                ["InvalidNumber"] = "Invalid number: {0}",
                ["MultiplesOnly"] = "Number must be a multiple of 500. ie: 500, 1000, 2000, 5000, 10000, 15000",
                ["NoRequestsReceived"] = "No players have requested a duel with you.",
                ["DuelCancelledFor"] = "<color=lime>{0}</color> has cancelled the duel!",
                ["NoPendingRequests"] = "You have no pending request to cancel.",
                ["DuelCancelledWith"] = "<color=lime>{0}</color> has cancelled the duel request.",
                ["DuelCancelComplete"] = "Duel request cancelled.",
                ["MustWaitToRequestAgain"] = "You must wait <color=red>{0} minute(s)</color> from the last time you requested a duel to request another.",
                ["AlreadyDueling"] = "You are already dueling another player!",
                ["CannotRequestThisPlayer"] = "You are not allowed to request duels with this player.",
                ["TargetAlreadyDueling"] = "<color=lime>{0}</color> is already dueling another player!",
                ["NotAllowedYet"] = "<color=lime>{0}</color> has not enabled duel requests yet. They must type <color=orange>/{1} allow</color>",
                ["MustWaitForAccept"] = "You have requested a duel with <color=lime>{0}</color> already. You must wait for this player to accept the duel.",
                ["PendingRequestAlready"] = "This player has a duel request pending already.",
                ["TargetHasNoBet"] = "You have an active bet going. <color=lime>{0}</color> must have the same bet to duel you.",
                ["YourBet"] = "Your bet: {0} ({1})",
                ["WoundedQueue"] = "You cannot duel while either player is wounded.",
                ["DuelMustBeNaked"] = "Duel cancelled: <color=lime>{0}</color> inventory is not empty.",
                ["LadderLife"] = "<color=#5A625B>Use <color=yellow>/{0} ladder life</color> to see all time stats</color>",
                ["EconomicsDeposit"] = "You have received <color=yellow>${0}</color>!",
                ["ServerRewardPoints"] = "You have received <color=yellow>{0} RP</color>!",
                ["DuelsMustBeEnabled"] = "Use '/{0} on' to enable dueling on the server.",
                ["DataSaved"] = "Data has been saved.",
                ["DuelsNowDisabledEmpty"] = "Duels disabled.",
                ["CannotTeleport"] = "You are not allowed to teleport from a dueling zone.",
                ["AllZonesFull"] = "All zones are currently full. Zones: {0}. Limit Per Zone: {1}",
                ["NoZoneFound"] = "No zone found. You must stand inside of the zone to remove it.",
                ["RemovedZoneAt"] = "Removed zone at {0}",
                ["CannotDuel"] = "You are not allowed to duel at the moment.",
                ["LeftZone"] = "<color=red>You were found outside of the dueling zone while dueling. Your items have been removed.</color>",
                ["SpawnAdd"] = "<color=orange>/{0} spawns add</color> - add a spawn point at the position you are looking at.",
                ["SpawnHere"] = "<color=orange>/{0} spawns here</color> - add a spawn point at your position.",
                ["SpawnRemove"] = "<color=orange>/{0} spawns remove</color> - removes the nearest spawn point within <color=orange>{1}m</color>.",
                ["SpawnRemoveAll"] = "<color=orange>/{0} spawns removeall</color> - remove all spawn points within <color=orange>{1}m</color>.",
                ["SpawnWipe"] = "<color=orange>/{0} spawns wipe</color> - wipe all spawn points.",
                ["SpawnWiped"] = "<color=red>{0}</color> spawns points wiped.",
                ["SpawnCount"] = "<color=green>{0}</color> spawn points in database.",
                ["SpawnNoneFound"] = "No custom spawn points found within <color=orange>{0}m</color>.",
                ["SpawnAdded"] = "Spawn point added at {0}",
                ["SpawnRemoved"] = "Removed <color=red>{0}</color> spawn(s)",
                ["SpawnExists"] = "This spawn point exists already.",
                ["SpawnNoneExist"] = "No spawn points exist.",
                ["ZoneExists"] = "A dueling zone already exists here.",
                ["ZoneLimit"] = "Zone limit reached ({0}). You must manually remove an existing zone before creating a new one.",
                ["CannotEventJoin"] = "You are not allowed to join this event while dueling.",
                ["KitDoesntExist"] = "This kit doesn't exist: {0}",
                ["KitSet"] = "Custom kit set to {0}. This kit will be used when both players have the same custom kit.",
                ["KitsNotConfigured"] = "No kits have been configured for dueling.",
                ["RemovedXWalls"] = "Removed {0} walls.",
                ["SupportCreated"] = "{0} new dueling zones were created, however the total amount was not met. Please lower the radius, increase Maximum Incline On Hills, or reload the plugin to try again.",
                ["SupportInvalidConfig"] = "Invalid zone radius detected in the configuration file for this map size. Please lower the radius, increase Maximum Incline On Hills, or reload the plugin to try again.",
                ["WallSyntax"] = "Use <color=orange>/{0} walls [radius] <wood|stone></color>, or stand inside of an existing area with walls and use <color=orange>/{0} walls</color> to remove them.",
                ["GeneratedWalls"] = "Generated {0} arena walls {1} high at {2} in {3}ms",
                ["ResetKit"] = "You are no longer using a custom kit.",
                ["HelpDuels"] = "<color=#183a0e><size=18>DUELIST ({0})</size></color><color=#5A625B>\nDuel other players.</color>",
                ["HelpAllow"] = "<color=#5A397A>/{0} allow</color><color=#5A625B> • Toggle requests for duels</color>",
                ["HelpBlock"] = "<color=#5A397A>/{0} block <name></color><color=#5A625B> • Toggle block requests for a player</color>",
                ["HelpChallenge"] = "<color=#5A397A>/{0} <name></color><color=#5A625B> • Challenge another player</color>",
                ["HelpAccept"] = "<color=#5A397A>/{0} accept</color><color=#5A625B> • Accept a challenge</color>",
                ["HelpCancel"] = "<color=#5A397A>/{0} cancel</color><color=#5A625B> • Cancel your duel request</color>",
                ["HelpQueue"] = "<color=#5A397A>/{0}</color><color=#5A625B> • Join duel queue</color>",
                ["HelpChat"] = "<color=#5A397A>/{0} chat</color><color=#5A625B> • Toggle duel death messages</color>",
                ["HelpLadder"] = "<color=#5A397A>/{0} ladder</color><color=#5A625B> • Show top 10 duelists</color>",
                ["HelpBet"] = "<color=#5A397A>/{0} bet</color><color=#5A625B> • Place a bet towards a duel</color>",
                ["TopFormat"] = "<color=#666666><color=#5A625B>{0}.</color> <color=#00FF00>{1}</color> (<color=#008000>W:{2}</color> • <color=#ff0000>L:{3} </color> • <color=#4c0000>WLR:{4}</color>)</color>",
                ["NowDueling"] = "<color=#ff0000>You are now dueling <color=#00FF00>{0}</color>!</color>",
                ["MoneyRequired"] = "Both players must be able to pay an entry fee of <color=#008000>${0}</color> to duel.",
                ["CannotShop"] = "You are not allowed to shop while dueling.",
                ["DuelRequestSent"] = "Sent request to duel <color=lime>{0}</color>. Request expires in 1 minute. Use <color=orange>/{1} cancel</color> to cancel this request.",
                ["DuelRequestReceived"] = "<color=lime>{0}</color> has requested a duel. You have 1 minute to type <color=orange>/{1} accept</color> to accept the duel, or use <color=orange>/{1} decline</color> to decline immediately.",
                ["MatchQueued"] = "You have entered the deathmatch queue. The match will start when a dueling zone becomes available.",
                ["MatchTeamed"] = "You are not allowed to do this while on a deathmatch team.",
                ["MatchNoMatchesExist"] = "No matches exist. Challenge a player by using <color=orange>/{0} name</color>",
                ["MatchStarted"] = "Your match is starting versus: <color=yellow>{0}</color>",
                ["MatchStartedAlready"] = "Your match has already started. You must wait for it to end.",
                ["MatchPlayerLeft"] = "You have removed yourself from your deathmatch team.",
                ["MatchCannotChallenge"] = "{0} is already in a match.",
                ["MatchCannotChallengeAgain"] = "You can only challenge one player at a time.",
                ["MatchRequested"] = "<color=lime>{0}</color> has requested a deathmatch. Use <color=orange>/{1} accept</color> to accept this challenge.",
                ["MatchRequestSent"] = "Match request sent to <color=lime>{0}</color>.",
                ["MatchNoneRequested"] = "No one has challenged you to a deathmatch yet.",
                ["MatchPlayerOffline"] = "The player challenging you is no longer online.",
                ["MatchSizeChanged"] = "Deathmatch changed to <color=yellow>{0}v{0}</color>.",
                ["MatchOpened"] = "Your deathmatch is now open for private invitation. Friends may use <color=orange>/{0} any</color>, and players may use <color=orange>/{0} {1}</color> to join your team. Use <color=orange>/{0} public</color> to toggle invitations as public or private.",
                ["MatchCancelled"] = "{0} has cancelled the deathmatch.",
                ["MatchNotAHost"] = "You must be a host of a deathmatch to use this command.",
                ["MatchDoesntExist"] = "You are not in a deathmatch. Challenge a player by using <color=orange>/{0} name</color>.",
                ["MatchSizeSyntax"] = "Invalid syntax, use /{0} size #",
                ["MatchTeamFull"] = "Team is full ({0} players)",
                ["MatchJoinedTeam"] = "{0} joined {1} ({2}/{3}). {4} ({5}/{3})",
                ["MatchNoPlayersLeft"] = "No players are left on the opposing team. Match cancelled.",
                ["MatchChallenge2"] = "<color=#5A397A>/{0} any</color><color=#5A625B> • Join any match where a friend is the host</color>",
                ["MatchChallenge3"] = "<color=#5A397A>/{0} <code></color><color=#5A625B> • Join a match with the provided code</color>",
                ["MatchAccept"] = "<color=#5A397A>/{0} accept</color><color=#5A625B> • Accept a challenge</color>",
                ["MatchCancel"] = "<color=#5A397A>/{0} cancel</color><color=#5A625B> • Cancel your match request</color>",
                ["MatchLeave"] = "<color=#5A397A>/{0} cancel</color><color=#5A625B> • Leave your match</color>",
                ["MatchSize"] = "<color=#5A397A>/{0} size #</color><color=#5A625B> • Set your match size ({1}v{1}) [Hosts Only]</color>",
                ["MatchKickBan"] = "<color=#5A397A>/{0} kickban id/name</color><color=#5A625B> • Kickban a player from the match [Host Only]</color>",
                ["MatchSetCode"] = "<color=#5A397A>/{0} setcode [code]</color><color=#5A625B> • Change or see your code [Host Only]</color>",
                ["MatchTogglePublic"] = "<color=#5A397A>/{0} public</color><color=#5A625B> • Toggle match as public or private invitation [Host Only]</color>",
                ["MatchDefeat"] = "<color=silver><color=lime>{0}</color> has defeated <color=lime>{1}</color> in a <color=yellow>{2}v{2}</color> deathmatch!</color>",
                ["MatchIsNotNaked"] = "Match cannot start because <color=lime>{0}</color> is not naked. Next queue check in 30 seconds.",
                ["MatchCannotBan"] = "You cannot ban this player, or this player is already banned.",
                ["MatchBannedUser"] = "You have banned <color=lime>{0}</color> from your team.",
                ["MatchPlayerNotFound"] = "<color=lime>{0}</color> is not on your team.",
                ["MatchCodeIs"] = "Your code is: {0}",
                ["InQueueList"] = "Players in the queue:",
                ["HelpTDM"] = "<color=#5A397A>/{0}</color><color=#5A625B> • Create a team deathmatch</color>",
                ["InMatchListGood"] = "Good Team: {0}",
                ["InMatchListEvil"] = "Evil Team: {0}",
                ["MatchNoTeamFoundCode"] = "No team could be found for you with the provided code: {0}",
                ["MatchNoTeamFoundAny"] = "No team could be found with a friend as the host. Use a code instead.",
                ["MatchPublic"] = "Your match is now open to the public.",
                ["MatchPrivate"] = "Your match is now private and requires a code, or to be a friend to join.",
                ["CannotBank"] = "You are not allowed to bank while dueling.",
                ["TargetMustBeNaked"] = "<color=red>The person you are challenging must be naked before you can challenge them.</color>",
                ["MatchKit"] = "<color=#5A397A>/{0} kit <name></color><color=#5A625B> • Changes the kit used [Host Only]</color>",
                ["MatchKitSet"] = "Kit set to: <color=yellow>{0}</color>",
                ["MatchChallenge0"] = "<color=#5A397A>/{0} <name> [kitname]</color><color=#5A625B> • Challenge another player and set the kit if specified</color>",
                ["MatchPlayerDefeated"] = "<color=silver><color=lime>{0}</color> was killed by <color=lime>{1}</color> using <color=red>{2}</color> (<color=red>{3}: {4}m</color>)</color>",
                ["CommandNotAllowed"] = "You are not allowed to use this command right now.",
                ["HelpKit"] = "<color=#5A397A>/{0} kit</color><color=#5A625B> • Pick a kit</color>",
                ["RemovedXWallsCustom"] = "Removed {0} walls due to the deletion of zones which exceed the Max Zone cap.",
                ["ZonesSetup"] = "Initialized {0} existing dueling zones.",
                ["ArenasSetup"] = "{0} existing arenas are now protected.",
                ["NoPendingRequests2"] = "You have no pending request to accept.",
                ["MatchNoLongerValid"] = "You cannot join this match anymore.",
                ["NoMatchesExistYet"] = "No matches exist yet.",
                ["UI_Accept"] = "Accept",
                ["UI_Decline"] = "Decline",
                ["UI_Kits"] = "Kits",
                ["UI_Public"] = "Public",
                ["UI_Queue"] = "Queue",
                ["UI_TDM"] = "TDM",
                ["UI_TeamSize"] = "Set Team Size: ",
                ["UI_Any"] = "Exists",
                ["UI_Help"] = "<color=#5A397A>/{0}</color><color=#5A625B> • Show Duelist User Interface</color>",
                ["ResetSeed"] = "Stats for this seed have been reset.",
                ["RematchNone"] = "No rematches are available for you.",
                ["RematchNotify"] = "A rematch is available for {0} seconds. Click Ready to join, or type /{1} ready",
                ["UI_Ready"] = "Ready",
                ["RematchAccepted"] = "You have accepted the rematch.",
                ["RematchAcceptedAlready"] = "You have accepted the rematch already!",
                ["RematchTimedOut"] = "Your rematch timed out.",
                ["RematchFailed"] = "The rematch failed to start. Not all players were ready.",
                ["RematchFailed2"] = "The rematch failed to open. Not all players are available.",
                ["RematchAutoOn"] = "You will now automatically ready up for rematches.",
                ["RematchAutoOff"] = "You will no longer automatically ready up for rematches.",
                ["UI_Respawn"] = "Respawn",
                ["UI_Requeue"] = "Requeue",
                ["BeginSpectating"] = "You are now spectating.",
                ["EndSpectating"] = "You are no longer a spectator.",
                ["UI_ReadyOn"] = "<color=red>Ready On</color>",
                ["UI_ReadyOff"] = "Ready Off",
                ["SuicideBlock"] = "<color=red>You have suicided or disconnected in a duel and must wait up to 60 seconds to duel again.</color>",
                ["ZoneRenamed"] = "Zone renamed to {0}",
                ["ZoneNames"] = "<color=#183a0e>Zone Names ({0}):</color> {1}",
                ["ZoneRename"] = "/{0} rename <name>",
                ["ZoneSet"] = "Zone set to: {0}",
                ["Prefix"] = "[ <color=#406B35>Duelist</color> ]: ",
            }, this);
        }

        public List<string> VerifiedKits
        {
            get
            {
                VerifyKits();

                var list = new List<string>();

                if (hpDuelingKits.Count > 0)
                    list.AddRange(hpDuelingKits);

                if (lpDuelingKits.Count > 0)
                    list.AddRange(lpDuelingKits);

                if (list.Count == 0 && customKits.Count > 0)
                {
                    list.AddRange(customKits.ToList().Select(kvp => kvp.Key));
                }

                list.Sort();
                return list;
            }
        }

        public string GetVerifiedKit(string kit)
        {
            string kits = string.Join(", ", VerifiedKits.ToArray());

            if (!string.IsNullOrEmpty(kits))
            {
                if (customKits.Exists(entry => entry.Key.Equals(kit, StringComparison.CurrentCultureIgnoreCase)))
                {
                    return customKits.FirstOrDefault(entry => entry.Key.Equals(kit, StringComparison.CurrentCultureIgnoreCase)).Key;
                }
                if (hpDuelingKits.Exists(entry => entry.Equals(kit, StringComparison.CurrentCultureIgnoreCase)))
                {
                    return hpDuelingKits.FirstOrDefault(entry => entry.Equals(kit, StringComparison.CurrentCultureIgnoreCase));
                }
                if (lpDuelingKits.Exists(entry => entry.Equals(kit, StringComparison.CurrentCultureIgnoreCase)))
                {
                    return lpDuelingKits.FirstOrDefault(entry => entry.Equals(kit, StringComparison.CurrentCultureIgnoreCase));
                }
            }

            return null;
        }

        private void LoadVariables()
        {
            LoadAnimalSettings();
            LoadNormalSettings();
            LoadDeviceSettings();
            LoadBetSettings();
            LoadZoneSettings();
            LoadDeployableSettings();
            LoadRankedSettings();
            LoadKitSettings();
            LoadRespawnSettings();
            LoadRewardSettings();
            LoadSpawnSettings();
            LoadDeathmatchSettings();
            LoadAdvancedSettings();
            LoadUserInterfaceSettings();
            LoadSpectatorSettings();
            RegisterCommands();
            EnsureLimits();

            canSaveConfig = true;

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        private bool canSaveConfig;

        protected override void SaveConfig()
        {
            if (canSaveConfig)
            {
                base.SaveConfig();
            }
        }

        private void LoadAnimalSettings()
        {
            putToSleep = Convert.ToBoolean(GetConfig("Animals", "Put To Sleep", true));
            killNpc = Convert.ToBoolean(GetConfig("Animals", "Die Instantly", false));
        }

        private void LoadNormalSettings()
        {
            chatSteamID = Convert.ToUInt64(GetConfig("Settings", "Chat SteamID", 0uL));
            setPlayerTime = Convert.ToBoolean(GetConfig("Settings", "Set Preferred Environment Plugin Time", false));
            removePlayers = Convert.ToBoolean(GetConfig("Settings", "Prevent Players Not Dueling From Entering The Zone", false));
            announceTime = Convert.ToSingle(GetConfig("Settings", "Announce Duel Information Every X Seconds", 1800f));
            wipeDuelZones = Convert.ToBoolean(GetConfig("Settings", "Auto Wipe Dueling Zones On Map Wipe", true));
            autoSetup = Convert.ToBoolean(GetConfig("Settings", "Auto Create Dueling Zone If Zone Does Not Exist", false));
            immunityTime = Convert.ToInt32(GetConfig("Settings", "Immunity Time", 10));
            deathTime = Convert.ToInt32(GetConfig("Settings", "Time To Duel In Minutes Before Death", 10));
            szDuelChatCommand = Convert.ToString(GetConfig("Settings", "Duel Command Name", "duel"));
            szQueueChatCommand = Convert.ToString(GetConfig("Settings", "Queue Command Name", "queue"));
            useAnnouncement = Convert.ToBoolean(GetConfig("Settings", "Allow Announcement", true));
            broadcastDefeat = Convert.ToBoolean(GetConfig("Settings", "Broadcast Defeat To All Players", true));
            damageScaleAmount = Convert.ToSingle(GetConfig("Settings", "Scale Damage Percent", 1f));
            buildingBlockExtensionRadius = Convert.ToSingle(GetConfig("Settings", "Building Block Extension Radius", 30f));
            autoAllowAll = Convert.ToBoolean(GetConfig("Settings", "Disable Requirement To Allow Duels", false));
            useRandomSkins = Convert.ToBoolean(GetConfig("Settings", "Use Random Skins", true));
            playerHealth = Convert.ToSingle(GetConfig("Settings", "Player Health After Duel [0 = disabled]", 100f));
            autoEnable = Convert.ToBoolean(GetConfig("Settings", "Auto Enable Dueling If Zone(s) Exist", false));
            bypassNewmans = Convert.ToBoolean(GetConfig("Settings", "Bypass Naked Check And Strip Items Anyway", false));
            respawnDeadDisconnect = Convert.ToBoolean(GetConfig("Settings", "Respawn Dead Players On Disconnect", true));
            resetSeed = Convert.ToBoolean(GetConfig("Settings", "Reset Temporary Ladder Each Wipe", true));
            noStability = Convert.ToBoolean(GetConfig("Settings", "No Stability On Structures", true));
            noMovement = Convert.ToBoolean(GetConfig("Settings", "No Movement During Immunity", false));
            respawnWalls = Convert.ToBoolean(GetConfig("Settings", "Respawn Zone Walls On Death", false));
            sphereAmount = Convert.ToInt32(GetConfig("Settings", "Create Dome Around Event Using Spheres (0 = disabled, recommended = 5)", 0));
            blockSpawning = Convert.ToBoolean(GetConfig("Settings", "Prevent Players From Spawning In Zone", true));
            useBlacklistCommands = Convert.ToBoolean(GetConfig("Settings", "Blacklist Commands", false));
            blacklistCommands = (GetConfig("Settings", "Blacklisted Chat Commands", BlacklistedCommands) as List<object>).Where(o => o != null && o.ToString().Length > 0).ToList().Select(o => o.ToString().ToLower()).ToList();
            useWhitelistCommands = Convert.ToBoolean(GetConfig("Settings", "Whitelist Commands", false));
            whitelistCommands = (GetConfig("Settings", "Whitelisted Chat Commands", WhitelistedCommands) as List<object>).Where(o => o != null && o.ToString().Length > 0).ToList().Select(o => o.ToString().ToLower()).ToList();
        }

        private void LoadDeviceSettings()
        {
            autoOvens = Convert.ToBoolean(GetConfig("Automatically Power On Devices", "Ovens", false));
            autoFlames = Convert.ToBoolean(GetConfig("Automatically Power On Devices", "FlameTurrets", false));
            autoTurrets = Convert.ToBoolean(GetConfig("Automatically Power On Devices", "AutoTurrets", false));
        }

        private void LoadBetSettings()
        {
            allowBetForfeit = Convert.ToBoolean(GetConfig("Betting", "Allow Bets To Be Forfeit", true));
            allowBetRefund = Convert.ToBoolean(GetConfig("Betting", "Allow Bets To Be Refunded", false));
            allowBets = Convert.ToBoolean(GetConfig("Betting", "Enabled", false));

            SetupBets();
        }

        private void LoadZoneSettings()
        {
            zoneRadius = Convert.ToSingle(GetConfig("Zone", "Zone Radius (Min: 50, Max: 300)", 50f));
            zoneCounter = Convert.ToInt32(GetConfig("Zone", "Create New Zone Every X Duels [0 = disabled]", 10));
            maxIncline = Convert.ToSingle(GetConfig("Zone", "Maximum Incline On Hills", 40f));
            zoneAmount = Convert.ToInt32(GetConfig("Zone", "Max Zones [Min 1]", 1));
            playersPerZone = Convert.ToInt32(GetConfig("Zone", "Players Per Zone [Multiple Of 2]", 10));
            visibleToAdmins = Convert.ToBoolean(GetConfig("Zone", "Players Visible To Admins", true));
            avoidWaterSpawns = Convert.ToBoolean(GetConfig("Zone", "Avoid Creating Automatic Spawn Points In Water", true));
            extraWallStacks = Convert.ToInt32(GetConfig("Zone", "Extra High External Wall Stacks", 2));
            useZoneWalls = Convert.ToBoolean(GetConfig("Zone", "Use Arena Wall Generation", true));
            zoneUseWoodenWalls = Convert.ToBoolean(GetConfig("Zone", "Use Wooden Walls", false));
            useLeastAmount = Convert.ToBoolean(GetConfig("Zone", "Create Least Amount Of Walls", false));
        }

        private void LoadDeployableSettings()
        {
            morphBarricadesStoneWalls = Convert.ToBoolean(GetConfig("Deployables", "Morph Barricades Into High External Stone Walls", false));
            morphBarricadesWoodenWalls = Convert.ToBoolean(GetConfig("Deployables", "Morph Barricades Into High External Wooden Walls", false));
        }

        private void LoadRankedSettings()
        {
            recordStats = Convert.ToBoolean(GetConfig("Ranked Ladder", "Enabled", true));
            permsToGive = Convert.ToInt32(GetConfig("Ranked Ladder", "Award Top X Players On Wipe", 3));
        }

        private void LoadRespawnSettings()
        {
            autoKitName = Convert.ToString(GetConfig("Respawn", "Give Kit If Respawn Items Are Empty", "autokit"));
            var defaultRespawn = GetConfig("Respawn", "Items", RespawnLoot) as List<object>;

            SetupRespawnItems(defaultRespawn, ref respawnLoot);
        }

        private void LoadRewardSettings()
        {
            economicsMoney = Convert.ToDouble(GetConfig("Rewards", "Economics Money [0 = disabled]", 0.0));
            serverRewardsPoints = Convert.ToInt32(GetConfig("Rewards", "ServerRewards Points [0 = disabled]", 0));
            requiredDuelMoney = Convert.ToDouble(GetConfig("Rewards", "Required Money To Duel", 0.0));
        }

        private void LoadSpawnSettings()
        {
            spDrawTime = Convert.ToSingle(GetConfig("Spawns", "Draw Time", 30f));
            spRemoveOneMaxDistance = Convert.ToSingle(GetConfig("Spawns", "Remove Distance", 10f));
            spRemoveAllMaxDistance = Convert.ToSingle(GetConfig("Spawns", "Remove All Distance", zoneRadius));
            //spRemoveInRange = Convert.ToBoolean(GetConfig("Spawns", "Remove In Duel Zone Only", false));
            spAutoRemove = Convert.ToBoolean(GetConfig("Spawns", "Auto Remove On Zone Removal", false));
        }

        private void LoadDeathmatchSettings()
        {
            dmFF = Convert.ToBoolean(GetConfig("Deathmatch", "Friendly Fire", true));
            minDeathmatchSize = Convert.ToInt32(GetConfig("Deathmatch", "Min Team Size", 2));
            maxDeathmatchSize = Convert.ToInt32(GetConfig("Deathmatch", "Max Team Size", 5));
            teamEvilShirt = Convert.ToUInt64(GetConfig("Deathmatch", "Evil Shirt Skin", 14177));
            teamGoodShirt = Convert.ToUInt64(GetConfig("Deathmatch", "Good Shirt Skin", 101));
            teamShirt = Convert.ToString(GetConfig("Deathmatch", "Shirt Shortname", "tshirt"));
            teamEconomicsMoney = Convert.ToDouble(GetConfig("Deathmatch", "Economics Money [0 = disabled]", 0.0));
            teamServerRewardsPoints = Convert.ToInt32(GetConfig("Deathmatch", "ServerRewards Points [0 = disabled]", 0));
            tdmEnabled = Convert.ToBoolean(GetConfig("Deathmatch", "Enabled", true));
            szMatchChatCommand = Convert.ToString(GetConfig("Deathmatch", "Chat Command", "tdm"));
            tdmServerDeaths = Convert.ToBoolean(GetConfig("Deathmatch", "Announce Deaths To Server", false));
            tdmMatchDeaths = Convert.ToBoolean(GetConfig("Deathmatch", "Announce Deaths To Match", true));
        }

        private void LoadAdvancedSettings()
        {
            requireTeamSize = Convert.ToBoolean(GetConfig("Advanced Options", "Require TDM Minimum Spawn Points To Be Equal Or Greater To The Number Of Players Joining", false));
            requiredMinSpawns = Convert.ToInt32(GetConfig("Advanced Options", "Require 1v1 Minimum Spawn Points To Be Equal Or Greater Than X", 2));
            requiredMaxSpawns = Convert.ToInt32(GetConfig("Advanced Options", "Require 1v1 Maximum Spawn Points To Be Less Than Or Equal To X", 200));
            allowPlayerDeaths = Convert.ToBoolean(GetConfig("Advanced Options", "Let Players Die Normally", false));
            sendDeadHome = Convert.ToBoolean(GetConfig("Advanced Options", "Send Dead Players Back Home", true));
            sendDefeatedHome = Convert.ToBoolean(GetConfig("Advanced Options", "Send Defeated Players Back Home", false));
        }

        private void LoadUserInterfaceSettings()
        {
            guiAutoEnable = Convert.ToBoolean(GetConfig("User Interface", "Auto Enable GUI For Players", false));
            szUIChatCommand = Convert.ToString(GetConfig("User Interface", "Chat Command", "dui"));
            guiUseCursor = Convert.ToBoolean(GetConfig("User Interface", "Use Cursor", false));
            guiUseCloseButton = Convert.ToBoolean(GetConfig("User Interface", "Show Close Button (X)", true));
            guiAnnounceUITime = Convert.ToSingle(GetConfig("User Interface", "Show Defeat Message UI For X Seconds", 7.5f));
            sendHomeRequeue = Convert.ToBoolean(GetConfig("User Interface", "Send Spectators Home FirstOrDefault When Clicking Requeue", false));
        }

        private void LoadSpectatorSettings()
        {
            sendHomeSpectatorWhenRematchTimesOut = Convert.ToBoolean(GetConfig("Spectators", "Send Home If Rematch Times Out", false));
        }

        private void RegisterCommands()
        {
            if (!permission.PermissionExists(duelistPerm)) // prevent warning
                permission.RegisterPermission(duelistPerm, this);

            permission.CreateGroup(duelistGroup, duelistGroup, 0);
            permission.GrantGroupPermission(duelistGroup, duelistPerm, this);

            AddCovalenceCommand("duelist", nameof(CommandDuelist));

            if (!string.IsNullOrEmpty(szDuelChatCommand))
            {
                cmd.AddChatCommand(szDuelChatCommand, this, cmdDuel);
                cmd.AddConsoleCommand(szDuelChatCommand, this, nameof(ccmdDuel));
                whitelistCommands.Add(szDuelChatCommand.ToLower());
            }

            if (!string.IsNullOrEmpty(szQueueChatCommand))
                cmd.AddChatCommand(szQueueChatCommand, this, cmdQueue);

            if (tdmEnabled && !string.IsNullOrEmpty(szMatchChatCommand))
            {
                cmd.AddChatCommand(szMatchChatCommand, this, cmdTDM);
                whitelistCommands.Add(szMatchChatCommand.ToLower());
            }

            if (!string.IsNullOrEmpty(szUIChatCommand))
            {
                cmd.AddChatCommand(szUIChatCommand, this, cmdDUI);
                cmd.AddConsoleCommand(szUIChatCommand, this, nameof(ccmdDUI));
            }
        }

        private void SetupBets()
        {
            var bets = GetConfig("Betting", "Bets", DefaultBets) as List<object>;

            foreach (var bet in bets)
            {
                duelingBets.Add(JsonConvert.DeserializeObject<BetInfo>(JsonConvert.SerializeObject(bet)));
            }
        }

        private void LoadKitSettings()
        {
            var kits = GetConfig("Settings", "Kits", DefaultKits) as List<object>;

            if (kits != null && kits.Count > 0)
            {
                foreach (object obj in kits)
                {
                    var kit = Convert.ToString(obj);

                    if (!string.IsNullOrEmpty(kit) && !hpDuelingKits.Contains(kit))
                    {
                        hpDuelingKits.Add(kit); // 0.1.14 fix
                        _hpDuelingKits.Add(kit); // 0.1.17 clone for Least Used Chance compatibility
                    }
                }
            }

            lesserKitChance = Convert.ToSingle(GetConfig("Settings", "Kits Least Used Chance", 0.25f));

            var lesserKits = GetConfig("Settings", "Kits Least Used", DefaultLesserKits) as List<object>;

            foreach (object obj in lesserKits)
            {
                var kit = Convert.ToString(obj);

                if (!string.IsNullOrEmpty(kit) && !lpDuelingKits.Contains(kit))
                {
                    lpDuelingKits.Add(kit); // 0.1.16
                    _lpDuelingKits.Add(kit); // 0.1.17 clone for Least Used Chance compatibility
                }
            }

            useWorkshopSkins = Convert.ToBoolean(GetConfig("Custom Kits", "Use Workshop Skins", true));

            var defaultKits = GetConfig("Custom Kits", "Kits", DefaultCustomKits) as Dictionary<string, object>;

            SetupCustomKits(defaultKits, ref customKits);
        }

        private void EnsureLimits()
        {
            if (buildingBlockExtensionRadius < 20f)
                buildingBlockExtensionRadius = 20f;

            if (zoneAmount < 1)
                zoneAmount = 1;

            if (playersPerZone < 2)
                playersPerZone = 2;
            else if (playersPerZone % 2 != 0)
                playersPerZone++;

            if (immunityTime < 0)
                immunityTime = 0;

            if (zoneRadius < 50f)
                zoneRadius = 50f;
            else if (zoneRadius > 300f)
                zoneRadius = 300f;

            if (requiredMinSpawns < 2)
                requiredMinSpawns = 2;

            if (requiredMaxSpawns < 2)
                requiredMaxSpawns = 2;

            if (guiAnnounceUITime < 1f)
                guiAnnounceUITime = 1f;
        }

        private void SetupDefinitions()
        {
            foreach (var itemDef in ItemManager.GetItemDefinitions())
            {
                var mod = itemDef.GetComponent<ItemModDeployable>();

                if (mod == null)
                {
                    continue;
                }

                bool externalWall = mod.entityPrefab.resourcePath.Contains("external") && mod.entityPrefab.resourcePath.Contains("wall");
                bool barricade = mod.entityPrefab.resourcePath.Contains("barricade");
                bool isLadder = mod.entityPrefab.resourcePath.Contains("ladder.wooden.wall");

                if (externalWall || barricade || isLadder)
                {
                    bool value = Convert.ToBoolean(GetConfig("Deployables", string.Format("Allow {0}", itemDef.displayName.translated), false));

                    if (!value)
                        continue;

                    deployables[itemDef.displayName.translated] = value;
                    prefabs[mod.entityPrefab.resourcePath] = itemDef.displayName.translated;
                }
            }
            if (Changed)
            {
                SaveConfig();
            }
        }

        private void SetupRespawnItems(List<object> list, ref List<DuelKitItem> source)
        {
            foreach (var entry in list)
            {
                source.Add(JsonConvert.DeserializeObject<DuelKitItem>(JsonConvert.SerializeObject(entry)));
            }
        }

        private void SetupCustomKits(Dictionary<string, object> dict, ref Dictionary<string, List<DuelKitItem>> source)
        {
            foreach (var entry in dict)
            {
                source[entry.Key] = JsonConvert.DeserializeObject<List<DuelKitItem>>(JsonConvert.SerializeObject(entry.Value));
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
            LoadVariables();
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        private Dictionary<string, string> hexColors = new Dictionary<string, string>
        {
            ["<color=blue>"] = "<color=#0000FF>",
            ["<color=red>"] = "<color=#FF0000>",
            ["<color=yellow>"] = "<color=#FFFF00>",
            ["<color=lightblue>"] = "<color=#ADD8E6>",
            ["<color=orange>"] = "<color=#FFA500>",
            ["<color=silver>"] = "<color=#C0C0C0>",
            ["<color=magenta>"] = "<color=#FF00FF>",
            ["<color=green>"] = "<color=#008000>",
            ["<color=lime>"] = "<color=#00FF00>",
        };

        private string msg(string key, string id = null, params object[] args)
        {
            var sb = new System.Text.StringBuilder(id == null ? RemoveFormatting(lang.GetMessage(key, this, id)) : lang.GetMessage(key, this, id));
            var str = sb.ToString();

            foreach (var entry in hexColors)
            {
                if (str.Contains(entry.Key))
                {
                    sb.Replace(entry.Key, entry.Value);
                }
            }

            return args.Length > 0 ? string.Format(sb.ToString(), args) : sb.ToString();
        }

        public string RemoveFormatting(string source)
        {
            return source.Contains(">") ? Regex.Replace(source, "<.*?>", string.Empty) : source;
        }

        public static void Message(BasePlayer player, string message)
        {
            Instance.Player.Message(player, message, Instance.chatSteamID);
        }

        public void Message(HashSet<BasePlayer> players, string key, params object[] args)
        {
            foreach (var player in players)
            {
                if (IsNotConnected(player)) continue;
                Message(player, msg(key, player.UserIDString, args ?? new string[0]));
            }
        }

        #endregion
    }
}

namespace Oxide.Plugins.DuelistExtensionMethods
{
    public static class ExtensionMethods
    {
        public static bool All<T>(this IEnumerable<T> a, Func<T, bool> b) { using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (!b(c.Current)) { return false; } } } return true; }
        public static T ElementAt<T>(this IEnumerable<T> a, int b) { using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (b == 0) { return c.Current; } b--; } } return default(T); }
        public static bool Exists<T>(this IEnumerable<T> a, Func<T, bool> b = null) { using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (b == null || b(c.Current)) { return true; } } } return false; }
        public static T FirstOrDefault<T>(this IEnumerable<T> a, Func<T, bool> b = null) { using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (b == null || b(c.Current)) { return c.Current; } } } return default(T); }
        public static IEnumerable<T> Select<Y, T>(this IList<Y> a, Func<Y, T> b) { var c = new List<T>(); for (int i = 0; i < a.Count; i++) { c.Add(b(a[i])); } return c; }
        public static string[] Skip(this string[] a, int b) { if (a.Length == 0) { return Array.Empty<string>(); } string[] c = new string[a.Length - b]; int n = 0; for (int i = 0; i < a.Length; i++) { if (i < b) continue; c[n] = a[i]; n++; } return c; }
        public static List<T> Take<T>(this IList<T> a, int b) { var c = new List<T>(); for (int i = 0; i < a.Count; i++) { if (c.Count == b) { break; } c.Add(a[i]); } return c; }
        public static List<T> ToList<T>(this IEnumerable<T> a) { var b = new List<T>(); using (var c = a.GetEnumerator()) { while (c.MoveNext()) { b.Add(c.Current); } } return b; }
        public static IEnumerable<T> Where<T>(this IEnumerable<T> a, Func<T, bool> b) { var c = new List<T>(); using (var d = a.GetEnumerator()) { while (d.MoveNext()) { if (b(d.Current)) { c.Add(d.Current); } } } return c; }
        public static bool IsHuman(this BasePlayer a) => a != null && a.userID.IsSteamId();
        public static List<T> OfType<T>(this IEnumerable<BaseNetworkable> a) where T : BaseNetworkable { var b = new List<T>(); using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (c.Current is T) { b.Add(c.Current as T); } } } return b; }
        public static int Sum<T>(this IEnumerable<T> a, Func<T, int> b) { int c = 0; foreach (T d in a) { c += b(d); } return c; }
        public static bool IsKilled(this BaseNetworkable a) => a == null || a.IsDestroyed || !a.IsFullySpawned();
        public static void SafelyKill(this BaseNetworkable a) { if (a == null || a.IsDestroyed) { return; } a.Kill(BaseNetworkable.DestroyMode.None); }
        public static bool CanCall(this Plugin a) { return a != null && a.IsLoaded; }
    }
}

// --- End of file: Duelist.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/decay-notifications ---
// --- Original File Path: D/DecayNotifications/DecayNotifications.cs ---

﻿using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("DecayNotifications", "Ankawi", "1.0.2")]
    [Description("Automatic decay notifications and a command for upkeep status in minutes.")]
    class DecayNotifications : RustPlugin
    {
        [PluginReference] Plugin HelpText;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating new configuration file for " + this.Title + "--Version#: " + this.Version);
            Config.Clear();
            Config["AutomaticNotificationsEnabled"] = true;
            Config["NotificationIntervalInMinutes"] = 10f;
            Config["MinutesLeftNeededToSendNotification"] = 30f;
            SaveConfig();
        }
        private void Init()
        {
            LoadConfig();
            permission.RegisterPermission("decaynotifications.use", this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PrimaryDecayNotification"] = "<color=#00FF00>DecayNotifications</color>" +
                "<color=#00FFFF>: Your base is going to decay in <color=#00FF00>{0}</color> minutes </color>",
                ["FinalDecayNotification"] = "<color=#00FF00>DecayNotifications</color>" +
                "<color=#00FFFF>: You have no items in your tool cupboard and your base has started to decay!</color>",
                ["NoPriviledge"] = "<color=#00FF00>DecayNotifications</color>" +
                "<color=#00FFFF>: You do not have any building priviledge</color>",
                ["NoPermission"] = "<color=#00FF00>DecayNotifications</color>" +
                "<color=#00FFFF>: You do not have permission to use this command",
                ["HelpTextAPI"] = "<color=#FFFF00>/tcstatus - Check the amount of minutes left you have before your tool cupboard decays!</color>"
            }, this, "en");
            SendNotifications();

        }
        private void SendNotifications()
        {
            if ((bool)Config["AutomaticNotificationsEnabled"])
            {
                timer.Repeat(Convert.ToSingle(Config["NotificationIntervalInMinutes"]) * 60, 0, () =>
                {
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        BuildingPrivlidge priv = player.GetBuildingPrivilege();
                        if (!priv) return;
                        if (!priv.IsAuthed(player) || !player.IsAdmin) return;
                        float minutesLeft = priv.GetProtectedMinutes();

                        if (minutesLeft < Convert.ToSingle(Config["MinutesLeftNeededToSendNotification"]) && minutesLeft > 0f)
                        {
                            PrintToChat(player, String.Format(lang.GetMessage("PrimaryDecayNotification", this, player.UserIDString), minutesLeft));
                        }
                        else if (minutesLeft == 0f)
                        {
                            PrintToChat(player, lang.GetMessage("FinalDecayNotification", this, player.UserIDString));
                        }
                    }
                });
            }
        }
        [ChatCommand("tcstatus")]
        void TcstatusCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "decaynotifications.use")) {
                PrintToChat(player, lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }
            BuildingPrivlidge priviledge = player.GetBuildingPrivilege();

            if (!priviledge) {
                PrintToChat(player, lang.GetMessage("NoPriviledge", this, player.UserIDString));
                return;
            }
            if (!priviledge.IsAuthed(player) || !player.IsAdmin) return;

            float minutesLeft = priviledge.GetProtectedMinutes();
            if (minutesLeft > 0f)
            {
                PrintToChat(player, String.Format(lang.GetMessage("PrimaryDecayNotification", this, player.UserIDString), minutesLeft));
            }
            else if (minutesLeft == 0)
            {
                PrintToChat(player, lang.GetMessage("FinalDecayNotification", this, player.UserIDString));
            }
            return;
        }
        private void SendHelpText(BasePlayer player)
        {
            player.ChatMessage(lang.GetMessage("HelpTextAPI", this, player.UserIDString));
        }
    }
}

// --- End of file: DecayNotifications.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-status ---
// --- Original File Path: D/DiscordStatus/DiscordStatus.cs ---

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Entities.Activities;
using Oxide.Ext.Discord.Entities.Applications;
using Oxide.Ext.Discord.Entities.Channels;
using Oxide.Ext.Discord.Entities.Gatway;
using Oxide.Ext.Discord.Entities.Gatway.Commands;
using Oxide.Ext.Discord.Entities.Gatway.Events;
using Oxide.Ext.Discord.Entities.Guilds;
using Oxide.Ext.Discord.Entities.Messages;
using Oxide.Ext.Discord.Entities.Messages.Embeds;
using Oxide.Ext.Discord.Entities.Permissions;
using Oxide.Ext.Discord.Libraries.Linking;
using Oxide.Ext.Discord.Logging;
using Random = Oxide.Core.Random;

namespace Oxide.Plugins
{
    [Info("Discord Status", "Gonzi", "4.0.1")]
    [Description("Shows server information as a discord bot status")]

    public class DiscordStatus : CovalencePlugin
    {
        private string seperatorText = string.Join("-", new string[25 + 1]);
        private bool enableChatSeparators;

        #region Fields

        [DiscordClient]
        private DiscordClient Client;

        private readonly DiscordSettings _settings = new DiscordSettings
        {
            Intents = GatewayIntents.Guilds | GatewayIntents.GuildMessages | GatewayIntents.GuildMembers
        };
        
        private DiscordGuild _guild;
        
        private readonly DiscordLink _link = GetLibrary<DiscordLink>();

        Configuration config;
        private int statusIndex = -1;
        private string[] StatusTypes = new string[]
        {
            "Game",
            "Stream",
            "Listen",
            "Watch"
        };

        #endregion

        #region Config
        class Configuration
        {
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string BotToken = string.Empty;
            
            [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
            public Snowflake GuildId { get; set; }

            [JsonProperty(PropertyName = "Prefix")]
            public string Prefix = "!";

            [JsonProperty(PropertyName = "Discord Group Id needed for Commands (null to disable)")]
            public Snowflake? GroupId;

            [JsonProperty(PropertyName = "Update Interval (Seconds)")]
            public int UpdateInterval = 5;

            [JsonProperty(PropertyName = "Randomize Status")]
            public bool Randomize = false;

            [JsonProperty(PropertyName = "Status Type (Game/Stream/Listen/Watch)")]
            public string StatusType = "Game";

            [JsonProperty(PropertyName = "Status", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Status = new List<string>
            {
                "{players.online} / {server.maxplayers} Online!",
                "{server.entities} Entities",
                "{players.sleepers} Sleepers!",
                "{players.authenticated} Linked Account(s)"
            };
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; } = DiscordLogLevel.Info;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                Config.WriteObject(config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonError");
                PrintError("The configuration file contains an error and has been replaced with a default config.\n" +
                           "The error configuration file was saved in the .jsonError extension");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Title"] = "Players List",
                ["Players"] = "Online Players [{0}/{1}] 🎆\n {2}",
                ["IPAddress"] = "steam://connect/{0}:{1}"

            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Title"] = "플레이어 목록",
                ["Players"] = "접속중인 플레이어 [{0}/{1}] 🎆\n {2}",
                ["IPAddress"] = "steam://connect/{0}:{1}"
            }, this, "kr");
        }

        private string Lang(string key, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this), args);
        }

        #endregion

        #region Discord
        public DiscordEmbed ServerStats(string content)
        {
            DiscordEmbed embed = new DiscordEmbed
            {
                Title = Lang("Title", ConVar.Server.hostname),
                Description = content,
                Thumbnail = new EmbedThumbnail
                {
                    Url = $"{ConVar.Server.headerimage}"
                },
                Footer = new EmbedFooter
                {
                    Text = $"Gonzi V{Version}",
                    IconUrl = "https://cdn.discordapp.com/avatars/321373026488811520/08f996472c573473e7e30574e0e28da0.png"
                },

                Color = new DiscordColor(15158332)
            };
            return embed;
        }
        
        [HookMethod(DiscordHooks.OnDiscordGuildMessageCreated)]
        void OnDiscordGuildMessageCreated(DiscordMessage message)
        {
            if (message.Author.Bot == true) return;


            if (message.Content[0] == config.Prefix[0])
            {

                string cmd;
                try
                {
                    cmd = message.Content.Split(' ')[0].ToLower();
                    if (string.IsNullOrEmpty(cmd.Trim()))
                        cmd = message.Content.Trim().ToLower();
                }
                catch
                {
                    cmd = message.Content.Trim().ToLower();
                }

                cmd = cmd.Remove(0, 1);

                cmd = cmd.Trim();
                cmd = cmd.ToLower();

                DiscordCMD(cmd, message);
            }
        }

        private void DiscordCMD(string command, DiscordMessage message)
        {
            if (config.GroupId.HasValue && !message.Member.Roles.Contains(config.GroupId.Value)) return;

            switch (command)
            {
                case "players":
                    {
                        string maxplayers = Convert.ToString(ConVar.Server.maxplayers);
                        string onlineplayers = Convert.ToString(BasePlayer.activePlayerList.Count);
                        string list = string.Empty;
                        var playerList = BasePlayer.activePlayerList;
                        foreach (var player in playerList)
                        {
                            list += $"[{player.displayName}](https://steamcommunity.com/profiles/{player.UserIDString}/) \n";
                        }

                        DiscordChannel.GetChannel(Client, message.ChannelId, channel =>
                        {
                            channel.CreateMessage(Client, ServerStats(Lang("Players", BasePlayer.activePlayerList.Count, ConVar.Server.maxplayers, list)));
                        });
                        break;
                    }
                case "ip":
                    {
                        DiscordChannel.GetChannel(Client, message.ChannelId, channel =>
                        {
                            webrequest.Enqueue("http://icanhazip.com", "", (code, response) =>
                            {
                                string ip = response.Trim();
                                channel.CreateMessage(Client, Lang("IPAddress", ip, ConVar.Server.port));
                            }, this);
                        });
                    }
                    break;
            }
        }

        #endregion

        #region Oxide Hooks
        private void OnServerInitialized()
        {
            lang.SetServerLanguage("en");

            if (config.BotToken == string.Empty)
                return;

            _settings.ApiToken = config.BotToken;
            _settings.LogLevel = config.ExtensionDebugging;
            Client.Connect(_settings);

            timer.Every(config.UpdateInterval, () => UpdateStatus());
        }
        
        [HookMethod(DiscordHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            if (ready.Guilds.Count == 0)
            {
                PrintError("Your bot was not found in any discord servers. Please invite it to a server and reload the plugin.");
                return;
            }

            DiscordGuild guild = null;
            if (ready.Guilds.Count == 1 && !config.GuildId.IsValid())
            {
                guild = ready.Guilds.Values.FirstOrDefault();
            }

            if (guild == null)
            {
                guild = ready.Guilds[config.GuildId];
            }

            if (guild == null)
            {
                PrintError("Failed to find a matching guild for the Discord Server Id. " +
                           "Please make sure your guild Id is correct and the bot is in the discord server.");
                return;
            }
                
            if (Client.Bot.Application.Flags.HasValue && !Client.Bot.Application.Flags.Value.HasFlag(ApplicationFlags.GatewayGuildMembersLimited))
            {
                PrintError($"You need to enable \"Server Members Intent\" for {Client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n" +
                           $"{Name} will not function correctly until that is fixed. Once updated please reload {Name}.");
                return;
            }
            
            _guild = guild;
        }
        #endregion

        #region Discord Hooks

        #endregion

        #region Status Update
        private void UpdateStatus()
        {
            try
            {
                if (config.Status.Count == 0)
                    return;

                var index = GetStatusIndex();

                Client.Bot.UpdateStatus(new UpdatePresenceCommand
                {
                    Activities = new List<DiscordActivity>
                    {
                        new DiscordActivity
                        {
                            Name = Format(config.Status[index]),
                            Type = ActivityType.Game
                        }
                    }
                });

                statusIndex = index;
            }
            catch (Exception err)
            {
                LogToFile("DiscordStatus", $"{err}", this);
            }
        }
        #endregion

        #region Helper Methods
        private int GetStatusIndex()
        {
            if (!config.Randomize)
                return (statusIndex + 1) % config.Status.Count;

            var index = 0;
            do index = Random.Range(0, config.Status.Count - 1);
            while (index == statusIndex);

            return index;
        }

        private ActivityType GetStatusType()
        {
            if (!StatusTypes.Contains(config.StatusType))
                PrintError($"Unknown Status Type '{config.StatusType}'");

            switch (config.StatusType)
            {
                case "Game":
                    return ActivityType.Game;
                case "Stream":
                    return ActivityType.Streaming;
                case "Listen":
                    return ActivityType.Listening;
                case "Watch":
                    return ActivityType.Watching;
                default:
                    return default(ActivityType);
            }
        }

        private string Format(string message)
        {
            message = message
                .Replace("{guild.name}", _guild.Name ?? "{unknown}")
                .Replace("{members.total}", _guild.MemberCount?.ToString() ?? "{unknown}")
                .Replace("{channels.total}", _guild.Channels?.Count.ToString() ?? "{unknown}")
                .Replace("{server.hostname}", server.Name)
                .Replace("{server.maxplayers}", server.MaxPlayers.ToString())
                .Replace("{players.online}", players.Connected.Count().ToString())
                .Replace("{players.authenticated}", GetAuthCount().ToString());

#if RUST
        message = message
            .Replace("{server.ip}", ConVar.Server.ip)
            .Replace("{server.port}", ConVar.Server.port.ToString())
            .Replace("{server.entities}", BaseNetworkable.serverEntities.Count.ToString())
            .Replace("{server.worldsize}", ConVar.Server.worldsize.ToString())
            .Replace("{server.seed}", ConVar.Server.seed.ToString())
            .Replace("{server.fps}", Performance.current.frameRate.ToString())
            .Replace("{server.avgfps}", Convert.ToInt32(Performance.current.frameRateAverage).ToString())
            .Replace("{players.queued}", ConVar.Admin.ServerInfo().Queued.ToString())
            .Replace("{players.joining}", ConVar.Admin.ServerInfo().Joining.ToString())
            .Replace("{players.sleepers}", BasePlayer.sleepingPlayerList.Count.ToString())
            .Replace("{players.total}", (players.Connected.Count() + BasePlayer.sleepingPlayerList.Count).ToString());
#endif

            return message;
        }

        private int GetAuthCount() => _link.GetLinkedCount();

        #endregion
    }
}

// --- End of file: DiscordStatus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/door-permissions ---
// --- Original File Path: D/DoorPermissions/DoorPermissions.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Oxide.Core.Plugins;
using UnityEngine;
using Physics = UnityEngine.Physics;

namespace Oxide.Plugins
{
    [Info("Door Permissions", "TheForbiddenAi", "2.0.0"),
     Description("Allows admins to lock doors to specific permissions.")]
    public class DoorPermissions : RustPlugin
    {
        #region Fields

        private readonly DynamicConfigFile _dataFile = Interface.Oxide.DataFileSystem.GetDatafile("DoorPermissions");
        private ConfigData _configData;

        private const BUTTON SelectDoorButton = BUTTON.FIRE_PRIMARY;

        private const string DoorPermPrefix = "doorpermissions.door.";
        private const string LockDoorPerm = "doorpermissions.lockdoor";
        private const string UnlockDoorPerm = "doorpermissions.unlockdoor";
        private const string ActivateDoorPerm = "doorpermissions.activatedoor";
        private const string DeactivateDoorPerm = "doorpermissions.deactivatedoor";
        private const string ViewDoorInfoPerm = "doorpermissions.viewdoorinfo";
        private const string SetDoorNamePerm = "doorpermissions.setdoorname";
        private const string SetTeleportDoorPerm = "doorpermissions.setteleportdoor";
        private const string SetTeleportPointPerm = "doorpermissions.setteleportpoint";
        private const string SetCategoryPerm = "doorpermissions.setcategory";
        private const string SetCategoryNamePerm = "doorpermissions.setcategoryname";
        private const string AddCategoryPermPerm = "doorpermissions.addcategoryperm";
        private const string RemoveCategoryPermPerm = "doorpermissions.removecategoryperm";
        private const string CreateCategoryPerm = "doorpermissions.createcategory";
        private const string DeleteCategoryPerm = "doorpermissions.deletecategory";
        private const string ViewCategoryInfoPerm = "doorpermissions.viewcategoryinfo";
        private const string ViewCategoriesPerm = "doorpermissions.viewcategories";

        private List<string> _zDoorFronts = new List<string>();
        private List<string> _positiveEntrances = new List<string>();

        private enum DoorActions
        {
            Lock,
            Unlock,
            Activate,
            Deactivate,
            ViewInfo,
            SetDoorName,
            SetTeleportDoor,
            CreatingTelePoint,
            SettingDoorCategory
        }

        private string _version;

        #endregion

        #region Config

        private class ConfigData
        {
            // Default values exist in the scenario that someone messes up their config keys, the code will still execute
            [JsonProperty(PropertyName = "Date File Version - DO NOT MODIFY")]
            public string DataFileVersion = "1.0.1";

            [JsonProperty(PropertyName = "Send No Permissons Message When Opening Door Without Required Permissions")]
            public bool SendInsufficientPerms = false;

            [JsonProperty(PropertyName = "Allow Damage To Locked Doors")]
            public bool AllowDamage = false;

            [JsonProperty(PropertyName = "Should Delete Doors On Category Deletion")]
            public bool ShouldDeleteDoors = false;

            public static ConfigData DefaultConfig()
            {
                return new ConfigData()
                {
                    DataFileVersion = "2.0.0",
                    SendInsufficientPerms = true,
                    AllowDamage = false,
                    ShouldDeleteDoors = false
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _configData = Config.ReadObject<ConfigData>();
            if (_configData == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private ConfigData GetDefaultConfig()
        {
            return ConfigData.DefaultConfig();
        }

        private void SaveConfig()
        {
            Config.WriteObject(_configData, true);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Insufficient Permissions"] =
                    "<color=red>You do not have the required permission to do this action!</color>",
                ["Invalid Syntax"] = "<color=red>Invalid Syntax:</color> <color=white>{0}</color>",
                ["Lock Door Syntax"] = "/lockdoor <permissions...> [note: {0} is implied in the permission]",
                ["Set Door Name Syntax"] = "/setdoorname <name>",
                ["Set Category Syntax"] = "/setcategory <id>",
                ["Set Category Name Syntax"] = "/setcategoryname <id> <name>",
                ["Add Category Perm Syntax"] =
                    "/addcategoryperm <id> <permissions...> [note: {0} is implied in the permission]",
                ["Remove Category Perm Syntax"] =
                    "/removecategoryperm <id> <permissions...> [note: {0} is implied in the permission]",
                ["Create Category Syntax"] =
                    "/createcategory <name> (permissions...) [note: {0} is implied in the permission]",
                ["Delete Category Syntax"] = "/deletecategory <id>",
                ["View Category Info Syntax"] = "/viewcategoryinfo <id>",
                ["Entered Locking Process"] =
                    "<color=#00ffffff>Look at a door and, use your primary attack keybind, to lock it, to cancel run /lockdoor!</color>",
                ["Entered Unlocking Process"] =
                    "<color=#00ffffff>Look at a door and, use your primary attack keybind, to unlock it, to cancel run /unlockdoor!</color>",
                ["Entered Activation Process"] =
                    "<color=#00ffffff>Look at a door and, use your primary attack keybind, to activate it, to cancel run /activatedoor!</color>",
                ["Entered Deactivation Process"] =
                    "<color=#00ffffff>Look at a door and, use your primary attack keybind, to deactivate it, to cancel run /deactivatedoor!</color>",
                ["Entered View Info Process"] =
                    "<color=#00ffffff>Look at a door and, use your primary attack keybind, to view it's information, to cancel run /viewdoorinfo!</color>",
                ["Entered Set Door Name Process"] =
                    "<color=#00ffffff>Look at a door and, use your primary attack keybind, to set it's name, to cancel run /setdoorname!</color>",
                ["Entered Set Tele Door Process"] =
                    "<color=#00ffffff>Look at a door and, use your primary attack keybind," +
                    " to make it a teleportation door, to cancel run /setteleportdoor!</color>",
                ["Entered Set Tele Point Process"] =
                    "<color=#00ffffff>Look at a door and, use your primary attack keybind, " +
                    "to create a teleportation point, to cancel run /setteleportpoint!</color>",
                ["Entered Set Category Process"] =
                    "<color=#00ffffff>Look at a door and, use your primary attack keybind, to set its category, to cancel run /setcategory!</color>",
                ["Door Locked"] = "<i>Door has been locked to the permission(s):</i> <color=green>{0}</color>",
                ["Door Locked New Permissions"] =
                    "<i>Door has been locked to the permission(s):</i> <color=green>{0}</color> <i>(prexisiting permissions still remain)</i>",
                ["Door Unlocked"] =
                    "<i>This door is no longer locked to the following permission(s):</i> <color=green>{0}</color>",
                ["Door Activated"] = "<color=green>This door is now activated!</color>",
                ["Door Deactivated"] =
                    "<color=green>This door is now</color> <color=red>deactivated</color><color=green>!</color>",
                ["Set Door Name"] =
                    "<color=green>Successfully changed the door's name to</color> {0}<color=green>!</color>",
                ["Set Tele Door"] = "<color=green>This door is now a teleportation door!</color>",
                ["Removed Tele Door"] = "<color=green>This door is no longer a teleportation door!</color>",
                ["Set Tele Point"] = "<color=green>Set Teleportation Point at</color> {0}",
                ["Set Category Name"] =
                    "<color=green>Successfully changed category name to</color> {0}<color=green>!</color>",
                ["Category Locked New Permissions"] =
                    "<i>The given category has been locked to the permission(s):</i> <color=green>{0}</color> <i>(prexisiting permissions still remain)</i>",
                ["Category Set"] =
                    "<color=green>Successfully changed the category to the category with an id of</color> {0}<color=green>!</color>",
                ["Category Unlocked"] =
                    "<i>The given category is no longer locked to the following permission(s):</i> <color=green>{0}</color>",
                ["Category Created"] =
                    "<color=green>Successfully created a category with the name of</color> {0}<color=green>!</color>",
                ["Category Deleted"] =
                    "<color=green>Successfully deleted the category with the id of</color> {0}<color=green>!</color>",
                ["Exited Process"] = "<color=green>Successfully exited the previous process!</color>",

                ["Locked To Category Not Door"] =
                    "<color=red>This door is not locked to the permission:</color> <i>{0}<i>, but it's category is! Continuing with remaining permissions.",
                ["View Door Info Format"] =
                    "<color=yellow>Door Name:</color> {0},\n<color=yellow>Category Id:</color> {1}," +
                    "\n<color=yellow>Door Active:</color> {2},\n<color=yellow>Permission List(Does not include category permissions):</color> {3}",
                ["View Category Info Format"] =
                    "<color=yellow>Category Name:</color> {0},\n<color=yellow>Category Id:</color> {1}," +
                    "\n<color=yellow>Permission List(Does not include any door permissions):</color> {2}",
                ["View Categories Format"] = "<color=yellow>Id:</color> {0}, <color=yellow>Name:</color> {1},\n",
                ["Failed To Create Codelock"] =
                    "<color=red>Failed to create code lock entity, please try again.</color>",
                ["Time Ended"] = "<color=yellow>The time period to select a door has ended!</color>",
                ["Not A Door"] =
                    "<color=red>You are either too far from the door or the entity you are looking at is not a door!</color>",
                ["Door Not Locked"] = "<color=red>This door is not currently locked to any permission!</color>",
                ["Door Is Not Locked To That Permission"] =
                    "<color=red>This door is not locked to the permission:</color> <i>{0}</i> " +
                    "<color=red>continuing with remaining permissions!</color>",
                ["Door Already Locked"] =
                    "<color=red>This door is already locked to the permission:</color> {0} </color>continuing with remaining permissions</color>",
                ["Door Already Activated"] = "<color=red>This door is already activated!</color>",
                ["Door Already Deactivated"] = "<color=red>This door is already deactivated!</color>",
                ["Door Already Has Name"] = "<color=red>This door is already has that name!</color>",
                ["Not A Category"] = "<color=red>There is no category with the id</color> {0}<color=red>!</color>",
                ["Not A Number"] = "<color=red>That is not a valid id, ids are only numbers!</color>",
                ["Already Has Category"] =
                    "<color=red>The selected door already has the category with an id of</color> {0}<color=green>!</color>",
                ["Category Already Locked"] =
                    "<color=red>That category is already locked to the permission:</color> {0} </color>continuing with remaining permissions</color>",
                ["Category Already Has Name"] = "<color=red>That category already has that name!</color>",
                ["Can Not Delete Default Category"] = "<color=red>You can not delete the default category!</color>",
                ["Category Is Not Locked To That Permission"] =
                    "<color=red>That category is not locked to the permission:</color> <i>{0}</i> " +
                    "<color=red>continuing with remaining permissions!</color>",
                ["No Categories Found"] = "<color=red>Uh Oh! There are no categories to display.</color>"
            }, this);
        }

        private string GetMessage(string key, BasePlayer player, params object[] args) =>
            string.Format(lang.GetMessage(key, this, player.UserIDString), args);

        #endregion

        #region Initalization

        private void Init()
        {
            _version = Version.ToString();

            if (_configData.AllowDamage)
            {
                Unsubscribe("OnEntityTakeDamage");
            }

            RegisterPermissions(
                LockDoorPerm,
                UnlockDoorPerm,
                ActivateDoorPerm,
                DeactivateDoorPerm,
                ViewDoorInfoPerm,
                SetDoorNamePerm,
                SetTeleportDoorPerm,
                SetTeleportPointPerm,
                SetCategoryPerm,
                SetCategoryNamePerm,
                AddCategoryPermPerm,
                RemoveCategoryPermPerm,
                CreateCategoryPerm,
                DeleteCategoryPerm,
                ViewCategoryInfoPerm,
                ViewCategoriesPerm
            );

            string dataFileVersion = _configData.DataFileVersion;
            
            if (!dataFileVersion.Equals(_version))
            {
                UpdateDataFile(dataFileVersion);
            }
            

            CacheDataObjects();
            InitializeQuaternionLists();
        }

        private void CacheDataObjects()
        {
            Dictionary<string, object> categoryJson = _dataFile["Categories"] as Dictionary<string, object>;
            if (categoryJson == null)
            {
                Puts("Invalid Data File!");
                return;
            }

            foreach (KeyValuePair<string, object> pair in categoryJson)
            {
                string catJson = JsonConvert.SerializeObject(pair.Value);
                CategoryObject category = JsonConvert.DeserializeObject<CategoryObject>(catJson);

                category.Id = int.Parse(pair.Key);
                category.Doors.ForEach(door =>
                {
                    door.Category = category;
                    RegisterPermissions(door.GetAllPermissions().ToArray());
                    DoorObject.AddDoors(door);
                });

                CategoryObject.AddCategory(category);
            }
        }

        private void UpdateDataFile(string oldVersion)
        {
            switch (oldVersion)
            {
                case "1.0.1":
                    int catId = 0;

                    List<DoorObject> doors = new List<DoorObject>();

                    foreach (KeyValuePair<string, object> pair in _dataFile)
                    {
                        DoorObject doorObj = new DoorObject();

                        string[] coords = Regex.Replace(pair.Key, @"[^0-9,.-]", "").Split(',');

                        doorObj.Position = new Vector3(float.Parse(coords[0]), float.Parse(coords[1]),
                            float.Parse(coords[2]));
                        doorObj.CategoryId = catId;
                        doorObj.IsActive = (bool) _dataFile[pair.Key, "active"];

                        List<object> rawPermissions = (List<object>) _dataFile[pair.Key, "permissions"];
                        List<string> permissions = rawPermissions.Select(obj => obj.ToString()).ToList();
                        doorObj.Permissions = permissions;

                        doors.Add(doorObj);
                    }

                    CategoryObject category = new CategoryObject
                    {
                        Id = catId,
                        Doors = doors,
                        Permissions = new List<string>()
                    };

                    _dataFile.Clear();
                    _dataFile["Categories", catId.ToString()] = category;

                    _configData.DataFileVersion = _version;
                    SaveConfig();
                    _dataFile.Save();
                    break;
            }
        }

        private void InitializeQuaternionLists()
        {
            Quaternion xDoorFrontQ = new Quaternion(0, 0.2F, 0, -1F);
            string xDoorFront = xDoorFrontQ.ToString();

            Quaternion zDoorFrontQ = new Quaternion(0, 0.6F, 0, 0.8F);
            Quaternion zDoorFront2Q = new Quaternion(0, 0.8F, 0, -0.6F);

            string zDoorFront = zDoorFrontQ.ToString();
            string zDoorFront2 = zDoorFront2Q.ToString();
            string zDoorFront3 = Quaternion.Inverse(zDoorFrontQ).ToString();
            string zDoorFront4 = Quaternion.Inverse(zDoorFront2Q).ToString();

            _zDoorFronts = new List<string> {zDoorFront, zDoorFront2, zDoorFront3, zDoorFront4};
            _positiveEntrances = new List<string> {xDoorFront, zDoorFront2, zDoorFront4};
        }

        #endregion

        #region Hooks

        private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            BaseEntity parent = baseLock.GetParentEntity();
            if (!(parent is Door)) return null;

            Vector3 doorPosition = parent.transform.position;

            DoorObject doorData = DoorObject.GetDoorByLocation(doorPosition);
            if (doorData == null) return null;

            if (!doorData.IsActive) return null;
            List<string> permList = doorData.GetAllPermissions();

            if (!HasPermissions(player, permList.ToArray()))
            {
                if (_configData.SendInsufficientPerms)
                    player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return null;
            }

            bool shouldUnlock = true;
            if (doorData.IsTeleportationDoor)
            {
                Vector3 playerPosition = player.transform.position;
                Vector3 entrance = doorData.TeleportationEntrance;
                Vector3 exit = doorData.TeleportationExit;

                bool shouldEnter = !IsDoorEntrance((Door) parent, playerPosition);

                player.Teleport(shouldEnter ? entrance : exit);

                shouldUnlock = false;
            }

            GameObjectRef unlockSound = (baseLock as CodeLock)?.effectUnlocked;
            if (unlockSound == null)
            {
                Puts("Unable to retrieve unlock sound for code lock!");
                return shouldUnlock;
            }

            Effect.server.Run(unlockSound.resourcePath, player.transform.position, Vector3.zero);

            return shouldUnlock;
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            BaseEntity baseEntity = info.HitEntity;
            if (!(baseEntity is Door)) return null;

            Vector3 position = baseEntity.transform.position;
            DoorObject doorData = DoorObject.GetDoorByLocation(position);
            if (doorData == null) return null;

            return true;
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            if (!(entity is Door)) return;

            Vector3 position = entity.transform.position;
            DoorObject doorData = DoorObject.GetDoorByLocation(position);
            if (doorData == null) return;

            doorData.IsActive = false;
            doorData.UpdateDoor(this);
        }

        #endregion

        #region Commands

        [ChatCommand("lockdoor")]
        private void LockDoorCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, LockDoorPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (TimerHandler.HasTimer(player) && TimerHandler.GetTimer(player).Action == DoorActions.Lock)
            {
                player.ChatMessage(GetMessage("Exited Process", player));
                TimerHandler.RemoveTimer(player);
                return;
            }

            if (args.Length < 1)
            {
                string syntax = GetMessage("Lock Door Syntax", player, DoorPermPrefix);
                player.ChatMessage(GetMessage("Invalid Syntax", player, syntax));
                return;
            }

            TimerHandler.RemoveTimer(player);
            args = args.Select(str => (DoorPermPrefix + str).ToLower()).ToArray();

            player.ChatMessage(GetMessage("Entered Locking Process", player));

            TimerHandler timerHandler = new TimerHandler(this,
                player,
                DoorActions.Lock,
                0.1f,
                LockDoor(player, args)
            );
        }

        [ChatCommand("unlockdoor")]
        private void UnlockDoorCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, UnlockDoorPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (TimerHandler.HasTimer(player) && TimerHandler.GetTimer(player).Action == DoorActions.Unlock)
            {
                player.ChatMessage(GetMessage("Exited Process", player));
                TimerHandler.RemoveTimer(player);
                return;
            }

            TimerHandler.RemoveTimer(player);
            args = args.Select(str => (DoorPermPrefix + str).ToLower()).ToArray();

            player.ChatMessage(GetMessage("Entered Unlocking Process", player));

            TimerHandler timerHandler = new TimerHandler(this,
                player,
                DoorActions.Unlock,
                0.1f,
                UnlockDoor(player, args)
            );
        }

        [ChatCommand("activatedoor")]
        private void ActivateDoorCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, ActivateDoorPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (TimerHandler.HasTimer(player) && TimerHandler.GetTimer(player).Action == DoorActions.Activate)
            {
                player.ChatMessage(GetMessage("Exited Process", player));
                TimerHandler.RemoveTimer(player);
                return;
            }

            TimerHandler.RemoveTimer(player);

            player.ChatMessage(GetMessage("Entered Activation Process", player));

            TimerHandler timerHandler = new TimerHandler(this,
                player,
                DoorActions.Activate,
                0.1f,
                ActivateDoor(player)
            );
        }

        [ChatCommand("deactivatedoor")]
        private void DeactivateDoorCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, DeactivateDoorPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (TimerHandler.HasTimer(player) && TimerHandler.GetTimer(player).Action == DoorActions.Deactivate)
            {
                player.ChatMessage(GetMessage("Exited Process", player));
                TimerHandler.RemoveTimer(player);
                return;
            }

            TimerHandler.RemoveTimer(player);

            player.ChatMessage(GetMessage("Entered Deactivation Process", player));

            TimerHandler timerHandler = new TimerHandler(this,
                player,
                DoorActions.Deactivate,
                0.1f,
                DeactivateDoor(player)
            );
        }

        [ChatCommand("viewdoorinfo")]
        private void ViewDoorInfoCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, ViewDoorInfoPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (TimerHandler.HasTimer(player) && TimerHandler.GetTimer(player).Action == DoorActions.ViewInfo)
            {
                player.ChatMessage(GetMessage("Exited Process", player));
                TimerHandler.RemoveTimer(player);
                return;
            }

            TimerHandler.RemoveTimer(player);

            player.ChatMessage(GetMessage("Entered View Info Process", player));

            TimerHandler timerHandler = new TimerHandler(this,
                player,
                DoorActions.ViewInfo,
                0.1f,
                ViewDoorInfo(player)
            );
        }

        [ChatCommand("setdoorname")]
        private void SetDoorNameCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, LockDoorPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (TimerHandler.HasTimer(player) && TimerHandler.GetTimer(player).Action == DoorActions.SetDoorName)
            {
                player.ChatMessage(GetMessage("Exited Process", player));
                TimerHandler.RemoveTimer(player);
                return;
            }

            if (args.Length < 1)
            {
                string syntax = GetMessage("Set Door Name Syntax", player);
                player.ChatMessage(GetMessage("Invalid Syntax", player, syntax));
                return;
            }

            TimerHandler.RemoveTimer(player);
            string newName = string.Join(" ", args);

            player.ChatMessage(GetMessage("Entered Set Door Name Process", player));

            TimerHandler timerHandler = new TimerHandler(this,
                player,
                DoorActions.SetDoorName,
                0.1f,
                SetDoorName(player, newName)
            );
        }

        [ChatCommand("setteleportdoor")]
        private void SetTeleportDoorCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, SetTeleportDoorPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (TimerHandler.HasTimer(player) && TimerHandler.GetTimer(player).Action == DoorActions.SetTeleportDoor)
            {
                player.ChatMessage(GetMessage("Exited Process", player));
                TimerHandler.RemoveTimer(player);
                return;
            }

            TimerHandler.RemoveTimer(player);

            player.ChatMessage(GetMessage("Entered Set Tele Door Process", player));

            TimerHandler timerHandler = new TimerHandler(this,
                player,
                DoorActions.SetTeleportDoor,
                0.1f,
                SetTeleDoor(player)
            );
        }

        [ChatCommand("setteleportpoint")]
        private void SetTeleportPointCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, SetTeleportPointPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (TimerHandler.HasTimer(player) && TimerHandler.GetTimer(player).Action == DoorActions.CreatingTelePoint)
            {
                player.ChatMessage(GetMessage("Exited Process", player));
                TimerHandler.RemoveTimer(player);
                return;
            }

            TimerHandler.RemoveTimer(player);

            player.ChatMessage(GetMessage("Entered Set Tele Point Process", player));
            Vector3 playerPosition = player.transform.position;

            TimerHandler timerHandler = new TimerHandler(this,
                player,
                DoorActions.CreatingTelePoint,
                0.1f,
                SetTelePoint(player, playerPosition)
            );
        }

        [ChatCommand("setcategory")]
        private void SetCategoryCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, SetCategoryPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (TimerHandler.HasTimer(player) &&
                TimerHandler.GetTimer(player).Action == DoorActions.SettingDoorCategory)
            {
                player.ChatMessage(GetMessage("Exited Process", player));
                TimerHandler.RemoveTimer(player);
                return;
            }

            if (args.Length < 1)
            {
                string syntax = GetMessage("Set Category Syntax", player);
                player.ChatMessage(GetMessage("Invalid Syntax", player, syntax));
                return;
            }

            CategoryObject category = TryGetCategory(player, args[0]);
            if (category == null) return;

            TimerHandler.RemoveTimer(player);

            player.ChatMessage(GetMessage("Entered Set Category Process", player));

            TimerHandler timerHandler = new TimerHandler(this,
                player,
                DoorActions.SettingDoorCategory,
                0.1f,
                SetCategory(player, category)
            );
        }

        [ChatCommand("setcategoryname")]
        private void SetCategoryNameCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, SetCategoryNamePerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (args.Length < 2)
            {
                string syntax = GetMessage("Set Category Name Syntax", player);
                player.ChatMessage(GetMessage("Invalid Syntax", player, syntax));
                return;
            }

            CategoryObject category = TryGetCategory(player, args[0]);
            if (category == null) return;

            List<string> nameArgs = args.ToList();
            nameArgs.Remove(args[0]);

            string newName = string.Join(" ", nameArgs);
            if (category.Name.Equals(newName))
            {
                player.ChatMessage(GetMessage("Category Already Has Name", player));
                return;
            }

            category.Name = newName;
            category.Save(this);
            player.ChatMessage(GetMessage("Set Category Name", player, newName));
        }

        [ChatCommand("addcategoryperm")]
        private void AddCategoryPermCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, AddCategoryPermPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (args.Length < 2)
            {
                string syntax = GetMessage("Add Category Perm Syntax", player, DoorPermPrefix);
                player.ChatMessage(GetMessage("Invalid Syntax", player, syntax));
                return;
            }

            CategoryObject category = TryGetCategory(player, args[0]);
            if (category == null) return;

            List<string> permissions = category.Permissions;

            List<string> newPerms = args.ToList();
            newPerms.Remove(args[0]);
            newPerms = newPerms.Select(str => (DoorPermPrefix + str).ToLower()).ToList();

            newPerms.RemoveAll(perm =>
            {
                if (!permissions.Contains(perm)) return false;
                player.ChatMessage(GetMessage("Category Already Locked", player, perm));
                return true;
            });

            if (newPerms.Count == 0) return;

            permissions.AddRange(newPerms);

            UpdateCategoryPermissions(category, permissions.ToArray());
            player.ChatMessage(GetMessage("Category Locked New Permissions", player, string.Join(", ", newPerms)));
        }

        [ChatCommand("removecategoryperm")]
        private void RemoveCategoryPermCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, RemoveCategoryPermPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (args.Length < 2)
            {
                string syntax = GetMessage("Remove Category Perm Syntax", player, DoorPermPrefix);
                player.ChatMessage(GetMessage("Invalid Syntax", player, syntax));
                return;
            }

            CategoryObject category = TryGetCategory(player, args[0]);
            if (category == null) return;

            List<string> permissions = category.Permissions;

            List<string> removePerms = args.ToList();
            removePerms.Remove(args[0]);
            removePerms = removePerms.Select(str => (DoorPermPrefix + str).ToLower()).ToList();

            removePerms.RemoveAll(perm =>
            {
                if (permissions.Contains(perm)) return false;
                player.ChatMessage(GetMessage("Category Is Not Locked To That Permission", player, perm));
                return true;
            });

            if (removePerms.Count == 0) return;

            permissions.RemoveAll(perm => removePerms.Contains((perm)));

            UpdateCategoryPermissions(category, permissions.ToArray());
            player.ChatMessage(GetMessage("Category Unlocked", player, string.Join(", ", removePerms)));
        }

        [ChatCommand("createcategory")]
        private void CreateCategoryCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, CreateCategoryPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (args.Length < 1)
            {
                string syntax = GetMessage("Create Category Syntax", player, DoorPermPrefix);
                player.ChatMessage(GetMessage("Invalid Syntax", player, syntax));
                return;
            }

            string catName = args[0];

            List<string> catPerms = args.ToList();
            catPerms.Remove(catName);
            catPerms = catPerms.Select(str => (DoorPermPrefix + str).ToLower()).ToList();

            CategoryObject newCategory = new CategoryObject
            {
                Id = CategoryObject.GetNewCategoryId(),
                Name = catName,
                Permissions = catPerms
            };
            RegisterPermissions(catPerms.ToArray());

            // Save method adds category to cache automatically
            newCategory.Save(this);

            player.ChatMessage(GetMessage("Category Created", player, catName));
        }

        [ChatCommand("deletecategory")]
        private void DeleteCategoryCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, DeleteCategoryPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (args.Length < 1)
            {
                string syntax = GetMessage("Delete Category Syntax", player);
                player.ChatMessage(GetMessage("Invalid Syntax", player, syntax));
                return;
            }

            CategoryObject category = TryGetCategory(player, args[0]);
            if (category == null) return;

            if (category.Id == 0)
            {
                player.ChatMessage(GetMessage("Can Not Delete Default Category", player));
                return;
            }

            if (!_configData.ShouldDeleteDoors)
            {
                // 0 is default category
                category.MoveAllDoors(this, 0);
            }

            CategoryObject.DeleteCategory(this, category.Id);
            player.ChatMessage(GetMessage("Category Deleted", player, args[0]));
        }

        [ChatCommand("viewcategoryinfo")]
        private void ViewCategoryInfoCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, DeleteCategoryPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            if (args.Length < 1)
            {
                string syntax = GetMessage("View Category Info Syntax", player);
                player.ChatMessage(GetMessage("Invalid Syntax", player, syntax));
                return;
            }

            CategoryObject category = TryGetCategory(player, args[0]);
            if (category == null) return;

            string catName = category.Name;
            string catPerms = string.Join(", ", category.Permissions);

            player.ChatMessage(GetMessage("View Category Info Format", player, catName, args[0], catPerms));
        }

        [ChatCommand("viewcategories")]
        private void ViewCategoriesCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPermissions(player, ViewCategoriesPerm))
            {
                player.ChatMessage(GetMessage("Insufficient Permissions", player));
                return;
            }

            StringBuilder stringBuilder = new StringBuilder();
            CategoryObject.GetCategories().ForEach(category =>
            {
                int catId = category.Id;
                string catName = category.Name;
                string format = GetMessage("View Categories Format", player, catId, catName);
                stringBuilder.Append(format);
            });

            player.ChatMessage(stringBuilder.Length == 0
                ? GetMessage("No Categories Found", player)
                : stringBuilder.ToString());
        }

        #endregion

        #region Door Logic

        private Action LockDoor(BasePlayer player, string[] args)
        {
            return () =>
            {
                if (!player.serverInput.IsDown(SelectDoorButton)) return;

                Door door = RetrieveDoorEntity(player);
                if (door == null) return;

                Vector3 doorPosition = door.transform.position;
                List<string> newPerms = args.ToList();

                DoorObject doorData = DoorObject.GetDoorByLocation(doorPosition);
                if (doorData != null)
                {
                    List<string> currentPermissionList = doorData.GetAllPermissions();

                    newPerms.RemoveAll(perm =>
                    {
                        if (!currentPermissionList.Contains(perm)) return false;

                        player.ChatMessage(GetMessage("Door Already Locked", player, perm));
                        return true;
                    });

                    if (newPerms.Count == 0) return;
                    currentPermissionList.AddRange(newPerms);
                    UpdateDoorPermissions(doorData, currentPermissionList.ToArray());

                    string joinedPerms = string.Join(", ", newPerms);
                    player.ChatMessage(GetMessage("Door Locked New Permissions", player, joinedPerms));

                    TimerHandler.RemoveTimer(player);
                    return;
                }

                doorData = new DoorObject
                {
                    Name = "Unknown",
                    Position = doorPosition,
                    Permissions = newPerms,
                    Category = CategoryObject.GetCategoryById(0)
                };

                RegisterPermissions(args);

                if (!PutLockOnDoor(door, player))
                {
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                DoorObject.AddDoors(doorData);
                doorData.UpdateDoor(this);

                string permStr = string.Join(", ", newPerms);
                player.ChatMessage(GetMessage("Door Locked", player, permStr));

                TimerHandler.RemoveTimer(player);
            };
        }

        private Action UnlockDoor(BasePlayer player, string[] args)
        {
            return () =>
            {
                if (!player.serverInput.IsDown(SelectDoorButton)) return;

                Door door = RetrieveDoorEntity(player);
                if (door == null) return;

                Vector3 doorPosition = door.transform.position;
                List<string> unlockPerms = args.ToList();

                DoorObject doorData = DoorObject.GetDoorByLocation(doorPosition);
                if (doorData == null)
                {
                    player.ChatMessage(GetMessage("Door Not Locked", player));
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                List<string> newDoorPerms = doorData.Permissions;

                // New list to stop aliasing
                List<string> preserveDoorPerms = new List<string>(doorData.Permissions);

                unlockPerms.RemoveAll(perm =>
                {
                    if (newDoorPerms.Contains(perm)) return false;

                    string msg = doorData.Category.Permissions.Contains(perm)
                        ? "Locked To Category Not Door"
                        : "Door Is Not Locked To That Permission";

                    player.ChatMessage(GetMessage(msg, player, perm));
                    return true;
                });

                newDoorPerms.RemoveAll(perm => unlockPerms.Contains(perm));

                bool killEntity = unlockPerms.Count == 0 ||
                                  (newDoorPerms.Count == 0 && doorData.Category.Permissions.Count == 0);
                if (killEntity)
                {
                    RemoveLockOnDoor(door);
                    doorData.DeleteDoor(this);
                }
                else
                {
                    UpdateDoorPermissions(doorData, newDoorPerms.ToArray());
                }

                List<string> permList = killEntity ? preserveDoorPerms : unlockPerms;
                player.ChatMessage(GetMessage("Door Unlocked", player, string.Join(", ", permList)));
                TimerHandler.RemoveTimer(player);
            };
        }

        private Action ActivateDoor(BasePlayer player)
        {
            return () =>
            {
                if (!player.serverInput.IsDown(SelectDoorButton)) return;

                Door door = RetrieveDoorEntity(player);
                if (door == null) return;

                Vector3 doorPosition = door.transform.position;

                DoorObject doorData = DoorObject.GetDoorByLocation(doorPosition);
                if (doorData == null)
                {
                    player.ChatMessage(GetMessage("Door Not Locked", player));
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                if (doorData.IsActive)
                {
                    player.ChatMessage(GetMessage("Door Already Activated", player));
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                if (!PutLockOnDoor(door, player))
                {
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                player.ChatMessage(GetMessage("Door Activated", player));

                doorData.IsActive = true;
                doorData.UpdateDoor(this);
                TimerHandler.RemoveTimer(player);
            };
        }

        private Action DeactivateDoor(BasePlayer player)
        {
            return () =>
            {
                if (!player.serverInput.IsDown(SelectDoorButton)) return;

                Door door = RetrieveDoorEntity(player);
                if (door == null) return;

                Vector3 doorPosition = door.transform.position;

                DoorObject doorData = DoorObject.GetDoorByLocation(doorPosition);
                if (doorData == null)
                {
                    player.ChatMessage(GetMessage("Door Not Locked", player));
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                if (!doorData.IsActive)
                {
                    player.ChatMessage(GetMessage("Door Already Deactivated", player));
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                RemoveLockOnDoor(door);

                player.ChatMessage(GetMessage("Door Deactivated", player));

                doorData.IsActive = false;
                doorData.UpdateDoor(this);
                TimerHandler.RemoveTimer(player);
            };
        }

        private Action ViewDoorInfo(BasePlayer player)
        {
            return () =>
            {
                if (!player.serverInput.IsDown(SelectDoorButton)) return;

                Door door = RetrieveDoorEntity(player);
                if (door == null) return;

                Vector3 doorPosition = door.transform.position;

                DoorObject doorData = DoorObject.GetDoorByLocation(doorPosition);
                if (doorData == null)
                {
                    player.ChatMessage(GetMessage("Door Not Locked", player));
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                string name = doorData.Name;
                int catId = doorData.CategoryId;
                bool active = doorData.IsActive;

                List<string> permList = doorData.Permissions;
                string formattedPerms = string.Join(", ", permList);

                string message = GetMessage("View Door Info Format", player, name, catId, active, formattedPerms);
                player.ChatMessage(message);

                TimerHandler.RemoveTimer(player);
            };
        }

        private Action SetDoorName(BasePlayer player, string newName)
        {
            return () =>
            {
                if (!player.serverInput.IsDown(SelectDoorButton)) return;

                Door door = RetrieveDoorEntity(player);
                if (door == null) return;

                Vector3 doorPosition = door.transform.position;

                DoorObject doorData = DoorObject.GetDoorByLocation(doorPosition);
                if (doorData == null)
                {
                    player.ChatMessage(GetMessage("Door Not Locked", player));
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                if (doorData.Name.Equals(newName))
                {
                    player.ChatMessage(GetMessage("Door Already Has Name", player));
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                doorData.Name = newName;
                doorData.UpdateDoor(this);

                player.ChatMessage(GetMessage("Set Door Name", player, newName));
                TimerHandler.RemoveTimer(player);
            };
        }

        private Action SetTeleDoor(BasePlayer player)
        {
            return () =>
            {
                if (!player.serverInput.IsDown(SelectDoorButton)) return;

                Door door = RetrieveDoorEntity(player);
                if (door == null) return;

                Vector3 doorPosition = door.transform.position;

                DoorObject doorData = DoorObject.GetDoorByLocation(doorPosition);
                if (doorData == null)
                {
                    player.ChatMessage(GetMessage("Door Not Locked", player));
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                bool setState = !doorData.IsTeleportationDoor;
                doorData.IsTeleportationDoor = setState;
                doorData.UpdateDoor(this);

                if (setState) door.SetFlag(BaseEntity.Flags.Open, false);
                player.ChatMessage(GetMessage(setState ? "Set Tele Door" : "Removed Tele Door", player));

                TimerHandler.RemoveTimer(player);
            };
        }

        private Action SetTelePoint(BasePlayer player, Vector3 playerPosition)
        {
            return () =>
            {
                if (!player.serverInput.IsDown(SelectDoorButton)) return;

                Door door = RetrieveDoorEntity(player);
                if (door == null) return;

                Vector3 doorPosition = door.transform.position;

                DoorObject doorData = DoorObject.GetDoorByLocation(doorPosition);
                if (doorData == null)
                {
                    player.ChatMessage(GetMessage("Door Not Locked", player));
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                bool isEntrance = IsDoorEntrance(door, playerPosition);

                if (isEntrance)
                {
                    doorData.TeleportationEntrance = playerPosition;
                }
                else
                {
                    doorData.TeleportationExit = playerPosition;
                }

                doorData.UpdateDoor(this);
                player.ChatMessage(GetMessage("Set Tele Point", player, playerPosition.ToString()));

                TimerHandler.RemoveTimer(player);
            };
        }

        private Action SetCategory(BasePlayer player, CategoryObject category)
        {
            return () =>
            {
                if (!player.serverInput.IsDown(SelectDoorButton)) return;

                Door door = RetrieveDoorEntity(player);
                if (door == null) return;

                Vector3 doorPosition = door.transform.position;

                DoorObject doorData = DoorObject.GetDoorByLocation(doorPosition);
                if (doorData == null)
                {
                    player.ChatMessage(GetMessage("Door Not Locked", player));
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                int id = category.Id;
                if (doorData.CategoryId == id)
                {
                    player.ChatMessage(GetMessage("Already Has Category", player, id));
                    TimerHandler.RemoveTimer(player);
                    return;
                }

                string msg = doorData.SetCategory(this, id) ? "Category Set" : "Not A Category";
                player.ChatMessage(GetMessage(msg, player, id));

                TimerHandler.RemoveTimer(player);
            };
        }

        #endregion

        #region Classes

        public class CategoryObject
        {
            private static readonly List<CategoryObject> CategoryCache = new List<CategoryObject>();

            [JsonIgnore] public int Id { get; set; } = -1;
            public string Name { get; set; } = "Unknown";
            public List<DoorObject> Doors { get; set; } = new List<DoorObject>();
            public List<string> Permissions { get; set; } = new List<string>();

            public void MoveAllDoors(DoorPermissions plugin, int id)
            {
                CategoryObject category = GetCategoryById(id);
                if (category == null) return;

                DoorObject.RemoveDoorsFromCache(Doors.ToArray());
                Doors.ForEach(door =>
                {
                    door.CategoryId = category.Id;
                    door.Category = category;
                });

                category.Doors.AddRange(Doors);

                Doors.Clear();
                DoorObject.AddDoorsToCache(plugin, category.Doors.ToArray());

                SaveCategories(plugin, this, category);
            }

            public static int GetNewCategoryId()
            {
                return CategoryCache.Count;
            }

            public static bool CategoryExists(int id)
            {
                return GetCategoryById(id) != null;
            }

            public static CategoryObject GetCategoryById(int id)
            {
                return CategoryCache.FirstOrDefault(cat => cat.Id == id);
            }

            public static List<CategoryObject> GetCategories()
            {
                return CategoryCache;
            }

            public static void AddCategory(params CategoryObject[] categoryArray)
            {
                CategoryCache.AddRange(categoryArray);
            }

            public static void DeleteCategory(DoorPermissions plugin, int id)
            {
                CategoryObject category = GetCategoryById(id);
                if (category == null) return;
                CategoryCache.Remove(category);

                List<CategoryObject> newCache = new List<CategoryObject>();
                SortedDictionary<int, CategoryObject> saveDictionary = new SortedDictionary<int, CategoryObject>();
                CategoryCache.ForEach(listCat =>
                {
                    int listId = listCat.Id;
                    listId -= listId > id ? 1 : 0;

                    listCat.Id = listId;

                    saveDictionary[listId] = listCat;
                    newCache.Add(listCat);
                });

                CategoryCache.Clear();
                CategoryCache.AddRange(newCache);

                plugin._dataFile["Categories"] = saveDictionary;
                plugin._dataFile.Save();
                return;
            }

            public void Save(DoorPermissions plugin)
            {
                SaveCategories(plugin, this);
            }

            private static void SaveCategories(DoorPermissions plugin, params CategoryObject[] categoryArray)
            {
                foreach (CategoryObject category in categoryArray)
                {
                    CategoryCache.RemoveAll(cat => cat.Name.Equals(category.Name));
                    int catId = category.Id;

                    plugin._dataFile["Categories", catId.ToString()] = category;
                }

                CategoryCache.AddRange(categoryArray);

                plugin._dataFile.Save();
            }
        }

        public class DoorObject
        {
            private static readonly List<DoorObject> DoorCache = new List<DoorObject>();

            public int CategoryId { get; set; }
            public string Name { get; set; } = "Unknown";
            public Vector3 Position { get; set; } = Vector3.zero;
            public bool IsActive { get; set; } = true;
            public bool IsTeleportationDoor { get; set; }
            public Vector3 TeleportationEntrance { get; set; } = Vector3.zero;
            public Vector3 TeleportationExit { get; set; } = Vector3.zero;
            public List<string> Permissions { get; set; } = new List<string>();

            [JsonIgnore] public CategoryObject Category { get; set; } = new CategoryObject();

            public List<string> GetAllPermissions()
            {
                var allPerms = new List<string>(Permissions);
                allPerms.AddRange(Category.Permissions);

                return allPerms;
            }

            public static List<DoorObject> GetDoorByName(string name)
            {
                return DoorCache.FindAll(door => door.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
            }

            public static DoorObject GetDoorByLocation(Vector3 position)
            {
                /*
                 * Comparing using strings because I had an issue previously where 2 vectors which were equal were
                 * returning false when not comparing using strings. Assuming it is because of some precision error,
                 * happened with both == and .Equals
                 */
                return DoorCache.Find(door => door.Position.ToString().Equals(position.ToString()));
            }

            public static void AddDoors(params DoorObject[] doorArray)
            {
                foreach (DoorObject door in doorArray)
                {
                    List<DoorObject> doorList = door.Category.Doors;

                    if (!doorList.Contains(door)) door.Category.Doors.Add(door);
                    DoorCache.Add(door);
                }
            }

            public static void AddDoorsToCache(DoorPermissions plugin, params DoorObject[] doorArray)
            {
                // Makes sure there are no duplicates
                RemoveDoorsFromCache(doorArray);
                DoorCache.AddRange(doorArray);
            }

            public static void RemoveDoorsFromCache(params DoorObject[] doorArray)
            {
                foreach (DoorObject door in doorArray)
                {
                    DoorCache.RemoveAll(otherDoor =>
                    {
                        string doorPosition = door.Position.ToString();
                        string otherDoorPosition = otherDoor.Position.ToString();

                        return doorPosition.Equals(otherDoorPosition);
                    });
                }
            }

            public void UpdateDoor(DoorPermissions plugin)
            {
                Category.Doors.RemoveAll(door => door.Position.ToString().Equals(Position.ToString()));
                DoorCache.RemoveAll(door => door.Position.ToString().Equals(Position.ToString()));

                Category.Doors.Add(this);
                DoorCache.Add(this);

                Category.Save(plugin);
            }

            public void DeleteDoor(DoorPermissions plugin)
            {
                // This is done case any of the fields change in door compared to using Remove(this)
                Category.Doors.RemoveAll(door => door.Position.ToString().Equals(Position.ToString()));
                DoorCache.RemoveAll(door => door.Position.ToString().Equals(Position.ToString()));
                Category.Save(plugin);
            }

            public bool SetCategory(DoorPermissions plugin, int id)
            {
                CategoryObject newCategory = CategoryObject.GetCategoryById(id);
                if (newCategory == null) return false;

                Category.Doors.RemoveAll(door => door.Position.ToString().Equals(Position.ToString()));
                Category.Save(plugin);

                CategoryId = id;
                Category = newCategory;
                UpdateDoor(plugin);
                return true;
            }
        }

        private class TimerHandler
        {
            private static readonly Dictionary<string, TimerHandler> ActiveTimers =
                new Dictionary<string, TimerHandler>();


            private readonly Timer _handledTimer;
            private readonly Timer _expireTimer;
            public readonly DoorActions Action;

            public TimerHandler(DoorPermissions plugin, BasePlayer player, DoorActions action, float interval,
                Action callback, long expireAfterSeconds = 30)
            {
                Action = action;
                _handledTimer = plugin.timer.Every(interval, callback);
                _expireTimer = plugin.timer.In(expireAfterSeconds, () =>
                {
                    player.ChatMessage(plugin.GetMessage("Time Ended", player));
                    _handledTimer.Destroy();
                });

                AddTimer(player, this);
            }

            public void CancelTimer()
            {
                _handledTimer.Destroy();
                _expireTimer.Destroy();
            }

            public static bool HasTimer(BasePlayer player)
            {
                return ActiveTimers.ContainsKey(player.UserIDString);
            }

            public static TimerHandler GetTimer(BasePlayer player)
            {
                return ActiveTimers[player.UserIDString];
            }

            private static void AddTimer(BasePlayer player, TimerHandler handler)
            {
                ActiveTimers[player.UserIDString] = handler;
            }

            public static void RemoveTimer(BasePlayer player)
            {
                if (!HasTimer(player)) return;

                GetTimer(player).CancelTimer();
                ActiveTimers.Remove(player.UserIDString);
            }
        }

        #endregion

        #region Utlity Methods

        private bool HasPermissions(BasePlayer player, params string[] permissions)
        {
            string userId = player.UserIDString;
            return permissions.Any(permName => permission.UserHasPermission(userId, permName));
        }

        public void UpdateDoorPermissions(DoorObject door, params string[] perms)
        {
            door.Permissions = perms.ToList();
            RegisterPermissions(perms);
            door.UpdateDoor(this);
        }

        public void UpdateCategoryPermissions(CategoryObject category, params string[] perms)
        {
            category.Permissions = perms.ToList();
            RegisterPermissions(perms);
            category.Save(this);
        }

        public void RegisterPermissions(params string[] permissions)
        {
            List<string> permList = permissions.ToList();
            permList.RemoveAll(perm => permission.PermissionExists(perm));
            permList.ForEach(perm => permission.RegisterPermission(perm, this));
        }

        private bool PutLockOnDoor(Door door, BasePlayer player)
        {
            if (door.GetSlot(BaseEntity.Slot.Lock) != null)
            {
                RemoveLockOnDoor(door);
            }

            CodeLock codeLockEntity = GameManager.server.CreateEntity("assets/prefabs/locks/keypad/lock.code.prefab",
                Vector3.zero, Quaternion.identity) as CodeLock;
            if (codeLockEntity == null)
            {
                player.ChatMessage(GetMessage("Failed To Create Codelock", player));
                return false;
            }

            codeLockEntity.SetParent(door, door.GetSlotAnchorName(BaseEntity.Slot.Lock));
            codeLockEntity.Spawn();

            door.SetSlot(BaseEntity.Slot.Lock, codeLockEntity);

            CodeLock codeLock = (CodeLock) door.GetSlot(BaseEntity.Slot.Lock);
            codeLock.SetFlag(BaseEntity.Flags.Locked, true);
            return true;
        }

        private void RemoveLockOnDoor(Door door)
        {
            if (door.GetSlot(BaseEntity.Slot.Lock) == null) return;

            CodeLock codeLock = (CodeLock) door.GetSlot(BaseEntity.Slot.Lock);
            codeLock.GetEntity().Kill();
            door.SetSlot(BaseEntity.Slot.Lock, null);
        }

        // Credit to Wulf
        private static BaseEntity FindObject(Ray ray, float distance)
        {
            RaycastHit hit;
            return Physics.Raycast(ray, out hit, distance) ? hit.GetEntity() : null;
        }

        private Door RetrieveDoorEntity(BasePlayer player)
        {
            Ray ray = new Ray(player.eyes.position, player.eyes.HeadForward());

            BaseEntity entity = FindObject(ray, 1.5f);
            if (entity != null && entity is Door) return entity as Door;

            player.ChatMessage(GetMessage("Not A Door", player));
            return null;
        }

        // This does not account for if both points are behind/in front of the door
        private bool IsDoorEntrance(Door door, Vector3 playerPosition)
        {
            Vector3 doorPosition = door.transform.position;
            string doorRotStr = door.GetNetworkRotation().ToString();

            bool isZ = _zDoorFronts.Contains(doorRotStr);
            float coordDifference = isZ ? doorPosition.z - playerPosition.z : doorPosition.x - playerPosition.x;

            return _positiveEntrances.Contains(doorRotStr) && coordDifference > 0 ||
                   !_positiveEntrances.Contains(doorRotStr) && coordDifference < 0;
        }

        private CategoryObject TryGetCategory(BasePlayer player, string strId)
        {
            int id;
            bool isNumber = int.TryParse(strId, out id);
            if (!isNumber)
            {
                player.ChatMessage(GetMessage("Not A Number", player));
                return null;
            }

            if (CategoryObject.CategoryExists(id)) return CategoryObject.GetCategoryById(id);

            player.ChatMessage(GetMessage("Not A Category", player, id));
            return null;
        }

        #endregion
    }
}

// --- End of file: DoorPermissions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/drone-lights ---
// --- Original File Path: D/DroneLights/DroneLights.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Drone Lights", "WhiteThunder", "2.0.2")]
    [Description("Adds controllable search lights to RC drones.")]
    internal class DroneLights : CovalencePlugin
    {
        #region Fields

        private const string PermissionAutoDeploy = "dronelights.searchlight.autodeploy";
        private const string PermissionMoveLight = "dronelights.searchlight.move";

        private const string SpherePrefab = "assets/prefabs/visualization/sphere.prefab";
        private const string SearchLightPrefab = "assets/prefabs/deployable/search light/searchlight.deployed.prefab";

        private const float SearchLightYAxisRotation = 180;
        private const float SearchLightScale = 0.1f;

        private static readonly Vector3 SphereEntityLocalPosition = new Vector3(0, -0.075f, 0.25f);
        private static readonly Vector3 SearchLightLocalPosition = new Vector3(0, -1.25f, -0.25f);

        private static readonly FieldInfo DronePitchField = typeof(Drone).GetField("pitch", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

        private Configuration _config;
        private ProtectionProperties _immortalProtection;

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionAutoDeploy, this);
            permission.RegisterPermission(PermissionMoveLight, this);
            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null || !IsDroneEligible(drone))
                    continue;

                SearchLightUpdater.RemoveFromDrone(drone);
            }

            UnityEngine.Object.Destroy(_immortalProtection);
        }

        private void OnServerInitialized()
        {
            _immortalProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
            _immortalProtection.name = "DroneLightsProtection";
            _immortalProtection.Add(1);

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null || !IsDroneEligible(drone))
                    continue;

                AddOrUpdateSearchLight(drone);
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                var station = player.GetMounted() as ComputerStation;
                if (station == null)
                    continue;

                var drone = station.currentlyControllingEnt.Get(serverside: true) as Drone;
                if (drone == null)
                    continue;

                OnBookmarkControlStarted(station, player, string.Empty, drone);
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        private void OnEntitySpawned(Drone drone)
        {
            if (!IsDroneEligible(drone))
                return;

            var drone2 = drone;
            NextTick(() =>
            {
                if (drone2 == null || drone2.IsDestroyed)
                    return;

                MaybeAutoDeploySearchLight(drone2);
            });
        }

        private void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string bookmarkName, Drone drone)
        {
            var controllerSteamId = drone.ControllingViewerId?.SteamId;
            if (controllerSteamId != player.userID)
                return;

            SphereEntity sphereEntity;
            var searchLight = GetDroneSearchLight(drone, out sphereEntity);
            if (searchLight == null)
                return;

            var hasMovePermission = permission.UserHasPermission(player.UserIDString, PermissionMoveLight);
            if (!hasMovePermission)
            {
                var defaultAngle = _config.SearchLight.DefaultAngle - 90 % 360;
                SetLightAngle(drone, sphereEntity, sphereEntity.transform, defaultAngle);
            }

            SearchLightUpdater.AddOrUpdateForDrone(this, drone, sphereEntity, searchLight, player, hasMovePermission);
        }

        #endregion

        #region Helper Methods

        private static bool DeployLightWasBlocked(Drone drone)
        {
            var hookResult = Interface.CallHook("OnDroneSearchLightDeploy", drone);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool IsDroneEligible(Drone drone)
        {
            return drone.skinID == 0 && !(drone is DeliveryDrone);
        }

        private static Drone GetControlledDrone(ComputerStation station)
        {
            return station.currentlyControllingEnt.Get(serverside: true) as Drone;
        }

        private static Drone GetControlledDrone(BasePlayer player)
        {
            var computerStation = player.GetMounted() as ComputerStation;
            if (computerStation == null)
                return null;

            return GetControlledDrone(computerStation);
        }

        private static T2 GetGrandChildOfType<T1, T2>(BaseEntity entity, out T1 childOfType) where T1 : BaseEntity where T2 : BaseEntity
        {
            foreach (var child in entity.children)
            {
                childOfType = child as T1;
                if (childOfType == null)
                    continue;

                foreach (var grandChild in childOfType.children)
                {
                    var grandChildOfType = grandChild as T2;
                    if (grandChildOfType != null)
                        return grandChildOfType;
                }
            }

            childOfType = null;
            return null;
        }

        private static SearchLight GetDroneSearchLight(Drone drone, out SphereEntity parentSphere)
        {
            return GetGrandChildOfType<SphereEntity, SearchLight>(drone, out parentSphere);
        }

        private static SearchLight GetControlledSearchLight(BasePlayer player, out SphereEntity parentSphere, out Drone drone)
        {
            drone = GetControlledDrone(player);
            if (drone == null)
            {
                parentSphere = null;
                return null;
            }

            return GetDroneSearchLight(drone, out parentSphere);
        }

        private static SearchLight GetControlledSearchLight(BasePlayer player)
        {
            Drone drone;
            SphereEntity parentSphere;
            return GetControlledSearchLight(player, out parentSphere, out drone);
        }

        private static void RemoveProblemComponents(BaseEntity entity)
        {
            foreach (var collider in entity.GetComponentsInChildren<Collider>())
            {
                UnityEngine.Object.DestroyImmediate(collider);
            }

            UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
        }

        private static void HideInputsAndOutputs(IOEntity ioEntity)
        {
            // Trick to hide the inputs and outputs on the client.
            foreach (var input in ioEntity.inputs)
            {
                input.type = IOEntity.IOType.Generic;
            }

            foreach (var output in ioEntity.outputs)
            {
                output.type = IOEntity.IOType.Generic;
            }
        }

        private static void SetLightAngle(Drone drone, SphereEntity sphere, Transform transform, float overrideAngle = 0)
        {
            float desiredPitch;

            if (overrideAngle != 0)
            {
                desiredPitch = overrideAngle;
            }
            else
            {
                if (DronePitchField == null)
                    return;

                desiredPitch = (float)DronePitchField.GetValue(drone);
                desiredPitch = (360 - desiredPitch) % 360;

            }

            var currentPitch = transform.localEulerAngles.x;
            if (Math.Abs(currentPitch - desiredPitch) < 0.1f)
                return;

            transform.localEulerAngles = new Vector3(desiredPitch, SearchLightYAxisRotation, 0);
            sphere.InvalidateNetworkCache();

            // This is the most expensive line in terms of performance.
            sphere.SendNetworkUpdate_Position();
        }

        private SearchLight TryDeploySearchLight(Drone drone)
        {
            if (DeployLightWasBlocked(drone))
                return null;

            var defaultAngle = _config.SearchLight.DefaultAngle - 90 % 360;
            var localRotation = Quaternion.Euler(defaultAngle, SearchLightYAxisRotation, 0);
            var sphereEntity = GameManager.server.CreateEntity(SpherePrefab, SphereEntityLocalPosition, localRotation) as SphereEntity;
            if (sphereEntity == null)
                return null;

            SetupSphereEntity(sphereEntity);

            sphereEntity.currentRadius = SearchLightScale;
            sphereEntity.lerpRadius = SearchLightScale;

            sphereEntity.SetParent(drone);
            sphereEntity.Spawn();

            var searchLight = GameManager.server.CreateEntity(SearchLightPrefab, SearchLightLocalPosition) as SearchLight;
            if (searchLight == null)
                return null;

            SetupSearchLight(searchLight);

            searchLight.SetFlag(BaseEntity.Flags.Disabled, true);
            searchLight.SetParent(sphereEntity);
            searchLight.Spawn();
            Interface.CallHook("OnDroneSearchLightDeployed", drone, searchLight);

            searchLight.Invoke(() =>
            {
                searchLight.SetFlag(BaseEntity.Flags.Disabled, false);
            }, 5f);

            return searchLight;
        }

        private void SetupSphereEntity(SphereEntity sphereEntity)
        {
            sphereEntity.transform.localPosition = SphereEntityLocalPosition;
            sphereEntity.EnableSaving(true);
            sphereEntity.EnableGlobalBroadcast(false);
        }

        private void SetupSearchLight(SearchLight searchLight)
        {
            RemoveProblemComponents(searchLight);
            HideInputsAndOutputs(searchLight);
            searchLight.EnableSaving(true);
            searchLight.SetFlag(BaseEntity.Flags.Busy, true);
            searchLight.baseProtection = _immortalProtection;
            searchLight.pickup.enabled = false;
        }

        private void AddOrUpdateSearchLight(Drone drone)
        {
            SphereEntity sphereEntity;
            var searchLight = GetDroneSearchLight(drone, out sphereEntity);
            if (searchLight == null)
            {
                MaybeAutoDeploySearchLight(drone);
                return;
            }

            SetupSphereEntity(sphereEntity);
            SetupSearchLight(searchLight);
        }

        private void MaybeAutoDeploySearchLight(Drone drone)
        {
            if (!permission.UserHasPermission(drone.OwnerID.ToString(), PermissionAutoDeploy))
                return;

            TryDeploySearchLight(drone);
        }

        #endregion

        #region Classes

        private class SearchLightUpdater : FacepunchBehaviour
        {
            public static void AddOrUpdateForDrone(DroneLights plugin, Drone drone, SphereEntity sphereEntity, SearchLight searchLight, BasePlayer controller, bool canMove)
            {
                var component = GetForDrone(drone);
                if (component == null)
                {
                    component = drone.gameObject.AddComponent<SearchLightUpdater>();
                    component._plugin = plugin;
                    component._drone = drone;
                    component._sphereEntity = sphereEntity;
                    component._sphereTransform = sphereEntity.transform;
                    component._searchLight = searchLight;
                }

                component._controller = controller;
                component._canMove = canMove;
                component.enabled = true;
            }

            public static void RemoveFromDrone(Drone drone)
            {
                DestroyImmediate(GetForDrone(drone));
            }

            private static SearchLightUpdater GetForDrone(Drone drone)
            {
                return drone.gameObject.GetComponent<SearchLightUpdater>();
            }

            private DroneLights _plugin;
            private Drone _drone;
            private SphereEntity _sphereEntity;
            private Transform _sphereTransform;
            private SearchLight _searchLight;
            private BasePlayer _controller;
            private bool _canMove;

            private void Update()
            {
                var controllerSteamId = _drone.ControllingViewerId?.SteamId ?? 0;
                if (controllerSteamId == 0)
                {
                    enabled = false;
                    return;
                }

                _plugin.TrackStart();

                if (_controller.lastTickTime == Time.time && _controller.serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY))
                {
                    _searchLight.SetFlag(IOEntity.Flag_HasPower, !_searchLight.IsPowered());
                }

                if (_canMove && !_drone.isGrounded && _searchLight.IsPowered())
                {
                    SetLightAngle(_drone, _sphereEntity, _sphereTransform);
                }

                _plugin.TrackEnd();
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("SearchLight")]
            public SearchLightSettings SearchLight = new SearchLightSettings();
        }

        private class SearchLightSettings
        {
            [JsonProperty("DefaultAngle")]
            public int DefaultAngle = 75;
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        [JsonObject(MemberSerialization.OptIn)]
        private class BaseConfiguration
        {
            private string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigSection(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigSection(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigSection(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {

            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion
    }
}


// --- End of file: DroneLights.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/disconnect-to-home ---
// --- Original File Path: D/DisconnectToHome/DisconnectToHome.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Disconnect To Home", "Ryz0r", "1.0.2")]
    [Description("Sends a player back to their defined home location when they disconnect.")]
    public class DisconnectToHome : RustPlugin
    {
        const string UsePerm = "disconnecttohome.use";
        
        private PluginData _data;
        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
        
        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new PluginData();
        }

        private class PluginData
        {
            [JsonProperty(PropertyName = "Home Locations")]
            public Dictionary<string, Vector3> HomeLocations = new Dictionary<string, Vector3>();
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BuildingBlocked"] = "You are building blocked and may not set your disconnect location.",
                ["LocationSetAlready"] = "You have already set a location. If you wish to update it, please type /disconnecthere remove then set it again.",
                ["LocationNotSet"] = "You have not yet set a location! Please do /disconnecthere set.",
                ["ValidArgs"] = "/disconnecthere set - Sets your disconnect location.\n/disconnecthere remove - Removes your disconnect location.",
                ["DisconnectRemoved"] = "Your disconnect location has been removed.",
                ["DisconnectAdded"] = "Your disconnect location has been set as your current location.",
                ["HomeTeleported"] = "You have been teleported back to your set location.",
                ["NoPerm"] = "You do not have the permissions to use this command.",
                ["FoundationOrFloor"] = "You must be on a foundation or a floor."
            }, this); 
        }

        private void Loaded()
        {
            permission.RegisterPermission(UsePerm, this);
            LoadData();
        }
        
        private void OnServerSave()
        {
            SaveData();
        }

        [ChatCommand("disconnecthere")]
        private void DisconnectCommand(BasePlayer bp, string command, string[] args)
        {
            if (!permission.UserHasPermission(bp.UserIDString, UsePerm))
            {
                bp.ChatMessage(lang.GetMessage("NoPerm", this, bp.UserIDString));
                return;
            }
            
            if (bp.IsBuildingBlocked())
            {
                bp.ChatMessage(lang.GetMessage("BuildingBlocked", this, bp.UserIDString));
                return;
            }

            if (args.Length == 0 || args.Length > 1)
            {
                bp.ChatMessage(lang.GetMessage("ValidArgs", this, bp.UserIDString));
                return;
            }

            switch (args[0])
            {
                case "remove":
                    if (!_data.HomeLocations.ContainsKey(bp.UserIDString))
                    {
                        bp.ChatMessage(lang.GetMessage("LocationNotSet", this, bp.UserIDString));
                        return;
                    }

                    _data.HomeLocations.Remove(bp.UserIDString);
                    bp.ChatMessage(lang.GetMessage("DisconnectRemoved", this, bp.UserIDString));
                    SaveData();
                    break;

                case "set":
                    if (_data.HomeLocations.ContainsKey(bp.UserIDString))
                    {
                        bp.ChatMessage(lang.GetMessage("LocationSetAlready", this, bp.UserIDString));
                        return;
                    }

                    if (!CheckIfOnFoundationOrFloor(bp))
                    {
                        bp.ChatMessage(lang.GetMessage("FoundationOrFloor", this, bp.UserIDString));
                        return;
                    }

                    _data.HomeLocations.Add(bp.UserIDString, bp.transform.position);
                    bp.ChatMessage(lang.GetMessage("DisconnectAdded", this, bp.UserIDString));
                    SaveData();
                    break;
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (permission.UserHasPermission(player.UserIDString, UsePerm) &&
                _data.HomeLocations.ContainsKey(player.UserIDString))
            {
                player.Teleport(_data.HomeLocations[player.UserIDString]);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, UsePerm) &&
                _data.HomeLocations.ContainsKey(player.UserIDString))
            {
                player.ChatMessage(lang.GetMessage("HomeTeleported", this, player.UserIDString));
            }
        }

        private bool CheckIfOnFoundationOrFloor(BasePlayer player)
        {
            var position = player.transform.position;
            var foundationCheck = false;
            RaycastHit hitinfo;

            if (Physics.Raycast(position + new Vector3(0f, 0.2f, 0f), Vector3.down, out hitinfo, 3f,
                Layers.Mask.Construction) && hitinfo.GetEntity().IsValid())
            {
                var entity = hitinfo.GetEntity();
                if (entity.PrefabName.Contains("floor") || entity.PrefabName.Contains("foundation"))
                {
                    foundationCheck = true;
                }
            }

            return foundationCheck;
        }
    }
}

// --- End of file: DisconnectToHome.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-sync ---
// --- Original File Path: D/DiscordSync/DiscordSync.cs ---

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;

namespace Oxide.Plugins
{
    [Info("Discord Sync", "Tricky & OuTSMoKE", "1.3.0")]
    [Description("Integrates players with the discord server")]

    public class DiscordSync : CovalencePlugin, IDiscordPlugin
    {
        #region Declared
        public DiscordClient Client { get; set; }
        
        private readonly BotConnection _settings = new BotConnection
        {
            Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers
        };
        
        private DiscordGuild _guild;

        private readonly DiscordLink _link = GetLibrary<DiscordLink>();
        #endregion

        #region Config
        Configuration config;

        class Configuration
        {
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string BotToken = string.Empty;

            [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
            public Snowflake GuildId { get; set; } = new Snowflake();

            [JsonProperty(PropertyName = "Enable Nick Syncing")]
            public bool NickSync = false;

            [JsonProperty(PropertyName = "Enable Ban Syncing")]
            public bool BanSync = false;

            [JsonProperty(PropertyName = "Enable Role Syncing")]
            public bool RoleSync = true;

            // [JsonProperty(PropertyName = "Auto Reload Plugin")]
            // public bool AutoReloadPlugin { get; set; }

            // [JsonProperty(PropertyName = "Auto Reload Time (Seconds, Minimum 60)")]
            // public int AutoReloadTime { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; } = DiscordLogLevel.Info;

            [JsonProperty(PropertyName = "Role Setup", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<RoleInfo> RoleSetup = new List<RoleInfo>
            {
                new RoleInfo
                {
                    OxideGroup = "default",
                    DiscordRole = "Member"
                },

                new RoleInfo
                {
                    OxideGroup = "vip",
                    DiscordRole = "Donator"
                }
            };

            public class RoleInfo
            {
                [JsonProperty(PropertyName = "Oxide Group")]
                public string OxideGroup;

                [JsonProperty(PropertyName = "Discord Role")]
                public string DiscordRole;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                Config.WriteObject(config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonError");
                PrintError("The configuration file contains an error and has been replaced with a default config.\n" +
                           "The error configuration file was saved in the .jsonError extension");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Oxide / Discord Hooks
        [HookMethod(DiscordExtHooks.OnDiscordClientCreated)]
        private void OnDiscordClientCreated()
        {
            if (config.BotToken != string.Empty)
            {
                _settings.ApiToken = config.BotToken;
                _settings.LogLevel = config.ExtensionDebugging;
                Client.Connect(_settings);
            }
            else
            {
                PrintWarning("Please set the Discord Bot Token and reload the plugin");
            }
        }

        void OnUserConnected(IPlayer player)
        {
            if (config.NickSync)
                HandleNick(player);
            if (config.BanSync)
                HandleBan(player);
            if (config.RoleSync)
                HandleRole(player);
        }

        private void OnServerInitialized()
        {
            if (!config.RoleSync)
                Unsubscribe(nameof(OnUserGroupAdded));

            if (!config.RoleSync)
                Unsubscribe(nameof(OnUserGroupRemoved));

            if (!config.BanSync)
                Unsubscribe(nameof(OnUserBanned));

            if (!config.BanSync)
                Unsubscribe(nameof(OnUserUnbanned));

            // var reloadtime = config.AutoReloadTime;
            // if (config.AutoReloadPlugin && config.AutoReloadTime > 59)
            // {
            //     timer.Every(reloadtime, () => Reload());
            // }
        }
        
        // Called when the client is created, and the plugin can use it
        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            if (ready.Guilds.Count == 0)
            {
                PrintError("Your bot was not found in any discord servers. Please invite it to a server and reload the plugin.");
                return;
            }

            DiscordGuild guild = null;
            if (ready.Guilds.Count == 1 && !config.GuildId.IsValid())
            {
                guild = ready.Guilds.Values.FirstOrDefault();
            }

            if (guild == null)
            {
                guild = ready.Guilds[config.GuildId];
            }

            if (guild == null)
            {
                PrintError("Failed to find a matching guild for the Discord Server Id. " +
                           "Please make sure your guild Id is correct and the bot is in the discord server.");
                return;
            }
                
            if (Client.Bot.Application.Flags.HasValue && !Client.Bot.Application.Flags.Value.HasFlag(ApplicationFlags.GatewayGuildMembersLimited))
            {
                PrintError($"You need to enable \"Server Members Intent\" for {Client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n" +
                           $"{Name} will not function correctly until that is fixed. Once updated please reload {Name}.");
                return;
            }
            
            _guild = guild;
            Puts($"Connected to bot: {Client.Bot.BotUser.Username}");
        }

        [HookMethod(DiscordExtHooks.OnDiscordPlayerLinked)]
        private void OnAuthenticate(IPlayer player, DiscordUser user)
        {
            if (config.NickSync)
                HandleNick(player);

            if (config.BanSync)
                HandleBan(player);

            if (config.RoleSync)
                HandleRole(player);
        }

        private void OnUserNameUpdated(string id)
        {
            var player = players.FindPlayerById(id);
            if (player == null)
                return;

            HandleNick(player);
        }

        private void OnUserBanned(string name, string id) => OnUserUnbanned(name, id);

        private void OnUserUnbanned(string name, string id)
        {
            var player = players.FindPlayerById(id);
            if (player == null)
                return;

            HandleBan(player);
        }

        private void OnUserGroupAdded(string id, string groupName) => OnUserGroupRemoved(id, groupName);

        private void OnUserGroupRemoved(string id, string groupName)
        {
            config.RoleSetup.ForEach(roleSetup =>
            {
                if (roleSetup.OxideGroup == groupName)
                    HandleRole(id, roleSetup.DiscordRole, groupName);
            });
        }
        #endregion

        #region Handle
        private void HandleNick(IPlayer player)
        {
            var discordId = player.GetDiscordUserId();
            if (!discordId.IsValid())
                return;

            var guildmember = GetGuildMember(discordId);
            if (guildmember == null)
                return;

            if (guildmember.Nickname == player.Name)
                return;

            _guild.EditMemberNick(Client, discordId, player.Name);
        }

        private void HandleBan(IPlayer player)
        {
            Snowflake discordId = player.GetDiscordUserId();
            if (!discordId.IsValid())
                return;

            if (GetGuildMember(discordId) == null)
                return;

            _guild.GetBans(Client).Then(bans =>
            {
                if ((bans.Any(ban => ban.User.Id != discordId) || bans.Count() == 0) && player.IsBanned)
                {
                    _guild.CreateBan(Client, discordId, new GuildBanCreate
                    {
                        DeleteMessageSeconds = 0
                    });
                }
                else if (bans.Any(ban => ban.User.Id == discordId) && !player.IsBanned)
                {
                    _guild.RemoveBan(Client, discordId);
                }
            });
        }

        private void HandleRole(string id, string roleName, string oxideGroup)
        {
            Snowflake discordId = _link.GetDiscordId(id);
            if (!discordId.IsValid())
                return;

            var guildmember = GetGuildMember(discordId);
            if (guildmember == null)
                return;

            var role = GetRoleByName(roleName);
            if (role == null)
            {
                Puts($"Unable to find '{roleName}' discord role!");
                return;
            }

            if (HasGroup(id, oxideGroup) && !UserHasRole(discordId, role.Id))
            {
                _guild.AddMemberRole(Client, guildmember.User, role);
            }
            else if (!HasGroup(id, oxideGroup) && UserHasRole(discordId, role.Id))
            {
                _guild.RemoveMemberRole(Client, guildmember.User, role);
            }
        }

        private void HandleRole(IPlayer player)
        {
            config.RoleSetup.ForEach(roleSetup =>
            {
                GetGroups(player.Id).ToList().ForEach(playerGroup =>
                {
                    if (roleSetup.OxideGroup == playerGroup)
                        HandleRole(player.Id, roleSetup.DiscordRole, playerGroup);
                });
            });
        }
        #endregion

        #region Helpers
        private bool HasGroup(string id, string groupName)
            => permission.UserHasGroup(id, groupName);

        private string[] GetGroups(string id)
            => permission.GetUserGroups(id);

        private DiscordRole GetRoleByName(string roleName) => _guild.GetRole(roleName);

        private GuildMember GetGuildMember(Snowflake discordId) => _guild.Members[discordId];

        private bool UserHasRole(Snowflake discordId, Snowflake roleId)
        {
            return GetGuildMember(discordId).HasRole(roleId);
        }
        #endregion
    }
}

// --- End of file: DiscordSync.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/data-logging-wipes ---
// --- Original File Path: D/DataLoggingWipes/DataLoggingWipes.cs ---

﻿// Requires: DataLogging

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Oxide.Core.Extensions;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Logging;
using Oxide.Game.Rust;

namespace Oxide.Plugins
{
    [Info("Data Logging: Wipes", "Rustoholics", "0.2.0")]
    [Description("Log every wipe")]

    public class DataLoggingWipes : DataLogging
    {
        #region Object
        public class Wipe
        {
            public DateTime Date = DateTime.Now;
            public int Seed;
            public string SaveFile = "";
            public string MapFile = "";
            public int Version;
            public string OxideVersion;
        }
        
        #endregion
        
        #region Language
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoRecords"] = "There are no records of any wipes",
                ["LastWipe"] = "There last wipe happened on {0}",
            }, this);
        }
        
        #endregion
        
        #region Setup
        
        DataList<Wipe> _data;

        private void OnServerInitialized()
        {
            _data = new DataList<Wipe>("global","wipe");
            var lastwipe = _data.GetDataLast();
            var currentSeed = ConVar.Server.seed;
            var savefile = World.SaveFileName;
            Match match = Regex.Match(savefile, @"\.([\d]*)\.sav");
            int version = 0;
                
            if (match.Success)
            {
                if (!int.TryParse(match.Groups[1].Value, out version))
                    version = 0;
            }

            if (lastwipe == null || lastwipe.Seed != currentSeed || lastwipe.Version != version || lastwipe.SaveFile != savefile)
            {
                _data.AddData(new Wipe
                {
                    Seed = currentSeed,
                    SaveFile = savefile,
                    MapFile = World.MapFileName,
                    Version = version,
                    OxideVersion = new RustExtension(new ExtensionManager(new CompoundLogger())).Version.ToString()
                });
                _data.Save();
            }

        }

        #endregion
        
        #region Data Analysis
        
        #endregion
        
        #region Commands

        [Command("datalogging.lastwipe")]
        private void LastWipeCommand(IPlayer iplayer, string command, string[] args)
        {
            var lastwipe = _data.GetDataLast();
            if (lastwipe == null)
            {
                iplayer.Reply(Lang("NoRecords", iplayer.Id));
                return;
            }
            iplayer.Reply(Lang("LastWipe",iplayer.Id, lastwipe.Date));
        }

        
        #endregion

        #region API

        private DateTime API_LastWipe()
        {
            var lastwipe = _data.GetDataLast();
            if (lastwipe == null) return default(DateTime);

            return lastwipe.Date;
        }

        #endregion
    }
}

// --- End of file: DataLoggingWipes.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/data-logging ---
// --- Original File Path: D/DataLogging/DataLogging.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using JetBrains.Annotations;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Data Logging", "Rustoholics", "0.1.1")]
    [Description("Record stats from the server")]

    public class DataLogging : CovalencePlugin
    {

        #region Caching

        private Dictionary<string, CacheItem> _cache = new Dictionary<string, CacheItem>();

        public object GetCache(string key)
        {
            if (_cache.ContainsKey(key))
            {
                if (!_cache[key].IsExpired())
                {
                    return _cache[key].Value;
                }
                _cache.Remove(key);
            }

            return null;
        }

        public void AddCache(string key, object value, int ttl=60)
        {
            if (ttl <= 0)
            {
                return;
            }
            _cache[key] = new CacheItem()
            {
                Expires =  DateTime.Now.AddSeconds(ttl),
                Value = value
            };
        }

        class CacheItem
        {
            public DateTime Expires;
            public object Value;

            public bool IsExpired()
            {
                return Expires < DateTime.Now;
            }
        }
        
        private void OnServerInitialized()
        {
            SetupConfig(ref _config);
            timer.Every(120f, () =>
            {
                var delete = new List<string>();
                // Clean up expired cache so that it doesn't sit in memory forever
                foreach (var cache in _cache)
                {
                    if (cache.Value.IsExpired())
                    {
                        delete.Add(cache.Key);
                    }
                }

                foreach (var d in delete)
                {
                    _cache.Remove(d);
                }
            });
        }

        #endregion
        
        #region Config

        protected void SaveConfig<T>(T obj) => Config.WriteObject(obj);

        private class Configuration
        {
            public bool Debug = false;
        }

        public void SetupConfig<T>(ref T config) where T : new()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<T>();
                if (config == null) throw new Exception();

                SaveConfig<T>(config);
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                config = new T();
            }
        }

        private Configuration _config;
        #endregion
        
        public class DataManager<T>
        {
            private Dictionary<string, DataList<T>> _data = new Dictionary<string, DataList<T>>();

            private List<string> _needsWriting = new List<string>();

            public string _fileName;

            public string _filePattern = @".*\/([\d]+)_([a-zA-Z]+)";


            public DataManager(string filename="", string filepattern="")
            {
                _fileName = filename;
                if (filepattern != "") _filePattern = filepattern;
                Load();
            }

            public List<string> GetKeys(){
                return new List<string>(_data.Keys);
            }

            public void Load()
            {
                try
                {
                    foreach (string file in Interface.Oxide.DataFileSystem.GetFiles("DataLogger",
                        "*_" + GetFileExt() + ".json"))
                    {
                        Match match = Regex.Match(file, _filePattern);
                        if (match.Success)
                        {
                            var uid = match.Groups[1].Value;
                            if (!_data.ContainsKey(uid))
                            {
                                _data.Add(uid, new DataList<T>(uid, GetFileExt()));
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine(e.Message);
                }
            }

            private string GetFileExt()
            {
                if (!string.IsNullOrEmpty(_fileName))
                {
                    return _fileName;
                }
                return typeof(T).Name.ToLower();
            }

            public List<T> GetData(string uid)
            {
                if (!_data.ContainsKey(uid))
                {
                    return new List<T>();
                }
                return _data[uid].GetData();
            }

            public Dictionary<string, DataList<T>> GetAllData()
            {
                return _data;
            }


            public void NeedsWriting(string uid)
            {
                if (!_needsWriting.Contains(uid))
                {
                    _needsWriting.Add(uid);
                }
            }
            
            public void AddData(string uid, T obj)
            {
                if (!_data.ContainsKey(uid))
                {
                    _data.Add(uid, new DataList<T>(uid, GetFileExt()));
                }
                _data[uid].AddData(obj);
                NeedsWriting(uid);
            }
            
            public void Save()
            {
                foreach (var uid in _needsWriting)
                {
                    if (_data.ContainsKey(uid))
                    {
                        _data[uid].Save();
                    }
                }
                _needsWriting.Clear();
            }

            public T GetDataLast(string playerId)
            {
                var data = GetData(playerId);
                if (data.Count == 0)
                {
                    return default(T);
                }

                return data[data.Count - 1];
            }
        }
        
        public class DataList<T>
        {
            private string _uid;

            private List<T> _list;

            private string _fileExt;

            public DataList(string userId, string filename)
            {
                _uid = userId;
                _fileExt = filename;
                Load();
            }

            private string Filename()
            {
                return "DataLogger\\" + _uid + "_" + _fileExt;
            }

            public void Load()
            {
                _list = Interface.Oxide.DataFileSystem.ReadObject<List<T>>(Filename());
            }

            public void Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject(Filename(), _list);
            }

            public List<T> GetData()
            {
                return _list;
            }

            public void AddData(T obj)
            {
                _list.Add(obj);
            }

            public T GetDataLast()
            {
                if (_list.Count == 0)
                {
                    return default(T);
                }

                return _list[_list.Count - 1];
            }
        }
        
        #region Helpers
        
        public void Debug(string txt)
        {
            if (_config.Debug)
            {
                Puts(txt);
            }
        }

        
        [CanBeNull]
        public IPlayer GetCommandPlayer(IPlayer iplayer, string[] args)
        {
            if (args.ElementAtOrDefault(0) == null) return iplayer;

            var player = players.FindPlayer(args[0]);
            if (player == null)
            {
                return null;
            }

            return player;
        }
        
        #endregion

    }
}

// --- End of file: DataLogging.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-death ---
// --- Original File Path: D/DiscordDeath/DiscordDeath.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Discord Death", "MJSU", "2.2.0")]
    [Description("Displays deaths to a discord channel")]
    internal class DiscordDeath : CovalencePlugin
    {
        #region Class Fields
        [PluginReference] private Plugin DeathNotes, PlaceholderAPI;

        private PluginConfig _pluginConfig;
        private DeathNotesConfiguration _deathNotesConfig;

        private const string DefaultUrl = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
        private const string EmptyField = "\u200b";

        private Hash<string, string> _weaponPrefabs;
        
        private enum DebugEnum
        {
            Message,
            None,
            Error,
            Warning,
            Info
        }
        
        public enum CombatEntityType
        {
            Helicopter = 0,
            Bradley = 1,
            Animal = 2,
            Murderer = 3,
            Scientist = 4,
            Player = 5,
            Trap = 6,
            Turret = 7,
            Barricade = 8,
            ExternalWall = 9,
            HeatSource = 10,
            Fire = 11,
            Lock = 12,
            Sentry = 13,
            Other = 14,
            None = 15,
            Scarecrow = 16,
            TunnelDweller = 17,
            UnderwaterDweller = 18,
            ZombieNPC = 19
        }

        private Action<IPlayer, StringBuilder, bool> _replacer;
        private readonly StringBuilder _parser = new StringBuilder();

        private DeathData _deathData;
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.UnknownOwner] = "Unknown Owner",
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.DisplayOptions = config.DisplayOptions ?? new List<DisplayOption>
            {
                new DisplayOption
                {
                    WebhookUrl = DefaultUrl,
                    KillerType = "Player",
                    VictimType = "*"
                },
                new DisplayOption
                {
                    WebhookUrl = DefaultUrl,
                    KillerType = "Animal",
                    VictimType = "Player"
                }
            };

            config.DeathMessage = config.DeathMessage ?? new DiscordMessageConfig
            {
                Content = "",
                Embed = new EmbedConfig
                {
                    Color = "#ff6961",
                    Title = "{server.name}",
                    Enabled = true,
                    Url = string.Empty,
                    Image = string.Empty,
                    Thumbnail = string.Empty,
                    Description = ":crossed_swords: {discorddeath.message} :crossed_swords:",
                    Footer = new FooterConfig
                    {
                        IconUrl = string.Empty,
                        Text = string.Empty,
                        Enabled = true
                    },
                    Fields = new List<FieldConfig>
                    {
                        new FieldConfig
                        {
                            Title = "Victim Type",
                            Value = "{discorddeath.victim.type}",
                            Inline = true
                        },
                        new FieldConfig
                        {
                            Title = "Victim",
                            Value = "{discorddeath.victim.name}({discorddeath.victim.id})",
                            Inline = true
                        },      
                        new FieldConfig
                        {
                            Title = "Body Part",
                            Value = "{discorddeath.victim.bodypart}",
                            Inline = true
                        },
                        new FieldConfig
                        {
                            Title = "Attacker Type",
                            Value = "{discorddeath.killer.type}",
                            Inline = true
                        },
                        new FieldConfig
                        {
                            Title = "Attacker",
                            Value = "{discorddeath.killer.name} ({discorddeath.killer.id})",
                            Inline = true
                        }, 
                        new FieldConfig
                        {
                            Title = "Attacker Health",
                            Value = "{discorddeath.killer.health:0.00} HP",
                            Inline = true
                        },
                        new FieldConfig
                        {
                            Title = "Weapon",
                            Value = "{discorddeath.killer.weapon} ({discorddeath.killer.attachments})",
                            Inline = true
                        },  
                        new FieldConfig
                        {
                            Title = "Distance",
                            Value = "{discorddeath.killer.distance:0.00} Meters",
                            Inline = true
                        },  
                        new FieldConfig
                        {
                            Title = "Entity Owner",
                            Value = "{discorddeath.killer.owner}",
                            Inline = true
                        },  
                    }
                }
            };

            return config;
        }
        
        private void OnServerInitialized()
        {
            if (DeathNotes == null || !DeathNotes.IsLoaded)
            {
                PrintError("Missing plugin dependency DeathNotes: https://umod.org/plugins/death-notes");
            }
            else if (DeathNotes.Version < new VersionNumber(6, 3, 6))
            {
                PrintError("DeathNotes plugin must be version 6.3.6 or higher");
            }

            if (!IsPlaceholderApiLoaded())
            {
                PrintError("Missing plugin dependency PlaceholderAPI: https://umod.org/plugins/placeholder-api");
            } 
            else if(PlaceholderAPI.Version < new VersionNumber(2, 2, 0))
            {
                PrintError("Placeholder API plugin must be version 2.2.0 or higher");
            }
            
            foreach (DisplayOption option in _pluginConfig.DisplayOptions)
            {
                if (!string.IsNullOrEmpty(option.WebhookUrl) && option.WebhookUrl != DefaultUrl)
                {
                    option.WebhookUrl = option.WebhookUrl.Replace("/api/webhooks", "/api/v9/webhooks");
                }
            }

            LoadDeathNotesConfig();
            LoadWeaponPrefabs();
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Name == nameof(DeathNotes))
            {
                LoadDeathNotesConfig();
                LoadWeaponPrefabs();
            }
        }
        #endregion

        #region Death Hook
        private void OnDeathNotice(Dictionary<string, object> data, string message)
        {
            string victim = data["VictimEntityType"].ToString();
            string killer = data["KillerEntityType"].ToString();
            DisplayOption option = null;
            
            foreach (DisplayOption display in _pluginConfig.DisplayOptions)
            {
                if ((display.KillerType == "*" || display.KillerType.Equals(killer, StringComparison.OrdinalIgnoreCase) || (display.KillerType == "-" && killer.Equals("None", StringComparison.OrdinalIgnoreCase)))
                    && (display.VictimType == "*" || display.VictimType.Equals(victim, StringComparison.OrdinalIgnoreCase)  || (display.VictimType == "-" && victim.Equals("None", StringComparison.OrdinalIgnoreCase))))
                {
                    option = display;
                    break;
                }
            }
            
            if (option == null)
            {
                return;
            }

            DeathNotesData notesData = new DeathNotesData(data);
            _deathData = CreateDeathData(notesData, message);

            DiscordMessage discordMessage = ParseMessage(_pluginConfig.DeathMessage);
            
            SendDiscordMessage(option.WebhookUrl, discordMessage);
        }
        #endregion

        #region Death Notes
        public DeathData CreateDeathData(DeathNotesData data, string message)
        {
            DeathData death = new DeathData
            {
                VictimType = data.VictimEntityType.ToString(),
                VictimName = GetEntityName(data.VictimEntity, data.VictimEntityTypeRaw),
                Message = message
            };

            if (data.VictimEntity is BasePlayer && !data.VictimEntity.IsNpc)
            {
                death.VictimId = ((BasePlayer) data.VictimEntity).UserIDString;
            }
            else
            {
                death.VictimId = data.VictimEntity.net.ID.ToString();
            }

            if (data.KillerEntityType != CombatEntityType.None)
            {
                death.KillerType = data.KillerEntityType.ToString();
                death.KillerName = GetEntityName(data.KillerEntity, data.KillerEntityTypeRaw);
                death.BodyPart = GetBodyPart(data.HitInfo);

                if (data.KillerEntity is BasePlayer && !data.KillerEntity.IsNpc)
                {
                    death.KilledId = ((BasePlayer) data.KillerEntity).UserIDString;
                }
                else
                {
                    death.KilledId = data.KillerEntity.net.ID.ToString();
                }
                
                if (data.KillerEntity != null)
                {
                    death.Distance = data.KillerEntity.Distance(data.VictimEntity);
                    death.KillerHealth = data.KillerEntity.Health();
                    
                    if (death.KillerType.Equals("Player", StringComparison.OrdinalIgnoreCase))
                    {
                        death.Weapon = GetCustomizedWeaponName(data.HitInfo, data.DamageType);
                        death.Attachments = GetAttachments(data.HitInfo);
                    }
                    else if(death.KillerType.Equals("Turret", StringComparison.OrdinalIgnoreCase)
                            || death.KillerType.Equals("Lock", StringComparison.OrdinalIgnoreCase)
                            || death.KillerType.Equals("Trap", StringComparison.OrdinalIgnoreCase))
                    {
                        death.Owner = covalence.Players.FindPlayerById(data.KillerEntity.OwnerID.ToString())?.Name ?? Lang(LangKeys.UnknownOwner);
                    }
                }
            }

            death.EnsureNotEmpty();
            
            return death;
        }
        
        public string GetEntityName(BaseEntity entity, object type)
        {
            return DeathNotes?.Call<string>("GetCustomizedEntityName", entity, type);
        }

        public string GetBodyPart(HitInfo info)
        {
            return DeathNotes?.Call<string>("GetCustomizedBodypartName", info);
        }
        
        public string GetAttachments(HitInfo info)
        {
            string[] attachments = DeathNotes?.Call<string[]>("GetCustomizedAttachmentNames", info);
            if (attachments == null)
            {
                return string.Empty;
            }

            return string.Join(", ", attachments);
        }

        private string GetCustomizedWeaponName(HitInfo info, DamageType type)
        {
            string name = GetWeaponName(info, type);

            if (string.IsNullOrEmpty(name))
                return null;

            return _deathNotesConfig?.Translations.Weapons[name] ?? name;
        }

        public float GetDistance(float distance)
        {
            if (_deathNotesConfig.UseMetricDistance)
            {
                return distance * 3.28f;
            }

            return distance;
        }

        private string GetWeaponName(HitInfo info, DamageType type)
        {
            if (info == null)
            {
                return null;
            }

            Item item = info.Weapon?.GetItem();
            if (item != null)
            {
                return item.info.displayName.english;
            }

            //TODO: Find way to access flame
            //string prefab = info.Initiator?.GetComponent<Flame>()?.SourceEntity?.ShortPrefabName ?? info.WeaponPrefab?.ShortPrefabName;
            string prefab = info.WeaponPrefab?.ShortPrefabName;
            if (prefab != null)
            {
                if (_weaponPrefabs?.ContainsKey(prefab) ?? false)
                {
                    return _weaponPrefabs[prefab];
                }

                return prefab;
            }
            
            if (type == DamageType.Collision)
            {
                return "Vehicle";
            }

            return null;
        }

        public void LoadWeaponPrefabs()
        {
            if (IsDeathNotesLoaded())
            {
                _weaponPrefabs = Interface.Oxide.DataFileSystem.ReadObject<Hash<string, string>>($"{nameof(DeathNotes)}/WeaponPrefabs");
            }
        }
        
        public void LoadDeathNotesConfig()
        {
            if (IsDeathNotesLoaded())
            {
                string path = $"{Interface.Oxide.ConfigDirectory}/{nameof(DeathNotes)}.json";
                DynamicConfigFile newConfig = new DynamicConfigFile(path);
                if (newConfig.Exists())
                {
                    _deathNotesConfig = newConfig.ReadObject<DeathNotesConfiguration>();
                }
            }
        }
        
        private sealed class DeathNotesConfiguration
        {
            [JsonProperty("Translations")]
            public Translation Translations = new Translation();

            [JsonProperty("Use Metric Distance")]
            public bool UseMetricDistance = true;
            
            public class Translation
            {
                [JsonProperty("Names")]
                public Hash<string, string> Names = new Hash<string, string>();

                [JsonProperty("Bodyparts")]
                public Hash<string, string> Bodyparts = new Hash<string, string>();

                [JsonProperty("Weapons")]
                public Hash<string, string> Weapons = new Hash<string, string>();

                [JsonProperty("Attachments")]
                public Hash<string, string> Attachments = new Hash<string, string>();
            }
        }
        #endregion

        #region PlaceholderAPI
        private string ParseField(string field)
        {
            _parser.Length = 0;
            _parser.Append(field);
            GetReplacer()?.Invoke(null, _parser, false);
            return _parser.ToString();
        }
        
        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin?.Name == "PlaceholderAPI")
            {
                _replacer = null;
            }
        }
        
        private void OnPlaceholderAPIReady()
        {
            RegisterPlaceholder("discorddeath.victim.type", (player, s) => _deathData.VictimType, "Displays the victim entity type");
            RegisterPlaceholder("discorddeath.victim.name", (player, s) => _deathData.VictimName, "Displays the victim entity name");
            RegisterPlaceholder("discorddeath.victim.id", (player, s) => _deathData.VictimId, "Displays the victim steam if player else entity id");
            RegisterPlaceholder("discorddeath.victim.bodypart", (player, s) => _deathData.BodyPart, "Displays the victim body part");
            RegisterPlaceholder("discorddeath.killer.type", (player, s) => _deathData.KillerType, "Displays the killer entity type");
            RegisterPlaceholder("discorddeath.killer.id", (player, s) => _deathData.KilledId, "Displays the killer steam if player else entity id");
            RegisterPlaceholder("discorddeath.killer.name", (player, s) => _deathData.KillerName, "Displays the killer entity name");
            RegisterPlaceholder("discorddeath.killer.weapon", (player, s) => _deathData.Weapon, "Displays the killer's weapon");
            RegisterPlaceholder("discorddeath.killer.attachments", (player, s) => _deathData.Attachments, "Displays the killer's attachments");
            RegisterPlaceholder("discorddeath.killer.health", (player, s) => _deathData.KillerHealth, "Displays the killer's health");
            RegisterPlaceholder("discorddeath.killer.owner", (player, s) => _deathData.Owner, "Displays the Owners name of the entity that did the killing");
            RegisterPlaceholder("discorddeath.killer.distance", (player, s) => GetDistance(_deathData.Distance), "Displays the distance to the victim the attacker was");
            RegisterPlaceholder("discorddeath.message", (player, s) => Formatter.ToPlaintext(StripRustTags(_deathData.Message)), "Displays the default death message");
        }

        private void RegisterPlaceholder(string key, Func<IPlayer, string, object> action, string description = null)
        {
            if (IsPlaceholderApiLoaded())
            {
                PlaceholderAPI.Call("AddPlaceholder", this, key, action, description);
            }
        }

        private Action<IPlayer, StringBuilder, bool> GetReplacer()
        {
            if (!IsPlaceholderApiLoaded())
            {
                return _replacer;
            }
            
            return _replacer ?? (_replacer = PlaceholderAPI.Call<Action<IPlayer, StringBuilder, bool>>("GetProcessPlaceholders", 1));
        }

        private bool IsPlaceholderApiLoaded() => PlaceholderAPI != null && PlaceholderAPI.IsLoaded;
        private bool IsDeathNotesLoaded() => DeathNotes != null && DeathNotes.IsLoaded;
        #endregion

        #region Rust Tag Stripping
        private readonly List<Regex> _regexTags = new List<Regex>
        {
            new Regex("<color=.+?>", RegexOptions.Compiled),
            new Regex("<size=.+?>", RegexOptions.Compiled)
        };

        private readonly List<string> _tags = new List<string>
        {
            "</color>",
            "</size>",
            "<i>",
            "</i>",
            "<b>",
            "</b>"
        };

        private string StripRustTags(string original)
        {
            if (string.IsNullOrEmpty(original))
            {
                return string.Empty;
            }

            for (int index = 0; index < _tags.Count; index++)
            {
                string tag = _tags[index];
                original = original.Replace(tag, string.Empty);
            }

            for (int index = 0; index < _regexTags.Count; index++)
            {
                Regex regexTag = _regexTags[index];
                original = regexTag.Replace(original, string.Empty);
            }

            return original;
        }
        #endregion

        #region Helpers
        private void Debug(DebugEnum level, string message)
        {
            if (level <= _pluginConfig.DebugLevel)
            {
                Puts($"{level}: {message}");
            }
        }
        
        public string Lang(string key, IPlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, player?.Id), args);
            }
            catch(Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception\n:{ex}");
                throw;
            }
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty("Display Options")]
            public List<DisplayOption> DisplayOptions { get; set; }

            [JsonProperty(PropertyName = "Death Message")]
            public DiscordMessageConfig DeathMessage { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DebugEnum.Warning)]
            [JsonProperty(PropertyName = "Debug Level (None, Error, Warning, Info)")]
            public DebugEnum DebugLevel { get; set; }
        }

        public class DisplayOption
        {
            [JsonProperty(PropertyName = "Webhook url")]
            public string WebhookUrl { get; set; }
            
            [JsonProperty(PropertyName = "Killer Type")]
            public string KillerType { get; set; }
            
            [JsonProperty(PropertyName = "Victim Type")]
            public string VictimType { get; set; }
        }

        public class DeathNotesData
        {
            public object VictimEntityTypeRaw { get; set; }
            public CombatEntityType VictimEntityType { get; set; }
            public BaseEntity VictimEntity { get; set; }
            
            public object KillerEntityTypeRaw { get; set; }
            public CombatEntityType KillerEntityType { get; set; }
            public BaseEntity KillerEntity { get; set; }
            public DamageType DamageType { get; set; }
            
            public HitInfo HitInfo { get; set; }
            
            public DeathNotesData(Dictionary<string,object> data)
            {
                if (data.ContainsKey("VictimEntityType"))
                {
                    VictimEntityTypeRaw = data["VictimEntityType"];
                    VictimEntityType = (CombatEntityType)(int)VictimEntityTypeRaw;
                }
                
                if (data.ContainsKey("VictimEntity"))
                {
                    VictimEntity = data["VictimEntity"] as BaseEntity;
                }
                
                if (data.ContainsKey("KillerEntityType"))
                {
                    KillerEntityTypeRaw = data["KillerEntityType"];
                    KillerEntityType = (CombatEntityType)(int)KillerEntityTypeRaw;
                }
                
                if (data.ContainsKey("KillerEntity"))
                {
                    KillerEntity = data["KillerEntity"] as BaseEntity;
                }
                
                if (data.ContainsKey("DamageType"))
                {
                    DamageType = (DamageType)data["DamageType"];
                }
                
                if (data.ContainsKey("HitInfo"))
                {
                    HitInfo = data["HitInfo"] as HitInfo;
                }
            }
        }
        
        public class DeathData
        {
            public string VictimName { get; set; }
            public string VictimId { get; set; }
            public string VictimType { get; set; }
            public string KillerName { get; set; }
            public string KilledId { get; set; }
            public string KillerType { get; set; }
            public float KillerHealth { get; set; }
            public string Weapon { get; set; }
            public string BodyPart { get; set; }
            public string Attachments { get; set; }
            public float Distance { get; set; }
            public string Owner { get; set; }
            public string Message { get; set; }

            public void EnsureNotEmpty()
            {
                if (string.IsNullOrEmpty(VictimName))
                {
                    VictimName = EmptyField;
                }
                
                if (string.IsNullOrEmpty(VictimId))
                {
                    VictimId = EmptyField;
                }
                
                if (string.IsNullOrEmpty(VictimType))
                {
                    VictimType = EmptyField;
                }

                if (string.IsNullOrEmpty(KillerName))
                {
                    KillerName = EmptyField;
                }
                
                if (string.IsNullOrEmpty(KilledId))
                {
                    KilledId = EmptyField;
                }
                
                if (string.IsNullOrEmpty(KillerType))
                {
                    KillerType = EmptyField;
                }
                
                if (string.IsNullOrEmpty(Weapon))
                {
                    Weapon = EmptyField;
                }

                if (string.IsNullOrEmpty(BodyPart))
                {
                    BodyPart = EmptyField;
                }
                
                if (string.IsNullOrEmpty(Owner))
                {
                    Owner = EmptyField;
                }
                
                if (string.IsNullOrEmpty(Message))
                {
                    Message = EmptyField;
                }
            }
        }
        
        private static class LangKeys
        {
            public const string UnknownOwner = nameof(UnknownOwner);
        }
        #endregion

        #region Discord Embed
        #region Send Embed Methods
        /// <summary>
        /// Headers when sending an embedded message
        /// </summary>
        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>()
        {
            {"Content-Type", "application/json"}
        };

        /// <summary>
        /// Sends the DiscordMessage to the specified webhook url
        /// </summary>
        /// <param name="url">Webhook url</param>
        /// <param name="message">Message being sent</param>
        private void SendDiscordMessage(string url, DiscordMessage message)
        {
            if (string.IsNullOrEmpty(url) || url == DefaultUrl)
            {
                Debug(DebugEnum.Warning, "Webhook URL not set. Please set url in config.");
                return;
            }
            
            string json = message.ToJson();
            if (_pluginConfig.DebugLevel >= DebugEnum.Info)
            {
                Debug(DebugEnum.Info, $"SendDiscordMessage - ToJson \n{json}");
            }

            webrequest.Enqueue(url, json, SendDiscordMessageCallback, this, RequestMethod.POST, _headers);
        }

        /// <summary>
        /// Callback when sending the embed if any errors occured
        /// </summary>
        /// <param name="code">HTTP response code</param>
        /// <param name="message">Response message</param>
        private void SendDiscordMessageCallback(int code, string message)
        {
            if (code != 204)
            {
                PrintError(message);
            }
        }
        #endregion

        #region Helper Methods
        private const string OwnerIcon = "https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/47/47db946f27bc76d930ac82f1656f7a10707bb67d_full.jpg";

        private void AddPluginInfoFooter(Embed embed)
        {
            embed.AddFooter($"{Title} V{Version} by {Author}", OwnerIcon);
        }
        #endregion

        #region Embed Classes
        private class DiscordMessage
        {
            /// <summary>
            /// The name of the user sending the message changing this will change the webhook bots name
            /// </summary>
            [JsonProperty("username")]
            private string Username { get; set; }

            /// <summary>
            /// The avatar url of the user sending the message changing this will change the webhook bots avatar
            /// </summary>
            [JsonProperty("avatar_url")]
            private string AvatarUrl { get; set; }

            /// <summary>
            /// String only content to be sent
            /// </summary>
            [JsonProperty("content")]
            private string Content { get; set; }

            /// <summary>
            /// Embeds to be sent
            /// </summary>
            [JsonProperty("embeds")]
            private List<Embed> Embeds { get; }

            public DiscordMessage(string username = null, string avatarUrl = null)
            {
                Username = username;
                AvatarUrl = avatarUrl;
                Embeds = new List<Embed>();
            }

            public DiscordMessage(string content, string username = null, string avatarUrl = null)
            {
                Content = content;
                Username = username;
                AvatarUrl = avatarUrl;
                Embeds = new List<Embed>();
            }

            public DiscordMessage(Embed embed, string username = null, string avatarUrl = null)
            {
                Embeds = new List<Embed> {embed};
                Username = username;
                AvatarUrl = avatarUrl;
            }

            /// <summary>
            /// Adds a new embed to the list of embed to send
            /// </summary>
            /// <param name="embed">Embed to add</param>
            /// <returns>This</returns>
            /// <exception cref="IndexOutOfRangeException">Thrown if more than 10 embeds are added in a send as that is the discord limit</exception>
            public DiscordMessage AddEmbed(Embed embed)
            {
                if (Embeds.Count >= 10)
                {
                    throw new IndexOutOfRangeException("Only 10 embed are allowed per message");
                }

                Embeds.Add(embed);
                return this;
            }

            /// <summary>
            /// Adds string content to the message
            /// </summary>
            /// <param name="content"></param>
            /// <returns></returns>
            public DiscordMessage AddContent(string content)
            {
                Content = content;
                return this;
            }

            /// <summary>
            /// Changes the username and avatar image for the bot sending the message
            /// </summary>
            /// <param name="username">username to change</param>
            /// <param name="avatarUrl">avatar img url to change</param>
            /// <returns>This</returns>
            public DiscordMessage AddSender(string username, string avatarUrl)
            {
                Username = username;
                AvatarUrl = avatarUrl;
                return this;
            }

            /// <summary>
            /// Returns message as JSON to be sent in the web request
            /// </summary>
            /// <returns></returns>
            public string ToJson() => JsonConvert.SerializeObject(this, Formatting.None,
                new JsonSerializerSettings {NullValueHandling = NullValueHandling.Ignore});
        }

        private class Embed
        {
            /// <summary>
            /// Color of the left side bar of the embed message
            /// </summary>
            [JsonProperty("color")]
            private int Color { get; set; }

            /// <summary>
            /// Fields to be added to the embed message
            /// </summary>
            [JsonProperty("fields")]
            private List<Field> Fields { get; } = new List<Field>();

            /// <summary>
            /// Title of the embed message
            /// </summary>
            [JsonProperty("title")]
            private string Title { get; set; }

            /// <summary>
            /// Description of the embed message
            /// </summary>
            [JsonProperty("description")]
            private string Description { get; set; }

            /// <summary>
            /// Description of the embed message
            /// </summary>
            [JsonProperty("url")]
            private string Url { get; set; }

            /// <summary>
            /// Image to added to the embed message. Appears at the bottom of the message above the footer
            /// </summary>
            [JsonProperty("image")]
            private Image Image { get; set; }

            /// <summary>
            /// Thumbnail image added to the embed message. Appears in the top right corner
            /// </summary>
            [JsonProperty("thumbnail")]
            private Image Thumbnail { get; set; }

            /// <summary>
            /// Video to add to the embed message
            /// </summary>
            [JsonProperty("video")]
            private Video Video { get; set; }

            /// <summary>
            /// Author to add to the embed message. Appears above the title.
            /// </summary>
            [JsonProperty("author")]
            private AuthorInfo Author { get; set; }

            /// <summary>
            /// Footer to add to the embed message. Appears below all content.
            /// </summary>
            [JsonProperty("footer")]
            private Footer Footer { get; set; }

            /// <summary>
            /// Adds a title to the embed message
            /// </summary>
            /// <param name="title">Title to add</param>
            /// <returns>This</returns>
            public Embed AddTitle(string title)
            {
                Title = title;
                return this;
            }

            /// <summary>
            /// Adds a description to the embed message
            /// </summary>
            /// <param name="description">description to add</param>
            /// <returns>This</returns>
            public Embed AddDescription(string description)
            {
                Description = description;
                return this;
            }

            /// <summary>
            /// Adds a url to the embed message
            /// </summary>
            /// <param name="url"></param>
            /// <returns>This</returns>
            public Embed AddUrl(string url)
            {
                Url = url;
                return this;
            }

            /// <summary>
            /// Adds an author to the embed message. The author will appear above the title
            /// </summary>
            /// <param name="name">Name of the author</param>
            /// <param name="iconUrl">Icon Url to use for the author</param>
            /// <param name="url">Url to go to when the authors name is clicked on</param>
            /// <param name="proxyIconUrl">Backup icon url. Can be left null if you only have one icon url</param>
            /// <returns>This</returns>
            public Embed AddAuthor(string name, string iconUrl = null, string url = null, string proxyIconUrl = null)
            {
                Author = new AuthorInfo(name, iconUrl, url, proxyIconUrl);
                return this;
            }

            /// <summary>
            /// Adds a footer to the embed message
            /// </summary>
            /// <param name="text">Text to be added to the footer</param>
            /// <param name="iconUrl">Icon url to add in the footer. Appears to the left of the text</param>
            /// <param name="proxyIconUrl">Backup icon url. Can be left null if you only have one icon url</param>
            /// <returns>This</returns>
            public Embed AddFooter(string text, string iconUrl = null, string proxyIconUrl = null)
            {
                Footer = new Footer(text, iconUrl, proxyIconUrl);

                return this;
            }

            /// <summary>
            /// Adds an int based color to the embed. Color appears as a bar on the left side of the message
            /// </summary>
            /// <param name="color"></param>
            /// <returns></returns>
            public Embed AddColor(int color)
            {
                if (color < 0x0 || color > 0xFFFFFF)
                {
                    throw new Exception($"Color '{color}' is outside the valid color range");
                }

                Color = color;
                return this;
            }

            /// <summary>
            /// Adds a hex based color. Color appears as a bar on the left side of the message
            /// </summary>
            /// <param name="color">Color in string hex format</param>
            /// <returns>This</returns>
            /// <exception cref="Exception">Exception thrown if color is outside of range</exception>
            public Embed AddColor(string color)
            {
                int parsedColor = int.Parse(color.TrimStart('#'), NumberStyles.AllowHexSpecifier);
                if (parsedColor < 0x0 || parsedColor > 0xFFFFFF)
                {
                    throw new Exception($"Color '{color}' is outside the valid color range");
                }

                Color = parsedColor;
                return this;
            }

            /// <summary>
            /// Adds a RGB based color. Color appears as a bar on the left side of the message
            /// </summary>
            /// <param name="red">Red value between 0 - 255</param>
            /// <param name="green">Green value between 0 - 255</param>
            /// <param name="blue">Blue value between 0 - 255</param>
            /// <returns>This</returns>
            /// <exception cref="Exception">Thrown if red, green, or blue is outside of range</exception>
            public Embed AddColor(int red, int green, int blue)
            {
                if (red < 0 || red > 255 || green < 0 || green > 255 || blue < 0 || blue > 255)
                {
                    throw new Exception($"Color Red:{red} Green:{green} Blue:{blue} is outside the valid color range. Must be between 0 - 255");
                }

                Color = red * 65536 + green * 256 + blue;
                ;
                return this;
            }

            /// <summary>
            /// Adds a blank field.
            /// If inline it will add a blank column.
            /// If not inline will add a blank row
            /// </summary>
            /// <param name="inline">If the field is inline</param>
            /// <returns>This</returns>
            public Embed AddBlankField(bool inline)
            {
                Fields.Add(new Field("\u200b", "\u200b", inline));
                return this;
            }

            /// <summary>
            /// Adds a new field with the name as the title and value as the value.
            /// If inline will add a new column. If row will add in a new row.
            /// </summary>
            /// <param name="name"></param>
            /// <param name="value"></param>
            /// <param name="inline"></param>
            /// <returns></returns>
            public Embed AddField(string name, string value, bool inline)
            {
                Fields.Add(new Field(name, value, inline));
                return this;
            }

            /// <summary>
            /// Adds an image to the embed. The url should point to the url of the image.
            /// If using attachment image you can make the url: "attachment://{image name}.{image extension}
            /// </summary>
            /// <param name="url">Url for the image</param>
            /// <param name="width">width of the image</param>
            /// <param name="height">height of the image</param>
            /// <param name="proxyUrl">Backup url for the image</param>
            /// <returns></returns>
            public Embed AddImage(string url, int? width = null, int? height = null, string proxyUrl = null)
            {
                Image = new Image(url, width, height, proxyUrl);
                return this;
            }

            /// <summary>
            /// Adds a thumbnail in the top right corner of the embed
            /// If using attachment image you can make the url: "attachment://{image name}.{image extension}
            /// </summary>
            /// <param name="url">Url for the image</param>
            /// <param name="width">width of the image</param>
            /// <param name="height">height of the image</param>
            /// <param name="proxyUrl">Backup url for the image</param>
            /// <returns></returns>
            public Embed AddThumbnail(string url, int? width = null, int? height = null, string proxyUrl = null)
            {
                Thumbnail = new Image(url, width, height, proxyUrl);
                return this;
            }

            /// <summary>
            /// Adds a video to the embed
            /// </summary>
            /// <param name="url">Url for the video</param>
            /// <param name="width">Width of the video</param>
            /// <param name="height">Height of the video</param>
            /// <returns></returns>
            public Embed AddVideo(string url, int? width = null, int? height = null)
            {
                Video = new Video(url, width, height);
                return this;
            }
        }

        /// <summary>
        /// Field for and embed message
        /// </summary>
        private class Field
        {
            /// <summary>
            /// Name of the field
            /// </summary>
            [JsonProperty("name")]
            private string Name { get; }

            /// <summary>
            /// Value for the field
            /// </summary>
            [JsonProperty("value")]
            private string Value { get; }

            /// <summary>
            /// If the field should be in the same row or a new row
            /// </summary>
            [JsonProperty("inline")]
            private bool Inline { get; }

            public Field(string name, string value, bool inline)
            {
                Name = name;
                Value = value;
                Inline = inline;
            }
        }

        /// <summary>
        /// Image for an embed message
        /// </summary>
        private class Image
        {
            /// <summary>
            /// Url for the image
            /// </summary>
            [JsonProperty("url")]
            private string Url { get; }

            /// <summary>
            /// Width for the image
            /// </summary>
            [JsonProperty("width")]
            private int? Width { get; }

            /// <summary>
            /// Height for the image
            /// </summary>
            [JsonProperty("height")]
            private int? Height { get; }

            /// <summary>
            /// Proxy url for the image
            /// </summary>
            [JsonProperty("proxyURL")]
            private string ProxyUrl { get; }

            public Image(string url, int? width, int? height, string proxyUrl)
            {
                Url = url;
                Width = width;
                Height = height;
                ProxyUrl = proxyUrl;
            }
        }

        /// <summary>
        /// Video for an embed message
        /// </summary>
        private class Video
        {
            /// <summary>
            /// Url to the video
            /// </summary>
            [JsonProperty("url")]
            private string Url { get; }

            /// <summary>
            /// Width of the video
            /// </summary>
            [JsonProperty("width")]
            private int? Width { get; }

            /// <summary>
            /// Height of the video
            /// </summary>
            [JsonProperty("height")]
            private int? Height { get; }

            public Video(string url, int? width, int? height)
            {
                Url = url;
                Width = width;
                Height = height;
            }
        }

        /// <summary>
        /// Author of an embed message
        /// </summary>
        private class AuthorInfo
        {
            /// <summary>
            /// Name of the author
            /// </summary>
            [JsonProperty("name")]
            private string Name { get; }

            /// <summary>
            /// Url to go to when clicking on the authors name
            /// </summary>
            [JsonProperty("url")]
            private string Url { get; }

            /// <summary>
            /// Icon url for the author
            /// </summary>
            [JsonProperty("icon_url")]
            private string IconUrl { get; }

            /// <summary>
            /// Proxy icon url for the author
            /// </summary>
            [JsonProperty("proxy_icon_url")]
            private string ProxyIconUrl { get; }

            public AuthorInfo(string name, string iconUrl, string url, string proxyIconUrl)
            {
                Name = name;
                Url = url;
                IconUrl = iconUrl;
                ProxyIconUrl = proxyIconUrl;
            }
        }

        /// <summary>
        /// Footer for an embed message
        /// </summary>
        private class Footer
        {
            /// <summary>
            /// Text for the footer
            /// </summary>
            [JsonProperty("text")]
            private string Text { get; }

            /// <summary>
            /// Icon url for the footer
            /// </summary>
            [JsonProperty("icon_url")]
            private string IconUrl { get; }

            /// <summary>
            /// Proxy icon url for the footer
            /// </summary>
            [JsonProperty("proxy_icon_url")]
            private string ProxyIconUrl { get; }

            public Footer(string text, string iconUrl, string proxyIconUrl)
            {
                Text = text;
                IconUrl = iconUrl;
                ProxyIconUrl = proxyIconUrl;
            }
        }
        #endregion

        #region Attachment Classes
        /// <summary>
        /// Enum for attachment content type
        /// </summary>
        private enum AttachmentContentType
        {
            Png,
            Jpg
        }

        private class Attachment
        {
            /// <summary>
            /// Attachment data
            /// </summary>
            public byte[] Data { get; }

            /// <summary>
            /// File name for the attachment.
            /// Used in the url field of an image
            /// </summary>
            public string Filename { get; }

            /// <summary>
            /// Content type for the attachment
            /// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
            /// </summary>
            public string ContentType { get; }

            public Attachment(byte[] data, string filename, AttachmentContentType contentType)
            {
                Data = data;
                Filename = filename;

                switch (contentType)
                {
                    case AttachmentContentType.Jpg:
                        ContentType = "image/jpeg";
                        break;

                    case AttachmentContentType.Png:
                        ContentType = "image/png";
                        break;
                }
            }

            public Attachment(byte[] data, string filename, string contentType)
            {
                Data = data;
                Filename = filename;
                ContentType = contentType;
            }
        }
        #endregion

        #region Config Classes
        private class DiscordMessageConfig
        {
            public string Content { get; set; }
            public EmbedConfig Embed { get; set; }
        }

        private class EmbedConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled { get; set; }

            [JsonProperty("Title")]
            public string Title { get; set; }

            [JsonProperty("Description")]
            public string Description { get; set; }

            [JsonProperty("Url")]
            public string Url { get; set; }

            [JsonProperty("Embed Color")]
            public string Color { get; set; }

            [JsonProperty("Image Url")]
            public string Image { get; set; }

            [JsonProperty("Thumbnail Url")]
            public string Thumbnail { get; set; }

            [JsonProperty("Fields")]
            public List<FieldConfig> Fields { get; set; }

            [JsonProperty("Footer")]
            public FooterConfig Footer { get; set; }
        }

        private class FieldConfig
        {
            [JsonProperty("Title")]
            public string Title { get; set; }

            [JsonProperty("Value")]
            public string Value { get; set; }

            [JsonProperty("Inline")]
            public bool Inline { get; set; }
        }

        private class FooterConfig
        {
            [JsonProperty("Icon Url")]
            public string IconUrl { get; set; }

            [JsonProperty("Text")]
            public string Text { get; set; }

            [JsonProperty("Enabled")]
            public bool Enabled { get; set; }
        }
        #endregion

        #region Config Methods
        private DiscordMessage ParseMessage(DiscordMessageConfig config)
        {
            DiscordMessage message = new DiscordMessage();

            if (!string.IsNullOrEmpty(config.Content))
            {
                message.AddContent(ParseField(config.Content));
            }

            if (config.Embed != null && config.Embed.Enabled)
            {
                EmbedConfig embedConfig = config.Embed;
                Embed embed = new Embed();
                string title = ParseField(embedConfig.Title);
                if (!string.IsNullOrEmpty(title))
                {
                    embed.AddTitle(title);
                }

                string description = ParseField(embedConfig.Description);
                if (!string.IsNullOrEmpty(description))
                {
                    embed.AddDescription(description);
                }

                string url = ParseField(embedConfig.Url);
                if (!string.IsNullOrEmpty(url))
                {
                    embed.AddUrl(url);
                }

                string color = ParseField(embedConfig.Color);
                if (!string.IsNullOrEmpty(color))
                {
                    embed.AddColor(color);
                }

                string img = ParseField(embedConfig.Image);
                if (!string.IsNullOrEmpty(img))
                {
                    embed.AddImage(img);
                }

                string thumbnail = ParseField(embedConfig.Thumbnail);
                if (!string.IsNullOrEmpty(thumbnail))
                {
                    embed.AddThumbnail(thumbnail);
                }

                foreach (FieldConfig field in embedConfig.Fields)
                {
                    string value = ParseField(field.Value);
                    if (string.IsNullOrEmpty(value) || value == EmptyField)
                    {
                        //PrintWarning($"Field: {field.Title} was skipped because the value was null or empty.");
                        continue;
                    }

                    embed.AddField(field.Title, value, field.Inline);
                }

                if (embedConfig.Footer != null && embedConfig.Footer.Enabled)
                {
                    if (string.IsNullOrEmpty(embedConfig.Footer.Text) &&
                        string.IsNullOrEmpty(embedConfig.Footer.IconUrl))
                    {
                        AddPluginInfoFooter(embed);
                    }
                    else
                    {
                        string text = ParseField(embedConfig.Footer.Text);
                        string footerUrl = ParseField(embedConfig.Footer.IconUrl);
                        embed.AddFooter(text, footerUrl);
                    }
                }

                message.AddEmbed(embed);        
            }

            return message;
        }
        #endregion
        #endregion
    }
}

// --- End of file: DiscordDeath.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/drone-turrets ---
// --- Original File Path: D/DroneTurrets/DroneTurrets.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Drone Turrets", "WhiteThunder", "1.3.3")]
    [Description("Allows players to deploy auto turrets to RC drones.")]
    internal class DroneTurrets : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin DroneSettings, EntityScaleManager;

        private Configuration _config;

        private const float TurretScale = 0.6f;

        private const string PermissionDeploy = "droneturrets.deploy";
        private const string PermissionDeployNpc = "droneturrets.deploynpc";
        private const string PermissionDeployFree = "droneturrets.deploy.free";
        private const string PermissionAutoDeploy = "droneturrets.autodeploy";
        private const string PermissionControl = "droneturrets.control";

        private const string SpherePrefab = "assets/prefabs/visualization/sphere.prefab";
        private const string AutoTurretPrefab = "assets/prefabs/npc/autoturret/autoturret_deployed.prefab";
        private const string NpcAutoTurretPrefab = "assets/content/props/sentry_scientists/sentry.bandit.static.prefab";
        private const string ElectricSwitchPrefab = "assets/prefabs/deployable/playerioents/simpleswitch/switch.prefab";
        // private const string AlarmPrefab = "assets/prefabs/io/electric/other/alarmsound.prefab";
        private const string AlarmPrefab = "assets/prefabs/deployable/playerioents/alarms/audioalarm.prefab";
        private const string SirenLightPrefab = "assets/prefabs/io/electric/lights/sirenlightorange.prefab";
        private const string DeployEffectPrefab = "assets/prefabs/npc/autoturret/effects/autoturret-deploy.prefab";
        private const string CodeLockDeniedEffectPrefab = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";

        private const int AutoTurretItemId = -2139580305;

        private const BaseEntity.Slot TurretSlot = BaseEntity.Slot.UpperModifier;

        private static readonly Vector3 SphereEntityLocalPosition = new(0, -0.14f, 0);
        private static readonly Vector3 TurretSwitchPosition = new Vector3(0, 0.36f, -0.32f);
        private static readonly Quaternion TurretSwitchRotation = Quaternion.Euler(0, 180, 0);

        private static readonly Vector3 SphereTransformScale = new(TurretScale, TurretScale, TurretScale);
        private static readonly Vector3 TurretTransformScale = new(1 / TurretScale, 1 / TurretScale, 1 / TurretScale);

        private readonly object True = true;
        private readonly object False = false;

        private DynamicHookSubscriber<NetworkableId> _turretDroneTracker;

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionDeploy, this);
            permission.RegisterPermission(PermissionDeployNpc, this);
            permission.RegisterPermission(PermissionDeployFree, this);
            permission.RegisterPermission(PermissionAutoDeploy, this);
            permission.RegisterPermission(PermissionControl, this);

            var dynamicHookNames = new List<string>
            {
                nameof(OnServerCommand),
                nameof(OnSwitchToggle),
                nameof(OnSwitchToggled),
                nameof(OnTurretTarget),
                nameof(OnEntityTakeDamage),
                nameof(OnEntityKill),
                nameof(OnEntityDeath),
                nameof(CanPickupEntity),
                nameof(OnBookmarkControlStarted),
                nameof(OnBookmarkControlEnded),
                nameof(canRemove),
            };

            _turretDroneTracker = new DynamicHookSubscriber<NetworkableId>(this, dynamicHookNames.ToArray());
            _turretDroneTracker.UnsubscribeAll();
        }

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null || !RCUtils.IsRCDrone(drone))
                    continue;

                var turret = GetDroneTurret(drone);
                if (turret == null)
                    continue;

                RefreshDroneTurret(drone, turret);
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                var turret = RCUtils.GetControlledEntity<AutoTurret>(player, out var station);
                if (turret == null)
                    continue;

                OnBookmarkControlStarted(station, player, turret.GetIdentifier(), turret);
            }
        }

        private void Unload()
        {
            DroneController.DestroyAll();
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
                return null;

            var player = arg.Player();
            if (player == null)
                return null;

            if (arg.cmd.FullName == "vehicle.swapseats")
            {
                HandleSwapSeats(player);
                return null;
            }

            if (arg.cmd.FullName == "inventory.lighttoggle")
                return HandleLightToggle(player);

            return null;
        }

        private void OnEntityBuilt(Planner planner, GameObject go)
        {
            if (planner == null || go == null)
                return;

            var drone = go.ToBaseEntity() as Drone;
            if (drone == null)
                return;

            var player = planner.GetOwnerPlayer();
            if (player == null)
                return;

            var drone2 = drone;

            NextTick(() =>
            {
                // Delay this check to allow time for other plugins to deploy an entity to this slot.
                if (drone2 == null || player == null || drone2.GetSlot(TurretSlot) != null)
                    return;

                if (permission.UserHasPermission(player.UserIDString, PermissionAutoDeploy))
                {
                    DeployAutoTurret(drone2, player, 1);
                }
                else if (permission.UserHasPermission(player.UserIDString, PermissionDeploy)
                    && UnityEngine.Random.Range(0, 100) < _config.TipChance)
                {
                    ChatMessage(player, Lang.TipDeployCommand);
                }
            });
        }

        private object OnSwitchToggle(ElectricSwitch electricSwitch, BasePlayer player)
        {
            var turret = GetParentTurret(electricSwitch);
            if (turret == null)
                return null;

            var drone = GetParentDrone(turret);
            if (drone == null)
                return null;

            if (!player.CanBuild())
            {
                // Disallow switching the turret on and off while building blocked.
                Effect.server.Run(CodeLockDeniedEffectPrefab, electricSwitch, 0, Vector3.zero, Vector3.forward);
                return False;
            }

            return null;
        }

        private void OnSwitchToggled(ElectricSwitch electricSwitch)
        {
            var turret = GetParentTurret(electricSwitch);
            if (turret == null)
                return;

            var drone = GetParentDrone(turret);
            if (drone == null)
                return;

            if (electricSwitch.IsOn())
            {
                turret.InitiateStartup();
            }
            else
            {
                turret.InitiateShutdown();
            }

            RefreshAlarmState(drone, turret);
        }

        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity target)
        {
            if (turret == null || target == null || GetParentDrone(turret) == null)
                return null;

            if (!_config.TargetAnimals && target is BaseAnimalNPC)
                return False;

            var basePlayer = target as BasePlayer;
            if (basePlayer != null)
            {
                if (!_config.TargetNPCs && basePlayer.IsNpc)
                    return False;

                if (!_config.TargetPlayers && basePlayer.userID.IsSteamId())
                    return False;

                // Don't target human or NPC players in safe zones, unless they are hostile.
                if (basePlayer.InSafeZone() && (basePlayer.IsNpc || !basePlayer.IsHostile()))
                    return False;

                return null;
            }

            return null;
        }

        // Redirect damage from the turret to the drone.
        private object OnEntityTakeDamage(AutoTurret turret, HitInfo info)
        {
            var drone = GetParentDrone(turret);
            if (drone == null)
                return null;

            drone.Hurt(info);
            HitNotify(drone, info);

            return True;
        }

        // Redirect damage from the turret switch to the drone.
        private object OnEntityTakeDamage(ElectricSwitch electricSwitch, HitInfo info)
        {
            var autoTurret = GetParentTurret(electricSwitch);
            if (autoTurret == null)
                return null;

            var drone = GetParentDrone(autoTurret);
            if (drone == null)
                return null;

            drone.Hurt(info);
            HitNotify(drone, info);

            return True;
        }

        private void OnEntityKill(Drone drone)
        {
            if (GetDroneTurret(drone))
                return;

            _turretDroneTracker.Remove(drone.net.ID);
        }

        private void OnEntityKill(AutoTurret turret)
        {
            SphereEntity parentSphere;
            var drone = GetParentDrone(turret, out parentSphere);
            if (drone == null)
                return;

            var parentSphere2 = parentSphere;
            parentSphere.Invoke(() =>
            {
                // EntityScaleManager may have already destroyed the sphere in the same frame.
                if (!parentSphere2.IsDestroyed)
                {
                    parentSphere2.Kill();
                }
            }, 0);

            _turretDroneTracker.Remove(drone.net.ID);

            var drone2 = drone;
            drone.Invoke(() => RefreshDroneSettingsProfile(drone2), 0);
        }

        private void OnEntityDeath(Drone drone)
        {
            if (!RCUtils.IsRCDrone(drone))
                return;

            var turret = GetDroneTurret(drone);
            if (turret != null)
            {
                // Causing the turret to die allows its inventory to potentially be dropped.
                // This approach is intentionally used, as opposed to dropping the inventory
                // directly, in order to respect vanilla behavior around `turret.dropChance`, and
                // to allow other plugins to intercept the OnEntityDeath(AutoTurret) hook to kill
                // the inventory before vanilla logic drops it.
                turret.Die();
            }
        }

        private object CanPickupEntity(BasePlayer player, Drone drone)
        {
            if (CanPickupInternal(drone))
                return null;

            ChatMessage(player, Lang.ErrorCannotPickupWithTurret);
            return False;
        }

        private void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string bookmarkName, Drone drone)
        {
            var turret = GetDroneTurret(drone);
            if (turret == null)
                return;

            RefreshAlarmState(drone, turret);
        }

        private void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string bookmarkName, AutoTurret turret)
        {
            var drone = GetParentDrone(turret);
            if (drone == null)
                return;

            if (!RCUtils.HasController(turret, player))
                return;

            if (!HasPermissionToControl(player))
            {
                RCUtils.RemoveController(turret);
                RCUtils.AddFakeViewer(turret);
                RCUtils.AddViewer(turret, player);
                RCUtils.RemoveController(turret);
                station.SetFlag(ComputerStation.Flag_HasFullControl, false);
                return;
            }

            if (RCUtils.CanControl(player, drone))
            {
                RCUtils.RemoveController(drone);
                RCUtils.AddViewer(drone, player);
                DroneController.AddToDrone(drone, turret, player);
                ExposedHooks.OnBookmarkControlStarted(station, player, drone.GetIdentifier(), drone);
            }
        }

        private void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, Drone drone)
        {
            if (drone == null)
                return;

            var turret = GetDroneTurret(drone);
            if (turret != null)
            {
                var drone2 = drone;
                var turret2 = turret;

                // Delay in case the drone is hovering.
                NextTick(() =>
                {
                    if (drone2 == null || turret2 == null)
                        return;

                    RefreshAlarmState(drone2, turret2);
                });
            }
        }

        private void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, AutoTurret turret)
        {
            if (turret == null)
                return;

            var drone = GetParentDrone(turret);
            if (drone == null)
                return;

            if (!RCUtils.HasController(drone, player))
                return;

            RCUtils.RemoveController(drone);

            // Notify other plugins such as Drone Hover, Limited Drone Range and Limited Drone Height.
            ExposedHooks.OnBookmarkControlEnded(station, player, drone);
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        private string canRemove(BasePlayer player, Drone drone)
        {
            if (CanPickupInternal(drone))
                return null;

            return GetMessage(player, Lang.ErrorCannotPickupWithTurret);
        }

        // This hook is exposed by plugin: Drone Settings (DroneSettings).
        private string OnDroneTypeDetermine(Drone drone)
        {
            return GetDroneTurret(drone) != null ? Name : null;
        }

        #endregion

        #region API

        private AutoTurret API_DeployAutoTurret(Drone drone, BasePlayer player)
        {
            if (GetDroneTurret(drone) != null
                || drone.GetSlot(TurretSlot) != null
                || DeployTurretWasBlocked(drone, player))
                return null;

            return DeployAutoTurret(drone, player);
        }

        private NPCAutoTurret API_DeployNpcAutoTurret(Drone drone, BasePlayer player)
        {
            if (GetDroneTurret(drone) != null
                || drone.GetSlot(TurretSlot) != null
                || DeployNpcTurretWasBlocked(drone))
                return null;

            return DeployNpcAutoTurret(drone, player);
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            // Oxide hook.
            public static void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string name, IRemoteControllable controllable)
            {
                Interface.CallHook("OnBookmarkControlStarted", station, player, name, controllable);
            }

            // Oxide hook.
            public static void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, IRemoteControllable controllable)
            {
                Interface.CallHook("OnBookmarkControlEnded", station, player, controllable);
            }

            // Oxide hook.
            public static void OnEntityBuilt(BaseEntity heldEntity, GameObject gameObject)
            {
                Interface.CallHook("OnEntityBuilt", heldEntity, gameObject);
            }

            public static object OnDroneTurretDeploy(Drone drone, BasePlayer deployer)
            {
                return Interface.CallHook("OnDroneTurretDeploy", drone, deployer);
            }

            public static void OnDroneTurretDeployed(Drone drone, AutoTurret turret, BasePlayer deployer)
            {
                Interface.CallHook("OnDroneTurretDeployed", drone, turret, deployer);
            }

            public static object OnDroneNpcTurretDeploy(Drone drone, BasePlayer deployer)
            {
                return Interface.CallHook("OnDroneNpcTurretDeploy", drone, deployer);
            }

            public static void OnDroneNpcTurretDeployed(Drone drone, NPCAutoTurret turret, BasePlayer deployer)
            {
                Interface.CallHook("OnDroneNpcTurretDeployed", drone, turret, deployer);
            }
        }

        #endregion

        #region Commands

        [Command("droneturret")]
        private void DroneTurretCommand(IPlayer player)
        {
            if (player.IsServer)
                return;

            var basePlayer = player.Object as BasePlayer;
            if (!basePlayer.CanInteract())
                return;

            if (!VerifyPermission(player, PermissionDeploy)
                || !VerifyDroneFound(player, out var drone)
                || !VerifyCanBuild(player, drone)
                || !VerifyDroneHasNoTurret(player, drone)
                || !VerifyDroneHasSlotVacant(player, drone))
                return;

            Item autoTurretPaymentItem = null;
            var conditionFraction = 1f;

            if (!player.HasPermission(PermissionDeployFree))
            {
                autoTurretPaymentItem = FindPlayerAutoTurretItem(basePlayer);
                if (autoTurretPaymentItem == null)
                {
                    ReplyToPlayer(player, Lang.ErrorNoTurretItem);
                    return;
                }
                conditionFraction = GetItemConditionFraction(autoTurretPaymentItem);
            }

            if (DeployTurretWasBlocked(drone, basePlayer))
                return;

            if (DeployAutoTurret(drone, basePlayer, conditionFraction) == null)
            {
                ReplyToPlayer(player, Lang.ErrorDeployFailed);
                return;
            }

            if (autoTurretPaymentItem != null)
            {
                UseItem(basePlayer, autoTurretPaymentItem);
            }
        }

        [Command("dronenpcturret")]
        private void DroneNpcTurretCommand(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer)
                return;

            var basePlayer = player.Object as BasePlayer;
            if (!basePlayer.CanInteract())
                return;

            if (!VerifyPermission(player, PermissionDeployNpc)
                || !VerifyDroneFound(player, out var drone)
                || !VerifyCanBuild(player, drone)
                || !VerifyDroneHasNoTurret(player, drone)
                || !VerifyDroneHasSlotVacant(player, drone)
                || DeployNpcTurretWasBlocked(drone, basePlayer))
                return;

            if (DeployNpcAutoTurret(drone, basePlayer) == null)
            {
                ReplyToPlayer(player, Lang.ErrorDeployFailed);
            }
        }

        #endregion

        #region Helper Methods - Command Checks

        private bool VerifyPermission(IPlayer player, string perm)
        {
            if (player.HasPermission(perm))
                return true;

            ReplyToPlayer(player, Lang.ErrorNoPermission);
            return false;
        }

        private bool VerifyDroneFound(IPlayer player, out Drone drone)
        {
            var basePlayer = player.Object as BasePlayer;
            drone = GetLookEntity(basePlayer, 3) as Drone;
            if (drone != null && RCUtils.IsRCDrone(drone))
                return true;

            ReplyToPlayer(player, Lang.ErrorNoDroneFound);
            return false;
        }

        private bool VerifyCanBuild(IPlayer player, Drone drone)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer.CanBuild() && basePlayer.CanBuild(drone.WorldSpaceBounds()))
                return true;

            ReplyToPlayer(player, Lang.ErrorBuildingBlocked);
            return false;
        }

        private bool VerifyDroneHasNoTurret(IPlayer player, Drone drone)
        {
            if (GetDroneTurret(drone) == null)
                return true;

            ReplyToPlayer(player, Lang.ErrorAlreadyHasTurret);
            return false;
        }

        private bool VerifyDroneHasSlotVacant(IPlayer player, Drone drone)
        {
            if (drone.GetSlot(TurretSlot) == null)
                return true;

            ReplyToPlayer(player, Lang.ErrorIncompatibleAttachment);
            return false;
        }

        #endregion

        #region Helpers

        private static class RCUtils
        {
            public static bool IsRCDrone(Drone drone)
            {
                return drone is not DeliveryDrone;
            }

            public static bool HasController(IRemoteControllable controllable)
            {
                return controllable.ControllingViewerId.HasValue;
            }

            public static bool HasController(IRemoteControllable controllable, BasePlayer player)
            {
                return controllable.ControllingViewerId?.SteamId == player.userID;
            }

            public static bool HasFakeController(IRemoteControllable controllable)
            {
                return controllable.ControllingViewerId?.SteamId == 0;
            }

            public static bool HasRealController(IRemoteControllable controllable)
            {
                return controllable.ControllingViewerId.GetValueOrDefault().SteamId != 0;
            }

            public static bool CanControl(BasePlayer player, IRemoteControllable controllable)
            {
                return !HasRealController(controllable) || HasController(controllable, player);
            }

            public static void RemoveController(IRemoteControllable controllable)
            {
                var controllerId = controllable.ControllingViewerId;
                if (controllerId.HasValue)
                {
                    controllable.StopControl(controllerId.Value);
                }
            }

            public static bool AddViewer(IRemoteControllable controllable, BasePlayer player)
            {
                return controllable.InitializeControl(new CameraViewerId(player.userID, 0));
            }

            public static void RemoveViewer(IRemoteControllable controllable, BasePlayer player)
            {
                controllable.StopControl(new CameraViewerId(player.userID, 0));
            }

            public static bool AddFakeViewer(IRemoteControllable controllable)
            {
                return controllable.InitializeControl(new CameraViewerId());
            }

            public static T GetControlledEntity<T>(BasePlayer player, out ComputerStation station) where T : class
            {
                station = player.GetMounted() as ComputerStation;
                if ((object)station == null)
                    return null;

                return station.currentlyControllingEnt.Get(serverside: true) as T;
            }

            public static T GetControlledEntity<T>(BasePlayer player) where T : class
            {
                ComputerStation station;
                return GetControlledEntity<T>(player, out station);
            }
        }

        private static bool DeployTurretWasBlocked(Drone drone, BasePlayer deployer)
        {
            var hookResult = ExposedHooks.OnDroneTurretDeploy(drone, deployer);
            return hookResult is false;
        }

        private static bool DeployNpcTurretWasBlocked(Drone drone, BasePlayer deployer = null)
        {
            var hookResult = ExposedHooks.OnDroneNpcTurretDeploy(drone, deployer);
            return hookResult is false;
        }

        private static Drone GetParentDrone(BaseEntity entity, out SphereEntity parentSphere)
        {
            parentSphere = entity.GetParentEntity() as SphereEntity;
            return parentSphere != null
                ? parentSphere.GetParentEntity() as Drone
                : null;
        }

        private static Drone GetParentDrone(BaseEntity entity)
        {
            return GetParentDrone(entity, out _);
        }

        private static AutoTurret GetDroneTurret(Drone drone)
        {
            return drone.GetSlot(TurretSlot) as AutoTurret;
        }

        private static T GetChildOfType<T>(BaseEntity entity, string prefabName = null) where T : BaseEntity
        {
            foreach (var child in entity.children)
            {
                var childOfType = child as T;
                if (childOfType != null && (prefabName == null || child.PrefabName == prefabName))
                    return childOfType;
            }

            return null;
        }

        private static IOEntity GetTurretAlarm(AutoTurret turret)
        {
            return GetChildOfType<IOEntity>(turret, AlarmPrefab);
        }

        private static IOEntity GetTurretLight(AutoTurret turret)
        {
            return GetChildOfType<IOEntity>(turret, SirenLightPrefab);
        }

        private static bool ShouldPowerAlarm(Drone drone, AutoTurret turret)
        {
            return drone.IsBeingControlled && (turret.booting || turret.IsOn());
        }

        private static bool CanPickupInternal(Drone drone)
        {
            if (!RCUtils.IsRCDrone(drone))
                return true;

            var turret = GetDroneTurret(drone);
            if (turret == null)
                return true;

            // Prevent drone pickup while it has a turret (the turret must be removed first).
            // Ignores NPC turrets since they can't be picked up.
            return turret == null || turret is NPCAutoTurret;
        }

        private static void HitNotify(BaseEntity entity, HitInfo info)
        {
            var player = info.Initiator as BasePlayer;
            if (player == null)
                return;

            entity.ClientRPCPlayer(null, player, "HitNotify");
        }

        private static SphereEntity SpawnSphereEntity(Drone drone)
        {
            var sphereEntity = GameManager.server.CreateEntity(SpherePrefab, SphereEntityLocalPosition) as SphereEntity;
            if (sphereEntity == null)
                return null;

            SetupSphereEntity(sphereEntity);
            sphereEntity.currentRadius = TurretScale;
            sphereEntity.lerpRadius = TurretScale;
            sphereEntity.SetParent(drone);
            sphereEntity.Spawn();

            return sphereEntity;
        }

        private static void RemoveProblemComponents(BaseEntity entity)
        {
            foreach (var collider in entity.GetComponentsInChildren<Collider>())
            {
                if (!collider.isTrigger)
                {
                    UnityEngine.Object.DestroyImmediate(collider);
                }
            }

            UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
        }

        private static void AddRigidBodyToTriggerCollider(AutoTurret turret)
        {
            // Without this hack, the drone's sweep test can collide with other entities using the
            // turret trigger collider, causing the drone to occasionally reduce altitude like when
            // it's close to the ground.
            turret.targetTrigger.GetOrAddComponent<Rigidbody>().isKinematic = true;
        }

        private static IOEntity AttachTurretAlarm(Drone drone, AutoTurret turret)
        {
            var turretAlarm = GameManager.server.CreateEntity(AlarmPrefab, new Vector3(0, 0.185f, 0)) as IOEntity;
            if (turretAlarm == null)
                return null;

            turretAlarm.pickup.enabled = false;
            turretAlarm.SetFlag(IOEntity.Flag_HasPower, ShouldPowerAlarm(drone, turret));
            RemoveProblemComponents(turretAlarm);
            HideInputsAndOutputs(turretAlarm);

            turretAlarm.SetParent(turret);
            turretAlarm.Spawn();

            return turretAlarm;
        }

        private static IOEntity AttachTurretLight(Drone drone, AutoTurret turret)
        {
            var turretLight = GameManager.server.CreateEntity(SirenLightPrefab, new Vector3(0, 0.3f, 0), Quaternion.Euler(180, 0, 0)) as IOEntity;
            if (turretLight == null)
                return null;

            turretLight.SetFlag(IOEntity.Flag_HasPower, ShouldPowerAlarm(drone, turret));
            RemoveProblemComponents(turretLight);
            HideInputsAndOutputs(turretLight);

            turretLight.SetParent(turret);
            turretLight.Spawn();

            return turretLight;
        }

        private static ElectricSwitch AttachTurretSwitch(AutoTurret autoTurret)
        {
            var position = autoTurret.transform.TransformPoint(TurretSwitchPosition);
            var rotation = autoTurret.transform.rotation * TurretSwitchRotation;
            var electricSwitch = GameManager.server.CreateEntity(ElectricSwitchPrefab, position, rotation) as ElectricSwitch;
            if (electricSwitch == null)
                return null;

            SetupTurretSwitch(electricSwitch);
            electricSwitch.Spawn();
            electricSwitch.SetParent(autoTurret, true);

            return electricSwitch;
        }

        private static void HideInputsAndOutputs(IOEntity ioEntity)
        {
            // Hide the inputs and outputs on the client.
            foreach (var input in ioEntity.inputs)
            {
                input.type = IOEntity.IOType.Generic;
            }

            foreach (var output in ioEntity.outputs)
            {
                output.type = IOEntity.IOType.Generic;
            }
        }

        private static void SetupTurretSwitch(ElectricSwitch electricSwitch)
        {
            // Damage will be processed by the drone.
            electricSwitch.baseProtection = null;

            electricSwitch.pickup.enabled = false;
            electricSwitch.SetFlag(IOEntity.Flag_HasPower, true);
            RemoveProblemComponents(electricSwitch);
            HideInputsAndOutputs(electricSwitch);

            if (electricSwitch.HasParent())
            {
                var transform = electricSwitch.transform;
                if (transform.localPosition != TurretSwitchPosition)
                {
                    transform.localPosition = TurretSwitchPosition;
                    electricSwitch.InvalidateNetworkCache();
                    electricSwitch.SendNetworkUpdate_Position();
                }
            }
        }

        private static void SetupSphereEntity(SphereEntity sphereEntity)
        {
            sphereEntity.EnableSaving(true);

            // Fix the issue where leaving the area and returning would not recreate the sphere and its children on clients.
            sphereEntity.EnableGlobalBroadcast(false);

            // Needs to be called since we aren't using server side lerping.
            sphereEntity.transform.localScale = SphereTransformScale;
        }

        private static BaseEntity GetLookEntity(BasePlayer basePlayer, float maxDistance = 3)
        {
            return Physics.Raycast(basePlayer.eyes.HeadRay(), out var hit, maxDistance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore)
                ? hit.GetEntity()
                : null;
        }

        private static AutoTurret GetParentTurret(BaseEntity entity)
        {
            return entity.GetParentEntity() as AutoTurret;
        }

        private static void RunOnEntityBuilt(Item turretItem, AutoTurret autoTurret)
        {
            ExposedHooks.OnEntityBuilt(turretItem.GetHeldEntity(), autoTurret.gameObject);
        }

        private static void UseItem(BasePlayer basePlayer, Item item, int amountToConsume = 1)
        {
            item.UseItem(amountToConsume);
            basePlayer.Command("note.inv", item.info.itemid, -amountToConsume);
        }

        private static float GetItemConditionFraction(Item item)
        {
            return item.hasCondition ? item.condition / item.info.condition.max : 1.0f;
        }

        private static Item FindPlayerAutoTurretItem(BasePlayer basePlayer)
        {
            return basePlayer.inventory.FindItemByItemID(AutoTurretItemId);
        }

        private void RefreshDroneSettingsProfile(Drone drone)
        {
            DroneSettings?.Call("API_RefreshDroneProfile", drone);
        }

        private void SwitchControl(BasePlayer player, ComputerStation station, IRemoteControllable previous, IRemoteControllable next)
        {
            var nextEnt = next.GetEnt();
            if (nextEnt == null)
                return;

            station.StopControl(player);
            station.SendNetworkUpdateImmediate();

            var forcedDroneHover = false;
            var drone = previous as Drone ?? next as Drone;

            // Check for a controller, in case Drone Hover has already added a fake one.
            if ((object)drone != null && !RCUtils.HasController(drone))
            {
                RCUtils.AddFakeViewer(drone);
                forcedDroneHover = true;
            }

            NextTick(() =>
            {
                if (player == null || player.IsDestroyed
                    || station == null || station.IsDestroyed
                    || ((previous as BaseEntity)?.IsDestroyed ?? false)
                    || ((next as BaseEntity)?.IsDestroyed ?? false)
                    || station.currentlyControllingEnt.IsValid(serverside: true))
                {
                    if (forcedDroneHover && RCUtils.HasFakeController(drone))
                    {
                        RCUtils.RemoveController(drone);
                    }

                    return;
                }

                RCUtils.RemoveController(next);

                station.currentlyControllingEnt.uid = nextEnt.net.ID;
                station.currentPlayerID = player.userID;
                var isControlling = RCUtils.AddViewer(next, player);
                station.SetFlag(ComputerStation.Flag_HasFullControl, isControlling, networkupdate: false);
                station.SendNetworkUpdateImmediate();
                // station.SendControlBookmarks(player);
                station.InvokeRepeating(station.ControlCheck, 0f, 0f);
                ExposedHooks.OnBookmarkControlStarted(station, player, next.GetIdentifier(), next);
            });
        }

        private bool HasPermissionToControl(BasePlayer player)
        {
            if (!_config.RequirePermission)
                return true;

            return permission.UserHasPermission(player.UserIDString, PermissionControl);
        }

        private void RegisterWithEntityScaleManager(BaseEntity entity)
        {
            EntityScaleManager?.Call("API_RegisterScaledEntity", entity);
        }

        private void RefreshAlarmState(Drone drone, AutoTurret turret)
        {
            if (_config.EnableAudioAlarm)
            {
                var turretAlarm = GetTurretAlarm(turret);
                if (turretAlarm != null)
                {
                    turretAlarm.SetFlag(IOEntity.Flag_HasPower, ShouldPowerAlarm(drone, turret));
                }
            }

            if (_config.EnableSirenLight)
            {
                var turretLight = GetTurretLight(turret);
                if (turretLight != null)
                {
                    turretLight.SetFlag(IOEntity.Flag_HasPower, ShouldPowerAlarm(drone, turret));
                }
            }
        }

        private void SetupDroneTurret(Drone drone, AutoTurret turret)
        {
            // Damage will be processed by the drone.
            turret.baseProtection = null;

            turret.sightRange = _config.TurretRange;
            turret.targetTrigger.GetComponent<SphereCollider>().radius = _config.TurretRange;

            RemoveProblemComponents(turret);
            HideInputsAndOutputs(turret);
            AddRigidBodyToTriggerCollider(turret);

            if (_config.EnableAudioAlarm)
            {
                var turretAlarm = GetTurretAlarm(turret);
                if (turretAlarm != null)
                {
                    turretAlarm.SetFlag(IOEntity.Flag_HasPower, ShouldPowerAlarm(drone, turret));
                }
                else
                {
                    AttachTurretAlarm(drone, turret);
                }
            }

            if (_config.EnableSirenLight)
            {
                var turretLight = GetTurretLight(turret);
                if (turretLight != null)
                {
                    turretLight.SetFlag(IOEntity.Flag_HasPower, ShouldPowerAlarm(drone, turret));
                }
                else
                {
                    AttachTurretLight(drone, turret);
                }
            }

            if (_config.EnableAudioAlarm || _config.EnableSirenLight)
            {
                var droneForClosure = drone;
                var turretForClosure = turret;

                // Delay refreshing the alarm state in case the turret is being automatically powered on.
                NextTick(() =>
                {
                    if (droneForClosure == null || turretForClosure == null)
                        return;

                    RefreshAlarmState(droneForClosure, turretForClosure);
                });
            }

            // Invert the localScale of the turret to compensate for the sphereEntity localScale being increased.
            // Without doing this, the range of the turret corresponds to the sphere scale.
            // This works fine for now because the only colliders remaining are triggers.
            // This will require a different approach if the non-trigger colliders are reintroduced.
            turret.transform.localScale = TurretTransformScale;

            RegisterWithEntityScaleManager(turret);
            RefreshDroneSettingsProfile(drone);
            _turretDroneTracker.Add(drone.net.ID);
        }

        private void RefreshDroneTurret(Drone drone, AutoTurret turret)
        {
            var sphereEntity = turret.GetParentEntity() as SphereEntity;
            if (sphereEntity == null)
                return;

            SetupSphereEntity(sphereEntity);
            SetupDroneTurret(drone, turret);

            var electricSwitch = turret.GetComponentInChildren<ElectricSwitch>();
            if (electricSwitch != null)
            {
                SetupTurretSwitch(electricSwitch);
            }
        }

        private NPCAutoTurret DeployNpcAutoTurret(Drone drone, BasePlayer deployer)
        {
            var sphereEntity = SpawnSphereEntity(drone);
            if (sphereEntity == null)
                return null;

            var turret = GameManager.server.CreateEntity(NpcAutoTurretPrefab) as NPCAutoTurret;
            if (turret == null)
            {
                sphereEntity.Kill();
                return null;
            }

            turret.SetParent(sphereEntity);
            turret.Spawn();

            drone.SetSlot(TurretSlot, turret);
            SetupDroneTurret(drone, turret);

            Effect.server.Run(DeployEffectPrefab, turret.transform.position);
            ExposedHooks.OnDroneNpcTurretDeployed(drone, turret, deployer);

            return turret;
        }

        private AutoTurret DeployAutoTurret(Drone drone, BasePlayer basePlayer, float conditionFraction = 1)
        {
            var sphereEntity = SpawnSphereEntity(drone);
            if (sphereEntity == null)
                return null;

            var turret = GameManager.server.CreateEntity(AutoTurretPrefab) as AutoTurret;
            if (turret == null)
            {
                sphereEntity.Kill();
                return null;
            }

            if (basePlayer != null)
            {
                turret.OwnerID = basePlayer.userID;
            }

            turret.SetFlag(IOEntity.Flag_HasPower, true);
            turret.SetParent(sphereEntity);
            turret.Spawn();
            turret.SetHealth(turret.MaxHealth() * conditionFraction);
            AttachTurretSwitch(turret);

            drone.SetSlot(TurretSlot, turret);
            SetupDroneTurret(drone, turret);

            Effect.server.Run(DeployEffectPrefab, turret.transform.position);
            ExposedHooks.OnDroneTurretDeployed(drone, turret, basePlayer);

            if (basePlayer == null)
                return turret;

            if (!turret.IsAuthed(basePlayer))
            {
                turret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID
                {
                    userid = basePlayer.userID,
                    username = basePlayer.displayName
                });
                turret.SendNetworkUpdate();
            }

            // Allow other plugins to detect the auto turret being deployed (e.g., to add a weapon automatically).
            var turretItem = FindPlayerAutoTurretItem(basePlayer);
            if (turretItem != null)
            {
                RunOnEntityBuilt(turretItem, turret);
            }
            else
            {
                // Temporarily increase the player inventory capacity to ensure there is enough space.
                basePlayer.inventory.containerMain.capacity++;
                var temporaryTurretItem = ItemManager.CreateByItemID(AutoTurretItemId);
                if (basePlayer.inventory.GiveItem(temporaryTurretItem))
                {
                    RunOnEntityBuilt(temporaryTurretItem, turret);
                    temporaryTurretItem.RemoveFromContainer();
                }

                temporaryTurretItem.Remove();
                basePlayer.inventory.containerMain.capacity--;
            }

            return turret;
        }

        private object HandleLightToggle(BasePlayer player)
        {
            var turret = RCUtils.GetControlledEntity<AutoTurret>(player, out _);
            if (turret == null || !RCUtils.HasController(turret, player))
                return null;

            var weapon = turret.GetAttachedWeapon();
            if (weapon == null)
                return null;

            weapon.SetLightsOn(!weapon.LightsOn());
            return False;
        }

        private void HandleSwapSeats(BasePlayer player)
        {
            var controllable = RCUtils.GetControlledEntity<IRemoteControllable>(player, out var station);
            if (controllable == null)
                return;

            AutoTurret turret;
            var drone = controllable as Drone;
            if (drone != null)
            {
                turret = GetDroneTurret(drone);
                if (turret != null && turret.IsOn() && !turret.PeacekeeperMode() && turret is not NPCAutoTurret)
                {
                    SwitchControl(player, station, drone, turret);
                }

                return;
            }

            turret = controllable as AutoTurret;
            if (turret != null)
            {
                drone = GetParentDrone(turret);
                if (drone != null)
                {
                    SwitchControl(player, station, turret, drone);
                }

                return;
            }
        }

        #endregion

        #region Dynamic Hook Subscriptions

        private class DynamicHookSubscriber<T>
        {
            private DroneTurrets _plugin;
            private HashSet<T> _list = new();
            private string[] _hookNames;

            public DynamicHookSubscriber(DroneTurrets plugin, params string[] hookNames)
            {
                _plugin = plugin;
                _hookNames = hookNames;
            }

            public void Add(T item)
            {
                if (_list.Add(item) && _list.Count == 1)
                {
                    SubscribeAll();
                }
            }

            public void Remove(T item)
            {
                if (_list.Remove(item) && _list.Count == 0)
                {
                    UnsubscribeAll();
                }
            }

            public void SubscribeAll()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Subscribe(hookName);
                }
            }

            public void UnsubscribeAll()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Unsubscribe(hookName);
                }
            }
        }

        #endregion

        #region Drone Controller

        private class DroneController : ListComponent<DroneController>
        {
            public static void AddToDrone(Drone drone, AutoTurret turret, BasePlayer player)
            {
                var component = drone.gameObject.GetComponent<DroneController>();
                if (component == null)
                {
                    component = drone.gameObject.AddComponent<DroneController>();
                    component._drone = drone;
                    component._turret = turret;
                }
                else
                {
                    component.enabled = true;
                }

                component._controller = player;
                component._viewerId = new CameraViewerId(player.userID, 0);
            }

            public static void DestroyAll()
            {
                foreach (var component in InstanceList.ToArray())
                {
                    DestroyImmediate(component);
                }
            }

            private Drone _drone;
            private AutoTurret _turret;
            private BasePlayer _controller;
            private CameraViewerId _viewerId;

            private void Update()
            {
                if (!RCUtils.HasController(_turret, _controller)
                    || RCUtils.GetControlledEntity<AutoTurret>(_controller) != _turret)
                {
                    enabled = false;
                    return;
                }

                // Optimization: Skip if there was no user input this frame.
                if (_controller.lastTickTime < Time.time)
                    return;

                // Send only keyboard inputs to the drone.
                var input = _controller.serverInput;
                var originalMouseDelta = input.current.mouseDelta;
                input.current.mouseDelta = Vector3.zero;
                _drone.UserInput(input, _viewerId);
                input.current.mouseDelta = originalMouseDelta;

                if (_drone.currentInput.movement == Vector3.zero)
                    return;

                // Rotate the drone movement direction by the turret aim direction.
                var worldDirection = _drone.transform.InverseTransformVector(_drone.currentInput.movement);
                var turretRotation = Quaternion.Euler(0, Quaternion.LookRotation(_turret.aimDir).eulerAngles.y, 0);
                _drone.currentInput.movement = turretRotation * worldDirection;
            }

            private void OnDestroy()
            {
                if (RCUtils.HasController(_drone, _controller))
                {
                    RCUtils.RemoveController(_drone);
                }
            }
        }

        #endregion

        #region Configuration

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("RequirePermissionToControlDroneTurrets")]
            public bool RequirePermission;

            [JsonProperty("TargetPlayers")]
            public bool TargetPlayers = true;

            [JsonProperty("TargetNPCs")]
            public bool TargetNPCs = true;

            [JsonProperty("TargetAnimals")]
            public bool TargetAnimals = true;

            [JsonProperty("EnableAudioAlarm")]
            public bool EnableAudioAlarm = false;

            [JsonProperty("EnableSirenLight")]
            public bool EnableSirenLight = false;

            [JsonProperty("TurretRange")]
            public float TurretRange = 30f;

            [JsonProperty("TipChance")]
            public int TipChance = 25;
        }

        private Configuration GetDefaultConfig() => new();

        #endregion

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Localization

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(BasePlayer player, string messageName, params object[] args) =>
            GetMessage(player.UserIDString, messageName, args);

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private class Lang
        {
            public const string TipDeployCommand = "Tip.DeployCommand";
            public const string ErrorNoPermission = "Error.NoPermission";
            public const string ErrorNoDroneFound = "Error.NoDroneFound";
            public const string ErrorBuildingBlocked = "Error.BuildingBlocked";
            public const string ErrorNoTurretItem = "Error.NoTurretItem";
            public const string ErrorAlreadyHasTurret = "Error.AlreadyHasTurret";
            public const string ErrorIncompatibleAttachment = "Error.IncompatibleAttachment";
            public const string ErrorDeployFailed = "Error.DeployFailed";
            public const string ErrorCannotPickupWithTurret = "Error.CannotPickupWithTurret";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.TipDeployCommand] = "Tip: Look at the drone and run <color=yellow>/droneturret</color> to deploy a turret.",
                [Lang.ErrorNoPermission] = "You don't have permission to do that.",
                [Lang.ErrorNoDroneFound] = "Error: No drone found.",
                [Lang.ErrorBuildingBlocked] = "Error: Cannot do that while building blocked.",
                [Lang.ErrorNoTurretItem] = "Error: You need an auto turret to do that.",
                [Lang.ErrorAlreadyHasTurret] = "Error: That drone already has a turret.",
                [Lang.ErrorIncompatibleAttachment] = "Error: That drone has an incompatible attachment.",
                [Lang.ErrorDeployFailed] = "Error: Failed to deploy turret.",
                [Lang.ErrorCannotPickupWithTurret] = "Cannot pick up that drone while it has a turret.",
            }, this, "en");
            //Add pt-BR
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.TipDeployCommand] = "Dica: olhe para o drone e execute <color=yellow>/droneturret</color> para implantar uma torre.",
                [Lang.ErrorNoPermission] = "Você não tem permissão para fazer isso.",
                [Lang.ErrorNoDroneFound] = "Erro: Nenhum drone encontrado.",
                [Lang.ErrorBuildingBlocked] = "Erro: Não é possível fazer isso enquanto o edifício está bloqueado.",
                [Lang.ErrorNoTurretItem] = "Erro: você precisa de uma torre automática para fazer isso.",
                [Lang.ErrorAlreadyHasTurret] = "Erro: esse drone já tem uma torre.",
                [Lang.ErrorIncompatibleAttachment] = "Erro: esse drone tem um anexo incompatível.",
                [Lang.ErrorDeployFailed] = "Erro: falha ao implantar a torre.",
                [Lang.ErrorCannotPickupWithTurret] = "Não é possível pegar aquele drone enquanto ele tiver uma torre.",
            }, this, "pt-BR");
        }

        #endregion
    }
}


// --- End of file: DroneTurrets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/disable-radiation ---
// --- Original File Path: D/DisableRadiation/DisableRadiation.cs ---

﻿using System;
using UnityEngine.Experimental;

namespace Oxide.Plugins
{
    [Info("Disable Radiation", "SwenenzY/Bushhy", "1.0.2")]
    [Description("Disable radiation with permission")]
    class DisableRadiation : CovalencePlugin
    {
        private const string permUse = "disableradiation.use";

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }

        private void OnUserPermissionGranted(string playerId, string perm)
        {
            if (perm == permUse)
            {
                BasePlayer basePlayer = BasePlayer.FindByID(Convert.ToUInt64(playerId));
                if (basePlayer != null)
                {
                    basePlayer.metabolism.radiation_level.max = 0;
                    basePlayer.metabolism.radiation_poison.max = 0;
                }
            }
        }

        private void OnUserPermissionRevoked(string playerId, string perm)
        {
            if (perm == permUse)
            {
                BasePlayer basePlayer = BasePlayer.FindByID(Convert.ToUInt64(playerId));
                if (basePlayer != null)
                {
                    basePlayer.metabolism.radiation_level.max = 500;
                    basePlayer.metabolism.radiation_poison.max = 500;
                }
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            player.metabolism.radiation_level.max = permission.UserHasPermission(player.UserIDString, permUse) ? 0 : 500;
            player.metabolism.radiation_poison.max = permission.UserHasPermission(player.UserIDString, permUse) ? 0 : 500;
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            player.metabolism.radiation_level.max = 500;
            player.metabolism.radiation_poison.max = 500;
        }
    }
}


// --- End of file: DisableRadiation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/devblog-announcer ---
// --- Original File Path: D/DevblogAnnouncer/DevblogAnnouncer.cs ---

using System.Text.RegularExpressions;
using System.Collections.Generic;
using Oxide.Core.Libraries;
using System.Linq;
using Oxide.Core;
using System;

namespace Oxide.Plugins
{
    [Info("Devblog Announcer", "LaserHydra", "1.2.0", ResourceId = 1340)]
    [Description("Broadcasts to chat when a new Devblog or Community Update was released.")]
    class DevblogAnnouncer : RustPlugin
	{
		private readonly WebRequests webRequests = Interface.GetMod().GetLibrary<WebRequests>("WebRequests");

		class Data
		{
			public int Devblog = 0;
			public int CommunityUpdate = 0;
		}
		
		Data data;
		
		void Loaded()
		{
            LoadConfig();

            data = Interface.GetMod().DataFileSystem.ReadObject<Data>("DevblogAnnouncer");
            CheckForBlogs();
			timer.Repeat(60, 0, () => CheckForBlogs());
		}

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new configfile...");
        }
		
		[ConsoleCommand("getblogs")]
		void GetLatest()
		{
            CheckForBlogs();
            Puts("Latest Devblog: Devblog " + data.Devblog.ToString());
			Puts("Latest Community Update: Community Update " + data.CommunityUpdate.ToString());
		}
		
		void SaveData()
		{
			Interface.GetMod().DataFileSystem.WriteObject("DevblogAnnouncer", data);
		}
		
		void LoadConfig()
		{
			SetConfig("Settings", "Enable Devblog", true);
            SetConfig("Settings", "Enable CommunityUpdate", true);

            SaveConfig();
		}
		
		void CheckForBlogs()
		{
			webRequests.EnqueueGet("http://api.steampowered.com/ISteamNews/GetNewsForApp/v0002/?appid=252490&count=1&maxlength=300&format=json", (code, response) => DataRecieved(code, response), this);
		}
		
		void DataRecieved(int code, string response)
		{
			if (response == null || code != 200)
            {
                Puts("Failed to get data.");
			}
			
			int devblog = 0;
            int community = 0;

			Match dev_match = new Regex(@"\""title\"": \""Devblog (\d+)\""").Match(response);
			Match community_match = new Regex(@"\""title\"": \""Community Update (\d+)\""").Match(response);

			if(dev_match.Success) devblog = Convert.ToInt32(dev_match.Groups[1].ToString());
			if(community_match.Success) community = Convert.ToInt32(community_match.Groups[1].ToString());

			if(GetConfig(true, "Settings", "Enable CommunityUpdate"))
			{
				if(community > data.CommunityUpdate) 
				{
					BroadcastChat($"Community Update {community} was released!");
					Puts($"Community Update {community} was released!");
					Console.Beep();

                    data.CommunityUpdate = community;

					SaveData();
				}
			}
			
			if(GetConfig(true, "Settings", "Enable Devblog"))
			{
				if(devblog > data.Devblog) 
				{
					BroadcastChat($"Devblog {devblog} was released!");
                    Puts($"Devblog {devblog} was released!");
					Console.Beep();

					data.Devblog = devblog;

					SaveData();
				}
			}
		}

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString(List<string> list, int first, string seperator)
        {
            return String.Join(seperator, list.Skip(first).ToArray());
        }

        ////////////////////////////////////////
        ///     Config & Message Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null)
                Config.Set(args);
        }

        T GetConfig<T>(T defaultVal, params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();

            if (Config.Get(stringArgs.ToArray()) == null)
            {
                PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin.");
                return defaultVal;
            }

            return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        }

        ////////////////////////////////////////
        ///     Chat Handling
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null, object userID = null) => rust.BroadcastChat(msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg, null, userID == null ? "0" : userID.ToString());

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => rust.SendChatMessage(player, msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);
    }
}

// --- End of file: DevblogAnnouncer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/disable-wet ---
// --- Original File Path: D/DisableWet/DisableWet.cs ---

﻿using System;
namespace Oxide.Plugins
{
    [Info("Disable Wet", "SwenenzY", "1.0.4")]
    [Description("disable wet count, with permission.")]
    public class DisableWet : RustPlugin
    {
        private const string Perm = "disablewet.use";

        private void Init()
        {
             permission.RegisterPermission(Perm, this);
        }
        private void OnUserPermissionGranted(string id, string permName)
        {
            if (permName != Perm) return;
            var basePlayer = BasePlayer.FindByID(Convert.ToUInt64(id));
            if (basePlayer == null)
            {
                return;       
            }
            basePlayer.metabolism.wetness.max = 0;
        }

        private void OnUserPermissionRevoked(string id, string permName)
        {
            if (permName != Perm) return;
            var basePlayer = BasePlayer.FindByID(Convert.ToUInt64(id));
            if (basePlayer == null)
            {
                return;  
            }
            basePlayer.metabolism.wetness.max = 100;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
        if (player == null) return;
        player.metabolism.wetness.max = permission.UserHasPermission(player.userID.ToString(), Perm) ? 0 : 100;
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
        if (player == null) return;
        player.metabolism.wetness.max = 100;
        }

    }
}

// --- End of file: DisableWet.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-rewards ---
// --- Original File Path: D/DiscordRewards/DiscordRewards.cs ---

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Entities.Applications;
using Oxide.Ext.Discord.Entities.Channels;
using Oxide.Ext.Discord.Entities.Gatway;
using Oxide.Ext.Discord.Entities.Gatway.Events;
using Oxide.Ext.Discord.Entities.Guilds;
using Oxide.Ext.Discord.Entities.Messages;
using Oxide.Ext.Discord.Entities.Permissions;
using Oxide.Ext.Discord.Logging;

namespace Oxide.Plugins
{
    [Info("Discord Rewards", "birthdates", "1.4.0")]
    [Description("Get rewards for joining a discord!")]
    public class DiscordRewards : CovalencePlugin
    {
        #region Variables
        [DiscordClient] private DiscordClient Client;

        private readonly DiscordSettings _settings = new DiscordSettings
        {
            Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers | GatewayIntents.DirectMessages
        };
        private DiscordRole role;
        private DiscordGuild _guild;
        private const string Perm = "discordrewards.use";
        private Data data;
        #endregion

        #region Hooks
        private void Init()
        {
            LoadConfig();
            data = Interface.Oxide.DataFileSystem.ReadObject<Data>("Discord Rewards");
            permission.RegisterPermission(Perm, this);
            AddCovalenceCommand(_config.command, "ChatCMD");
            if (!_config.wipeData)
            {
                Unsubscribe(nameof(OnNewSave));
            }
        }

        private void OnServerInitialized()
        {
            _settings.ApiToken = _config.botKey;
            _settings.LogLevel = _config.ExtensionDebugging;
            Client.Connect(_settings);
        }
        
        private void OnNewSave()
        {
            data = new Data();
            SaveData();
            PrintWarning("Wiped all verification data");
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMembersLoaded)]
        private void OnDiscordGuildMembersLoaded()
        {
            role = _guild.GetRole(_config.role);
            if (role == null)
            {
                Snowflake roleId;
                if (Snowflake.TryParse(_config.role, out roleId))
                {
                    role = _guild.Roles[roleId];
                }
            }
                
            if (role == null)
            {
                PrintError($"ERROR: The \"{_config.role}\" role couldn't be found (try role ID instead)! Expect further errors!");
                return;
            }
            foreach (Snowflake id in data.verified2)
            {
                GuildMember member = _guild.Members[id];
                if (member == null || member.Roles.Contains(role.Id))
                {
                    continue;
                }
                _guild.AddGuildMemberRole(Client, member.User, role);
            }
        }

        private void ChatCMD(IPlayer player)
        {
            if (!permission.UserHasPermission(player.Id, Perm))
            {
                player.Message(lang.GetMessage("NoPermission", this, player.Id));
                return;
            }

            if (data.verified.Contains(player.Id))
            {
                player.Message(lang.GetMessage("AlreadyVerified", this, player.Id));
                return;
            }
            if (data.codes.ContainsValue(player.Id))
            {
                player.Message(string.Format(lang.GetMessage("YouAlreadyHaveACodeOut", this, player.Id), data.codes.First(x => x.Value == player.Id).Key));
                return;
            }
            var code = RandomString(_config.codeLength);
            data.codes.Add(code, player.Id);
            player.Message(string.Format(lang.GetMessage("Verify", this, player.Id), code));
        }
        private readonly System.Random random = new System.Random();

        private string RandomString(int length)
        {
            return new string(Enumerable.Repeat(_config.codeChars, length)
              .Select(s => s[random.Next(s.Length)]).ToArray());
        }

        [HookMethod(DiscordExtHooks.OnDiscordDirectMessageCreated)]
        private void OnDiscordDirectMessageCreated(DiscordMessage message)
        {
            if (message.Author.Bot == true) return;
            DiscordChannel.GetChannel(Client, message.ChannelId, c =>
            {
                if (c.Type != ChannelType.Dm)
                    return;
                if (data.verified2.Contains(message.Author.Id))
                {
                    message.Reply(Client, lang.GetMessage("AlreadyVerified", this));
                    return;
                }
                if (!data.codes.ContainsKey(message.Content))
                {
                    message.Reply(Client, lang.GetMessage("NotAValidCode", this));
                    return;
                }
                var p = players.FindPlayer(data.codes[message.Content]);
                data.verified.Add(p.Id);
                data.verified2.Add(message.Author.Id);
                foreach (var s in _config.commands)
                {
                    server.Command(string.Format(s, p.Id));
                }
                message.Reply(Client, lang.GetMessage("Success", this));
                data.codes.Remove(message.Content);
                p.Message(lang.GetMessage("VerifiedInGame", this, p.Id));
                SaveData();
                if(role != null) _guild.AddGuildMemberRole(Client, message.Author, role);
            });
            
        }
        
        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            if (ready.Guilds.Count == 0)
            {
                PrintError("Your bot was not found in any discord servers. Please invite it to a server and reload the plugin.");
                return;
            }

            DiscordGuild guild = null;
            if (ready.Guilds.Count == 1 && !_config.GuildId.IsValid())
            {
                guild = ready.Guilds.Values.FirstOrDefault();
            }

            if (guild == null)
            {
                guild = ready.Guilds[_config.GuildId];
            }

            if (guild == null)
            {
                PrintError("Failed to find a matching guild for the Discord Server Id. " +
                           "Please make sure your guild Id is correct and the bot is in the discord server.");
                return;
            }
                
            if (Client.Bot.Application.Flags.HasValue && !Client.Bot.Application.Flags.Value.HasFlag(ApplicationFlags.GatewayGuildMembersLimited))
            {
                PrintError($"You need to enable \"Server Members Intent\" for {Client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n" +
                           $"{Name} will not function correctly until that is fixed. Once updated please reload {Name}.");
                return;
            }
            
            _guild = guild;
            Puts($"Connected to bot: {Client.Bot.BotUser.Username}");
        }
        private void Unload()
        {
            SaveData();
        }

        #endregion

        #region API

        [HookMethod("IsAuthorized")]
        private bool IsAuthorized(string ID)
        {
            return data.verified.Contains(ID) || 
                   data.verified2.Contains(new Snowflake(ID));
        }

        [HookMethod("Deauthorize")]
        private bool Deauthorize(string ID)
        {
            return data.verified.Remove(ID) ||
                data.verified2.Remove(new Snowflake(ID));
        }

        #endregion

        #region Configuration & Language
        private ConfigFile _config;

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NotAValidCode", "That is not a valid code!"},
                {"Success", "Success you are now verified, check for you rewards in game!"},
                {"AlreadyVerified", "You are already verified."},
                {"NoPermission", "You dont have permission to do this!"},
                {"YouAlreadyHaveACodeOut", "You already have a code out, it is {0}"},
                {"Verify", "Please message the bot on our discord with {0}"},
                {"VerifiedInGame", "Thank you for supporting the server, here are your rewards!"}
            }, this);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Discord Rewards", data);
        }

        private class Data
        {
            public List<Snowflake> verified2 = new List<Snowflake>();
            public List<string> verified = new List<string>();
            public Dictionary<string, string> codes = new Dictionary<string, string>();
        }

        public class ConfigFile
        {
            [JsonProperty("Command")]
            public string command;
            [JsonProperty("Discord bot key (Look at documentation for how to get this)")]
            public string botKey;
            [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
            public Snowflake GuildId { get; set; }
            [JsonProperty("Verification Role (role given when verified)")]
            public string role;
            [JsonProperty("Commands to execute when player is verified (use {0} for the player's steamid)")]
            public List<string> commands;
            [JsonProperty("Amount of characters in the code")]
            public int codeLength;
            [JsonProperty("Erase all verification data on wipe (new map save)?")]
            public bool wipeData;
            [JsonProperty("Characters used in the verification code")]
            public string codeChars;
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; } = DiscordLogLevel.Info;
            
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    command = "verify",
                    botKey = "INSERT_BOT_KEY_HERE",
                    GuildId = default(Snowflake),
                    role = "enter_role_here",
                    commands = new List<string>
                    {
                        "inventory.giveto {0} stones 1000"
                    },
                    codeLength = 6,
                    wipeData = false,
                    codeChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz",
                    ExtensionDebugging = DiscordLogLevel.Info
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion
    }
}
//Generated with birthdates' Plugin Maker

// --- End of file: DiscordRewards.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/default-radio-station ---
// --- Original File Path: D/DefaultRadioStation/DefaultRadioStation.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Default Radio Station", "marcuzz", "1.1.0")]
    [Description("Set default radio station for spawned, created or placed boomboxes.")]
    public class DefaultRadioStation : RustPlugin
    {
        private static PluginConfig _config;

        void OnEntitySpawned(DeployableBoomBox boombox)
        {
            if (!_config.SetDefaultHeld)
                return;

            if (boombox != null)
                SetBoomboxRadioIP(boombox.BoxController);
        }

        void OnEntitySpawned(HeldBoomBox boombox)
        {
            if (!_config.SetDefaultHeld)
                return;

            if (boombox != null)
                SetBoomboxRadioIP(boombox.BoxController);
        }

        void Unload()
        {
            _config = null;
            Config.Clear();
        }

        private void SetBoomboxRadioIP(BoomBox box)
        {
            int index = 0;
            if (_config.DefaultRadioStationUrlList.Count > 1)
                index = Random.Range(0, _config.DefaultRadioStationUrlList.Count);

            box.CurrentRadioIp = _config.DefaultRadioStationUrlList[index];
            box.baseEntity
                .ClientRPC<string>(null, "OnRadioIPChanged", box.CurrentRadioIp);
        }

        private static PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                DefaultRadioStationUrlList = new List<string> { "rustradio.facepunch.com" },
                SetDefaultDeployed = true,
                SetDefaultHeld = true,
            };
        }

        private class PluginConfig
        {
            [JsonProperty("Default radio station URL list (mp3 streams): ")] public List<string> DefaultRadioStationUrlList { get; set; }
            [JsonProperty("Set for deployed: ")] public bool SetDefaultDeployed { get; set; }
            [JsonProperty("Set for held: ")] public bool SetDefaultHeld { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config.WriteObject(GetDefaultConfig(), true);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
        }
    }
}

// --- End of file: DefaultRadioStation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/disable-cold-damage ---
// --- Original File Path: D/DisableColdDamage/DisableColdDamage.cs ---

using System.Linq;

namespace Oxide.Plugins
{
    [Info("Disable Cold Damage", "Talha", "1.0.4")]
    [Description("Prevents cold damage for players, with permission.")]
    public class DisableColdDamage : RustPlugin
    { 
        private const string permDisable = "disablecolddamage.use";
        void Init() { permission.RegisterPermission(permDisable, this); }
        void OnServerInitialized() { CheckAll(); }
        void OnGroupPermissionGranted() { CheckAll(); }
        void OnGroupPermissionRevoked() { CheckAll(); }
        void OnPlayerConnected(BasePlayer player) { Cold(player); }
        void Unload() 
        {
            foreach (var player in BasePlayer.activePlayerList.ToList()) { player.metabolism.temperature.min = -100; }
        }
        void CheckAll()
        {
            foreach (var player in BasePlayer.activePlayerList.ToList()) { Cold(player); }
        }
        void Cold(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, permDisable)) {
                player.metabolism.temperature.value = 20;
                player.metabolism.temperature.min = 20;
            }
            else
            {
                player.metabolism.temperature.min = -100;
            }
        }
    }
}

// --- End of file: DisableColdDamage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-server-messages ---
// --- Original File Path: D/DiscordServerMessages/DiscordServerMessages.cs ---

﻿// Requires: DiscordMessages
using Oxide.Core.Plugins;
using System;
using System.Text.RegularExpressions;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Discord Server Messages", "takocchi", "1.2.41")]
    [Description("Logs SERVER messages and cheat logs to Discord Chat")]
    class DiscordServerMessages : RustPlugin
    {
        [PluginReference]
        private Plugin DiscordMessages;

        string webhookURL;
        string cheatLogURL;

        bool logCheats;
        bool fancyMessage;

        //Static readonly, compiled due to this RegEx being used a lot, so this will be less costy for the Server.
        //Even if plugin is unloaded, this Regex won't be called anymore, so it won't be a huge loss to the Server.
        static readonly Regex isGivingItem = new Regex(@"(.*?)\s+gave\s+(.*?)\s+(\d+)\s+x\s(.*?)\s?", RegexOptions.Compiled);
        static readonly Regex isFlyhack = new Regex(@"Kicking\s(.*?)\s\(FlyHack\sViolation\sLevel\s(\d+)\.*(\d+)*\)", RegexOptions.Compiled);
        static readonly Regex eggCollected = new Regex(@"(.*?)\sis\sthe\stop\sbunny\swith\s(\d+)\seggs\scollected\.", RegexOptions.Compiled);

        protected override void LoadDefaultConfig()
        {
            Config["webhookURL"] = webhookURL = GetConfig("webhookURL", "Your URL here.");
            Config["cheatLog"] = logCheats = GetConfig("cheatLog", false);
            Config["cheatLogURL"] = cheatLogURL = GetConfig("cheatLogURL", "Your URL here.");
            Config["fancyMessage"] = fancyMessage = GetConfig("fancyMessage", true);
            SaveConfig();
        }

        void Init()
        {
            LoadDefaultConfig();
        }

        void OnServerMessage(string message, string name, string color, ulong id)
        {
            
            string discordMessage;
            // Server broadcasted giving message, return.
            if (CheckItemCheat(message))
            {
                discordMessage = ModifyMessage(message, fancyMessage);
                DiscordMessages?.Call("API_SendTextMessage", cheatLogURL, discordMessage);
                return;
            }
            // Return if it is FlyHack
            if (CheckFlyHack(message))
                return;
            // Return if it is Eastern Event.
            if (CheckEasterEvent(message))
                return;

            // Server wrote a real message here.
            discordMessage = ModifyMessage(message, fancyMessage);
            DiscordMessages?.Call("API_SendTextMessage", webhookURL, discordMessage);
        }

        private bool CheckItemCheat(string message)
        {
            var isItemMatch = isGivingItem.IsMatch(message);
            if (isItemMatch && logCheats)
                return true;
            return false;
        }
        private bool CheckFlyHack(string message)
        {
            var isFlyhackMatch = isFlyhack.IsMatch(message);
            if (isFlyhackMatch)
                return true;
            return false;

        }
        private bool CheckEasterEvent(string message)
        {
            if (message == "Wow, no one played so no one won.")
                return true;

            var isEggMatch = eggCollected.IsMatch(message);
            if (isEggMatch)
                return true;
            return false;
        }
        private string ModifyMessage(string message, bool fancy = true)
        {
            var time = DateTime.Now.ToShortTimeString();
            var msg = "";
            if (fancy)
                msg = $"```CSS\n[{time}] #SERVER: {message}```";
            else
                msg = $"[{time}] **__SERVER:__** {message}";
            return msg;
        }
        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));
    }
}

// --- End of file: DiscordServerMessages.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-report ---
// --- Original File Path: D/DiscordReport/DiscordReport.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Discord Report", "misticos", "1.2.0")]
    [Description("Send reports from players ingame to a Discord channel")]
    class DiscordReport : CovalencePlugin
    {
        #region Variables

        [PluginReference("PlaceholderAPI")]
        private Plugin _placeholders = null;

        private Action<IPlayer, StringBuilder, bool> _placeholderProcessor = null;

        private static DiscordReport _ins;

        private const string SteamProfileXML = "https://steamcommunity.com/profiles/{0}?xml=1";
        private const string SteamProfile = "https://steamcommunity.com/profiles/";

        private readonly Regex _steamProfileIconRegex =
            new Regex(@"(?<=<avatarIcon>[\w\W]+)https://.+\.jpg(?=[\w\W]+<\/avatarIcon>)", RegexOptions.Compiled);

        private Dictionary<string, uint> _cooldownData = new Dictionary<string, uint>();

        private Time _time = GetLibrary<Time>();

        private const string PermissionIgnoreCooldown = "discordreport.ignorecooldown";
        private const string PermissionUse = "discordreport.use";
        private const string PermissionAdmin = "discordreport.admin";

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty("Webhook URL")]
            public string Webhook = "YOUR WEBHOOK LINK HERE";

            [JsonProperty("Message Content")]
            public string MessageContent = "";

            [JsonProperty("Embed Title")]
            public string EmbedTitle = "My Server Report";

            [JsonProperty("Embed Description")]
            public string EmbedDescription = "Report sent by a player from your server";

            [JsonProperty("Embed Color")]
            public int EmbedColor = 1484265;

            [JsonProperty("Set Author Icon From Player Profile")]
            public bool AuthorIcon = true;

            [JsonProperty("Use Reporter (True) Or Suspect (False) As Author")]
            public bool IsReporterIcon = true;

            [JsonProperty("Allow Reporting Admins")]
            public bool ReportAdmins = false;

            [JsonProperty("Report Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> ReportCommands = new List<string> { "report" };

            [JsonProperty("Allow Only Online Suspects Reports")]
            public bool OnlyOnlineSuspects = true;

            [JsonProperty("Threshold Before Sending Reports")]
            public int Threshold = 0;

#if RUST
            [JsonProperty("Show Recent Suspect Combatlog")]
            public bool ShowCombatlog = false;

            [JsonProperty("Show In-Game Subject")]
            public bool ShowInGameSubject = true;

            [JsonProperty("Minimum In-Game Report Subject Length")]
            public int SubjectMinimumGame = 0;

            [JsonProperty("Minimum In-Game Report Message Length")]
            public int MessageMinimumGame = 0;

            [JsonProperty("Allowed In-Game Report Types", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] AllowedTypes = { "cheat", "abusive", "name", "spam" };

            [JsonProperty("Recent Combatlog Entries")]
            public int CombatlogEntries = 2;
#endif

            [JsonProperty("Cooldown In Seconds")]
            public uint Cooldown = 300;

            [JsonProperty("User Cache Validity In Seconds")]
            public uint UserCacheValidity = 86400;

            [JsonProperty("Minimum Message Length")]
            public int MessageMinimum = 0;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Work with Data

        private Dictionary<string, PlayerData> _loadedData = new Dictionary<string, PlayerData>();

        private void SaveData(string id)
        {
            PlayerData data;
            if (!_loadedData.TryGetValue(id, out data))
                return;

            Interface.Oxide.DataFileSystem.WriteObject(nameof(DiscordReport) + '/' + id, data);
        }

        private PlayerData GetOrLoadData(string id)
        {
            PlayerData data;
            if (_loadedData.TryGetValue(id, out data))
                return data;

            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<PlayerData>(nameof(DiscordReport) + '/' + id);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            return _loadedData[id] = data ?? new PlayerData();
        }

        private class PlayerData
        {
            public string ImageURL = string.Empty;
            public string LastKnownAddress = string.Empty;

            public HashSet<string> Reporters = new HashSet<string>();

            public uint LastImageUpdate = 0;
        }

        #endregion

        #region Discord Classes

        // ReSharper disable NotAccessedField.Local

        private class WebhookBody
        {
            [JsonProperty("embeds")]
            public List<EmbedBody> Embeds;

            [JsonProperty("content")]
            public string Content = null;
        }

        private class EmbedBody
        {
            [JsonProperty("title")]
            public string Title;

            [JsonProperty("type")]
            public string Type;

            [JsonProperty("description")]
            public string Description;

            [JsonProperty("color")]
            public int Color;

            [JsonProperty("author")]
            public AuthorBody Author;

            [JsonProperty("fields")]
            public List<FieldBody> Fields;

            public class AuthorBody
            {
                [JsonProperty("name")]
                public string Name;

                [JsonProperty("url")]
                public string AuthorURL;

                [JsonProperty("icon_url")]
                public string AuthorIconURL;
            }

            public class FieldBody
            {
                [JsonProperty("name")]
                public string Name;

                [JsonProperty("value")]
                public string Value;

                [JsonProperty("inline")]
                public bool Inline;
            }
        }

        // ReSharper restore NotAccessedField.Local

        #endregion

        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Webhook: Reporter Data Title", "Reporter" },
                { "Webhook: Suspect Data Title", "Suspect" },
#if RUST
                { "Webhook: Combatlog Title", "Suspect's Combatlog #{n}" },
                { "Webhook: Combatlog Attacker Title", "Attacker" },
                { "Webhook: Combatlog Target Title", "Target" },
                { "Webhook: Combatlog Time Title", "Time" },
                { "Webhook: Combatlog Weapon Title", "Weapon" },
                { "Webhook: Combatlog Ammo Title", "Ammo" },
                { "Webhook: Combatlog Distance Title", "Distance" },
                { "Webhook: Combatlog Old HP Title", "Old HP" },
                { "Webhook: Combatlog New HP Title", "New HP" },
                { "Webhook: Combatlog Info Title", "Info" },
#endif
                {
                    "Webhook: Reporter Data", "#{discordreport.total} {name} ({id}). IP: {ip}.\n" +
                                              "Ping: {ping}ms. Connected: {connected}"
                },
                {
                    "Webhook: Suspect Data", "#{discordreport.total} {name} ({id}). IP: {ip}.\n" +
                                             "Ping: {ping}ms. Connected: {connected}"
                },
                { "Webhook: Report Subject", "Report Subject" },
                { "Webhook: Report Message", "Report Message" },
                {
                    "Command: Syntax", "Syntax:\n" +
                                       "report (ID / \"Name\") (Message)\n" +
                                       "WARNING! Use quotes for names."
                },
                { "Command: User Not Found", "We were unable to find this user or multiple were found." },
                { "Command: Report Sent", "Thank you for your report, it was sent to our administration." },
                { "Command: Exceeded Cooldown", "You have exceeded your cooldown on reports." },
                { "Command: Cannot Report Admins", "You cannot report admins." },
                { "Command: Cannot Use", "You cannot use this command since you do not have enough permissions." },
                { "Command: Message Length", "Please add more information to the message." }
            }, this);
        }

        private void Init()
        {
            _ins = this;

            permission.RegisterPermission(PermissionIgnoreCooldown, this);
            permission.RegisterPermission(PermissionUse, this);
            permission.RegisterPermission(PermissionAdmin, this);

            foreach (var command in _config.ReportCommands)
                AddCovalenceCommand(command, nameof(CommandReport));
        }

        private void Loaded()
        {
            foreach (var player in players.Connected)
                OnUserConnected(player);
        }

        private void Unload()
        {
            _ins = null;
        }

        private void OnUserConnected(IPlayer player)
        {
            var user = GetOrLoadData(player.Id);

            if (_config.AuthorIcon)
                UpdateCachedImage(player, user);

            user.LastKnownAddress = player.Address;

            SaveData(player.Id);
        }

        private void OnPlaceholderAPIReady()
        {
            _placeholderProcessor =
                _placeholders.Call<Action<IPlayer, StringBuilder, bool>>("GetProcessPlaceholders", 1);

            _placeholders.Call("AddPlaceholder", this, "discordreport.total", new Func<IPlayer, string, object>(
                (player, s) => GetOrLoadData(player.Id).Reporters.Count));
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin?.Name != "PlaceholderAPI")
                return;

            _placeholderProcessor = null;
        }

#if RUST
        private void OnPlayerReported(BasePlayer player, string targetName, string targetId, string subject,
            string message, string type)
        {
            if (player == null)
                return;

            // Empty message will not be shown
            if (_config.MessageMinimumGame != 0 && !string.IsNullOrEmpty(message) &&
                message.Length < _config.MessageMinimumGame)
                return;

            subject = subject.Substring(3 + type.Length);
            if (_config.SubjectMinimumGame != 0 && _config.ShowInGameSubject &&
                subject.Length < _config.SubjectMinimumGame)
                return;

            if (_config.AllowedTypes.Length != 0 && !_config.AllowedTypes.Contains(type))
                return;

            var suspect = players.FindPlayer(targetId);
            if (suspect == null || player.IPlayer == null)
                return;

            if (!CanUse(player.IPlayer))
                return;

            if (!_config.ReportAdmins && suspect.HasPermission(PermissionAdmin))
                return;

            if (_config.OnlyOnlineSuspects && !suspect.IsConnected)
                return;

            if (ExceedsCooldown(player.IPlayer))
                return;

            SendReport(player.IPlayer, suspect, _config.ShowInGameSubject ? subject : string.Empty, message);
        }
#endif

        #endregion

        #region Commands

        private void CommandReport(IPlayer player, string command, string[] args)
        {
            if (!CanUse(player))
            {
                player.Reply(GetMsg("Command: Cannot Use", player.Id));
                return;
            }

            if (args.Length < 2)
                goto syntax;

            var message = string.Join(" ", args.Skip(1));
            if (_config.MessageMinimum != 0 && message.Length < _config.MessageMinimum)
            {
                player.Reply(GetMsg("Command: Message Length", player.Id));
                return;
            }

            var suspect = players.FindPlayer(args[0]);
            if (suspect == null || !suspect.IsConnected && _config.OnlyOnlineSuspects)
            {
                player.Reply(GetMsg("Command: User Not Found", player.Id));
                return;
            }

            if (!_config.ReportAdmins && suspect.HasPermission(PermissionAdmin))
            {
                player.Reply(GetMsg("Command: Cannot Report Admins", player.Id));
                return;
            }

            if (ExceedsCooldown(player))
            {
                player.Reply(GetMsg("Command: Exceeded Cooldown", player.Id));
                return;
            }

            SendReport(player, suspect, string.Empty, message);
            player.Reply(GetMsg("Command: Report Sent", player.Id));
            return;

            syntax:
            player.Reply(GetMsg("Command: Syntax", player.Id));
        }

        #endregion

        #region Helpers

        private void UpdateCachedImage(IPlayer player, PlayerData data)
        {
            var now = _time.GetUnixTimestamp();

            // If cached and still valid, return
            if (!string.IsNullOrEmpty(data.ImageURL) &&
                data.LastImageUpdate + _config.UserCacheValidity > now)
                return;

            webrequest.Enqueue(string.Format(SteamProfileXML, player.Id), string.Empty,
                (code, result) =>
                {
                    data.ImageURL = _steamProfileIconRegex.Match(result).Value;
                    data.LastImageUpdate = now;

                    SaveData(player.Id);
                },
                this);
        }

        #region Webhook

        private void SendReport(IPlayer reporter, IPlayer suspect, string subject, string message)
        {
            // Threshold

            var cached = GetOrLoadData(suspect.Id);

            cached.Reporters.Add(reporter.Id);
            if (cached.Reporters.Count < _config.Threshold)
                return;

            // Author Icon

            var authorIconURL = string.Empty;
            var author = _config.IsReporterIcon ? reporter : suspect;
            if (_config.AuthorIcon)
            {
                var user = GetOrLoadData(author.Id);
                if (!string.IsNullOrEmpty(user.ImageURL))
                    authorIconURL = user.ImageURL;

                UpdateCachedImage(author, user); // Won't get update now but will be for any other reports for this user
            }

            // Embed data

            const string type = "rich";
            var body = new WebhookBody
            {
                Embeds = Pool.GetList<EmbedBody>(),
                Content = string.IsNullOrEmpty(_config.MessageContent) ? null : _config.MessageContent
            };

            var fields = Pool.GetList<EmbedBody.FieldBody>();

            if (!string.IsNullOrEmpty(subject))
            {
                fields.Add(new EmbedBody.FieldBody
                {
                    Name = GetMsg("Webhook: Report Subject"),
                    Value = subject,
                    Inline = false
                });
            }

            if (!string.IsNullOrEmpty(message))
            {
                fields.Add(new EmbedBody.FieldBody
                {
                    Name = GetMsg("Webhook: Report Message"),
                    Value = message,
                    Inline = false
                });
            }

            fields.Add(new EmbedBody.FieldBody
            {
                Name = GetMsg("Webhook: Reporter Data Title"),
                Value =
                    FormatUserDetails(new StringBuilder(GetMsg("Webhook: Reporter Data")), reporter),
                Inline = false
            });

            fields.Add(new EmbedBody.FieldBody
            {
                Name = GetMsg("Webhook: Suspect Data Title"),
                Value = FormatUserDetails(new StringBuilder(GetMsg("Webhook: Suspect Data")), suspect),
                Inline = false
            });

            body.Embeds.Add(new EmbedBody
            {
                Title = _config.EmbedTitle,
                Description = _config.EmbedDescription,
                Type = type,
                Color = _config.EmbedColor,
                Author = new EmbedBody.AuthorBody
                {
                    AuthorIconURL = authorIconURL,
                    AuthorURL = SteamProfile + author.Id,
                    Name = author.Name
                },
                Fields = fields
            });

            // Rust-specific embed data

#if RUST
            if (_config.ShowCombatlog && suspect.Object is BasePlayer)
            {
                var events = CombatLog.Get(((BasePlayer)suspect.Object).userID).ToArray();
                for (var i = 1; i <= _config.CombatlogEntries && i <= events.Length; i++)
                {
                    var combat = events[events.Length - i];

                    var combatFields = Pool.GetList<EmbedBody.FieldBody>();

                    combatFields.Add(new EmbedBody.FieldBody
                    {
                        Name = GetMsg("Webhook: Combatlog Attacker Title"),
                        Value = combat.attacker,
                        Inline = true
                    });

                    combatFields.Add(new EmbedBody.FieldBody
                    {
                        Name = GetMsg("Webhook: Combatlog Target Title"),
                        Value = combat.target,
                        Inline = true
                    });

                    combatFields.Add(new EmbedBody.FieldBody
                    {
                        Name = GetMsg("Webhook: Combatlog Time Title"),
                        Value = (UnityEngine.Time.realtimeSinceStartup - combat.time).ToString("0.0s"),
                        Inline = true
                    });

                    combatFields.Add(new EmbedBody.FieldBody
                    {
                        Name = GetMsg("Webhook: Combatlog Weapon Title"),
                        Value = combat.weapon,
                        Inline = true
                    });

                    combatFields.Add(new EmbedBody.FieldBody
                    {
                        Name = GetMsg("Webhook: Combatlog Ammo Title"),
                        Value = combat.ammo,
                        Inline = true
                    });

                    combatFields.Add(new EmbedBody.FieldBody
                    {
                        Name = GetMsg("Webhook: Combatlog Distance Title"),
                        Value = combat.distance.ToString("0.0m"),
                        Inline = true
                    });

                    combatFields.Add(new EmbedBody.FieldBody
                    {
                        Name = GetMsg("Webhook: Combatlog Old HP Title"),
                        Value = combat.health_old.ToString("0.0"),
                        Inline = true
                    });

                    combatFields.Add(new EmbedBody.FieldBody
                    {
                        Name = GetMsg("Webhook: Combatlog New HP Title"),
                        Value = combat.health_new.ToString("0.0"),
                        Inline = true
                    });

                    combatFields.Add(new EmbedBody.FieldBody
                    {
                        Name = GetMsg("Webhook: Combatlog Info Title"),
                        Value = string.IsNullOrEmpty(combat.info) ? "none" : combat.info,
                        Inline = true
                    });

                    body.Embeds.Add(new EmbedBody
                    {
                        Title = GetMsg("Webhook: Combatlog Title").Replace("{n}", $"{i}"),
                        Type = type,
                        Color = _config.EmbedColor,
                        Fields = combatFields
                    });
                }
            }
#endif

            // Send a web request

            webrequest.Enqueue(_config.Webhook, JObject.FromObject(body).ToString(),
                (code, result) =>
                {
                    if (code == 204)
                    {
                        SetCooldown(reporter);
                    }
                    else
                    {
                        PrintWarning($"Discord Webhook returned {code}:\n{result}");
                    }
                }, this, RequestMethod.POST,
                new Dictionary<string, string> { { "Content-Type", "application/json" } });

            foreach (var embed in body.Embeds)
            {
                Pool.FreeList(ref embed.Fields);
            }

            Pool.FreeList(ref body.Embeds);
        }

        private string FormatUserDetails(StringBuilder builder, IPlayer player)
        {
            // Apply placeholders if possible
            _placeholderProcessor?.Invoke(player, builder, false);

            return builder
                .Replace("{name}", player.Name).Replace("{id}", player.Id)
                .Replace("{ip}", GetOrLoadData(player.Id)?.LastKnownAddress ?? "Unknown")
                .Replace("{ping}", player.IsConnected ? player.Ping.ToString() : "0")
                .Replace("{connected}", player.IsConnected.ToString()).ToString();
        }

        #endregion

        #region Cooldown

        private bool ExceedsCooldown(IPlayer player)
        {
            if (player.HasPermission(PermissionIgnoreCooldown))
                return false;

            var currentTime = _time.GetUnixTimestamp();
            if (_cooldownData.ContainsKey(player.Id))
                return _cooldownData[player.Id] - currentTime < _config.Cooldown;

            return false;
        }

        private void SetCooldown(IPlayer player) => _cooldownData[player.Id] = _time.GetUnixTimestamp();

        #endregion

        private bool CanUse(IPlayer player) => player.HasPermission(PermissionUse);

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion
    }
}

// --- End of file: DiscordReport.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-auth ---
// --- Original File Path: D/DiscordAuth/DiscordAuth.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Text;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord.Builders;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;
using Random = Oxide.Core.Random;

namespace Oxide.Plugins
{
    [Info("Discord Auth", "OuTSMoKE", "1.4.0")]
    [Description("Allows players to connect their discord account with steam")]
    public class DiscordAuth : CovalencePlugin, IDiscordPlugin, IDiscordLink
    {
        #region Fields
        public DiscordClient Client { get; set; }

        private Configuration _pluginConfig;
        private Data _pluginData;
        
        private readonly BotConnection _settings = new BotConnection
        {
            Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers | GatewayIntents.DirectMessages
        };

        private readonly DiscordLink _link = GetLibrary<DiscordLink>();

        private DiscordGuild _guild;
        
        private string _groupNames;
        private string _roleNames;

        private readonly List<DiscordRole> _roles = new List<DiscordRole>();
        private readonly StringBuilder _builder = new StringBuilder();
        private readonly Dictionary<string, string> _codes = new Dictionary<string, string>();

        private char[] _codeCharacters;
        
        public enum DeauthReason {Command, IsLeaving, Inactive}
        
        private const string AuthPerm = "discordauth.auth";
        private const string DeauthPerm = "discordauth.deauth";
        #endregion

        #region Config
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _pluginConfig = Config.ReadObject<Configuration>();
            Config.WriteObject(_pluginConfig);
        }

        protected override void LoadDefaultConfig() => _pluginConfig = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_pluginConfig);
        #endregion
        
        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Chat Format"] = "[#1874CD](Auth)[/#]: {0}",
                ["Code Generation"] = "Here is your code: [#1874CD]{0}[/#]\nJoin our [#EE3B3B]Discord[/#] and PM the code to the Discord Bot",
                ["Code Expired"] = "Your code has [#EE3B3B]Expired![/#]",
                ["Authenticated"] = "Thank you for authenticating your account",
                ["Game-Deauthenticated"] = "Successfully deauthenticated your account",
                ["Discord-Deauthenticated"] = "You have been deauthenticated from {0}",
                ["Discord-Deauthenticated-NonActive"] = "You have been deauthenticated from {0} because you haven't been active on the game server for {1} days",
                ["Already Authenticated"] = "You have already [#1874CD]authenticated[/#] your account, no need to do it again",
                ["Not Authenticated"] = "You are not authenticated",
                ["Group Revoked"] = "Your '{0}' Server Group(s) have been revoked! Reauthenticate to receive it",
                ["Roles Revoked"] = "Your '{0}' Discord Role(s) have been revoked! Reauthenticate to receive it",
                ["Join Granted"] = "Granted '{0}' Group(s) and '{1}' Discord Role(s)",
                ["Rejoin Granted"] = "Granted '{0}' Group(s) and '{1}' Discord Role(s) for joining {2} back",
                ["Unable to find code"] = "Sorry, we couldn't find your code, please try to authenticate again, If you haven't generated a code, please type /auth in-game",
                ["No Permission"] = "You dont have permission to use this command"
            }, this);
        }
        #endregion

        #region Chat Commands
        private void AuthCommand(IPlayer player, string command, string[] args)
        {
            // No Permission
            if (!player.HasPermission(AuthPerm))
            {
                Message(player, "No Permission");
                return;
            }

            // Already authenticated-check
            if (_link.IsLinked(player.Id))
            {
                Message(player, "Already Authenticated");
                return;
            }

            // Sends the code if already exist to prevent duplication
            if (_codes.ContainsKey(player.Id))
            {
                Message(player, "Code Generation", _codes[player.Id]);
                return;
            }

            // Adds a random code and send it to the player if doesn't already exist
            string code = GenerateCode();
            _codes.Add(player.Id, code);
            Message(player, "Code Generation", code);

            // Code Expiration Function
            timer.In(_pluginConfig.Code.CodeLifetime * 60, () =>
            {
                if (_codes.ContainsKey(player.Id))
                {
                    _codes.Remove(player.Id);
                    Message(player, "Code Expired");
                }
            });
        }

        private void DeauthCommand(IPlayer player, string command, string[] args)
        {
            // No Permission
            if (!player.HasPermission(DeauthPerm))
            {
                Message(player, "No Permission");
                return;
            }

            Snowflake userId = _link.GetDiscordId(player.Id);
            if (!userId.IsValid())
            {
                Message(player, "Not Authenticated");
                return;
            }

            DiscordUser user = GetDiscordUser(userId);

            Deauthenticate(player, user, DeauthReason.Command);
            Message(player, "Game-Deauthenticated");
        }
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            _pluginData = Interface.Oxide.DataFileSystem.ReadObject<Data>(Name);
            _codeCharacters = _pluginConfig.Code.CodeChars.ToCharArray();
            
            _link.AddLinkPlugin(this);
            
            AddCovalenceCommand(_pluginConfig.Info.AuthCommands, nameof(AuthCommand));
            AddCovalenceCommand(_pluginConfig.Info.DeauthCommands, nameof(DeauthCommand));
            foreach (string group in _pluginConfig.Info.Groups)
            {
                permission.CreateGroup(group, group, 0);
            }
            
            permission.RegisterPermission(AuthPerm, this);
            permission.RegisterPermission(DeauthPerm, this);

            if (!_pluginConfig.Info.AutomaticallyReauthenticate)
            {
                Unsubscribe(nameof(OnDiscordGuildMemberAdded));
            }
        }

        private void OnServerInitialized()
        {
            _groupNames = string.Join(", ", _pluginConfig.Info.Groups);
            
            foreach (IPlayer player in players.Connected)
            {
                OnUserConnected(player);
            }
        }
        
        private void OnUserConnected(IPlayer player)
        {
            if (player.IsLinked())
            {
                _pluginData.LastJoinedDate[player.Id] = DateTime.UtcNow;
            }
        }

        private void OnServerSave() => SaveData();
        
        private void Unload()
        {
            SaveData();
        }
        #endregion

        #region Discord Hooks
        [HookMethod(DiscordExtHooks.OnDiscordClientCreated)]
        private void OnDiscordClientCreated()
        {
            if (string.IsNullOrEmpty(_pluginConfig.Info.BotToken))
            {
                PrintWarning("Please set the Discord Bot Token and reload the plugin");
                return;
            }

            _settings.ApiToken = _pluginConfig.Info.BotToken;
            _settings.LogLevel = _pluginConfig.Info.ExtensionDebugging;
            Client.Connect(_settings);
        }
        
        // Called when the client is created, and the plugin can use it
        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            if (ready.Guilds.Count == 0)
            {
                PrintError("Your bot was not found in any discord servers. Please invite it to a server and reload the plugin.");
                return;
            }

            DiscordGuild guild = null;
            if (ready.Guilds.Count == 1 && !_pluginConfig.Info.GuildId.IsValid())
            {
                guild = ready.Guilds.Values.FirstOrDefault();
            }

            if (guild == null)
            {
                guild = ready.Guilds[_pluginConfig.Info.GuildId];
                if (guild == null)
                {
                    PrintError("Failed to find a matching guild for the Discord Server Id. " +
                               "Please make sure your guild Id is correct and the bot is in the discord server.");
                    return;
                }
            }

            if (!Client.Bot.Application.HasApplicationFlag(ApplicationFlags.GatewayGuildMembersLimited) && !Client.Bot.Application.HasApplicationFlag(ApplicationFlags.GatewayGuildMembers))
            {
                PrintError($"You need to enable \"Server Members Intent\" for {Client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n" +
                           $"{Name} will not function correctly until that is fixed. Once updated please reload {Name}.");
                return;
            }
            
            _guild = guild;
            Puts($"Connected to bot: {Client.Bot.BotUser.Username}");
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMembersLoaded)]
        private void OnDiscordGuildMembersLoaded(DiscordGuild guild)
        {
            if (_guild?.Id != guild.Id)
            {
                return;
            }

            foreach (string name in _pluginConfig.Info.Roles)
            {
                DiscordRole role = _guild.GetRole(name);
                if (role != null)
                {
                    _roles.Add(role);
                    continue;
                }

                Snowflake roleId;
                if (Snowflake.TryParse(name, out roleId) && _guild.Roles.ContainsKey(roleId))
                {
                    _roles.Add(_guild.Roles[roleId]);
                    continue;
                }

                PrintWarning($"Failed to find role {name} in guild {_guild.Name}");
            }

            _roleNames = string.Join(", ", _roles.Select(r => r.Name));

            List<KeyValuePair<string, Snowflake>> leftLinks = new List<KeyValuePair<string, Snowflake>>();
            foreach (KeyValuePair<string, Snowflake> link in _pluginData.Players.ToList())
            {
                if (!_guild.Members.ContainsKey(link.Value) || players.FindPlayerById(link.Key) == null)
                {
                    leftLinks.Add(link);
                }
            }
            
            ProcessNextLeft(leftLinks);
            CheckInactivePlayers();
            timer.Every(24 * 60 * 60, CheckInactivePlayers);
        }

        // Called when a member leaves the Discord server
        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberRemoved)]
        private void OnDiscordGuildMemberRemoved(GuildMemberRemovedEvent removed, DiscordGuild guild)
        {
            if (_guild?.Id != guild.Id)
            {
                return;
            }
            
            PlayerId steamId = _link.GetPlayerId(removed.User);

            // No user found
            if (!steamId.IsValid)
            {
                return;
            }

            IPlayer player = steamId.Player;
            if (player == null)
            {
                return;
            }
            
            Deauthenticate(player, removed.User, DeauthReason.IsLeaving);
            Message(player, "Game-Deauthenticated");
        }

        // Called when a user joins the discord server
        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberAdded)]
        private void OnDiscordGuildMemberAdded(GuildMember member, DiscordGuild guild)
        {
            if (!_pluginConfig.Info.AutomaticallyReauthenticate)
            {
                return;
            }
            
            string playerId = _pluginData.Backup[member.Id];
            if (string.IsNullOrEmpty(playerId))
            {
                return;
            }

            IPlayer player = players.FindPlayerById(playerId);
            if (player == null)
            {
                return;
            }
            
            Authenticate(player, member.User);
            Message(player, "Authenticated");
            member.User.SendDirectMessage(Client, new List<DiscordEmbed>
            {
                GetEmbed(Formatter.ToPlaintext(Lang("Authenticated", player)), 11523722),
                GetEmbed(Formatter.ToPlaintext(Lang("Rejoin Granted", player, _groupNames, _roleNames, _guild?.Name)), 11523722)
            });
        }

        // Called when a private message is received
        [HookMethod(DiscordExtHooks.OnDiscordDirectMessageCreated)]
        private void OnDiscordDirectMessageCreated(DiscordMessage message)
        {
            // Bot-check
            if (message.Author.Bot == true)
                return;

            //Don't process guild channel messages
            if (message.GuildId.HasValue)
                return;
            
            // Length-check
            if (string.IsNullOrEmpty(message.Content) || message.Content.Length != _pluginConfig.Code.CodeLength)
                return;

            // No code found
            StringComparison comparison = _pluginConfig.Code.CaseInsensitiveMatch ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal;
            string playerId = null;
            foreach (KeyValuePair<string, string> code in _codes)
            {
                if (code.Value.Equals(message.Content, comparison))
                {
                    playerId = code.Key;
                    break;
                }
            }

            if (string.IsNullOrEmpty(playerId))
            { 
                message.Reply(Client, GetEmbed(Formatter.ToPlaintext(Lang("Unable to find code")), 16098851));
                return;
            }

            // Already authenticated-check
            if(_link.IsLinked(message.Author.Id))
            {
                message.Reply(Client, GetEmbed(Formatter.ToPlaintext(Lang("Already Authenticated", message.Author.Player)), 4886754));
                return;
            }

            _codes.Remove(playerId);
                
            IPlayer player = covalence.Players.FindPlayerById(playerId);
            if (player == null)
            {
                return;
            }
                
            Message(player, "Authenticated");
            message.Reply(Client, new List<DiscordEmbed>
            {
                GetEmbed(Formatter.ToPlaintext(Lang("Authenticated", player)),11523722),
                GetEmbed(Formatter.ToPlaintext(Lang("Join Granted", player, _groupNames, _roleNames)),11523722),
            });
            Authenticate(player, message.Author);
        }
        #endregion

        #region Core
        public void Authenticate(IPlayer player, DiscordUser user)
        {
            _pluginData.Players[player.Id] = user.Id;
            _pluginData.Backup.Remove(user.Id);
            _link.OnLinked(this, player, user);
            foreach (string group in _pluginConfig.Info.Groups)
            {
                permission.AddUserGroup(player.Id, group);
            }
            
            foreach (DiscordRole role in _roles)
            {
                _guild?.AddMemberRole(Client, user, role);
            }
            OnUserConnected(player);
            SaveData();
        }

        public void Deauthenticate(IPlayer player, DiscordUser user, DeauthReason reason)
        {
            List<DiscordEmbed> embeds = new List<DiscordEmbed>();
            if (reason == DeauthReason.IsLeaving)
            {
                if (user.Id.IsValid())
                {
                    _pluginData.Backup[user.Id] = player.Id;
                }
            }
            else if (reason == DeauthReason.Inactive)
            {
                embeds.Add( GetEmbed(Formatter.ToPlaintext(Lang("Discord-Deauthenticated-NonActive", player, _guild?.Name, _pluginConfig.Info.NonActiveDuration)), 9905970));
            }
            else
            {
                embeds.Add(GetEmbed(Formatter.ToPlaintext(Lang("Discord-Deauthenticated", player, _guild?.Name)), 9905970));
            }
            
            _pluginData.LastJoinedDate.Remove(player.Id);
            _link.OnUnlinked(this, player, user);
            _pluginData.Players.Remove(player.Id);

            if (_pluginConfig.Info.RemoveFromGroups)
            {
                foreach (string group in _pluginConfig.Info.Groups)
                {
                    permission.RemoveUserGroup(player.Id, group);
                }

                embeds.Add(GetEmbed(Formatter.ToPlaintext(Lang("Group Revoked", player, _groupNames)), 16098851));
            }

            if (_pluginConfig.Info.RemoveFromRoles && reason != DeauthReason.IsLeaving)
            {
                Snowflake userId = user.Id;
                if (userId.IsValid())
                {
                    foreach (DiscordRole role in _roles)
                    {
                        _guild?.RemoveMemberRole(Client, userId, role.Id);
                    }
                    
                    embeds.Add(GetEmbed(Formatter.ToPlaintext(Lang("Roles Revoked", player, _roleNames)), 16098851));
                }
            }

            if (reason != DeauthReason.IsLeaving)
            {
                user.SendDirectMessage(Client, embeds);
            }

            SaveData();
        }

        public void ProcessNextLeft(List<KeyValuePair<string, Snowflake>> leftLinks)
        {
            if (leftLinks.Count == 0)
            {
                return;
            }

            KeyValuePair<string, Snowflake> link = leftLinks[0];
            leftLinks.RemoveAt(0);
            
            IPlayer player = players.FindPlayerById(link.Key);
            if (player == null)
            {
                if (link.Value.IsValid())
                {
                    _pluginData.Backup[link.Value] = link.Key;
                }
              
                _pluginData.Players.Remove(link.Key);
                timer.In(2f, () => ProcessNextLeft(leftLinks));
                return;
            }
                
            try
            {
                DiscordUser user = _link.GetDiscordUser(link.Key);
                if (user.Id == default(Snowflake))
                {
                    user.Id = link.Value;
                }
                Deauthenticate(player, user, DeauthReason.IsLeaving);
            }
            catch (Exception ex)
            {
                PrintWarning($"Failed to Deauthenticate Left Player {player.Name}({link.Key}) User ID: {link.Value}\n{ex}");
            }
            
            timer.In(2f, () => ProcessNextLeft(leftLinks));
        }
        
        public void CheckInactivePlayers()
        {
            foreach (KeyValuePair<string, Snowflake> link in _pluginData.Players.ToList())
            {
                IPlayer player = _link.GetPlayer(link.Value);
                if (!_pluginData.LastJoinedDate.ContainsKey(link.Key))
                {
                    _pluginData.LastJoinedDate[link.Key] = DateTime.UtcNow;
                    continue;
                }

                if (!_pluginConfig.Info.DeauthNonActive)
                {
                    continue;
                }

                if (!player.IsConnected && _pluginData.LastJoinedDate[link.Key] + TimeSpan.FromDays(_pluginConfig.Info.NonActiveDuration) < DateTime.UtcNow)
                {
                    Snowflake userId = _link.GetDiscordId(link.Key);
                    if (userId.IsValid())
                    {
                        DiscordUser user = GetDiscordUser(userId);
                        Deauthenticate(player, user, DeauthReason.Inactive);
                    }
                }
            }
        }
        #endregion

        #region Helpers
        public DiscordUser GetDiscordUser(Snowflake userId)
        {
            DiscordUser user = _guild.Members[userId]?.User ?? new DiscordUser
            {
                Id = userId,
                Bot = false
            };
            return user;
        }
        
        public void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _pluginData);

        public string Lang(string key, IPlayer player = null) => lang.GetMessage(key, this, player?.Id);

        public string Lang(string key, IPlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(Lang(key, player), args);
            }
            catch(Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception\n:{ex}");
                throw;
            }
        }

        public void Message(IPlayer player, string key, params object[] args)
        {
            if (player.IsConnected)
            {
                player.Reply(Lang("Chat Format", player, Lang(key, player, args)));
            }
        }
        
        public void Message(IPlayer player, string key)
        {
            if (player.IsConnected)
            {
                player.Reply(Lang("Chat Format", player, Lang(key, player)));
            }
        }

        public string GenerateCode()
        {
            _builder.Clear();
            
            for (int i = 0; i < _pluginConfig.Code.CodeLength; i++)
            {
                _builder.Append(_codeCharacters[Random.Range(0, _codeCharacters.Length)]);
            }

            return _builder.ToString();
        }

        public DiscordEmbed GetEmbed(string text, uint color)
        {
            return new DiscordEmbedBuilder()
                   .AddDescription(text)
                   .AddColor(color)
                   .Build();
        }
        #endregion

        #region Discord Link
        public IDictionary<PlayerId, Snowflake> GetPlayerIdToDiscordIds()
        {
            Puts($"Loaded {_pluginData.Players.Count} Players");
            return _pluginData.Players.ToDictionary(key => new PlayerId(key.Key), value => value.Value);
        }
        #endregion
        
        #region Classes
        class Configuration
        {
            [JsonProperty(PropertyName = "Settings")]
            public Settings Info = new Settings();

            [JsonProperty(PropertyName = "Authentication Code")]
            public AuthCode Code = new AuthCode();

            public class Settings
            {
                [JsonProperty(PropertyName = "Bot Token")]
                public string BotToken = string.Empty;

                [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
                public Snowflake GuildId;

                [JsonProperty(PropertyName = "Auth Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public string[] AuthCommands = { "auth", "authenticate" };

                [JsonProperty(PropertyName = "Deauth Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public string[] DeauthCommands = { "deauth", "deauthenticate" };

                [JsonProperty(PropertyName = "Oxide Groups to Assign", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<string> Groups = new List<string>
                {
                    "authenticated"
                };
                
                [JsonProperty(PropertyName = "Discord Roles to Assign", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<string> Roles = new List<string>
                {
                    "Authenticated"
                };

                [JsonProperty(PropertyName = "Revoke Oxide Groups on Deauthenticate")]
                public bool RemoveFromGroups = true;
                
                [JsonProperty(PropertyName = "Revoke Discord Roles on Deauthenticate")]
                public bool RemoveFromRoles = true;
                
                [JsonProperty(PropertyName = "Automatically Reauthenticate on Leaving and Rejoining the Discord Server")]
                public bool AutomaticallyReauthenticate = true;
                
                [JsonProperty(PropertyName = "Automatically Deauthenticate Non Active Players")]
                public bool DeauthNonActive = false;
                
                [JsonProperty(PropertyName = "Player Considered Non Active After (Days)")]
                public float NonActiveDuration = 30f;

                [JsonConverter(typeof(StringEnumConverter))]
                [DefaultValue(DiscordLogLevel.Info)]
                [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
                public DiscordLogLevel ExtensionDebugging = DiscordLogLevel.Info;
            }

            public class AuthCode
            {
                [JsonProperty(PropertyName = "Code Lifetime (minutes)")]
                public int CodeLifetime = 60;

                [JsonProperty(PropertyName = "Code Length")]
                public int CodeLength = 5;

                [JsonProperty(PropertyName = "Code Case Insensitive Match")]
                public bool CaseInsensitiveMatch = true;

                [JsonProperty(PropertyName = "Code Characters")]
                public string CodeChars = "ABCDEFGHJKMNPQRSTUVWXYZ";
            }
        }
        
        private class Data
        {
            public Hash<string, Snowflake> Players = new Hash<string, Snowflake>();
            public Hash<Snowflake, string> Backup = new Hash<Snowflake, string>();
            public Hash<string, DateTime> LastJoinedDate = new Hash<string, DateTime>();
        }
        #endregion
    }
}


// --- End of file: DiscordAuth.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/daynight-gather ---
// --- Original File Path: D/DayNightGather/DayNightGather.cs ---

﻿// Requires: GatherManager

using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Day Night Gather", "klauz24", "1.1.1"), Description("Sets different gather rates for day and night.")]
    internal class DayNightGather : RustPlugin
    {
        [PluginReference] readonly Plugin TimeOfDay;

        private bool _isDay;

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Scale dispensers")]
            public bool ScaleDispensers = true;

            [JsonProperty(PropertyName = "Chat announcements")]
            public bool ChatAnnouncements = true;

            [JsonProperty(PropertyName = "Time check interval (Only used if TimeOfDay plugin is not installed)")]
            public int TimeCheckInterval = 60;

            [JsonProperty(PropertyName = "Day")]
            public Values Day = new Values();

            [JsonProperty(PropertyName = "Night")]
            public Values Night = new Values();

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        private class Values
        {
            public int Dispenser = 1;
            public int Pickup = 1;
            public int Quarry = 1;
            public int Excavator = 1;
            public int Survey = 1;
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    Puts("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                Puts($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Announcement", "The server rates have changed due to time change! To know more, type <color=#008000ff>/gather</color>."}
            }, this);
        }

        private void OnServerInitialized()
        {
            if (TimeOfDay == null)
            {
                timer.Every(_config.TimeCheckInterval, () => IsDayOrNight());
            }
            _isDay = IsDay;
            SetRates(_isDay);
        }

        private void OnTimeSunrise() => OnTimeChange(_config.Day.Dispenser, _config.Day.Pickup, _config.Day.Quarry, _config.Day.Excavator, _config.Day.Survey, true);

        private void OnTimeSunset() => OnTimeChange(_config.Night.Dispenser, _config.Night.Pickup, _config.Night.Quarry, _config.Night.Excavator, _config.Night.Survey, false);

        private void OnTimeChange(int dispenser, int pickup, int quarry, int excavator, int survey, bool boolean)
        {
            Server.Command($"gather.rate dispenser * {dispenser}");
            Server.Command($"gather.rate pickup * {pickup}");
            Server.Command($"gather.rate quarry * {quarry}");
            Server.Command($"gather.rate excavator * {excavator}");
            Server.Command($"gather.rate survey * {survey}");
            if (_config.ScaleDispensers)
            {
                Server.Command($"dispenser.scale tree {dispenser}");
                Server.Command($"dispenser.scale ore {dispenser}");
                Server.Command($"dispenser.scale corpse {dispenser}");
            }
            if (_config.ChatAnnouncements)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    var message = lang.GetMessage("Announcement", this, player.UserIDString);
                    player.ChatMessage(message);
                }
            }
            _isDay = boolean;
        }

        private void SetRates(bool boolean)
        {
            if (boolean)
            {
                OnTimeSunrise();
            }
            else
            {
                OnTimeSunset();
            }
        }

        private void IsDayOrNight()
        {
            if ((IsDay && _isDay) || (!IsDay && !_isDay))
            {
                return;
            }
            if (IsDay)
            {
                SetRates(true);
            }
            else
            {
                SetRates(false);
            }
        }

        private bool IsDay => TOD_Sky.Instance.IsDay;
    }
}


// --- End of file: DayNightGather.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-welcomer ---
// --- Original File Path: D/DiscordWelcomer/DiscordWelcomer.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Logging;

namespace Oxide.Plugins
{
    [Info("Discord Welcomer", "Trey", "2.1.0")]
    [Description("Welcomes players when they join your Discord server.")]
    public class DiscordWelcomer : RustPlugin, IDiscordPlugin
    {
        #region Fields
        
        public DiscordClient Client { get; set; }

        private DiscordGuild _guild;

        private readonly BotConnection _settings = new BotConnection
        {
            Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers
        };
        #endregion

        #region Data

        Data _Data;
        public class Data
        {
            public List<string> ExistingData = new List<string>();
        }

        private void LoadData() => _Data = Interface.Oxide.DataFileSystem.ReadObject<Data>(Name);

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _Data);

        #endregion

        #region Configuration

        Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string BotToken = string.Empty;
            
            [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
            public Snowflake GuildId { get; set; }

            [JsonProperty(PropertyName = "Your Discord ID (For Testing)")]
            public Snowflake TestID;

            [JsonProperty(PropertyName = "Discord Embed Title")]
            public string EmbedTitle = "Welcome!";

            [JsonProperty(PropertyName = "Discord Embed Color (No '#')")]
            public string EmbedColor = "66B2FF";

            [JsonProperty(PropertyName = "Discord Embed Author Name (Leave Blank if Unwanted)")]
            public string EmbedAuthorName = "Server Administration";

            [JsonProperty(PropertyName = "Discord Embed Author Icon URL (Leave Blank if Unwanted)")]
            public string EmbedAuthorURL = "https://steamuserimages-a.akamaihd.net/ugc/687094810512264399/04BA8A55B390D1ED0389E561E95775BCF33A9857/";

            [JsonProperty(PropertyName = "Discord Embed Thumbnail Link (Leave Blank if Unwanted)")]
            public string EmbedThumbnailURL = "https://leganerd.com/wp-content/uploads/2014/05/Rust-logo.png";

            [JsonProperty(PropertyName = "Discord Embed Full Image URL (Leave Blank if Unwanted)")]
            public string EmbedFullImageURL = "https://leganerd.com/wp-content/uploads/2014/05/Rust-logo.png";

            [JsonProperty(PropertyName = "Discord Embed Footer Text (Leave Blank if Unwanted)")]
            public string EmbedFooterText = "Thanks for playing with us!";

            [JsonProperty(PropertyName = "Discord Embed Footer Image URL (Leave Blank if Unwanted)")]
            public string EmbedFooterURL = "https://steamuserimages-a.akamaihd.net/ugc/687094810512264399/04BA8A55B390D1ED0389E561E95775BCF33A9857/";

            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; } = DiscordLogLevel.Info;
            
            [JsonProperty(PropertyName = "Config Version")]
            public string ConfigVersion = "2.0.1";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Localization

        public class LangKeys
        {
            public const string Welcome_New = "Welcome_New";
            public const string Welcome_Existing = "Welcome_Existing";
        }

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Welcome_New] = "Welcome to our Discord Server! Please read over our rules and regulations. We truly hope you enjoy your time with us!",
                [LangKeys.Welcome_Existing] = "Welcome back! Please read over our rules and regulations. We hope you stay with us this time!",
            }, this);
        }

        #endregion

        #region Core Methods
        private void OnServerInitialized()
        {
            LoadData();
            CheckConfigVersion(Version);

            if (config.BotToken != string.Empty)
            {
                _settings.ApiToken = config.BotToken;
                _settings.LogLevel = config.ExtensionDebugging;
                Client.Connect(_settings);
            }
            else
            {
                PrintWarning($"{Name} cannot function while your Discord Bot Token is empty!");
            }
        }

        private void Unload()
        {
            SaveData();
        }

        private void OnServerSave()
        {
            SaveData();
        }

        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            if (ready.Guilds.Count == 0)
            {
                PrintError("Your bot was not found in any discord servers. Please invite it to a server and reload the plugin.");
                return;
            }

            DiscordGuild guild = null;
            if (ready.Guilds.Count == 1 && !config.GuildId.IsValid())
            {
                guild = ready.Guilds.Values.FirstOrDefault();
            }

            if (guild == null)
            {
                guild = ready.Guilds[config.GuildId];
            }

            if (guild == null)
            {
                PrintError("Failed to find a matching guild for the Discord Server Id. " +
                           "Please make sure your guild Id is correct and the bot is in the discord server.");
                return;
            }
                
            if (Client.Bot.Application.Flags.HasValue && !Client.Bot.Application.Flags.Value.HasFlag(ApplicationFlags.GatewayGuildMembersLimited))
            {
                PrintError($"You need to enable \"Server Members Intent\" for {Client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n" +
                           $"{Name} will not function correctly until that is fixed. Once updated please reload {Name}.");
                return;
            }

            _guild = guild;

            Puts($"{Title} ready!");
        }
        
        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberAdded)]
        private void OnDiscordGuildMemberAdded(GuildMember member)
        {
            if (member == null) return;
            if (Client == null) return;

            member.User.CreateDirectMessageChannel(Client).Then(dm => 
            {
            
                if (_Data.ExistingData.Contains(member.User.Id))
                {
                    dm.CreateMessage(Client, CreateEmbed(Lang(LangKeys.Welcome_Existing, null)));
                }

                else
                {
                    dm.CreateMessage(Client, CreateEmbed(Lang(LangKeys.Welcome_New, null)));
                    _Data.ExistingData.Add(member.User.Id);
                }
            
            });
        }
        #endregion

        #region Command
        [ConsoleCommand("testwelcomemessage")]
        private void TestWelcomeCommand(ConsoleSystem.Arg args)
        {
            if (args.Args == null)
            {
                if (config.TestID == string.Empty)
                {
                    PrintError("We couldn't send you a test message because your Test ID is empty in your config.");
                    return;
                }

                GuildMember member = _guild?.Members[config.TestID];

                if (member == null) return;

                OnDiscordGuildMemberAdded(member);
            }
        }
        #endregion

        #region Helpers

        private DiscordEmbed CreateEmbed(string message)
        {
            DiscordEmbed embed = new DiscordEmbed
            {
                Title = config.EmbedTitle,
                Color = ConvertColorToDiscordColor(config.EmbedColor),
                Author = new EmbedAuthor
                {
                    Name = config.EmbedAuthorName,
                    IconUrl = config.EmbedAuthorURL
                },
                Thumbnail = new EmbedThumbnail
                {
                    Url = config.EmbedThumbnailURL
                },
                Description = message,
                Footer = new EmbedFooter
                {
                    Text = config.EmbedFooterText,
                    IconUrl = config.EmbedFooterURL
                },
                Image = new EmbedImage
                {
                    Url = config.EmbedFullImageURL
                },
                Timestamp = DateTime.UtcNow
            };

            return embed;
        }

        private DiscordColor ConvertColorToDiscordColor(string colorcode) => new DiscordColor(Convert.ToUInt32($"0x{colorcode}", 16));

        string Lang(string key, string id, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void CheckConfigVersion(VersionNumber version)
        {
            if (config.ConfigVersion != version.ToString())
            {
                Config.WriteObject(config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonOld");
                PrintError("Your configuration file is out of date, generating up to date one.\nThe old configuration file was saved in the .jsonOld extension");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        #endregion
    }
}

// --- End of file: DiscordWelcomer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-roles ---
// --- Original File Path: D/DiscordRoles/DiscordRoles.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;

namespace Oxide.Plugins
{
    [Info("Discord Roles", "MJSU", "2.1.0")]
    [Description("Syncs players oxide group with discord roles")]
    class DiscordRoles : CovalencePlugin, IDiscordPlugin
    {
        #region Class Fields
        [PluginReference] private Plugin AntiSpam, Clans;
        
        public DiscordClient Client { get; set; }
        
        private PluginConfig _pluginConfig; //Plugin Config

        private readonly List<PlayerSync> _processIds = new List<PlayerSync>();
        
        private Timer _playerChecker;
        private DiscordGuild _guild;
        private BotConnection _discordSettings;

        private const string AccentColor = "#de8732";

        private readonly List<string> _added = new List<string>();
        private readonly List<string> _removed = new List<string>();

        private readonly DiscordLink _link = GetLibrary<DiscordLink>();

        private readonly Hash<string, string> _nicknames = new Hash<string, string>();
        private readonly List<string> _userRoleList = new List<string>();

        public enum DebugEnum
        {
            Message,
            None,
            Error,
            Warning,
            Info
        }

        public enum Source
        {
            Server,
            Discord
        }

        public enum SyncEvent
        {
            None,
            PluginLoaded,
            PlayerConnected,
            ServerGroupChanged,
            DiscordRoleChanged,
            DiscordNicknameChanged,
            PlayerLinkedChanged,
            DiscordServerJoinLeave
        }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _discordSettings = new BotConnection
            {
                ApiToken = _pluginConfig.DiscordApiKey,
                LogLevel = _pluginConfig.ExtensionDebugging,
                Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers
            };
            
            UnsubscribeAll();
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Chat] = $"[#BEBEBE][[{AccentColor}]{Title}[/#]] {{0}}[/#]",
                [LangKeys.ClanTag] = "[{0}] {1}",
                [LangKeys.ServerMessageGroupAdded] = "{player.name} has been added to server group {group.name}",
                [LangKeys.ServerMessageGroupRemoved] = "{player.name} has been removed to server group {group.name}",
                [LangKeys.ServerMessageRoleAdded] = "{player.name} has been added to discord role {role.name}",
                [LangKeys.ServerMessageRoleRemoved] = "{player.name} has been removed to discord role {role.name}",

                [LangKeys.DiscordMessageGroupAdded] = "{discord.name} has been added to server group {group.name}",
                [LangKeys.DiscordMessageGroupRemoved] = "{discord.name} has been removed to server group {group.name}",
                [LangKeys.DiscordMessageRoleAdded] = "{discord.name} has been added to discord role {role.name}",
                [LangKeys.DiscordMessageRoleRemoved] = "{discord.name} has been removed to discord role {role.name}",
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.EventSettings = new EventSettings(config.EventSettings);
            
            config.SyncData = config.SyncData ?? new List<SyncData>
            {
                new SyncData("Default", default(Snowflake), Source.Server),
                new SyncData("VIP", default(Snowflake), Source.Discord)
            };

            for (int index = 0; index < config.SyncData.Count; index++)
            {
                config.SyncData[index] = new SyncData(config.SyncData[index]);
            }

            return config;
        }

        private void OnServerInitialized()
        {
            if (string.IsNullOrEmpty(_pluginConfig.DiscordApiKey))
            {
                PrintWarning("Please enter your bot token in the config and reload the plugin.");
                return;
            }
            
            if (_pluginConfig.UseAntiSpam && AntiSpam == null)
            {
                PrintWarning("AntiSpam is enabled in the config but is not loaded. " +
                             "Please disable the setting in the config or load AntiSpam: https://umod.org/plugins/anti-spam");
                _pluginConfig.UseAntiSpam = false;
            }
            
            Client.Connect(_discordSettings);
        }
        #endregion

        #region Discord Hooks
        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            if (ready.Guilds.Count == 0)
            {
                PrintError("Your bot was not found in any discord servers. Please invite it to a server and reload the plugin.");
                return;
            }

            _guild = null;
            if (ready.Guilds.Count == 1 && !_pluginConfig.GuildId.IsValid())
            {
                _guild = ready.Guilds.Values.FirstOrDefault();
            }

            if (_guild == null)
            {
                _guild = ready.Guilds[_pluginConfig.GuildId];
                if (_guild == null)
                {
                    PrintError("Failed to find a matching guild for the Discord Server Id. " +
                               "Please make sure your guild Id is correct and the bot is in the discord server.");
                }
            }
            
            DiscordApplication app = Client.Bot.Application;
            if (!app.HasApplicationFlag(ApplicationFlags.GatewayGuildMembersLimited) && !app.HasApplicationFlag(ApplicationFlags.GatewayGuildMembers))
            {
                PrintError($"You need to enable \"Server Members Intent\" for {Client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n" +
                           $"{Name} will not function correctly until that is fixed. Once updated please reload {Name}.");
                return;
            }
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMembersLoaded)]
        private void OnDiscordGuildMembersLoaded(DiscordGuild guild)
        {
            if (guild.Id != _guild.Id)
            {
                return;
            }

            HandleMembersLoaded();
            SubscribeAll();
            Puts($"{Title} Ready");
        }

        private void HandleMembersLoaded()
        {
            if (!_pluginConfig.EventSettings.IsAnyEnabled(SyncEvent.PluginLoaded))
            {
                Debug(DebugEnum.Info, "Skipping plugin load event due to no events being enabled");
                return;
            }
            
            for (int index = _pluginConfig.SyncData.Count - 1; index >= 0; index--)
            {
                SyncData data = _pluginConfig.SyncData[index];
                bool remove = false;
                if (!permission.GroupExists(data.ServerGroup))
                {
                    PrintWarning($"Server group does not exist: '{data.ServerGroup}'. Please create the group or correct the name");
                    remove = true;
                }

                DiscordRole role = _guild.Roles[data.DiscordRole];
                if (role == null)
                {
                    PrintWarning($"Discord role ID does not exist: '{data.DiscordRole}'.\n" +
                                 "Please fix the role ID.");
                    remove = true;
                }

                if (remove)
                {
                    _pluginConfig.SyncData.RemoveAt(index);
                }
            }

            timer.In(5f, CheckAllPlayers);
        }

        private void CheckAllPlayers()
        {
            IReadOnlyDictionary<PlayerId, Snowflake> links = _link.PlayerToDiscordIds;
            if (links == null)
            {
                PrintWarning("No Discord Link plugin registered. Please add a Discord Link plugin and reload this plugin.");
                return;
            }
            
            foreach (KeyValuePair<PlayerId, Snowflake> link in links)
            {
                IPlayer player = link.Key.Player;
                if (player.IsDummyPlayer())
                {
                    continue;
                }

                _processIds.Add(new PlayerSync(player, link.Value, false, SyncEvent.PluginLoaded));
            }

            Debug(DebugEnum.Message, $"Starting sync for {_processIds.Count} linked players");

            StartChecker();
        }
        
        private void StartChecker()
        {
            if (_playerChecker == null || _playerChecker.Destroyed)
            {
                _playerChecker = timer.Every(_pluginConfig.UpdateRate, ProcessNextStartupId);
            }
        }

        private void ProcessNextStartupId()
        {
            if (_processIds.Count == 0)
            {
                _playerChecker?.Destroy();
                _playerChecker = null;
                return;
            }

            PlayerSync id = _processIds[0];
            _processIds.RemoveAt(0);

            ProcessUser(id);
        }
        #endregion

        #region Commands
        [Command("dcr.forcecheck")]
        private void HandleCommand(IPlayer player, string cmd, string[] args)
        {
            Debug(DebugEnum.Message, "Begin checking all players");
            CheckAllPlayers();
        }
        #endregion

        #region Hooks
        private void OnUserConnected(IPlayer player)
        {
            if (!_pluginConfig.EventSettings.IsAnyEnabled(SyncEvent.PlayerConnected))
            {
                Debug(DebugEnum.Info, "Skipping player connected event due to no events being enabled");
                return;
            }
            
            Debug(DebugEnum.Info, $"{nameof(OnUserConnected)} Added {player.Name}({player.Id}) to be processed");
            ProcessChange(player.Id, false, SyncEvent.PlayerConnected);
        }

        private void OnUserGroupAdded(string id, string groupName)
        {
            if (!_pluginConfig.EventSettings.IsAnyEnabled(SyncEvent.ServerGroupChanged))
            {
                Debug(DebugEnum.Info, "Skipping server group changed event due to no events being enabled");
                return;
            }
            
            Debug(DebugEnum.Info, $"{nameof(OnUserGroupAdded)} Added ({id}) to be processed because added to group {groupName}");
            ProcessChange(id, false, SyncEvent.ServerGroupChanged);
        }

        private void OnUserGroupRemoved(string id, string groupName)
        {
            if (!_pluginConfig.EventSettings.IsAnyEnabled(SyncEvent.ServerGroupChanged))
            {
                Debug(DebugEnum.Info, "Skipping server group changed event due to no events being enabled");
                return;
            }
            
            Debug(DebugEnum.Info, $"{nameof(OnUserGroupRemoved)} Added ({id}) to be processed because removed from group {groupName}");
            ProcessChange(id, false, SyncEvent.ServerGroupChanged);
        }

        [HookMethod(DiscordExtHooks.OnDiscordPlayerLinked)]
        private void OnDiscordPlayerLinked(IPlayer player, DiscordUser user)
        {
            if (!_pluginConfig.EventSettings.IsAnyEnabled(SyncEvent.PlayerLinkedChanged))
            {
                Debug(DebugEnum.Info, "Skipping player linked event due to no events being enabled");
                return;
            }
            
            Debug(DebugEnum.Info, $"{nameof(OnDiscordPlayerLinked)} Added Player {player.Name}({player.Id}) Discord: {user.Username}#{user.Discriminator}({user.Id}) to be processed");
            ProcessChange(player.Id, false, SyncEvent.PlayerLinkedChanged);
        }

        [HookMethod(DiscordExtHooks.OnDiscordPlayerUnlinked)]
        private void OnDiscordPlayerUnlinked(IPlayer player, DiscordUser user)
        {
            if (!_pluginConfig.EventSettings.IsAnyEnabled(SyncEvent.PlayerLinkedChanged))
            {
                Debug(DebugEnum.Info, "Skipping player unlinked event due to no events being enabled");
                return;
            }
            
            Debug(DebugEnum.Info, $"{nameof(OnDiscordPlayerUnlinked)} Added Player {player.Name}({player.Id}) Discord: {user.Username}#{user.Discriminator}({user.Id}) to be processed");
            ProcessChange(player.Id, true, SyncEvent.PlayerLinkedChanged);
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberAdded)]
        private void OnDiscordGuildMemberAdded(GuildMemberAddedEvent member)
        {
            if (member.GuildId != _guild.Id)
            {
                return;
            }
            
            if (!_pluginConfig.EventSettings.IsAnyEnabled(SyncEvent.DiscordServerJoinLeave))
            {
                Debug(DebugEnum.Info, "Skipping player join event due to no events being enabled");
                return;
            }
            
            Debug(DebugEnum.Info, $"{nameof(OnDiscordGuildMemberAdded)} Added {member.DisplayName}({member.User.Id}) to be processed");
            HandleDiscordChange(member.User, false, SyncEvent.DiscordServerJoinLeave);
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberRemoved)]
        private void OnDiscordGuildMemberRemoved(GuildMemberRemovedEvent member)
        {
            if (member.GuildId != _guild.Id)
            {
                return;
            }
            
            if (!_pluginConfig.EventSettings.IsAnyEnabled(SyncEvent.DiscordServerJoinLeave))
            {
                Debug(DebugEnum.Info, "Skipping player leave event due to no events being enabled");
                return;
            }
            
            Debug(DebugEnum.Info, $"{nameof(OnDiscordGuildMemberRemoved)} Added {member.User.FullUserName}({member.User.Id}) to be processed");
            HandleDiscordChange(member.User, true, SyncEvent.DiscordServerJoinLeave);
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberUpdated)]
        private void OnDiscordGuildMemberUpdated(GuildMember update, GuildMember oldMember, DiscordGuild guild)
        {
            if (guild.Id != _guild?.Id)
            {
                Debug(DebugEnum.Info, $"{nameof(OnDiscordGuildMemberUpdated)} Skipping {update.Nickname}({update.User.Id}) Guild Mismatch");
                return;
            }

            PlayerId playerId = _link.GetPlayerId(update.User.Id);
            if (!playerId.IsValid)
            {
                Debug(DebugEnum.Info, $"{nameof(OnDiscordGuildMemberUpdated)} Player ID is null or empty for user {update.User.FullUserName}");
                return;
            }

            IPlayer player = playerId.Player;
            if (player == null)
            {
                Debug(DebugEnum.Info, $"{nameof(OnDiscordGuildMemberUpdated)} Skipping {update.Nickname}({update.User.Id}) No Linked Player Link: {update.User.IsLinked()} {playerId}");
                return;
            }

            _added.Clear();
            _removed.Clear();

            foreach (Snowflake snowflake in update.Roles.Except(oldMember.Roles))
            {
                _added.Add(_guild?.Roles[snowflake]?.Name ?? "Unknown Role");
            }

            foreach (Snowflake snowflake in oldMember.Roles.Except(update.Roles))
            {
                _removed.Add(_guild?.Roles[snowflake]?.Name ?? "Unknown Role");
            }

            bool shouldUpdate = false;
            SyncEvent syncEvent = SyncEvent.None;
            if (_added.Count != 0)
            {
                shouldUpdate = true;
                Debug(DebugEnum.Info, $"{nameof(OnDiscordGuildMemberUpdated)} Added {update.Nickname}({update.User.Id}) to be processed because added roles {string.Join(", ", _added)}");
                syncEvent = SyncEvent.DiscordRoleChanged;
            }

            if (_removed.Count != 0)
            {
                shouldUpdate = true;
                Debug(DebugEnum.Info, $"{nameof(OnDiscordGuildMemberUpdated)} Added {update.Nickname}({update.User.Id}) to be processed because removed roles {string.Join(", ", _removed)}");
                syncEvent = SyncEvent.DiscordRoleChanged;
            }

            if (update.Nickname != null && (!_nicknames.ContainsKey(update.Id) || _nicknames[update.Id] != update.Nickname) && update.Nickname != GetPlayerName(player))
            {
                shouldUpdate = true;
                Debug(DebugEnum.Info, $"{nameof(OnDiscordGuildMemberUpdated)} Added {update.Nickname}({update.User.Id}) to be processed nickname changed: {oldMember.Nickname} -> {update.Nickname}");
                syncEvent = SyncEvent.DiscordNicknameChanged;
            }

            if (!shouldUpdate)
            {
                Debug(DebugEnum.Info, $"{nameof(OnDiscordGuildMemberUpdated)} Skipping {update.Nickname}({update.User.Id}) no changes detected.");
                return;
            }

            if (!_pluginConfig.EventSettings.IsAnyEnabled(syncEvent))
            {
                Debug(DebugEnum.Info, "Skipping guild member updated event due to no events being enabled");
                return;
            }

            HandleDiscordChange(update.User, false, syncEvent);
        }

        public void HandleDiscordChange(DiscordUser user, bool isLeaving, SyncEvent syncEvent)
        {
            PlayerId playerId = _link.GetPlayerId(user.Id);
            if (!playerId.IsValid)
            {
                Debug(DebugEnum.Info, $"{nameof(HandleDiscordChange)} Player ID is null or empty for user {user.FullUserName}");
                return;
            }

            IPlayer player = playerId.Player;
            if (player == null)
            {
                Debug(DebugEnum.Info, $"{nameof(HandleDiscordChange)} IPlayer not found for user {user.FullUserName}");
                return;
            }
            
            _processIds.RemoveAll(p => p.MemberId == user.Id && !p.IsLeaving);

            PlayerSync sync = new PlayerSync(player, user.Id, isLeaving, syncEvent);
            if (isLeaving)
            {
                sync.Member = new GuildMember
                {
                    User = user,
                    Roles = new List<Snowflake>()
                };
            }

            _processIds.Insert(0, sync);
            StartChecker();
        }

        private void ProcessChange(string playerId, bool isLeaving, SyncEvent syncEvent)
        {
            _processIds.RemoveAll(p => p.Player.Id == playerId);

            IPlayer player = players.FindPlayerById(playerId);
            if (player == null)
            {
                return;
            }

            Snowflake discordId = player.GetDiscordUserId();
            if (!discordId.IsValid())
            {
                return;
            }

            _processIds.Insert(0, new PlayerSync(player, discordId, isLeaving, syncEvent));

            StartChecker();
        }
        #endregion

        #region Role Handling
        public void ProcessUser(PlayerSync sync)
        {
            if (sync.Member == null)
            {
                if (!sync.MemberId.IsValid())
                {
                    return;
                }
                
                if (!_guild.Members.ContainsKey(sync.MemberId))
                {
                    return;
                }
                
                _guild.GetMember(Client, sync.MemberId).Then(member =>
                {
                    sync.Member = member;
                    ProcessUser(sync);
                });
                return;
            }
            
            try
            {
                Debug(DebugEnum.Info, $"Start processing: Player: {sync.Player.Name}({sync.Player.Id}) Discord: {sync.Member.DisplayName}({sync.Member.User?.Id}) Is Leaving: {sync.IsLeaving}");
                UnsubscribeAll();
                HandleServerGroups(sync);
                HandleDiscordRoles(sync);
                HandleUserNick(sync);
            }
            finally
            {
                SubscribeAll();
            }
        }

        public void HandleServerGroups(PlayerSync playerSync)
        {
            if (playerSync.IsLeaving)
            {
                return;
            }
            
            IPlayer player = playerSync.Player;
            GuildMember member = playerSync.Member;
            
            string playerName = $"{player.Name}({playerSync.Player.Id}) {member.DisplayName}({member.User.Id})";
            
            Debug(DebugEnum.Info, $"Processing Server for {player.Name}({player.Id}) Discord {member.DisplayName}({member.User.Id}) Is Leaving {playerSync.IsLeaving}");

            if (!_pluginConfig.EventSettings.ServerSync.IsEnabled(playerSync.Event))
            {
                Debug(DebugEnum.Info, $"Skipping server sync due to event not being enabled for {playerSync.Event}");
                return;
            }
            
            foreach (IGrouping<Snowflake, SyncData> data in _pluginConfig.SyncData.Where(s => s.Source == Source.Server).GroupBy(s => s.DiscordRole))
            {
                bool isInGroup = data.Any(d => permission.UserHasGroup(player.Id, d.ServerGroup));
                bool isInDiscord = member.Roles.Contains(data.Key);
                if (isInDiscord == isInGroup)
                {
                    Debug(DebugEnum.Info, $"{playerSync.Player.Name} skipping Server Sync: [{string.Join(", ", data.Select(d => d.ServerGroup).ToArray())}] -> {_guild.Roles[data.Key]?.Name} {(isInGroup ? "Already Synced" : "Not in group")}");
                    continue;
                }

                string roleName = _guild.Roles[data.Key]?.Name;
                
                if (isInGroup)
                {
                    Debug(DebugEnum.Message, $"Adding player {playerName} to discord role {roleName}");
                    _guild.AddMemberRole(Client, member.User.Id, data.Key).Then(() =>
                    {
                        Debug(DebugEnum.Message, $"Successfully added {playerName} to {roleName}");
                    }).Catch<ResponseError>(error =>
                    {
                        Debug(DebugEnum.Error, $"An error has occured adding {playerName} to {roleName}. Please check above this message for the error.");
                    });
                }
                else
                {
                    _guild.RemoveMemberRole(Client, playerSync.Member.User.Id, data.Key).Then(() =>
                    {
                        Debug(DebugEnum.Message, $"Successfully removed {playerName} from {roleName}");
                    }).Catch<ResponseError>(error =>
                    {
                        Debug(DebugEnum.Error, $"An error has occured removing {playerName} from {roleName}. Please check above this message for the error.");
                    });
                }

                SyncData sync = data.FirstOrDefault(d => permission.UserHasGroup(player.Id, d.ServerGroup)) ?? data.FirstOrDefault();
                SendSyncNotification(playerSync, sync, isInGroup);
            }
        }

        public void HandleDiscordRoles(PlayerSync playerSync)
        {
            IPlayer player = playerSync.Player;
            GuildMember member = playerSync.Member;
            
            string playerName = $"{player.Name}({playerSync.Player.Id}) {member.DisplayName}({member.User.Id})";
            
            Debug(DebugEnum.Info, $"Processing Discord for {player.Name}({player.Id}) Discord {member.DisplayName}({member.User.Id}) Is Leaving {playerSync.IsLeaving} Roles: {GetUserRoles(playerSync.Member)}");
            
            if (!_pluginConfig.EventSettings.DiscordSync.IsEnabled(playerSync.Event))
            {
                Debug(DebugEnum.Info, $"Skipping discord sync due to event not being enabled for {playerSync.Event}");
                return;
            }
            
            foreach (IGrouping<string, SyncData> data in _pluginConfig.SyncData.Where(s => s.Source == Source.Discord).GroupBy(s => s.ServerGroup))
            {
                bool isInGroup = permission.UserHasGroup(player.Id, data.Key);
                bool isInDiscord = false;
                SyncData sync = null;
                if (!playerSync.IsLeaving)
                {
                    foreach (SyncData syncData in data)
                    {
                        if (member.Roles.Contains(syncData.DiscordRole))
                        {
                            sync = syncData;
                            isInDiscord = true;
                            break;
                        }
                    }
                }

                if (isInDiscord == isInGroup)
                {
                    Debug(DebugEnum.Info, $"{player?.Name} skipping Discord Sync: [{string.Join(", ", data.Select(d => _guild.Roles[d.DiscordRole]?.Name ?? string.Empty).ToArray())}] -> {data.Key} {(isInDiscord ? "Already Synced" : "Doesn't have role")}");
                    continue;
                }

                if (isInDiscord)
                {
                    Debug(DebugEnum.Message, $"Adding player {playerName} to server group {data.Key}");
                    permission.AddUserGroup(player.Id, data.Key);
                }
                else
                {
                    Debug(DebugEnum.Message, $"Removing player {playerName} from server group {data.Key}");
                    permission.RemoveUserGroup(player.Id, data.Key);
                }
                
                sync = sync ?? data.FirstOrDefault();
                SendSyncNotification(playerSync, sync, isInDiscord);
            }
        }

        public void HandleUserNick(PlayerSync sync)
        {
            IPlayer player = sync.Player;
            if (!_pluginConfig.SyncNicknames || sync.IsLeaving)
            {
                Debug(DebugEnum.Info, $"{nameof(HandleUserNick)} don't sync nicknames or is leaving");
                return;
            }
            
            if (sync.Member.User.Id == _guild.OwnerId)
            {
                Debug(DebugEnum.Info, $"{nameof(HandleUserNick)} don't sync nickname discord server owner");
                return;
            }
            
            if (!_pluginConfig.EventSettings.NicknameSync.IsEnabled(sync.Event))
            {
                Debug(DebugEnum.Info, $"Skipping nickname sync due to event not being enabled for {sync.Event}");
                return;
            }

            string playerName = GetPlayerName(player);
            if (playerName.Equals(sync.Member.Nickname))
            {
                Debug(DebugEnum.Info, $"{nameof(HandleUserNick)} skipping nickname as it matches what we expect: {playerName}");
                return;
            }
            
            Debug(DebugEnum.Info, $"Updating {sync.Member.DisplayName}'s discord server nickname to {playerName}");
            
            _guild.EditMemberNick(Client, sync.Member.User.Id, playerName).Then(member =>
            {
                Debug(DebugEnum.Info, $"Successfully updated {sync.Member.DisplayName}'s discord server nickname to {playerName}");
                _nicknames[sync.Member.User.Id] = member.Nickname;
            }).Catch<ResponseError>(error =>
            {
                Debug(DebugEnum.Error, $"An error has occured updating {sync.Member.DisplayName}'s discord server nickname to {playerName}");
            });
        }
        
        private string GetPlayerName(IPlayer player)
        {
            string playerName = player.Name;
            if (_pluginConfig.UseAntiSpam && AntiSpam != null && AntiSpam.IsLoaded)
            {
                playerName = AntiSpam.Call<string>("GetClearName", player);
                if (string.IsNullOrEmpty(playerName))
                {
                    Debug(DebugEnum.Warning, $"AntiSpam returned an empty string for '{player.Name}'");
                    playerName = player.Name;
                }
                else if (!playerName.Equals(player.Name))
                {
                    Debug(DebugEnum.Info, $"Nickname '{player.Name}' was filtered by AntiSpam: '{playerName}'");
                }
            }
            
            if (_pluginConfig.SyncClanTag)
            {
                string tag = Clans?.Call<string>("GetClanOf", player.Id);
                if (!string.IsNullOrEmpty(tag))
                {
                    playerName = Lang(LangKeys.ClanTag, player, tag, playerName);
                }
            }

            if (playerName.Length > 32)
            {
                playerName = playerName.Substring(0, 32);
            }
            
            return playerName;
        }
        #endregion

        #region Message Handling
        private void SendSyncNotification(PlayerSync sync, SyncData data, bool wasAdded)
        {
            NotificationSettings settings = data.Notifications;
            if (!settings.SendMessageToServer && !settings.SendMessageToDiscord)
            {
                return;
            }

            if (wasAdded && !settings.SendMessageOnAdd)
            {
                return;
            }

            if (!wasAdded && !settings.SendMessageOnRemove)
            {
                return;
            }

            if (settings.SendMessageToServer)
            {
                StringBuilder message = GetServerMessage(data, wasAdded);
                ProcessMessage(message, sync, data);
                Chat(message.ToString());
            }

            if (settings.SendMessageToDiscord)
            {
                if (!settings.DiscordMessageChannelId.IsValid())
                {
                    return;
                }

                StringBuilder message = GetDiscordMessage(data, wasAdded);
                ProcessMessage(message, sync, data);
                DiscordMessage.Create(Client, settings.DiscordMessageChannelId, message.ToString());
            }
        }

        private StringBuilder GetServerMessage(SyncData sync, bool wasAdded)
        {
            StringBuilder message = new StringBuilder();
            if (wasAdded && !string.IsNullOrEmpty(sync.Notifications.ServerMessageAddedOverride))
            {
                message.Append(sync.Notifications.ServerMessageAddedOverride);
            }
            else if (!wasAdded && !string.IsNullOrEmpty(sync.Notifications.ServerMessageRemovedOverride))
            {
                message.Append(sync.Notifications.ServerMessageRemovedOverride);
            }
            else
            {
                switch (sync.Source)
                {
                    case Source.Server:
                        message.Append(wasAdded ? LangNoFormat(LangKeys.ServerMessageRoleAdded) : LangNoFormat(LangKeys.ServerMessageRoleRemoved));
                        break;

                    case Source.Discord:
                        message.Append(wasAdded ? LangNoFormat(LangKeys.ServerMessageGroupAdded) : LangNoFormat(LangKeys.ServerMessageGroupRemoved));
                        break;
                }
            }

            return message;
        }

        private StringBuilder GetDiscordMessage(SyncData sync, bool wasAdded)
        {
            StringBuilder message = new StringBuilder();
            if (wasAdded && !string.IsNullOrEmpty(sync.Notifications.DiscordMessageAddedOverride))
            {
                message.Append(sync.Notifications.DiscordMessageAddedOverride);
            }
            else if (!wasAdded && !string.IsNullOrEmpty(sync.Notifications.DiscordMessageRemovedOverride))
            {
                message.Append(sync.Notifications.DiscordMessageRemovedOverride);
            }
            else
            {
                switch (sync.Source)
                {
                    case Source.Server:
                        message.Append(wasAdded ? LangNoFormat(LangKeys.DiscordMessageRoleAdded) : LangNoFormat(LangKeys.DiscordMessageRoleRemoved));
                        break;

                    case Source.Discord:
                        message.Append(wasAdded ? LangNoFormat(LangKeys.DiscordMessageGroupAdded) : LangNoFormat(LangKeys.DiscordMessageGroupRemoved));
                        break;
                }
            }

            return message;
        }

        private void ProcessMessage(StringBuilder message, PlayerSync sync, SyncData data)
        {
            IPlayer player = sync.Player;
            GuildMember member = sync.Member;

            if (player != null)
            {
                message.Replace("{player.id}", player.Id);
                message.Replace("{player.name}", player.Name);
            }

            if (member != null)
            {
                message.Replace("{discord.id}", member.User.Id.ToString());
                message.Replace("{discord.name}", member.User.Username);
                message.Replace("{discord.discriminator}", member.User.Discriminator);
                message.Replace("{discord.nickname}", member.Nickname);
            }

            DiscordRole role = _guild.Roles[data.DiscordRole];
            if (role != null)
            {
                message.Replace("{role.id}", role.Id.ToString());
                message.Replace("{role.name}", role.Name);
            }

            message.Replace("{group.name}", data.ServerGroup);
        }
        #endregion

        #region Subscription Handling
        public void UnsubscribeAll()
        {
            try
            {
                Unsubscribe(nameof(OnUserGroupAdded));
                Unsubscribe(nameof(OnUserGroupRemoved));
                Unsubscribe(nameof(OnUserConnected));
            }
            catch
            {
                
            }
        }

        public void SubscribeAll()
        {
            try
            {
                Subscribe(nameof(OnUserGroupAdded));
                Subscribe(nameof(OnUserGroupRemoved));
                Subscribe(nameof(OnUserConnected));
            }
            catch
            {
                
            }
        }
        #endregion

        #region Helper Methods
        public string GetUserRoles(GuildMember member)
        {
            _userRoleList.Clear();
            foreach (Snowflake role in member.Roles)
            {
                _userRoleList.Add($"{_guild.Roles[role].Name} ({role.ToString()})");
            }

            return string.Join(", ", _userRoleList);
        }

        public void Debug(DebugEnum level, string message)
        {
            if (level <= _pluginConfig.DebugLevel)
            {
                Puts($"{level}: {message}");
            }
        }

        public void Chat(string message)
        {
            server.Broadcast(Lang(LangKeys.Chat, null, message));
        }

        public string Lang(string key, IPlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, player?.Id), args);
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception:\n{ex}");
                throw;
            }
        }
        
        public string LangNoFormat(string key, IPlayer player = null) => lang.GetMessage(key, this, player?.Id);
        #endregion

        #region Classes
        public class PluginConfig
        {
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string DiscordApiKey { get; set; }
            
            [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
            public Snowflake GuildId { get; set; }
            
            [DefaultValue(false)]
            [JsonProperty(PropertyName = "Sync Nicknames")]
            public bool SyncNicknames { get; set; }
            
            [DefaultValue(false)]
            [JsonProperty(PropertyName = "Sync Clan Tag")]
            public bool SyncClanTag { get; set; }

            [DefaultValue(2f)]
            [JsonProperty(PropertyName = "Update Rate (Seconds)")]
            public float UpdateRate { get; set; }
            
            [DefaultValue(false)]
            [JsonProperty(PropertyName = "Use AntiSpam On Discord Nickname")]
            public bool UseAntiSpam { get; set; }
            
            [JsonProperty(PropertyName = "Action To Perform By Event")]
            public EventSettings EventSettings { get; set; }

            [JsonProperty(PropertyName = "Sync Data")]
            public List<SyncData> SyncData { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DebugEnum.Warning)]
            [JsonProperty(PropertyName = "Plugin Log Level (None, Error, Warning, Info)")]
            public DebugEnum DebugLevel { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; }
        }

        public class EventSettings
        {
            [JsonProperty("Events To Sync Server Groups -> Discord Roles")]
            public EnabledSyncEvents ServerSync { get; set; }
            
            [JsonProperty("Events To Sync Discord Roles -> Server Groups")]
            public EnabledSyncEvents DiscordSync { get; set; }
            
            [JsonProperty("Events To Sync Discord Nickname")]
            public EnabledSyncEvents NicknameSync { get; set; }

            [JsonConstructor]
            public EventSettings()
            {
                
            }
            
            public EventSettings(EventSettings settings)
            {
                ServerSync = new EnabledSyncEvents
                {
                    SyncOnPluginLoad = settings?.ServerSync?.SyncOnPluginLoad ?? true,
                    SyncOnPlayerConnected = settings?.ServerSync?.SyncOnPlayerConnected ?? true,
                    SyncOnServerGroupChanged = settings?.ServerSync?.SyncOnServerGroupChanged ?? true,
                    SyncOnDiscordRoleChanged = settings?.ServerSync?.SyncOnDiscordRoleChanged ?? true,
                    SyncOnDiscordNicknameChanged = settings?.ServerSync?.SyncOnDiscordNicknameChanged ?? false,
                    SyncOnLinkedChanged = settings?.ServerSync?.SyncOnLinkedChanged ?? true,
                    SyncOnDiscordServerJoinLeave = settings?.ServerSync?.SyncOnDiscordServerJoinLeave ?? true
                };
                
                DiscordSync = new EnabledSyncEvents
                {
                    SyncOnPluginLoad = settings?.DiscordSync?.SyncOnPluginLoad ?? true,
                    SyncOnPlayerConnected = settings?.DiscordSync?.SyncOnPlayerConnected ?? true,
                    SyncOnServerGroupChanged = settings?.DiscordSync?.SyncOnServerGroupChanged ?? true,
                    SyncOnDiscordRoleChanged = settings?.DiscordSync?.SyncOnDiscordRoleChanged ?? true,
                    SyncOnDiscordNicknameChanged = settings?.DiscordSync?.SyncOnDiscordNicknameChanged ?? false,
                    SyncOnLinkedChanged = settings?.DiscordSync?.SyncOnLinkedChanged ?? true,
                    SyncOnDiscordServerJoinLeave = settings?.DiscordSync?.SyncOnDiscordServerJoinLeave ?? true
                };
                
                NicknameSync = new EnabledSyncEvents
                {
                    SyncOnPluginLoad = settings?.NicknameSync?.SyncOnPluginLoad ?? true,
                    SyncOnPlayerConnected = settings?.NicknameSync?.SyncOnPlayerConnected ?? true,
                    SyncOnServerGroupChanged = settings?.NicknameSync?.SyncOnServerGroupChanged ?? false,
                    SyncOnDiscordRoleChanged = settings?.NicknameSync?.SyncOnDiscordRoleChanged ?? false,
                    SyncOnDiscordNicknameChanged = settings?.NicknameSync?.SyncOnDiscordNicknameChanged ?? true,
                    SyncOnLinkedChanged = settings?.NicknameSync?.SyncOnLinkedChanged ?? true,
                    SyncOnDiscordServerJoinLeave = settings?.NicknameSync?.SyncOnDiscordServerJoinLeave ?? false
                };
            }

            public bool IsAnyEnabled(SyncEvent syncEvent)
            {
                return ServerSync.IsEnabled(syncEvent) || DiscordSync.IsEnabled(syncEvent) || NicknameSync.IsEnabled(syncEvent);
            } 
        }

        public class SyncData
        {
            [JsonProperty(PropertyName = "Server Group")]
            public string ServerGroup { get; set; }

            [JsonProperty(PropertyName = "Discord Role ID")]
            public Snowflake DiscordRole { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Sync Source (Server or Discord)")]
            public Source Source { get; set; }

            [JsonProperty(PropertyName = "Sync Notification Settings")]
            public NotificationSettings Notifications { get; set; }

            [JsonConstructor]
            public SyncData()
            {
                
            }
            
            public SyncData(string serverGroup, Snowflake discordRole, Source source)
            {
                ServerGroup = serverGroup;
                DiscordRole = discordRole;
                Source = source;
                Notifications = new NotificationSettings();
            }

            public SyncData(SyncData settings)
            {
                ServerGroup = settings?.ServerGroup ?? string.Empty;
                DiscordRole = settings?.DiscordRole ?? default(Snowflake);
                Source = settings?.Source ?? Source.Server;
                Notifications = new NotificationSettings(settings?.Notifications);
            }
        }

        public class NotificationSettings
        {
            [JsonProperty(PropertyName = "Send message to Server")]
            public bool SendMessageToServer { get; set; }

            [JsonProperty(PropertyName = "Send Message To Discord")]
            public bool SendMessageToDiscord { get; set; }

            [JsonProperty(PropertyName = "Discord Message Channel ID")]
            public Snowflake DiscordMessageChannelId { get; set; }

            [JsonProperty(PropertyName = "Send Message When Added")]
            public bool SendMessageOnAdd { get; set; }

            [JsonProperty(PropertyName = "Send Message When Removed")]
            public bool SendMessageOnRemove { get; set; }

            [JsonProperty(PropertyName = "Server Message Added Override Message")]
            public string ServerMessageAddedOverride { get; set; }

            [JsonProperty(PropertyName = "Server Message Removed Override Message")]
            public string ServerMessageRemovedOverride { get; set; }

            [JsonProperty(PropertyName = "Discord Message Added Override Message")]
            public string DiscordMessageAddedOverride { get; set; }

            [JsonProperty(PropertyName = "Discord Message Removed Override Message")]
            public string DiscordMessageRemovedOverride { get; set; }

            public NotificationSettings()
            {
                SendMessageToServer = false;
                SendMessageToDiscord = false;
                DiscordMessageChannelId = default(Snowflake);
                SendMessageOnAdd = false;
                SendMessageOnRemove = false;
                ServerMessageAddedOverride = string.Empty;
                ServerMessageRemovedOverride = string.Empty;
                DiscordMessageAddedOverride = string.Empty;
                DiscordMessageRemovedOverride = string.Empty;
            }

            public NotificationSettings(NotificationSettings settings)
            {
                SendMessageToServer = settings?.SendMessageToServer ?? false;
                SendMessageToDiscord = settings?.SendMessageToDiscord ?? false;
                DiscordMessageChannelId = settings?.DiscordMessageChannelId ?? default(Snowflake);
                SendMessageOnAdd = settings?.SendMessageOnAdd ?? false;
                SendMessageOnRemove = settings?.SendMessageOnRemove ?? false;
                ServerMessageAddedOverride = settings?.ServerMessageAddedOverride ?? string.Empty;
                ServerMessageRemovedOverride = settings?.ServerMessageRemovedOverride ?? string.Empty;
                DiscordMessageAddedOverride = settings?.DiscordMessageAddedOverride ?? string.Empty;
                DiscordMessageRemovedOverride = settings?.DiscordMessageRemovedOverride ?? string.Empty;
            }
        }

        public class EnabledSyncEvents
        {
            [JsonProperty("Sync On Plugin Load")]
            public bool SyncOnPluginLoad { get; set; }
            
            [JsonProperty("Sync On Player Connected")]
            public bool SyncOnPlayerConnected { get; set; }
            
            [JsonProperty("Sync On Server Group Changed")]
            public bool SyncOnServerGroupChanged { get; set; }
            
            [JsonProperty("Sync On Discord Role Changed")]
            public bool SyncOnDiscordRoleChanged { get; set; }
            
            [JsonProperty("Sync On Discord Nickname Changed")]
            public bool SyncOnDiscordNicknameChanged { get; set; }
            
            [JsonProperty("Sync On Player Linked / Unlinked")]
            public bool SyncOnLinkedChanged { get; set; }
            
            [JsonProperty("Sync On User Join / Leave Discord Server")]
            public bool SyncOnDiscordServerJoinLeave { get; set; }

            public bool IsEnabled(SyncEvent syncEvent)
            {
                switch (syncEvent)
                {
                    case SyncEvent.None:
                        return false;
                    case SyncEvent.PluginLoaded:
                        return SyncOnPluginLoad;
                    case SyncEvent.PlayerConnected:
                        return SyncOnPlayerConnected;
                    case SyncEvent.ServerGroupChanged:
                        return SyncOnServerGroupChanged;
                    case SyncEvent.DiscordRoleChanged:
                        return SyncOnDiscordRoleChanged;
                    case SyncEvent.DiscordNicknameChanged:
                        return SyncOnDiscordNicknameChanged;
                    case SyncEvent.PlayerLinkedChanged:
                        return SyncOnLinkedChanged;
                    case SyncEvent.DiscordServerJoinLeave:
                        return SyncOnDiscordServerJoinLeave;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(syncEvent), syncEvent, null);
                }
            }
        }

        public class PlayerSync
        {
            public IPlayer Player { get; set; }
            public GuildMember Member { get; set; }
            public Snowflake MemberId { get; set; }
            public SyncEvent Event { get; set; }
            public bool IsLeaving { get; set; }

            public PlayerSync(IPlayer player, Snowflake memberId, bool isLeaving, SyncEvent syncEvent)
            {
                Player = player;
                MemberId = memberId;
                IsLeaving = isLeaving;
                Event = syncEvent;
            }
        }

        public class LangKeys
        {
            public const string Chat = nameof(Chat);
            public const string ClanTag = nameof(ClanTag);

            public const string ServerMessageGroupAdded = nameof(ServerMessageGroupAdded);
            public const string ServerMessageGroupRemoved = nameof(ServerMessageGroupRemoved);
            public const string ServerMessageRoleAdded = nameof(ServerMessageRoleAdded);
            public const string ServerMessageRoleRemoved = nameof(ServerMessageRoleRemoved);

            public const string DiscordMessageGroupAdded = nameof(DiscordMessageGroupAdded);
            public const string DiscordMessageGroupRemoved = nameof(DiscordMessageGroupRemoved);
            public const string DiscordMessageRoleAdded = nameof(DiscordMessageRoleAdded);
            public const string DiscordMessageRoleRemoved = nameof(DiscordMessageRoleRemoved);
        }
        #endregion
    }
}

// --- End of file: DiscordRoles.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-sign-logger ---
// --- Original File Path: D/DiscordSignLogger/DiscordSignLogger.cs ---

//Reference: System.Drawing
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Builders;
using Oxide.Ext.Discord.Cache;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.Types;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Text;
using UnityEngine;

using Color = System.Drawing.Color;
using Graphics = System.Drawing.Graphics;
using Star = ProtoBuf.PatternFirework.Star;

//DiscordSignLogger created with PluginMerge v(1.0.9.0) by MJSU @ https://github.com/dassjosh/Plugin.Merge
namespace Oxide.Plugins
{
    [Info("Discord Sign Logger", "MJSU", "3.0.0")]
    [Description("Logs Sign / Firework Changes To Discord")]
    public partial class DiscordSignLogger : RustPlugin, IDiscordPlugin, IDiscordPool
    {
        #region Plugins\DiscordSignLogger.Fields.cs
        #pragma warning disable CS0649
        // ReSharper disable InconsistentNaming
        [PluginReference] private Plugin RustTranslationAPI, SignArtist;
        // ReSharper restore InconsistentNaming
        #pragma warning restore CS0649
        
        #pragma warning disable CS0649
        public DiscordClient Client { get; set; }
        #pragma warning restore CS0649
        
        private PluginConfig _pluginConfig;
        private PluginData _pluginData;
        
        private const string CommandPrefix = "DSL_CMD";
        private const string ActionPrefix = "DSL_ACTION";
        private const string ModalPrefix = "DSL_MODAL";
        private const string PlayerMessage = "PLAYER_MESSAGE";
        private const string ServerMessage = "SERVER_MESSAGE";
        private const string AccentColor = "#de8732";
        
        private readonly MessageCreate _actionMessage = new()
        {
            AllowedMentions = AllowedMentions.None
        };
        
        public DiscordPluginPool Pool { get; set; }
        
        private readonly StringBuilder _sb = new();
        public readonly Hash<UnityEngine.Color, Brush> FireworkBrushes = new();
        private readonly Hash<NetworkableId, SignageUpdate> _updates = new();
        private readonly Hash<uint, string> _prefabNameCache = new();
        private readonly Hash<int, string> _itemNameCache = new();
        private readonly Hash<TemplateKey, SignMessage> _signMessages = new();
        private readonly Hash<ButtonId, ImageButton> _imageButtons = new();
        
        private DiscordChannel _actionChannel;
        
        private readonly DiscordPlaceholders _placeholders = GetLibrary<DiscordPlaceholders>();
        private readonly DiscordMessageTemplates _templates = GetLibrary<DiscordMessageTemplates>();
        private readonly DiscordButtonTemplates _buttonTemplates = GetLibrary<DiscordButtonTemplates>();
        private readonly DiscordCommandLocalizations _local = GetLibrary<DiscordCommandLocalizations>();
        
        public int FireworkImageSize;
        public int FireworkHalfImageSize;
        public int FireworkCircleSize;
        
        private readonly object _true = true;
        private readonly object _false = false;
        
        public static DiscordSignLogger Instance;
        #endregion

        #region Plugins\DiscordSignLogger.Setup.cs
        private void Init()
        {
            Instance = this;
            
            UnsubscribeAll();
            
            _pluginConfig.ReplaceImage.TextColor = _pluginConfig.ReplaceImage.TextColor.Replace("#", "");
            _pluginConfig.ReplaceImage.BodyColor = _pluginConfig.ReplaceImage.BodyColor.Replace("#", "");
            
            HashSet<string> ids = new();
            foreach (SignMessage message in _pluginConfig.SignMessages)
            {
                if (ids.Add(message.MessageId.Name))
                {
                    _signMessages[message.MessageId] = message;
                }
                else
                {
                    PrintWarning($"Duplicate Sign Message ID: '{message.MessageId.Name}'. Please check your config and correct the duplicate Sign Message ID's");
                }
            }
            
            ids.Clear();
            foreach (ImageButton button in _pluginConfig.Buttons)
            {
                if (ids.Add(button.ButtonId.Id))
                {
                    _imageButtons[button.ButtonId] = button;
                }
                else
                {
                    PrintWarning($"Duplicate Button ID: '{button.ButtonId.Id}'. Please check your config and correct the duplicate Image Button ID's");
                }
            }
            
            _pluginData = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
            
            RegisterPlaceholders();
            RegisterTemplates();
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }
        
        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.FireworkSettings = new FireworkSettings(config.FireworkSettings);
            config.ReplaceImage = new ReplaceImageSettings(config.ReplaceImage);
            config.SignMessages ??= new List<SignMessage>();
            config.PluginSettings = new PluginSettings(config.PluginSettings);
            
            if (config.SignMessages.Count == 0)
            {
                config.SignMessages.Add(new SignMessage(null));
            }
            else
            {
                for (int index = 0; index < config.SignMessages.Count; index++)
                {
                    config.SignMessages[index] = new SignMessage(config.SignMessages[index]);
                }
            }
            
            config.Buttons ??= new List<ImageButton>
            {
                new()
                {
                    ButtonId = new ButtonId("ERASE"),
                    DisplayName = "Erase",
                    Style = ButtonStyle.Primary,
                    Commands = new List<string> { $"dsl.erase {PlaceholderKeys.EntityId} {PlaceholderKeys.TextureIndex}" },
                    PlayerMessage = "An admin erased your sign for being inappropriate",
                    ServerMessage = string.Empty,
                    RequirePermissions = false,
                    ConfirmModal = false,
                    AllowedRoles = new List<Snowflake>(),
                    AllowedGroups = new List<string>()
                },
                new()
                {
                    ButtonId = new ButtonId("SIGN_BLOCK_24_HOURS"),
                    DisplayName = "Sign Block (24 Hours)",
                    Style = ButtonStyle.Primary,
                    Commands = new List<string> { "dsl.signblock {player.id} 86400" },
                    PlayerMessage = "You have been banned from updating signs for 24 hours.",
                    ServerMessage = string.Empty,
                    RequirePermissions = true,
                    ConfirmModal = false,
                    AllowedRoles = new List<Snowflake>(),
                    AllowedGroups = new List<string>()
                },
                new()
                {
                    ButtonId = new ButtonId("KILL_ENTITY"),
                    DisplayName = "Kill Entity",
                    Style = ButtonStyle.Secondary,
                    Commands = new List<string> { $"entid kill {PlaceholderKeys.EntityId}" },
                    PlayerMessage = "An admin killed your sign for being inappropriate",
                    ServerMessage = string.Empty,
                    RequirePermissions = true,
                    ConfirmModal = false,
                    AllowedRoles = new List<Snowflake>(),
                    AllowedGroups = new List<string>()
                },
                new()
                {
                    ButtonId = new ButtonId("KICK_PLAYER"),
                    DisplayName = "Kick Player",
                    Style = ButtonStyle.Danger,
                    Commands = new List<string> {
                        $"kick {DefaultKeys.Player.Id} \"{PlaceholderKeys.PlayerMessage}\"",
                        $"dsl.erase {PlaceholderKeys.EntityId} {PlaceholderKeys.TextureIndex}"
                    },
                    PlayerMessage = string.Empty,
                    ServerMessage = string.Empty,
                    RequirePermissions = true,
                    ConfirmModal = true,
                    AllowedRoles = new List<Snowflake>(),
                    AllowedGroups = new List<string>()
                },
                new()
                {
                    ButtonId = new ButtonId("BAN_PLAYER"),
                    DisplayName = "Ban Player",
                    Style = ButtonStyle.Danger,
                    Commands = new List<string>
                    {
                        $"ban {DefaultKeys.Player.Id} \"{PlaceholderKeys.PlayerMessage}\"",
                        $"dsl.erase {PlaceholderKeys.EntityId} {PlaceholderKeys.TextureIndex}"
                    },
                    PlayerMessage = string.Empty,
                    ServerMessage = string.Empty,
                    RequirePermissions = true,
                    ConfirmModal = true,
                    AllowedRoles = new List<Snowflake>(),
                    AllowedGroups = new List<string>()
                }
            };
            
            for (int index = 0; index < config.Buttons.Count; index++)
            {
                config.Buttons[index] = new ImageButton(config.Buttons[index]);
            }
            
            return config;
        }
        
        private void OnServerInitialized()
        {
            FireworkCircleSize = _pluginConfig.FireworkSettings.CircleSize;
            FireworkImageSize = _pluginConfig.FireworkSettings.ImageSize + FireworkCircleSize;
            FireworkHalfImageSize = _pluginConfig.FireworkSettings.ImageSize / 2;
            
            if (string.IsNullOrEmpty(_pluginConfig.DiscordApiKey))
            {
                PrintWarning("Please set the Discord Bot Token and reload the plugin");
                return;
            }
            
            if (SignArtist is { IsLoaded: true })
            {
                if (SignArtist.Version < new VersionNumber(1, 4, 0))
                {
                    PrintWarning("Sign Artist version is outdated and may not function correctly. Please update SignArtist @ https://umod.org/plugins/sign-artist to version 1.4.0 or higher");
                }
            }
            else
            {
                Unsubscribe(nameof(OnPlayerCommand));
            }
            
            Client.Connect(new BotConnection
            {
                Intents = GatewayIntents.Guilds,
                ApiToken = _pluginConfig.DiscordApiKey,
                LogLevel = _pluginConfig.ExtensionDebugging
            });
        }
        
        private void Unload()
        {
            SaveData();
            Instance = null;
        }
        #endregion

        #region Plugins\DiscordSignLogger.CoreHooks.cs
        private void OnImagePost(BasePlayer player, string url, bool raw, ISignage signage, uint textureIndex)
        {
            bool ignore = player == null || !_pluginConfig.PluginSettings.SignArtist.ShouldLog(url);
            _updates[signage.NetworkID] = new SignageUpdate(player, signage, (byte)textureIndex, ignore, url);
        }
        
        private void OnSignUpdated(ISignage signage, BasePlayer player, int textureIndex = 0)
        {
            if (player == null)
            {
                _updates.Remove(signage.NetworkID);
                return;
            }
            
            if (signage.GetTextureCRCs()[textureIndex] == 0)
            {
                return;
            }
            
            SignageUpdate update = _updates[signage.NetworkID] ?? new SignageUpdate(player, signage, (byte)textureIndex, player == null);
            _updates.Remove(signage.NetworkID);
            if (update.IgnoreMessage)
            {
                return;
            }
            
            SendDiscordMessage(update);
        }
        
        private void OnItemPainted(PaintedItemStorageEntity entity, Item item, BasePlayer player, byte[] image)
        {
            if (entity._currentImageCrc != 0)
            {
                PaintedItemUpdate update = new(player, entity, item, image, false);
                SendDiscordMessage(update);
            }
        }
        
        private void OnFireworkDesignChanged(PatternFirework firework, ProtoBuf.PatternFirework.Design design, BasePlayer player)
        {
            if (design?.stars != null && design.stars.Count != 0)
            {
                SendDiscordMessage(new FireworkUpdate(player, firework));
            }
        }
        
        private void OnCopyInfoToSign(SignContent content, ISignage sign, IUGCBrowserEntity browser)
        {
            BaseEntity entity = (BaseEntity)sign;
            BasePlayer player = BasePlayer.FindByID(entity.OwnerID);
            SignageUpdate update = new(player, sign, 0);
            SendDiscordMessage(update);
        }
        
        private object CanUpdateSign(BasePlayer player, BaseEntity entity)
        {
            if (!_pluginData.IsSignBanned(player))
            {
                return null;
            }
            
            PlaceholderData data = GetPlaceholderData();
            data.AddTimeSpan(_pluginData.GetRemainingBan(player));
            
            Chat(player, LangKeys.BlockedMessage, data);
            
            //Client side the sign will still be updated if we block it here. We destroy the entity client side to force a redraw of the image.
            NextTick(() =>
            {
                entity.DestroyOnClient(player.Connection);
                entity.SendNetworkUpdate();
            });
            
            return _false;
        }
        
        private object OnFireworkDesignChange(PatternFirework firework, ProtoBuf.PatternFirework.Design design, BasePlayer player)
        {
            if (!_pluginData.IsSignBanned(player))
            {
                return null;
            }
            
            PlaceholderData data = GetPlaceholderData();
            data.AddTimeSpan(_pluginData.GetRemainingBan(player));
            
            Chat(player, LangKeys.BlockedMessage, data);
            return _true;
        }
        
        private object OnPlayerCommand(BasePlayer player, string cmd, string[] args)
        {
            if (!cmd.StartsWith("sil", StringComparison.OrdinalIgnoreCase))
            {
                return null;
            }
            
            if (!_pluginData.IsSignBanned(player))
            {
                return null;
            }
            
            PlaceholderData data = GetPlaceholderData();
            data.AddTimeSpan(_pluginData.GetRemainingBan(player));
            
            Chat(player, LangKeys.BlockedMessage, data);
            return _true;
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnImagePost));
            Unsubscribe(nameof(OnSignUpdated));
            Unsubscribe(nameof(OnFireworkDesignChanged));
            Unsubscribe(nameof(CanUpdateSign));
            Unsubscribe(nameof(OnFireworkDesignChange));
            Unsubscribe(nameof(OnPlayerCommand));
            Unsubscribe(nameof(OnCopyInfoToSign));
        }
        
        private void SubscribeAll()
        {
            Subscribe(nameof(OnSignUpdated));
            Subscribe(nameof(OnFireworkDesignChanged));
            Subscribe(nameof(CanUpdateSign));
            Subscribe(nameof(OnFireworkDesignChange));
            Subscribe(nameof(OnCopyInfoToSign));
            
            if (SignArtist is { IsLoaded: true })
            {
                Subscribe(nameof(OnPlayerCommand));
                Subscribe(nameof(OnImagePost));
            }
        }
        #endregion

        #region Plugins\DiscordSignLogger.DiscordHooks.cs
        [HookMethod(DiscordExtHooks.OnDiscordGuildCreated)]
        private void OnDiscordGuildCreated(DiscordGuild guild)
        {
            bool subscribe = false;
            foreach (SignMessage message in _pluginConfig.SignMessages)
            {
                if (message.MessageChannel == null && message.ChannelId.IsValid())
                {
                    DiscordChannel channel = guild.GetChannel(message.ChannelId);
                    if (channel != null)
                    {
                        message.MessageChannel = channel;
                        subscribe = true;
                    }
                }
            }
            
            if (_pluginConfig.ActionLogChannel.IsValid())
            {
                DiscordChannel channel = guild.GetChannel(_pluginConfig.ActionLogChannel);
                if (channel != null)
                {
                    _actionChannel = channel;
                }
            }
            
            if (subscribe)
            {
                SubscribeAll();
                Puts($"{Title} Ready");
                RegisterApplicationCommands();
            }
        }
        #endregion

        #region Plugins\DiscordSignLogger.DiscordHelpers.cs
        public void RunCommand(DiscordInteraction interaction, SignUpdateState state, ImageButton button, string playerMessage, string serverMessage)
        {
            using PlaceholderData data = GetPlaceholderData(state, interaction)
            .AddGuild(Client, interaction.GuildId)
            .Add(PlaceholderDataKeys.PlayerMessage, playerMessage)
            .Add(PlaceholderDataKeys.ServerMessage, serverMessage);
            
            data.ManualPool();
            
            _sb.Clear();
            foreach (string buttonCommand in button.Commands)
            {
                string command = _placeholders.ProcessPlaceholders(buttonCommand, data);
                covalence.Server.Command(command);
                
                if (_actionChannel != null)
                {
                    _sb.AppendLine(command);
                }
            }
            
            if (_actionChannel != null)
            {
                string command = _sb.ToString();
                data.Add(PlaceholderDataKeys.Command, command);
                _actionChannel.CreateGlobalTemplateMessage(Client, TemplateKeys.Action.Message, null, data);
            }
            
            if (!string.IsNullOrEmpty(playerMessage))
            {
                BasePlayer player = state.Player.Object as BasePlayer;
                if (player != null && player.IsConnected)
                {
                    string message = _placeholders.ProcessPlaceholders(playerMessage, data);
                    Chat(player, message);
                }
            }
            
            if (!string.IsNullOrEmpty(serverMessage))
            {
                string message = _placeholders.ProcessPlaceholders(serverMessage, data);
                covalence.Server.Broadcast(message);
            }
            
            if (_pluginConfig.DisableDiscordButton)
            {
                DisableButton(interaction.Message, interaction.Data.CustomId);
            }
            
            interaction.CreateResponse(Client, new InteractionResponse
            {
                Type = InteractionResponseType.UpdateMessage,
                Data = new InteractionCallbackData
                {
                    Components = interaction.Message.Components
                }
            });
        }
        
        public void ShowConfirmationModal(DiscordInteraction interaction, SignUpdateState state, ImageButton button, TemplateKey messageId, ButtonId buttonId)
        {
            InteractionModalBuilder builder = new(interaction);
            builder.AddModalCustomId(BuildCustomId(ModalPrefix, messageId, buttonId, state.Serialize()));
            builder.AddModalTitle(button.DisplayName);
            builder.AddInputText(PlayerMessage, "Player Message", InputTextStyles.Paragraph, button.PlayerMessage, false);
            builder.AddInputText(ServerMessage, "Server Message", InputTextStyles.Paragraph, button.ServerMessage, false);
            interaction.CreateResponse(Client, builder);
        }
        
        public bool UserHasButtonPermission(DiscordInteraction interaction, ImageButton button)
        {
            for (int index = 0; index < button.AllowedRoles.Count; index++)
            {
                Snowflake role = button.AllowedRoles[index];
                if (interaction.Member.HasRole(role))
                {
                    return true;
                }
            }
            
            IPlayer player = interaction.Member.User.Player;
            if (player != null)
            {
                for (int index = 0; index < button.AllowedGroups.Count; index++)
                {
                    string group = button.AllowedGroups[index];
                    if (permission.UserHasGroup(player.Id, group))
                    {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        public bool TryParseCommand(string command, out TemplateKey messageId, out ButtonId buttonId, out SignUpdateState state)
        {
            messageId = default;
            buttonId = default;
            state = null;
            
            ReadOnlySpan<char> span = command.AsSpan();
            ReadOnlySpan<char> token = " ";
            
            //Command Prefix can be ignored
            if (!span.TryParseNextString(token, out span, out ReadOnlySpan<char> _)) return false;
            if (!span.TryParseNextString(token, out span, out ReadOnlySpan<char> messageIdString)) return false;
            if (!span.TryParseNextString(token, out span, out ReadOnlySpan<char> buttonIdString)) return false;
            if (!span.TryParseNextString(token, out span, out ReadOnlySpan<char> stateString)) return false;
            
            messageId = new TemplateKey(messageIdString.ToString());
            buttonId = new ButtonId(buttonIdString.ToString());
            state = SignUpdateState.Deserialize(stateString);
            return true;
        }
        
        public void DisableButton(DiscordMessage message, string id)
        {
            for (int index = 0; index < message.Components.Count; index++)
            {
                ActionRowComponent row = message.Components[index];
                for (int i = 0; i < row.Components.Count; i++)
                {
                    BaseComponent component = row.Components[i];
                    if (component is ButtonComponent button && button.CustomId == id)
                    {
                        button.Disabled = true;
                        return;
                    }
                }
            }
        }
        
        public void DisableAllButtons(DiscordMessage message)
        {
            for (int index = 0; index < message.Components.Count; index++)
            {
                ActionRowComponent row = message.Components[index];
                for (int i = 0; i < row.Components.Count; i++)
                {
                    BaseComponent component = row.Components[i];
                    if (component is ButtonComponent button)
                    {
                        button.Disabled = true;
                    }
                }
            }
        }
        
        public void SendErrorResponse(DiscordInteraction interaction, TemplateKey template, PlaceholderData data)
        {
            DisableAllButtons(interaction.Message);
            SendComponentUpdateResponse(interaction);
            SendFollowupResponse(interaction, template, data);
        }
        
        public void SendComponentUpdateResponse(DiscordInteraction interaction)
        {
            interaction.CreateResponse(Client, new InteractionResponse
            {
                Type = InteractionResponseType.UpdateMessage,
                Data = new InteractionCallbackData
                {
                    Components = interaction.Message.Components
                }
            });
        }
        
        public void SendTemplateResponse(DiscordInteraction interaction, TemplateKey templateName, PlaceholderData data)
        {
            interaction.CreateTemplateResponse(Client, InteractionResponseType.ChannelMessageWithSource, templateName, null, data);
        }
        
        public void SendFollowupResponse(DiscordInteraction interaction, TemplateKey templateName, PlaceholderData data)
        {
            interaction.CreateFollowUpTemplateResponse(Client, templateName, null, data);
        }
        
        public IEnumerable<IPlayer> GetBannedPlayers()
        {
            foreach (ulong key in _pluginData.SignBannedUsers.Keys)
            {
                IPlayer player = FindPlayerById(StringCache<ulong>.Instance.ToString(key));
                if (player != null)
                {
                    yield return player;
                }
            }
        }
        #endregion

        #region Plugins\DiscordSignLogger.DiscordMethods.cs
        public void SendDiscordMessage(BaseImageUpdate update)
        {
            SignUpdateState state = new(update);
            
            StateKey encodedState = state.Serialize();
            
            using PlaceholderData data = GetPlaceholderData(state);
            data.ManualPool();
            data.AddPlayer(state.Player)
            .Add(PlaceholderDataKeys.State, state)
            .Add(PlaceholderDataKeys.Owner, state.Owner)
            .Add(PlaceholderDataKeys.MessageState, encodedState);
            
            if (update is SignageUpdate signage)
            {
                data.Add(PlaceholderDataKeys.SignArtistUrl, signage.Url);
            }
            
            for (int index = 0; index < _pluginConfig.SignMessages.Count; index++)
            {
                SignMessage signMessage = _pluginConfig.SignMessages[index];
                DiscordMessageTemplate message = _templates.GetGlobalTemplate(this, signMessage.MessageId);
                MessageCreate create = message.ToMessage<MessageCreate>(data);
                data.Add(PlaceholderDataKeys.MessageId, signMessage.MessageId);
                
                create.AddAttachment("image.png", update.GetImage(), "image/png", $"{update.DisplayName} Updated {update.Entity.ShortPrefabName} @{update.Entity.transform.position} On {DateTime.Now:f}");
                
                if (signMessage.Buttons.Count != 0)
                {
                    if (signMessage.UseActionButton)
                    {
                        create.Components = new List<ActionRowComponent>
                        {
                            new()
                            {
                                Components = { _buttonTemplates.GetGlobalTemplate(this, TemplateKeys.Action.Button).ToComponent(data) }
                            }
                        };
                    }
                    else
                    {
                        create.Components = CreateButtons(signMessage, data, encodedState);
                    }
                }
                
                signMessage.MessageChannel?.CreateMessage(Client, create);
            }
        }
        
        private List<ActionRowComponent> CreateButtons(SignMessage signMessage, PlaceholderData data, StateKey encodedState)
        {
            MessageComponentBuilder builder = new();
            for (int i = 0; i < signMessage.Buttons.Count; i++)
            {
                ButtonId buttonId = signMessage.Buttons[i];
                ImageButton command = _imageButtons[buttonId];
                if (command.Commands.Count == 0)
                {
                    continue;
                }
                
                if (command.Style == ButtonStyle.Link)
                {
                    builder.AddLinkButton(command.DisplayName, _placeholders.ProcessPlaceholders(command.Commands[0], data));
                }
                else
                {
                    builder.AddActionButton(command.Style, command.DisplayName, BuildCustomId(CommandPrefix, signMessage.MessageId, buttonId, encodedState));
                }
            }
            
            return builder.Build();
        }
        
        private string BuildCustomId(string command, IDiscordKey messageId, ButtonId? buttonId, IDiscordKey encodedState)
        {
            return $"{command} {messageId.ToString()} {(buttonId.HasValue ? buttonId.Value.Id : "_")} {encodedState}";
        }
        #endregion

        #region Plugins\DiscordSignLogger.Commands.cs
        [ConsoleCommand("dsl.erase")]
        private void EraseCommand(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                return;
            }
            
            NetworkableId id = arg.GetEntityID(0);
            uint index = arg.GetUInt(1);
            BaseEntity entity = BaseNetworkable.serverEntities.Find(id) as BaseEntity;
            if (!entity)
            {
                return;
            }
            
            switch (entity)
            {
                case ISignage signage:
                {
                    uint[] textures = signage.GetTextureCRCs();
                    uint crc = textures[index];
                    if (crc != 0)
                    {
                        FileStorage.server.RemoveExact(crc, FileStorage.Type.png, signage.NetworkID, index);
                        textures[index] = 0;
                        entity.SendNetworkUpdate();
                        HandleReplaceImage(signage, index);
                    }
                    
                    break;
                }
                case PaintedItemStorageEntity item:
                {
                    if (item._currentImageCrc != 0)
                    {
                        FileStorage.server.RemoveExact(item._currentImageCrc, FileStorage.Type.png, item.net.ID, 0);
                        item._currentImageCrc = 0;
                        item.SendNetworkUpdate();
                    }
                    
                    break;
                }
                case PatternFirework firework:
                firework.Design?.Dispose();
                firework.Design = null;
                firework.SendNetworkUpdateImmediate();
                break;
            }
        }
        
        [ConsoleCommand("dsl.signblock")]
        private void BanCommand(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                return;
            }
            
            ulong playerId = arg.GetULong(0);
            float duration = arg.GetFloat(1);
            
            _pluginData.AddSignBan(playerId, duration);
            
            using PlaceholderData data = GetPlaceholderData();
            data.ManualPool();
            data.AddTimeSpan(TimeSpan.FromSeconds(duration));
            
            if (duration <= 0)
            {
                arg.ReplyWith($"{playerId} has been sign blocked permanently");
            }
            else
            {
                arg.ReplyWith(_placeholders.ProcessPlaceholders($"{playerId} has been sign blocked for {DefaultKeys.Timespan.Formatted}", data));
            }
            
            SaveData();
        }
        
        [ConsoleCommand("dsl.signunblock")]
        private void UnbanCommand(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                return;
            }
            
            ulong playerId = arg.GetULong(0);
            _pluginData.RemoveSignBan(playerId);
            SaveData();
            arg.ReplyWith($"{playerId} has been unbanned");
        }
        
        private void HandleReplaceImage(ISignage signage, uint index)
        {
            if (_pluginConfig.ReplaceImage.Mode == EraseMode.None || SignArtist is not { IsLoaded: true })
            {
                return;
            }
            
            ReplaceImageSettings image = _pluginConfig.ReplaceImage;
            if (signage is Signage)
            {
                if (image.Mode == EraseMode.Text)
                {
                    SignArtist.Call("API_SignText", null, signage, image.Message, image.FontSize, image.TextColor, image.BodyColor, index);
                }
                else if (!string.IsNullOrEmpty(image.Url))
                {
                    SignArtist.Call("API_SkinSign", null, signage, image.Url, _false, index);
                }
            }
            else if (signage is PhotoFrame)
            {
                if (!string.IsNullOrEmpty(image.Url))
                {
                    SignArtist.Call("API_SkinPhotoFrame", null, signage, image.Url);
                }
            }
            else if (signage is CarvablePumpkin)
            {
                if (!string.IsNullOrEmpty(image.Url))
                {
                    SignArtist.Call("API_SkinPumpkin", null, signage, image.Url);
                }
            }
        }
        #endregion

        #region Plugins\DiscordSignLogger.Helpers.cs
        public IPlayer FindPlayerById(string id) => covalence.Players.FindPlayerById(id);
        
        public void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _pluginData);
        
        public void Puts(string format) => base.Puts(format);
        #endregion

        #region Plugins\DiscordSignLogger.Lang.cs
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Chat] = $"<color=#bebebe>[<color={AccentColor}>{Title}</color>] {{0}}</color>",
                [LangKeys.NoPermission] = "You do not have permission to perform this action",
                [LangKeys.KickReason] = "Inappropriate sign/firework image",
                [LangKeys.BanReason] = "Inappropriate sign/firework image",
                [LangKeys.BlockedMessage] = $"You're not allowed to update this sign/firework because you have been blocked. Your block will expire in {DefaultKeys.Timespan.Formatted}.",
            }, this);
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Chat] = $"<color=#bebebe>[<color={AccentColor}>{Title}</color>] {{0}}</color>",
                [LangKeys.NoPermission] = "У вас нет разрешения на выполнение этого действия",
                [LangKeys.KickReason] = "Недопустимое изображение знака/фейерверка",
                [LangKeys.BanReason] = "Недопустимое изображение знака/фейерверка",
                [LangKeys.BlockedMessage] = $"Возможность использовать изображения на знаке/феерверке для вас заблокирована. Разблокировка через {DefaultKeys.Timespan.Formatted}.",
            }, this, "ru");
        }
        
        public string Lang(string key, BasePlayer player = null)
        {
            return lang.GetMessage(key, this, player ? player.UserIDString : null);
        }
        
        public string Lang(string key, BasePlayer player, PlaceholderData data)
        {
            return _placeholders.ProcessPlaceholders(Lang(key, player), data);
        }
        
        public string Lang(string key, BasePlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(Lang(key, player), args);
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception\n:{ex}");
                throw;
            }
        }
        
        public void Chat(BasePlayer player, string key) => PrintToChat(player, Lang(LangKeys.Chat, player, Lang(key, player)));
        public void Chat(BasePlayer player, string key, PlaceholderData data) => PrintToChat(player, Lang(LangKeys.Chat, player, Lang(key, player, data)));
        #endregion

        #region Plugins\DiscordSignLogger.Placeholders.cs
        public void RegisterPlaceholders()
        {
            _placeholders.RegisterPlaceholder<SignUpdateState, ulong>(this, PlaceholderKeys.EntityId, PlaceholderDataKeys.State, state => state.EntityId);
            _placeholders.RegisterPlaceholder<SignUpdateState, string>(this, PlaceholderKeys.EntityName, PlaceholderDataKeys.State, state => GetEntityName(state.Entity));
            _placeholders.RegisterPlaceholder<SignUpdateState, string>(this, PlaceholderKeys.ItemName, PlaceholderDataKeys.State, state => GetItemName(state.ItemId));
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.PlayerMessage, PlaceholderDataKeys.PlayerMessage);
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.ServerMessage, PlaceholderDataKeys.ServerMessage);
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.SignArtistUrl, PlaceholderDataKeys.SignArtistUrl);
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.Command, PlaceholderDataKeys.Command);
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.ButtonId, PlaceholderDataKeys.ButtonId);
            _placeholders.RegisterPlaceholder<string>(this, PlaceholderKeys.PlayerId, PlaceholderDataKeys.PlayerId);
            _placeholders.RegisterPlaceholder<SignUpdateState, bool>(this, PlaceholderKeys.IsOutside, PlaceholderDataKeys.State, state => state.Entity && state.Entity.IsOutside());
            _placeholders.RegisterPlaceholder<TemplateKey>(this, PlaceholderKeys.MessageId, PlaceholderDataKeys.MessageId);
            _placeholders.RegisterPlaceholder<StateKey, string>(this, PlaceholderKeys.MessageState, PlaceholderDataKeys.MessageState, state => state.State);
            _placeholders.RegisterPlaceholder<SignUpdateState, string>(this, PlaceholderKeys.TextureIndex, PlaceholderDataKeys.State, state =>
            {
                if (state.Entity is ISignage signage && signage.GetTextureCRCs().Length <= 1)
                {
                    return null;
                }
                
                return StringCache<byte>.Instance.ToString(state.TextureIndex);
            });
            _placeholders.RegisterPlaceholder<SignUpdateState, GenericPosition>(this, PlaceholderKeys.Position, PlaceholderDataKeys.State, state =>
            {
                BaseEntity entity = state.Entity;
                Vector3 pos = entity ? entity.transform.position : Vector3.zero;
                return new GenericPosition(pos.x, pos.y, pos.z);
            });
            
            PlayerPlaceholders.RegisterPlaceholders(this, PlaceholderKeys.OwnerKeys, PlaceholderDataKeys.Owner);
        }
        
        public PlaceholderData GetPlaceholderData(SignUpdateState state, DiscordInteraction interaction) => GetPlaceholderData(state).AddInteraction(interaction);
        
        public PlaceholderData GetPlaceholderData(SignUpdateState state)
        {
            return GetPlaceholderData()
            .AddPlayer(state.Player)
            .Add(PlaceholderDataKeys.State, state)
            .Add(PlaceholderDataKeys.Owner, state.Owner);
        }
        
        public PlaceholderData GetPlaceholderData(DiscordInteraction interaction) => GetPlaceholderData().AddInteraction(interaction);
        
        public PlaceholderData GetPlaceholderData()
        {
            return _placeholders.CreateData(this);
        }
        #endregion

        #region Plugins\DiscordSignLogger.Templates.cs
        public void RegisterTemplates()
        {
            HashSet<string> messages = new();
            foreach (SignMessage message in _pluginConfig.SignMessages)
            {
                if (messages.Add(message.MessageId.Name))
                {
                    _templates.RegisterGlobalTemplateAsync(this, message.MessageId, CreateDefaultTemplate(),
                    new TemplateVersion(1, 0, 2), new TemplateVersion(1, 0, 2));
                }
                else
                {
                    PrintWarning($"Duplicate Message ID: '{message.MessageId.Name}'. Please check your config and correct the duplicate Sign Message ID's");
                }
            }
            
            _templates.RegisterGlobalTemplateAsync(this, TemplateKeys.Action.Message, CreateActionMessage($"{DefaultKeys.User.Mention} ran command \"{PlaceholderKeys.Command}\"", DiscordColor.Blurple), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            _buttonTemplates.RegisterGlobalTemplateAsync(this, TemplateKeys.Action.Button, new ButtonTemplate("Actions", ButtonStyle.Primary, BuildCustomId(ActionPrefix, PlaceholderKeys.MessageId, null, PlaceholderKeys.MessageState)), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            RegisterEn();
            RegisterRu();
        }
        
        public void RegisterEn()
        {
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.NoPermission, CreateMessage("You do not have permission to perform this action", DiscordColor.Danger), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.FailedToParse, CreateMessage("An error occurred parsing button data", DiscordColor.Danger), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.ButtonIdNotFound, CreateMessage($"Failed to find button with id: {PlaceholderKeys.ButtonId}. Please validate the button exists in the config.", DiscordColor.Danger), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Block.Success, CreateMessage($"{DefaultKeys.Player.Name} ({DefaultKeys.Player.Id}) has been sign blocked for {DefaultKeys.Timespan.Formatted}.", DiscordColor.Success), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Block.Errors.PlayerNotFound, CreateMessage($"Failed to find player with id: {PlaceholderKeys.PlayerId}", DiscordColor.Danger), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Block.Errors.IsAlreadyBanned, CreateMessage($"{DefaultKeys.Player.Name} ({DefaultKeys.Player.Id}) is already banned", DiscordColor.Danger), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Unblock.Success, CreateMessage($"You have removed {DefaultKeys.Player.Name} ({DefaultKeys.Player.Id}) sign block.", DiscordColor.Success), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Unblock.Errors.PlayerNotFound, CreateMessage($"Failed to find player with id: {PlaceholderKeys.PlayerId}", DiscordColor.Danger), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Commands.Unblock.Errors.NotBanned, CreateMessage($"{DefaultKeys.Player.Name} ({DefaultKeys.Player.Id}) is not sign blocked.", DiscordColor.Danger), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0));
        }
        
        public void RegisterRu()
        {
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.NoPermission, CreateMessage("У вас нет разрешения на выполнение этого действия", DiscordColor.Danger), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0), "ru");
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.FailedToParse, CreateMessage("Произошла ошибка при анализе данных кнопки.", DiscordColor.Danger), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0), "ru");
            _templates.RegisterLocalizedTemplateAsync(this, TemplateKeys.Errors.ButtonIdNotFound, CreateMessage($"Не удалось найти кнопку с идентификатором: {PlaceholderKeys.ButtonId}. Пожалуйста, проверьте наличие кнопки в файле конфигурации.", DiscordColor.Danger), new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0), "ru");
        }
        
        public DiscordMessageTemplate CreateMessage(string description, DiscordColor color)
        {
            return new DiscordMessageTemplate
            {
                Embeds = new List<DiscordEmbedTemplate>
                {
                    CreateEmbedTemplate(description, color)
                }
            };
        }
        
        public DiscordMessageTemplate CreateActionMessage(string description, DiscordColor color)
        {
            return new DiscordMessageTemplate
            {
                Embeds = new List<DiscordEmbedTemplate>
                {
                    CreateEmbedTemplate(description, color)
                },
                Components = new List<BaseComponentTemplate>
                {
                    new ButtonTemplate("Image Message", ButtonStyle.Link, "discord://-/channels/{guild.id}/{channel.id}/{message.id}")
                }
            };
        }
        
        public DiscordEmbedTemplate CreateEmbedTemplate(string description, DiscordColor color)
        {
            return new()
            {
                Description = $"[{Title}] {description}",
                Color = color.ToHex(),
                Footer = GetFooterTemplate()
            };
        }
        
        public DiscordMessageTemplate CreateDefaultTemplate()
        {
            return new DiscordMessageTemplate
            {
                Embeds = new List<DiscordEmbedTemplate>
                {
                    new()
                    {
                        Title = $"{DefaultKeys.Server.Name}",
                        Color = "#AC7061",
                        ImageUrl = "attachment://image.png",
                        TimeStamp = true,
                        Fields = new List<DiscordEmbedFieldTemplate>
                        {
                            new()
                            {
                                Name = "Player:",
                                Value = $"{DefaultKeys.Player.Name} ([{DefaultKeys.Player.Id}]({DefaultKeys.Player.SteamProfile}))",
                                Inline = true
                            },
                            new()
                            {
                                Name = "Owner:",
                                Value = $"{PlaceholderKeys.OwnerKeys.Name} ([{PlaceholderKeys.OwnerKeys.Id}]({PlaceholderKeys.OwnerKeys.SteamProfile}))",
                                Inline = true
                            },
                            new()
                            {
                                Name = "Position:",
                                Value = $"{PlaceholderKeys.Position}",
                                Inline = true
                            },
                            new()
                            {
                                Name = "Item:",
                                Value = $"{PlaceholderKeys.EntityName}",
                                Inline = true
                            },
                            new()
                            {
                                Name = "Is Outside:",
                                Value = $"{PlaceholderKeys.IsOutside}",
                                Inline = true
                            },
                            new()
                            {
                                Name = "Texture Index",
                                Value = $"{PlaceholderKeys.TextureIndex}",
                                Inline = true,
                                HideIfEmpty = true
                            },
                            new()
                            {
                                Name = "Sign Artist URL",
                                Value = $"{PlaceholderKeys.SignArtistUrl}",
                                Inline = true,
                                HideIfEmpty = true
                            }
                        },
                        Footer = GetFooterTemplate()
                    }
                }
            };
        }
        
        public EmbedFooterTemplate GetFooterTemplate()
        {
            return new EmbedFooterTemplate
            {
                Enabled = true,
                Text = $"{DefaultKeys.Plugin.Name} V{DefaultKeys.Plugin.Version} by {DefaultKeys.Plugin.Author}",
                IconUrl = "https://assets.umod.org/images/icons/plugin/61f1b7f6da7b6.png"
            };
        }
        #endregion

        #region Plugins\DiscordSignLogger.RustTranslationApi.cs
        public string GetEntityName(BaseEntity entity)
        {
            if (!entity.IsValid())
            {
                return string.Empty;
            }
            
            if (_prefabNameCache.TryGetValue(entity.prefabID, out string name))
            {
                return name;
            }
            
            if (RustTranslationAPI is { IsLoaded: true })
            {
                name = RustTranslationAPI.Call<string>("GetDeployableTranslation", lang.GetServerLanguage(), entity.ShortPrefabName);
                if (!string.IsNullOrEmpty(name))
                {
                    _prefabNameCache[entity.prefabID] = name;
                    return name;
                }
            }
            
            _prefabNameCache[entity.prefabID] = entity.ShortPrefabName;
            return entity.ShortPrefabName;
        }
        
        public string GetItemName(int itemId)
        {
            if (itemId == 0)
            {
                return string.Empty;
            }
            
            if (_itemNameCache.TryGetValue(itemId, out string name))
            {
                return name;
            }
            
            if (RustTranslationAPI is { IsLoaded: true })
            {
                name = RustTranslationAPI.Call<string>("GetItemTranslationByID", lang.GetServerLanguage(), itemId);
                if (!string.IsNullOrEmpty(name))
                {
                    _itemNameCache[itemId] = name;
                    return name;
                }
            }
            
            name = ItemManager.FindItemDefinition(itemId).displayName.translated;
            _itemNameCache[itemId] = name;
            return name;
        }
        #endregion

        #region Plugins\DiscordSignLogger.AppCommands.cs
        public void RegisterApplicationCommands()
        {
            ApplicationCommandBuilder builder = new ApplicationCommandBuilder(AppCommand.Command, "Discord Sign Logger Commands", ApplicationCommandType.ChatInput)
            .AddDefaultPermissions(PermissionFlags.None);
            
            AddBlockCommand(builder);
            AddUnblockCommand(builder);
            
            CommandCreate build = builder.Build();
            DiscordCommandLocalization localization = builder.BuildCommandLocalization();
            
            TemplateKey template = new("Command");
            _local.RegisterCommandLocalizationAsync(this, template, localization, new TemplateVersion(1, 0, 0), new TemplateVersion(1, 0, 0)).Then(_ =>
            {
                _local.ApplyCommandLocalizationsAsync(this, build, template).Then(() =>
                {
                    Client.Bot.Application.CreateGlobalCommand(Client, build);
                });
            });
        }
        
        public void AddBlockCommand(ApplicationCommandBuilder builder)
        {
            builder.AddSubCommand(AppCommand.Block, "Block a player from painting on signs", cmd =>
            {
                cmd.AddOption(CommandOptionType.String, AppArgs.Player, "Player to block",
                options => options.Required().AutoComplete())
                .AddOption(CommandOptionType.Integer, AppArgs.Duration, "Block duration (Seconds)", options =>
                options.Required()
                .AddChoice("1 Hour", 60 * 60)
                .AddChoice("12 Hours", 60 * 60 * 12)
                .AddChoice("1 Day", 60 * 60 * 24)
                .AddChoice("3 Days", 60 * 60 * 24 * 3)
                .AddChoice("1 Week", 60 * 60 * 24 * 7)
                .AddChoice("2 Weeks", 60 * 60 * 24 * 7 * 2)
                .AddChoice("1 Month", 60 * 60 * 24 * 31)
                .AddChoice("Forever", -1));
            });
        }
        
        public void AddUnblockCommand(ApplicationCommandBuilder builder)
        {
            builder.AddSubCommand(AppCommand.Unblock, "Unblock a sign blocked player", cmd =>
            {
                cmd.AddOption(CommandOptionType.String, AppArgs.Player, "Player to unblock",
                options => options.Required().AutoComplete());
            });
        }
        
        
        [DiscordAutoCompleteCommand(AppCommand.Command, AppArgs.Player, AppCommand.Block)]
        private void DiscordBlockAutoComplete(DiscordInteraction interaction, InteractionDataOption focused)
        {
            string search = focused.GetString();
            InteractionAutoCompleteBuilder response = interaction.GetAutoCompleteBuilder();
            response.AddAllOnlineFirstPlayers(search, PlayerNameFormatter.All);
            interaction.CreateResponse(Client, response);
        }
        
        [DiscordAutoCompleteCommand(AppCommand.Command, AppArgs.Player, AppCommand.Unblock)]
        private void DiscordUnblockAutoComplete(DiscordInteraction interaction, InteractionDataOption focused)
        {
            string search = focused.GetString();
            InteractionAutoCompleteBuilder response = interaction.GetAutoCompleteBuilder();
            response.AddPlayerList(search, GetBannedPlayers(), PlayerNameFormatter.All);
            interaction.CreateResponse(Client, response);
        }
        
        [DiscordApplicationCommand(AppCommand.Command, AppCommand.Block)]
        private void DiscordBlockCommand(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            string playerId = parsed.Args.GetString(AppArgs.Player);
            IPlayer player = FindPlayerById(playerId);
            PlaceholderData data = GetPlaceholderData(interaction);
            if (player == null)
            {
                data.Add(PlaceholderDataKeys.PlayerId, playerId);
                SendTemplateResponse(interaction, TemplateKeys.Commands.Block.Errors.PlayerNotFound, data);
                return;
            }
            
            data.AddPlayer(player);
            
            if (_pluginData.IsSignBanned(playerId))
            {
                SendTemplateResponse(interaction, TemplateKeys.Commands.Block.Errors.IsAlreadyBanned, data);
                return;
            }
            
            int duration = parsed.Args.GetInt(AppArgs.Duration);
            _pluginData.AddSignBan(ulong.Parse(playerId), duration);
            data.AddTimeSpan(TimeSpan.FromSeconds(duration));
            
            SendTemplateResponse(interaction, TemplateKeys.Commands.Block.Success, data);
        }
        
        [DiscordApplicationCommand(AppCommand.Command, AppCommand.Unblock)]
        private void DiscordUnblockCommand(DiscordInteraction interaction, InteractionDataParsed parsed)
        {
            string playerId = parsed.Args.GetString(AppArgs.Player);
            IPlayer player = FindPlayerById(playerId);
            PlaceholderData data = GetPlaceholderData(interaction);
            if (player == null)
            {
                data.Add(PlaceholderDataKeys.PlayerId, playerId);
                SendTemplateResponse(interaction, TemplateKeys.Commands.Unblock.Errors.PlayerNotFound, data);
                return;
            }
            
            data.AddPlayer(player);
            
            if (!_pluginData.IsSignBanned(playerId))
            {
                SendTemplateResponse(interaction, TemplateKeys.Commands.Unblock.Errors.NotBanned, data);
                return;
            }
            
            _pluginData.RemoveSignBan(ulong.Parse(playerId));
            SendTemplateResponse(interaction, TemplateKeys.Commands.Unblock.Success, data);
        }
        #endregion

        #region Plugins\DiscordSignLogger.DiscordInteractions.cs
        [DiscordMessageComponentCommand(CommandPrefix)]
        private void DiscordSignLoggerCommand(DiscordInteraction interaction)
        {
            if (!TryParseCommand(interaction.Data.CustomId, out TemplateKey messageId, out ButtonId buttonId, out SignUpdateState state))
            {
 