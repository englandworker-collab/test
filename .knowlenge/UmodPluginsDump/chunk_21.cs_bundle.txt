               SendErrorResponse(interaction, TemplateKeys.Errors.FailedToParse, GetPlaceholderData());
                return;
            }
            
            ImageButton button = _imageButtons[buttonId];
            if (button == null)
            {
                SendErrorResponse(interaction, TemplateKeys.Errors.ButtonIdNotFound, GetPlaceholderData().Add(PlaceholderDataKeys.ButtonId, buttonId.Id));
                return;
            }
            
            if (button.RequirePermissions && !UserHasButtonPermission(interaction, button))
            {
                SendTemplateResponse(interaction, TemplateKeys.NoPermission, GetPlaceholderData());
                return;
            }
            
            if (button.ConfirmModal)
            {
                ShowConfirmationModal(interaction, state, button, messageId, buttonId);
                return;
            }
            
            RunCommand(interaction, state, button, button.PlayerMessage, button.ServerMessage);
        }
        
        [DiscordMessageComponentCommand(ActionPrefix)]
        private void DiscordSignLoggerAction(DiscordInteraction interaction)
        {
            if (!TryParseCommand(interaction.Data.CustomId, out TemplateKey messageId, out ButtonId buttonId, out SignUpdateState state))
            {
                SendErrorResponse(interaction, TemplateKeys.Errors.FailedToParse, GetPlaceholderData());
                return;
            }
            
            SignMessage message = _signMessages[messageId];
            interaction.CreateResponse(Client, InteractionResponseType.UpdateMessage, new InteractionCallbackData
            {
                Components = CreateButtons(message, GetPlaceholderData(state, interaction), state.Serialize())
            });
        }
        
        [DiscordModalSubmit(ModalPrefix)]
        private void DiscordSignLoggerModal(DiscordInteraction interaction)
        {
            if (!TryParseCommand(interaction.Data.CustomId, out TemplateKey messageId, out ButtonId buttonId, out SignUpdateState state))
            {
                SendErrorResponse(interaction, TemplateKeys.Errors.FailedToParse, GetPlaceholderData());
                return;
            }
            
            ImageButton button = _imageButtons[buttonId];
            if (button == null)
            {
                SendErrorResponse(interaction, TemplateKeys.Errors.ButtonIdNotFound, GetPlaceholderData().Add(PlaceholderDataKeys.ButtonId, buttonId.Id));
                return;
            }
            
            string playerMessage = interaction.Data.GetComponent<InputTextComponent>(PlayerMessage).Value;
            string serverMessage = interaction.Data.GetComponent<InputTextComponent>(ServerMessage).Value;
            
            RunCommand(interaction, state, button, playerMessage, serverMessage);
        }
        #endregion

        #region AppCommands\AppArgs.cs
        public class AppArgs
        {
            public const string Player = "player";
            public const string Duration = "duration";
        }
        #endregion

        #region AppCommands\AppCommand.cs
        public class AppCommand
        {
            public const string Command = "dsl";
            public const string Block = "block";
            public const string Unblock = "unblock";
        }
        #endregion

        #region Configuration\FireworkSettings.cs
        public class FireworkSettings
        {
            [JsonProperty(PropertyName = "Image Size (Pixels)")]
            public int ImageSize { get; set; }
            
            [JsonProperty(PropertyName = "Circle Size (Pixels)")]
            public int CircleSize { get; set; }
            
            [JsonConstructor]
            private FireworkSettings() { }
            
            public FireworkSettings(FireworkSettings settings)
            {
                ImageSize = settings?.ImageSize ?? 250;
                CircleSize = settings?.CircleSize ?? 19;
            }
        }
        #endregion

        #region Configuration\ImageButton.cs
        public class ImageButton
        {
            [JsonProperty(PropertyName = "Button ID")]
            public ButtonId ButtonId { get; set; }
            
            [JsonProperty(PropertyName = "Button Display Name")]
            public string DisplayName { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Button Style")]
            public ButtonStyle Style { get; set; }
            
            [JsonProperty(PropertyName = "Commands")]
            public List<string> Commands { get; set; }
            
            [JsonProperty(PropertyName = "Player Message")]
            public string PlayerMessage { get; set; }
            
            [JsonProperty(PropertyName = "Server Message")]
            public string ServerMessage { get; set; }
            
            [JsonProperty(PropertyName = "Show Confirmation Modal")]
            public bool ConfirmModal { get; set; }
            
            [JsonProperty(PropertyName = "Requires Permissions To Use Button")]
            public bool RequirePermissions { get; set; }
            
            [JsonProperty(PropertyName = "Allowed Discord Roles (Role ID)")]
            public List<Snowflake> AllowedRoles { get; set; }
            
            [JsonProperty(PropertyName = "Allowed Oxide Groups (Group Name)")]
            public List<string> AllowedGroups { get; set; }
            
            [JsonConstructor]
            public ImageButton() { }
            
            public ImageButton(ImageButton settings)
            {
                ButtonId = settings.ButtonId;
                DisplayName = settings.DisplayName ?? "Button Display Name";
                Style = settings.Style;
                Commands = settings.Commands ?? new List<string>();
                PlayerMessage = settings.PlayerMessage ?? string.Empty;
                ServerMessage = settings.ServerMessage ?? string.Empty;
                ConfirmModal = settings.ConfirmModal;
                RequirePermissions = settings.RequirePermissions;
                AllowedRoles = settings.AllowedRoles ?? new List<Snowflake>();
                AllowedGroups = settings.AllowedGroups ?? new List<string>();
            }
        }
        #endregion

        #region Configuration\PluginConfig.cs
        public class PluginConfig
        {
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string DiscordApiKey { get; set; }
            
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Disable Discord Button After Use")]
            public bool DisableDiscordButton { get; set; }
            
            [JsonProperty(PropertyName = "Action Log Channel ID")]
            public Snowflake ActionLogChannel { get; set; }
            
            [JsonProperty(PropertyName = "Replace Erased Image (Requires SignArtist)")]
            public ReplaceImageSettings ReplaceImage { get; set; }
            
            [JsonProperty(PropertyName = "Firework Settings")]
            public FireworkSettings FireworkSettings { get; set; }
            
            [JsonProperty(PropertyName = "Sign Messages")]
            public List<SignMessage> SignMessages { get; set; }
            
            [JsonProperty(PropertyName = "Buttons")]
            public List<ImageButton> Buttons { get; set; }
            
            public PluginSettings PluginSettings { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; } = DiscordLogLevel.Info;
        }
        #endregion

        #region Configuration\ReplaceImageSettings.cs
        public class ReplaceImageSettings
        {
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Replaced Mode (None, Url, Text)")]
            public EraseMode Mode { get; set; }
            
            [JsonProperty(PropertyName = "URL")]
            public string Url { get; set; }
            
            [JsonProperty(PropertyName = "Message")]
            public string Message { get; set; }
            
            [JsonProperty(PropertyName = "Font Size")]
            public int FontSize { get; set; }
            
            [JsonProperty(PropertyName = "Text Color")]
            public string TextColor { get; set; }
            
            [JsonProperty(PropertyName = "Body Color")]
            public string BodyColor { get; set; }
            
            [JsonConstructor]
            private ReplaceImageSettings() { }
            
            public ReplaceImageSettings(ReplaceImageSettings settings)
            {
                Mode = settings?.Mode ?? EraseMode.Url;
                Url = settings?.Url ?? "https://i.postimg.cc/mD5xZ5R5/Erased-4.png";
                Message = settings?.Message ?? "ERASED BY ADMIN";
                FontSize = settings?.FontSize ?? 16;
                TextColor = settings?.TextColor ?? "#cd4632";
                BodyColor = settings?.BodyColor ?? "#000000";
            }
            
            private bool ShouldSerializeUrl() => Mode == EraseMode.Url;
            private bool ShouldSerializeMessage() => Mode == EraseMode.Text;
            private bool ShouldSerializeFontSize() => Mode == EraseMode.Text;
            private bool ShouldSerializeTextColor() => Mode == EraseMode.Text;
            private bool ShouldSerializeBodyColor() => Mode == EraseMode.Text;
        }
        #endregion

        #region Configuration\SignMessage.cs
        public class SignMessage
        {
            [JsonProperty("Message ID")]
            public TemplateKey MessageId { get; set; }
            
            [JsonProperty("Discord Channel ID")]
            public Snowflake ChannelId { get; set; }
            
            [JsonProperty("Use Action Button")]
            public bool UseActionButton { get; set; } = true;
            
            [JsonProperty("Buttons")]
            public List<ButtonId> Buttons { get; set; }
            
            [JsonIgnore]
            public DiscordChannel MessageChannel;
            
            [JsonConstructor]
            private SignMessage() { }
            
            public SignMessage(SignMessage settings)
            {
                MessageId = settings?.MessageId ?? new TemplateKey("DEFAULT");
                if (!MessageId.IsValid)
                {
                    MessageId = new TemplateKey("DEFAULT");
                }
                ChannelId = settings?.ChannelId ?? default(Snowflake);
                UseActionButton = settings?.UseActionButton ?? true;
                Buttons = settings?.Buttons ?? new List<ButtonId>
                {
                    new("ERASE"),
                    new("SIGN_BLOCK_24_HOURS"),
                    new("KILL_ENTITY"),
                    new("KICK_PLAYER"),
                    new("BAN_PLAYER"),
                };
            }
        }
        #endregion

        #region Data\PluginData.cs
        public class PluginData
        {
            public Hash<ulong, DateTime> SignBannedUsers = new();
            
            public void AddSignBan(ulong player, float duration)
            {
                SignBannedUsers[player] = duration <= 0 ? DateTime.MaxValue : DateTime.UtcNow + TimeSpan.FromSeconds(duration);
            }
            
            public void RemoveSignBan(ulong player)
            {
                SignBannedUsers.Remove(player);
            }
            
            public bool IsSignBanned(BasePlayer player) => IsSignBanned(player.userID);
            public bool IsSignBanned(string playerId) => IsSignBanned(ulong.Parse(playerId));
            
            public bool IsSignBanned(ulong playerId)
            {
                if (!SignBannedUsers.ContainsKey(playerId))
                {
                    return false;
                }
                
                DateTime bannedUntil = SignBannedUsers[playerId];
                if (bannedUntil < DateTime.UtcNow)
                {
                    SignBannedUsers.Remove(playerId);
                    return false;
                }
                
                return true;
            }
            
            public TimeSpan GetRemainingBan(BasePlayer player)
            {
                return SignBannedUsers[player.userID] - DateTime.UtcNow;
            }
        }
        #endregion

        #region Enums\EraseMode.cs
        public enum EraseMode
        {
            None,
            Url,
            Text
        }
        #endregion

        #region Ids\ButtonId.cs
        [JsonConverter(typeof(ButtonIdConverter))]
        public readonly struct ButtonId : IEquatable<ButtonId>
        {
            public readonly string Id;
            
            public ButtonId(string id)
            {
                Id = id;
            }
            
            public bool Equals(ButtonId other) => Id == other.Id;
            
            public override bool Equals(object obj) => obj is ButtonId other && Equals(other);
            
            public override int GetHashCode() => Id != null ? Id.GetHashCode() : 0;
        }
        #endregion

        #region Ids\StateKey.cs
        public readonly struct StateKey : IDiscordKey
        {
            public readonly string State;
            
            public StateKey(string state)
            {
                State = state;
            }
            
            public override string ToString() => State;
        }
        #endregion

        #region Interfaces\ILogEvent.cs
        public interface ILogEvent
        {
            IPlayer Player { get; }
            BaseEntity Entity { get; }
            int ItemId { get; }
            byte TextureIndex { get; }
        }
        #endregion

        #region Json\ButtonIdConverter.cs
        public class ButtonIdConverter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                ButtonId id = (ButtonId)value;
                writer.WriteValue(id.Id);
            }
            
            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    return new ButtonId(reader.Value.ToString());
                }
                
                throw new JsonException($"Unexpected token {reader.TokenType} when parsing ButtonID.");
            }
            
            public override bool CanConvert(Type objectType)
            {
                return typeof(ButtonId) == objectType;
            }
        }
        #endregion

        #region Lang\LangKeys.cs
        public static class LangKeys
        {
            public const string Chat = nameof(Chat);
            public const string NoPermission = nameof(NoPermission);
            public const string KickReason = nameof(KickReason);
            public const string BanReason = nameof(BanReason);
            public const string BlockedMessage = nameof(BlockedMessage);
        }
        #endregion

        #region Placeholders\PlaceholderDataKeys.cs
        public class PlaceholderDataKeys
        {
            public static readonly PlaceholderDataKey Owner = new("owner");
            public static readonly PlaceholderDataKey State = new("state");
            public static readonly PlaceholderDataKey PlayerMessage = new("message.player");
            public static readonly PlaceholderDataKey ServerMessage = new("message.server");
            public static readonly PlaceholderDataKey SignArtistUrl = new("signartist.url");
            public static readonly PlaceholderDataKey Command = new("command");
            public static readonly PlaceholderDataKey ButtonId = new("buttonid");
            public static readonly PlaceholderDataKey MessageId = new("message.id");
            public static readonly PlaceholderDataKey MessageState = new("message.staate");
            public static readonly PlaceholderDataKey PlayerId = new("playerid");
        }
        #endregion

        #region Placeholders\PlaceholderKeys.cs
        public class PlaceholderKeys
        {
            public static readonly PlaceholderKey EntityId = new(nameof(DiscordSignLogger), "entity.id");
            public static readonly PlaceholderKey EntityName = new(nameof(DiscordSignLogger), "entity.name");
            public static readonly PlaceholderKey TextureIndex = new(nameof(DiscordSignLogger), "entity.textureindex");
            public static readonly PlaceholderKey Position = new(nameof(DiscordSignLogger), "entity.position");
            public static readonly PlaceholderKey ItemName = new(nameof(DiscordSignLogger), "item.name");
            public static readonly PlaceholderKey PlayerMessage = new(nameof(DiscordSignLogger), "message.player");
            public static readonly PlaceholderKey ServerMessage = new(nameof(DiscordSignLogger), "message.server");
            public static readonly PlaceholderKey SignArtistUrl = new(nameof(DiscordSignLogger), "signartist.url");
            public static readonly PlaceholderKey Command = new(nameof(DiscordSignLogger), "command");
            public static readonly PlaceholderKey ButtonId = new(nameof(DiscordSignLogger), "error.buttonid");
            public static readonly PlaceholderKey MessageId = new(nameof(DiscordSignLogger), "message.id");
            public static readonly PlaceholderKey MessageState = new(nameof(DiscordSignLogger), "message.state");
            public static readonly PlaceholderKey PlayerId = new(nameof(DiscordSignLogger), "player.id");
            public static readonly PlaceholderKey IsOutside = new(nameof(DiscordSignLogger), "entity.isoutside");
            
            public static readonly PlayerKeys OwnerKeys = new($"{nameof(DiscordSignLogger)}.owner");
            
        }
        #endregion

        #region State\SignUpdateState.cs
        [ProtoContract]
        public class SignUpdateState
        {
            [ProtoMember(1)]
            public ulong PlayerId { get; set; }
            
            [ProtoMember(2)]
            public ulong EntityId { get; set; }
            
            [ProtoMember(3)]
            public byte TextureIndex { get; set; }
            
            [ProtoMember(4)]
            public int ItemId { get; set; }
            
            private IPlayer _player;
            public IPlayer Player => _player ??= DiscordSignLogger.Instance.FindPlayerById(PlayerId.ToString());
            
            private IPlayer _owner;
            public IPlayer Owner => _owner ??= DiscordSignLogger.Instance.FindPlayerById(Entity.IsValid() ? Entity.OwnerID.ToString() : "0");
            
            private BaseEntity _entity;
            public BaseEntity Entity => _entity ??= BaseNetworkable.serverEntities.Find(new NetworkableId(EntityId)) as BaseEntity;
            
            public SignUpdateState() { }
            
            public SignUpdateState(BaseImageUpdate update)
            {
                PlayerId = update.PlayerId;
                EntityId = update.Entity.net.ID.Value;
                
                if (update.SupportsTextureIndex)
                {
                    TextureIndex = update.TextureIndex;
                }
                
                if (update is PaintedItemUpdate itemUpdate)
                {
                    ItemId = itemUpdate.ItemId;
                }
            }
            
            public StateKey Serialize()
            {
                MemoryStream stream = DiscordSignLogger.Instance.Pool.GetMemoryStream();
                Serializer.Serialize(stream, this);
                stream.TryGetBuffer(out ArraySegment<byte> buffer);
                string base64 = Convert.ToBase64String(buffer.AsSpan());
                DiscordSignLogger.Instance.Pool.FreeMemoryStream(stream);
                return new StateKey(base64);
            }
            
            public static SignUpdateState Deserialize(ReadOnlySpan<char> base64)
            {
                Span<byte> buffer = stackalloc byte[64];
                Convert.TryFromBase64Chars(base64, buffer, out int written);
                MemoryStream stream = DiscordSignLogger.Instance.Pool.GetMemoryStream();
                stream.Write(buffer[..written]);
                stream.Flush();
                stream.Position = 0;
                SignUpdateState state = Serializer.Deserialize<SignUpdateState>(stream);
                DiscordSignLogger.Instance.Pool.FreeMemoryStream(stream);
                return state;
            }
        }
        #endregion

        #region Templates\TemplateKeys.cs
        public class TemplateKeys
        {
            public static readonly TemplateKey NoPermission = new(nameof(NoPermission));
            
            public static class Action
            {
                private const string Base = nameof(Action) + ".";
                
                public static readonly TemplateKey Message = new(Base + nameof(Message));
                public static readonly TemplateKey Button = new(Base + nameof(Button));
            }
            
            public static class Errors
            {
                private const string Base = nameof(Errors) + ".";
                
                public static readonly TemplateKey FailedToParse = new(Base + nameof(FailedToParse));
                public static readonly TemplateKey ButtonIdNotFound = new(Base + nameof(ButtonIdNotFound));
            }
            
            public static class Commands
            {
                private const string Base = nameof(Commands) + ".";
                
                public static class Block
                {
                    private const string Base = Commands.Base + nameof(Block) + ".";
                    
                    public static readonly TemplateKey Success = new(Base + nameof(Success));
                    
                    public static class Errors
                    {
                        private const string Base = Block.Base + nameof(Errors) + ".";
                        
                        public static readonly TemplateKey PlayerNotFound = new(Base + nameof(PlayerNotFound));
                        public static readonly TemplateKey IsAlreadyBanned = new(Base + nameof(IsAlreadyBanned));
                    }
                }
                
                public static class Unblock
                {
                    private const string Base = Commands.Base + nameof(Unblock) + ".";
                    
                    public static readonly TemplateKey Success = new(Base + nameof(Success));
                    
                    public static class Errors
                    {
                        private const string Base = Unblock.Base + nameof(Errors) + ".";
                        
                        public static readonly TemplateKey PlayerNotFound = new(Base + nameof(PlayerNotFound));
                        public static readonly TemplateKey NotBanned = new(Base + nameof(NotBanned));
                    }
                }
            }
        }
        #endregion

        #region Updates\BaseImageUpdate.cs
        public abstract class BaseImageUpdate : ILogEvent
        {
            public IPlayer Player { get; }
            public ulong PlayerId { get; }
            public string DisplayName { get; }
            public BaseEntity Entity { get; }
            public bool IgnoreMessage { get; }
            public int ItemId { get; protected set; }
            
            public byte TextureIndex { get; protected set; }
            public virtual bool SupportsTextureIndex => false;
            
            protected BaseImageUpdate(BasePlayer player, BaseEntity entity, bool ignoreMessage)
            {
                Player = player.IPlayer;
                DisplayName = player.displayName;
                PlayerId = player.userID;
                Entity = entity;
                IgnoreMessage = ignoreMessage;
            }
            
            public abstract byte[] GetImage();
        }
        #endregion

        #region Updates\FireworkUpdate.cs
        public class FireworkUpdate : BaseImageUpdate
        {
            public PatternFirework Firework => (PatternFirework)Entity;
            
            public FireworkUpdate(BasePlayer player, PatternFirework entity) : base(player, entity, false) { }
            
            public override byte[] GetImage()
            {
                PatternFirework firework = Firework;
                List<Star> stars = firework.Design.stars;
                
                using Bitmap image = new(DiscordSignLogger.Instance.FireworkImageSize, DiscordSignLogger.Instance.FireworkImageSize);
                using Graphics g = Graphics.FromImage(image);
                for (int index = 0; index < stars.Count; index++)
                {
                    Star star = stars[index];
                    int x = (int)((star.position.x + 1) * DiscordSignLogger.Instance.FireworkHalfImageSize);
                    int y = (int)((-star.position.y + 1) * DiscordSignLogger.Instance.FireworkHalfImageSize);
                    g.FillEllipse(GetBrush(star.color), x, y, DiscordSignLogger.Instance.FireworkCircleSize, DiscordSignLogger.Instance.FireworkCircleSize);
                }
                
                return GetImageBytes(image);
            }
            
            private Brush GetBrush(UnityEngine.Color color)
            {
                Brush brush = DiscordSignLogger.Instance.FireworkBrushes[color];
                if (brush == null)
                {
                    brush = new SolidBrush(FromUnityColor(color));
                    DiscordSignLogger.Instance.FireworkBrushes[color] = brush;
                }
                
                return brush;
            }
            
            private Color FromUnityColor(UnityEngine.Color color)
            {
                int red = FromUnityColorField(color.r);
                int green = FromUnityColorField(color.g);
                int blue = FromUnityColorField(color.b);
                int alpha = FromUnityColorField(color.a);
                
                return Color.FromArgb(alpha, red, green, blue);
            }
            
            private int FromUnityColorField(float color)
            {
                return (int)(color * 255);
            }
            
            private byte[] GetImageBytes(Bitmap image)
            {
                MemoryStream stream = DiscordSignLogger.Instance.Pool.GetMemoryStream();
                image.Save(stream, ImageFormat.Png);
                byte[] bytes = stream.ToArray();
                DiscordSignLogger.Instance.Pool.FreeMemoryStream(stream);
                return bytes;
            }
        }
        #endregion

        #region Updates\PaintedItemUpdate.cs
        public class PaintedItemUpdate : BaseImageUpdate
        {
            private readonly byte[] _image;
            
            public PaintedItemUpdate(BasePlayer player, PaintedItemStorageEntity entity, Item item, byte[] image, bool ignoreMessage) : base(player, entity, ignoreMessage)
            {
                _image = image;
                ItemId = item.info.itemid;
            }
            
            public override byte[] GetImage()
            {
                return _image;
            }
        }
        #endregion

        #region Updates\SignageUpdate.cs
        public class SignageUpdate : BaseImageUpdate
        {
            public string Url { get; }
            public override bool SupportsTextureIndex => true;
            public ISignage Signage => (ISignage)Entity;
            
            public SignageUpdate(BasePlayer player, ISignage entity, byte textureIndex, bool ignoreMessage = false, string url = null) : base(player, (BaseEntity)entity, ignoreMessage)
            {
                TextureIndex = textureIndex;
                Url = url;
            }
            
            public override byte[] GetImage()
            {
                ISignage sign = Signage;
                uint crc = sign.GetTextureCRCs()[TextureIndex];
                return FileStorage.server.Get(crc, FileStorage.Type.png, sign.NetworkID, (uint)TextureIndex);
            }
        }
        #endregion

        #region Configuration\PluginSupport\PluginSettings.cs
        public class PluginSettings
        {
            [JsonProperty("Sign Artist Settings")]
            public SignArtistSettings SignArtist { get; set; }
            
            [JsonConstructor]
            private PluginSettings() { }
            
            public PluginSettings(PluginSettings settings)
            {
                SignArtist = new SignArtistSettings(settings?.SignArtist);
            }
        }
        #endregion

        #region Configuration\PluginSupport\SignArtistSettings.cs
        public class SignArtistSettings
        {
            [JsonProperty("Log /sil")]
            public bool LogSil { get; set; }
            
            [JsonProperty("Log /sili")]
            public bool LogSili { get; set; }
            
            [JsonProperty("Log /silt")]
            public bool LogSilt { get; set; }
            
            [JsonConstructor]
            private SignArtistSettings() { }
            
            public SignArtistSettings(SignArtistSettings settings)
            {
                LogSil = settings?.LogSil ?? true;
                LogSili = settings?.LogSili ?? true;
                LogSilt = settings?.LogSilt ?? true;
            }
            
            public bool ShouldLog(string url)
            {
                if (url.StartsWith("http://assets.imgix.net"))
                {
                    return LogSilt;
                }
                
                if (ItemManager.itemDictionaryByName.ContainsKey(url))
                {
                    return LogSili;
                }
                
                return LogSil;
            }
        }
        #endregion

    }

}


// --- End of file: DiscordSignLogger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-messages ---
// --- Original File Path: D/DiscordMessages/DiscordMessages.cs ---

﻿using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info( "DiscordMessages", "Slut", "2.1.8" )]
    [SuppressMessage( "ReSharper", "UnusedMember.Local" )]
    internal class DiscordMessages : CovalencePlugin
    {
        #region PlayerChat

#if RUST
        private void OnPlayerChat(BasePlayer basePlayer, string message, ConVar.Chat.ChatChannel channel)
        {
            if (channel == ConVar.Chat.ChatChannel.Team)
            {
                return;
            }

            var player = basePlayer.IPlayer;
            if (player == null)
            {
                return;
            }
            if (BetterChatMute?.Call<bool>("API_IsMuted", player) ?? false)
            {
                return;
            }
            if (AdminChat?.Call<bool>("HasAdminChatEnabled", player) ?? false)
            {
                return;
            }
            
            if (!player.HasPermission(AdminPermission)) message = message.Replace("@everyone", "@ everyone").Replace("@here", "@ here");
            var chatConfig = GetFeatureConfig<Configuration.Chat>(FeatureType.PlayerChat);
            string discordMessage = GetLang( "PlayerChatFormatNew", null, player.Name, message, DateTime.Now.ToShortTimeString() );
            Request.Send(chatConfig.WebhookUrl, new FancyMessage().WithContent(discordMessage).AsTTS(chatConfig.TextToSpeech), this);   
        }

#else
        private void OnUserChat( IPlayer player, string message )
        {
            if ( !GetFeatureConfig<Configuration.Chat>( FeatureType.PlayerChat ).Enabled )
            {
                return;
            }

            if ( BetterChatMute?.Call<bool>( "API_IsMuted", player ) ?? false )
            {
                return;
            }

            if ( AdminChat?.Call<bool>( "HasAdminChatEnabled", player ) ?? false )
            {
                return;
            }

            if ( !player.HasPermission( AdminPermission ) )
            {
                message = message.Replace( "@everyone", "@ everyone" ).Replace( "@here", "@ here" );
            }

            var chatConfig = GetFeatureConfig<Configuration.Chat>( FeatureType.PlayerChat );
            string discordMessage = GetLang( "PlayerChatFormatNew", null, player.Name, message, DateTime.Now.ToShortTimeString() );
            Request.Send( chatConfig.WebhookUrl, new FancyMessage().WithContent( discordMessage ).AsTTS( chatConfig.TextToSpeech ), this );
        }
#endif

        #endregion

        #region Message

        private void MessageCommand( IPlayer player, string command, string[] args )
        {
            if ( args.Length < 1 )
            {
                SendMessage( player, GetLang( "MessageSyntax", player.Id ) );
                return;
            }

            var messageConfig = GetFeatureConfig<Configuration.Message>( FeatureType.Message );

            int secondsRemaining;
            if ( OnCooldown( player, CooldownType.MessageCooldown, out secondsRemaining ) )
            {
                SendMessage( player, GetLang( "Cooldown", player.Id, secondsRemaining.ToString() ));

                return;
            }

            string message = string.Join( " ", args.ToArray() );
            EmbedBuilder builder = new EmbedBuilder().WithTitle( GetLang( "Embed_MessageTitle" ) ).AddInlineField( GetLang( "Embed_MessagePlayer" ), $"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})" ).AddField( GetLang( "Embed_MessageMessage" ), message ).SetColor( messageConfig.Color );
            FancyMessage payload = new FancyMessage().WithContent( messageConfig.Alert ).SetEmbed( builder );
            Request.Send( messageConfig.WebhookUrl, payload, response =>
            {
                if ( response.IsOk )
                {
                    SendMessage( player, GetLang( "MessageSent", player.Id ) );

                    PlayerData data;
                    if ( !_data.Players.TryGetValue( player.Id, out data ) )
                    {
                        _data.Players.Add( player.Id, data = new PlayerData() );
                    }

                    data.MessageCooldown = DateTime.UtcNow;

                    if ( messageConfig.LogToConsole )
                    {
                        Puts( $"MESSAGE ({player.Name}/{player.Id}) : {message}" );
                    }
                }
                else if ( response.IsBad )
                {
                    SendMessage( player, GetLang( "MessageNotSent", player.Id ) );
                }
            }, this );
        }

        #endregion

        #region Classes

        private class Data
        {
            public readonly Dictionary<string, PlayerData> Players = new Dictionary<string, PlayerData>();
        }

        private class PlayerData
        {
            public int Reports { get; set; }
            public DateTime? ReportCooldown { get; set; }
            public DateTime? MessageCooldown { get; set; }
            public bool ReportDisabled { get; set; }
        }

        public class FancyMessage
        {
            [JsonProperty( "content" )] private string Content { get; set; }

            [JsonProperty( "tts" )] private bool TextToSpeech { get; set; }

            [JsonProperty( "embeds" )] private EmbedBuilder[] Embeds { get; set; }

            public FancyMessage WithContent( string value )
            {
                Content = value;
                return this;
            }

            public FancyMessage AsTTS( bool value )
            {
                TextToSpeech = value;
                return this;
            }

            public FancyMessage SetEmbed( EmbedBuilder value )
            {
                Embeds = new[]
                {
                    value
                };
                return this;
            }

            public string GetContent()
            {
                return Content;
            }

            public bool IsTTS()
            {
                return TextToSpeech;
            }

            public EmbedBuilder GetEmbed()
            {
                return Embeds[0];
            }

            public string ToJson()
            {
                return JsonConvert.SerializeObject( this, _instance._jsonSettings );
            }
        }

        public class EmbedBuilder
        {
            public EmbedBuilder()
            {
                Fields = new List<Field>();
            }

            [JsonProperty( "title" )] private string Title { get; set; }

            [JsonProperty( "color" )] private int Color { get; set; }

            [JsonProperty( "fields" )] private List<Field> Fields { get; }

            [JsonProperty( "description" )] private string Description { get; set; }

            public EmbedBuilder WithTitle( string title )
            {
                Title = title;
                return this;
            }

            public EmbedBuilder WithDescription( string description )
            {
                Description = description;
                return this;
            }

            public EmbedBuilder SetColor( int color )
            {
                Color = color;
                return this;
            }

            public EmbedBuilder SetColor( string color )
            {
                Color = ParseColor( color );
                return this;
            }

            public EmbedBuilder AddInlineField( string name, object value )
            {
                Fields.Add( new Field( name, value, true ) );
                return this;
            }

            public EmbedBuilder AddField( string name, object value )
            {
                Fields.Add( new Field( name, value, false ) );
                return this;
            }

            public EmbedBuilder AddField( Field field )
            {
                Fields.Add( field );
                return this;
            }

            public EmbedBuilder AddFields( Field[] fields )
            {
                for ( var i = 0; i < fields.Length; i++ )
                {
                    Fields.Add( fields[i] );
                }

                return this;
            }

            public int GetColor()
            {
                return Color;
            }

            public string GetTitle()
            {
                return Title;
            }

            public Field[] GetFields()
            {
                return Fields.ToArray();
            }

            private int ParseColor( string input )
            {
                int color;
                if ( !int.TryParse( input, out color ) )
                {
                    color = 3329330;
                }

                return color;
            }

            public class Field
            {
                [JsonProperty( "inline" )]
                public bool Inline;

                [JsonProperty( "name" )]
                public string Name;

                [JsonProperty( "value" )]
                public object Value;

                public Field( string name, object value, bool inline )
                {
                    Name = name;
                    Value = value;
                    Inline = inline;
                }

                public Field() { }
            }
        }

        private abstract class Response
        {
            public int Code { get; set; }
            public string Message { get; set; }
        }

        private class BaseResponse : Response
        {
            public bool IsRatelimit => Code == 429;
            public bool IsOk => ( Code == 200 ) | ( Code == 204 );
            public bool IsBad => !IsRatelimit && !IsOk;

            public RateLimitResponse GetRateLimit()
            {
                return Message.Length == 0 ? null : JsonConvert.DeserializeObject<RateLimitResponse>( Message );
            }
        }

        private class Request
        {
            private static bool _rateLimited;
            private static bool _busy;
            private static Queue<Request> _requestQueue;
            private readonly string _payload;
            private readonly Plugin _plugin;
            private readonly Action<BaseResponse> _response;
            private readonly string _url;

            public static void Init()
            {
                _requestQueue = new Queue<Request>();
            }

            private Request( string url, FancyMessage message, Action<BaseResponse> response = null, Plugin plugin = null )
            {
                _url = url;
                _payload = message.ToJson();
                _response = response;
                _plugin = plugin;
            }

            private Request( string url, FancyMessage message, Plugin plugin = null )
            {
                _url = url;
                _payload = message.ToJson();
                _plugin = plugin;
            }

            private static void SendNextRequest()
            {
                if ( _requestQueue.Count == 0 )
                {
                    return;
                }

                Request request = _requestQueue.Dequeue();
                request.Send();
            }

            private static void EnqueueRequest( Request request )
            {
                _requestQueue.Enqueue( request );
            }


            private void Send()
            {
                if ( _busy )
                {
                    EnqueueRequest( this );
                    return;
                }

                _busy = true;

                _instance.webrequest.Enqueue( _url, _payload, ( code, rawResponse ) =>
                {
                    var response = new BaseResponse
                    {
                        Message = rawResponse,
                        Code = code
                    };

                    if ( response.IsRatelimit )
                    {
                        RateLimitResponse rateLimit = response.GetRateLimit();
                        if ( rateLimit != null )
                        {
                            EnqueueRequest( this );
                            OnRateLimit( rateLimit.RetryAfter );
                        }
                    }
                    else if ( response.IsBad )
                    {
                        _instance.PrintWarning( "Failed! Discord responded with code: {0}. Plugin: {1}\n{2}", code, _plugin != null ? _plugin.Name : "Unknown Plugin", response.Message );
                    }
                    else
                    {
                        try
                        {
                            _response?.Invoke( response );
                        }
                        catch ( Exception ex )
                        {
                            Interface.Oxide.LogException( "[DiscordMessages] Request callback raised an exception!", ex );
                        }
                    }

                    _busy = false;
                    SendNextRequest();
                }, _instance, RequestMethod.POST, _instance._headers );
            }

            private static void OnRateLimit( int retryAfter )
            {
                if ( _rateLimited )
                {
                    return;
                }

                _rateLimited = true;
                _instance.timer.In( retryAfter / 1000, OnRateLimitEnd );
            }

            private static void OnRateLimitEnd()
            {
                _rateLimited = false;
                SendNextRequest();
            }

            public static void Send( string url, FancyMessage message, Plugin plugin = null )
            {
                new Request( url, message, plugin ).Send();
            }

            public static void Send( string url, FancyMessage message, Action<BaseResponse> callback, Plugin plugin = null )
            {
                new Request( url, message, callback, plugin ).Send();
            }

            public static void Dispose()
            {
                _requestQueue = null;
                _rateLimited = false;
                _busy = false;
            }
        }

        private class RateLimitResponse : BaseResponse
        {
            [JsonProperty( "retry_after" )] public int RetryAfter { get; set; }
        }

        private enum CooldownType
        {
            ReportCooldown,
            MessageCooldown
        }

        private enum FeatureType
        {
            Ban,
            Message,
            Report,
            PlayerChat,
            Mute
        }

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            public General GeneralSettings { get; set; } = new General();

            public Ban BanSettings { get; set; } = new Ban();

            public Report ReportSettings { get; set; } = new Report();

            public Message MessageSettings { get; set; } = new Message();
            public Chat ChatSettings { get; set; } = new Chat();
            public Mute MuteSettings { get; set; } = new Mute();

            [JsonIgnore] public Dictionary<FeatureType, WebhookObject> FeatureTypes { get; set; }

            public static Configuration Defaults()
            {
                return new Configuration();
            }

            public class General
            {
                public bool Announce { get; set; } = true;
            }

            public class Ban : EmbedObject { }

            public class Message : EmbedObject
            {
                public bool LogToConsole { get; set; } = true;
                public bool SuggestAlias { get; set; } = false;
                public string Alert { get; set; } = "";
                public int Cooldown { get; set; } = 30;
            }

            public class Report : EmbedObject
            {
                public bool LogToConsole { get; set; } = true;
                public string Alert { get; set; } = "";
                public int Cooldown { get; set; } = 30;
            }

            public class Chat : WebhookObject
            {
                public bool TextToSpeech { get; set; } = false;
            }

            public class Mute : EmbedObject { }

            public class EmbedObject : WebhookObject
            {
                public string Color { get; set; } = "3329330";
            }

            public class WebhookObject
            {
                public bool Enabled { get; set; } = true;
                public string WebhookUrl { get; set; } = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            _config.FeatureTypes = new Dictionary<FeatureType, Configuration.WebhookObject>
            {
                [FeatureType.Ban] = _config.BanSettings,
                [FeatureType.Report] = _config.ReportSettings,
                [FeatureType.Message] = _config.MessageSettings,
                [FeatureType.Mute] = _config.MuteSettings,
                [FeatureType.PlayerChat] = _config.ChatSettings
            };
        }

        protected override void SaveConfig()
        {
            base.SaveConfig();
            Config.WriteObject( _config );
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning( "Generating new config!" );
            _config = Configuration.Defaults();
        }

        private T GetFeatureConfig<T>( FeatureType type ) where T : Configuration.WebhookObject
        {
            return ( T ) _config.FeatureTypes[type];
        }

        #endregion

        #region Variables

        private Data _data;

        [PluginReference]
        private readonly Plugin BetterChatMute, AdminChat;

        private static DiscordMessages _instance;
        private readonly JsonSerializerSettings _jsonSettings = new JsonSerializerSettings();

        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>
        {
            ["Content-Type"] = "application/json"
        };

        #endregion

        #region Hooks / Load

        private void Loaded()
        {
            _instance = this;
            Request.Init();
            _jsonSettings.NullValueHandling = NullValueHandling.Ignore;
            LoadData();
            RegisterPermissions();

            foreach ( var feature in _config.FeatureTypes )
            {
                Configuration.WebhookObject value = feature.Value;
                if ( !value.Enabled || value.WebhookUrl != null && value.WebhookUrl != "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks" )
                {
                    continue;
                }

                value.Enabled = false;
                PrintWarning( $"{feature.Key} was enabled however the Webhook is incorrect." );
            }

            RegisterCommands();
            CheckHooks();
        }

        private void CheckHooks()
        {
            if ( !GetFeatureConfig<Configuration.Chat>( FeatureType.PlayerChat ).Enabled )
            {
#if RUST
                Unsubscribe(nameof(OnPlayerChat));
#else
                Unsubscribe( nameof( OnUserChat ) );
#endif
            }

            if ( !GetFeatureConfig<Configuration.Mute>( FeatureType.Mute ).Enabled )
            {
                Unsubscribe( nameof( OnBetterChatMuted ) );
                Unsubscribe( nameof( OnBetterChatTimeMuted ) );
            }
        }

        private void Unload()
        {
            SaveData();
            Request.Dispose();
            _instance = null;
        }

        private void OnServerSave()
        {
            SaveData();
        }

        private void RegisterCommands()
        {
            if ( GetFeatureConfig<Configuration.Report>( FeatureType.Report ).Enabled )
            {
                AddCovalenceCommand( "report", "ReportCommand", ReportPermission );
                AddCovalenceCommand( new[]
                {
                    "reportadmin",
                    "ra"
                }, "ReportAdminCommand", AdminPermission );
            }

            if ( GetFeatureConfig<Configuration.Ban>( FeatureType.Ban ).Enabled )
            {
                AddCovalenceCommand( "ban", "BanCommand", BanPermission );
            }

            var messageConfig = GetFeatureConfig<Configuration.Message>( FeatureType.Message );
            if ( messageConfig.Enabled )
            {
                AddCovalenceCommand( messageConfig.SuggestAlias
                    ? new[]
                    {
                        "message",
                        "suggest"
                    }
                    : new[]
                    {
                        "message"
                    }, "MessageCommand", MessagePermission );
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages( new Dictionary<string, string>
            {
                ["ReportSyntax"] = "Syntax error. Please use /report \"name/id\" \"reason\"",
                ["BanSyntax"] = "Syntax error. Please use /ban \"name/id\" \"reason\"",
                ["MessageSyntax"] = "Syntax error. Please use /message \"your message\"",
                ["Multiple"] = "Multiple players found:\n{0}",
                ["BanMessage"] = "{0} was banned for {1}",
                ["ReportSent"] = "Your report has been sent!",
                ["MessageSent"] = "Your message has been sent!",
                ["NotFound"] = "Unable to find player {0}",
                ["NoReports"] = "{0} has not been reported yet!",
                ["ReportDisallowed"] = "You have been blacklisted from reporting players.",
                ["ReportAccessChanged"] = "Report feature for {0} is now {1}",
                ["ReportReset"] = "You have reset the report count for {0}",
                ["Cooldown"] = "You must wait {0} seconds to use this command again.",
                ["AlreadyBanned"] = "{0} is already banned!",
                ["NoPermission"] = "You do not have permision for this command!",
                ["Disabled"] = "This feature is currently disabled.",
                ["Failed"] = "Your report failed to send, contact the server owner.",
                ["ToSelf"] = "You cannot perform this action on yourself.",
                ["ReportTooShort"] = "Your report was too short! Please be more descriptive.",
                ["PlayerChatFormatNew"] = "[{2}] **{0}:** {1}",
                ["BanPrefix"] = "Banned: {0}",
                ["Embed_ReportPlayer"] = "Reporter",
                ["Embed_ReportTarget"] = "Reported",
                ["Embed_ReportCount"] = "Times Reported",
                ["Embed_ReportReason"] = "Reason",
                ["Embed_Online"] = "Online",
                ["Embed_Offline"] = "Offline",
                ["Embed_ReportStatus"] = "Status",
                ["Embed_ReportTitle"] = "Player Report",
                ["Embed_MuteTitle"] = "Player Muted",
                ["Embed_MuteTarget"] = "Player",
                ["Embed_MutePlayer"] = "Muted by",
                ["Embed_BanPlayer"] = "Banned by",
                ["Embed_BanTarget"] = "Player",
                ["Embed_BanReason"] = "Reason",
                ["Embed_BanTitle"] = "Player Ban",
                ["Embed_MessageTitle"] = "Player Message",
                ["Embed_MessagePlayer"] = "Player",
                ["Embed_MessageMessage"] = "Message",
                ["Embed_MuteTime"] = "Time",
                ["Embed_MuteReason"] = "Reason"
            }, this );
        }

        #endregion

        #region Permissions

        private const string BanPermission = "discordmessages.ban";
        private const string ReportPermission = "discordmessages.report";
        private const string MessagePermission = "discordmessages.message";
        private const string AdminPermission = "discordmessages.admin";

        private void RegisterPermissions()
        {
            permission.RegisterPermission( BanPermission, this );
            permission.RegisterPermission( ReportPermission, this );
            permission.RegisterPermission( MessagePermission, this );
            permission.RegisterPermission( AdminPermission, this );
        }

        #endregion

        #region API

        private void API_SendFancyMessage( string webhookUrl, string content, string embedJsonString, Plugin plugin = null )
        {
            EmbedBuilder embed;
            try
            {
                embed = JsonConvert.DeserializeObject<EmbedBuilder>( embedJsonString );
            }
            catch ( JsonSerializationException )
            {
                PrintWarning( "Failed to deserialize json string: {0}", embedJsonString );
                return;
            }

            FancyMessage payload = new FancyMessage().SetEmbed( embed ).WithContent( content );
            Request.Send( webhookUrl, payload, plugin );
        }

        private void API_SendFancyMessage( string webhookUrl, string embedName, int embedColor, string json, string content = null, Plugin plugin = null )
        {
            EmbedBuilder builder = new EmbedBuilder().WithTitle( embedName ).SetColor( embedColor );


            EmbedBuilder.Field[] fields;
            try
            {
                fields = JsonConvert.DeserializeObject<EmbedBuilder.Field[]>( json );
            }
            catch ( JsonSerializationException )
            {
                PrintWarning( "Failed to deserialize json string: {0}", json );
                return;
            }

            builder.AddFields( fields );

            FancyMessage payload = new FancyMessage().SetEmbed( builder ).WithContent( content );
            Request.Send( webhookUrl, payload, plugin );
        }

        private void API_SendFancyMessage( string webhookUrl, string embedName, string json, string content = null, int embedColor = 3329330, Plugin plugin = null )
        {
            API_SendFancyMessage( webhookUrl, embedName, embedColor, json, content, plugin );
        }

        private void API_SendTextMessage( string webhookUrl, string content, bool tts = false, Plugin plugin = null )
        {
            Request.Send( webhookUrl, new FancyMessage().AsTTS( tts ).WithContent( content ), plugin );
        }

        #endregion

        #region Report

        private void ReportAdminCommand( IPlayer player, string command, string[] args )
        {
            IPlayer target = GetPlayer( args[1], player, false );
            if ( target == null )
            {
                player.Reply( GetLang( "NotFound", player.Id, args[1] ) );
                return;
            }

            PlayerData data;

            switch ( args[0] )
            {
                case "enable":

                    if ( _data.Players.TryGetValue( target.Id, out data ) )
                    {
                        data.ReportDisabled = false;
                    }

                    player.Reply( GetLang( "ReportAccessChanged", player.Id, target.Name, "enabled" ) );
                    return;
                case "disable":
                    if ( !_data.Players.TryGetValue( target.Id, out data ) )
                    {
                        _data.Players.Add( target.Id, data = new PlayerData() );
                    }

                    data.ReportDisabled = true;

                    player.Reply( GetLang( "ReportAccessChanged", player.Id, target.Name, "disabled" ) );
                    return;
                case "reset":
                    if ( _data.Players.TryGetValue( target.Id, out data ) && data.Reports > 0 )
                    {
                        data.Reports = 0;
                        player.Reply( GetLang( "ReportReset", player.Id, target.Name ) );
                        return;
                    }

                    player.Reply( GetLang( "NoReports", player.Id, target.Name ) );
                    return;
            }
        }

        private void ReportCommand( IPlayer player, string command, string[] args )
        {
            if ( ( player.Name == "Server Console" ) | !player.IsConnected )
            {
                return;
            }

            PlayerData data;
            if ( !_data.Players.TryGetValue( player.Id, out data ) )
            {
                _data.Players.Add( player.Id, data = new PlayerData() );
            }
            else if ( data.ReportDisabled )
            {
                SendMessage( player, GetLang( "ReportDisallowed", player.Id ) );
                return;
            }

            if ( args.Length < 2 )
            {
                SendMessage( player, GetLang( "ReportSyntax", player.Id ) );
                return;
            }

            var reportConfig = GetFeatureConfig<Configuration.Report>( FeatureType.Report );

            int secondsRemaining;
            if ( OnCooldown( player, CooldownType.ReportCooldown, out secondsRemaining ) )
            {
                SendMessage( player, GetLang( "Cooldown", player.Id, secondsRemaining.ToString() ) );
                return;
            }

            IPlayer target = GetPlayer( args[0], player, true );
            if ( target == null )
            {
                return;
            }

            var reason = args.Skip( 1 ).ToList();
            if ( player.Id == target.Id )
            {
                SendMessage( player, GetLang( "ToSelf", player.Id ) );
                return;
            }

            string[] targetName = target.Name.Split( ' ' );
            if ( targetName.Length > 1 )
            {
                for ( var x = 0; x < targetName.Length - 1; x++ )
                {
                    if ( reason[x].Equals( targetName[x + 1] ) )
                    {
                        reason.RemoveAt( x );
                    }
                    else
                    {
                        break;
                    }
                }
            }

            if ( reason.Count < 1 )
            {
                SendMessage( player, GetLang( "ReportTooShort", player.Id ) );
                return;
            }

            string cleanReason = string.Join( " ", reason.ToArray() );

            PlayerData targetData;
            if ( !_data.Players.TryGetValue( target.Id, out targetData ) )
            {
                _data.Players.Add( target.Id, targetData = new PlayerData() );
            }

            targetData.Reports++;

            string status = target.IsConnected ? lang.GetMessage( "Online", null ) : lang.GetMessage( "Offline", null );
            EmbedBuilder builder = new EmbedBuilder().WithTitle( GetLang( "Embed_ReportTitle" ) ).SetColor( reportConfig.Color ).AddInlineField( GetLang( "Embed_ReportTarget" ), $"[{target.Name}](https://steamcommunity.com/profiles/{target.Id})" ).AddInlineField( GetLang( "Embed_ReportPlayer" ), $"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})" ).AddInlineField( GetLang( "Embed_ReportStatus" ), status ).AddField( GetLang( "Embed_ReportReason" ), cleanReason ).AddInlineField( GetLang( "Embed_ReportCount" ), targetData.Reports.ToString() );
            FancyMessage payload = new FancyMessage().WithContent( reportConfig.Alert ).SetEmbed( builder );
            Request.Send( reportConfig.WebhookUrl, payload, response =>
            {
                if ( response.IsOk )
                {
                    SendMessage( player, GetLang( "ReportSent", player.Id ) );
                    data.ReportCooldown = DateTime.UtcNow;

                    if ( reportConfig.LogToConsole )
                    {
                        Puts( $"REPORT ({player.Name}/{player.Id}) -> ({target.Name}/{target.Id}): {reason}" );
                    }
                }
                else if ( response.IsBad )
                {
                    SendMessage( player, GetLang( "ReportNotSent", player.Id ) );
                }
            }, this );
        }

        #endregion

        #region Mutes

        private static string FormatTime( TimeSpan time )
        {
            return $"{( time.Days == 0 ? string.Empty : $"{time.Days} day(s)" )}{( time.Days != 0 && time.Hours != 0 ? ", " : string.Empty )}{( time.Hours == 0 ? string.Empty : $"{time.Hours} hour(s)" )}{( time.Hours != 0 && time.Minutes != 0 ? ", " : string.Empty )}{( time.Minutes == 0 ? string.Empty : $"{time.Minutes} minute(s)" )}{( time.Minutes != 0 && time.Seconds != 0 ? ", " : string.Empty )}{( time.Seconds == 0 ? string.Empty : $"{time.Seconds} second(s)" )}";
        }

        private void OnBetterChatTimeMuted( IPlayer target, IPlayer player, TimeSpan expireDate, string reason )
        {
            SendMute( target, player, expireDate, true, reason );
        }

        private void OnBetterChatMuted( IPlayer target, IPlayer player, string reason )
        {
            SendMute( target, player, TimeSpan.Zero, false, reason );
        }

        private void SendMute( IPlayer target, IPlayer player, TimeSpan expireDate, bool timed, string reason )
        {
            if ( target == null || player == null )
            {
                return;
            }

            var muteConfig = GetFeatureConfig<Configuration.Mute>( FeatureType.Mute );
            EmbedBuilder builder = new EmbedBuilder().WithTitle( GetLang( "Embed_MuteTitle" ) ).AddInlineField( GetLang( "Embed_MuteTarget" ), $"[{target.Name}](https://steamcommunity.com/profiles/{target.Id})" ).AddInlineField( GetLang( "Embed_MutePlayer" ), !player.Id.Equals( "server_console" ) ? $"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})" : player.Name ).AddInlineField( GetLang( "Embed_MuteTime" ), timed ? FormatTime( expireDate ) : "Permanent" ).SetColor( muteConfig.Color );
            if ( !string.IsNullOrEmpty( reason ) )
            {
                builder.AddField( GetLang( "Embed_MuteReason" ), reason );
            }

            FancyMessage message = new FancyMessage().SetEmbed( builder );
            Request.Send( muteConfig.WebhookUrl, message, this );
        }

        #endregion

        #region Bans

        private bool _banFromCommand;

        private void BanCommand( IPlayer player, string command, string[] args )
        {
            if ( args.Length == 0 )
            {
                SendMessage( player, GetLang( "BanSyntax", player.Id ) );
                return;
            }

            string reason = args.Length == 1 ? "Banned" : string.Join( " ", args.Skip( 1 ).ToArray() );
            IPlayer target = GetPlayer( args[0], player, false );
            if ( target != null )
            {
                if ( target.Id == player.Id )
                {
                    SendMessage( player, GetLang( "ToSelf", player.Id ) );
                    return;
                }

                ExecuteBan( target, player, reason );
            }
            else
            {
                player.Reply( GetLang( "NotFound", player.Id, args[0] ) );
            }
        }

        private void ExecuteBan( IPlayer target, IPlayer player, string reason )
        {
            if ( target.IsBanned )
            {
                SendMessage( player, GetLang( "AlreadyBanned", player.Id, target.Name ) );
                return;
            }

            _banFromCommand = true;
            OnUserBanned( target.Name, target.Id, target.Address, reason, -1, player );
            target.Ban( GetLang( "BanPrefix", target.Id ) + reason );
            if ( _config.GeneralSettings.Announce )
            {
                server.Broadcast( GetLang( "BanMessage", null, target.Name, reason ) );
            }
        }

        private void OnUserBanned( string name, string bannedId, string address, string reason, long expiry, IPlayer source = null )
        {
            var banConfig = GetFeatureConfig<Configuration.Ban>( FeatureType.Ban );
            if ( !banConfig.Enabled )
            {
                return;
            }

            EmbedBuilder builder = new EmbedBuilder().WithTitle( GetLang( "Embed_BanTitle" ) ).AddInlineField( GetLang( "Embed_BanTarget" ), $"[{name}](https://steamcommunity.com/profiles/{bannedId})" );
            if ( source == null )
            {
                if ( _banFromCommand )
                {
                    return;
                }
            }
            else
            {
                builder.AddInlineField( GetLang( "Embed_BanPlayer" ), !source.Id.Equals( "server_console" ) ? $"[{source.Name}](https://steamcommunity.com/profiles/{source.Id})" : source.Name );
            }

            builder.AddField( GetLang( "Embed_BanReason" ), reason );

            if ( expiry > 0 )
            {
                builder.AddField( "Expiry", DateTimeOffset.FromUnixTimeSeconds( expiry ).LocalDateTime.ToString( CultureInfo.CurrentCulture ) );
            }

            builder.SetColor( banConfig.Color );
            FancyMessage message = new FancyMessage().SetEmbed( builder );
            Request.Send( banConfig.WebhookUrl, message, this );
            _banFromCommand = false;
        }

        #endregion

        #region Helpers

        private string GetLang( string key, string id = null, params object[] args )
        {
            return args.Length > 0 ? string.Format( lang.GetMessage( key, this, id ), args ) : lang.GetMessage( key, this, id );
        }

        private void SendMessage( IPlayer player, string message )
        {
            player.Reply( message );
        }

        private bool OnCooldown( IPlayer player, CooldownType type, out int secondsRemaining )
        {
            secondsRemaining = 0;
            PlayerData data;
            if ( !_data.Players.TryGetValue( player.Id, out data ) )
            {
                return false;
            }

            switch ( type )
            {
                case CooldownType.MessageCooldown:
                {
                    if ( !data.MessageCooldown.HasValue )
                    {
                        return false;
                    }

                    secondsRemaining = (int)(DateTime.UtcNow - data.MessageCooldown.Value.AddSeconds( GetFeatureConfig<Configuration.Message>( FeatureType.Message ).Cooldown )).TotalSeconds;
                    return secondsRemaining > 0;

                }
                case CooldownType.ReportCooldown:
                {
                    if ( !data.ReportCooldown.HasValue )
                    {
                        return false;
                    }

                    secondsRemaining = (int)(DateTime.UtcNow - data.ReportCooldown.Value.AddSeconds( GetFeatureConfig<Configuration.Report>( FeatureType.Report ).Cooldown )).TotalSeconds;
                    return secondsRemaining > 0;

                }
                default:
                    return false;
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject( Name, _data );
        }

        private void LoadData()
        {
            _data = Interface.Oxide.DataFileSystem.ReadObject<Data>( Name );
        }

        private IPlayer GetPlayer( string nameOrId, IPlayer player, bool sendError )
        {
            if ( nameOrId.IsSteamId() )
            {
                IPlayer result = players.All.ToList().Find( p => p.Id == nameOrId );

                return result;
            }

            var foundPlayers = new List<IPlayer>();

            foreach ( IPlayer current in players.Connected )
            {
                if ( string.Equals( current.Name, nameOrId, StringComparison.CurrentCultureIgnoreCase ) )
                {
                    return current;
                }

                if ( current.Name.ToLower().Contains( nameOrId.ToLower() ) )
                {
                    foundPlayers.Add( current );
                }
            }

            if ( foundPlayers.Count == 0 )
            {
                foreach ( IPlayer all in players.All )
                {
                    if ( string.Equals( all.Name, nameOrId, StringComparison.CurrentCultureIgnoreCase ) )
                    {
                        return all;
                    }

                    if ( all.Name.ToLower().Contains( nameOrId.ToLower() ) )
                    {
                        foundPlayers.Add( all );
                    }
                }
            }

            switch ( foundPlayers.Count )
            {
                case 0:
                    if ( !nameOrId.IsSteamId() )
                    {
                        if ( sendError )
                        {
                            SendMessage( player, GetLang( "NotFound", player.Id, nameOrId ) );
                        }
                    }

                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    string[] names = ( from current in foundPlayers
                        select current.Name ).ToArray();
                    SendMessage( player, GetLang( "Multiple", player.Id, string.Join( ", ", names ) ) );
                    break;
            }

            return null;
        }

        #endregion
    }
}

// --- End of file: DiscordMessages.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/discord-hooks ---
// --- Original File Path: D/DiscordHooks/DiscordHooks.cs ---

﻿using System;
using System.Net;
using System.Text;
using System.Collections.Generic;
using System.Collections.Specialized;

using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Discord Hooks", "NooBlet", "0.2.2", ResourceId = 2149)]
    [Description("Discord Client for Rust")]
    class DiscordHooks : CovalencePlugin
    {
        private static PluginConfig Settings;
        private static string BaseURLTemplate = "https://discordapp.com/api/channels/{{ChannelID}}/messages";

        void SendMessage(string MessageText)
        {
            string payloadJson = JsonConvert.SerializeObject(new DiscordPayload()
            {
                MessageText = MessageText
            });

            Dictionary<string, string> headers = new Dictionary<string, string>();
            if (Settings.BotToken.StartsWith("Bot "))
            {
                headers.Add("Authorization", Settings.BotToken);
            }
            else
            {
                headers.Add("Authorization", String.Format("Bot {0}", Settings.BotToken));
            }
            headers.Add("Content-Type", "application/json");

            string url = BaseURLTemplate.Replace("{{ChannelID}}", Settings.ChannelID.ToString());
            webrequest.EnqueuePost(url, payloadJson, (code, response) => PostCallBack(code, response), this, headers);
            //webrequest.EnqueuePost(UrlWithAccessToken, payloadJson, (code, response) => PostCallBack(code, response), this);
        }



        void PostCallBack(int code, string response)
        {
            if (code != 200)
            {
                PrintWarning(String.Format("Discord Api responded with {0}: {1}", code, response));
            }
        }

        void Init()
        {
            LoadConfigValues();
            //UnityEngine.Application.logMessageReceived += ConsoleLog;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config.WriteObject(DefaultConfig(), true);

            PrintWarning("Default Configuration File Created");
        }

        private void LoadConfigValues()
        {
            Settings = Config.ReadObject<PluginConfig>();
        }

        private PluginConfig DefaultConfig()
        {
            return new PluginConfig
            {
                BotToken = String.Empty,
                ChannelID = 0
            };
        }

        private class PluginConfig
        {
            public string BotToken { get; set; }
            public ulong ChannelID { get; set; }
        }

        class DiscordPayload
        {
            [JsonProperty("content")]
            public string MessageText { get; set; }
        }

        //private void ConsoleLog(string condition, string stackTrace, LogType type)
        //{
        //    if (!string.IsNullOrEmpty(condition))
        //    {
        //        SendMessage($"[LOG] {condition}");
        //    }
        //}
    }
}



// --- End of file: DiscordHooks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dung-protector ---
// --- Original File Path: D/DungProtector/DungProtector.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Dung Protector", "KajWithAJ", "1.4.0")]
    [Description("Prevent players from stealing horse dung.")]

    class DungProtector : RustPlugin
    {
        private const string PermissionUse = "dungprotector.use";
        private const string PermissionExclude = "dungprotector.exclude";
        

        private void Init() {
            permission.RegisterPermission(PermissionUse, this);
            permission.RegisterPermission(PermissionExclude, this);
        }

        protected override void LoadDefaultMessages() {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BuildingBlocked"] = "You cannot pickup this item because you are buildingblocked.",
                ["PickupFailed"] = "{0} - ({1}) tried to picking up {2} but was buildingblocked at location {3} - {4}."
            }, this);
        }

        object OnItemPickup(Item item, BasePlayer player) {
            if (item.info.shortname == "horsedung" && player.IsBuildingBlocked()) {
                if (!permission.UserHasPermission(player.UserIDString, PermissionExclude) && permission.UserHasPermission(player.UserIDString, PermissionUse)) {
                    var location = player.transform.position;
                    var gridLocation = MapHelper.PositionToGrid(location);
                    
                    var message = lang.GetMessage("PickupFailed", this);
                    Puts(string.Format(message, player.displayName, player.userID, item.info.shortname, gridLocation, location.ToString("F1")));

                    player.ChatMessage(lang.GetMessage("BuildingBlocked", this, player.UserIDString));
                    return false;
                }
            }
            return null;
        }
    }
}


// --- End of file: DungProtector.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/dynamic-loot-drops ---
// --- Original File Path: D/DynamicLootDrops/DynamicLootDrops.cs ---

﻿
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Dynamic Loot Drops", "birthdates", "1.1.1")]
    [Description("Adding a new way of looting.")]
    public class DynamicLootDrops : RustPlugin
    {

        private List<Item> pickUp = new List<Item>();
        private ConfigFile config;
        private Dictionary<BasePlayer, long> cooldowns = new Dictionary<BasePlayer, long>();
        private const string Permission = "DynamicLootDrops.use";

        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player is NPCPlayer)
            {
                return;
            }

            var items = new List<Item>();
            foreach (var i in player.inventory.containerMain.itemList)
            {
                items.Add(i);
            }
            foreach (var i in player.inventory.containerBelt.itemList)
            {
                items.Add(i);
            }
            foreach (var i in player.inventory.containerWear.itemList)
            {
                items.Add(i);
            }

            if (items.Count < 1)
            {
                return;
            }

            foreach (var z in items)
            {
                if (!config.bAP.Contains(z.info.shortname))
                {
                    pickUp.Add(z);
                }

                z.Drop(player.transform.position, new Vector3(Core.Random.Range(0, 3), Core.Random.Range(0, 3), Core.Random.Range(0, 3)));
            }
            player.inventory.Strip();
        }

        bool CanTake(BasePlayer player) => !player.inventory.containerMain.IsFull() || !player.inventory.containerBelt.IsFull();

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!input.IsDown(BUTTON.FORWARD) && !input.IsDown(BUTTON.BACKWARD) && !input.IsDown(BUTTON.JUMP))
            {
                return;
            }

            if (!permission.UserHasPermission(player.UserIDString, Permission) && !player.IsAdmin)
            {
                return;
            }

            if (pickUp.Count < 1 && !config.pickUpWithoutDeath)
            {
                return;
            }

            if (!CanTake(player))
            {
                return;
            }

            var entity = Physics.OverlapSphere(player.transform.position, 0.5f).Select(col => col.GetComponentInParent<BaseEntity>());

            foreach (var e in entity)
            {

                if (e != null && e.GetItem() != null && !config.bAP.Contains(e.GetItem().info.shortname))
                {
                    if (config.cooldown > 0)
                    {
                        if (!cooldowns.ContainsKey(player))
                        {
                            cooldowns.Add(player, DateTime.Now.Ticks + TimeSpan.FromMilliseconds(config.cooldown).Ticks);
                        }
                        else
                        {
                            if (cooldowns[player] < DateTime.Now.Ticks)
                            {

                                cooldowns.Remove(player);
                            }
                        }
                    }
                    var item = e.GetItem();
                    pickUp.Remove(e.GetItem());
                    player.GiveItem(item);
                    if (!e.IsDestroyed)
                    {
                        e.Kill();
                    }
                }
            }
        }

        public class ConfigFile
        {
            [JsonProperty(PropertyName = "Blacklisted auto-pickups")]
            public List<string> bAP;

            [JsonProperty(PropertyName = "Pick up without death")]
            public bool pickUpWithoutDeath;

            [JsonProperty(PropertyName = "Cooldown in milliseconds")]
            public long cooldown;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                    cooldown = 2,
                    pickUpWithoutDeath = false,
                    bAP = new List<string>()
                    {
                        "rifle.ak",
                        "rifle.bolt"
                    }

                };
            }

        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }


        protected override void LoadConfig()
        {
            base.LoadConfig();

            config = Config.ReadObject<ConfigFile>();
            if (config == null)
            {
                LoadDefaultConfig();
            }
        }


        protected override void LoadDefaultConfig()
        {
            config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }


        void Init()
        {
            permission.RegisterPermission(Permission, this);
            LoadConfig();
        }

    }
}

// --- End of file: DynamicLootDrops.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/town-teleport ---
// --- Original File Path: T/TownTeleport/TownTeleport.cs ---

using System.Collections.Generic;
using UnityEngine;
using System;
using Rust;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("TownTeleport", "mvrb", "1.10.2")]
    [Description("Teleport to Outpost and Bandit Camp")]
    class TownTeleport : RustPlugin
    {
        [PluginReference] Plugin NoEscape;

        private StoredData storedData;

        private List<Vector3> OutpostSpawns = new List<Vector3>();
        private List<Vector3> BanditSpawns = new List<Vector3>();

        private Dictionary<BasePlayer, Timer> TeleportTimers = new Dictionary<BasePlayer, Timer>();

        private string permissionOutpost = "townteleport.outpost";
        private string permissionBandit = "townteleport.bandit";
        private string permissionNoCooldown = "townteleport.nocooldown";
        private string teleportCommandOutpost = "otp";
        private string teleportCommandBandit = "btp";
        private string cancelTeleportCommand = "ttc";

        private bool blockTeleportWhenMounted = false;
        private bool blockTeleportFromCargo = false;
        private bool cancelTpAnyDamamage = false;
        private bool cancelTpPlayerDamage = true;
        private bool cancelTpFallDamage = true;
        private bool forceResetHostileTimer = true;

        private int outpostCooldown = 30;
        private int outpostCountdown = 30;
        private int banditCooldown = 30;
        private int banditCountdown = 30;

        protected override void LoadDefaultConfig()
        {
            Config["BlockTeleportWhenMounted"] = blockTeleportWhenMounted = GetConfig("BlockTeleportWhenMounted", false);
            Config["BlockTeleportFromCargo"] = blockTeleportFromCargo = GetConfig("BlockTeleportFromCargo", false);

            Config["CancelTpAnyDamage"] = cancelTpAnyDamamage = GetConfig("CancelTpAnyDamage", true);
            Config["CancelTpPlayerDamage"] = cancelTpPlayerDamage = GetConfig("CancelTpPlayerDamage", true);
            Config["CancelTpFallDamage"] = cancelTpFallDamage = GetConfig("CancelTpFallDamage", true);

            Config["ForceResetHostileTimer"] = forceResetHostileTimer = GetConfig("ForceResetHostileTimer", true);

            Config["OutpostTeleportCommand"] = teleportCommandOutpost = GetConfig("OutpostTeleportCommand", "otp");
            Config["BanditCampTeleportCommand"] = teleportCommandBandit = GetConfig("BanditCampTeleportCommand", "btp");
            Config["CancelTeleportCommand"] = cancelTeleportCommand = GetConfig("CancelTeleportCommand", "ttc");


            Config["OutpostTeleportCooldown"] = outpostCooldown = GetConfig("OutpostTeleportCooldown", 0);
            Config["OutpostTeleportCountdown"] = outpostCountdown = GetConfig("OutpostTeleportCountdown", 30);
            Config["BanditTeleportCooldown"] = banditCooldown = GetConfig("BanditTeleportCooldown", 0);
            Config["BanditTeleportCountdown"] = banditCountdown = GetConfig("BanditTeleportCountdown", 30);

            SaveConfig();
        }

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["OutpostTeleport"] = "TownTeleport: Teleporting to Outpost in {0} seconds...\nType /{1} to cancel the teleport.",
                ["BanditTeleport"] = "TownTeleport: Teleporting to BanditCamp in {0} seconds...\nType /{1} to cancel the teleport.",
                ["TeleportSuccessMessage"] = "TownTeleport: You have successfully teleported to the Outpost.",
                ["NoActiveTeleport"] = "TownTeleport: You are not about to teleport to Bandit Camp or Outpost.\nType /{0} to teleport to the Outpost.\nType /{1} to teleport to Bandit Camp.",
                ["AlreadyTeleporting"] = "TownTeleport: You are already about to teleport to the Outpost.",

                ["Error: Seated"] = "You can't teleport while seated.",
                ["Error: NoBuildingPrivilege"] = "You can't teleport without Building Privilege.",
                ["Error: Wounded"] = "You can't teleport while wounded.",
                ["Error: Mounted"] = "You can't teleport while seated.",
                ["Error: CargoShip"] = "You can't teleport from the Cargo Ship",
                ["Error: Hostile"] = "You can't teleport while you are marked as Hostile.\nYou will be unmarked as hostile in {0} {1}",
                ["Error: Cooldown"] = "You can't teleport yet.\nYou will be able to teleport in {0} {1}",
                ["Error: RaidBlocked"] = "You can't teleport while raid blocked.",
                ["Error: CombatBlocked"] = "You can't teleport while combat blocked.",

                ["TeleportCancelled"] = "TownTeleport: You have cancelled the teleport timer.",
                ["TeleportCancelledPlayerDamage"] = "TownTeleport: Teleport cancelled due to player damage.",
                ["TeleportCancelledFallDamage"] = "TownTeleport: Teleport cancelled due to fall damage.",
                ["TeleportCancelledDamage"] = "TownTeleport: Teleport cancelled because you took damage.",

                ["OutpostNotFound"] = "TownTeleport: Plugin was unable to locate Outpost.",
                ["BanditNotFound"] = "TownTeleport: Plugin was unable to locate BanditCamp.",
                ["NoPermission"] = "TownTeleport: You do not have permission to use this command."
            }, this);
        }

        private void OnServerInitialized() => FindTowns();

        private void Loaded()
        {
            LoadDefaultConfig();
            LoadData();

            permission.RegisterPermission(permissionOutpost, this);
            permission.RegisterPermission(permissionBandit, this);
            permission.RegisterPermission(permissionNoCooldown, this);

            cmd.AddChatCommand(teleportCommandOutpost, this, "CmdOutpost");
            cmd.AddChatCommand(teleportCommandBandit, this, "CmdBandit");
            cmd.AddChatCommand(cancelTeleportCommand, this, "CmdCancelTp");
        }

        private class StoredData
        {
            public Dictionary<ulong, int> Cooldowns = new Dictionary<ulong, int>();
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!TeleportTimers.ContainsKey(player)) return;

            TeleportTimers[player]?.Destroy();
            TeleportTimers.Remove(player);
        }

        private void CmdOutpost(BasePlayer player)
        {
            var canTeleport = CanTownTeleport(player, "outpost", true);

            if (canTeleport is string)
            {
                player.ChatMessage(canTeleport as string);
                return;
            }

            StartTeleportTimer(player, "outpost");

            player.ChatMessage(Lang("OutpostTeleport", player.UserIDString, outpostCountdown, cancelTeleportCommand));
        }

        private void CmdBandit(BasePlayer player)
        {
            var canTeleport = CanTownTeleport(player, "bandit", true);

            if (canTeleport is string)
            {
                player.ChatMessage(canTeleport as string);
                return;
            }

            StartTeleportTimer(player, "bandit");

            player.ChatMessage(Lang("BanditTeleport", player.UserIDString, banditCountdown, cancelTeleportCommand));
        }

        private object CanTownTeleport(BasePlayer player, string town, bool checkTimers)
        {
            int teleportCooldown = banditCooldown;

            if (town == "outpost")
            {
                if (!permission.UserHasPermission(player.UserIDString, permissionOutpost))
                {
                    return Lang("NoPermission", player.UserIDString);
                }

                if (OutpostSpawns.Count == 0)
                {
                    return Lang("OutpostNotFound", player.UserIDString);
                }

                teleportCooldown = outpostCooldown;

            }
            else if (town == "bandit")
            {
                if (!permission.UserHasPermission(player.UserIDString, permissionBandit))
                {
                    return Lang("NoPermission", player.UserIDString);
                }

                if (BanditSpawns.Count == 0)
                {
                    return Lang("BanditNotFound", player.UserIDString);
                }

                teleportCooldown = banditCooldown;
            }


            if (!permission.UserHasPermission(player.UserIDString, permissionNoCooldown))
            {
                int currentTime = GetUnix();

                if (storedData.Cooldowns.ContainsKey(player.userID))
                {
                    int lastTeleport = storedData.Cooldowns[player.userID];

                    if (teleportCooldown > 0 && currentTime < lastTeleport + teleportCooldown)
                    {
                        int remaining = lastTeleport - currentTime + teleportCooldown;

                        if (remaining > 0 && remaining < 60)
                        {
                            return Lang("Error: Cooldown", player.UserIDString, (remaining).ToString("#,#"), "seconds");

                        }
                        else if (remaining > 60 && remaining < 3600)
                        {
                            return Lang("Error: Cooldown", player.UserIDString, (remaining / 60).ToString("#,#"), "minutes");

                        }
                        else if (remaining > 3600)
                        {
                            return Lang("Error: Cooldown", player.UserIDString, (remaining / 60 / 60).ToString("#,#"), "hours");
                        }
                    }
                }
            }

            if (!player.CanBuild())
            {
                return Lang("Error: NoBuildingPrivilege", player.UserIDString);
            }

            if (player.IsWounded())
            {
                return Lang("Error: Wounded", player.UserIDString);
            }

            if (blockTeleportWhenMounted && player.isMounted)
            {
                return Lang("Error: Mounted", player.UserIDString);
            }

            if (blockTeleportFromCargo && player.GetComponentInParent<CargoShip>())
            {
                return Lang("Error: CargoShip", player.UserIDString);
            }

            if (player.IsHostile())
            {
                double remaining = player.State.unHostileTimestamp - Time.realtimeSinceStartup;

                if (remaining > 0 && remaining < 60)
                {
                    return Lang("Error: Hostile", player.UserIDString, (remaining).ToString("#,#"), "seconds");

                }
                else if (remaining > 60 && remaining < 3600)
                {
                    return Lang("Error: Hostile", player.UserIDString, (remaining / 60).ToString("#,#"), "minutes");

                }
                else if (remaining > 3600)
                {
                    return Lang("Error: Hostile", player.UserIDString, (remaining / 60 / 60).ToString("#,#"), "hours");
                }
            }

            if (NoEscape)
            {
                if ((bool)NoEscape?.Call("IsRaidBlocked", player))
                {
                    return Lang("Error: RaidBlocked", player.UserIDString);
                }
                if ((bool)NoEscape?.Call("IsCombatBlocked", player))
                {
                    return Lang("Error: CombatBlocked", player.UserIDString);
                }
            }

            if (checkTimers && TeleportTimers.ContainsKey(player))
            {
                return Lang("AlreadyTeleporting", player.UserIDString);
            }

            return null;
        }

        private void StartTeleportTimer(BasePlayer player, string town)
        {
            int teleportCountdown = town == "bandit" ? banditCountdown : outpostCountdown;

            TeleportTimers[player] = timer.Once(teleportCountdown, () =>
            {
                HeldEntity heldEntity = player.GetHeldEntity();
                if (heldEntity != null)
                {
                    heldEntity.SetHeld(false);
                }

                var canTeleport = CanTownTeleport(player, town, false);

                if (canTeleport is string)
                {
                    player.ChatMessage(canTeleport as string);
                    return;
                }

                if (forceResetHostileTimer)
                {
                    player.State.unHostileTimestamp = 0;
                    player.ClientRPCPlayer(null, player, "SetHostileLength", 0f);
                }

                if (town == "outpost")
                {
                    Teleport(player, OutpostSpawns[new System.Random().Next(OutpostSpawns.Count)]);
                }
                else if (town == "bandit")
                {
                    Teleport(player, BanditSpawns[new System.Random().Next(BanditSpawns.Count)]);
                }

                int currentTime = GetUnix();

                if (!storedData.Cooldowns.ContainsKey(player.userID))
                {
                    storedData.Cooldowns.Add(player.userID, currentTime);
                }
                else
                {
                    storedData.Cooldowns[player.userID] = currentTime;
                }

                SaveData();

                TeleportTimers[player]?.Destroy();
                if (TeleportTimers.ContainsKey(player)) TeleportTimers.Remove(player);

                player.ChatMessage(Lang("TeleportSuccessMessage", player.UserIDString));
            });
        }

        private void CmdCancelTp(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, permissionOutpost) || permission.UserHasPermission(player.UserIDString, permissionBandit))
            {
                if (!TeleportTimers.ContainsKey(player))
                {
                    player.ChatMessage(Lang("NoActiveTeleport", player.UserIDString, teleportCommandOutpost, teleportCommandBandit));
                    return;
                }

                CancelTp(player, Lang("TeleportCancelled", player.UserIDString));
            }
            else
            {
                player.ChatMessage(Lang("NoPermission", player.UserIDString));
            }
        }

        private void FindTowns()
        {
            foreach (MonumentInfo monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                if (monument.name.ToLower().Contains("compound"))
                {
                    List<BaseEntity> list = new List<BaseEntity>();
                    Vis.Entities(monument.transform.position, 25, list);
                    foreach (BaseEntity entity in list)
                    {
                        if (entity.name.Contains("chair"))
                        {
                            Vector3 chairPos = entity.transform.position;
                            chairPos.y += 1;
                            if (!OutpostSpawns.Contains(chairPos)) OutpostSpawns.Add(chairPos);
                        }
                    }
                }
                else if (monument.name.Contains("bandit"))
                {
                    Vector3 t = monument.transform.position + -monument.transform.right * -50.75f;
                    Vector3 pos = t + (monument.transform.forward * -21.75f) + (Vector3.up * 7f);
                    if (!BanditSpawns.Contains(pos)) BanditSpawns.Add(pos);
                }
            }
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var player = entity.ToPlayer();

            if (player == null || info == null) return;

            if (!TeleportTimers.ContainsKey(player)) return;

            NextTick(() =>
            {
                if (info.damageTypes.Total() <= 0) return;

                if (cancelTpAnyDamamage)
                {
                    CancelTp(player, Lang("TeleportCancelledDamage", player.UserIDString));
                }
                else if (cancelTpPlayerDamage && info?.Initiator is BasePlayer)
                {
                    CancelTp(player, Lang("TeleportCancelledPlayerDamage", player.UserIDString));
                }
                else if (cancelTpFallDamage && info.damageTypes.Has(DamageType.Fall))
                {
                    CancelTp(player, Lang("TeleportCancelledFallDamage", player.UserIDString));
                }
            });
        }

        private void CancelTp(BasePlayer player, string reason)
        {
            TeleportTimers[player]?.Destroy();
            TeleportTimers.Remove(player);
            player.ChatMessage(reason);
        }

        private void Teleport(BasePlayer player, Vector3 position)
        {
            player.EnsureDismounted();

            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "StartLoading");

            StartSleeping(player);
            player.MovePosition(position);

            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "ForcePositionTo", position);

            if (player.net?.connection != null)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);

            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate();

            if (player.net?.connection == null) return;

            try { player.ClearEntityQueue(); } catch { }

            player.SendFullSnapshot();

            player.SetParent(null, true, true);
        }

        private void StartSleeping(BasePlayer player)
        {
            if (player.IsSleeping()) return;

            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);

            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);

            player.CancelInvoke("InventoryUpdate");
        }

        private void LoadData() => storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Name);

        private void SaveData() => Interface.GetMod().DataFileSystem.WriteObject(this.Name, storedData);

        private Int32 GetUnix() => (Int32)(DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;

        private T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
    }
}

// --- End of file: TownTeleport.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/trapper ---
// --- Original File Path: T/Trapper/Trapper.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

//Trapper created with PluginMerge v(1.0.6.0) by MJSU @ https://github.com/dassjosh/Plugin.Merge
namespace Oxide.Plugins
{
    [Info("Trapper", "Shady14u", "1.1.1")]
    [Description("Control who sets off traps")]
    public partial class Trapper : RustPlugin
    {
        #region 0.Trapper.cs
        [PluginReference]
        private Plugin Friends, RustIO, Clans;
        
        private static BasePlayer FindPlayer(string nameOrId)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrId)
                return activePlayer;
                if (activePlayer.displayName.Contains(nameOrId, CompareOptions.OrdinalIgnoreCase))
                return activePlayer;
            }
            foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.UserIDString == nameOrId)
                return sleepingPlayer;
                if (sleepingPlayer.displayName.Contains(nameOrId, CompareOptions.OrdinalIgnoreCase))
                return sleepingPlayer;
            }
            return null;
        }
        #endregion

        #region 1.Trapper.Config.cs
        private static Configuration _config;
        
        public class Configuration
        {
            [JsonProperty(PropertyName = "Reset Time")]
            public float ResetTime { get; set; } = 5f;
            [JsonProperty(PropertyName = "Trigger for Owner")]
            public bool HurtOwner { get; set; } = false;
            [JsonProperty(PropertyName = "Trigger for Friends")]
            public bool HurtFriends { get; set; } = false;
            [JsonProperty(PropertyName = "Trigger for Clan Mates")]
            public bool HurtClanMates { get; set; } = false;
            [JsonProperty(PropertyName = "Trigger for Authorized")]
            public bool HurtAuthed { get; set; } = false;
            [JsonProperty(PropertyName = "Ignore Projectiles")]
            public bool IgnoreProjectiles { get; set; } = false;
            
            
            public static Configuration DefaultConfig()
            {
                return new Configuration();
            }
        }
        
        
        #region BoilerPlate
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }
        
        protected override void LoadDefaultConfig() => _config = Configuration.DefaultConfig();
        
        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion
        #endregion

        #region 3.Trapper.Permissions.cs
        public static class PluginPermissions
        {
            public const string PermissionNameAdmin = "trapper.admin";
            public const string PermissionName = "trapper.auto";
            public const string PermissionNameOwner = "trapper.owner";
            public const string PermissionNameFriends = "trapper.friends";
            public const string PermissionNameClan = "trapper.clan";
            public const string PermissionNameAuth = "trapper.auth";
        }
        
        private void LoadPermissions()
        {
            permission.RegisterPermission(PluginPermissions.PermissionName, this);
            permission.RegisterPermission(PluginPermissions.PermissionNameOwner, this);
            permission.RegisterPermission(PluginPermissions.PermissionNameFriends, this);
            permission.RegisterPermission(PluginPermissions.PermissionNameAdmin, this);
            permission.RegisterPermission(PluginPermissions.PermissionNameClan, this);
            permission.RegisterPermission(PluginPermissions.PermissionNameAuth, this);
        }
        #endregion

        #region 5.Trapper.Hooks.cs
        private void Init()
        {
            LoadPermissions();
        }
        
        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (!_config.IgnoreProjectiles) return null;
            var trap = entity.GetComponent<BaseTrap>();
            if (!trap) return null;
            if (!info.IsProjectile()) return null;
            var bearTrap = entity.GetComponent<BearTrap>();
            if (bearTrap)
            bearTrap.Arm();
            return true;
        }
        
        private object OnTrapTrigger(BaseTrap trap, GameObject obj)
        {
            if (!(trap is BearTrap) && !(trap is Landmine))
            return null;
            var target = obj.GetComponent<BasePlayer>();
            if (target != null)
            {
                if (permission.UserHasPermission(target.UserIDString, PluginPermissions.PermissionNameAdmin))
                return false;
            }
            var player = FindPlayer(trap.OwnerID.ToString());
            if (target != null && player != null)
            {
                // Owner protection
                if (!_config.HurtOwner)
                if (target == player){
                    if (permission.UserHasPermission(target.UserIDString, PluginPermissions.PermissionNameOwner)){
                        return false;
                    }
                }
                // Building auth protection
                if (!_config.HurtAuthed)
                if (permission.UserHasPermission(target.UserIDString, PluginPermissions.PermissionNameAuth))
                if (target.IsBuildingAuthed()){
                    return false;
                }
                
                // Friends protection
                if (!_config.HurtFriends)
                {
                    if (target.Team.members.Contains(trap.OwnerID)) return false;
                    
                    if (Friends!=null && Friends.IsLoaded)
                    if (Friends.Call<bool>("AreFriends", target.userID, player.userID))
                    if (permission.UserHasPermission(target.UserIDString, PluginPermissions.PermissionNameFriends))
                    return false;
                    
                    if (RustIO!=null && RustIO.IsLoaded)
                    if (RustIO.Call<bool>("HasFriend", target.UserIDString, player.UserIDString))
                    if (permission.UserHasPermission(target.UserIDString, PluginPermissions.PermissionNameFriends))
                    return false;
                }
                
                // ClanMates protection
                if (!_config.HurtClanMates)
                {
                    if (Clans)
                    {
                        var targetClan = Clans?.Call<string>("GetClanTag", target.UserIDString);
                        var playerClan = Clans?.Call<string>("GetClanTag", player.UserIDString);
                        if (targetClan == playerClan && !string.IsNullOrEmpty(playerClan ))
                        {
                            if (permission.UserHasPermission(target.UserIDString, PluginPermissions.PermissionNameClan))
                            return false;
                        }
                        else if (Clans?.Call<string>("GetClanOf", target.UserIDString) == Clans?.Call<string>("GetClanOf", player.UserIDString)){
                            if (permission.UserHasPermission(target.UserIDString, PluginPermissions.PermissionNameClan))
                            return false;
                        }
                    }
                }
            }
            
            // Automatic re-arming
            if (!(trap is BearTrap))
            return null;
            if (player == null)
            return null;
            if (permission.UserHasPermission(player.UserIDString, PluginPermissions.PermissionName))
            timer.Once(_config.ResetTime, () =>
            {
                // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                if (trap != null)
                ((BearTrap)trap).Arm();
            });
            return null;
        }
        #endregion

    }

}


// --- End of file: Trapper.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/trade ---
// --- Original File Path: T/Trade/Trade.cs ---

using System;
using System.Text;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using System.Linq;

namespace Oxide.Plugins
{
    [Info ("Trade", "Calytic", "1.2.45")]
    class Trade : RustPlugin
    {
        #region Configuration

        string box;
        int slots;
        float cooldownMinutes;
        float maxRadius;
        float pendingSeconds;
        float radiationMax;
        bool allowSafeZone;

        [PluginReference]
        Plugin Ignore, Clans, Friends;

        Dictionary<string, DateTime> tradeCooldowns = new Dictionary<string, DateTime> ();

        #endregion

        #region Trade State

        class OnlinePlayer
        {
            public BasePlayer Player;
            public StorageContainer View;
            public OpenTrade Trade;

            public PlayerInventory inventory {
                get {
                    return Player.inventory;
                }
            }

            public ItemContainer containerMain {
                get {
                    return Player.inventory.containerMain;
                }
            }

            public OnlinePlayer (BasePlayer player)
            {
            }

            public void Clear ()
            {
                View = null;
                Trade = null;
            }
        }

        [OnlinePlayers]
        Hash<BasePlayer, OnlinePlayer> onlinePlayers = new Hash<BasePlayer, OnlinePlayer> ();

        class OpenTrade
        {
            public OnlinePlayer source;
            public OnlinePlayer target;

            public BasePlayer sourcePlayer {
                get {
                    return source.Player;
                }
            }

            public BasePlayer targetPlayer {
                get {
                    return target.Player;
                }
            }

            public bool complete = false;
            public bool closing = false;

            public bool sourceAccept = false;
            public bool targetAccept = false;

            public OpenTrade (OnlinePlayer source, OnlinePlayer target)
            {
                this.source = source;
                this.target = target;
            }

            public OnlinePlayer GetOther (OnlinePlayer onlinePlayer)
            {
                if (source == onlinePlayer) {
                    return target;
                }

                return source;
            }

            public BasePlayer GetOther (BasePlayer player)
            {
                if (sourcePlayer == player) {
                    return targetPlayer;
                }

                return sourcePlayer;
            }

            public void ResetAcceptance ()
            {
                sourceAccept = false;
                targetAccept = false;
            }

            public bool IsInventorySufficient ()
            {
                if (target == null || source == null) {
                    return false;
                }

                if (target.containerMain == null || source.containerMain == null) {
                    return false;
                }

                if ((target.containerMain.capacity - target.containerMain.itemList.Count) < source.View.inventory.itemList.Count ||
                       (source.containerMain.capacity - source.containerMain.itemList.Count) < target.View.inventory.itemList.Count) {
                    return true;
                }

                return false;
            }

            public bool IsValid ()
            {
                if (IsSourceValid () && IsTargetValid ())
                    return true;

                return false;
            }

            public bool IsSourceValid ()
            {
                if (sourcePlayer != null && sourcePlayer.IsConnected)
                    return true;

                return false;
            }

            public bool IsTargetValid ()
            {
                if (targetPlayer != null && targetPlayer.IsConnected)
                    return true;

                return false;
            }
        }

        class PendingTrade
        {
            public BasePlayer Target;
            public Timer Timer;

            public PendingTrade (BasePlayer target)
            {
                Target = target;
            }

            public void Destroy ()
            {
                if (Timer != null && !Timer.Destroyed) {
                    Timer.Destroy ();
                }
            }
        }

        List<OpenTrade> openTrades = new List<OpenTrade> ();
        Dictionary<BasePlayer, PendingTrade> pendingTrades = new Dictionary<BasePlayer, PendingTrade> ();
        #endregion

        #region Initialization

        void Init ()
        {

            UnsubscribeAll ();
        }

        void UnsubscribeAll ()
        {
            //Unsubscribe(nameof(CanNetworkTo));
            Unsubscribe (nameof (OnItemAction));
            Unsubscribe (nameof (OnItemAddedToContainer));
            Unsubscribe (nameof (CanMoveItem));
            Unsubscribe (nameof (OnItemRemovedFromContainer));
        }

        void SubscribeAll ()
        {
            //Subscribe(nameof(CanNetworkTo));
            Subscribe (nameof (OnItemAction));
            Subscribe (nameof (OnItemAddedToContainer));
            Subscribe (nameof (CanMoveItem));
            Subscribe (nameof (OnItemRemovedFromContainer));
        }

        void Loaded ()
        {
            permission.RegisterPermission ("trade.use", this);
            permission.RegisterPermission ("trade.accept", this);

            LoadMessages ();

            CheckConfig ();

            box = GetConfig ("Settings", "box", "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab");
            slots = GetConfig ("Settings", "slots", 30);
            cooldownMinutes = GetConfig ("Settings", "cooldownMinutes", 5f);
            maxRadius = GetConfig ("Settings", "maxRadius", 5000f);
            pendingSeconds = GetConfig ("Settings", "pendingSeconds", 25f);
            radiationMax = GetConfig ("Settings", "radiationMax", 1f);
            allowSafeZone = GetConfig ("Settings", "allowSafeZone", true);
        }

        void Unloaded ()
        {
            foreach (var player in BasePlayer.activePlayerList) {
                OnlinePlayer onlinePlayer;
                if (onlinePlayers.TryGetValue (player, out onlinePlayer)) {
                    if (onlinePlayer.Trade != null) {
                        TradeCloseBoxes (onlinePlayer.Trade);
                    } else if (onlinePlayer.View != null) {
                        CloseBoxView (player, onlinePlayer.View);
                    }
                }
            }
        }

        protected new void LoadDefaultConfig ()
        {
            Config ["Settings", "box"] = "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab";
            Config ["Settings", "slots"] = 30;
            Config ["Settings", "cooldownMinutes"] = 5;
            Config ["Settings", "maxRadius"] = 5000f;
            Config ["Settings", "pendingSeconds"] = 25f;
            Config ["Settings", "radiationMax"] = 1;
            Config ["Settings", "allowSafeZone"] = true;
            Config ["VERSION"] = Version.ToString ();
        }

        void CheckConfig ()
        {
            if (Config ["VERSION"] == null) {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig ();
            } else if (GetConfig<string> ("VERSION", "") != Version.ToString ()) {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig ();
            }
        }

        protected void ReloadConfig ()
        {
            Config ["VERSION"] = Version.ToString ();

            // NEW CONFIGURATION OPTIONS HERE
            Config ["Settings", "radiationMax"] = GetConfig ("Settings", "radiationMax", 1f);
            // END NEW CONFIGURATION OPTIONS

            PrintToConsole ("Upgrading configuration file");
            SaveConfig ();
        }

        void LoadMessages ()
        {
            lang.RegisterMessages (new Dictionary<string, string>
            {
                {"Inventory: You", "You do not have enough room in your inventory"},
                {"Inventory: Them", "Their inventory does not have enough room"},
                {"Inventory: Generic", "Insufficient inventory space"},

                {"Player: Not Found", "No player found by that name"},
                {"Player: Unknown", "Unknown"},
                {"Player: Yourself", "You cannot trade with yourself"},

                {"Status: Completing", "Completing trade.."},
                {"Status: No Pending", "You have no pending trade requests"},
                {"Status: Pending", "They already have a pending trade request"},
                {"Status: Received", "You have received a trade request from {0}. Type <color=#00FF00>/trade accept</color> to begin trading"},
                {"Status: They Interrupted", "They moved or closed the trade"},
                {"Status: You Interrupted", "You moved or closed the trade"},

                {"Trade: Sent", "Trade request sent"},
                {"Trade: They Declined", "They declined your trade request"},
                {"Trade: You Declined", "You declined their trade request"},
                {"Trade: They Accepted", "{0} accepted."},
                {"Trade: You Accepted", "You accepted."},
                {"Trade: Pending", "Trade pending."},

                {"Denied: Permission", "You lack permission to do that"},
                {"Denied: Privilege", "You do no have building privilege"},
                {"Denied: Swimming", "You cannot do that while swimming"},
                {"Denied: Falling", "You cannot do that while falling"},
                {"Denied: Mounted", "You cannot do that while mounted"},
                {"Denied: Wounded", "You cannot do that while wounded"},
                {"Denied: Irradiated", "You cannot do that while irradiated"},
                {"Denied: Generic", "You cannot do that right now"},
                {"Denied: They Busy", "That player is busy"},
                {"Denied: They Ignored You", "They ignored you"},
                {"Denied: Distance", "Too far away"},
                {"Denied: Ship", "You cannot do that while on a ship"},
                {"Denied: Lift", "You cannot do that while on a lift"},
                {"Denied: Balloon", "You cannot do that while on a balloon"},
                {"Denied: Safe Zone", "You cannot do that while in a safe zone"},

                {"Item: BP", "BP"},

                {"Syntax: Trade Accept", "Invalid syntax. /trade accept"},
                {"Syntax: Trade", "Invalid syntax. /trade \"Player Name\""},

                {"Cooldown: Seconds", "You are doing that too often, try again in a {0} seconds(s)."},
                {"Cooldown: Minutes", "You are doing that too often, try again in a {0} minute(s)."},
            }, this);
        }

        #endregion

        #region Oxide Hooks

        //object CanNetworkTo(BaseNetworkable entity, BasePlayer target)
        //{
        //    if (entity == null || target == null || entity == target) return null;
        //    if (target.IsAdmin) return null;

        //    OnlinePlayer onlinePlayer;
        //    bool IsMyBox = false;
        //    if (onlinePlayers.TryGetValue(target, out onlinePlayer))
        //    {
        //        if (onlinePlayer.View != null && onlinePlayer.View.net.ID == entity.net.ID)
        //        {
        //            IsMyBox = true;
        //        }
        //    }

        //    if (IsTradeBox(entity) && !IsMyBox) return false;

        //    return null;
        //}

        void OnPlayerConnected (BasePlayer player)
        {
            onlinePlayers [player].View = null;
            onlinePlayers [player].Trade = null;
        }

        void OnPlayerDisconnected (BasePlayer player)
        {
            OnlinePlayer onlinePlayer;
            if (onlinePlayers.TryGetValue (player, out onlinePlayer)) {
                if (onlinePlayer.Trade != null) {
                    TradeCloseBoxes (onlinePlayer.Trade);
                } else if (onlinePlayer.View != null) {
                    CloseBoxView (player, onlinePlayer.View);
                }
            }
        }

        void OnPlayerLootEnd (PlayerLoot inventory)
        {
            var player = inventory.GetComponent<BasePlayer> ();
            if (player == null)
                return;

            OnlinePlayer onlinePlayer;
            if (onlinePlayers.TryGetValue (player, out onlinePlayer) && onlinePlayer.View != null) {
                if (onlinePlayer.View == inventory.entitySource && onlinePlayer.Trade != null) {
                    OpenTrade t = onlinePlayer.Trade;

                    if (!t.closing) {
                        t.closing = true;
                        if (!onlinePlayer.Trade.complete) {
                            if (onlinePlayer.Trade.sourcePlayer == player) {
                                TradeReply (t, "Status: They Interrupted", "Status: You Interrupted");
                            } else {
                                TradeReply (t, "Status: You Interrupted", "Status: They Interrupted");
                            }
                        }
                        CloseBoxView (player, (StorageContainer)inventory.entitySource);
                    }
                }
            }
        }

        void OnItemAction (Item item, string cmd)
        {
            if (cmd == "drop") {
                BasePlayer player = item.GetOwnerPlayer ();

                if (player is BasePlayer) {
                    OnlinePlayer onlinePlayer;
                    if (onlinePlayers.TryGetValue (player, out onlinePlayer) && onlinePlayer.Trade != null && player.inventory != null) {
                        if (item.parent == player.inventory.containerMain && !onlinePlayer.Trade.IsInventorySufficient ()) {
                            ShowTrades (onlinePlayer.Trade, "Trade: Pending");
                        }
                    }
                }
            }
        }

        void OnItemAddedToContainer (ItemContainer container, Item item)
        {
            if (container.playerOwner is BasePlayer) {
                OnlinePlayer onlinePlayer;
                if (onlinePlayers.TryGetValue (container.playerOwner, out onlinePlayer) && onlinePlayer.Trade != null) {
                    OpenTrade t = onlinePlayers [container.playerOwner].Trade;

                    if (!t.complete) {
                        t.ResetAcceptance ();

                        if (t.IsValid ()) {
                            ShowTrades (t, "Trade: Pending");
                        } else {
                            TradeCloseBoxes (t);
                        }
                    }
                }
            }
        }

        object CanMoveItem (Item item, PlayerInventory playerLoot, uint targetContainer, int targetSlot)
        {
            var player = playerLoot.GetComponent<BasePlayer> ();
            if (player == null) {
                return null;
            }

            OnlinePlayer onlinePlayer;
            if (onlinePlayers.TryGetValue (player, out onlinePlayer) && onlinePlayer.Trade != null) {
                OpenTrade t = onlinePlayers [player].Trade;
                if (t.closing) {
                    return false;
                }
            }

            return null;
        }

        void OnItemRemovedFromContainer (ItemContainer container, Item item)
        {
            if (container.playerOwner is BasePlayer) {
                OnlinePlayer onlinePlayer;
                if (onlinePlayers.TryGetValue (container.playerOwner, out onlinePlayer) && onlinePlayer.Trade != null) {
                    OpenTrade t = onlinePlayers [container.playerOwner].Trade;
                    if (!t.complete) {
                        t.ResetAcceptance ();

                        if (t.IsValid ()) {
                            ShowTrades (t, "Trade: Pending");
                        } else {
                            TradeCloseBoxes (t);
                        }
                    }
                }
            }
        }

        #endregion

        #region Commands

        [ChatCommand ("trade")]
        void cmdTrade (BasePlayer player, string command, string [] args)
        {
            if (args.Length == 1) {
                if (args [0] == "accept") {
                    if (!CanPlayerTrade (player, "trade.accept"))
                        return;

                    AcceptTrade (player);
                    return;
                }
            }

            if (args.Length != 1) {
                if (pendingTrades.ContainsKey (player)) {
                    SendReply (player, GetMsg ("Syntax: Trade Accept", player));
                } else {
                    SendReply (player, GetMsg ("Syntax: Trade", player));
                }

                return;
            }

            var targetPlayer = FindPlayerByPartialName (args [0]);
            if (targetPlayer == null) {
                SendReply (player, GetMsg ("Player: Not Found", player));
                return;
            }

            if (targetPlayer == player) {
                SendReply (player, GetMsg ("Player: Yourself", player));
                return;
            }

            if (!CheckCooldown (player)) {
                return;
            }

            if (Ignore != null) {
                var IsIgnored = Ignore.Call ("IsIgnored", player.UserIDString, targetPlayer.UserIDString);
                if ((bool)IsIgnored == true) {
                    SendReply (player, GetMsg ("Denied: They Ignored You", player));
                    return;
                }
            }

            OnlinePlayer onlineTargetPlayer;
            if (onlinePlayers.TryGetValue (targetPlayer, out onlineTargetPlayer) && onlineTargetPlayer.Trade != null) {
                SendReply (player, GetMsg ("Denied: They Busy", player));
                return;
            }

            if (maxRadius > 0) {
                if (targetPlayer.Distance (player) > maxRadius) {
                    SendReply (player, GetMsg ("Denied: Distance", player));
                    return;
                }
            }

            if (!CanPlayerTrade (player, "trade.use"))
                return;

            if (pendingTrades.ContainsKey (player)) {
                SendReply (player, GetMsg ("Status: Pending", player));
            } else {
                SendReply (targetPlayer, GetMsg ("Status: Received", targetPlayer), player.displayName);
                SendReply (player, GetMsg ("Trade: Sent", player));
                var pendingTrade = new PendingTrade (targetPlayer);
                pendingTrades.Add (player, pendingTrade);

                pendingTrade.Timer = timer.In (pendingSeconds, delegate () {
                    if (pendingTrades.ContainsKey (player)) {
                        pendingTrades.Remove (player);
                        SendReply (player, GetMsg ("Trade: They Declined", player));
                        SendReply (targetPlayer, GetMsg ("Trade: You Declined", targetPlayer));
                    }
                });
            }
        }

        [ConsoleCommand ("trade")]
        void ccTrade (ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
                return;
            if (arg.Connection.player == null)
                return;
            cmdTrade (arg.Connection.player as BasePlayer, arg.cmd.Name, arg.Args);
        }

        [ConsoleCommand ("trade.decline")]
        void ccTradeDecline (ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
                return;
            if (arg.Connection.player == null)
                return;
            var player = arg.Connection.player as BasePlayer;

            OnlinePlayer onlinePlayer;
            if (onlinePlayers.TryGetValue (player, out onlinePlayer) && onlinePlayer.Trade != null) {
                onlinePlayer.Trade.closing = true;
                var target = onlinePlayer.Trade.GetOther (player);
                SendReply (player, GetMsg ("Trade: You Declined", player));
                SendReply (target, GetMsg ("Trade: They Declined", target));

                TradeCloseBoxes (onlinePlayer.Trade);
            } else if (player is BasePlayer) {
                HideTrade (player);
            }
        }

        [ConsoleCommand ("trade.accept")]
        void ccTradeAccept (ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
                return;
            if (arg.Connection.player == null)
                return;
            var player = arg.Connection.player as BasePlayer;

            TradeAccept (player);
        }

        void TradeAccept (BasePlayer player)
        {
            OnlinePlayer onlinePlayer;
            if (onlinePlayers.TryGetValue (player, out onlinePlayer) && onlinePlayer.Trade != null) {
                var t = onlinePlayers [player].Trade;
                if (t.sourcePlayer == player) {
                    if (!CheckSourceInventory (t)) {
                        return;
                    }

                    t.sourceAccept = true;
                } else if (t.targetPlayer == player) {
                    if (!CheckTargetInventory (t)) {
                        return;
                    }

                    t.targetAccept = true;
                }

                if (t.targetAccept == true && t.sourceAccept == true) {
                    CompleteTrade (t);
                } else {
                    ShowTrades (t, "Trade: Pending");
                }
            } else if (player is BasePlayer) {
                HideTrade (player);
            }
        }

        void CompleteTrade (OpenTrade t)
        {
            if (t.IsInventorySufficient ()) {
                t.ResetAcceptance ();
                ShowTrades (t, "Inventory: Generic");
                return;
            }
            if (t.complete) {
                return;
            }
            t.complete = true;
            t.closing = true;

            TradeCooldown (t);

            TradeReply (t, "Status: Completing");
            Interface.Oxide.NextTick (() => FinishTrade (t));
        }

        bool CheckSourceInventory (OpenTrade t)
        {
            var i = t.target.View.inventory.itemList.Count;
            var f = t.source.containerMain.capacity - t.source.containerMain.itemList.Count;
            if (i > f) {

                TradeReply (t, "Inventory: Them", "Inventory: You");

                t.sourceAccept = false;
                ShowTrades (t, "Inventory: Generic");
                return false;
            }

            return true;
        }

        bool CheckTargetInventory (OpenTrade t)
        {
            var i = t.source.View.inventory.itemList.Count;
            var f = t.target.containerMain.capacity - t.target.containerMain.itemList.Count;
            if (i > f) {
                TradeReply (t, "Inventory: You", "Inventory: Them");
                t.targetAccept = false;
                ShowTrades (t, "Inventory: Generic");
                return false;
            }

            return true;
        }

        #endregion

        #region GUI

        public string jsonTrade = @"[{""name"":""TradeMsg"",""parent"":""Overlay"",""components"":[{""type"":""UnityEngine.UI.Image"",""color"":""0 0 0 0.76"",""imagetype"":""Filled""},{""type"":""RectTransform"",""anchormax"":""0.77 0.91"",""anchormin"":""0.24 0.52""}]},{""name"":""SourceLabel{1}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""{sourcename}"",""fontSize"":""16"",""align"":""UpperLeft""},{""type"":""RectTransform"",""anchormax"":""0.48 0.98"",""anchormin"":""0.03 0.91""}]},{""name"":""TargetLabel{2}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""{targetname}"",""fontSize"":""17""},{""type"":""RectTransform"",""anchormax"":""0.97 0.98"",""anchormin"":""0.52 0.91""}]},{""name"":""SourceItemsPanel{3}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.RawImage"",""color"":""0 0 0 0.52"",""imagetype"":""Filled""},{""type"":""RectTransform"",""anchormax"":""0.47 0.9"",""anchormin"":""0.03 0.13""}]},{""name"":""SourceItemsText"",""parent"":""SourceItemsPanel{3}"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""{sourceitems}"",""fontSize"":""14"",""align"":""UpperLeft""},{""type"":""RectTransform"",""anchormax"":""0.99 0.99"",""anchormin"":""0.01 0.01""}]},{""name"":""TargetItemsPanel{4}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.RawImage"",""color"":""0 0 0 0.52"",""imagetype"":""Filled""},{""type"":""RectTransform"",""anchormax"":""0.96 0.9"",""anchormin"":""0.52 0.13""}]},{""name"":""TargetItemsText"",""parent"":""TargetItemsPanel{4}"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""{targetitems}"",""fontSize"":""14"",""align"":""UpperLeft""},{""type"":""RectTransform"",""anchormax"":""0.99 0.99"",""anchormin"":""0.01 0.01""}]},{""name"":""AcceptTradeButton{5}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.Button"",""color"":""0 0.95 0.14 0.54"",""command"":""trade.accept""},{""type"":""RectTransform"",""anchormax"":""0.47 0.09"",""anchormin"":""0.35 0.03""}]},{""name"":""AcceptTradeLabel"",""parent"":""AcceptTradeButton{5}"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""Accept"",""fontSize"":""13"",""align"":""MiddleCenter""},{""type"":""RectTransform"",""anchormax"":""1 1"",""anchormin"":""0 0""}]},{""name"":""DeclineTradeButton{6}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.Button"",""color"":""0.95 0 0.02 0.61"",""command"":""trade.decline""},{""type"":""RectTransform"",""anchormax"":""0.15 0.09"",""anchormin"":""0.03 0.03""}]},{""name"":""DeclineTradeLabel"",""parent"":""DeclineTradeButton{6}"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""Decline"",""fontSize"":""13"",""align"":""MiddleCenter""},{""type"":""RectTransform"",""anchormax"":""1 1"",""anchormin"":""0 0""}]},{""name"":""TargetStatusLabel{7}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""{targetstatus}"",""fontSize"":""14"",""align"":""UpperLeft""},{""type"":""RectTransform"",""anchormax"":""0.97 0.09"",""anchormin"":""0.52 0.01""}]}]
";
        private void ShowTrade (BasePlayer player, OpenTrade trade, string status)
        {
            HideTrade (player);

            OnlinePlayer onlinePlayer;
            if (!onlinePlayers.TryGetValue (player, out onlinePlayer)) {
                return;
            }

            if (onlinePlayer.View == null) {
                return;
            }

            StorageContainer sourceContainer = onlinePlayer.View;
            StorageContainer targetContainer = null;
            BasePlayer target = null;

            if (trade.sourcePlayer == player && trade.target.View != null) {
                targetContainer = trade.target.View;
                target = trade.targetPlayer;
                if (target is BasePlayer) {
                    if (trade.targetAccept) {
                        status += string.Format (GetMsg ("Trade: They Accepted", player), CleanName (target.displayName));
                    } else if (trade.sourceAccept) {
                        status += GetMsg ("Trade: You Accepted", player);
                    }
                } else {
                    return;
                }
            } else if (trade.targetPlayer == player && trade.source.View != null) {
                targetContainer = trade.source.View;
                target = trade.sourcePlayer;
                if (target is BasePlayer) {
                    if (trade.sourceAccept) {
                        status += string.Format (GetMsg ("Trade: They Accepted", player), CleanName (target.displayName));
                    } else if (trade.targetAccept) {
                        status += GetMsg ("Trade: You Accepted", player);
                    }
                } else {
                    return;
                }
            }

            if (targetContainer == null || target == null) {
                return;
            }

            string send = jsonTrade;
            for (int i = 1; i < 100; i++) {
                send = send.Replace ("{" + i + "}", Oxide.Core.Random.Range (9999, 99999).ToString ());
            }

            send = send.Replace ("{sourcename}", CleanName (player.displayName));
            if (target != null) {
                send = send.Replace ("{targetname}", CleanName (target.displayName));
            } else {
                send = send.Replace ("{targetname}", GetMsg ("Player: Unknown", player));
            }
            send = send.Replace ("{targetstatus}", status);

            var slotsAvailable = target.inventory.containerMain.capacity - (target.inventory.containerMain.itemList.Count);
            List<string> sourceItems = new List<string> ();
            var x = 1;
            foreach (Item i in sourceContainer.inventory.itemList) {
                string n = "";
                if (i.IsBlueprint ()) {
                    n = i.amount + " x <color=lightblue>" + i.blueprintTargetDef.displayName.english + " [" + GetMsg ("Item: BP", player) + "]</color>";
                } else {
                    n = i.amount + " x " + i.info.displayName.english;
                    if(i.info.condition.enabled)
                    {
                        var conditionPercent = System.Math.Round(i.condition * 100 / i.info.condition.max, 0);
                        if(conditionPercent <= 25f)
                        {
                            n += " [<color=red>" + conditionPercent + "%</color>]";
                        }
                        else if(conditionPercent <= 75f)
                        {
                            n += " [<color=yellow>" + conditionPercent + "%</color>]";
                        }
                        else if(conditionPercent <= 99f)
                        {
                            n += " [<color=green>" + conditionPercent + "%</color>]";
                        }
                    }
                }

                if (x > slotsAvailable) {
                    n = "<color=red>" + n + "</color>";
                }
                x++;

                sourceItems.Add (n);
            }

            send = send.Replace ("{sourceitems}", string.Join ("\n", sourceItems.ToArray ()));

            if (player != target) {
                slotsAvailable = player.inventory.containerMain.capacity - (player.inventory.containerMain.itemList.Count);
                List<string> targetItems = new List<string> ();
                x = 1;
                if (targetContainer != null) {
                    foreach (Item i in targetContainer.inventory.itemList) {
                        string n2 = "";
                        if (i.IsBlueprint ()) {
                            n2 = i.amount + " x <color=lightblue>" + i.blueprintTargetDef.displayName.english + " [" + GetMsg ("Item: BP", player) + "]</color>";
                        } else {
                            n2 = i.amount + " x " + i.info.displayName.english;
                            if (i.info.condition.enabled)
                            {
                                var conditionPercent = System.Math.Round(i.condition * 100 / i.info.condition.max, 0);
                                if (conditionPercent <= 25f)
                                {
                                    n2 += " [<color=red>" + conditionPercent + "%</color>]";
                                }
                                else if (conditionPercent <= 75f)
                                {
                                    n2 += " [<color=yellow>" + conditionPercent + "%</color>]";
                                }
                                else if (conditionPercent <= 99f)
                                {
                                    n2 += " [<color=green>" + conditionPercent + "%</color>]";
                                }
                            }
                        }
                        if (x > slotsAvailable) {
                            n2 = "<color=red>" + n2 + "</color>";
                        }
                        x++;
                        targetItems.Add (n2);
                    }
                }

                send = send.Replace ("{targetitems}", string.Join ("\n", targetItems.ToArray ()));
            } else {
                send = send.Replace ("{targetitems}", "");
            }

            CommunityEntity.ServerInstance.ClientRPCEx (new Network.SendInfo { connection = player.net.connection }, null, "AddUI", send);
        }

        private void HideTrade (BasePlayer player)
        {
            if (player.IsConnected) {
                CommunityEntity.ServerInstance.ClientRPCEx (new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "TradeMsg");
            }
        }

        #endregion

        #region Core Methods

        bool CheckCooldown (BasePlayer player)
        {
            if (cooldownMinutes > 0) {
                DateTime startTime;
                if (tradeCooldowns.TryGetValue (player.UserIDString, out startTime)) {
                    var endTime = DateTime.Now;

                    var span = endTime.Subtract (startTime);
                    if (span.TotalMinutes > 0 && span.TotalMinutes < Convert.ToDouble (cooldownMinutes)) {
                        double timeleft = System.Math.Round (Convert.ToDouble (cooldownMinutes) - span.TotalMinutes, 2);
                        if (timeleft < 1) {
                            double timelefts = System.Math.Round ((Convert.ToDouble (cooldownMinutes) * 60) - span.TotalSeconds);
                            SendReply (player, string.Format (GetMsg ("Cooldown: Seconds", player), timelefts.ToString ()));
                        } else {
                            SendReply (player, string.Format (GetMsg ("Cooldown: Minutes", player), System.Math.Round (timeleft).ToString ()));
                        }
                        return false;
                    } else {
                        tradeCooldowns.Remove (player.UserIDString);
                    }
                }
            }

            return true;
        }

        void TradeCloseBoxes (OpenTrade trade)
        {
            if (trade.IsSourceValid ()) {
                CloseBoxView (trade.sourcePlayer, trade.source.View);
            }

            if (trade.IsTargetValid () && trade.targetPlayer != trade.sourcePlayer) {
                CloseBoxView (trade.targetPlayer, trade.target.View);
            }
        }

        void TradeReply (OpenTrade trade, string msg, string msg2 = null)
        {
            if (msg2 == null) {
                msg2 = msg;
            }

            if (trade.targetPlayer != null) {
                SendReply (trade.targetPlayer, GetMsg (msg, trade.targetPlayer));
            }

            if (trade.sourcePlayer != null) {
                SendReply (trade.sourcePlayer, GetMsg (msg2, trade.sourcePlayer));
            }
        }

        void ShowTrades (OpenTrade trade, string msg)
        {
            ShowTrade (trade.sourcePlayer, trade, GetMsg (msg, trade.sourcePlayer));
            ShowTrade (trade.targetPlayer, trade, GetMsg (msg, trade.targetPlayer));
        }

        void TradeCooldown (OpenTrade trade)
        {
            PlayerCooldown (trade.targetPlayer);
            PlayerCooldown (trade.sourcePlayer);
        }

        void PlayerCooldown (BasePlayer player)
        {
            if (player.IsAdmin) {
                return;
            }
            if (tradeCooldowns.ContainsKey (player.UserIDString)) {
                tradeCooldowns.Remove (player.UserIDString);
            }

            tradeCooldowns.Add (player.UserIDString, DateTime.Now);
        }

        void FinishTrade (OpenTrade t)
        {
            foreach (var i in t.source.View.inventory.itemList.ToArray ()) {
                i.MoveToContainer (t.target.containerMain);
            }

            foreach (var i in t.target.View.inventory.itemList.ToArray ()) {
                i.MoveToContainer (t.source.containerMain);
            }

            TradeCloseBoxes (t);
        }

        void AcceptTrade (BasePlayer player)
        {
            BasePlayer source = null;

            PendingTrade pendingTrade = null;

            foreach (KeyValuePair<BasePlayer, PendingTrade> kvp in pendingTrades) {
                if (kvp.Value.Target == player) {
                    pendingTrade = kvp.Value;
                    source = kvp.Key;
                    break;
                }
            }

            if (source != null && pendingTrade != null) {
                pendingTrade.Destroy ();
                pendingTrades.Remove (source);
                StartTrades (source, player);
            } else {
                SendReply (player, GetMsg ("Status: No Pending", player));
            }
        }

        void StartTrades (BasePlayer source, BasePlayer target)
        {
            var trade = new OpenTrade (onlinePlayers [source], onlinePlayers [target]);
            StartTrade (source, target, trade);
            if (source != target) {
                StartTrade (target, source, trade);
            }
        }

        void StartTrade (BasePlayer source, BasePlayer target, OpenTrade trade)
        {
            OpenBox (source, source);

            if (!openTrades.Contains (trade)) {
                openTrades.Add (trade);
            }
            onlinePlayers [source].Trade = trade;

            timer.In (0.1f, () => ShowTrade (source, trade, GetMsg ("Trade: Pending", source)));
        }

        void OpenBox (BasePlayer player, BaseEntity target)
        {
            SubscribeAll ();
            var ply = onlinePlayers [player];
            if (ply.View == null) {
                OpenBoxView (player, target);
                return;
            }

            CloseBoxView (player, ply.View);
            timer.In (1f, () => OpenBoxView (player, target));
        }

        void OpenBoxView (BasePlayer player, BaseEntity targArg)
        {
            var pos = new Vector3 (player.transform.position.x, player.transform.position.y - 1, player.transform.position.z);
            var boxContainer = GameManager.server.CreateEntity (box, pos) as StorageContainer;
            boxContainer.GetComponent<DestroyOnGroundMissing> ().enabled = false;
            boxContainer.GetComponent<GroundWatch> ().enabled = false;
            boxContainer.transform.position = pos;

            if (!boxContainer) return;

            StorageContainer view = boxContainer as StorageContainer;
            view.limitNetworking = true;
            player.EndLooting ();
            if (targArg is BasePlayer) {

                BasePlayer target = targArg as BasePlayer;
                view.CreateInventory(true);
                view.inventory.playerOwner = player;
                view.inventory.ServerInitialize (null, slots);

                view.enableSaving = false;
                view.Spawn ();

                onlinePlayers [player].View = view;
                timer.In (0.1f, () => view.PlayerOpenLoot (player));
            }
        }

        void CloseBoxView (BasePlayer player, StorageContainer view)
        {

            OnlinePlayer onlinePlayer;
            if (!onlinePlayers.TryGetValue (player, out onlinePlayer)) return;
            if (onlinePlayer.View == null) return;

            HideTrade (player);
            if (onlinePlayer.Trade != null) {
                OpenTrade t = onlinePlayer.Trade;
                t.closing = true;

                if (t.sourcePlayer == player && t.targetPlayer != player && t.target.View != null) {
                    t.target.Trade = null;
                    CloseBoxView (t.targetPlayer, t.target.View);
                } else if (t.targetPlayer == player && t.sourcePlayer != player && t.source.View != null) {
                    t.source.Trade = null;
                    CloseBoxView (t.sourcePlayer, t.source.View);
                }

                if (openTrades.Contains (t)) {
                    openTrades.Remove (t);
                }
            }

            if (view.inventory.itemList.Count > 0) {
                foreach (Item item in view.inventory.itemList.ToArray ()) {
                    if (item.position != -1) {
                        item.MoveToContainer (player.inventory.containerMain);
                    }
                }
            }

            if (view.inventory.itemList.Count > 0) {
                foreach (Item item in view.inventory.itemList.ToArray ()) {
                    if (item.position != -1) {
                        item.MoveToContainer (player.inventory.containerBelt);
                    }
                }
            }

            if (player.inventory.loot.entitySource != null) {
                player.inventory.loot.Invoke ("SendUpdate", 0.1f);
                view.SendMessage ("PlayerStoppedLooting", player, SendMessageOptions.DontRequireReceiver);
                player.SendConsoleCommand ("inventory.endloot", null);
            }

            player.inventory.loot.entitySource = null;
            player.inventory.loot.itemSource = null;
            player.inventory.loot.containers = new List<ItemContainer> ();

            onlinePlayer.Clear ();

            view.Kill (BaseNetworkable.DestroyMode.None);

            if (onlinePlayers.Values.Count (p => p.View != null) <= 0) {
                UnsubscribeAll ();
            }
        }

        bool CanPlayerTrade (BasePlayer player, string perm)
        {
            if (!permission.UserHasPermission (player.UserIDString, perm)) {
                SendReply (player, GetMsg ("Denied: Permission", player));
                return false;
            }

            if (!player.CanBuild ()) {
                SendReply (player, GetMsg ("Denied: Privilege", player));
                return false;
            }

            if (radiationMax > 0 && player.radiationLevel > radiationMax) {
                SendReply (player, GetMsg ("Denied: Irradiated", player));
                return false;
            }

            if (player.IsSwimming ()) {
                SendReply (player, GetMsg ("Denied: Swimming", player));
                return false;
            }

            if (!player.IsOnGround () || player.IsFlying || player.isInAir) {
                SendReply (player, GetMsg ("Denied: Falling", player));
                return false;
            }

            if (player.isMounted) {
                SendReply (player, GetMsg ("Denied: Mounted", player));
                return false;
            }

            if (player.IsWounded ()) {
                SendReply (player, GetMsg ("Denied: Wounded", player));
                return false;
            }

            if (player.GetComponentInParent<CargoShip> ()) {
                SendReply (player, GetMsg ("Denied: Ship", player));
                return false;
            }

            if (player.GetComponentInParent<HotAirBalloon> ()) {
                SendReply (player, GetMsg ("Denied: Balloon", player));
                return false;
            }

            if (player.GetComponentInParent<Lift> ()) {
                SendReply (player, GetMsg ("Denied: Lift", player));
                return false;
            }

            if (!allowSafeZone && player.InSafeZone ()) {
                SendReply (player, GetMsg ("Denied: Safe Zone", player));
                return false;
            }

            var canTrade = Interface.Call ("CanTrade", player);
            if (canTrade != null) {
                if (canTrade is string) {
                    SendReply (player, Convert.ToString (canTrade));
                } else {
                    SendReply (player, GetMsg ("Denied: Generic", player));
                }
                return false;
            }

            return true;
        }

        #endregion

        #region HelpText
        private void SendHelpText (BasePlayer player)
        {
            var sb = new StringBuilder ()
               .Append ("Trade by <color=#ce422b>http://rustservers.io</color>\n")
               .Append ("  ").Append ("<color=\"#ffd479\">/trade \"Player Name\"</color> - Send trade request").Append ("\n")
               .Append ("  ").Append ("<color=\"#ffd479\">/trade accept</color> - Accept trade request").Append ("\n");
            player.ChatMessage (sb.ToString ());
        }
        #endregion

        #region Helper methods

        private bool IsTradeBox (BaseNetworkable entity)
        {
            foreach (KeyValuePair<BasePlayer, OnlinePlayer> kvp in onlinePlayers) {
                if (kvp.Value.View != null && kvp.Value.View.net != null && entity.net != null && kvp.Value.View.net.ID == entity.net.ID) {
                    return true;
                }
            }

            return false;
        }

        bool hasAccess (BasePlayer player, string permissionname)
        {
            if (player.IsAdmin) return true;
            return permission.UserHasPermission (player.UserIDString, permissionname);
        }

        private BasePlayer FindPlayerByPartialName (string name)
        {
            if (string.IsNullOrEmpty (name))
                return null;
            BasePlayer player = null;
            name = name.ToLower ();
            var awakePlayers = BasePlayer.activePlayerList.ToArray ();
            foreach (var p in awakePlayers) {
                if (p.net == null || p.net.connection == null)
                    continue;

                if (p.displayName == name) {
                    if (player != null)
                        return null;
                    player = p;
                }
            }

            if (player != null)
                return player;
            foreach (var p in awakePlayers) {
                if (p.net == null || p.net.connection == null)
                    continue;

                if (p.displayName.ToLower ().IndexOf (name) >= 0) {
                    if (player != null)
                        return null;
                    player = p;
                }
            }

            return player;
        }

        private T GetConfig<T> (string name, T defaultValue)
        {
            if (Config [name] == null) {
                return defaultValue;
            }

            return (T)Convert.ChangeType (Config [name], typeof (T));
        }

        private T GetConfig<T> (string name, string name2, T defaultValue)
        {
            if (Config [name, name2] == null) {
                return defaultValue;
            }

            return (T)Convert.ChangeType (Config [name, name2], typeof (T));
        }

        string GetMsg (string key, BasePlayer player = null)
        {
            return lang.GetMessage (key, this, player == null ? null : player.UserIDString);
        }

        private string CleanName (string name)
        {
            return JsonConvert.ToString (name.Trim ()).Replace ("\"", "");
        }

        #endregion
    }
}

// --- End of file: Trade.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/teleport-marker ---
// --- Original File Path: T/TeleportMarker/TeleportMarker.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using ProtoBuf;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Teleport Marker", "Talha", "1.0.6")]
    [Description("Authorized players can teleport to map markers with that plugin.")]
    public class TeleportMarker : RustPlugin
    {
		private const string permUse = "teleportmarker.use";
        private ConfigData config;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Admins can teleport without permission")]
            public bool admins;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                admins = true,
            };
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt.");
                return;
            }
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        private void Message(BasePlayer player, string key, params object[] args)
        {
            var message = string.Format(lang.GetMessage(key, this, player.UserIDString), args);
            player.ChatMessage(message);
        }
        private void OnServerInitialized()
        {
            permission.RegisterPermission(permUse, this);
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Teleported"] = "You are teleported to <color=#FFA600>{0}</color>.",
                ["Cooldown"] = "Your health has been set to {0}, you can teleport again."
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Teleported"] = "<color=#FFA600>{0}</color> konumuna ışınlandınız.",
                ["Cooldown"] = "Canın eskisi gibi <color=#FFA600>{0}</color> olarak ayarlandı, yeniden ışınlanabilirsiniz."
            }, this, "tr");
        }
        private void TP(BasePlayer player, MapNote note)
        {
            player.flyhackPauseTime = 10f;
            var health = player.health;
            var health2 = 100 - health;
            player._health = 100000;
            var pos = note.worldPosition + new Vector3(0,120,0);;
            player.Teleport(pos);
            Message(player, "Teleported", pos);
            timer.Once(6f, () => { if (player == null) return; Message(player, "Cooldown", (100 - health2)); player.SetMaxHealth(100); player.Hurt(health2); });
        }
        private void OnMapMarkerAdded(BasePlayer player, MapNote note)
        {
            if (player == null || note == null || player.isMounted || !player.IsAlive()) return;
            if (config.admins == true)
            {
                if (player.IsAdmin) {TP(player, note);}
            }
            else
            {
                if (player.IPlayer.HasPermission(permUse)) {TP(player, note);}
            }
        }
    }
}

// --- End of file: TeleportMarker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/true-pve ---
// --- Original File Path: T/TruePVE/TruePVE.cs ---

﻿using Facepunch;
using Facepunch.Math;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using Rust.Ai.Gen2;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("TruePVE", "nivex", "2.2.8")]
    [Description("Improvement of the default Rust PVE behavior")]
    // Thanks to the original author, ignignokt84.
    internal class TruePVE : RustPlugin
    {
        #region Variables
        // config/data container
        private Configuration config = new();

        [PluginReference]
        Plugin ZoneManager, LiteZones, Clans, Friends, AbandonedBases, RaidableBases;

        public string usageString;
        public enum Command { def, sched, trace, usage, enable, sleepers };
        public enum DamageResult { None, Allow, Block }

        [Flags]
        public enum RuleFlags : ulong
        {
            None = 0,
            AdminsHurtSleepers = 1uL << 1,
            AdminsHurtPlayers = 1uL << 2,
            AnimalsIgnoreSleepers = 1uL << 3,
            AuthorizedDamage = 1uL << 4,
            AuthorizedDamageRequiresOwnership = 1uL << 5,
            CupboardOwnership = 1uL << 6,
            FriendlyFire = 1uL << 7,
            HeliDamageLocked = 1uL << 8,
            HumanNPCDamage = 1uL << 9,
            LockedBoxesImmortal = 1uL << 10,
            LockedDoorsImmortal = 1uL << 11,
            NoPlayerDamageToCar = 1uL << 12,
            NoPlayerDamageToMini = 1uL << 13,
            NoPlayerDamageToScrap = 1uL << 14,
            NoHeliDamage = 1uL << 15,
            NoHeliDamagePlayer = 1uL << 16,
            NoHeliDamageQuarry = 1uL << 17,
            NoHeliDamageRidableHorses = 1uL << 18,
            NoHeliDamageSleepers = 1uL << 19,
            NoMLRSDamage = 1uL << 20,
            NpcsCanHurtAnything = 1uL << 21,
            PlayerSamSitesIgnorePlayers = 1uL << 22,
            ProtectedSleepers = 1uL << 23,
            TrapsIgnorePlayers = 1uL << 24,
            TrapsIgnoreScientist = 1uL << 25,
            TurretsIgnorePlayers = 1uL << 26,
            TurretsIgnoreScientist = 1uL << 27,
            StaticTurretsIgnoreScientist = 1uL << 28,
            TwigDamage = 1uL << 29,
            TwigDamageRequiresOwnership = 1uL << 30,
            VehiclesTakeCollisionDamageWithoutDriver = 1uL << 31,
            SamSitesIgnoreMLRS = 1uL << 32,
            SelfDamage = 1uL << 33,
            StaticSamSitesIgnorePlayers = 1uL << 34,
            StaticTurretsIgnorePlayers = 1uL << 35,
            SafeZoneTurretsIgnorePlayers = 1uL << 36,
            SuicideBlocked = 1uL << 37,
            NoHeliDamageBuildings = 1uL << 38,
            WoodenDamage = 1uL << 39,
            WoodenDamageRequiresOwnership = 1uL << 40,
            AuthorizedDamageCheckPrivilege = 1uL << 41,
            ExcludeTugboatFromImmortalFlags = 1uL << 42,
            LockedVehiclesImmortal = 1uL << 43,
            TurretsIgnoreBradley = 1uL << 44,
        }

        private Timer scheduleUpdateTimer;                              // timer to check for schedule updates
        private bool shareRedirectDudEnabled;                           // undocumented. UAYOR.
        private RuleSet dudRuleSet;                                     // dud ruleset when no locations are shared
        private RuleSet currentRuleSet;                                 // current ruleset
        private string currentBroadcastMessage;                         // current broadcast message
        private bool useZones;                                          // internal useZones flag
        private const string Any = "any";                               // constant "any" string for rules
        private const string AllZones = "allzones";                     // constant "allzones" string for mappings
        private const string PermCanMap = "truepve.canmap";             // permission for mapping command
        private bool animalsIgnoreSleepers;                             // toggle flag to protect sleepers
        private bool trace;                                             // trace flag
        private const string traceFile = "ruletrace";                   // tracefile name
        private const float traceTimeout = 300f;                        // auto-disable trace after 300s (5m)
        private Timer traceTimer;                                       // trace timeout timer
        private bool tpveEnabled = true;                                // toggle flag for damage handling
        private List<DamageType> _damageTypes = new()
        {
            DamageType.Arrow,
            DamageType.Blunt,
            DamageType.Bullet,
            DamageType.Explosion,
            DamageType.Cold,
            DamageType.Heat,
            DamageType.Generic,
            DamageType.Slash,
            DamageType.Stab,
        };

        private uint maincannonshell = 3032863244;
        private uint trainbarricade = 1221760186;
        private uint trainbarricadeheavy = 1363243026;
        private uint loot_trash = 3279100614;
        private uint giftbox_loot = 2216891097;
        private uint campfire = 4160694184;
        private uint oilfireballsmall = 3550347674;
        private uint heli_napalm = 184893264;
        private uint rocket_heli_napalm = 200672762;
        private uint rocket_heli = 129320027;

        private bool excludeAllZones;
        private bool twigOutputHandlerEnabled;
        private readonly List<ulong> _waiting = new();
        private readonly HashSet<string> _deployables = new();
        private readonly HashSet<string> exclusionLocationsSet = new(StringComparer.OrdinalIgnoreCase);
        private readonly Dictionary<ulong, List<PlayerExclusion>> playerDelayExclusions = new();
        private readonly Dictionary<string, RuleSet> ruleSetByNameDictionary = new(StringComparer.OrdinalIgnoreCase);
        private readonly TimedCache<bool?> _npcCache = new (TimeSpan.FromMinutes(1));

        public class TimedCache<T>
        {
            public readonly struct Entry
            {
                public readonly T Value;
                public readonly DateTime Timestamp;

                public Entry(T value)
                {
                    Value = value;
                    Timestamp = DateTime.UtcNow;
                }
            }

            private readonly Dictionary<string, Entry> _cache;
            private readonly TimeSpan _cacheDuration;
            private readonly List<string> _remove = new();
            private readonly int _maxCapacity;

            public TimedCache(TimeSpan cacheDuration, int maxCapacity = 500)
            {
                _cacheDuration = cacheDuration;
                _maxCapacity = maxCapacity;
                _cache = new(maxCapacity);
            }

            public bool TryGetValue(string key, out object value)
            {
                if (_cache.TryGetValue(key, out Entry entry))
                {
                    if (DateTime.UtcNow - entry.Timestamp < _cacheDuration)
                    {
                        value = entry.Value;
                        return true;
                    }
                    else
                    {
                        _cache.Remove(key);
                    }
                }

                value = null;
                return false;
            }

            public T Set(string key, T value)
            {
                if (_cache.Count >= _maxCapacity)
                {
                    RemoveOldest();
                }

                _cache[key] = new(value);

                if (_cache.Count == 1)
                {
                    InvokeHandler.Instance.InvokeRepeating(OnTick, 1f, 1f);
                }

                return value;
            }

            private void OnTick()
            {
                var now = DateTime.UtcNow;

                foreach (var kvp in _cache)
                {
                    if (now - kvp.Value.Timestamp >= _cacheDuration)
                    {
                        _remove.Add(kvp.Key);
                    }
                }

                if (_remove.Count > 0)
                {
                    foreach (var key in _remove)
                    {
                        _cache.Remove(key);
                    }

                    if (_cache.Count == 0)
                    {
                        CancelInvoke();
                    }

                    _remove.Clear();
                }
            }

            private void RemoveOldest()
            {
                KeyValuePair<string, Entry> oldest = default;
                bool isFirst = true;

                foreach (var kvp in _cache)
                {
                    if (isFirst || kvp.Value.Timestamp < oldest.Value.Timestamp)
                    {
                        oldest = kvp;
                        isFirst = false;
                    }
                }

                _cache.Remove(oldest.Key);
            }

            public void CancelInvoke()
            {
                InvokeHandler.Instance.CancelInvoke(OnTick);
                _cache.Clear();
            }
        }

        private class PlayerExclusion : Pool.IPooled
        {
            public Plugin plugin;
            public float time;
            public bool IsExpired => Time.time > time;
            public void EnterPool()
            {
                plugin = null;
                time = 0f;
            }
            public void LeavePool()
            {
            }
        }

        #endregion

        #region Loading/Unloading

		protected new static void Puts(string format, params object[] args)
        {
            if (!string.IsNullOrEmpty(format))
            {
                Interface.Oxide.LogInfo("[{0}] {1}", "TruePVE", (args.Length != 0) ? string.Format(format, args) : format);
            }
        }
		
        private void Unload()
        {
            scheduleUpdateTimer?.Destroy();
            _npcCache.CancelInvoke();
            SaveData();
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Name == "ZoneManager")
                ZoneManager = plugin;
            if (plugin.Name == "LiteZones")
                LiteZones = plugin;
            if (ZoneManager != null || LiteZones != null)
                useZones = config == null || config.options.useZones;
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin.Name == "ZoneManager")
                ZoneManager = null;
            if (plugin.Name == "LiteZones")
                LiteZones = null;
            if (ZoneManager == null && LiteZones == null)
                useZones = false;
            traceTimer?.Destroy();
        }

        private void Init()
        {
            Unsubscribe(nameof(OnTimedExplosiveExplode));
			Unsubscribe(nameof(CanWaterBallSplash));
            Unsubscribe(nameof(OnEntityMarkHostile));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityEnter));
            Unsubscribe(nameof(OnTurretTarget));
            Unsubscribe(nameof(OnWallpaperRemove));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnPlayerConnected));
            Unsubscribe(nameof(OnSamSiteTarget));
            Unsubscribe(nameof(OnTrapTrigger));
            Unsubscribe(nameof(OnNpcTarget));
            Unsubscribe(nameof(OnMlrsFire));
            // register console commands automagically
            foreach (Command command in Enum.GetValues(typeof(Command)))
            {
                AddCovalenceCommand($"tpve.{command}", nameof(CommandDelegator));
            }
            // register chat commands
            AddCovalenceCommand("tpve_prod", nameof(CommandDelegator));
            AddCovalenceCommand("tpve_enable", nameof(CommandDelegator));
            AddCovalenceCommand("tpve", nameof(CommandDelegator));
            permission.RegisterPermission(PermCanMap, this);
            // build usage string for console (without sizing)
            usageString = WrapColor("orange", GetMessage("Header_Usage")) + $" - {Version}{Environment.NewLine}" +
                          WrapColor("cyan", $"tpve.{Command.def}") + $" - {GetMessage("Cmd_Usage_def")}{Environment.NewLine}" +
                          WrapColor("cyan", $"tpve.{Command.trace}") + $" - {GetMessage("Cmd_Usage_trace")}{Environment.NewLine}" +
                          WrapColor("cyan", $"tpve.{Command.sched} [enable|disable]") + $" - {GetMessage("Cmd_Usage_sched")}{Environment.NewLine}" +
                          WrapColor("cyan", $"/tpve_prod") + $" - {GetMessage("Cmd_Usage_prod")}{Environment.NewLine}" +
                          WrapColor("cyan", $"/tpve map") + $" - {GetMessage("Cmd_Usage_map")}";
            LoadData();
        }

        private void OnServerInitialized(bool isStartup)
        {
            // check for server pve setting
            if (ConVar.Server.pve) WarnPve();
            // load configuration
            config.Init(this);
            currentRuleSet = config.GetDefaultRuleSet();
            dudRuleSet = config.GetDudRuleSet();
            if (currentRuleSet == null)
                Puts(GetMessage("Warning_NoRuleSet"), config.defaultRuleSet);
            useZones = config.options.useZones && (LiteZones != null || ZoneManager != null);
            if (useZones && config.mappings.Count == 1)
            {
                foreach (var mapping in config.mappings)
                {
                    useZones = !mapping.Key.Equals(config.defaultRuleSet);
                }
            }
            if (config.schedule.enabled)
            {
                TimerLoop(true);
            }
            if (config.ruleSets.Exists(ruleSet => (ruleSet._flags & RuleFlags.AnimalsIgnoreSleepers) != 0))
            {
                Subscribe(nameof(OnNpcTarget));
            }
            if (config.BlockRadioactiveWaterDamage)
            {
                Subscribe(nameof(CanWaterBallSplash));
            }
            if (currentRuleSet == null)
            {
                return;
            }
            if (config.ruleSets.Exists(ruleSet => (ruleSet._flags & (RuleFlags.SafeZoneTurretsIgnorePlayers | RuleFlags.StaticTurretsIgnorePlayers | RuleFlags.StaticTurretsIgnoreScientist | RuleFlags.TrapsIgnorePlayers | RuleFlags.TrapsIgnoreScientist | RuleFlags.TurretsIgnorePlayers | RuleFlags.TurretsIgnoreScientist | RuleFlags.TurretsIgnoreBradley)) != 0))
            {
                Subscribe(nameof(OnEntityEnter));
                Subscribe(nameof(OnTurretTarget));
            }
            if (config.ruleSets.Exists(ruleSet => (ruleSet._flags & (RuleFlags.SamSitesIgnoreMLRS | RuleFlags.PlayerSamSitesIgnorePlayers | RuleFlags.StaticSamSitesIgnorePlayers)) != 0))
            {
                Subscribe(nameof(OnSamSiteTarget));
            }
            if (config.ruleSets.Exists(ruleSet => (ruleSet._flags & (RuleFlags.TrapsIgnorePlayers | RuleFlags.TrapsIgnoreScientist)) != 0))
            {
                Subscribe(nameof(OnTrapTrigger));
            }
            if (config.schedule.enabled && config.schedule.broadcast && !string.IsNullOrEmpty(currentBroadcastMessage))
            {
                Subscribe(nameof(OnPlayerConnected));
            }
            if (config.options.disableBaseOvenSplash)
            {
                ServerMgr.Instance.StartCoroutine(OvenCo());
            }
            if (config.options.disableHostility)
            {
                Subscribe(nameof(OnEntityMarkHostile));
            }
            RuleSet ruleSet = currentRuleSet;
            if (config.options.handleDamage && ruleSet != null && !ruleSet.IsEmpty() && ruleSet.enabled)
            {
                Subscribe(nameof(OnEntityTakeDamage));
                tpveEnabled = true;
            }
            if (config.wallpaper)
            {
                Subscribe(nameof(OnWallpaperRemove));
            }
            Subscribe(nameof(OnTimedExplosiveExplode));
            Subscribe(nameof(OnEntitySpawned));
            Subscribe(nameof(OnMlrsFire));
            BuildPrefabIds();
        }

        private IEnumerator OvenCo()
        {
            int checks = 0;
            foreach (var ent in BaseNetworkable.serverEntities)
            {
                if (++checks > 500)
                {
                    checks = 0;
                    yield return null;
                }
                if (ent is BaseOven oven)
                {
                    oven.disabledBySplash = false;
                }
            }
        }

        private void BuildPrefabIds()
        {
            if (StringPool.toNumber.TryGetValue("assets/prefabs/npc/m2bradley/maincannonshell.prefab", out var prefab1)) maincannonshell = prefab1;
            if (StringPool.toNumber.TryGetValue("assets/content/props/train_tunnels/trainbarricade.prefab", out var prefab2)) trainbarricade = prefab2;
            if (StringPool.toNumber.TryGetValue("assets/content/props/train_tunnels/trainbarricadeheavy.prefab", out var prefab3)) trainbarricadeheavy = prefab3;
            if (StringPool.toNumber.TryGetValue("assets/bundled/prefabs/radtown/loot_trash.prefab", out var prefab4)) loot_trash = prefab4;
            if (StringPool.toNumber.TryGetValue("assets/prefabs/misc/xmas/giftbox/giftbox_loot.prefab", out var prefab5)) giftbox_loot = prefab5;
            if (StringPool.toNumber.TryGetValue("assets/prefabs/deployable/campfire/campfire.prefab", out var prefab6)) campfire = prefab6;
            if (StringPool.toNumber.TryGetValue("assets/bundled/prefabs/oilfireballsmall.prefab", out var prefab7)) oilfireballsmall = prefab7;
            if (StringPool.toNumber.TryGetValue("assets/bundled/prefabs/napalm.prefab", out var prefab8)) heli_napalm = prefab8;
            if (StringPool.toNumber.TryGetValue("assets/prefabs/npc/patrol helicopter/rocket_heli_napalm.prefab", out var prefab9)) rocket_heli_napalm = prefab9;
            if (StringPool.toNumber.TryGetValue("assets/prefabs/npc/patrol helicopter/rocket_heli.prefab", out var prefab10)) rocket_heli = prefab10;
        }
        #endregion

        #region Data

        private void OnNewSave()
        {
            data = new();
            SaveData();
        }

        private class StoredData
        {
            public Dictionary<ulong, int> LastSeen = new();
            public DateTime LastRunTime { get; set; } = DateTime.MinValue;
        }

        private StoredData data = new();

        private void LoadData()
        {
            try { data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name); } catch (Exception ex) { Puts(ex.ToString()); }
            data ??= new();
            data.LastSeen ??= new();
            if (data.LastRunTime != DateTime.MinValue && DateTime.Now.Subtract(data.LastRunTime).TotalHours >= 24)
            {
                if (config.AllowKillingSleepersHoursOffline > 0f && data.LastSeen.Count > 0)
                {
                    Puts("Last seen data wiped due to plugin not being loaded for {0} day(s).", DateTime.Now.Subtract(data.LastRunTime).Days);
                }
                data = new();
                data.LastRunTime = DateTime.Now;
            }
            if (config.AllowKillingSleepersHoursOffline <= 0f)
            {
                if (data.LastSeen.Count > 0)
                {
                    data.LastSeen.Clear();
                    SaveData();
                }
                return;
            }
            timer.Every(60f, UpdateLastSeen);
            UpdateLastSeen();
        }

        private void SaveData()
        {
            data.LastRunTime = DateTime.Now;
            Interface.Oxide.DataFileSystem.WriteObject(Name, data);
        }

        public void UpdateLastSeen()
        {
            bool changed = false;
            foreach (var sleeper in BasePlayer.sleepingPlayerList)
            {
                if (sleeper == null || !sleeper.userID.IsSteamId())
                {
                    continue;
                }
                if (!data.LastSeen.ContainsKey(sleeper.userID))
                {
                    data.LastSeen[sleeper.userID] = Epoch.Current;
                    changed = true;
                }
            }
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (data.LastSeen.Remove(player.userID))
                {
                    changed = true;
                }
            }
            if (changed)
            {
                SaveData();
            }
        }

        public bool CanKillOfflinePlayer(BasePlayer player, out double timeLeft)
        {
            timeLeft = 0;
            if (config.AllowKillingSleepersHoursOffline <= 0f)
            {
                return false;
            }
            if (player.IsConnected || !player.IsSleeping())
            {
                data.LastSeen.Remove(player.userID);
                return false;
            }
            if (!data.LastSeen.TryGetValue(player.userID, out var lastSeen))
            {
                return false;
            }
            double timeOffline = Epoch.Current - lastSeen;
            double allowedOfflineTime = config.AllowKillingSleepersHoursOffline * 3600.0;
            timeLeft = (allowedOfflineTime - timeOffline) / 3600.0;
            return timeOffline > allowedOfflineTime;
        }

        #endregion Data

        #region Command Handling
        // delegation method for commands
        private void CommandDelegator(IPlayer user, string command, string[] args)
        {
            // return if user doesn't have access to run console command
            if (!user.IsAdmin) return;

            if (args.Length > 0 && args[0] == "map")
            {
                if (user.HasPermission(PermCanMap))
                {
                    CommandMap(user, command, args);
                }
                return;
            }

            if (args.Contains("pvp"))
            {
                if (currentRuleSet.rules.Remove("players cannot hurt players"))
                {
                    currentRuleSet.rules.Add("players can hurt players");
                }
                else if (currentRuleSet.rules.Remove("player can hurt players"))
                {
                    currentRuleSet.rules.Add("player cannot hurt players");
                }

                Puts("PVP toggled {0}", currentRuleSet.rules.Contains("players can hurt players") ? "on" : "off");
                SaveConfig();
                return;
            }

            if (command == "tpve_prod")
            {
                HandleProd(user);
                return;
            }

            if (command == "tpve_enable")
            {
				tpveEnabled = !tpveEnabled;
                ValidateCurrentDamageHook();
                Message(user, "Enable", tpveEnabled);
                return;
            }

            if (command == "tpve" && args.Length != 0) command = args[0];
            else command = command.Replace("tpve.", string.Empty);

            if (!Enum.TryParse(command, out Command @enum))
            {
                user.Reply($"Invalid argument: {command}");
                return;
            }

            switch (@enum)
            {
                case Command.sleepers:
                    HandleSleepers(user);
                    return;
                case Command.def:
                    HandleDef(user);
                    return;
                case Command.sched:
                    HandleScheduleSet(user, args);
                    return;
                case Command.trace:
                    HandleTrace(user);
                    return;
                case Command.enable:
					tpveEnabled = !tpveEnabled;
                    ValidateCurrentDamageHook();
                    Message(user, "Enable", tpveEnabled);
                    return;
                case Command.usage:
                default:
                    ShowUsage(user);
                    return;
            }
        }

        protected void HandleTrace(IPlayer user)
        {
            if (!IsTraceEnabled(user))
            {
                return;
            }
            if (user.IsServer)
            {
                traceDistance = 0f;
            }
            else traceDistance = config.options.MaxTraceDistance;
            trace = !trace;
            if (!trace)
            {
                tracePlayer = null;
                traceEntity = null;
            }
            else tracePlayer = user.Object as BasePlayer;
            Message(user, "Notify_TraceToggle", new object[] { trace ? "on" : "off" });
            traceTimer?.Destroy();
            if (trace)
            {
                traceTimer = timer.In(traceTimeout, () => trace = false);
            }
        }

        private bool IsTraceEnabled(IPlayer user)
        {
            if (config.options.PlayerConsole || config.options.ServerConsole)
            {
                return true;
            }
            Message(user, "`Trace To Player Console` or `Trace To Server Console` must be enabled in the config!");
            return false;
        }

        private void HandleSleepers(IPlayer user)
        {
            if (animalsIgnoreSleepers)
            {
                animalsIgnoreSleepers = false;
                if (!config.ruleSets.Exists(ruleSet => (ruleSet._flags & RuleFlags.AnimalsIgnoreSleepers) != 0))
                {
                    Unsubscribe(nameof(OnNpcTarget));
                    _npcCache.CancelInvoke();
                }
                user.Reply("Sleepers are no longer protected from animals.");
            }
            else
            {
                animalsIgnoreSleepers = true;
                Subscribe(nameof(OnNpcTarget));
                user.Reply("Sleepers are now protected from animals.");
            }
        }

        // handle setting defaults
        private void HandleDef(IPlayer user)
        {
            config.options = new();
            Message(user, "Notify_DefConfigLoad");
            LoadDefaultData();
            Message(user, "Notify_DefDataLoad");
            CheckData();
            SaveConfig();
        }

        // handle prod command (raycast to determine what player is looking at)
        private void HandleProd(IPlayer user)
        {
            var player = user.Object as BasePlayer;
            if (player == null || !player.IsAdmin)
            {
                Message(user, "Error_NoPermission");
                return;
            }

            if (!GetRaycastTarget(player, out var entity))
            {
                SendReply(player, WrapSize(12, WrapColor("red", GetMessage("Error_NoEntityFound", player.UserIDString))));
                return;
            }

            Message(player, "Notify_ProdResult", entity.GetType(), entity.ShortPrefabName);
        }

        private void CommandMap(IPlayer user, string command, string[] args)
        {
            // assume args[0] is the command (beyond /tpve)
            if (args.Length > 0) command = args[0];

            // shift arguments
            args = args.Length > 1 ? args[1..] : Array.Empty<string>();

            if (command != "map")
            {
                Message(user, "Error_InvalidCommand");
            }
            else if (args.Length == 0)
            {
                Message(user, "Error_InvalidParamForCmd", command);
            }
            else
            {
                string from = args[0]; // mapping name
                string to = args.Length == 2 ? args[1] : null; // target ruleSet/exclude, otherwise delete mapping
                if (to != null)
                {
                    if (to != "exclude" && !config.ruleSets.Exists(r => r.name == to))
                    {
                        // target ruleset must exist, or be "exclude"
                        Message(user, "Error_InvalidMapping", from, to);
                        return;
                    }
                    if (config.HasMapping(from))
                    {
                        string old = config.mappings[from];
                        Message(user, "Notify_MappingUpdated", from, old, to); // update existing mapping
                    }
                    else Message(user, "Notify_MappingCreated", from, to); // add new mapping
                    config.mappings[from] = to;
                    SaveConfig();
                    TryBuildExclusionMappings();
                }
                else
                {
                    if (config.HasMapping(from))
                    {
                        Message(user, "Notify_MappingDeleted", from, config.mappings[from]);
                        config.mappings.Remove(from); // remove mapping
                        SaveConfig();
                        TryBuildExclusionMappings();
                    }
                    else Message(user, "Error_NoMappingToDelete", from);
                }
            }
        }

        // handles schedule enable/disable
        private void HandleScheduleSet(IPlayer user, string[] args)
        {
            if (args.Length == 0)
            {
                Message(user, "Error_InvalidParamForCmd");
                return;
            }
            if (!config.schedule.valid)
            {
                Message(user, "Notify_InvalidSchedule");
            }
            else if (args[0] == "enable")
            {
                if (config.schedule.enabled) return;
                config.schedule.enabled = true;
                TimerLoop();
                Message(user, "Notify_SchedSetEnabled");
            }
            else if (args[0] == "disable")
            {
                if (!config.schedule.enabled) return;
                config.schedule.enabled = false;
                if (scheduleUpdateTimer != null)
                    scheduleUpdateTimer.Destroy();
                Message(user, "Notify_SchedSetDisabled");
            }
            else
            {
                Message(user, "Error_InvalidParameter", args[0]);
            }
        }
        #endregion

        #region Configuration/Data

        // load config
        protected override void LoadConfig()
        {
            base.LoadConfig();
            canSaveConfig = false;
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                canSaveConfig = true;
                CheckData();
                SaveConfig();
            }
            catch (Exception ex)
            {
                Puts(ex.ToString());
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new()
            {
                configVersion = Version.ToString(),
                options = new()
            };
            LoadDefaultData();
            Puts("Loaded default config.");
        }

        private bool canSaveConfig = true;

        // save data
        protected override void SaveConfig()
        {
            if (canSaveConfig)
            {
                Config.WriteObject(config);
            }
        }

        // check rulesets and groups
        private void CheckData()
        {
            if (string.IsNullOrEmpty(config.defaultRuleSet))
            {
                config.defaultRuleSet = "default";
                Puts("Loaded default ruleset (no default ruleset was configured)");
            }
            if (config.mappings.IsNullOrEmpty())
            {
                BuildDefaultMappings();
                Puts("Loaded default mappings (no mappings were configured)");
            }
            if (config.schedule == null)
            {
                Puts("Loaded default schedule (schedule was null)");
                BuildDefaultSchedule();
            }
            if (config.groups.IsNullOrEmpty())
            {
                BuildDefaultGroups();
                Puts("Loaded default entity groups (no entity groups were configured)");
            }
            if (config.ruleSets.IsNullOrEmpty())
            {
                BuildDefaultRuleset();
                Puts("Loaded default rulesets (no rulesets were configured)");
            }
            for (int i = 0; i < config.groups.Count; i++)
            {
                if (string.IsNullOrEmpty(config.groups[i].name))
                {
                    config.groups[i].name = $"group{i}";
                }
                if (config.groups[i].name == "ridablehorses" && config.groups.Count == 1 && config.groups[0].members.Equals("RidableHorse"))
                {
                    config.groups[i].members = "RidableHorse2";
                }
            }
            allowKillingSleepersEnabled = config.AllowKillingSleepersAlly || config.AllowKillingSleepers || config.AllowKillingSleepersAuthorization || config.AllowKillingSleepersIds.Exists(x => x.IsSteamId());
            twigOutputHandlerEnabled = config.options.BlockHandler.Any;
            config.configVersion = Version.ToString();
            CheckMappings();
            BuildRuleSetDictionary();
            BuildExclusionMappings();
        }

        // rebuild mappings
        private bool CheckMappings()
        {
            bool dirty = false;
            foreach (RuleSet ruleSet in config.ruleSets)
            {
                if (!config.mappings.ContainsValue(ruleSet.name))
                {
                    config.mappings[ruleSet.name] = ruleSet.name;
                    dirty = true;
                }
            }
            return dirty;
        }

        protected void BuildRuleSetDictionary()
        {
            ruleSetByNameDictionary.Clear();

            foreach (RuleSet ruleSet in config.ruleSets)
            {
                if (ruleSet.enabled)
                {
                    ruleSetByNameDictionary[ruleSet.name] = ruleSet;
                }
            }
        }

        protected void TryBuildExclusionMappings()
        {
            if (!config.mappings.TryGetValue(AllZones, out var val) || !val.Equals("exclude", StringComparison.OrdinalIgnoreCase))
            {
                BuildExclusionMappings();
            }
        }

        protected void BuildExclusionMappings()
        {
            excludeAllZones = false;
            exclusionLocationsSet.Clear();

            if (config.mappings.TryGetValue(AllZones, out var val) && val.Equals("exclude", StringComparison.OrdinalIgnoreCase))
            {
                excludeAllZones = true;
                return;
            }

            foreach (var (key, value) in config.mappings)
            {
                if (!value.Equals("exclude", StringComparison.OrdinalIgnoreCase))
                {
                    foreach (var ruleSet in config.ruleSets)
                    {
                        if (ruleSet.name.Equals(value, StringComparison.OrdinalIgnoreCase) && ruleSet.IsEmpty())
                        {
                            exclusionLocationsSet.Add(key);
                        }
                    }
                }
                else
                {
                    exclusionLocationsSet.Add(key);
                }
            }

            foreach (var group in config.groups)
            {
                foreach (var exclusion in group._exclusionSet)
                {
                    if (!string.IsNullOrWhiteSpace(exclusion))
                    {
                        exclusionLocationsSet.Add(exclusion.Trim());
                    }
                }
            }
        }

        // load default data to mappings, rulesets, and groups
        protected bool LoadDefaultData()
        {
            BuildDefaultMappings();

            BuildDefaultSchedule();

            BuildDefaultGroups();

            BuildDefaultRuleset();

            return true;
        }

        protected void BuildDefaultSchedule()
        {
            config.schedule = new();
        }

        protected void BuildDefaultMappings()
        {
            config.mappings ??= new();
            config.mappings.Clear();
            config.defaultRuleSet = "default";
            config.mappings[config.defaultRuleSet] = config.defaultRuleSet; // create mapping for ruleset
        }

        protected void BuildDefaultGroups()
        {
            config.groups ??= new();
            config.groups.Clear();

            config.groups.Add(new("barricades")
            {
                members = "door_barricade_a, door_barricade_a_large, door_barricade_b, door_barricade_dbl_a, door_barricade_dbl_a_large, door_barricade_dbl_b, door_barricade_dbl_b_large, gingerbread_barricades_house, gingerbread_barricades_snowman, gingerbread_barricades_tree, wooden_crate_gingerbread",
                exclusions = "barricade.concrete, barricade.sandbags, barricade.stone"
            });

            config.groups.Add(new("barricades2")
            {
                members = "spikes_static, barricade.metal, barricade.wood, barricade.woodwire, spikes.floor, icewall, GraveyardFence",
            });

            config.groups.Add(new("dispensers")
            {
                members = "BaseCorpse, HelicopterDebris, PlayerCorpse, NPCPlayerCorpse, HorseCorpse, SkyLantern, Pinata"
            });

            config.groups.Add(new("fire")
            {
                members = "FireBall, FlameExplosive, FlameThrower, BaseOven, FlameTurret, rocket_heli_napalm, napalm, oilfireball2"
            });

            config.groups.Add(new("guards")
            {
                members = "bandit_guard, scientistpeacekeeper, sentry.scientist.static, sentry.bandit.static"
            });

            config.groups.Add(new("heli")
            {
                members = "PatrolHelicopter"
            });

            config.groups.Add(new("highwalls")
            {
                members = "SimpleBuildingBlock, wall.external.high.ice, gates.external.high.stone, gates.external.high.wood"
            });

            config.groups.Add(new("ridablehorses")
            {
                members = "RidableHorse2"
            });

            config.groups.Add(new("cars")
            {
                members = "BasicCar, ModularCar, BaseModularVehicle, BaseVehicleModule, VehicleModuleEngine, VehicleModuleSeating, VehicleModuleStorage, VehicleModuleTaxi, ModularCarSeat, Bike"
            });

            config.groups.Add(new("mini")
            {
                members = "minicopter.entity"
            });

            config.groups.Add(new("scrapheli")
            {
                members = "ScrapTransportHelicopter"
            });

            config.groups.Add(new("ch47")
            {
                members = "ch47.entity"
            });

            config.groups.Add(new("npcs")
            {
                members = "ch47scientists.entity, BradleyAPC, CustomScientistNpc, ScarecrowNPC, HumanNPC, NPCPlayer, ScientistNPC, TunnelDweller, SimpleShark, UnderwaterDweller, ZombieNPC"
            });

            config.groups.Add(new("players")
            {
                members = "BasePlayer, FrankensteinPet"
            });

            config.groups.Add(new("resources")
            {
                members = "ResourceEntity, TreeEntity, OreResourceEntity, LootContainer, NaturalBeehive",
                exclusions = "hobobarrel.deployed"
            });

            config.groups.Add(new("snowmobiles")
            {
                members = "snowmobile, tomahasnowmobile"
            });

            config.groups.Add(new("traps")
            {
                members = "AutoTurret, BearTrap, FlameTurret, Landmine, GunTrap, ReactiveTarget, TeslaCoil, spikes.floor"
            });

            config.groups.Add(new("junkyard")
            {
                members = "magnetcrane.entity, carshredder.entity"
            });

            config.groups.Add(new("tugboats")
            {
                members = "Tugboat"
            });

            config.groups.Add(new("heliturrets")
            {
                members = "turret_attackheli"
            });

            config.groups.Add(new("ramhead")
            {
                members = "BatteringRamHead"
            });

            config.groups.Add(new("siege")
            {
                members = "SiegeTower, Catapult, Ballista, BallistaGun, BatteringRam, ConstructableEntity"
            });

            config.groups.Add(new("bees")
            {
                members = "BeeSwarmAI, Beehive, BeeGrenade, BeeSwarmMaster, NaturalBeehive"
            });

            config.groups.Add(new("farm")
            {
                members = "simplechicken.entity, FarmableAnimal, ChickenCoop"
            });
        }

        protected void BuildDefaultRuleset()
        {
            config.ruleSets ??= new();
            config.ruleSets.Clear();

            // create default ruleset
            RuleSet defaultRuleSet = new(config.defaultRuleSet)
            {
                _flags = RuleFlags.HumanNPCDamage | RuleFlags.LockedBoxesImmortal | RuleFlags.LockedDoorsImmortal | RuleFlags.PlayerSamSitesIgnorePlayers | RuleFlags.TrapsIgnorePlayers | RuleFlags.TurretsIgnorePlayers,
                flags = "HumanNPCDamage, LockedBoxesImmortal, LockedDoorsImmortal, PlayerSamSitesIgnorePlayers, TrapsIgnorePlayers, TurretsIgnorePlayers"
            };

            // create rules and add to ruleset
            defaultRuleSet.AddRule(this, "anything can hurt dispensers");
            defaultRuleSet.AddRule(this, "anything can hurt resources");
            defaultRuleSet.AddRule(this, "anything can hurt barricades");
            defaultRuleSet.AddRule(this, "anything can hurt traps");
            defaultRuleSet.AddRule(this, "anything can hurt heli");
            defaultRuleSet.AddRule(this, "anything can hurt npcs");
            defaultRuleSet.AddRule(this, "anything can hurt players");
            defaultRuleSet.AddRule(this, "nothing can hurt ch47");
            defaultRuleSet.AddRule(this, "nothing can hurt cars");
            defaultRuleSet.AddRule(this, "nothing can hurt mini");
            defaultRuleSet.AddRule(this, "nothing can hurt snowmobiles");
            defaultRuleSet.AddRule(this, "nothing can hurt ridablehorses");
            defaultRuleSet.AddRule(this, "cars cannot hurt anything");
            defaultRuleSet.AddRule(this, "mini cannot hurt anything");
            defaultRuleSet.AddRule(this, "ch47 cannot hurt anything");
            defaultRuleSet.AddRule(this, "scrapheli cannot hurt anything");
            defaultRuleSet.AddRule(this, "players cannot hurt players");
            defaultRuleSet.AddRule(this, "players cannot hurt traps");
            defaultRuleSet.AddRule(this, "guards cannot hurt players");
            defaultRuleSet.AddRule(this, "fire cannot hurt players");
            defaultRuleSet.AddRule(this, "traps cannot hurt players");
            defaultRuleSet.AddRule(this, "highwalls cannot hurt players");
            defaultRuleSet.AddRule(this, "barricades2 cannot hurt players");
            defaultRuleSet.AddRule(this, "mini cannot hurt mini");
            defaultRuleSet.AddRule(this, "npcs can hurt players");
            defaultRuleSet.AddRule(this, "junkyard cannot hurt anything");
            defaultRuleSet.AddRule(this, "junkyard can hurt cars");
            defaultRuleSet.AddRule(this, "players cannot hurt tugboats");
            defaultRuleSet.AddRule(this, "heliturrets cannot hurt players");
            defaultRuleSet.AddRule(this, "ramhead can hurt ramhead");
            defaultRuleSet.AddRule(this, "siege cannot hurt players");
            defaultRuleSet.AddRule(this, "players cannot hurt farm");

            config.ruleSets.Add(defaultRuleSet); // add ruleset to rulesets list
        }

        private bool ResetRules(string key)
        {
            if (string.IsNullOrEmpty(key) || config == null)
            {
                return false;
            }

            string old = config.defaultRuleSet;
            config.defaultRuleSet = key;
            currentRuleSet = config.GetDefaultRuleSet();

            if (currentRuleSet == null)
            {
                config.defaultRuleSet = old;
                currentRuleSet = config.GetDefaultRuleSet();
            }

            ValidateCurrentDamageHook();
            return currentRuleSet != null;
        }
        #endregion

        #region Trace
        private StringBuilder _tsb = new();
        private BaseEntity traceEntity;
        private BasePlayer tracePlayer;
        private float traceDistance;

        private void Trace(string message, int indentation = 0)
        {
            if (traceEntity == null || traceEntity.IsDestroyed)
            {
                return;
            }

            bool playerInRange = tracePlayer != null && !tracePlayer.IsDestroyed && tracePlayer.Distance(traceEntity) <= traceDistance;
            bool shouldLogToConsole = (config.options.PlayerConsole && playerInRange) || (config.options.ServerConsole && (traceDistance == 0 || playerInRange));

            if (shouldLogToConsole)
            {
                _tsb.Append(new string(' ', indentation)).AppendLine(message);
            }
        }

        private void LogTrace()
        {
            var text = _tsb.ToString();
            traceEntity = null;
            _tsb.Length = 0;
            try
            {
                if (!string.IsNullOrEmpty(text))
                {
                    if (config.options.ServerConsole)
                    {
                        Puts(text);
                    }
                    if (config.options.PlayerConsole && tracePlayer != null && tracePlayer.IsConnected)
                    {
                        tracePlayer.ConsoleMessage(text);
                    }
                    if (config.options.LogToFile)
                    {
                        LogToFile(traceFile, text, this);
                    }
                }
            }
            catch (IOException)
            {
                timer.Once(1f, () => LogToFile(traceFile, text, this));
            }
        }

        #endregion Trace

        #region Hooks/Handler Procedures
        private void OnPlayerConnected(BasePlayer player)
        {
            if (config.schedule.broadcast && !string.IsNullOrEmpty(currentBroadcastMessage))
            {
                SendReply(player, GetMessage("Prefix") + currentBroadcastMessage);
            }
        }

        private string CurrentRuleSetName() => currentRuleSet?.name;

        private bool IsEnabled() => tpveEnabled;

        private object OnWallpaperRemove(BuildingBlock block, int side)
        {
            if (block == null || block.IsDestroyed)
            {
                return null;
            }
            switch (side)
            {
                case 0:
                    {
                        if (block.wallpaperHealth <= 0f)
                        {
                            using var entityLocations = GetLocationKeys(block);
                            if (CheckExclusion(entityLocations, entityLocations, trace))
                            {
                                return null;
                            }

                            if (trace) Trace("Block Damage Wallpaper1 enabled; block and return", 1);
                            block.wallpaperHealth = block.health;
                            return true;
                        }
                        break;
                    }
                case 1:
                    {
                        if (block.wallpaperHealth2 <= 0f)
                        {
                            using var entityLocations = GetLocationKeys(block);
                            if (CheckExclusion(entityLocations, entityLocations, trace))
                            {
                                return null;
                            }

                            if (trace) Trace("Block Damage Wallpaper2 enabled; block and return", 1);
                            block.wallpaperHealth2 = block.health;
                            return true;
                        }
                        break;
                    }
            }
            return null;
        }

        private object OnEntityTakeDamage(ResourceEntity entity, HitInfo info)
        {
            if (info == null || info.Initiator == null)
            {
                return null;
            }

            RuleSet ruleSet;

            if (useZones)
            {
                // get entity and initiator locations (zones)
                using var entityLocations = GetLocationKeys(entity);
                using var initiatorLocations = GetLocationKeys(info.Initiator);

                // check for exclusion zones (zones with no rules mapped)
                if (CheckExclusion(entityLocations, initiatorLocations, trace))
                {
                    if (trace) Trace("Exclusion found; allow and return", 1);
                    return null;
                }

                if (trace) Trace("No exclusion found - looking up RuleSet...", 1);

                // process location rules
                if (config.PVEZones && initiatorLocations.IsNullOrEmpty())
                {
                    ruleSet = GetRuleSet(entityLocations, entityLocations);
                }
                else ruleSet = GetRuleSet(entityLocations, initiatorLocations);
            }
            else ruleSet = currentRuleSet;

            return EvaluateRules(entity, info.Initiator, ruleSet) ? (object)null : true;
        }

        private object OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            if (info == null || entity == null || entity.IsDestroyed || !entity.isSpawned)
            {
                return null;
            }

            if (!AllowDamage(entity, info))
            {
                if (trace) LogTrace();
                info.damageTypes?.Clear();
                info.DidHit = false;
                info.DoHitEffects = false;
                return true;
            }

            if (trace) LogTrace();
            return null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private string ConcatenateListOrDefault(List<string> list, string defaultValue)
        {
            return (list == null || list.Count == 0) ? defaultValue : string.Join(", ", list);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private string ConcatenateRuleSetNames(List<RuleSet> sets)
        {
            if (sets == null || sets.Count == 0)
                return string.Empty;
            var sb = Pool.Get<StringBuilder>();
            for (int i = 0; i < sets.Count; i++)
            {
                sb.Append(sets[i].name);
                if (i < sets.Count - 1)
                {
                    sb.Append(", ");
                }
            }
            string text = sb.ToString();
            Pool.FreeUnmanaged(ref sb);
            return text;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public DamageResult HandleMetabolismDamage(HitInfo info, BasePlayer victim, DamageType damageType, float damageAmount)
        {
            if (damageType != DamageType.Cold && damageType != DamageType.Heat)
            {
                return DamageResult.None;
            }

            if (victim == null || !victim.userID.IsSteamId())
            {
                return DamageResult.None;
            }

            float temperature = victim.metabolism.temperature.value;
            float multiplier;
            float normalized;

            if (damageType == DamageType.Cold)
            {
                if (temperature > 1f)
                {
                    return DamageResult.None;
                }

                multiplier = temperature < -20f ? 1f :
                             temperature < -10f ? 0.3f : 0.1f;

                normalized = (temperature - 1f) / -51f;
            }
            else // DamageType.Heat
            {
                if (temperature < 60f)
                {
                    return DamageResult.None;
                }

                multiplier = 5f;
                normalized = (temperature - 60f) / 140f;
            }

            normalized = normalized < 0f ? 0f : (normalized > 1f ? 1f : normalized);

            float threshold = normalized * ConVar.Player.serverTickInterval * multiplier;

            if (damageAmount > threshold)
            {
                return DamageResult.None;
            }

            bool option = damageType == DamageType.Cold ? config.options.Cold : config.options.Heat;
            DamageResult damageResult = option ? DamageResult.Allow : DamageResult.Block;

            if (trace)
            {
                string action = damageResult == DamageResult.Allow ? "allow and return" : "block and return";
                Trace($"Initiator is {damageType} metabolism damage; {action}", 1);
                LogTrace();
            }

            if (damageResult == DamageResult.Block)
            {
                info.damageTypes.Clear();
            }

            return damageResult;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool CanPlayerTriggerTurretOrTrap(BasePlayer victim, BaseEntity entity, BaseEntity weapon)
        {
            if (weapon == null || weapon.IsDestroyed || weapon.OwnerID != 0uL)
            {
                return false;
            }
            if (config.PlayersTriggerTraps && (weapon is BaseTrap || weapon is BaseDetector || weapon is GunTrap))
            {
                return (TerrainMeta.TopologyMap.GetTopology(weapon.transform.position, 5f) & (int)TerrainTopology.Enum.Monument) != 0;
            }
            if (config.PlayersTriggerTurrets && (weapon is FlameTurret || weapon is AutoTurret))
            {
                return (TerrainMeta.TopologyMap.GetTopology(weapon.transform.position, 5f) & (int)TerrainTopology.Enum.Monument) != 0;
            }
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool CanPlayerHurtTurretOrTrap(BasePlayer victim, BaseEntity entity, BasePlayer attacker)
        {
            if (config.PlayersHurtTraps && (entity is BaseTrap || entity is HBHFSensor || entity is GunTrap))
            {
                return (TerrainMeta.TopologyMap.GetTopology(attacker.transform.position, 5f) & (int)TerrainTopology.Enum.Monument) != 0;
            }
            if (config.PlayersHurtTurrets && (entity is FlameTurret || entity is AutoTurret))
            {
                return (TerrainMeta.TopologyMap.GetTopology(attacker.transform.position, 5f) & (int)TerrainTopology.Enum.Monument) != 0;
            }
            return false;
        }

        private bool allowKillingSleepersEnabled;

        private bool AllowKillingSleepers(BaseEntity entity, BaseEntity initiator)
        {
            if (entity is BasePlayer victim && victim.userID.IsSteamId() && victim.IsSleeping())
            {
                if (config.AllowKillingSleepersAuthorization && initiator is BasePlayer attacker && AllowAuthorizationDamage(victim, attacker))
                {
                    return true;
                }
                if (config.AllowKillingSleepersIds.Count > 0 && initiator is BasePlayer attacker3 && attacker3.userID.IsSteamId() && config.AllowKillingSleepersIds.Contains(attacker3.userID))
                {
                    return true;
                }
                if (config.AllowKillingSleepersAlly && initiator is BasePlayer attacker2 && attacker2.userID.IsSteamId())
                {
                    return IsAlly(victim.userID, attacker2.userID);
                }
                return config.AllowKillingSleepers;
            }
            return false;
        }

        private static bool AllowAuthorizationDamage(BasePlayer victim, BasePlayer attacker)
        {
            if (!attacker.userID.IsSteamId())
            {
                return false;
            }
            if (victim.GetParentEntity() is Tugboat tugboat && tugboat.IsAuthed(attacker))
            {
                return true;
            }
            if (victim.GetBuildingPrivilege() is BuildingPrivlidge priv && priv.IsAuthed(attacker))
            {
                return true;
            }
            return false;
        }

        private static bool IsAuthed(DecayEntity entity, BasePlayer attacker)
        {
            if (entity is LegacyShelter || entity is LegacyShelterDoor)
            {
                return entity.GetEntityBuildingPrivilege() is EntityPrivilege entityPriv && entityPriv.AnyAuthed() && entityPriv.IsAuthed(attacker);
            }
            return entity.GetBuilding() is BuildingManager.Building building && building.GetDominatingBuildingPrivilege() is BuildingPrivlidge priv && priv.AnyAuthed() && priv.IsAuthed(attacker);
        }

        private static bool IsAuthed(Tugboat tugboat, BasePlayer attacker)
        {
            return !tugboat.children.IsNullOrEmpty() && tugboat.children.Exists(child => child is VehiclePrivilege vehiclePrivilege && vehiclePrivilege.AnyAuthed() && vehiclePrivilege.IsAuthed(attacker));
        }

        private static bool IsAuthed(BaseHelicopter heli, BasePlayer attacker)
        {
            return attacker.GetBuildingPrivilege(heli.WorldSpaceBounds()) is BuildingPrivlidge priv && priv.AnyAuthed() && priv.IsAuthed(attacker);
        }

        // determines if an entity is "allowed" to take damage
        private bool AllowDamage(BaseEntity entity, HitInfo info)
        {
            if (trace)
            {
                traceEntity = entity;
                _tsb.Length = 0;
            }

            if (Interface.CallHook("CanEntityTakeDamage", new object[] { entity, info }) is bool val)
            {
                return val;
            }

            var initiator = info.Initiator switch
            {
                BasePlayer player => player,
                { creatorEntity: BasePlayer player } => player,
                { parentEntity: EntityRef parentRef } when parentRef.Get(true) is BasePlayer player => player,
                _ => info.WeaponPrefab switch
                {
                    BasePlayer player => player,
                    { creatorEntity: BasePlayer player } => player,
                    { parentEntity: EntityRef parentRef } when parentRef.Get(true) is BasePlayer player => player,
                    _ => info.Weapon switch
                    {
                        { creatorEntity: BasePlayer player } => player,
                        { parentEntity: EntityRef parentRef } when parentRef.Get(true) is BasePlayer player => player,
                        _ => info.Initiator
                    }
                }
            };

            var weapon = initiator ?? info.WeaponPrefab ?? info.Weapon;

            if (allowKillingSleepersEnabled && AllowKillingSleepers(entity, initiator))
            {
                return true;
            }

            var damageType = info.damageTypes.GetMajorityDamageType();

            if (damageType == DamageType.Decay)
            {
                if (entity is BaseVehicle)
                {
                    return !config.BlockDecayDamageToVehicles;
                }
                return true;
            }

            if (damageType == DamageType.Fall || damageType == DamageType.Radiation)
            {
                return true;
            }

            if (config.igniter && entity.OwnerID != 0 && entity is Igniter)
            {
                info.damageTypes.Clear();
                return true;
            }

            var damageAmount = info.damageTypes.Total();

            if (damageAmount <= 0f)
            {
                return true;
            }

            var victim = entity as BasePlayer;

            if (config.scrap)
            {
                if (victim && weapon is ScrapTransportHelicopter)
                {
                    info.damageTypes.Clear();
                    return true;
                }
                if (weapon is BasePlayer driver && (driver.GetMountedVehicle() is ScrapTransportHelicopter || info.WeaponPrefab is ScrapTransportHelicopter))
                {
                    info.damageTypes.Clear();
                    return true;
                }
            }

            if (damageAmount < 15f && HandleMetabolismDamage(info, victim, damageType, damageAmount) != DamageResult.None)
            {
                return true;
            }

            if (entity is BaseNpc || entity is BaseNPC2)
            {
                if (trace) Trace($"Target is animal; allow and return {weapon} -> {entity}", 1);
                return true;
            }

            // allow damage to door barricades and covers 
            if (entity.prefabID == trainbarricade || entity.prefabID == trainbarricadeheavy || (entity is Barricade && (entity.ShortPrefabName.Contains("door_barricade") || entity.ShortPrefabName.Contains("cover"))))
            {
                if (trace) Trace($"Target is {entity.ShortPrefabName}; allow and return", 1);
                return true;
            }

            // if entity is a barrel, trash can, or giftbox, allow damage (exclude waterbarrel and hobobarrel)
            if (entity is LootContainer && (entity.prefabID == giftbox_loot || entity.prefabID == loot_trash || entity.ShortPrefabName.Contains("barrel")))
            {
                if (trace) Trace($"Target is {entity.ShortPrefabName} ({entity.GetType().Name}); allow and return", 1);
                return true;
            }

            if (trace)
            {
                // Sometimes the initiator is not the attacker (turrets)
                Trace("======================" + Environment.NewLine +
                  "==  STARTING TRACE  ==" + Environment.NewLine +
                  "==  " + DateTime.Now.ToString("HH:mm:ss.fffff") + "  ==" + Environment.NewLine +
                  "======================");
                Trace($"From: {weapon?.GetType().Name ?? "Unknown_Weapon"}, {weapon?.ShortPrefabName ?? "Unknown_Prefab"}", 1);
                Trace($"To: {entity.GetType().Name}, {entity.ShortPrefabName}", 1);
            }

            var ruleSet = currentRuleSet;
            if (useZones)
            {
                // get entity and initiator locations (zones)
                using var entityLocations = GetLocationKeys(entity);
                using var initiatorLocations = GetLocationKeys(weapon);
                // check for exclusion zones (zones with no rules mapped)
                if (CheckExclusion(entityLocations, initiatorLocations, trace))
                {
                    if (trace) Trace("Exclusion found; allow and return", 1);
                    return true;
                }
                ruleSet = GetRuleSet(entityLocations, initiatorLocations);
            }

            var attacker = initiator as BasePlayer;
            var isAttacker = attacker != null && !attacker.IsDestroyed;
            var isAtkId = isAttacker && attacker.userID.IsSteamId();
            var isVictim = victim != null && !victim.IsDestroyed;
            var isVicId = isVictim && victim.userID.IsSteamId();

            if (isVictim)
            {
                if (isAttacker)
                {
                    if (CanKillOfflinePlayer(victim, out _))
                    {
                        if (trace) Trace($"Initiator ({attacker}) and target ({victim} exceeds Allow Killing Sleepers offline time); allow and return", 1);
                        return true;
                    }

                    if (PlayerHasExclusion(attacker) && PlayerHasExclusion(victim))
                    {
                        if (trace) Trace($"Initiator ({attacker}) and target ({victim}) meet exclusion conditions; allow and return", 1);
                        return true;
                    }
                }

                if (config.options.UnderworldOther > -500f && (!isAttacker || !attacker.userID.IsSteamId()) && victim.transform.position.y <= config.options.UnderworldOther)
                {
                    if (trace) Trace($"Initiator is {weapon} under world; Target is player; allow and return", 1);
                    return true;
                }

                if (config.options.AboveworldOther < 5000f && (!isAttacker || !attacker.userID.IsSteamId()) && victim.transform.position.y >= config.options.AboveworldOther)
                {
                    if (trace) Trace($"Initiator is {weapon} above world; Target is player; allow and return", 1);
                    return true;
                }
            }

            if (isAtkId && entity.OwnerID == 0uL && (config.PlayersHurtTraps || config.PlayersHurtTurrets) && CanPlayerHurtTurretOrTrap(victim, entity, attacker))
            {
                if (trace) Trace($"Initiator is player; Target is turret or trap in monument topology; allow and return", 1);
                return true;
            }

            if (isVicId && (config.PlayersTriggerTraps || config.PlayersTriggerTurrets) && CanPlayerTriggerTurretOrTrap(victim, entity, weapon))
            {
                if (trace) Trace($"Initiator is turret or trap in monument topology; Target is player; allow and return", 1);
                return true;
            }

            if (trace) Trace("No exclusion found - looking up RuleSet...", 1);

            // process location rules
            RuleFlags _flags = ruleSet._flags;

            if (trace) Trace($"Using RuleSet \"{ruleSet.name}\"", 1);

            // LockedVehiclesImmortal flag with modular car
            if (((_flags & RuleFlags.LockedVehiclesImmortal) != 0) && entity.PrefabName.Contains("modular"))
            {
                ModularCar car = entity.HasParent() ? entity.GetParentEntity() as ModularCar : entity as ModularCar;
                if (car != null && car.CarLock.HasALock)
                {
                    if (trace) Trace($"Initiator is {weapon}; Target is locked {car}; block and return (LockedVehiclesImmortal)", 1);
                    return false;
                }
            }

            if (isVictim)
            {
                if (config.PreventRagdolling && isVicId && damageType == DamageType.Collision)
                {
                    victim.lastAdminCheatTime = UnityEngine.Time.realtimeSinceStartup + 1.9f;
                }

                double hoursLeft = 0;

                if (isAtkId && isVicId)
                {
                    if (CanKillOfflinePlayer(victim, out hoursLeft))
                    {
                        if (trace) Trace($"Initiator ({attacker}) and target ({victim} exceeds Allow Killing Sleepers offline time); allow and return", 1);
                        return true;
                    }

                    if (!useZones)
                    {
                        if (PlayerHasExclusion(attacker) && PlayerHasExclusion(victim))
                        {
                            if (trace) Trace($"Initiator ({attacker}) and target ({victim}) meet exclusion conditions; allow and return", 1);
                            return true;
                        }
                    }
                }

                if (!isAtkId && isVicId && config.options.UnderworldOther > -500f && victim.transform.position.y <= config.options.UnderworldOther)
                {
                    if (trace) Trace($"Initiator is {weapon} under world; Target is player; allow and return", 1);
                    return true;
                }

                if (!isAtkId && isVicId && config.options.AboveworldOther < 5000f && victim.transform.position.y >= config.options.AboveworldOther)
                {
                    if (trace) Trace($"Initiator is {weapon} above world; Target is player; allow and return", 1);
                    return true;
                }

                if (isAtkId && hoursLeft > 0 && damageType != DamageType.Heat)
                {
                    ulong userid = attacker.userID;
                    if (!_waiting.Contains(userid))
                    {
                        timer.Once(1f, () => _waiting.Remove(userid));
                        Message(attacker, "Error_TimeLeft", Math.Round(hoursLeft, 2));
                        _waiting.Add(userid);
                    }
                }
            }

            if (entity is PatrolHelicopter)
            {
                if (isAttacker || weapon is PatrolHelicopter)
                {
                    bool isBlocked = !EvaluateRules(entity, weapon, ruleSet, false);
                    if (trace)
                    {
                        string action = isBlocked ? "block and return" : "allow and return";
                        Trace($"Target is PatrolHelicopter; Initiator is {attacker}; {action}", 1);
                    }
                    return !isBlocked;
                }
                if (trace) Trace($"Target is PatrolHelicopter; Initiator is {weapon?.GetType()?.Name}; allow and return", 1);
                return true;
            }

            if (weapon != null && (weapon is BradleyAPC || weapon.prefabID == maincannonshell))
            {
                if (trace) Trace("Initiator is BradleyAPC; evaluating RuleSet rules...", 1);
                return EvaluateRules(entity, weapon, ruleSet);
            }

            if ((_flags & RuleFlags.VehiclesTakeCollisionDamageWithoutDriver) != 0 && entity is BaseVehicle vehicle && weapon == vehicle && !vehicle.GetDriver())
            {
                if (trace) Trace($"Vehicle collision: No driver; allow and return", 1);
                return true;
            }

            // check heli and turret
            DamageResult heli = CheckHeliInitiator(ruleSet, initiator, info.WeaponPrefab);

            if (config.Firework && entity is BaseFirework)
            {
                if (trace)
                {
                    string action = heli == DamageResult.None ? "allow and return" : "block and return";
                    Trace($"Target is firework; {action}", 1);
                }
                return heli == DamageResult.None;
            }

            if (heli != DamageResult.None)
            {
                DamageResult immortalFlag = CheckImmortalFlag(entity, ruleSet, initiator, info.WeaponPrefab);
                if (immortalFlag != DamageResult.None)
                {
                    return immortalFlag == DamageResult.Allow;
                }
                return HandleHelicopter(ruleSet, entity, weapon, victim, isVicId, heli == DamageResult.Allow);
            }

            if ((_flags & RuleFlags.NoMLRSDamage) != 0 && info.WeaponPrefab is MLRSRocket)
            {
                if (trace) Trace("Initiator is MLRS rocket with NoMLRSDamage set; block and return", 1);
                return false;
            }

            // after heli check, return true if initiator is null
            if (initiator == null)
            {
                if (entity is ParachuteUnpacked)
                {
                    if (trace) Trace("Initiator is server hurting parachute; allow and return", 1);
                    return true;
                }
                if (weapon is MLRSRocket)
                {
                    if (trace) Trace($"Initiator empty for MLRS Rocket; block and return", 1);
                    return false;
                }
                if ((damageType == DamageType.Slash || damageType == DamageType.Stab || damageType == DamageType.Cold) && isVictim &&
                   (!(victim.lastAttacker is BasePlayer lastAttacker) || !lastAttacker.userID.IsSteamId() || lastAttacker == entity))
                {
                    if (trace) Trace("Initiator is hurt trigger; allow and return", 1);
                    return true;
                }
                foreach (DamageType _damageType in _damageTypes)
                {
                    if (info.damageTypes.Has(_damageType))
                    {
                        if (entity is NPCPlayerCorpse || entity is BaseCorpse && !(entity is PlayerCorpse))
                        {
                            if (trace) _tsb.Clear(); // reduce useless spam
                            return true;
                        }
                        bool tut = IsTutorialNetworkGroup(entity);
                        if (trace)
                        {
                            string action = tut ? "allow and return (Tutorial Zone)" : ruleSet.defaultAllowDamage ? "defaultAllowDamage is true; allow and return" : "block and return";
                            Trace($"Initiator empty for player damage; {action} (Damage Type: {damageType}, Damage Amount: {damageAmount})", 1);
                        }
                        return tut || ruleSet.defaultAllowDamage;
                    }
                }
                if (trace) Trace($"Initiator empty; allow and return {damageType} {damageAmount}", 1);
                return true;
            }

            DamageResult immortalFlag2 = CheckImmortalFlag(entity, ruleSet, initiator, info.WeaponPrefab);
            if (immortalFlag2 != DamageResult.None)
            {
                return immortalFlag2 == DamageResult.Allow;
            }

            if (initiator is SamSite ss && (isVictim || entity is BaseMountable))
            {
                if (CheckExclusion(ss))
                {
                    if (trace) Trace($"Initiator is samsite, and target is player; exclusion found; allow and return", 1);
                    return true;
                }

                bool isAllowed = ss.staticRespawn
                                 ? ((_flags & RuleFlags.StaticSamSitesIgnorePlayers) == 0)
                                 : ((_flags & RuleFlags.PlayerSamSitesIgnorePlayers) == 0);
                if (trace)
                {
                    string action = isAllowed ? "flag not set; allow and return" : "flag set; block and return";
                    Trace($"Initiator is samsite, and target is player; {action}", 1);
                }
                return isAllowed;
            }

            if ((isAttacker && !isAtkId) || initiator is BaseNpc || initiator is BaseNPC2)
            {
                if (isVictim && (_flags & RuleFlags.ProtectedSleepers) != 0 && victim.IsSleeping())
                {
                    if (trace) Trace("Target is sleeping player, with ProtectedSleepers flag set; block and return", 1);
                    return false;
                }

                if ((_flags & RuleFlags.NpcsCanHurtAnything) != 0)
                {
                    if (trace) Trace("Initiator is NPC; flag set; allow damage and return", 1);
                    return true;
                }
            }

            bool selfDamageFlag = (_flags & RuleFlags.SelfDamage) != 0;

            if (isVictim)
            {
                if (isVicId && initiator is AutoTurret && initiator.OwnerID == 0)
                {
                    if (initiator is NPCAutoTurret)
                    {
                        bool safezoneFlag = (_flags & RuleFlags.SafeZoneTurretsIgnorePlayers) == 0;
                        if (trace)
                        {
                            string action = safezoneFlag ? "allow and return" : "block and return";
                            Trace($"Initiator is npc turret; Target is player; {action}", 1);
                        }
                        return safezoneFlag;
                    }
                    bool staticFlag = (_flags & RuleFlags.StaticTurretsIgnorePlayers) == 0;
                    if (trace)
                    {
                        string action = staticFlag ? "allow and return" : "block and return";
                        Trace($"Initiator is static turret; Target is player; {action}", 1);
                    }
                    return staticFlag;
                }

                // handle suicide
                if (isVicId && damageType == DamageType.Suicide)
                {
                    bool isBlocked = (_flags & RuleFlags.SuicideBlocked) != 0;
                    if (trace)
                    {
                        string action = isBlocked ? "block and return" : "allow and return";
                        Trace($"DamageType is suicide; {action}", 1);
                    }
                    if (isBlocked) Message(victim, "Error_NoSuicide");
                    return !isBlocked;
                }

                // allow players to inflict self damage
                if (selfDamageFlag && isVicId && isAtkId && attacker.userID == victim.userID)
                {
                    if (trace) Trace($"SelfDamage flag; player inflicted damage to self; allow and return", 1);
                    return true;
                }
            }

            if (isAttacker)
            {
                if (isAtkId)
                {
                    var mounted = attacker.GetMounted() as BaseMountable;
                    if (mounted != null && !EvaluateRules(entity, mounted, ruleSet, false))
                    {
                        if (trace) Trace($"Player is mounted; evaluation? block and return", 1);
                        return false;
                    }
                }

                if (isAtkId && entity is BuildingBlock block && block.OwnerID != 0)
                {
                    if (attacker.GetMounted() is Minicopter mini)
                    {
                        bool eval = EvaluateRules(block, mini, ruleSet, false);
                        if (!eval)
                        {
                            if (trace) Trace("Initiator is player in minicopter, target is building; block and return", 1);
                            return eval;
                        }
                    }

                    if (block.grade == BuildingGrade.Enum.Twigs && (_flags & RuleFlags.TwigDamage) != 0)
                    {
                        bool isAllowed = ((_flags & RuleFlags.TwigDamageRequiresOwnership) == 0) || IsAlly(block.OwnerID, attacker.userID) || IsAuthed(block, attacker);
                        if (trace)
                        {
                            string action = isAllowed ? "allow" : "block";
                            Trace($"Initiator is player and target is twig block, with TwigDamage flag set; {action} and return", 1);
                        }
                        if (twigOutputHandlerEnabled && isAtkId && !isAllowed) TwigOutputHandler(block, damageType, damageAmount, attacker, selfDamageFlag);
                        return isAllowed;
                    }

                    if (block.grade == BuildingGrade.Enum.Wood && (_flags & RuleFlags.WoodenDamage) != 0)
                    {
                        bool isAllowed = ((_flags & RuleFlags.WoodenDamageRequiresOwnership) == 0) || IsAlly(block.OwnerID, attacker.userID) || IsAuthed(block, attacker);
                        if (trace)
                        {
                            string action = isAllowed ? "allow" : "block";
                            Trace($"Initiator is player and target is wood block, with WoodenDamage flag set; {action} and return", 1);
                        }
                        if (twigOutputHandlerEnabled && isAtkId && !isAllowed) TwigOutputHandler(block, damageType, damageAmount, attacker, selfDamageFlag);
                        return isAllowed;
                    }

                    if (twigOutputHandlerEnabled && isAtkId && !HandleBlockGrade(block, attacker, damageType, damageAmount, selfDamageFlag))
                    {
                        return false;
                    }
                }

                if ((_flags & RuleFlags.NoPlayerDamageToMini) != 0 && entity is Minicopter)
                {
                    if (trace) Trace("Initiator is player and target is Minicopter, with NoPlayerDamageToMini flag set; block and return", 1);
                    return false;
                }

                if ((_flags & RuleFlags.NoPlayerDamageToScrap) != 0 && entity is ScrapTransportHelicopter)
                {
                    if (trace) Trace("Initiator is player and target is ScrapTransportHelicopter, with NoPlayerDamageToScrap flag set; block and return", 1);
                    return false;
                }

                if ((_flags & RuleFlags.NoPlayerDamageToCar) != 0 && entity.PrefabName.Contains("modularcar"))
                {
                    if (trace) Trace("Initiator is player and target is ModularCar, with NoPlayerDamageToCar flag set; block and return", 1);
                    return false;
                }

                if (entity.OwnerID == 0 && entity is AdvancedChristmasLights)
                {
                    if (trace) Trace($"Entity is christmas lights; block and return", 1);
                    return false;
                }

                if (entity is GrowableEntity)
                {
                    bool isAllowed = !(entity.GetParentEntity() is PlanterBox planter) || IsAlly(planter.OwnerID, attacker.userID);
                    if (trace)
                    {
                        string action = isAllowed ? "allow ally" : "block non-ally";
                        Trace($"Entity is growable entity; {action} and return", 1);
                    }
                    return isAllowed;
                }

                if (config.SleepingBags && entity is SleepingBag)
                {
                    if (trace) Trace("Initiator is player and target is sleeping bag; allow and return", 1);
                    return true;
                }

                if (config.Campfires && entity.prefabID == campfire)
                {
                    if (trace) Trace("Initiator is player and target is campfire; allow and return", 1);
                    return true;
                }

                if (config.Ladders && entity is BaseLadder)
                {
                    if (trace) Trace("Initiator is player and target is ladder; allow and return", 1);
                    return true;
                }

                if (isVictim)
                {
                    if (isVicId && isAtkId && (_flags & RuleFlags.FriendlyFire) != 0 && victim.userID != attacker.userID && IsAlly(victim.userID, attacker.userID))
                    {
                        if (trace) Trace("Initiator and target are allied players, with FriendlyFire flag set; allow and return", 1);
                        return true;
                    }

                    // allow damage to players by admins if configured
                    if (attacker.IsAdmin && isVicId && (_flags & RuleFlags.AdminsHurtPlayers) != 0)
                    {
                        if (trace) Trace("Initiator is admin player and target is player, with AdminsHurtPlayers flag set; allow and return", 1);
                        return true;
                    }

                    // allow sleeper damage by admins if configured
                    if (attacker.IsAdmin && isVicId && (_flags & RuleFlags.AdminsHurtSleepers) != 0 && victim.IsSleeping())
                    {
                        if (trace) Trace("Initiator is admin player and target is sleeping player, with AdminsHurtSleepers flag set; allow and return", 1);
                        return true;
                    }

                    // allow Human NPC damage if configured
                    if ((_flags & RuleFlags.HumanNPCDamage) != 0 && (!isAtkId || !isVicId))
                    {
                        if (trace) Trace("Initiator or target is HumanNPC, with HumanNPCDamage flag set; allow and return", 1);
                        return true;
                    }
                }
                else if ((_flags & RuleFlags.AuthorizedDamage) != 0 && !isVictim && !entity.IsNpc && isAtkId && !(entity is FarmableAnimal))
                { // ignore checks if authorized damage enabled (except for players and npcs)
                    if ((_flags & RuleFlags.AuthorizedDamageCheckPrivilege) != 0)
                    {
                        if (entity is DecayEntity decayEntity && IsAuthed(decayEntity, attacker))
                        {
                            if (trace) Trace("Initiator is player with building priv over target; allow and return", 1);
                            return true;
                        }
                        if (entity is BaseHelicopter playerHelicopter && !(entity is PatrolHelicopter) && IsAuthed(playerHelicopter, attacker))
                        {
                            if (trace) Trace("Initiator is player with heli priv over target; allow and return", 1);
                            return true;
                        }
                        if (entity is Tugboat tugboat && IsAuthed(tugboat, attacker))
                        {
                            if (trace) Trace("Initiator is player with tugboat priv over target; allow and return", 1);
                            return true;
                        }
                        if (entity.HasParent() && entity.GetParentEntity() is Tugboat tugboat2 && IsAuthed(tugboat2, attacker))
                        {
                            if (trace) Trace("Initiator is player with tugboat priv over target; allow and return", 1);
                            return true;
                        }
                    }

                    if ((_flags & RuleFlags.AuthorizedDamageRequiresOwnership) != 0 && !IsAlly(entity.OwnerID, attacker.userID) && CanAuthorize(entity, attacker, ruleSet))
                    {
                        if (trace) Trace("Initiator is player who does not own the target; block and return", 1);
                        return false;
                    }

                    bool cupboardOwnership = (_flags & RuleFlags.CupboardOwnership) != 0;

                    if (CheckAuthorized(entity, attacker, ruleSet, cupboardOwnership))
                    {
                        if (entity is SamSite || entity is BaseMountable || entity.PrefabName.Contains("modular"))
                        {
                            if (trace) Trace($"Target is {entity.ShortPrefabName}; evaluate and return", 1);
                            return EvaluateRules(entity, attacker, ruleSet);
                        }
                        if (trace) Trace("Initiator is player with authorization over target; allow and return", 1);
                        return true;
                    }

                    if (cupboardOwnership)
                    {
                        if (trace) Trace("Initiator is player without authorization over target; block and return", 1);
                        return false;
                    }
                }
            }

            if (trace) Trace("No match in pre-checks; evaluating RuleSet rules...", 1);
            return EvaluateRules(entity, weapon, ruleSet);
        }

        private BuildingGrade.Enum[] GradeEnums = new BuildingGrade.Enum[] { BuildingGrade.Enum.Twigs, BuildingGrade.Enum.Wood, BuildingGrade.Enum.Stone, BuildingGrade.Enum.Metal, BuildingGrade.Enum.TopTier };

        private bool HandleBlockGrade(BuildingBlock block, BasePlayer attacker, DamageType damageType, float damageAmount, bool selfDamageFlag)
        {
            foreach (var grade in GradeEnums)
            {
                if (block.grade == grade)
                {
                    if (!(grade switch
                    {
                        BuildingGrade.Enum.Twigs when config.options.BlockHandler.Twig => true,
                        BuildingGrade.Enum.Wood when config.options.BlockHandler.Wood => true,
                        BuildingGrade.Enum.Stone when config.options.BlockHandler.Stone => true,
                        BuildingGrade.Enum.Metal when config.options.BlockHandler.Metal => true,
                        BuildingGrade.Enum.TopTier when config.options.BlockHandler.HQM => true,
                        _ => false
                    }))
                    {
                        continue;
                    }

                    bool isAllowed = IsAlly(block.OwnerID, attacker.userID) || IsAuthed(block, attacker);

                    if (trace)
                    {
                        string action = isAllowed ? $"{grade} continue checks" : "block and return";
                        Trace($"Initiator is player and target is {grade} block, {action}", 1);
                    }

                    if (!isAllowed)
                    {
                        TwigOutputHandler(block, damageType, damageAmount, attacker, selfDamageFlag);
                        return false;
                    }
                }
            }

            return true;
        }

        private void TwigOutputHandler(BuildingBlock block, DamageType damageType, float damageAmount, BasePlayer attacker, bool selfDamageFlag)
        {
            if (config.options.BlockHandler.Online && BasePlayer.FindByID(block.OwnerID) == null)
            {
                return;
            }
            if (config.options.BlockHandler.Log)
            {
                string grade = block.grade.ToString();
                string ownerDisplayName = BasePlayer.FindAwakeOrSleepingByID(block.OwnerID) is BasePlayer owner ? owner.displayName : "Unknown Owner";
                Puts($"{grade} Damage: Attacker - {attacker.displayName} ({attacker.userID}) | {grade} Owner: {ownerDisplayName} ({block.OwnerID}) at Location: {block.transform.position} | Damage Amount: {damageAmount}");
            }

            if (config.options.BlockHandler.Notify)
            {
                SendReply(attacker, GetMessage("Twig", attacker.UserIDString));
            }

            if (config.options.BlockHandler.ReflectDamageMultiplier > 0f)
            {
                float reflectedDamage = damageAmount * config.options.BlockHandler.ReflectDamageMultiplier;

                if (!selfDamageFlag)
                {
                    damageType = DamageType.Radiation;
                }

                attacker.Hurt(damageAmount, damageType, attacker, config.options.BlockHandler.ReflectDamageProtection);

                if (config.options.BlockHandler.Log)
                {
                    Puts($"Debug: Attacker {attacker.displayName} ({attacker.userID}) was hurt for {reflectedDamage} damage. New Health: {attacker.health}");
                }
            }
        }

        private bool IsTutorialNetworkGroup(BaseEntity entity)
        {
            if (entity.net == null || entity.net.group == null) return false;
            return TutorialIsland.IsTutorialNetworkGroup(entity.net.group.ID);
        }

        private DamageResult CheckImmortalFlag(BaseEntity entity, RuleSet ruleSet, BaseEntity initiator, BaseEntity weaponPrefab)
        {
            // Check storage containers and doors for locks for player entity only
            if ((ruleSet._flags & RuleFlags.LockedBoxesImmortal) != 0 && entity is StorageContainer && !(entity is LootContainer) || (ruleSet._flags & RuleFlags.LockedDoorsImmortal) != 0 && entity is Door)
            {
                if ((ruleSet._flags & RuleFlags.ExcludeTugboatFromImmortalFlags) != 0 && entity.GetParentEntity() is Tugboat)
                {
                    if (trace) Trace($"Player Door/StorageContainer detected with immortal flag on tugboat with ImmortalExcludesTugboats flag; allow and return", 1);
                    return DamageResult.Allow;
                }
                DamageResult hurt = CheckLock(ruleSet, entity, initiator, weaponPrefab); // check for lock
                if (trace)
                {
                    string action = hurt == DamageResult.None ? "null (no lock or unlocked); continue checks" : hurt == DamageResult.Allow ? "allow and return" : "block and return";
                    Trace($"Player Door/StorageContainer detected with immortal flag; lock check results: {action}", 1);
                }
                return hurt;
            }
            return DamageResult.None;
        }

        private bool HandleHelicopter(RuleSet ruleSet, BaseEntity entity, BaseEntity weapon, BasePlayer victim, bool isVicId, bool allow)
        {
            if (isVicId)
            {
                if ((ruleSet._flags & RuleFlags.NoHeliDamageSleepers) != 0)
                {
                    if (trace)
                    {
                        string action1 = victim.IsSleeping() ? "victim is sleeping; block and return" : "victim is not sleeping; continue checks";
                        Trace($"Initiator is heli, and target is player; flag check results: {action1}", 1);
                    }
                    if (victim.IsSleeping()) return false;
                }
                bool val = (ruleSet._flags & RuleFlags.NoHeliDamagePlayer) != 0;
                if (trace)
                {
                    string action = val ? "flag set; block and return" : "flag not set; allow and return";
                    Trace($"Initiator is heli, and target is player; flag check results: {action}", 1);
                }
                return !val;
            }
            if (entity is MiningQuarry)
            {
                bool val = (ruleSet._flags & RuleFlags.NoHeliDamageQuarry) != 0;
                if (trace)
                {
                    string action = val ? "flag set; block and return" : "flag not set; allow and return";
                    Trace($"Initiator is heli, and target is quarry; flag check results: {action}", 1);
                }
                return !val;
            }
            if (entity is RidableHorse2)
            {
                bool val = (ruleSet._flags & RuleFlags.NoHeliDamageRidableHorses) != 0;
                if (trace)
                {
                    string action = val ? "flag set; block and return" : "flag not set; allow and return";
                    Trace($"Initiator is heli, and target is ridablehorse; flag check results: {action}", 1);
                }
                return !val;
            }
            if ((ruleSet._flags & RuleFlags.NoHeliDamageBuildings) != 0 && IsPlayerEntity(entity))
            {
                if (!entity.HasParent() && entity is DecayEntity decayEntity && !HasBuildingPrivilege(decayEntity))
                {
                    if (trace) Trace($"Initiator is heli, {entity.ShortPrefabName} is not within TC; allow and return", 1);
                    return true;
                }
                if (trace) Trace($"Initiator is heli, {entity.ShortPrefabName} is within TC; block and return", 1);
                return false;
            }
            if (trace)
            {
                if (entity is FarmableAnimal || entity is ChickenCoop) allow = false;
                string action = allow ? "allow and return" : "block and return";
                Trace($"Initiator is heli, target is {entity.ShortPrefabName}; {action}", 1);
            }
            return allow;
        }

        private bool HasBuildingPrivilege(DecayEntity decayEntity)
        {
            var building = decayEntity.GetBuilding();
            if (building == null) return false;
            return building.GetDominatingBuildingPrivilege();
        }

        private bool IsAlly(ulong vic, ulong atk) => vic switch
        {
            _ when vic == atk => true,
            _ when RelationshipManager.ServerInstance.playerToTeam.TryGetValue(vic, out var team) && team.members.Contains(atk) => true,
            _ when Clans != null && Convert.ToBoolean(Clans?.Call("IsClanMember", vic, atk)) => true,
            _ when Friends != null && Convert.ToBoolean(Friends?.Call("AreFriends", vic, atk)) => true,
            _ => false
        };

        private bool CanAuthorize(BaseEntity entity, BasePlayer attacker, RuleSet ruleSet)
        {
            if (entity is BaseVehicle && !EvaluateRules(entity, attacker, ruleSet, false))
            {
                return false;
            }

            if (entity.OwnerID == 0)
            {
                return entity is Minicopter;
            }

            return IsPlayerEntity(entity);
        }

        private bool IsPlayerEntity(BaseEntity entity)
        {
            if (entity is BaseMountable || entity is LegacyShelter || entity is LegacyShelterDoor || entity is FarmableAnimal)
            {
                return true;
            }

            if (entity.PrefabName.IndexOf("building", StringComparison.Ordinal) >= 0)
            {
                return true;
            }

            if (entity.PrefabName.IndexOf("modular", StringComparison.Ordinal) >= 0)
            {
                return true;
            }

            if (_deployables.Count == 0)
            {
                foreach (var def in ItemManager.GetItemDefinitions())
                {
                    if (def.TryGetComponent<ItemModDeployable>(out var imd))
                    {
                        _deployables.Add(imd.entityPrefab.resourcePath);
                    }
                }
            }

            return _deployables.Contains(entity.PrefabName);
        }

        private void ExcludePlayer(ulong userid, float maxDelayLength, Plugin plugin)
        {
            if (plugin == null)
            {
                return;
            }
            if (!playerDelayExclusions.TryGetValue(userid, out var exclusions))
            {
                playerDelayExclusions[userid] = exclusions = Pool.Get<List<PlayerExclusion>>();
            }
            var exclusion = exclusions.Find(x => x.plugin == plugin);
            if (maxDelayLength <= 0f)
            {
                if (exclusion != null)
                {
                    exclusions.Remove(exclusion);
                    exclusion.plugin = null;
                    exclusion.time = 0f;
                    Pool.Free(ref exclusion);
                }
                if (exclusions.Count == 0)
                {
                    playerDelayExclusions.Remove(userid);
                    Pool.FreeUnmanaged(ref exclusions);
                }
            }
            else
            {
                if (exclusion == null)
                {
                    exclusion = Pool.Get<PlayerExclusion>();
                    exclusions.Add(exclusion);
                }
                exclusion.plugin = plugin;
                exclusion.time = Time.time + maxDelayLength;
            }
        }

        private bool HasDelayExclusion(ulong userid)
        {
            if (playerDelayExclusions.TryGetValue(userid, out var exclusions))
            {
                for (int i = 0; i < exclusions.Count; i++)
                {
                    var exclusion = exclusions[i];
                    if (!exclusion.IsExpired)
                    {
                        return true;
                    }
                    exclusions.RemoveAt(i);
                    exclusion.plugin = null;
                    exclusion.time = 0f;
                    Pool.Free(ref exclusion);
                    i--;
                }
                if (exclusions.Count == 0)
                {
                    playerDelayExclusions.Remove(userid);
                    Pool.Free(ref exclusions);
                }
            }
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool PlayerHasExclusion(BasePlayer player, PooledList<string> locs)
        {
            if (playerDelayExclusions.Count > 0 && HasDelayExclusion(player.userID))
            {
                return true;
            }
            float playerY = player.transform.position.y;
            if ((config.options.Aboveworld < 5000f && playerY >= config.options.Aboveworld) ||
                (config.options.Underworld > -500f && playerY <= config.options.Underworld))
            {
                return true;
            }
            if (locs != null && locs.Count > 0)
            {
                foreach (var loc in locs)
                {
                    if (config.mappings.TryGetValue(loc, out var mapping) && mapping == "exclude")
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool PlayerHasExclusion(BasePlayer player)
        {
            if (playerDelayExclusions.Count > 0 && HasDelayExclusion(player.userID))
            {
                return true;
            }
            float playerY = player.transform.position.y;
            if ((config.options.Aboveworld < 5000f && playerY >= config.options.Aboveworld) ||
                (config.options.Underworld > -500f && playerY <= config.options.Underworld))
            {
                return true;
            }
            if (useZones)
            {
                using var locs = GetLocationKeys(player);
                if (locs != null && locs.Count > 0)
                {
                    foreach (var loc in locs)
                    {
                        if (config.mappings.TryGetValue(loc, out var mapping) && mapping == "exclude")
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        [HookMethod("GetPlayerMapping")]
        public string GetPlayerMapping(BasePlayer player)
        {
            var t = trace;
            trace = false;
            RuleSet ruleSet;
            if (useZones)
            {
                using var entityLocations = GetLocationKeys(player);
                ruleSet = GetRuleSet(entityLocations, entityLocations);
                trace = t;
                if (!entityLocations.IsNullOrEmpty())
                {
                    foreach (var loc in entityLocations)
                    {
                        if (config.mappings.TryGetValue(loc, out var locMapping))
                        {
                            return locMapping;
                        }
                    }
                }
            }
            else ruleSet = currentRuleSet;
            trace = t;
            if (ruleSet != null && ruleSet.enabled && !ruleSet.IsEmpty() && config.mappings.TryGetValue(ruleSet.name, out var ruleSetMapping))
            {
                return ruleSetMapping;
            }
            return "default";
        }

        // process rules to determine whether to allow damage
        private bool EvaluateRules(BaseEntity entity, BaseEntity attacker, RuleSet ruleSet, bool returnDefaultValue = true)
        {
            List<string> e0Groups = config.ResolveEntityGroups(attacker);
            List<string> e1Groups = config.ResolveEntityGroups(entity);

            if (trace)
            {
                string action1 = ConcatenateListOrDefault(e0Groups, "none");
                string action2 = ConcatenateListOrDefault(e1Groups, "none");
                Trace($"Initiator EntityGroup matches: {action1}", 2);
                Trace($"Target EntityGroup matches: {action2}", 2);
            }

            return ruleSet.Evaluate(this, e0Groups, e1Groups, returnDefaultValue);
        }

        // checks an entity to see if it has a lock
        private DamageResult CheckLock(RuleSet ruleSet, BaseEntity entity, BaseEntity initiator, BaseEntity weaponPrefab)
        {
            var slot = entity.GetSlot(BaseEntity.Slot.Lock); // check for lock

            if (slot == null || !slot.IsLocked())
            {
                return DamageResult.None; // no lock or unlocked, continue checks
            }

            // if HeliDamageLocked flag is false or NoHeliDamage flag, all damage is cancelled from immortal flag
            if ((ruleSet._flags & RuleFlags.HeliDamageLocked) == 0 || (ruleSet._flags & RuleFlags.NoHeliDamage) != 0)
            {
                return DamageResult.Block;
            }

            return CheckHeliInitiator(ruleSet, initiator, weaponPrefab); // cancel damage except from heli
        }

        private DamageResult CheckHeliInitiator(RuleSet ruleSet, BaseEntity initiator, BaseEntity weaponPrefab)
        {
            // Check for heli initiator
            if (initiator is PatrolHelicopter || (initiator != null && (initiator.prefabID.Equals(oilfireballsmall) || initiator.prefabID.Equals(heli_napalm))))
            {
                return (ruleSet._flags & RuleFlags.NoHeliDamage) == 0 ? DamageResult.Allow : DamageResult.Block;
            }
            else if (weaponPrefab != null && (weaponPrefab.prefabID.Equals(rocket_heli) || weaponPrefab.prefabID.Equals(rocket_heli_napalm)))
            {
                return (ruleSet._flags & RuleFlags.NoHeliDamage) == 0 ? DamageResult.Allow : DamageResult.Block;
            }
            return DamageResult.None;
        }

        // checks if the player is authorized to damage the entity
        private bool CheckAuthorized(BaseEntity entity, BasePlayer player, RuleSet ruleSet, bool cupboardOwnership)
        {
            if (!cupboardOwnership)
            {
                return entity.OwnerID == 0 && !entity.InSafeZone() || IsAlly(entity.OwnerID, player.userID); // allow damage to entities that the player owns or is an ally of
            }

            // treat entities outside of cupboard range as unowned, and entities inside cupboard range require authorization
            if (entity is LegacyShelter || entity is LegacyShelterDoor)
            {
                var entityPriv = entity.GetEntityBuildingPrivilege();

                return entityPriv == null || entityPriv.AnyAuthed() && entityPriv.IsAuthed(player);
            }

            BuildingPrivlidge priv = null;
            if (entity is DecayEntity decayEntity)
            {
                BuildingManager.Building building = decayEntity.GetBuilding();
                if (building != null)
                {
                    priv = building.GetDominatingBuildingPrivilege();
                }
            }

            if (priv == null)
            {
                priv = player.GetBuildingPrivilege(entity.WorldSpaceBounds());
            }

            return priv == null || priv.AnyAuthed() && priv.IsAuthed(player);
        }

        private bool IsFunTurret(AutoTurret turret)
        {
            return turret.GetAttachedWeapon() is BaseProjectile projectile && projectile.GetItem() is Item weapon && weapon.info.shortname.StartsWith("fun.");
        }

        private object OnSamSiteTarget(BaseEntity attacker, BaseEntity entity)
        {
            SamSite ss = attacker as SamSite;
            if (Interface.CallHook("CanEntityBeTargeted", new object[] { entity, attacker }) is bool val)
            {
                if (val)
                {
                    if (trace) Trace($"CanEntityBeTargeted allowed {entity.ShortPrefabName} to be targetted by SamSite", 1);
                    return null;
                }

                if (trace) Trace($"CanEntityBeTargeted blocked {entity.ShortPrefabName} from being targetted by SamSite", 1);
                if (ss != null)
                {
                    ss.CancelInvoke(ss.WeaponTick);
                }
                return true;
            }

            RuleSet ruleSet = GetRuleSet(entity, attacker);

            if (ruleSet == null)
            {
                if (trace) Trace($"OnSamSiteTarget allowed {entity.ShortPrefabName} to be targetted; no ruleset found.", 1);
                return null;
            }

            if (entity is MLRSRocket)
            {
                if ((ruleSet._flags & RuleFlags.SamSitesIgnoreMLRS) != 0) return SamSiteHelper(ss, entity);
                return null;
            }

            var staticRespawn = ss == null ? attacker.OwnerID == 0 : ss.staticRespawn;
            if (staticRespawn && (ruleSet._flags & RuleFlags.StaticSamSitesIgnorePlayers) != 0) return SamSiteHelper(attacker, entity);
            if (!staticRespawn && (ruleSet._flags & RuleFlags.PlayerSamSitesIgnorePlayers) != 0) return SamSiteHelper(attacker, entity);

            return null;
        }

        private object OnMlrsFire(MLRS mlrs, BasePlayer player)
        {
            if (mlrs == null || player == null)
            {
                return true;
            }

            if (Interface.CallHook("CanMlrsTargetLocation", new object[] { mlrs, player }) is bool val)
            {
                if (val)
                {
                    if (trace) Trace($"CanMlrsTargetLocation allowed {mlrs.TrueHitPos} to be targetted by {player.displayName}", 1);
                    return null;
                }

                if (trace) Trace($"CanMlrsTargetLocation blocked {mlrs.TrueHitPos} from being targetted by {player.displayName}", 1);
                return true;
            }

            RuleSet ruleSet = GetRuleSet(player, mlrs);

            if (ruleSet == null)
            {
                if (trace) Trace($"CanMlrsTargetLocation allowed {mlrs.TrueHitPos} to be targetted by {player.displayName}; no ruleset found.", 1);
                return null;
            }

            return (ruleSet._flags & RuleFlags.NoMLRSDamage) != 0 ? true : (object)null;
        }

        private object CanWaterBallSplash(ItemDefinition liquidDef, Vector3 position, float radius, int amount)
        {
            if (liquidDef == WaterTypes.RadioactiveWaterItemDef)
            {
                return false;
            }
            return null;
        }

        private object OnEntityMarkHostile(BasePlayer player, float duration) => true;

#if OXIDE_PUBLICIZED || CARBON
        private void OnEntitySpawned(RidableHorse2 horse)
        {
            if (config.PreventRagdolling && horse != null)
            {
                horse.playerRagdollThreshold = float.MaxValue;
            }
        }

        private void CanRagdollDismount(BaseRagdoll ragdoll, BasePlayer player)
        {
            if (config.PreventRagdolling && ragdoll != null)
            {            
                ragdoll.dieOnImpact = false;
            }
        }
#endif

        private void OnEntitySpawned(BaseOven oven)
        {
            if (config.options.disableBaseOvenSplash && oven != null)
            {
                oven.disabledBySplash = false;
            }
        }

        private void OnEntitySpawned(MLRSRocket rocket)
        {
            if (rocket == null || rocket.IsDestroyed) return;
            using var systems = Pool.Get<PooledList<MLRS>>();
            Vis.Entities(rocket.transform.position, 15f, systems, -1);
            if (systems.Count == 0 || CheckIsEventTerritory(systems[0].TrueHitPos)) return;
            if (systems[0].rocketOwnerRef.Get(true) is not BasePlayer owner) return;
            rocket.creatorEntity = owner;
            rocket.OwnerID = owner.userID;
        }

        private BeeSwarmMaster _lastSwarmMaster;
        private void OnEntitySpawned(BeeSwarmMaster swarm)
        {
            if (swarm == null || swarm.creatorEntity != null) return;
            _lastSwarmMaster = swarm;
            InvokeHandler.Instance.Invoke(() => _lastSwarmMaster = null, 0.1f);
        }

        private void OnTimedExplosiveExplode(BeeGrenade grenade, Vector3 fxPos)
        {
            if (_lastSwarmMaster == null || _lastSwarmMaster.IsDestroyed || grenade == null || grenade.IsDestroyed) return;
            if ((_lastSwarmMaster.transform.position - grenade.transform.position).sqrMagnitude <= 9f)
            {
                _lastSwarmMaster.creatorEntity = grenade.creatorEntity;
            }
            _lastSwarmMaster = null;
        }

        private void OnEntitySpawned(BeeSwarmAI ai)
        {
            if (ai == null || ai.IsDestroyed || ai.creatorEntity != null) return;
            using var masters = Pool.Get<PooledList<BeeSwarmMaster>>();
            Vis.Entities(ai.transform.position, 0.001f, masters);
            if (masters.Count == 0 || masters[0] == null) return;
            ai.creatorEntity = masters[0].creatorEntity;
        }

        private bool CheckIsEventTerritory(Vector3 position)
        {
            if (AbandonedBases != null && AbandonedBases.IsLoaded && Convert.ToBoolean(AbandonedBases?.Call("EventTerritory", position))) return true;
            if (RaidableBases != null && RaidableBases.IsLoaded && Convert.ToBoolean(RaidableBases?.Call("EventTerritory", position))) return true;
            return false;
        }

        private object SamSiteHelper(BaseEntity attacker, BaseEntity entity)
        {
            if (useZones)
            {
                using var entityLocations = GetLocationKeys(entity);
                using var initiatorLocations = GetLocationKeys(attacker);

                // check for exclusion zones (zones with no rules mapped)
                if (CheckExclusion(entityLocations, initiatorLocations, false))
                {
                    if (trace) Trace($"OnSamSiteTarget allowed {entity.ShortPrefabName} to be targetted; exclusion of zone found.", 1);
                    return null;
                }
            }

            // check for exclusions in entity groups
            if (CheckExclusion(attacker))
            {
                if (trace) Trace($"OnSamSiteTarget allowed {entity.ShortPrefabName} to be targetted; exclusion found in entity group.", 1);
                return null;
            }

            if (trace && entity is BasePlayer) Trace($"SamSitesIgnorePlayers blocked {entity.ShortPrefabName} from being targetted.", 1);
            else if (trace && entity is MLRSRocket) Trace($"SamSitesIgnoreMLRS blocked {entity.ShortPrefabName} from being targetted.", 1);
            if (attacker is SamSite ss)
            {
                ss.CancelInvoke(ss.WeaponTick);
            }
            return true;
        }

        // Check if entity can be targeted
        private object OnEntityEnter(TargetTrigger trigger, BasePlayer target)
        {
            if (trigger == null || target == null)
            {
                return null;
            }

            var entity = trigger.gameObject.ToBaseEntity();
            if (!entity.IsValid())
            {
                return null;
            }

            return OnEntityEnterInternal(entity, target);
        }

        private static void DrawText(BasePlayer player, float duration, Color color, Vector3 from, object text) => player?.SendConsoleCommand("ddraw.text", duration, color, from, $"<size=24>{text}</size>");

        private object OnEntityEnterInternal(BaseEntity entity, BasePlayer target)
        {
            if (Interface.CallHook("CanEntityBeTargeted", new object[] { target, entity }) is bool val)
            {
                return val ? (object)null : true;
            }

            if (config.PlayersTriggerTurrets && entity.OwnerID == 0uL && target.userID.IsSteamId() && (entity is FlameTurret || entity is AutoTurret) && !entity.HasParent())
            {
                return null;
            }

            RuleSet ruleSet = GetRuleSet(target, entity);

            if (ruleSet == null)
            {
                return null;
            }

            var isAutoTurret = entity is AutoTurret;
            var isStatic = !entity.OwnerID.IsSteamId();
            var isSafeZone = entity is NPCAutoTurret && entity.OwnerID == 0;

            if (!target.userID.IsSteamId())
            {
                if (isAutoTurret)
                {
                    if (isStatic)
                    {
                        return (ruleSet._flags & RuleFlags.StaticTurretsIgnoreScientist) != 0 ? true : (object)null;
                    }
                    return (ruleSet._flags & RuleFlags.TurretsIgnoreScientist) != 0 ? true : (object)null;
                }
                else
                {
                    return (ruleSet._flags & RuleFlags.TrapsIgnoreScientist) != 0 ? true : (object)null;
                }
            }
            else if (isSafeZone)
            {
                return (ruleSet._flags & RuleFlags.SafeZoneTurretsIgnorePlayers) != 0 ? true : (object)null;
            }
            else if (isAutoTurret && (ruleSet._flags & (isStatic ? RuleFlags.StaticTurretsIgnorePlayers : RuleFlags.TurretsIgnorePlayers)) != 0 || !isAutoTurret && (ruleSet._flags & RuleFlags.TrapsIgnorePlayers) != 0)
            {
                if (isAutoTurret && IsFunTurret(entity as AutoTurret))
                {
                    return null;
                }

                if (useZones)
                {
                    using var entityLocations = GetLocationKeys(target);
                    using var initiatorLocations = GetLocationKeys(entity);

                    // check for exclusion zones (zones with no rules mapped)
                    if (CheckExclusion(entityLocations, initiatorLocations, trace))
                    {
                        return null;
                    }
                }

                // check for exclusions in entity group
                if (CheckExclusion(target, entity) || CheckExclusion(entity))
                {
                    return null;
                }

                return true;
            }

            return null;
        }

        private object OnTurretTarget(AutoTurret turret, BradleyAPC target)
        {
            if (turret == null || target == null) return null;
            RuleSet ruleSet = GetRuleSet(target, turret);

            if (ruleSet == null)
            {
                return null;
            }

            if ((ruleSet._flags & RuleFlags.TurretsIgnoreBradley) == 0)
            {
                // flag not set, do nothing
                return null;
            }

            if (useZones)
            {
                using var entityLocations = GetLocationKeys(target);
                using var initiatorLocations = GetLocationKeys(turret);

                // check for exclusion zones (zones with no rules mapped)
                if (CheckExclusion(entityLocations, initiatorLocations, trace))
                {
                    // zone exclusion, do nothing
                    return null;
                }
            }

            // check for exclusions in entity group
            if (CheckExclusion(target, turret))
            {
                // group exclusion, do nothing
                return null;
            }

            // prevent turret from targeting bradley
            return true;
        }

        private object OnTurretTarget(AutoTurret turret, BasePlayer target)
        {
            if (turret == null || target == null) return null;
            return OnEntityEnterInternal(turret, target);
        }

        // ignore players stepping on traps if configured
        private object OnTrapTrigger(BaseTrap trap, GameObject go)
        {
            if (go == null || trap == null || !go.TryGetComponent(out BasePlayer player))
            {
                return null;
            }

            if (Interface.CallHook("CanEntityTrapTrigger", new object[] { trap, player }) is bool val)
            {
                return val ? (object)null : true;
            }

            RuleSet ruleSet = GetRuleSet(player, trap);

            if (ruleSet == null)
            {
                return null;
            }

            if ((player.IsNpc || !player.userID.IsSteamId()) && (ruleSet._flags & RuleFlags.TrapsIgnoreScientist) != 0)
            {
                return true;
            }
            else if (player.userID.IsSteamId() && (ruleSet._flags & RuleFlags.TrapsIgnorePlayers) != 0)
            {
                if (useZones)
                {
                    using var entityLocations = GetLocationKeys(player);
                    using var initiatorLocations = GetLocationKeys(trap);

                    // check for exclusion zones (zones with no rules mapped)
                    if (CheckExclusion(entityLocations, initiatorLocations, false))
                    {
                        return null;
                    }
                }

                if (CheckExclusion(trap))
                {
                    return null;
                }

                if (config.PlayersTriggerTraps && trap.OwnerID == 0uL && !trap.HasParent())
                {
                    return null;
                }

                return true;
            }

            return null;
        }

        private object OnNpcTarget(BaseNpc npc, BasePlayer target) => OnNpcTargetInternal(npc, target);

        private object OnNpcTarget(BaseNPC2 npc, BasePlayer target) => OnNpcTargetInternal(npc, target);

        private object OnNpcTargetInternal(BaseEntity npc, BasePlayer target)
        {
            string cacheKey = $"{npc}_{target}";

            if (_npcCache.TryGetValue(cacheKey, out object value))
            {
                return value;
            }

            if (npc == null || target == null || !target.userID.IsSteamId() || !target.IsSleeping())
            {
                return _npcCache.Set(cacheKey, null);
            }

            RuleSet ruleSet = GetRuleSet(target, npc);

            if (ruleSet == null || !animalsIgnoreSleepers && (ruleSet._flags & RuleFlags.AnimalsIgnoreSleepers) == 0)
            {
                return null;
            }

            if (useZones)
            {
                using var entityLocations = GetLocationKeys(target);
                using var initiatorLocations = GetLocationKeys(npc);

                // check for exclusion zones (zones with no rules mapped)
                if (CheckExclusion(entityLocations, initiatorLocations, false))
                {
                    return _npcCache.Set(cacheKey, null);
                }
            }

            return _npcCache.Set(cacheKey, true);
        }

        // Check for exclusions in entity groups (attacker)
        private bool CheckExclusion(BaseEntity attacker)
        {
            string attackerName = attacker.GetType().Name;

            foreach (var group in config.groups)
            {
                if (group.IsExclusion(attacker.ShortPrefabName) || group.IsExclusion(attackerName))
                {
                    return true;
                }
            }

            return false;
        }

        // Check for exclusions in entity groups (target, attacker)
        private bool CheckExclusion(BaseEntity target, BaseEntity attacker)
        {
            string targetName = target.GetType().Name;
            string attackerName = attacker.GetType().Name;

            foreach (var vicGroup in config.groups)
            {
                if (vicGroup.IsMember(target.ShortPrefabName) || vicGroup.IsExclusion(targetName))
                {
                    // Target is in a relevant group; now check attacker exclusions
                    foreach (var atkGroup in config.groups)
                    {
                        if (atkGroup.IsExclusion(attacker.ShortPrefabName) || atkGroup.IsExclusion(attackerName))
                        {
                            return true; // Exclusion found for attacker
                        }
                    }

                    return false; // Target is in a group, but no attacker exclusion found
                }
            }

            return false; // Target is not in any member or exclusion group
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private RuleSet GetRuleSet(PooledList<string> vicLocations, PooledList<string> atkLocations)
        {
            bool hasAtkLocations = !atkLocations.IsNullOrEmpty();
            bool hasVicLocations = !vicLocations.IsNullOrEmpty();

            if (shareRedirectDudEnabled && (hasAtkLocations ^ hasVicLocations))
            {
                return dudRuleSet;
            }

            if (!hasVicLocations)
            {
                if (trace) Trace("No shared locations with attacker (empty locations for victim) - no exclusions", 3);
                return currentRuleSet;
            }

            if (!hasAtkLocations)
            {
                if (trace) Trace("No shared locations with victim (empty locations for attacker) - no exclusions", 3);
                return currentRuleSet;
            }

            if (trace)
            {
                string str1 = ConcatenateListOrDefault(vicLocations, "empty");
                string str2 = ConcatenateListOrDefault(atkLocations, "empty");

                Trace($"Beginning RuleSet lookup for [{str1}] and [{str2}]", 2);
            }

            RuleSet ruleSet = currentRuleSet;

            using var sharedLocations = GetSharedLocations(vicLocations, atkLocations);

            if (trace)
            {
                string str = ConcatenateListOrDefault(sharedLocations, "none");

                Trace($"Shared locations: {str}", 3);
            }

            if (sharedLocations.Count > 0)
            {
                using var names = Pool.Get<PooledList<string>>();
                foreach (var loc in sharedLocations)
                {
                    if (config.mappings.TryGetValue(loc, out string mapping))
                    {
                        names.Add(mapping);
                    }
                }

                using var sets = Pool.Get<PooledList<RuleSet>>();
                foreach (var name in names)
                {
                    if (ruleSetByNameDictionary.TryGetValue(name, out RuleSet set))
                    {
                        sets.Add(set);
                    }
                }

                if (trace)
                {
                    Trace($"Found {names.Count} location names, with {sets.Count} mapped RuleSets", 3);
                }

                if (sets.Count == 0 && config.mappings.TryGetValue(AllZones, out var val) && ruleSetByNameDictionary.TryGetValue(val, out RuleSet all))
                {
                    sets.Add(all);

                    if (trace)
                    {
                        Trace($"Found allzones mapped RuleSet", 3);
                    }
                }

                if (sets.Count > 1)
                {
                    string ruleSetNames = ConcatenateRuleSetNames(sets);

                    if (trace)
                    {
                        Trace($"WARNING: Found multiple RuleSets: {ruleSetNames}", 3);
                    }

                    Puts(ruleSetNames);
                }

                if (sets.Count > 0)
                {
                    ruleSet = sets[0];

                    if (trace)
                    {
                        Trace($"Found RuleSet: {ruleSet?.name ?? "null"}", 3);
                    }
                }
            }

            if (ruleSet == null)
            {
                ruleSet = currentRuleSet;

                if (trace)
                {
                    Trace($"No RuleSet found; assigned current global RuleSet: {ruleSet?.name ?? "null"}", 3);
                }
            }

            return ruleSet;
        }

        private RuleSet GetRuleSet(BaseEntity e0, BaseEntity e1)
        {
            using var vic = GetLocationKeys(e0);
            using var atk = GetLocationKeys(e1);
            return GetRuleSet(vic, atk);
        }

        // get locations shared between the two passed location lists
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        private PooledList<string> GetSharedLocations(PooledList<string> e0Locations, PooledList<string> e1Locations)
        {
            var sharedLocations = Pool.Get<PooledList<string>>();

            if (e0Locations == null || e1Locations == null || e0Locations.Count == 0 || e1Locations.Count == 0)
                return sharedLocations;

            foreach (string loc in e0Locations)
            {
                if (e1Locations.Contains(loc) && config.HasMapping(loc))
                {
                    sharedLocations.Add(loc);
                }
            }

            return sharedLocations;
        }

        // Check exclusion for given entity locations
        private bool CheckExclusion(PooledList<string> e0Locations, PooledList<string> e1Locations, bool trace)
        {
            if (e0Locations == null || e1Locations == null)
            {
                if (trace) Trace("No shared locations (empty location) - no exclusions", 3);
                return false;
            }
            if (excludeAllZones)
            {
                if (trace) Trace("All zones are excluded via 'AllZones' mapping. Exclusion found.", 3);
                return true;
            }
            using var sharedLocations = GetSharedLocations(e0Locations, e1Locations);
            if (trace)
            {
                string action1 = ConcatenateListOrDefault(e0Locations, "empty");
                string action2 = ConcatenateListOrDefault(e1Locations, "empty");
                string action3 = ConcatenateListOrDefault(sharedLocations, "none");
                Trace($"Checking exclusions between [{action1}] and [{action2}]", 2);
                Trace($"Shared locations: {action3}", 3);
            }
            if (sharedLocations.Count > 0)
            {
                foreach (string loc in sharedLocations)
                {
                    if (exclusionLocationsSet.Contains(loc))
                    {
                        if (trace) Trace($"Found exclusion mapping for location: {loc}", 3);
                        return true;
                    }
                }
            }
            if (trace) Trace("No shared locations, or no matching exclusion mapping - no exclusions", 3);
            return false;
        }

        // add or update a mapping
        private bool AddOrUpdateMapping(string key, string ruleset)
        {
            if (string.IsNullOrEmpty(key) || config == null || ruleset == null || (ruleset != "exclude" && !config.ruleSets.Exists(r => r.name == ruleset)))
            {
                return false;
            }

            config.mappings[key] = ruleset;
            SaveConfig();
            TryBuildExclusionMappings();

            return true;
        }

        // remove a mapping
        private bool RemoveMapping(string key)
        {
            if (config.mappings.Remove(key))
            {
                SaveConfig();
                return true;
            }
            return false;
        }
        #endregion

        #region Messaging
        private void Message(BasePlayer player, string key, params object[] args)
        {
            string message = BuildMessage(player, key, args);
            if (string.IsNullOrEmpty(message)) return;
            SendReply(player, message);
        }

        private void Message(IPlayer user, string key, params object[] args)
        {
            string message = BuildMessage(user.Object as BasePlayer, key, args);
            if (string.IsNullOrEmpty(message)) return;
            user.Reply(RemoveFormatting(message));
        }

        // build message string
        private string BuildMessage(BasePlayer player, string key, params object[] args)
        {
            string message = GetMessage(key, player?.UserIDString);
            if (string.IsNullOrEmpty(message)) return string.Empty;
            if (args.Length > 0) message = string.Format(message, args);
            string type = key.Split('_')[0];
            if (player != null)
            {
                string size = GetMessage("Format_" + type + "Size");
                string color = GetMessage("Format_" + type + "Color");
                return WrapSize(size, WrapColor(color, message));
            }
            else
            {
                string color = GetMessage("Format_" + type + "Color");
                return WrapColor(color, message);
            }
        }

        // prints the value of an Option
        private void PrintValue(ConsoleSystem.Arg arg, string text, bool value)
        {
            SendReply(arg, WrapSize(GetMessage("Format_NotifySize"), WrapColor(GetMessage("Format_NotifyColor"), text + ": ") + value));
        }

        // wrap string in <size> tag, handles parsing size string to integer
        private string WrapSize(string size, string input)
        {
            return int.TryParse(size, out var i) ? WrapSize(i, input) : input;
        }

        // wrap a string in a <size> tag with the passed size
        private string WrapSize(int size, string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;
            return "<size=" + size + ">" + input + "</size>";
        }

        // wrap a string in a <color> tag with the passed color
        private string WrapColor(string color, string input)
        {
            if (string.IsNullOrEmpty(input) || string.IsNullOrEmpty(color))
                return input;
            return "<color=" + color + ">" + input + "</color>";
        }

        // show usage information
        private void ShowUsage(IPlayer user) => user.Message(RemoveFormatting(usageString));

        public string RemoveFormatting(string source) => source.Contains('>') ? Regex.Replace(source, "<.*?>", string.Empty) : source;

        // warn that the server is set to PVE mode
        private void WarnPve() => Puts(GetMessage("Warning_PveMode"));
        #endregion

        #region Helper Procedures

        // get location keys from ZoneManager (zone IDs) or LiteZones (zone names)
        private PooledList<string> GetLocationKeys(BaseEntity entity)
        {
            if (!useZones || entity == null) return null;
            var locations = Pool.Get<PooledList<string>>();
            if (ZoneManager != null && ZoneManager.IsLoaded)
            {
                using var locs = Pool.Get<PooledList<string>>();
                if (entity is BasePlayer player)
                {
                    // BasePlayer fix from chadomat
                    string[] array = (string[])ZoneManager.Call("GetPlayerZoneIDs", new object[] { player });
                    if (array != null && array.Length > 0)
                    {
                        foreach (string loc in array)
                        {
                            if (!string.IsNullOrEmpty(loc) && !locs.Contains(loc))
                            {
                                locs.Add(loc);
                            }
                        }
                    }
                }
                else if (entity.IsValid())
                {
                    string[] array = (string[])ZoneManager.Call("GetEntityZoneIDs", new object[] { entity });
                    if (array != null && array.Length > 0)
                    {
                        foreach (string loc in array)
                        {
                            if (!string.IsNullOrEmpty(loc) && !locs.Contains(loc))
                            {
                                locs.Add(loc);
                            }
                        }
                    }
                }
                if (locs.Count > 0)
                {
                    // Add names into list of ID numbers
                    foreach (string loc in locs)
                    {
                        if (!locations.Contains(loc)) locations.Add(loc);
                        string zname = (string)ZoneManager.Call("GetZoneName", loc);
                        if (!string.IsNullOrEmpty(zname) && !locations.Contains(zname)) locations.Add(zname);
                    }
                }
            }
            if (LiteZones != null && LiteZones.IsLoaded)
            {
                List<string> locs = (List<string>)LiteZones?.Call("GetEntityZones", new object[] { entity });
                if (locs != null && locs.Count > 0)
                {
                    foreach (string loc in locs)
                    {
                        if (!locations.Contains(loc))
                        {
                            locations.Add(loc);
                        }
                    }
                }
            }
            return locations;
        }

        // handle raycast from player (for prodding)
        private bool GetRaycastTarget(BasePlayer player, out BaseEntity closestEntity)
        {
            if (Physics.Raycast(player.eyes.HeadRay(), out var hit, 10f) && hit.GetEntity() is BaseEntity hitEntity)
            {
                closestEntity = hitEntity;
                return closestEntity != null;
            }
            closestEntity = null;
            return false;
        }

        // loop to update current ruleset
        private void TimerLoop(bool firstRun = false)
        {
            config.schedule.ClockUpdate(out var ruleSetName, out currentBroadcastMessage);
            if (firstRun || currentRuleSet.name != ruleSetName)
            {
                currentRuleSet = config.ruleSets.Find(r => r.name == ruleSetName);

                if (currentRuleSet == null)
                {
                    currentRuleSet = new(ruleSetName);  // create empty ruleset to hold name
                }

				ValidateCurrentDamageHook();
                if (config.schedule.broadcast && !string.IsNullOrEmpty(currentBroadcastMessage))
                {
                    Server.Broadcast(currentBroadcastMessage, GetMessage("Prefix"));
                    Puts(RemoveFormatting(GetMessage("Prefix") + " Schedule Broadcast: " + currentBroadcastMessage));
                }
            }

            if (config.schedule.enabled)
                scheduleUpdateTimer = timer.Once(config.schedule.useRealtime ? 30f : 3f, () => TimerLoop());
        }

        private void ValidateCurrentDamageHook()
        {
            if (!config.options.handleDamage)
            {
                Unsubscribe(nameof(OnEntityTakeDamage));
                tpveEnabled = false;
                return;
            }
            RuleSet ruleSet = currentRuleSet;
            tpveEnabled = ruleSet != null && ruleSet.enabled && !ruleSet.IsEmpty();
            if (tpveEnabled)
            {
                Subscribe(nameof(OnEntityTakeDamage));
            }
            else
            {
                Unsubscribe(nameof(OnEntityTakeDamage));
            }
        }

		#endregion

        #region Subclasses
        // configuration and data storage container

        private class TwigDamageOptions
        {
            [JsonProperty(PropertyName = "Apply To Twig (when TwigDamage flag is not set")]
            public bool Twig { get; set; }

            [JsonProperty(PropertyName = "Apply To Wood")]
            public bool Wood { get; set; }

            [JsonProperty(PropertyName = "Apply To Stone")]
            public bool Stone { get; set; }

            [JsonProperty(PropertyName = "Apply To Metal")]
            public bool Metal { get; set; }

            [JsonProperty(PropertyName = "Apply To HQM")]
            public bool HQM { get; set; }

            [JsonProperty(PropertyName = "Require Owner Online")]
            public bool Online { get; set; } = true;

            [JsonProperty(PropertyName = "Log Offenses")]
            public bool Log { get; set; }

            [JsonProperty(PropertyName = "Notify Offenders")]
            public bool Notify { get; set; }

            [JsonProperty(PropertyName = "Reflect Damage Multiplier")]
            public float ReflectDamageMultiplier { get; set; }

            [JsonProperty(PropertyName = "Multiplier Allows Armor Protection")]
            public bool ReflectDamageProtection { get; set; } = true;

            internal bool Any => Log || Notify || ReflectDamageMultiplier > 0f || Wood || Stone || Metal || HQM;
        }

        private class ConfigurationOptions
        {
            [JsonProperty(PropertyName = "TwigDamage (FLAG)")]
            public TwigDamageOptions BlockHandler { get; set; } = new();

            [JsonProperty(PropertyName = "handleDamage")] // (true) enable TruePVE damage handling hooks
            public bool handleDamage { get; set; } = true;

            [JsonProperty(PropertyName = "useZones")] // (true) use ZoneManager/LiteZones for zone-specific damage behavior (requires modification of ZoneManager.cs)
            public bool useZones { get; set; } = true;

            [JsonProperty(PropertyName = "Trace To Player Console")]
            public bool PlayerConsole { get; set; }

            [JsonProperty(PropertyName = "Trace To Server Console")]
            public bool ServerConsole { get; set; } = true;

            [JsonProperty(PropertyName = "Log Trace To File")]
            public bool LogToFile { get; set; } = true;

            [JsonProperty(PropertyName = "Maximum Distance From Player To Trace")]
            public float MaxTraceDistance { get; set; } = 50f;

            [JsonProperty(PropertyName = "Prevent Water From Extinguishing BaseOven")]
            public bool disableBaseOvenSplash { get; set; }

            [JsonProperty(PropertyName = "Prevent Players From Being Marked Hostile")]
            public bool disableHostility { get; set; }

            [JsonProperty(PropertyName = "Allow PVP Below Height")]
            public float Underworld { get; set; } = -500f;

            [JsonProperty(PropertyName = "Allow PVP Above Height")]
            public float Aboveworld { get; set; } = 5000f;

            [JsonProperty(PropertyName = "Allow Other Damage Below Height")]
            public float UnderworldOther { get; set; } = -500f;

            [JsonProperty(PropertyName = "Allow Other Damage Above Height")]
            public float AboveworldOther { get; set; } = 5000f;

            [JsonProperty(PropertyName = "Allow Cold Metabolism Damage")]
            public bool Cold { get; set; }

            [JsonProperty(PropertyName = "Allow Heat Metabolism Damage")]
            public bool Heat { get; set; }
        }

        private class Configuration
        {
            [JsonProperty(PropertyName = "Config Version")]
            public string configVersion = null;

            [JsonProperty(PropertyName = "Default RuleSet")]
            public string defaultRuleSet = "default";

            [JsonProperty(PropertyName = "Configuration Options")]
            public ConfigurationOptions options = new();

            [JsonProperty(PropertyName = "Mappings")]
            public Dictionary<string, string> mappings = new();

            [JsonProperty(PropertyName = "Schedule")]
            public Schedule schedule = new();

            [JsonProperty(PropertyName = "RuleSets")]
            public List<RuleSet> ruleSets = new();

            [JsonProperty(PropertyName = "Entity Groups")]
            public List<EntityGroup> groups = new();

            [JsonProperty(PropertyName = "Allow Killing Sleepers")]
            public bool AllowKillingSleepers;

            [JsonProperty(PropertyName = "Allow Killing Sleepers (Ally Only)")]
            public bool AllowKillingSleepersAlly;

            [JsonProperty(PropertyName = "Allow Killing Sleepers (Authorization Only)")]
            public bool AllowKillingSleepersAuthorization;

            [JsonProperty(PropertyName = "Allow Killing Sleepers (After X Hours Offline)")]
            public float AllowKillingSleepersHoursOffline;

            [JsonProperty(PropertyName = "Allow Killing Sleepers (Allowed steam ids)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> AllowKillingSleepersIds = new() { 0 };

            [JsonProperty(PropertyName = "Ignore Firework Damage")]
            public bool Firework = true;

            [JsonProperty(PropertyName = "Ignore Campfire Damage")]
            public bool Campfires;

            [JsonProperty(PropertyName = "Ignore Ladder Damage")]
            public bool Ladders;

            [JsonProperty(PropertyName = "Ignore Sleeping Bag Damage")]
            public bool SleepingBags;

            [JsonProperty(PropertyName = "Players Can Trigger Traps In Monument Topology")]
            public bool PlayersTriggerTraps = true;

            [JsonProperty(PropertyName = "Players Can Hurt Traps In Monument Topology")]
            public bool PlayersHurtTraps;

            [JsonProperty(PropertyName = "Players Can Trigger Turrets In Monument Topology")]
            public bool PlayersTriggerTurrets = true;

            [JsonProperty(PropertyName = "Players Can Hurt Turrets In Monument Topology")]
            public bool PlayersHurtTurrets;

            [JsonProperty(PropertyName = "Block Scrap Heli Damage")]
            public bool scrap = true;

            [JsonProperty(PropertyName = "Block Igniter Damage")]
            public bool igniter;

            [JsonProperty(PropertyName = "Block Wallpaper Damage")]
            public bool wallpaper = true;

            [JsonProperty(PropertyName = "Block Radioactive Water Damage")]
            public bool BlockRadioactiveWaterDamage = true;

            [JsonProperty(PropertyName = "Block Decay Damage To Vehicles")]
            public bool BlockDecayDamageToVehicles;

            [JsonProperty(PropertyName = "Prevent ragdolling when struck by another vehicle")]
            public bool PreventRagdolling = true;

            [JsonProperty(PropertyName = "Experimental ZoneManager support for PVE zones")]
            public bool PVEZones;

            internal Dictionary<ulong, List<string>> groupCache = new();

            public void Init(TruePVE instance)
            {
                schedule.Init(instance);
                foreach (RuleSet rs in ruleSets)
                    rs.Build(instance);
                ruleSets.Remove(null);
            }

            public List<string> ResolveEntityGroups(BaseEntity entity)
            {
                ulong id = entity == null || entity.net == null ? 0 : entity.net.ID.Value;

                if (id > 0 && groupCache.TryGetValue(id, out var cachedGroups))
                {
                    return cachedGroups;
                }

                List<string> currentGroups = new(groups.Count);

                foreach (EntityGroup group in groups)
                {
                    if (group.Contains(entity))
                    {
                        currentGroups.Add(group.name);
                    }
                }

                if (id > 0)
                {
                    groupCache[id] = currentGroups;
                }

                return currentGroups;
            }

            public bool HasMapping(string key)
            {
                return mappings.ContainsKey(key) || mappings.ContainsKey(AllZones);
            }

            public RuleSet GetDefaultRuleSet()
            {
                RuleSet foundRuleSet = null;
                int matchCount = 0;

                foreach (var r in ruleSets)
                {
                    if (r.name == defaultRuleSet)
                    {
                        foundRuleSet = r;
                        matchCount++;
                    }
                }

                if (matchCount > 1)
                {
                    Puts($"Warning - duplicate ruleset found for default RuleSet: '{defaultRuleSet}'");
                }

                return foundRuleSet;
            }

            public RuleSet GetDudRuleSet()
            {
                return new("override")
                {
                    _flags = RuleFlags.HumanNPCDamage,
                    defaultAllowDamage = false,
                    enabled = true
                };
            }
        }

        private class RuleSet
        {
            public string name;
            public bool enabled = true;
            public bool defaultAllowDamage = false;
            public string flags = string.Empty;
            internal RuleFlags _flags = RuleFlags.None;
            internal bool Changed;

            public HashSet<string> rules = new();
            internal HashSet<Rule> parsedRules = new();
            internal Dictionary<string, Rule> ruleDictionary = new();

            public RuleSet() { }
            public RuleSet(string name) { this.name = name; }

            // evaluate the passed lists of entity groups against rules
            public bool Evaluate(TruePVE instance, List<string> eg1, List<string> eg2, bool returnDefaultValue = true)
            {
                bool trace = instance.trace;

                if (trace) instance.Trace("Evaluating Rules...", 3);

                if (ruleDictionary == null || ruleDictionary.Count == 0)
                {
                    if (trace) instance.Trace($"No rules found; returning default value: {defaultAllowDamage}", 4);
                    return defaultAllowDamage;
                }

                bool vg1 = eg1 != null && eg1.Count > 0;
                bool vg2 = eg2 != null && eg2.Count > 0;

                // 1. Check all direct links between eg1 and eg2
                if (vg1 && vg2)
                {
                    if (trace) instance.Trace("Checking direct initiator->target rules...", 4);

                    foreach (string s1 in eg1)
                    {
                        foreach (string s2 in eg2)
                        {
                            string ruleText = s1 + "->" + s2; // Using concatenation for performance

                            if (trace) instance.Trace($"Evaluating \"{ruleText}\"...", 5);

                            if (ruleDictionary.TryGetValue(ruleText, out Rule rule))
                            {
                                if (trace) instance.Trace($"Match found; allow damage? {rule.hurt}", 6);
                                return rule.hurt;
                            }

                            if (trace) instance.Trace("No match found", 6);
                        }
                    }
                }

                // 2. If no direct match, check group -> Any
                if (vg1)
                {
                    if (trace) instance.Trace("No direct match rules found; continuing with group->Any...", 4);

                    foreach (string s1 in eg1)
                    {
                        string ruleText = s1 + "->" + Any;

                        if (trace) instance.Trace($"Evaluating \"{ruleText}\"...", 5);

                        if (ruleDictionary.TryGetValue(ruleText, out Rule rule))
                        {
                            if (trace) instance.Trace($"Match found; allow damage? {rule.hurt}", 6);
                            return rule.hurt;
                        }

                        if (trace) instance.Trace("No match found", 6);
                    }
                }

                // 3. If still no match, check Any -> group
                if (vg2)
                {
                    if (trace) instance.Trace("No matching group->Any rules found; continuing with Any->group...", 4);

                    foreach (string s2 in eg2)
                    {
                        string ruleText = Any + "->" + s2;

                        if (trace) instance.Trace($"Evaluating \"{ruleText}\"...", 5);

                        if (ruleDictionary.TryGetValue(ruleText, out Rule rule))
                        {
                            if (trace) instance.Trace($"Match found; allow damage? {rule.hurt}", 6);
                            return rule.hurt;
                        }

                        if (trace) instance.Trace("No match found", 6);
                    }
                }

                // 4. If no rule was found, return the default value if specified
                if (returnDefaultValue)
                {
                    if (trace) instance.Trace($"No matching rules found; returning default value: {defaultAllowDamage}", 4);

                    return defaultAllowDamage;
                }

                // 5. If not returning default, default to Allow
                return true;
            }

            // build rule strings to rules
            public void Build(TruePVE instance)
            {
                foreach (string ruleText in rules)
                    parsedRules.Add(new(instance, ruleText));
                parsedRules.Remove(null);
                ValidateRules();
                InitializeRuleDictionary();
                if (flags.Length == 0)
                {
                    _flags |= RuleFlags.None;
                    return;
                }
                foreach (string _value in flags.Split(','))
                {
                    string value = _value.Trim();
                    if (!Enum.TryParse(value, out RuleFlags flag))
                    {
                        if (value == "SamSitesIgnorePlayers")
                        {
                            ConvertSamSiteFlag();
                        }
                        else if (value == "TrapsIgnoreScientists")
                        {
                            ConvertTrapsIgnoreScientists();
                        }
                        else if (value == "TurretsIgnoreScientists")
                        {
                            ConvertTurretsIgnoreScientists("TurretsIgnoreScientists", "TurretsIgnoreScientist", RuleFlags.TurretsIgnoreScientist);
                        }
                        else if (value == "StaticTurretsIgnoreScientists")
                        {
                            ConvertTurretsIgnoreScientists("StaticTurretsIgnoreScientists", "StaticTurretsIgnoreScientist", RuleFlags.StaticTurretsIgnoreScientist);
                        }
                        else
                        {
                            Puts("WARNING - invalid flag: '{0}' (does this flag still exist?)", value);
                        }
                    }
                    else if (!HasFlag(flag))
                    {
                        _flags |= flag;
                    }
                }
                if (Changed)
                {
                    instance.SaveConfig();
                    Changed = false;
                }
            }

            public void InitializeRuleDictionary()
            {
                if (parsedRules != null)
                {
                    ruleDictionary = new(StringComparer.OrdinalIgnoreCase);

                    foreach (Rule rule in parsedRules)
                    {
                        if (rule != null && rule.valid && rule.key != null)
                        {
                            ruleDictionary[rule.key] = rule;
                        }
                    }
                }
                else
                {
                    ruleDictionary = null;
                }
            }

            private void ConvertSamSiteFlag()
            {
                flags = flags.Replace("SamSitesIgnorePlayers", "PlayerSamSitesIgnorePlayers, StaticSamSitesIgnorePlayers");
                if (!HasFlag(RuleFlags.PlayerSamSitesIgnorePlayers))
                {
                    _flags |= RuleFlags.PlayerSamSitesIgnorePlayers;
                }
                if (!HasFlag(RuleFlags.StaticSamSitesIgnorePlayers))
                {
                    _flags |= RuleFlags.StaticSamSitesIgnorePlayers;
                }
                Changed = true;
            }

            private void ConvertTrapsIgnoreScientists()
            {
                flags = flags.Replace("TrapsIgnoreScientists", "TrapsIgnoreScientist");
                if (!HasFlag(RuleFlags.TrapsIgnoreScientist))
                {
                    _flags |= RuleFlags.TrapsIgnoreScientist;
                }
                Changed = true;
            }

            private void ConvertTurretsIgnoreScientists(string from, string to, RuleFlags flag)
            {
                flags = flags.Replace(from, to);
                if (!HasFlag(flag))
                {
                    _flags |= flag;
                }
                Changed = true;
            }

            public void ValidateRules()
            {
                foreach (Rule rule in parsedRules)
                    if (!rule.valid)
                        Interface.Oxide.LogWarning($"Warning - invalid rule: {rule.ruleText}");
            }

            // add a rule
            public void AddRule(TruePVE instance, string ruleText)
            {
                rules.Add(ruleText);
                parsedRules.Add(new(instance, ruleText));
            }

            public bool HasAnyFlag(RuleFlags flags) => (_flags | flags) != RuleFlags.None;
            public bool HasFlag(RuleFlags flag) => (_flags & flag) == flag;
            public bool IsEmpty() => rules.IsNullOrEmpty() && _flags == RuleFlags.None;
        }

        private class Rule
        {
            public string ruleText;
            internal string key;
            internal bool hurt;
            internal bool valid;

            public Rule() { }
            public Rule(TruePVE instance, string ruleText)
            {
                this.ruleText = ruleText;
                valid = Translate(instance);
            }

            public bool Translate(TruePVE instance)
            {
                if (string.IsNullOrWhiteSpace(ruleText))
                    return false;

                string[] splitStr = instance.regex.Split(ruleText.Trim());
                if (splitStr.Length < 3)
                    return false;

                string rs0 = splitStr[0];
                string rs1 = splitStr[^1]; // Using index from end operator
                string[] mid = splitStr[1..^1]; // Slicing the array

                bool canHurt = !Array.Exists(mid, s => s.Equals("cannot", StringComparison.OrdinalIgnoreCase) || s.Equals("can't", StringComparison.OrdinalIgnoreCase));

                // rs0 and rs1 shouldn't ever be "nothing" simultaneously
                if (rs0.Equals("nothing", StringComparison.OrdinalIgnoreCase) || rs1.Equals("nothing", StringComparison.OrdinalIgnoreCase) || rs0.Equals("none", StringComparison.OrdinalIgnoreCase) || rs1.Equals("none", StringComparison.OrdinalIgnoreCase))
                {
                    canHurt = !canHurt;
                }

                if (instance.synonyms.Contains(rs0)) rs0 = Any;
                if (instance.synonyms.Contains(rs1)) rs1 = Any;

                key = rs0 + "->" + rs1;
                hurt = canHurt;
                return true;
            }

            public override int GetHashCode() => key.GetHashCode();

            public override bool Equals(object obj)
            {
                if (obj == null) return false;
                if (obj == this) return true;
                if (obj is Rule obj2)
                    return key.Equals(obj2.key);
                return false;
            }
        }

        private readonly Regex regex = new(@"\s+", RegexOptions.Compiled);

        private readonly HashSet<string> synonyms = new(StringComparer.OrdinalIgnoreCase)
        {
            "anything", "nothing", "all", "any", "none", "everything"
        };

        // container for mapping entities
        private class EntityGroup
        {
            public string name { get; set; }

            internal readonly HashSet<string> _memberSet;
            internal readonly HashSet<string> _exclusionSet;

            private string _cachedMembersString = string.Empty;
            private string _cachedExclusionsString = string.Empty;

            private bool _isMembersDirty = true;
            private bool _isExclusionsDirty = true;

            public EntityGroup()
            {
                _memberSet = new(StringComparer.OrdinalIgnoreCase);
                _exclusionSet = new(StringComparer.OrdinalIgnoreCase);
            }

            public EntityGroup(string name) : this()
            {
                this.name = name;
            }

            public string members
            {
                get
                {
                    if (_isMembersDirty)
                    {
                        _cachedMembersString = string.Join(", ", _memberSet);
                        _isMembersDirty = false;
                    }
                    return _cachedMembersString;
                }
                set
                {
                    _memberSet.Clear();
                    if (!string.IsNullOrEmpty(value))
                    {
                        var members = value.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                        foreach (var member in members)
                        {
                            var trimmed = member.Trim();
                            if (!string.IsNullOrEmpty(trimmed))
                            {
                                _memberSet.Add(trimmed);
                            }
                        }
                    }

                    _isMembersDirty = true;
                }
            }

            public string exclusions
            {
                get
                {
                    if (_isExclusionsDirty)
                    {
                        _cachedExclusionsString = string.Join(", ", _exclusionSet);
                        _isExclusionsDirty = false;
                    }
                    return _cachedExclusionsString;
                }
                set
                {
                    _exclusionSet.Clear();
                    if (!string.IsNullOrEmpty(value))
                    {
                        var exclusions = value.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                        foreach (var exclusion in exclusions)
                        {
                            var trimmed = exclusion.Trim();
                            if (!string.IsNullOrEmpty(trimmed))
                            {
                                _exclusionSet.Add(trimmed);
                            }
                        }
                    }

                    _isExclusionsDirty = true;
                }
            }

            public bool IsMember(string value)
            {
                if (string.IsNullOrEmpty(value)) return false;
                return _memberSet.Contains(value);
            }

            public bool IsExclusion(string value)
            {
                if (string.IsNullOrEmpty(value)) return false;
                return _exclusionSet.Contains(value);
            }

            public bool Contains(BaseEntity entity)
            {
                string typeName = entity.GetType().Name;
                string prefabName = entity.ShortPrefabName;

                bool isMember = _memberSet.Contains(typeName) || _memberSet.Contains(prefabName);

                if (!isMember)
                {
                    return false;
                }

                bool isExcluded = _exclusionSet.Contains(typeName) || _exclusionSet.Contains(prefabName);

                return !isExcluded;
            }
        }

        // scheduler
        private class Schedule
        {
            public bool enabled;
            public bool useRealtime;
            public bool broadcast;
            public List<string> entries = new();
            internal List<ScheduleEntry> parsedEntries = new();
            internal bool valid;

            public void Init(TruePVE instance)
            {
                // Add entries to parsedEntries
                foreach (string str in entries)
                {
                    parsedEntries.Add(new(instance, str));
                }

                // Check if parsedEntries is null or empty
                if (parsedEntries == null || parsedEntries.Count == 0)
                {
                    enabled = false;
                    return;
                }

                // Count valid entries
                int validEntriesCount = 0;
                foreach (var entry in parsedEntries)
                {
                    if (entry.valid)
                    {
                        validEntriesCount++;
                    }
                }

                // If there are less than 2 valid entries, disable the schedule
                if (validEntriesCount < 2)
                {
                    enabled = false;
                    return;
                }

                // Collect all distinct ruleSets
                using var distinctRuleSets = Pool.Get<PooledHashSet<string>>();
                foreach (var entry in parsedEntries)
                {
                    distinctRuleSets.Add(entry.ruleSet);
                }

                // If there are less than 2 distinct ruleSets, disable the schedule
                if (distinctRuleSets.Count < 2)
                {
                    enabled = false;
                }
                else
                {
                    valid = true;
                }
            }

            // returns delta between current time and next schedule entry
            public void ClockUpdate(out string ruleSetName, out string message)
            {
                // Determine the current TimeSpan based on useRealtime
                TimeSpan currentTime = default;
                if (useRealtime || TOD_Sky.Instance?.Cycle == null)
                {
                    // Create a TimeSpan representing the total number of days since Sunday
                    currentTime = new TimeSpan((int)DateTime.Now.DayOfWeek, 0, 0, 0).Add(DateTime.Now.TimeOfDay);
                }
                else
                {
                    currentTime = TOD_Sky.Instance.Cycle.DateTime.TimeOfDay;
                }

                ScheduleEntry se = null;

                // Step 1: Check for non-daily entries
                bool hasNonDaily = false;
                foreach (var entry in parsedEntries)
                {
                    if (!entry.isDaily)
                    {
                        hasNonDaily = true;
                        break; // Early exit once a non-daily entry is found
                    }
                }

                // Step 2: Find the most recent valid non-daily entry
                if (hasNonDaily)
                {
                    TimeSpan? maxTime = null;
                    foreach (var entry in parsedEntries)
                    {
                        if (entry.valid && entry.time <= currentTime)
                        {
                            if (useRealtime && entry.isDaily)
                            {
                                continue; // Skip daily entries if useRealtime is true
                            }

                            if (!maxTime.HasValue || entry.time > maxTime.Value)
                            {
                                maxTime = entry.time;
                            }
                        }
                    }

                    if (maxTime.HasValue)
                    {
                        foreach (var entry in parsedEntries)
                        {
                            if (entry.time == maxTime.Value)
                            {
                                se = entry;
                                break; // Exit once the first matching entry is found
                            }
                        }
                    }
                }

                // Step 3: Handle daily entries if useRealtime is true
                if (useRealtime)
                {
                    ScheduleEntry daily = null;
                    TimeSpan maxDailyTime = TimeSpan.Zero;
                    bool hasValidDaily = false;

                    // Find the maximum time among valid daily entries <= current real-time
                    foreach (var entry in parsedEntries)
                    {
                        if (entry.valid && entry.isDaily && entry.time <= DateTime.Now.TimeOfDay)
                        {
                            if (!hasValidDaily || entry.time > maxDailyTime)
                            {
                                maxDailyTime = entry.time;
                                hasValidDaily = true;
                            }
                        }
                    }

                    if (hasValidDaily)
                    {
                        foreach (var entry in parsedEntries)
                        {
                            if (entry.isDaily && entry.valid && entry.time == maxDailyTime)
                            {
                                daily = entry;
                                break;
                            }
                        }
                    }

                    if (daily != null)
                    {
                        if (se == null)
                        {
                            se = daily;
                        }
                        else
                        {
                            // Create a TimeSpan representing the day's offset
                            TimeSpan dayOffset = new((int)DateTime.Now.DayOfWeek, 0, 0, 0);
                            TimeSpan dailyAdjustedTime = daily.time.Add(dayOffset);

                            if (dailyAdjustedTime > se.time)
                            {
                                se = daily;
                            }
                        }
                    }
                }

                // Assign the output parameters
                ruleSetName = se?.ruleSet;
                message = se?.message;
            }
        }

        private class ScheduleEntry
        {
            public string ruleSet;
            public string message;
            public string scheduleText;
            public bool valid;
            public TimeSpan time { get; set; }
            internal bool isDaily = false;

            public ScheduleEntry() { }

            public ScheduleEntry(TruePVE instance, string scheduleText)
            {
                this.scheduleText = scheduleText;
                valid = Translate(instance);
            }

            private bool Translate(TruePVE instance)
            {
                if (string.IsNullOrWhiteSpace(scheduleText))
                    return false;

                // Split the scheduleText into at most 3 parts: TimeSpan, RuleSet, Message
                string[] split = instance.regex.Split(scheduleText.Trim(), 3);
                if (split.Length < 2)
                {
                    return false; // At least TimeSpan and RuleSet are required
                }

                string ts = split[0];
                string rs = split[1];
                string msg = split.Length > 2 ? split[2] : string.Empty;

                // Check if the TimeSpan starts with "*." indicating a daily schedule
                if (ts.Length > 2 && ts.StartsWith("*.", StringComparison.Ordinal))
                {
                    isDaily = true;
                    ts = ts[2..]; // Remove the "*." prefix
                }

                if (!TimeSpan.TryParse(ts, out TimeSpan span))
                {
                    string c = ts[^1].ToString();
                    if (!c.IsNumeric())
                    {
                        Puts("Invalid last character '{0}' in time format '{1}'", c, ts);
                    }
                    else
                    {
                        Puts("Time format is invalid: {0}", ts);
                    }
                    return false;
                }

                time = span;
                ruleSet = rs;
                message = msg;

                return true;
            }

            public override int GetHashCode() => ruleSet != null ? StringComparer.OrdinalIgnoreCase.GetHashCode(ruleSet) : 0;

            public override bool Equals(object obj)
            {
                if (obj is ScheduleEntry other)
                    return string.Equals(ruleSet, other.ruleSet, StringComparison.OrdinalIgnoreCase);
                return false;
            }
        }

#endregion

        #region Lang
        // load default messages to Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new()
            {
                {"Prefix", "<color=#FFA500>[ TruePVE ]</color>" },
                {"Enable", "TruePVE enable set to {0}" },
                {"Twig", "<color=#ff0000>WARNING:</color> It is against server rules to destroy other players' items. Actions logged for admin review." },

                {"Header_Usage", "---- TruePVE usage ----"},
                {"Cmd_Usage_def", "Loads default configuration and data"},
                {"Cmd_Usage_sched", "Enable or disable the schedule" },
                {"Cmd_Usage_prod", "Show the prefab name and type of the entity being looked at"},
                {"Cmd_Usage_map", "Create/remove a mapping entry" },
                {"Cmd_Usage_trace", "Toggle tracing on/off" },

                {"Warning_PveMode", "ConVar server.pve is TRUE!  TruePVE is designed for PVP mode, and may cause unexpected behavior in PVE mode."},
                {"Warning_NoRuleSet", "No RuleSet found for \"{0}\"" },
                {"Warning_DuplicateRuleSet", "Multiple RuleSets found for \"{0}\"" },

                {"Error_InvalidCommand", "Invalid command" },
                {"Error_InvalidParameter", "Invalid parameter: {0}"},
                {"Error_InvalidParamForCmd", "Invalid parameters for command \"{0}\""},
                {"Error_InvalidMapping", "Invalid mapping: {0} => {1}; Target must be a valid RuleSet or \"exclude\"" },
                {"Error_NoMappingToDelete", "Cannot delete mapping: \"{0}\" does not exist" },
                {"Error_NoPermission", "Cannot execute command: No permission"},
                {"Error_NoSuicide", "You are not allowed to commit suicide"},
                {"Error_NoEntityFound", "No entity found"},

                {"Notify_AvailOptions", "Available Options: {0}"},
                {"Notify_DefConfigLoad", "Loaded default configuration"},
                {"Notify_DefDataLoad", "Loaded default mapping data"},
                {"Notify_ProdResult", "Prod results: type={0}, prefab={1}"},
                {"Notify_SchedSetEnabled", "Schedule enabled" },
                {"Notify_SchedSetDisabled", "Schedule disabled" },
                {"Notify_InvalidSchedule", "Schedule is not valid" },
                {"Notify_MappingCreated", "Mapping created for \"{0}\" => \"{1}\"" },
                {"Notify_MappingUpdated", "Mapping for \"{0}\" changed from \"{1}\" to \"{2}\"" },
                {"Notify_MappingDeleted", "Mapping for \"{0}\" => \"{1}\" deleted" },
                {"Notify_TraceToggle", "Trace mode toggled {0}" },

                {"Format_EnableColor", "#00FFFF"}, // cyan
                {"Format_EnableSize", "12"},
                {"Format_NotifyColor", "#00FFFF"}, // cyan
                {"Format_NotifySize", "12"},
                {"Format_HeaderColor", "#FFA500"}, // orange
                {"Format_HeaderSize", "14"},
                {"Format_ErrorColor", "#FF0000"}, // red
                {"Format_ErrorSize", "12"},

                {"Error_TimeLeft", "You must wait another {0} hours to attack this player."},
            }, this);
        }

        // get message from Lang
        private string GetMessage(string key, string userId = null) => lang.GetMessage(key, this, userId);
        #endregion
    }
}

// --- End of file: TruePVE.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/toggle-convar ---
// --- Original File Path: T/ToggleConVar/ToggleConVar.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Toggle ConVar", "birthdates", "1.0.3")]
    [Description("Toggle ConVars between two values")]
    public class ToggleConVar : RustPlugin
    {
        #region Core Logic

        private const string UsePermission = "toggleconvar.use";

        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
        }

        /// <summary>
        ///     This variable handles the active timers and handles any overwrites by resetting the <see cref="Timer" />
        /// </summary>
        private readonly IDictionary<ulong, Timer> _timers =
            new Dictionary<ulong, Timer>();

        /// <summary>
        ///     Reply to a console command
        /// </summary>
        /// <param name="arg">Target command</param>
        /// <param name="msg">Message to reply with</param>
        /// <param name="error">Is this an error?</param>
        private void Reply(ConsoleSystem.Arg arg, string msg, bool error = true)
        {
            arg.ReplyWith(msg);
            if (!_config.ReplyWithGameTips) return;
            var player = arg.Player();
            if (player == null) return;
            ShowGameTip(player, msg, error);
            HideGameTipLater(player, _config.GameTipTime);
        }

        /// <summary>
        ///     The main command to toggle a <see cref="ConVar" />
        /// </summary>
        /// <param name="arg">Given arguments</param>
        [ConsoleCommand("server.toggle")]
        private void ToggleCommand(ConsoleSystem.Arg arg)
        {
            if (arg == null) return;
            var player = arg.Player();
            if (player && !player.IPlayer.HasPermission(UsePermission)) return;
            if (arg.Args == null || arg.Args.Length < 3)
            {
                Reply(arg, "Invalid args");
                return;
            }

            var conVar = arg.Args[0];
            var firstValue = arg.Args[1];
            var currentValue = RunSilentCommand(conVar);
            if (currentValue == null)
            {
                Reply(arg, "Invalid ConVar!");
                return;
            }

            var currentValueStr = currentValue.cmd.String;
            var change = !currentValueStr.Equals(firstValue) ? firstValue : arg.Args[2];
            RunSilentCommand(conVar, change);
            Reply(arg, $"{currentValue.cmd.FullName} has been changed to {change}", false);
        }

        #endregion

        #region Helpers

        /// <summary>
        ///     Run a console command without any output into the console
        /// </summary>
        /// <param name="strCommand">Target command</param>
        /// <param name="args">Target args</param>
        /// <returns>A <see cref="ConsoleSystem.Arg" /> with the outcome of the command</returns>
        private static ConsoleSystem.Arg RunSilentCommand(string strCommand, params object[] args)
        {
            var command = ConsoleSystem.BuildCommand(strCommand, args);
            var arg = new ConsoleSystem.Arg(ConsoleSystem.Option.Unrestricted, command);
            if (arg.Invalid || !arg.cmd.Variable) return null;

            var oldArgs = ConsoleSystem.CurrentArgs;
            ConsoleSystem.CurrentArgs = arg;
            arg.cmd.Call(arg);
            ConsoleSystem.CurrentArgs = oldArgs;
            return arg;
        }

        /// <summary>
        ///     Show a game tip to <paramref name="player" /> with the message <seealso cref="msg" />
        /// </summary>
        /// <param name="player">Target player</param>
        /// <param name="msg">Target message</param>
        /// <param name="error">Should we color this red?</param>
        private static void ShowGameTip(BasePlayer player, string msg, bool error = true)
        {
            var style = error ? "1" : "0";
            player.SendConsoleCommand($"gametip.showtoast_translated {style} _ \"{msg}\"");
        }

        /// <summary>
        ///     Hide a game tip sent to a player in a later time
        /// </summary>
        /// <param name="player">Target player</param>
        /// <param name="time">Target time (seconds)</param>
        private void HideGameTipLater(BasePlayer player, float time)
        {
            Timer playerTimer;
            if (!_timers.TryGetValue(player.userID, out playerTimer))
            {
                var id = player.userID;
                _timers[id] = timer.In(time, () =>
                {
                    HideGameTip(player);
                    _timers.Remove(id);
                });

                return;
            }

            playerTimer.Reset(time);
        }

        /// <summary>
        ///     Hide a game tip
        /// </summary>
        /// <param name="player">Target player</param>
        private static void HideGameTip(BasePlayer player)
        {
            if (player == null || !player.IsConnected) return;
            player.SendConsoleCommand("gametip.hidegametip");
        }

        #endregion

        #region Configuration

        private ConfigFile _config;

        public class ConfigFile
        {
            [JsonProperty("Reply with Game Tips")] public bool ReplyWithGameTips { get; set; }

            [JsonProperty("Game Tip Time")] public float GameTipTime { get; set; }

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    ReplyWithGameTips = true,
                    GameTipTime = 3f
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}

// --- End of file: ToggleConVar.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/team-battlefield ---
// --- Original File Path: T/TeamBattlefield/TeamBattlefield.cs ---

using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Reflection;
using System;

namespace Oxide.Plugins
{
    [Info("TeamBattlefield", "BodyweightEnergy / k1lly0u", "2.1.45"), Description("Two teams, adjustable friendly-fire, kits, individual team items, spectator mode")]
    class TeamBattlefield : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin Spawns;

        private List<TBPlayer> TBPlayers = new List<TBPlayer>();
        private Dictionary<ulong, PlayerData> DCPlayers = new Dictionary<ulong, PlayerData>();
        private Dictionary<ulong, Timer> DCTimers = new Dictionary<ulong, Timer>();
        private bool UseTB;

        private int TeamA_Score;
        private int TeamB_Score;
        #endregion

        #region UI
        #region UI Main
        private const string UIMain = "TBUI_Main";
        private const string UIScoreboard = "TBUI_Scoreboard";
        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool useCursor = false)
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent,
                        panelName
                    }
                };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0.2f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
        }
        #endregion

        #region Team Selection
        private void OpenTeamSelection(BasePlayer player)
        {
            var MainCont = UI.CreateElementContainer(UIMain, "0.1 0.1 0.1 0.95", "0 0", "1 1", true);
            UI.CreateLabel(ref MainCont, UIMain, "", $"{configData.TeamA.Chat_Color}Team A Players : {CountPlayers(Team.A)}</color>", 20, "0.2 0.55", "0.4 0.65");
            UI.CreateButton(ref MainCont, UIMain, "0.2 0.2 0.2 0.7", $"{configData.TeamA.Chat_Color}Team A</color>", 35, "0.2 0.45", "0.395 0.55", "TBUI_TeamSelect a");

            UI.CreateLabel(ref MainCont, UIMain, "", $"{configData.TeamB.Chat_Color}Team B Players : {CountPlayers(Team.B)}</color>", 20, "0.4 0.55", "0.6 0.65");
            UI.CreateButton(ref MainCont, UIMain, "0.2 0.2 0.2 0.7", $"{configData.TeamB.Chat_Color}Team B</color>", 35, "0.405 0.45", "0.595 0.55", "TBUI_TeamSelect b");

            if (configData.Spectators.EnableSpectators)
            {
                UI.CreateLabel(ref MainCont, UIMain, "", $"{configData.Spectators.Chat_Color}Spectators : {CountPlayers(Team.SPECTATOR)}</color>", 20, "0.6 0.55", "0.8 0.65");
                UI.CreateButton(ref MainCont, UIMain, "0.2 0.2 0.2 0.7", $"{configData.Spectators.Chat_Color}Spectate</color>", 35, "0.605 0.45", "0.795 0.55", "TBUI_TeamSelect spectator");
            }
            if (player.IsAdmin)
            {
                UI.CreateButton(ref MainCont, UIMain, "0.2 0.2 0.2 0.7", $"{configData.Admin.Chat_Color}Admin</color>", 35, "0.4 0.25", "0.6 0.35", "TBUI_TeamSelect admin");
            }
            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.AddUi(player, MainCont);
        }
        #endregion

        #region Scoreboard       
        public void Scoreboard(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIScoreboard);
            var MainCont = UI.CreateElementContainer(UIScoreboard, "0.1 0.1 0.1 0.5", "0.39 0.95", "0.61 1", false);
            UI.CreateLabel(ref MainCont, UIScoreboard, "", $"{configData.TeamA.Chat_Color}Team A: {TeamA_Score}</color>   ||   {configData.TeamB.Chat_Color}{TeamB_Score} : Team B</color>", 20, "0 0", "1 1");

            CuiHelper.AddUi(player, MainCont);
        }
        #endregion               
        #endregion
        
        #region Hooks       
        void OnServerInitialized()
        {
            LoadVariables();
            if (!CheckDependencies()) return;
            if (!CheckSpawnfiles()) return;
            UseTB = true;
            TeamA_Score = 0;
            TeamB_Score = 0;
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerInit(player);
        }
        private void OnEntityTakeDamage(BasePlayer victim, HitInfo hitInfo)
        {
            if (victim == null || hitInfo == null)
                return;

            if (UseTB)
            {
                if (hitInfo.InitiatorPlayer)
                {
                    var attacker = hitInfo.InitiatorPlayer;
                    if (victim != attacker)
                    {
                        if (victim.GetComponent<TBPlayer>() && attacker.GetComponent<TBPlayer>())
                        {
                            if (victim.GetComponent<TBPlayer>().team == attacker.GetComponent<TBPlayer>().team)
                            {
                                hitInfo.damageTypes.ScaleAll(configData.Options.FF_DamageScale);
                                SendReply(hitInfo.Initiator as BasePlayer, "Friendly Fire!");
                            }
                        }
                    }
                }
            }
        }

        private void OnEntityDeath(BasePlayer victim, HitInfo hitInfo)
        {
            if (victim == null || hitInfo == null)
                return;

            if (UseTB)
            {
                if (hitInfo.InitiatorPlayer != null)
                {
                    BasePlayer attacker = hitInfo.InitiatorPlayer;
                    if (victim != attacker)
                    {
                        if (victim.GetComponent<TBPlayer>() && attacker.GetComponent<TBPlayer>())
                        {
                            if (victim.GetComponent<TBPlayer>().team != attacker.GetComponent<TBPlayer>().team)
                            {
                                attacker.GetComponent<TBPlayer>().kills++;
                                AddPoints(attacker, victim);
                            }
                        }
                    }
                }
            }
        }       
        private void RefreshScoreboard()
        {
            foreach(var player in BasePlayer.activePlayerList)
            {
                Scoreboard(player);
            }
        }
        private void OnPlayerInit(BasePlayer player)
        {
            if (UseTB)
            {
                if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
                {
                    timer.Once(1, () =>
                    {
                        player.EndSleeping();
                        OnPlayerInit(player);
                    });
                }
                else InitPlayer(player);               
            }
        }  
        private void InitPlayer(BasePlayer player)
        {
            if (!player.GetComponent<TBPlayer>())
            {
                TBPlayers.Add(player.gameObject.AddComponent<TBPlayer>());
                Scoreboard(player);
                if (DCPlayers.ContainsKey(player.userID))
                {
                    player.GetComponent<TBPlayer>().kills = DCPlayers[player.userID].kills;
                    player.GetComponent<TBPlayer>().team = DCPlayers[player.userID].team;
                    DCPlayers.Remove(player.userID);
                    DCTimers[player.userID].Destroy();
                    DCTimers.Remove(player.userID);
                    player.DieInstantly();
                    player.Respawn();
                }
                else OpenTeamSelection(player);
            }            
        }   
        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (UseTB)
            {
                CuiHelper.DestroyUi(player, UIMain);
                CuiHelper.DestroyUi(player, UIScoreboard);

                TBPlayer tbPlayer = player.GetComponent<TBPlayer>();
                if (tbPlayer != null)
                {
                    DCPlayers.Add(player.userID, new PlayerData { kills = tbPlayer.kills, team = tbPlayer.team });
                    DCTimers.Add(player.userID, timer.Once(configData.Options.RemoveSleeper_Timer * 60, () => { DCPlayers.Remove(player.userID); DCTimers[player.userID].Destroy(); DCTimers.Remove(player.userID); }));
                                
                    if (TBPlayers.Contains(tbPlayer))
                        TBPlayers.Remove(tbPlayer);
                    UnityEngine.Object.Destroy(tbPlayer);
                }                
            }
        }      
        private void OnPlayerRespawned(BasePlayer player) 
        {
            if (UseTB)
            {
                if (player.GetComponent<TBPlayer>())
                {
                    Team team = player.GetComponent<TBPlayer>().team;
                    player.inventory.Strip();
                    if (team != Team.SPECTATOR)
                    {
                        GivePlayerWeapons(player);
                        GivePlayerGear(player, team);

                        object newpos = null;

                        if (team == Team.A) newpos = Spawns.Call("GetRandomSpawn", new object[] { configData.TeamA.Spawnfile });
                        else if (team == Team.B) newpos = Spawns.Call("GetRandomSpawn", new object[] { configData.TeamB.Spawnfile });
                        else if (team == Team.ADMIN && !string.IsNullOrEmpty(configData.Admin.Spawnfile)) newpos = Spawns.Call("GetRandomSpawn", new object[] { configData.Admin.Spawnfile });

                        if (newpos is Vector3)
                            MovePlayerPosition(player, (Vector3)newpos);
                    }
                }
                else OnPlayerInit(player);
            }           
        }
        private object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            if (UseTB)
            {
                if (configData.Options.UsePluginChatControl)
                {
                    BasePlayer player = (BasePlayer)arg.Connection.player;
                    string message = arg.GetString(0, "text");
                    string color = configData.Spectators.Chat_Color + configData.Spectators.Chat_Prefix;
                    if (player.GetComponent<TBPlayer>())
                    {
                        switch (player.GetComponent<TBPlayer>().team)
                        {
                            case Team.A:
                                color = configData.TeamA.Chat_Color + configData.TeamA.Chat_Prefix;
                                break;
                            case Team.B:
                                color = configData.TeamB.Chat_Color + configData.TeamB.Chat_Prefix;
                                break;
                            case Team.ADMIN:
                                color = configData.Admin.Chat_Color + configData.Admin.Chat_Prefix;
                                break;
                        }
                    }
                    string formatMsg = $"{color} {player.displayName}</color> : {message}";
                    PrintToChat(formatMsg);
                    return false;
                }
            }
            return null;
        }
        void Unload()
        {
            foreach (var p in BasePlayer.activePlayerList)
                OnPlayerDisconnected(p);

            var objects = UnityEngine.Object.FindObjectsOfType<TBPlayer>();
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);

            TBPlayers.Clear();
            DCPlayers.Clear();
            DCTimers.Clear();
        }
        #endregion

        #region Functions
        private bool CheckDependencies()
        {
            if (Spawns == null)
            {
                PrintWarning($"Spawns Database could not be found!");
                return false;
            }            
            return true;
        }
        private bool CheckSpawnfiles()
        {
            object successA = Spawns.Call("GetSpawnsCount", configData.TeamA.Spawnfile);
            object successB = Spawns.Call("GetSpawnsCount", configData.TeamB.Spawnfile);
            object successAdmin = Spawns.Call("GetSpawnsCount", configData.Admin.Spawnfile);
            if (successA is string)
            {
                configData.TeamA.Spawnfile = null;
                Puts("Error finding the Team A spawn file");
                return false;
            }
            if (successB is string)
            {
                configData.TeamB.Spawnfile = null;
                Puts("Error finding the Team B spawn file");
                return false;
            }
            if (successAdmin is string)
            {
                configData.Admin.Spawnfile = null;
                SaveConfig(configData);
                Puts("Error finding the Admin spawn file, removing admin spawn points");                
            }
            return true;
        }
        static void MovePlayerPosition(BasePlayer player, Vector3 destination)
        {
            try
            {
                if (player.isMounted)
                    player.GetMounted().DismountPlayer(player, true);

                player.SetParent(null, true, true);

                player.StartSleeping();
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);

                player.EnablePlayerCollider();
                player.RemovePlayerRigidbody();
                //player.UpdatePlayerCollider(true);
                //player.UpdatePlayerRigidbody(false);
                player.EnableServerFall(true);
                player.MovePosition(destination);
                player.ClientRPCPlayer(null, player, "ForcePositionTo", destination);

                player.UpdateNetworkGroup();
                player.SendNetworkUpdateImmediate(false);
                player.ClearEntityQueue(null);
                player.SendFullSnapshot();
            }
            finally
            {
                //player.UpdatePlayerCollider(true);
                //player.UpdatePlayerRigidbody(true);
                player.EnablePlayerCollider();
                player.AddPlayerRigidbody();
                player.EnableServerFall(false);
            }
        }
        
        private void StartSpectating(BasePlayer player, BasePlayer target)
        {
            if (!player.IsSpectating())
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
                player.gameObject.SetLayerRecursive(10);
                player.CancelInvoke("MetabolismUpdate");
                player.CancelInvoke("InventoryUpdate");
                player.ClearEntityQueue();
                player.SendEntitySnapshot(target);
                player.gameObject.Identity();
                player.SetParent(target, 0);
            }
        }
        private void EndSpectating(BasePlayer player)
        {
            if (player.IsSpectating())
            {
                player.SetParent(null, 0);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
                player.gameObject.SetLayerRecursive(17);
                player.metabolism.Reset();
                player.InvokeRepeating("InventoryUpdate", 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
            }
        }       
        private void AddPoints(BasePlayer player, BasePlayer victim)
        {
            string colorAttacker = "";
            string colorVictim = "";
            string prefixAttacker = "";
            string prefixVictim = "";
            switch (player.GetComponent<TBPlayer>().team)
            {
                case Team.NONE:
                    return;
                case Team.A:
                    TeamA_Score++;
                    colorAttacker = configData.TeamA.Chat_Color; 
                    prefixAttacker = configData.TeamA.Chat_Prefix;                    
                    break;
                case Team.B:
                    TeamB_Score++;
                    colorAttacker = configData.TeamB.Chat_Color;                    
                    prefixAttacker = configData.TeamB.Chat_Prefix;                    
                    break;
                case Team.ADMIN:
                    colorAttacker = configData.Admin.Chat_Color;
                    prefixAttacker = configData.Admin.Chat_Prefix;
                    return;
                case Team.SPECTATOR:
                    return;
            }
            switch (victim.GetComponent<TBPlayer>().team)
            {
                case Team.NONE:
                    return;
                case Team.A:
                    colorVictim = configData.TeamA.Chat_Color;
                    prefixVictim = configData.TeamA.Chat_Prefix;
                    break;
                case Team.B:
                    colorVictim = configData.TeamB.Chat_Color;
                    prefixVictim = configData.TeamB.Chat_Prefix;
                    break;
                case Team.SPECTATOR:
                    return;
                case Team.ADMIN:
                    colorVictim = configData.Admin.Chat_Color;
                    prefixVictim = configData.Admin.Chat_Prefix;
                    break;               
            }
            RefreshScoreboard();
            if (configData.Options.BroadcastDeath)
            {
                string formatMsg = colorAttacker + player.displayName + "</color> has killed " + colorVictim + victim.displayName + "</color>";
                PrintToChat(formatMsg);
            }
        }
        #endregion

        #region Giving Items
        private void GivePlayerWeapons(BasePlayer player)
        {
            foreach (var entry in configData.Gear.StartingWeapons)
            {
                for (var i = 0; i < entry.amount; i++)
                    GiveItem(player, BuildWeapon(entry), entry.container);
                if (!string.IsNullOrEmpty(entry.ammoType))
                    GiveItem(player, BuildItem(entry.ammoType, entry.ammo), "main");
            }
        }
        private void GivePlayerGear(BasePlayer player, Team team)
        {
            foreach (var entry in configData.Gear.CommonGear)            
                GiveItem(player, BuildItem(entry.shortname, entry.amount, entry.skin), entry.container);

            var teamGear = new List<Gear>();
            if (team == Team.A) teamGear = configData.TeamA.Gear;
            else if (team == Team.B) teamGear = configData.TeamB.Gear;
            else if (team == Team.ADMIN) teamGear = configData.Admin.Gear;

            if (teamGear != null)
                foreach(var entry in teamGear)
                    GiveItem(player, BuildItem(entry.shortname, entry.amount, entry.skin), entry.container);
        }
        private Item BuildItem(string shortname, int amount = 1, ulong skin = 0)
        {
            var definition = ItemManager.FindItemDefinition(shortname);
            if (definition != null)
            {
                var item = ItemManager.Create(definition, amount, skin);
                if (item != null)
                    return item;
            }
            Puts("Error making item: " + shortname);
            return null;
        }
        private Item BuildWeapon(Weapon newWeapon)
        {
            var item = BuildItem(newWeapon.shortname, 1, newWeapon.skin);
            if (item == null) return null;
            var weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                weapon.primaryMagazine.contents = weapon.primaryMagazine.capacity;
                if (!string.IsNullOrEmpty(newWeapon.ammoType))
                {
                    var ammoType = ItemManager.FindItemDefinition(newWeapon.ammoType);
                    if (ammoType != null)
                        weapon.primaryMagazine.ammoType = ammoType;
                }
            }
            if (newWeapon.contents == null) return item;

            foreach (var content in newWeapon.contents)
                BuildItem(content)?.MoveToContainer(item.contents);

            return item;
        }
        public void GiveItem(BasePlayer player, Item item, string container)
        {
            if (item == null) return;
            ItemContainer cont;
            switch (container)
            {
                case "wear":
                    cont = player.inventory.containerWear;
                    break;
                case "belt":
                    cont = player.inventory.containerBelt;
                    break;
                default:
                    cont = player.inventory.containerMain;
                    break;
            }
            player.inventory.GiveItem(item, cont);
        }
        #endregion

        #region Console Commands
        
        [ConsoleCommand("tbf.list")]
        private void cmdList(ConsoleSystem.Arg arg)
        {
            for (int i = 0; i < TBPlayers.Count; i++)
                SendReply(arg, "Name: " + TBPlayers[i].player.displayName + ", Team: " + TBPlayers[i].team.ToString()); 
        }
        [ConsoleCommand("tbf.clearscore")]
        private void cmdClearscore(ConsoleSystem.Arg arg)
        {
            if (isAuth(arg))
            {
                TeamA_Score = 0;
                TeamB_Score = 0;
                RefreshScoreboard();
                SendReply(arg, "Score's have been reset");
            }
        }

        [ConsoleCommand("tbf.assign")]
        private void cmdAssign(ConsoleSystem.Arg arg)
        {
            if (!isAuth(arg)) return;
            if (arg.Args == null || arg.Args.Length == 0)            
            {
                SendReply(arg, "Format: tbf.assign <PARTIAL_PLAYERNAME> <[\"a\",\"b\",\"spectator\"]>");
                return;
            }           
            if (arg.Args.Length == 2)
            {
                var partialPlayerName = arg.Args[0];
                var foundPlayers = FindPlayer(partialPlayerName);
                if (foundPlayers.Count == 0)
                {
                    SendReply(arg, "No players found");
                    return;
                }
                if (foundPlayers.Count > 1)
                {
                    SendReply(arg, "Multiple players found");
                    return;
                }
                var newTeam = Team.SPECTATOR;

                switch (arg.Args[1].ToUpper())
                {
                    case "A":
                        newTeam = Team.A;
                        break;

                    case "B":
                        newTeam = Team.B;
                        break;
                    case "SPECTATOR":
                        if (!configData.Spectators.EnableSpectators)
                        {
                            SendReply(arg, "You have spectators disabled in the config");
                            return;
                        }
                        newTeam = Team.SPECTATOR;
                        break;

                    default:
                        SendReply(arg, "Invalid team assignment.");
                        return;
                }
                if (foundPlayers[0] != null)
                {
                    AssignPlayerToTeam(foundPlayers[0], newTeam);
                    SendReply(arg, foundPlayers[0].displayName + " has been successfully assigned to team " + newTeam.ToString());
                }
                else SendReply(arg, "There was a error assigning a new team");
            }
        }

        [ConsoleCommand("tbf.version")]
        private void cmdVersion(ConsoleSystem.Arg arg) => SendReply(arg, Title + "  --  V " + Version.ToString() + "  --  by " + Author);
       
        [ConsoleCommand("tbf.help")]
        private void cmdHelp(ConsoleSystem.Arg arg)
        {
            SendReply(arg, "TeamBattlefield Console Commands:");
            SendReply(arg, "tbf.list - Lists teams and disconnect times of players.");
            SendReply(arg, "tbf.assign <PartialPlayerName> [one/two/spectator] - Assigns player to team.");
            SendReply(arg, "tbf.purge - Removes players from all teams if they're been disconnected for more than 5 minutes.");
            SendReply(arg, "tbf.version - Prints current version number of plugin.");
        }

        [ConsoleCommand("tbf.purge")]
        private void cmdPurge(ConsoleSystem.Arg arg)
        {
            int count = DCPlayers.Count;
            foreach (var entry in DCTimers)
                entry.Value.Destroy();
            DCPlayers.Clear();
            DCTimers.Clear();
            SendReply(arg, string.Format("You have removed {0} inactive player data", count));
        }

        [ChatCommand("switchteam")]
        private void cmdChangeTeam(BasePlayer player, string command, string[] args) => OpenTeamSelection(player);

        bool isAuth(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel < 1)
                {
                    SendReply(arg, "You dont not have permission to use this command.");
                    return false;
                }
            }
            return true;
        }
        [ChatCommand("t")]
        private void cmdTeamChat(BasePlayer player, string command, string[] args)
        {
            if (player.GetComponent<TBPlayer>())
            {
                var message = string.Join(" ", args);
                if (string.IsNullOrEmpty(message))
                    return;

                var sendingPlayer = player.GetComponent<TBPlayer>();
                var team = sendingPlayer.team;
                string color = "";                
                switch (team)
                {
                    case Team.A:
                        color = configData.TeamA.Chat_Color;
                        break;
                    case Team.B:
                        color = configData.TeamB.Chat_Color;
                        break;
                    case Team.ADMIN:
                        color = configData.Admin.Chat_Color;
                        return;
                    case Team.SPECTATOR:
                        color = configData.Spectators.Chat_Color;
                        return;
                }               

                foreach (var p in TBPlayers)
                {
                    if (p.team == player.GetComponent<TBPlayer>().team)
                    {
                        SendReply(p.player, $"{color}Team Chat : </color>{message}");
                    }
                }
            }
        }
        #endregion

        #region UI Commands
        [ConsoleCommand("TBUI_TeamSelect")]
        private void cmdTeamSelectA(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var team = ConvertStringToTeam(arg.GetString(0));
            AssignPlayerToTeam(player, team);
        }
        
        private Team ConvertStringToTeam(string team)
        {
            switch (team)
            {
                case "a": return Team.A;
                case "b": return Team.B;
                case "admin": return Team.ADMIN;
                case "spectator": return Team.SPECTATOR;
                default:
                    return Team.A;
            }
        }
        #endregion

        #region Team Management
        enum Team
        {
            NONE,
            A,
            B,
            SPECTATOR,
            ADMIN
        }
        private List<BasePlayer> FindPlayer(string arg)
        {
            var foundPlayers = new List<BasePlayer>();
            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var p in BasePlayer.activePlayerList)
                if (p != null)
                {
                    if (steamid != 0L)
                        if (p.userID == steamid)
                        {
                            foundPlayers.Add(p);
                            return foundPlayers;
                        }
                    string lowername = p.displayName.ToLower();
                    if (lowername.Contains(lowerarg))
                        foundPlayers.Add(p);
                }
            return foundPlayers;
        }
        private int CountPlayers(Team team)
        {
            int i = 0;
            foreach (var entry in TBPlayers)
            {
                if (entry.team == team)
                    i++;
            }
            return i;
        }
        private void AssignPlayerToTeam(BasePlayer player , Team team)
        {
            CuiHelper.DestroyUi(player, UIMain);
            if (!player.GetComponent<TBPlayer>())
                TBPlayers.Add(player.gameObject.AddComponent<TBPlayer>());
            else if (player.GetComponent<TBPlayer>().team == team)
                return;

            bool isSpec = false;
            if (player.GetComponent<TBPlayer>().team == Team.SPECTATOR)
                isSpec = true;

            int aCount = CountPlayers(Team.A);
            int bCount = CountPlayers(Team.B);
            if (team == Team.A)
            {
                if (aCount > bCount + configData.Options.MaximumTeamCountDifference)
                {
                    team = Team.B;
                    SendReply(player, "There are too many players on Team A, auto assigning to Team B");
                }
            }
            if (team == Team.B)
            {
                if (bCount > aCount + configData.Options.MaximumTeamCountDifference)
                {
                    team = Team.A;
                    SendReply(player, "There are too many players on Team B, auto assigning to Team A");
                }
            }
            if (team == Team.SPECTATOR)
            {
                var target = GetRandomTeammate(player);
                player.GetComponent<TBPlayer>().team = team;
                if (target != null)
                    StartSpectating(player, target);
                else StartSpectating(player, BasePlayer.activePlayerList[UnityEngine.Random.Range(0, BasePlayer.activePlayerList.Count - 1)]);
                return;               
            }

            player.GetComponent<TBPlayer>().team = team;
           
            if (isSpec)
                EndSpectating(player);
            player.DieInstantly();            
            player.Respawn();
        } 
        private BasePlayer GetRandomTeammate(BasePlayer player)
        {
            var teammates = new List<BasePlayer>();
            var team = player.GetComponent<TBPlayer>().team;
            foreach (var tm in TBPlayers)
            {
                if (tm.player == player) continue;
                if (tm.team == team)
                    teammates.Add(tm.player);
            }
            if (teammates.Count > 0)
                return teammates[UnityEngine.Random.Range(0, teammates.Count - 1)];
            else return null;
        }      
        #endregion

        #region Externally Called Functions
        string GetPlayerTeam (ulong playerID)
        {
            foreach (var entry in TBPlayers)
                if (entry.player.userID == playerID)
                    return entry.team.ToString();
            return null;            
        }
        Dictionary<ulong, string> GetTeams()
        {
            Dictionary<ulong, string> returnedList = new Dictionary<ulong, string>();
            foreach (var player in TBPlayers)
                returnedList.Add(player.player.userID, player.team.ToString());
            
            return returnedList;
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class TeamOptions
        {
            public string Spawnfile { get; set; }
            public string Chat_Prefix { get; set; }
            public string Chat_Color { get; set; }
            public List<Gear> Gear { get; set; }
        }
        class Options
        {
            public int MaximumTeamCountDifference { get; set; }
            public int RemoveSleeper_Timer { get; set; }
            public float FF_DamageScale { get; set; }
            public bool UsePluginChatControl { get; set; }
            public bool BroadcastDeath { get; set; }
            
        }
        class GUI
        {
            public float XPosition { get; set; }
            public float YPosition { get; set; }
            public float XDimension { get; set; }
            public float YDimension { get; set; }
        }
        class ConfigGear
        {
            public List<Gear> CommonGear { get; set; }
            public List<Weapon> StartingWeapons { get; set; }
        }
        class Spectators
        {
            public bool EnableSpectators { get; set; }
            public string Chat_Color { get; set; }
            public string Chat_Prefix { get; set; }
        }
        class ConfigData
        {            
            public TeamOptions TeamA { get; set; }
            public TeamOptions TeamB { get; set; }
            public TeamOptions Admin { get; set; }
            public ConfigGear Gear { get; set; }
            public Options Options { get; set; }
            public Spectators Spectators { get; set; }
            public GUI ScoreboardUI { get; set; }               
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Admin = new TeamOptions
                {
                    Chat_Color = "<color=#00ff04>",
                    Chat_Prefix = "[Admin] ",
                    Gear = new List<Gear>
                    {
                        new Gear
                    {
                        name = "Hoodie",
                        shortname = "hoodie",
                        amount = 1,
                        container = "wear",
                        skin = 10129
                    },
                    new Gear
                    {
                        name = "Pants",
                        shortname = "pants",
                        amount = 1,
                        container = "wear",
                        skin = 10078
                    },
                    new Gear
                    {
                        name = "Gloves",
                        shortname = "burlap.gloves",
                        amount = 1,
                        container = "wear",
                        skin = 10128
                    },
                    new Gear
                    {
                        name = "Boots",
                        shortname = "shoes.boots",
                        amount = 1,
                        container = "wear",
                        skin = 10023
                    }
                    },
                    Spawnfile = "admin_spawns"
                },
                Gear = new ConfigGear
                {
                    CommonGear = new List<Gear>
                {
                    {
                        new Gear
                        {
                            name = "Machete",
                            shortname = "machete",
                            amount = 1,
                            container = "belt"
                        }
                    },
                    {
                        new Gear
                        {
                            name = "Medical Syringe",
                            shortname = "syringe.medical",
                            amount = 2,
                            container = "belt"
                        }
                    },
                    {
                        new Gear
                        {
                            name = "Bandage",
                            shortname = "bandage",
                            amount = 1,
                            container = "belt"
                        }
                    },
                    {
                        new Gear
                        {
                            name = "Paper Map",
                            shortname = "map",
                            amount = 1,
                            container = "belt"
                        }
                    },
                    {
                        new Gear
                        {
                            name = "Metal ChestPlate",
                            shortname = "metal.plate.torso",
                            amount = 1,
                            container = "wear"
                        }
                    }
                },

                StartingWeapons = new List<Weapon>
                {
                    new Weapon
                    {
                            name = "AssaultRifle",
                            shortname = "rifle.ak",
                            container = "belt",
                            ammoType = "ammo.rifle.hv",
                            ammo = 120,
                            amount = 1,
                            contents = new [] {"weapon.mod.holosight"}
                    },
                    new Weapon
                    {
                            name = "SemiAutoPistol",
                            shortname = "pistol.semiauto",
                            container = "belt",
                            ammoType = "ammo.pistol.hv",
                            amount = 1,
                            ammo = 120,
                            contents = new [] {"weapon.mod.silencer"}
                    }
                }
                },
                Options = new Options
                {
                    BroadcastDeath = true,
                    FF_DamageScale = 0.5f,
                    MaximumTeamCountDifference = 5,
                    RemoveSleeper_Timer = 5,
                    UsePluginChatControl = true
                },
                ScoreboardUI = new GUI
                {
                    XDimension = 0.22f,
                    XPosition = 0.39f,
                    YDimension = 0.05f,
                    YPosition = 0.95f
                },
                Spectators = new Spectators
                {
                    Chat_Color = "<color=white>",
                    Chat_Prefix = "[Spectator] ",
                    EnableSpectators = true
                },
                TeamA = new TeamOptions
                {
                    Spawnfile = "team_a_spawns",
                    Chat_Color = "<color=#0066ff>",
                    Chat_Prefix = "[Team A] ",
                    Gear = new List<Gear>
                    {
                         new Gear
                    {
                        name = "Hoodie",
                        shortname = "hoodie",
                        amount = 1,
                        container = "wear",
                        skin = 14178
                    },
                    new Gear
                    {
                        name = "Pants",
                        shortname = "pants",
                        amount = 1,
                        container = "wear",
                        skin = 10020
                    },
                    new Gear
                    {
                        name = "Gloves",
                        shortname = "burlap.gloves",
                        amount = 1,
                        container = "wear",
                        skin = 10128
                    },
                    new Gear
                    {
                        name = "Boots",
                        shortname = "shoes.boots",
                        amount = 1,
                        container = "wear",
                        skin = 10023
                    }
                    }
                },
                TeamB = new TeamOptions
                {
                    Chat_Color = "<color=#ff0000>",
                    Chat_Prefix = "[Team B] ",
                    Spawnfile = "team_b_spawns",
                    Gear = new List<Gear>
                    {
                        new Gear
                    {
                        name = "Hoodie",
                        shortname = "hoodie",
                        amount = 1,
                        container = "wear",
                        skin = 0
                    },
                    new Gear
                    {
                        name = "Pants",
                        shortname = "pants",
                        amount = 1,
                        container = "wear",
                        skin = 10019
                    },
                    new Gear
                    {
                        name = "Gloves",
                        shortname = "burlap.gloves",
                        amount = 1,
                        container = "wear",
                        skin = 10128
                    },
                    new Gear
                    {
                        name = "Boots",
                        shortname = "shoes.boots",
                        amount = 1,
                        container = "wear",
                        skin = 10023
                    }
                    }
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);        
        #endregion

        #region Classes
        class TBPlayer : MonoBehaviour
        {
            public BasePlayer player;
            public int kills;
            public Team team;
            
            void Awake()
            {
                player = GetComponent<BasePlayer>();
                enabled = false;
                kills = 0;
                team = Team.NONE;
            }
        }        
        class PlayerData
        {
            public int kills;
            public Team team;
        }
        class Gear
        {
            public string name;
            public string shortname;
            public ulong skin;
            public int amount;
            public string container;
        }
        class Weapon
        {
            public string name;
            public string shortname;
            public ulong skin;
            public string container;
            public int amount;
            public int ammo;
            public string ammoType;
            public string[] contents = new string[0];
        }
        #endregion
    }
}


// --- End of file: TeamBattlefield.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tebex ---
// --- Original File Path: T/TebexPlugin/TebexPlugin.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Plugins;
using System;
using System.Linq;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Tebex", "Tebex", "2.0.13")]
    [Description("Official support for the Tebex server monetization platform")]
    public class TebexPlugin : CovalencePlugin
    {
        private static TebexOxideAdapter _adapter;

        private Dictionary<string, DateTime> _lastNoteGiven = new Dictionary<string, DateTime>();

        public static string GetPluginVersion()
        {
            return "2.0.13";
        }

        public TebexPlatform GetPlatform(IServer server)
        {
            String gameId = "";
            
            #if RUST
                gameId = "Rust";
            #else
                gameId = "7 Days";
            #endif
            
            return new TebexPlatform(gameId, GetPluginVersion(), new TebexTelemetry("Oxide", server.Version, server.Protocol));
        }
        
        
        private void Init()
        {
            // Setup our API and adapter
            _adapter = new TebexOxideAdapter(this);
            TebexApi.Instance.InitAdapter(_adapter);

            BaseTebexAdapter.PluginConfig = Config.ReadObject<BaseTebexAdapter.TebexConfig>();
            if (!Config.Exists())
            {
                //Creates new config file
                LoadConfig();
            }

            // Register permissions
            permission.RegisterPermission("tebexplugin.secret", this);
            permission.RegisterPermission("tebexplugin.sendlink", this);
            permission.RegisterPermission("tebexplugin.forcecheck", this);
            permission.RegisterPermission("tebexplugin.refresh", this);
            permission.RegisterPermission("tebexplugin.report", this);
            permission.RegisterPermission("tebexplugin.ban", this);
            permission.RegisterPermission("tebexplugin.lookup", this);
            permission.RegisterPermission("tebexplugin.debug", this);
            permission.RegisterPermission("tebexplugin.setup", this);

            // Register user permissions
            permission.RegisterPermission("tebexplugin.info", this);
            permission.RegisterPermission("tebexplugin.categories", this);
            permission.RegisterPermission("tebexplugin.packages", this);
            permission.RegisterPermission("tebexplugin.checkout", this);

            // Check if auto reporting is disabled and show a warning if so.
            if (!BaseTebexAdapter.PluginConfig.AutoReportingEnabled)
            {
                _adapter.LogWarning("Auto reporting issues to Tebex is disabled.", "To enable, please set 'AutoReportingEnabled' to 'true' in config/Tebex.json");
                PluginEvent.IS_DISABLED = true;
            }

            // Check if secret key has been set. If so, get store information and place in cache
            if (BaseTebexAdapter.PluginConfig.SecretKey != "your-secret-key-here")
            {
                _adapter.FetchStoreInfo((info =>
                {
                    PluginEvent.SERVER_IP = server.Address.ToString();
                    PluginEvent.SERVER_ID = info.ServerInfo.Id.ToString();
                    PluginEvent.STORE_URL = info.AccountInfo.Domain;
                    new PluginEvent(this, this.GetPlatform(server), EnumEventLevel.INFO, "Server Init").Send(_adapter);
                    _adapter.SetSecretKeyValidated(true);
                }));
                return;
            }

            _adapter.LogInfo("Tebex detected a new configuration file.");
            _adapter.LogInfo("Use tebex:secret <secret> to add your store's secret key.");
            _adapter.LogInfo("Alternatively, add the secret key to 'Tebex.json' and reload the plugin.");
        }

        public WebRequests WebRequests()
        {
            return webrequest;
        }

        public IPlayerManager PlayerManager()
        {
            return players;
        }

        public PluginTimers PluginTimers()
        {
            return timer;
        }

        public IServer Server()
        {
            return server;
        }

        public string GetGame()
        {
            return game;
        }

        public void Warn(string message)
        {
            if (!BaseTebexAdapter.PluginConfig.SuppressWarnings)
            {
                LogWarning("{0}", message);    
            }
        }

        public void Error(string message)
        {
            if (!BaseTebexAdapter.PluginConfig.SuppressErrors)
            {
                LogError("{0}", message);    
            }
        }

        public void Info(string info)
        {
            Puts("{0}", info);
        }

        private void OnUserConnected(IPlayer player)
        {
            // Check for default config and inform the admin that configuration is waiting.
            if (player.IsAdmin && BaseTebexAdapter.PluginConfig.SecretKey == "your-secret-key-here")
            {
                player.Command("chat.add", 0, player.Id,
                    "Tebex is not configured. Use tebex:secret <secret> from the F1 menu to add your key.");
                player.Command("chat.add", 0, player.Id, "Get your secret key by logging in at:");
                player.Command("chat.add", 0, player.Id, "https://tebex.io/");
            }

            _adapter.LogDebug($"Player login event: {player.Id}@{player.Address}");
            _adapter.OnUserConnected(player.Id, player.Address);
        }

        #if RUST // VIP notes are enabled on Rust only
        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (!BaseTebexAdapter.PluginConfig.VipNotesEnabled)
            {
                return;
            }
            
            // If the user configured no VIP codes, skip.
            if (BaseTebexAdapter.PluginConfig.VipCodes.Count == 0)
            {
                return;
            }

            // Check if we have a target loot crate by prefab name
            string prefabName = entity?.ShortPrefabName;
            if (string.IsNullOrEmpty(prefabName) || (prefabName != "crate_normal_2" &&
                                                     prefabName != "crate_normal_2_food" &&
                                                     prefabName != "crate_normal_2_tools"))
            {
                return;
            }

            // Ensure the player was provided
            string userID = player?.UserIDString;
            if (string.IsNullOrEmpty(userID))
            {
                return;
            }

            // If the player is already in a VIP group, they won't receive a VIP note
            if (BaseTebexAdapter.PluginConfig.VipGroups.Any(group => permission.UserHasGroup(userID, group)))
            {
                return;
            }

            // Make sure we haven't spawned a note too recently for the user.
            if (_lastNoteGiven.TryGetValue(userID, out DateTime lastGivenTime) &&
                (DateTime.Now - lastGivenTime).Seconds < BaseTebexAdapter.PluginConfig.NoteCooldown)
            {
                return;
            }

            // Spawn chance check
            if (Oxide.Core.Random.Range(0.0f, 1.0f) > BaseTebexAdapter.PluginConfig.NoteSpawnChance)
            {
                return;
            }

            // Create the note
            Item item = ItemManager.CreateByName("note", 1, 0UL);
            if (item == null)
            {
                return;
            }

            List<string> messages = BaseTebexAdapter.PluginConfig.NoteMessages["en"];
            string message = messages[Oxide.Core.Random.Range(0, messages.Count)];
            string vipCode = BaseTebexAdapter.PluginConfig.VipCodes[Oxide.Core.Random.Range(0, BaseTebexAdapter.PluginConfig.VipCodes.Count)];

            var info = BaseTebexAdapter.Cache.Instance.Get("information").Value as TebexApi.TebexStoreInfo;
            if (info != null)
            {
                item.text = string.Format(message, player.displayName, info.AccountInfo.Domain, vipCode);
                item.MarkDirty();
                player.GiveItem(item, BaseEntity.GiveItemReason.Generic);

                _lastNoteGiven[userID] = DateTime.Now;                
            }
            else
            {
                _adapter.LogDebug("Store information not present in cache when trying to spawn VIP note!");
            }
        }
        #endif
        
        private void OnServerShutdown()
        {
            // Make sure join queue is always emptied on shutdown
            _adapter.ProcessJoinQueue();
        }

        private void PrintCategories(IPlayer player, List<TebexApi.Category> categories)
        {
            // Index counter for selecting displayed items
            var categoryIndex = 1;
            var packIndex = 1;

            // Line separator for category response
            _adapter.ReplyPlayer(player, "---------------------------------");

            // Sort categories in order and display
            var orderedCategories = categories.OrderBy(category => category.Order).ToList();
            for (int i = 0; i < categories.Count; i++)
            {
                var listing = orderedCategories[i];
                _adapter.ReplyPlayer(player, $"[C{categoryIndex}] {listing.Name}");
                categoryIndex++;

                // Show packages for the category in order from API
                if (listing.Packages.Count > 0)
                {
                    var packages = listing.Packages.OrderBy(category => category.Order).ToList();
                    _adapter.ReplyPlayer(player, $"Packages");
                    foreach (var package in packages)
                    {
                        // Add additional flair on sales
                        if (package.Sale != null && package.Sale.Active)
                        {
                            _adapter.ReplyPlayer(player,
                                $"-> [P{packIndex}] {package.Name} {package.Price - package.Sale.Discount} (SALE {package.Sale.Discount} off)");
                        }
                        else
                        {
                            _adapter.ReplyPlayer(player, $"-> [P{packIndex}] {package.Name} {package.Price}");
                        }

                        packIndex++;
                    }
                }

                // At the end of each category add a line separator
                _adapter.ReplyPlayer(player, "---------------------------------");
            }
        }

        private static void PrintPackages(IPlayer player, List<TebexApi.Package> packages)
        {
            // Index counter for selecting displayed items
            var packIndex = 1;

            _adapter.ReplyPlayer(player, "---------------------------------");
            _adapter.ReplyPlayer(player, "      PACKAGES AVAILABLE         ");
            _adapter.ReplyPlayer(player, "---------------------------------");

            // Sort categories in order and display
            var orderedPackages = packages.OrderBy(package => package.Order).ToList();
            for (var i = 0; i < packages.Count; i++)
            {
                var package = orderedPackages[i];
                // Add additional flair on sales
                _adapter.ReplyPlayer(player, $"[P{packIndex}] {package.Name}");
                _adapter.ReplyPlayer(player, $"Category: {package.Category.Name}");
                _adapter.ReplyPlayer(player, $"Description: {package.Description}");

                if (package.Sale != null && package.Sale.Active)
                {
                    _adapter.ReplyPlayer(player,
                        $"Original Price: {package.Price} {package.GetFriendlyPayFrequency()}  SALE: {package.Sale.Discount} OFF!");
                }
                else
                {
                    _adapter.ReplyPlayer(player, $"Price: {package.Price} {package.GetFriendlyPayFrequency()}");
                }

                _adapter.ReplyPlayer(player,
                    $"Purchase with 'tebex.checkout P{packIndex}' or 'tebex.checkout {package.Id}'");
                _adapter.ReplyPlayer(player, "--------------------------------");

                packIndex++;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private BaseTebexAdapter.TebexConfig GetDefaultConfig()
        {
            return new BaseTebexAdapter.TebexConfig();
        }

        [Command("tebex.secret", "tebex:secret")]
        private void TebexSecretCommand(IPlayer player, string command, string[] args)
        {
            // Secret can only be ran as the admin
            if (!player.HasPermission("tebexplugin.secret"))
            {
                _adapter.ReplyPlayer(player, "You do not have permission to run this command.");
                _adapter.ReplyPlayer(player, "If you are an admin, grant permission to use `tebex.secret`");
                return;
            }

            if (args.Length != 1)
            {
                _adapter.ReplyPlayer(player, "Invalid syntax. Usage: \"tebex.secret <secret>\"");
                return;
            }

            _adapter.ReplyPlayer(player, "Setting your secret key...");
            BaseTebexAdapter.PluginConfig.SecretKey = args[0];
            Config.WriteObject(BaseTebexAdapter.PluginConfig);

            // Reset store info so that we don't fetch from the cache
            BaseTebexAdapter.Cache.Instance.Remove("information");

            // Any failure to set secret key is logged to console automatically
            _adapter.FetchStoreInfo(info =>
            {
                _adapter.ReplyPlayer(player, $"Successfully set your secret key.");
                _adapter.ReplyPlayer(player,
                    $"Store set as: {info.ServerInfo.Name} for the web store {info.AccountInfo.Name}");

                PluginEvent.SERVER_ID = info.ServerInfo.Id.ToString();
                PluginEvent.STORE_URL = info.AccountInfo.Domain;
                _adapter.SetSecretKeyValidated(true);
            });
        }

        [Command("tebex.info", "tebex:info", "tebex.information", "tebex:information")]
        private void TebexInfoCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("tebexplugin.info"))
            {
                _adapter.ReplyPlayer(player, "You do not have permission to run that command.");
                return;
            }

            _adapter.ReplyPlayer(player, "Getting store information...");
            _adapter.FetchStoreInfo(info =>
            {
                _adapter.ReplyPlayer(player, "Information for this server:");
                _adapter.ReplyPlayer(player, $"{info.ServerInfo.Name} for webstore {info.AccountInfo.Name}");
                _adapter.ReplyPlayer(player, $"Server prices are in {info.AccountInfo.Currency.Iso4217}");
                _adapter.ReplyPlayer(player, $"Webstore domain {info.AccountInfo.Domain}");
            });
        }

        [Command("tebex.checkout", "tebex:checkout")]
        private void TebexCheckoutCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("tebexplugin.checkout"))
            {
                _adapter.ReplyPlayer(player, "You do not have permission to run that command.");
                return;
            }

            if (player.IsServer)
            {
                _adapter.ReplyPlayer(player,
                    $"{command} cannot be executed via server. Use tebex:sendlink <username> <packageId> to specify a target player.");
                return;
            }

            // Only argument will be the package ID of the item in question
            if (args.Length != 1)
            {
                _adapter.ReplyPlayer(player, "Invalid syntax: Usage \"tebex.checkout <packageId>\"");
                return;
            }

            // Lookup the package by provided input and respond with the checkout URL
            var package = _adapter.GetPackageByShortCodeOrId(args[0].Trim());
            if (package == null)
            {
                _adapter.ReplyPlayer(player, "A package with that ID was not found.");
                return;
            }

            _adapter.ReplyPlayer(player, "Creating your checkout URL...");
            _adapter.CreateCheckoutUrl(player.Name, package, checkoutUrl =>
            {
                player.Command("chat.add", 0, player.Id, "Please visit the following URL to complete your purchase:");
                player.Command("chat.add", 0, player.Id, $"{checkoutUrl.Url}");
            }, error => { _adapter.ReplyPlayer(player, $"{error.ErrorMessage}"); });
        }

        [Command("tebex.help", "tebex:help")]
        private void TebexHelpCommand(IPlayer player, string command, string[] args)
        {
            _adapter.ReplyPlayer(player, "Tebex Commands Available:");
            if (player.IsAdmin) //Always show help to admins regardless of perms, for new server owners
            {
                _adapter.ReplyPlayer(player, "-- Administrator Commands --");
                _adapter.ReplyPlayer(player, "tebex.secret <secretKey>          - Sets your server's secret key.");
                _adapter.ReplyPlayer(player, "tebex.debug <on/off>              - Enables or disables debug logging.");
                _adapter.ReplyPlayer(player,
                    "tebex.sendlink <player> <packId>  - Sends a purchase link to the provided player.");
                _adapter.ReplyPlayer(player,
                    "tebex.forcecheck                  - Forces the command queue to check for any pending purchases.");
                _adapter.ReplyPlayer(player,
                    "tebex.refresh                     - Refreshes store information, packages, categories, etc.");
                _adapter.ReplyPlayer(player,
                    "tebex.report                      - Generates a report for the Tebex support team.");
                _adapter.ReplyPlayer(player,
                    "tebex.ban <playerId>              - Bans a player from using your Tebex store.");
                _adapter.ReplyPlayer(player,
                    "tebex.lookup <playerId>           - Looks up store statistics for the given player.");
            }

            _adapter.ReplyPlayer(player, "-- User Commands --");
            _adapter.ReplyPlayer(player,
                "tebex.info                       - Get information about this server's store.");
            _adapter.ReplyPlayer(player,
                "tebex.categories                 - Shows all item categories available on the store.");
            _adapter.ReplyPlayer(player,
                "tebex.packages <opt:categoryId>  - Shows all item packages available in the store or provided category.");
            _adapter.ReplyPlayer(player,
                "tebex.checkout <packId>          - Creates a checkout link for an item. Visit to purchase.");
        }
        
        [Command("tebex.debug", "tebex:debug")]
        private void TebexDebugCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("tebexplugin.debug"))
            {
                _adapter.ReplyPlayer(player, "You do not have permission to run that command.");
                return;
            }

            if (args.Length != 1)
            {
                _adapter.ReplyPlayer(player, "Usage: tebex.debug <on/off>");
                return;
            }

            if (args[0].Equals("on"))
            {
                BaseTebexAdapter.PluginConfig.DebugMode = true;
                Config.WriteObject(BaseTebexAdapter.PluginConfig);
                _adapter.ReplyPlayer(player, "Debug mode is enabled.");
            }
            else if (args[0].Equals("off"))
            {
                BaseTebexAdapter.PluginConfig.DebugMode = false;
                Config.WriteObject(BaseTebexAdapter.PluginConfig);
                _adapter.ReplyPlayer(player, "Debug mode is disabled.");
            }
            else
            {
                _adapter.ReplyPlayer(player, "Usage: tebex.debug <on/off>");
            }
        }

        [Command("tebex.forcecheck", "tebex:forcecheck")]
        private void TebexForceCheckCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("tebexplugin.forcecheck"))
            {
                _adapter.ReplyPlayer(player, "You do not have permission to run that command.");
                return;
            }

            _adapter.RefreshStoreInformation(true);
            _adapter.ProcessCommandQueue(true);
            _adapter.ProcessJoinQueue(true);
            _adapter.DeleteExecutedCommands(true);
        }

        [Command("tebex.refresh", "tebex:refresh")]
        private void TebexRefreshCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("tebexplugin.refresh"))
            {
                _adapter.ReplyPlayer(player, "You do not have permission to run that command.");
                return;
            }

            _adapter.ReplyPlayer(player, "Refreshing listings...");
            BaseTebexAdapter.Cache.Instance.Remove("packages");
            BaseTebexAdapter.Cache.Instance.Remove("categories");

            _adapter.RefreshListings((code, body) =>
            {
                if (BaseTebexAdapter.Cache.Instance.HasValid("packages") &&
                    BaseTebexAdapter.Cache.Instance.HasValid("categories"))
                {
                    var packs = (List<TebexApi.Package>)BaseTebexAdapter.Cache.Instance.Get("packages").Value;
                    var categories = (List<TebexApi.Category>)BaseTebexAdapter.Cache.Instance.Get("categories").Value;
                    _adapter.ReplyPlayer(player,
                        $"Fetched {packs.Count} packages out of {categories.Count} categories");
                }
            });
        }

        [Command("tebex.ban", "tebex:ban")]
        private void TebexBanCommand(IPlayer commandRunner, string command, string[] args)
        {
            if (!commandRunner.HasPermission("tebexplugin.ban"))
            {
                _adapter.ReplyPlayer(commandRunner, $"{command} can only be used by administrators.");
                return;
            }

            if (args.Length < 2)
            {
                _adapter.ReplyPlayer(commandRunner, $"Usage: tebex.ban <playerName> <reason>");
                return;
            }

            var player = players.FindPlayer(args[0].Trim());
            if (player == null)
            {
                _adapter.ReplyPlayer(commandRunner, $"Could not find that player on the server.");
                return;
            }

            var reason = string.Join(" ", args.Skip(1));
            _adapter.ReplyPlayer(commandRunner, $"Processing ban for player {player.Name} with reason '{reason}'");
            _adapter.BanPlayer(player.Name, player.Address, reason,
                (code, body) => { _adapter.ReplyPlayer(commandRunner, "Player banned successfully."); },
                error => { _adapter.ReplyPlayer(commandRunner, $"Could not ban player. {error.ErrorMessage}"); });
        }

        [Command("tebex.unban", "tebex:unban")]
        private void TebexUnbanCommand(IPlayer commandRunner, string command, string[] args)
        {
            if (!commandRunner.IsAdmin)
            {
                _adapter.ReplyPlayer(commandRunner, $"{command} can only be used by administrators.");
                return;
            }

            _adapter.ReplyPlayer(commandRunner, $"You must unban players via your webstore.");
        }

        [Command("tebex.categories", "tebex:categories", "tebex.listings", "tebex:listings")]
        private void TebexCategoriesCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("tebexplugin.categories"))
            {
                _adapter.ReplyPlayer(player, "You do not have permission to run that command.");
                return;
            }

            _adapter.GetCategories(categories => { PrintCategories(player, categories); });
        }

        [Command("tebex.packages", "tebex:packages")]
        private void TebexPackagesCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("tebexplugin.packages"))
            {
                _adapter.ReplyPlayer(player, "You do not have permission to run that command.");
                return;
            }

            _adapter.GetPackages(packages => { PrintPackages(player, packages); });
        }

        [Command("tebex.lookup", "tebex:lookup")]
        private void TebexLookupCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("tebexplugin.lookup"))
            {
                _adapter.ReplyPlayer(player, "You do not have permission to run that command.");
                return;
            }

            if (args.Length != 1)
            {
                _adapter.ReplyPlayer(player, $"Usage: tebex.lookup <playerId/playerUsername>");
                return;
            }

            // Try to find the given player
            var target = players.FindPlayer(args[0]);
            if (target == null)
            {
                _adapter.ReplyPlayer(player, $"Could not find a player matching the name or id {args[0]}.");
                return;
            }

            _adapter.GetUser(target.Id, (code, body) =>
            {
                var response = JsonConvert.DeserializeObject<TebexApi.UserInfoResponse>(body);
                _adapter.ReplyPlayer(player, $"Username: {response.Player.Username}");
                _adapter.ReplyPlayer(player, $"Id: {response.Player.Id}");
                _adapter.ReplyPlayer(player, $"Payments Total: ${response.Payments.Sum(payment => payment.Price)}");
                _adapter.ReplyPlayer(player, $"Chargeback Rate: {response.ChargebackRate}%");
                _adapter.ReplyPlayer(player, $"Bans Total: {response.BanCount}");
                _adapter.ReplyPlayer(player, $"Payments: {response.Payments.Count}");
            }, error => { _adapter.ReplyPlayer(player, error.ErrorMessage); });
        }

        [Command("tebex.sendlink", "tebex:sendlink")]
        private void TebexSendLinkCommand(IPlayer commandRunner, string command, string[] args)
        {
            if (!commandRunner.HasPermission("tebexplugin.sendlink"))
            {
                _adapter.ReplyPlayer(commandRunner, "You must be an administrator to run this command.");
                return;
            }

            if (args.Length != 2)
            {
                _adapter.ReplyPlayer(commandRunner, "Usage: tebex.sendlink <username> <packageId>");
                return;
            }

            var username = args[0].Trim();
            var package = _adapter.GetPackageByShortCodeOrId(args[1].Trim());
            if (package == null)
            {
                _adapter.ReplyPlayer(commandRunner, "A package with that ID was not found.");
                return;
            }

            _adapter.ReplyPlayer(commandRunner,
                $"Creating checkout URL with package '{package.Name}'|{package.Id} for player {username}");
            var player = players.FindPlayer(username);
            if (player == null)
            {
                _adapter.ReplyPlayer(commandRunner, $"Couldn't find that player on the server.");
                return;
            }

            _adapter.CreateCheckoutUrl(player.Name, package, checkoutUrl =>
            {
                player.Command("chat.add", 0, player.Id, "Please visit the following URL to complete your purchase:");
                player.Command("chat.add", 0, player.Id, $"{checkoutUrl.Url}");
            }, error => { _adapter.ReplyPlayer(player, $"{error.ErrorMessage}"); });
        }
        
        
    }    public abstract class BaseTebexAdapter
    {
        public static BaseTebexAdapter Instance => _adapterInstance.Value;
        private static readonly Lazy<BaseTebexAdapter> _adapterInstance = new Lazy<BaseTebexAdapter>();
        
        public static TebexConfig PluginConfig { get; set; } = new TebexConfig();

        private static bool _isSecretKeyValidated = false;
        
        /** For rate limiting command queue based on next_check */
        private static DateTime _nextCheckCommandQueue = DateTime.Now;
        
        // Time checks for our plugin timers.
        private static DateTime _nextCheckDeleteCommands = DateTime.Now;
        private static DateTime _nextCheckJoinQueue = DateTime.Now;
        private static DateTime _nextCheckRefresh = DateTime.Now;
        
        private static List<TebexApi.TebexJoinEventInfo> _eventQueue = new List<TebexApi.TebexJoinEventInfo>();
        
        /** For storing successfully executed commands and deleting them from API */
        protected static readonly List<TebexApi.Command> ExecutedCommands = new List<TebexApi.Command>();

        /** Allow pausing all web requests if rate limits are received from remote */
        protected bool IsRateLimited = false;
        
        public abstract void Init();

        public void DeleteExecutedCommands(bool ignoreWaitCheck = false)
        {
            LogDebug("Deleting executed commands...");
            if (!IsSecretKeyValidated())
            {
                LogDebug("Store key is not set or incorrect. Skipping command queue.");
                return;
            }
            
            if (!CanProcessNextDeleteCommands() && !ignoreWaitCheck)
            {
                LogDebug("Skipping check for completed commands - not time to be processed");
                return;
            }
            
            if (ExecutedCommands.Count == 0)
            {
                LogDebug("  No commands to flush.");
                return;
            }

            LogDebug($"  Found {ExecutedCommands.Count} commands to flush.");

            List<int> ids = new List<int>();
            foreach (var command in ExecutedCommands)
            {
                ids.Add(command.Id);
            }

            _nextCheckDeleteCommands = DateTime.Now.AddSeconds(60);
            TebexApi.Instance.DeleteCommands(ids.ToArray(), (code, body) =>
            {
                LogDebug("Successfully flushed completed commands.");
                ExecutedCommands.Clear();
            }, (error) =>
            {
                LogDebug($"Failed to flush completed commands: {error.ErrorMessage}");
            }, (code, body) =>
            {
                LogDebug($"Unexpected error while flushing completed commands. API response code {code}. Response body follows:");
                LogDebug(body);
            });
        }

        /**
         * Logs a warning to the console and game log.
         */
        public abstract void LogWarning(string message, string solution);

        public abstract void LogWarning(string message, string solution, Dictionary<String, String> metadata);

        /**
         * Logs an error to the console and game log.
         */
        public abstract void LogError(string message);

        public abstract void LogError(string message, Dictionary<String, String> metadata);
        
        /**
             * Logs information to the console and game log.
             */
        public abstract void LogInfo(string message);

        /**
             * Logs debug information to the console and game log if debug mode is enabled.
             */
        public abstract void LogDebug(string message);

        public void OnUserConnected(string steam64Id, string ip)
        {
            var joinEvent = new TebexApi.TebexJoinEventInfo(steam64Id, "server.join", DateTime.Now, ip);
            _eventQueue.Add(joinEvent);

            // If we're already over a threshold, go ahead and send the events.
            if (_eventQueue.Count > 10)
            {
                ProcessJoinQueue();
            }
        }
        
        public class TebexConfig
        {
            // Enables additional debug logging, which may show raw user info in console.
            public bool DebugMode = false;

            public bool SuppressWarnings = false;

            public bool SuppressErrors = false;
            
            // Automatically sends detected issues to Tebex 
            public bool AutoReportingEnabled = true;
            
            //public bool AllowGui = false;
            public string SecretKey = "your-secret-key-here";
            public int CacheLifetime = 30;
            
            //#if RUST
            [JsonProperty(PropertyName = "VIP Notes Enabled")]
            public bool VipNotesEnabled { get; set; } = false;
            
            [JsonProperty(PropertyName = "VIP Codes")]
            public List<string> VipCodes { get; set; } = new List<string>();
            
            [JsonProperty(PropertyName = "VIP Groups")]
            public List<string> VipGroups { get; set; } = new List<string>();

            [JsonProperty(PropertyName = "Note Spawn Chance")]
            public float NoteSpawnChance { get; set; } = 0.02f; // 2%
            
            [JsonProperty(PropertyName = "Note Cooldown (Seconds)")]
            public float NoteCooldown { get; set; } = 600; // 10 minutes

            [JsonProperty(PropertyName = "Note Messages")]
            public Dictionary<string, List<string>> NoteMessages { get; set; } = new Dictionary<string, List<string>>
            {
                {
                    "en", new List<string>
                    {
                        "Hey {0}, grab your exclusive 10% OFF VIP offer with code {2} at {1}! Limited time only!",
                        "{0}, seize your special discount! Use code {2} at {1} for a limited time offer!",
                        "Special surprise for you, {0}! Use code {2} at {1} for 10% off and enjoy your VIP benefits!"
                    }
                },
            };
            
            //#endif
        }
        
        public class Cache
        {
            public static Cache Instance => _cacheInstance.Value;
            private static readonly Lazy<Cache> _cacheInstance = new Lazy<Cache>(() => new Cache());
            private static Dictionary<string, CachedObject> _cache = new Dictionary<string, CachedObject>();
            public CachedObject Get(string key)
            {
                if (_cache.ContainsKey(key))
                {
                    return _cache[key];
                }
                return null;
            }

            public void Set(string key, CachedObject obj)
            {
                _cache[key] = obj;
            }

            public bool HasValid(string key)
            {
                return _cache.ContainsKey(key) && !_cache[key].HasExpired();
            }

            public void Clear()
            {
                _cache.Clear();
            }

            public void Remove(string key)
            {
                _cache.Remove(key);
            }
        }

        public class CachedObject
        {
            public object Value { get; private set; }
            private DateTime _expires;

            public CachedObject(object obj, int minutesValid)
            {
                Value = obj;
                _expires = DateTime.Now.AddMinutes(minutesValid);
            }

            public bool HasExpired()
            {
                return DateTime.Now > _expires;
            }
        }
        
        /** Callback type to use /information response */
        public delegate void FetchStoreInfoResponse(TebexApi.TebexStoreInfo info);

        /**
             * Returns the store's /information payload. Info is cached according to configured cache lifetime.
             */
        public void FetchStoreInfo(FetchStoreInfoResponse response)
        {
            if (Cache.Instance.HasValid("information"))
            {
                response?.Invoke((TebexApi.TebexStoreInfo)Cache.Instance.Get("information").Value);
            }
            else
            {
                TebexApi.Instance.Information((code, body) =>
                {
                    var storeInfo = JsonConvert.DeserializeObject<TebexApi.TebexStoreInfo>(body);
                    if (storeInfo == null)
                    {
                        LogError("Failed to parse fetched store information!", new Dictionary<string, string>()
                        {
                            {"response", body},
                        });
                        return;
                    }

                    Cache.Instance.Set("information", new CachedObject(storeInfo, PluginConfig.CacheLifetime));
                    response?.Invoke(storeInfo);
                });
            }
        }

        /** Callback type for response from creating checkout url */
        public delegate void CreateCheckoutUrlResponse(TebexApi.CheckoutUrlPayload checkoutUrl);

        public TebexApi.Package GetPackageByShortCodeOrId(string value)
        {
            var shortCodes = (Dictionary<String, TebexApi.Package>)Cache.Instance.Get("packageShortCodes").Value;
            if (shortCodes.ContainsKey(value))
            {
                return shortCodes[value];
            }

            // No short code found, assume it's a package ID
            var packages = (List<TebexApi.Package>)Cache.Instance.Get("packages").Value;
            foreach (var package in packages)
            {
                if (package.Id.ToString() == value)
                {
                    return package;
                }
            }

            // Package not found
            return null;
        }

        /**
             * Refreshes cached categories and packages from the Tebex API. Can be used by commands or with no arguments
             * to update the information while the server is idle.
             */
        public void RefreshListings(TebexApi.ApiSuccessCallback onSuccess = null)
        {
            // Get our categories from the /listing endpoint as it contains all category data
            TebexApi.Instance.GetListing((code, body) =>
            {
                var response = JsonConvert.DeserializeObject<TebexApi.ListingsResponse>(body);
                if (response == null)
                {
                    LogError("Could not get refresh all listings!", new Dictionary<string, string>()
                    {
                        {"response", body},
                    });
                    return;
                }

                Cache.Instance.Set("categories", new CachedObject(response.categories, PluginConfig.CacheLifetime));
                if (onSuccess != null)
                {
                    onSuccess.Invoke(code, body);    
                }
            });

            // Get our packages from a verbose get all packages call so that we always have the description
            // of the package cached.
            TebexApi.Instance.GetAllPackages(true, (code, body) =>
            {
                var response = JsonConvert.DeserializeObject<List<TebexApi.Package>>(body);
                if (response == null)
                {
                    LogError("Could not refresh package listings!", new Dictionary<string, string>()
                    {
                        {"response", body}
                    });
                    return;
                }

                Cache.Instance.Set("packages", new CachedObject(response, PluginConfig.CacheLifetime));

                // Generate and save shortcodes for each package
                var orderedPackages = response.OrderBy(package => package.Order).ToList();
                var shortCodes = new Dictionary<String, TebexApi.Package>();
                for (var i = 0; i < orderedPackages.Count; i++)
                {
                    var package = orderedPackages[i];
                    shortCodes.Add($"P{i + 1}", package);
                }

                Cache.Instance.Set("packageShortCodes", new CachedObject(shortCodes, PluginConfig.CacheLifetime));
                onSuccess?.Invoke(code, body);
            });
        }

        /** Callback type for getting all categories */
        public delegate void GetCategoriesResponse(List<TebexApi.Category> categories);

        /**
             * Gets all categories and their packages (no description) from the API. Response is cached according to the
             * configured cache lifetime.
             */
        public void GetCategories(GetCategoriesResponse onSuccess,
            TebexApi.ServerErrorCallback onServerError = null)
        {
            if (Cache.Instance.HasValid("categories"))
            {
                onSuccess.Invoke((List<TebexApi.Category>)Cache.Instance.Get("categories").Value);
            }
            else
            {
                TebexApi.Instance.GetListing((code, body) =>
                {
                    var response = JsonConvert.DeserializeObject<TebexApi.ListingsResponse>(body);
                    if (response == null)
                    {
                        onServerError?.Invoke(code, body);
                        return;
                    }

                    Cache.Instance.Set("categories", new CachedObject(response.categories, PluginConfig.CacheLifetime));
                    onSuccess.Invoke(response.categories);
                });
            }
        }

        /** Callback type for working with packages received from the API */
        public delegate void GetPackagesResponse(List<TebexApi.Package> packages);

        /** Gets all package info from API. Response is cached according to the configured cache lifetime. */
        public void GetPackages(GetPackagesResponse onSuccess,
            TebexApi.ServerErrorCallback onServerError = null)
        {
            try
            {
                if (Cache.Instance.HasValid("packages"))
                {
                    onSuccess.Invoke((List<TebexApi.Package>)Cache.Instance.Get("packages").Value);
                }
                else
                {
                    // Updates both packages and shortcodes in the cache
                    RefreshListings((code, body) =>
                    {
                        onSuccess.Invoke((List<TebexApi.Package>)Cache.Instance.Get("packages").Value);
                    });
                }
            }
            catch (Exception e)
            {
                LogError("An error occurred while getting your store's packages. " + e.Message, new Dictionary<string, string>()
                {
                    {"trace", e.StackTrace},
                    {"message", e.Message}
                });
            }
        }

        // Periodically keeps store info updated from the API
        public void RefreshStoreInformation(bool ignoreWaitCheck = false)
        {
            LogDebug("Refreshing store information...");
            if (!IsSecretKeyValidated())
            {
                LogDebug("Store key is not set or incorrect. Skipping command queue.");
                return;
            }
            
            // Calling places the information in the cache
            if (!CanProcessNextRefresh() && !ignoreWaitCheck)
            {
                LogDebug("  Skipping store info refresh - not time to be processed");
                return;
            }
            
            _nextCheckRefresh = DateTime.Now.AddMinutes(15);
            FetchStoreInfo(info =>
            {
            }); // automatically stores in the cache
        }
        
        public void ProcessJoinQueue(bool ignoreWaitCheck = false)
        {
            LogDebug("Processing player join queue...");
            if (!IsSecretKeyValidated())
            {
                LogDebug("Store key is not set or incorrect. Skipping command queue.");
                return;
            }
            
            if (!CanProcessNextJoinQueue() && !ignoreWaitCheck)
            {
                LogDebug("  Skipping join queue - not time to be processed");
                return;
            }
            
            _nextCheckJoinQueue = DateTime.Now.AddSeconds(60);
            if (_eventQueue.Count > 0)
            {
                LogDebug($"  Found {_eventQueue.Count} join events.");
                TebexApi.Instance.PlayerJoinEvent(_eventQueue, (code, body) =>
                    {
                        LogDebug("Join queue cleared successfully.");
                        _eventQueue.Clear();
                    }, error =>
                    {
                        LogError($"Could not process join queue - error response from API: {error.ErrorMessage}");
                    },
                    (code, body) =>
                    {
                        LogError("Could not process join queue - unexpected server error.", new Dictionary<string, string>()
                        {
                            {"response", body},
                            {"code", code.ToString()},
                        });
                    });
            }
            else // Empty queue
            {
                LogDebug($"  No recent join events.");
            }
        }
        
        public bool CanProcessNextCommandQueue()
        {
            return DateTime.Now > _nextCheckCommandQueue;
        }

        public bool CanProcessNextDeleteCommands()
        {
            return DateTime.Now > _nextCheckDeleteCommands;
        }
        
        public bool CanProcessNextJoinQueue()
        {
            return DateTime.Now > _nextCheckJoinQueue;
        }
        
        public bool CanProcessNextRefresh()
        {
            return DateTime.Now > _nextCheckRefresh;
        }
        
        public void ProcessCommandQueue(bool ignoreWaitCheck = false)
        {
            LogDebug("Processing command queue...");
            if (!IsSecretKeyValidated())
            {
                LogDebug("Store key is not set or incorrect. Skipping command queue.");
                return;
            }
            
            if (!CanProcessNextCommandQueue() && !ignoreWaitCheck)
            {
                var secondsToWait = (int)(_nextCheckCommandQueue - DateTime.Now).TotalSeconds;
                LogDebug($"  Tried to run command queue, but should wait another {secondsToWait} seconds.");
                return;
            }

            // Get the state of the command queue
            TebexApi.Instance.GetCommandQueue((cmdQueueCode, cmdQueueResponseBody) =>
            {
                var response = JsonConvert.DeserializeObject<TebexApi.CommandQueueResponse>(cmdQueueResponseBody);
                if (response == null)
                {
                    LogError("Failed to get command queue. Could not parse response from API.", new Dictionary<string, string>()
                    {
                        {"response", cmdQueueResponseBody},
                        {"code", cmdQueueCode.ToString()},
                    });
                    return;
                }

                // Set next available check time
                _nextCheckCommandQueue = DateTime.Now.AddSeconds(response.Meta.NextCheck);

                // Process offline commands immediately
                if (response.Meta != null && response.Meta.ExecuteOffline)
                {
                    LogDebug("Requesting offline commands from API...");
                    TebexApi.Instance.GetOfflineCommands((code, offlineCommandsBody) =>
                    {
                        var offlineCommands = JsonConvert.DeserializeObject<TebexApi.OfflineCommandsResponse>(offlineCommandsBody);
                        if (offlineCommands == null)
                        {
                            LogError("Failed to get offline commands. Could not parse response from API.", new Dictionary<string, string>()
                            {
                                {"code", code.ToString()},
                                {"responseBody", offlineCommandsBody}
                            });
                            return;
                        }

                        LogDebug($"Found {offlineCommands.Commands.Count} offline commands to execute.");
                        foreach (TebexApi.Command command in offlineCommands.Commands)
                        {
                            var parsedCommand = ExpandOfflineVariables(command.CommandToRun, command.Player);
                            var splitCommand = parsedCommand.Split(' ');
                            var commandName = splitCommand[0];
                            var args = splitCommand.Skip(1);
                            
                            LogDebug($"Executing offline command: `{parsedCommand}`");
                            ExecuteOfflineCommand(command, null, commandName, args.ToArray());
                            ExecutedCommands.Add(command);
                            LogDebug($"Executed commands queue has {ExecutedCommands.Count} commands");
                        }
                    }, (error) =>
                    {
                        LogError($"Error response from API while processing offline commands: {error.ErrorMessage}", new Dictionary<string, string>()
                        {
                            {"error",error.ErrorMessage},
                            {"errorCode", error.ErrorCode.ToString()}
                        });
                    }, (offlineComandsCode, offlineCommandsServerError) =>
                    {
                        LogError("Unexpected error response from API while processing offline commands", new Dictionary<string, string>()
                        {
                            {"code", offlineComandsCode.ToString()},
                            {"responseBody", offlineCommandsServerError}
                        });
                    });
                }
                else
                {
                    LogDebug("No offline commands to execute.");
                }

                // Process any online commands 
                LogDebug($"Found {response.Players.Count} due players in the queue");
                foreach (var duePlayer in response.Players)
                {
                    LogDebug($"Processing online commands for player {duePlayer.Name}...");
                    object playerRef = GetPlayerRef(duePlayer.UUID);
                    if (playerRef == null)
                    {
                        LogDebug($"> Player {duePlayer.Name} has online commands but is no ref found (are they connected?) Skipping.");
                        continue;
                    }
                    
                    TebexApi.Instance.GetOnlineCommands(duePlayer.Id,
                        (onlineCommandsCode, onlineCommandsResponseBody) =>
                        {
                            LogDebug(onlineCommandsResponseBody);
                            var onlineCommands =
                                JsonConvert.DeserializeObject<TebexApi.OnlineCommandsResponse>(
                                    onlineCommandsResponseBody);
                            if (onlineCommands == null)
                            { 
                                LogError($"> Failed to get online commands for ${duePlayer.Name}. Could not unmarshal response from API.", new Dictionary<string, string>()
                                {
                                    {"playerName", duePlayer.Name},
                                    {"code", onlineCommandsCode.ToString()},
                                    {"responseBody", onlineCommandsResponseBody}
                                });
                                return;
                            }

                            LogDebug($"> Processing {onlineCommands.Commands.Count} commands for this player...");
                            foreach (var command in onlineCommands.Commands)
                            {
                                var parsedCommand = ExpandUsernameVariables(command.CommandToRun, playerRef);
                                var splitCommand = parsedCommand.Split(' ');
                                var commandName = splitCommand[0];
                                var args = splitCommand.Skip(1);
                                
                                LogDebug($"Pre-execution: {parsedCommand}");
                                var success = ExecuteOnlineCommand(command, playerRef, commandName, args.ToArray());
                                LogDebug($"Post-execution: {parsedCommand}");
                                if (success)
                                {
                                    ExecutedCommands.Add(command);    
                                }
                            }
                        }, tebexError => // Error for this player's online commands
                        {
                            LogError("Failed to get due online commands due to error response from API.", new Dictionary<string, string>()
                            {
                                {"playerName", duePlayer.Name},
                                {"code", tebexError.ErrorCode.ToString()},
                                {"message", tebexError.ErrorMessage}
                            });
                        });
                }
            }, tebexError => // Error for get due players
            {
                LogError("Failed to get due players due to error response from API.", new Dictionary<string, string>()
                {
                    {"code", tebexError.ErrorCode.ToString()},
                    {"message", tebexError.ErrorMessage}
                });
            });
        }

        /**
     * Creates a checkout URL for a player to purchase the given package.
     */
        public void CreateCheckoutUrl(string playerName, TebexApi.Package package,
            CreateCheckoutUrlResponse success,
            TebexApi.ApiErrorCallback error)
        {
            TebexApi.Instance.CreateCheckoutUrl(package.Id, playerName, (code, body) =>
            {
                var responsePayload = JsonConvert.DeserializeObject<TebexApi.CheckoutUrlPayload>(body);
                if (responsePayload == null)
                {
                    return;
                }

                success?.Invoke(responsePayload);
            }, error);
        }

        public delegate void GetGiftCardsResponse(List<TebexApi.GiftCard> giftCards);

        public delegate void GetGiftCardByIdResponse(TebexApi.GiftCard giftCards);

        public void GetGiftCards(GetGiftCardsResponse success, TebexApi.ApiErrorCallback error)
        {
            //TODO
        }

        public void GetGiftCardById(GetGiftCardByIdResponse success, TebexApi.ApiErrorCallback error)
        {
            //TODO
        }

        public void BanPlayer(string playerName, string playerIp, string reason, TebexApi.ApiSuccessCallback onSuccess,
            TebexApi.ApiErrorCallback onError)
        {
            TebexApi.Instance.CreateBan(reason, playerIp, playerName, onSuccess, onError);
        }

        public void GetUser(string userId, TebexApi.ApiSuccessCallback onSuccess = null,
            TebexApi.ApiErrorCallback onApiError = null, TebexApi.ServerErrorCallback onServerError = null)
        {
            TebexApi.Instance.GetUser(userId, onSuccess, onApiError, onServerError);
        }

        public void GetActivePackagesForCustomer(string playerId, int? packageId = null, TebexApi.ApiSuccessCallback onSuccess = null,
            TebexApi.ApiErrorCallback onApiError = null, TebexApi.ServerErrorCallback onServerError = null)
        {
            TebexApi.Instance.GetActivePackagesForCustomer(playerId, packageId, onSuccess, onApiError, onServerError);
        }
        
        /**
         * Sends a message to the given player.
         */
        public abstract void ReplyPlayer(object player, string message);

        public abstract void ExecuteOfflineCommand(TebexApi.Command command, object playerObj, string commandName, string[] args);
        public abstract bool ExecuteOnlineCommand(TebexApi.Command command, object playerObj, string commandName, string[] args);
        
        public abstract bool IsPlayerOnline(string playerRefId);
        public abstract object GetPlayerRef(string playerId);

        /**
         * As we support the use of different games across the Tebex Store
         * we offer slightly different ways of getting a customer username or their ID.
         * 
         * All games support the same default variables, but some games may have additional variables.
         */
        public abstract string ExpandUsernameVariables(string input, object playerObj);

        public abstract string ExpandOfflineVariables(string input, TebexApi.PlayerInfo info);
        
        public abstract void MakeWebRequest(string endpoint, string body, TebexApi.HttpVerb verb,
            TebexApi.ApiSuccessCallback onSuccess, TebexApi.ApiErrorCallback onApiError,
            TebexApi.ServerErrorCallback onServerError);

        public bool IsSecretKeyValidated()
        {
            return _isSecretKeyValidated;
        }
        
        public void SetSecretKeyValidated(bool value)
        {
            _isSecretKeyValidated = value;
        }
    }
    public class TebexOxideAdapter : BaseTebexAdapter
    {
        public static Oxide.Plugins.TebexPlugin Plugin { get; private set; }

        public TebexOxideAdapter(Oxide.Plugins.TebexPlugin plugin)
        {
            Plugin = plugin;
        }

        public override void Init()
        {
            // Initialize timers, hooks, etc. here
            
            /*
             * NOTE: We have noticed interesting behavior with plugin timers here in that Rust attempts to "catch up"
             *  on events that it missed instead of skipping ticks in the event of sleep, lag, etc. This caused
             *  hundreds of events to fire simultaneously for our timers. To handle this we will rate limit the plugin's
             *  requests when a 429 is received.
             */
            Plugin.PluginTimers().Every(121.0f, () =>
            {
                ProcessCommandQueue(false);
            });
            Plugin.PluginTimers().Every(61.0f, () =>
            {
                DeleteExecutedCommands(false);
            });
            Plugin.PluginTimers().Every(61.0f, () =>
            {
                ProcessJoinQueue(false);
            });
            Plugin.PluginTimers().Every((60.0f * 15) + 1.0f, () =>  // Every 15 minutes for store info
            {
                RefreshStoreInformation(false);
            });
        }

        public override void LogWarning(string message, string solution)
        {
            Plugin.Warn(message);
            Plugin.Warn("- " + solution);

            if (PluginConfig.AutoReportingEnabled)
            {
                new PluginEvent(Plugin, Plugin.GetPlatform(Plugin.Server()), EnumEventLevel.WARNING, message).Send(this);
            }
        }

        public override void LogWarning(string message, string solution, Dictionary<String, String> metadata)
        {
            Plugin.Warn(message);
            Plugin.Warn("- " + solution);

            if (PluginConfig.AutoReportingEnabled)
            {
                new PluginEvent(Plugin, Plugin.GetPlatform(Plugin.Server()), EnumEventLevel.WARNING, message).WithMetadata(metadata).Send(this);
            }
        }
        
        public override void LogError(string message)
        {
            Plugin.Error(message);
            
            if (PluginConfig.AutoReportingEnabled)
            {
                new PluginEvent(Plugin, Plugin.GetPlatform(Plugin.Server()), EnumEventLevel.ERROR, message).Send(this);
            }
        }

        public override void LogError(string message, Dictionary<String, String> metadata)
        {
            Plugin.Error(message);
            if (PluginConfig.AutoReportingEnabled)
            {
                new PluginEvent(Plugin, Plugin.GetPlatform(Plugin.Server()), EnumEventLevel.ERROR, message).WithMetadata(metadata).Send(this);
            }
        }
        
        public override void LogInfo(string message)
        {
            Plugin.Info(message);
        }

        public override void LogDebug(string message)
        {
            if (PluginConfig.DebugMode)
            {
                Plugin.Error($"[DEBUG] {message}");    
            }
        }

        /**
             * Sends a web request to the Tebex API. This is just a wrapper around webrequest.Enqueue, but passes through
             * multiple callbacks that can be used to interact with each API function based on the response received.
             */
        public override void MakeWebRequest(string endpoint, string body, TebexApi.HttpVerb verb,
            TebexApi.ApiSuccessCallback onSuccess, TebexApi.ApiErrorCallback onApiError,
            TebexApi.ServerErrorCallback onServerError)
        {
            // Use Oxide request method for the webrequests call. We use HttpVerb in the api so as not to depend on
            // Oxide.
            RequestMethod method;
            Enum.TryParse<RequestMethod>(verb.ToString(), true, out method);
            if (method == null)
            {
                LogDebug($"Unknown HTTP method!: {verb.ToString()} {endpoint} | {body}");
                return;
            }

            var headers = new Dictionary<string, string>
            {
                { "X-Tebex-Secret", PluginConfig.SecretKey },
                { "Content-Type", "application/json" }
            };

            var url = endpoint;
            var logOutStr = $"-> {method.ToString()} {url} | {body}";
            
            LogDebug(logOutStr); // Write the full output entry to a debug log
            if (logOutStr.Length > 256) // Limit any sent size of an output string to 256 characters, to prevent sending too much data
            {
                logOutStr = logOutStr.Substring(0, 251) + "[...]";
            }
            
            if (IsRateLimited)
            {
                LogDebug("Skipping web request as rate limiting is enabled.");
                return;
            }
            
            Plugin.WebRequests().Enqueue(url, body, (code, response) =>
            {
                var truncatedResponse = response;
                if (truncatedResponse.Length > 256) // As above limit any data logged or sent to 256 characters
                {
                    truncatedResponse = truncatedResponse.Substring(0, 251) + "[...]";
                }
                
                var logInStr = $"{code} | '{truncatedResponse}' <- {method.ToString()} {url}";
                LogDebug(logInStr);
                
                // To prevent issues where triage events try to be reported due to server issues on the triage API itself,
                //   handle any triage response callbacks here
                if (url.Contains(TebexApi.TebexTriageUrl))
                {
                    try
                    {
                        switch (code)
                        {
                            case 200:
                            case 201:
                            case 202:
                            case 204:
                                onSuccess?.Invoke(code, response);
                                return;
                            case 400:
                                onServerError?.Invoke(code, response);
                                return;
                            case 500:
                                onServerError?.Invoke(code, response);
                                return;
                            default:
                                LogDebug($"Unexpected response code from plugin logs API: {code}");
                                return;
                        }                        
                    }
                    catch (Exception e)
                    {
                        LogDebug($"Failed to handle automatic error log request: {e.Message}");
                        LogDebug(e.ToString());
                        return;
                    }
                }
                
                // We should never have an HTML response passed to callback functions which might assume is JSON
                if (body.Contains("DOCTYPE html") || body.StartsWith("<html"))
                {
                    
                    LogDebug("> Unexpected html response from web request!");
                    return;
                }
                
                if (code == 200 || code == 201 || code == 202 || code == 204)
                {
                    onSuccess?.Invoke(code, response);
                }
                else if (code == 403) // Admins get a secret key warning on any command that's rejected
                {
                    if (url.Contains(TebexApi.TebexApiBase))
                    {
                        LogWarning("403 Forbidden from Tebex API: " + url, "Double check that your secret key is valid. Use /tebex.secret <key> to set your secret key.");
                    }
                }
                else if (code == 429) // Rate limited
                {
                    // Rate limits sent from Tebex enforce a 5 minute cooldown.
                    LogInfo("We are being rate limited by Tebex API. Requests will resume after 5 minutes.");
                    Plugin.PluginTimers().Once(60 * 5, () =>
                    {
                        LogDebug("Rate limit timer has elapsed.");
                        IsRateLimited = false;
                    });
                }
                else if (code == 500)
                {
                    LogError("Internal Server Error from Tebex API. " + response, new Dictionary<string, string>()
                    {
                        {"response", response}
                    });
                    onServerError?.Invoke(code, response);
                }
                else if (code == 530) // Cloudflare origin error
                {
                    LogDebug("CDN reported error code, web request not completed: " + code);
                    LogDebug(response);
                    onServerError?.Invoke(code, response);
                }
                else if (code == 0)
                {
                    LogWarning("Request timeout to plugin API", "Please try again. Automated requests will re-run at the next command check.", new Dictionary<string, string>
                    {
                        { "request", logOutStr },
                        { "response", logInStr },
                    });
                }
                else // This should be a general failure error message with a JSON-formatted response from the API.
                {
                    try
                    {
                        var error = JsonConvert.DeserializeObject<TebexApi.TebexError>(response);
                        if (error != null)
                        {
                            LogError("API request failed: " + error.ErrorMessage, new Dictionary<string, string>
                            {
                                { "request", logOutStr },
                                { "response", response },
                                { "error", error.ErrorMessage },
                            });
                            onApiError?.Invoke(error);
                        }
                        else
                        {
                            LogError("Plugin API error could not be interpreted!", new Dictionary<string, string>
                                {
                                    { "request", logOutStr },
                                    { "response", response },
                                });
                            onServerError?.Invoke(code, response);
                        }

                        LogDebug($"Request to {url} failed with code {code}.");
                        LogDebug(response);
                    }
                    catch (Exception e) // Something really unexpected with our response and it's likely not JSON
                    {
                        LogError("Did not handle error response from API", new Dictionary<string, string>
                        {
                            { "request", logOutStr },
                            { "response", logInStr },
                        });
                        
                        LogDebug("Could not gracefully handle error response.");
                        LogDebug($"Response from remote {response}");
                        LogDebug(e.ToString());

                        // Try to allow server error callbacks to be processed, but they may assume the body contains
                        // parseable json when it doesn't.
                        try
                        {
                            onServerError?.Invoke(code, $"{e.Message}: {response}");    
                        }
                        catch (JsonReaderException jsonException)
                        {
                            LogDebug($"Could not parse response from remote as JSON. {jsonException.Message}: {response}");
                        }
                    }
                }
            }, Plugin, method, headers, 10.0f);
        }

        public override void ReplyPlayer(object player, string message)
        {
            var playerInstance = player as IPlayer;
            if (playerInstance != null)
            {
                playerInstance.Reply("{0}", "", message);
            }
        }

        public override void ExecuteOfflineCommand(TebexApi.Command command, object player, string commandName, string[] args)
        {
            if (command.Conditions.Delay > 0)
            {
                // Command requires a delay, use built-in plugin timer to wait until callback
                // in order to respect game threads
                Plugin.PluginTimers().Once(command.Conditions.Delay,
                    () =>
                    {
                        ExecuteServerCommand(command, player as IPlayer, commandName, args);
                    });
            }
            else // No delay, execute immediately
            {
                ExecuteServerCommand(command, player as IPlayer, commandName, args);
            }
        }

        private void ExecuteServerCommand(TebexApi.Command command, IPlayer player, string commandName, string[] args)
        {
            // For the say command, don't pass args or they will all get quoted in chat.
            if (commandName.Equals("chat.add") && args.Length >= 2 && player != null && args[0].ToString().Equals(player.Id))
            {
                var message = string.Join(" ", args.Skip(2));
                
                // Remove leading and trailing quotes if present
                if (message.StartsWith('"'))
                {
                    message = message.Substring(1, message.Length - 1);
                }

                if (message.EndsWith('"'))
                {
                    message = message.Substring(0, message.Length - 1);
                }
                
                player.Message(message);
                return;
            }

            var fullCommand = $"{commandName} {string.Join(" ", args)}";
            Plugin.Server().Command(fullCommand);
        }
        
        public override bool IsPlayerOnline(string playerRefId)
        {
            // Get a reference to the in-game player instance
            IPlayer iPlayer = GetPlayerRef(playerRefId) as IPlayer;
            if (iPlayer == null) // Player is not connected
            {
                return false;
            }

            // IsConnected might indicate just a connection to the server, but unknown if it's possible to have an IPlayer
            // reference and for the player to not actually be connected. This would create a case where we can't
            // check inventory slots prior to package delivery.
            return iPlayer.IsConnected;
        }

        public override object GetPlayerRef(string playerId)
        {
            return Plugin.PlayerManager().FindPlayer(playerId);
        }

        public override bool ExecuteOnlineCommand(TebexApi.Command command, object playerObj, string commandName,
            string[] args)
        {
            try
            {
                if (command.Conditions.Slots > 0)
                {
                    #if RUST
                    // Cast down to the base player in order to get inventory slots available.
                    var player = playerObj as Oxide.Game.Rust.Libraries.Covalence.RustPlayer;
                    BasePlayer basePlayer = player.Object as BasePlayer;
                    var slotsAvailable = basePlayer.inventory.containerMain.capacity - basePlayer.inventory.containerMain.itemList.Count;                    
                    LogDebug($"Detected {slotsAvailable} slots in main inventory where command wants {command.Conditions.Slots}");
                    
                    // Some commands have slot requirements, don't execute those if the player can't accept it
                    if (slotsAvailable < command.Conditions.Slots)
                    {
                        LogWarning($"> Player has command {command.CommandToRun} but not enough main inventory slots.", "Need {command.Conditions.Slots} empty slots.");
                        return false;
                    }
                    #else
                    LogWarning($"> Command has slots condition, but slots are not supported in this game.", "Remove the slots condition to suppress this message.");
                    #endif
                }
                
                if (command.Conditions.Delay > 0)
                {
                    // Command requires a delay, use built-in plugin timer to wait until callback
                    // in order to respect game threads
                    Plugin.PluginTimers().Once(command.Conditions.Delay,
                        () =>
                        {
                            ExecuteServerCommand(command, playerObj as IPlayer, commandName, args);
                        });
                }
                else
                {
                    ExecuteServerCommand(command, playerObj as IPlayer, commandName, args);    
                }
            }
            catch (Exception e)
            {
                LogError("Caused exception while executing online command", new Dictionary<string, string>()
                {
                    {"command", command.CommandToRun},
                    {"exception", e.Message},
                    {"trace", e.StackTrace},
                });
                return false;
            }
            
            return true;
        }

        public override string ExpandOfflineVariables(string input, TebexApi.PlayerInfo info)
        {
            string parsed = input;
            parsed = parsed.Replace("{id}", info.Uuid); // In offline commands there is a "UUID" param for the steam ID, and this ID is an internal plugin ID
            parsed = parsed.Replace("{username}", info.Username);
            parsed = parsed.Replace("{name}", info.Username);

            if (parsed.Contains("{") || parsed.Contains("}"))
            {
                LogDebug($"Detected lingering curly braces after expanding offline variables!");
                LogDebug($"Input: {input}");
                LogDebug($"Parsed: {parsed}");
            }

            return parsed;
        }

        public override string ExpandUsernameVariables(string input, object playerObj)
        {
            IPlayer iPlayer = playerObj as IPlayer;
            if (iPlayer == null)
            {
                LogError($"Could not cast player instance when expanding username variables: {playerObj}", new Dictionary<string, string>
                {
                    {"input", input},
                    {"playerObj", playerObj?.ToString()},
                });
                return input;
            }

            if (input.Contains("{username}") && string.IsNullOrEmpty(iPlayer.Name))
            {
                LogError("Player ID is null while expanding username?!: ", new Dictionary<string, string>
                {
                    {"input", input},
                    {"iPlayer.Id", iPlayer.Id},
                    {"iPlayer.Name", iPlayer.Name}
                });
                return input;
            }

            string parsed = input;
            parsed = parsed.Replace("{id}", iPlayer.Id);
            parsed = parsed.Replace("{username}", iPlayer.Name);
            parsed = parsed.Replace("{name}", iPlayer.Name);

            if (parsed.Contains("{") || parsed.Contains("}"))
            {
                LogDebug($"Detected lingering curly braces after expanding username variables!");
                LogDebug($"Input: {input}");
                LogDebug($"Parsed: {parsed}");
            }

            return parsed;
        }
    }
    public enum EnumEventLevel
    {
        INFO,
        WARNING,
        ERROR
    }

    public class PluginEvent
    {
        // Data attached to all plugin events, set via Init()
        public static string SERVER_IP = "";
        public static string SERVER_ID = "";
        public static string STORE_URL = "";
        public static bool IS_DISABLED = false;

        [JsonProperty("game_id")] private string GameId { get; set; }
        [JsonProperty("framework_id")] private string FrameworkId { get; set; }
        [JsonProperty("runtime_version")] private string RuntimeVersion { get; set; }

        [JsonProperty("framework_version")]
        private string FrameworkVersion { get; set; }

        [JsonProperty("plugin_version")] private string PluginVersion { get; set; }
        [JsonProperty("server_id")] private string ServerId { get; set; }
        [JsonProperty("event_message")] private string EventMessage { get; set; }
        [JsonProperty("event_level")] private String EventLevel { get; set; }
        [JsonProperty("metadata")] private Dictionary<string, string> Metadata { get; set; }
        [JsonProperty("trace")] private string Trace { get; set; }

        [JsonProperty("store_url")] private string StoreUrl { get; set; }
        
        [JsonProperty("server_ip")] private string ServerIp { get; set; }

        [JsonIgnore]
        public TebexPlatform platform;
        
        private TebexPlugin _plugin;
        
        public PluginEvent(TebexPlugin plugin, TebexPlatform platform, EnumEventLevel level, string message)
        {
            _plugin = plugin;
            platform = platform;

            TebexTelemetry tel = platform.GetTelemetry();

            GameId = platform.GetGameId();
            FrameworkId = tel.GetServerSoftware(); // Oxide / Carbon
            RuntimeVersion = tel.GetRuntimeVersion(); // version of Rust
            FrameworkVersion = tel.GetServerVersion(); // version of Oxide
            PluginVersion = platform.GetPluginVersion(); // version of plugin
            EventLevel = level.ToString();
            EventMessage = message;
            Trace = "";
            ServerIp = PluginEvent.SERVER_IP;
            ServerId = PluginEvent.SERVER_ID;
            StoreUrl = PluginEvent.STORE_URL;
        }

        public PluginEvent WithTrace(string trace)
        {
            Trace = trace;
            return this;
        }

        public PluginEvent WithMetadata(Dictionary<string, string> metadata)
        {
            Metadata = metadata;
            return this;
        }

        public void Send(BaseTebexAdapter adapter)
        {
            if (IS_DISABLED)
            {
                return;
            }

            List<PluginEvent> eventsList = new List<PluginEvent>(); //TODO
            eventsList.Add(this);
            adapter.MakeWebRequest("https://plugin-logs.tebex.io/events", JsonConvert.SerializeObject(eventsList), TebexApi.HttpVerb.POST,
                (code, body) =>
                {
                    if (code < 300 && code > 199) // success
                    {
                        adapter.LogDebug("Successfully sent plugin events");
                        return;
                    }
                    
                    adapter.LogDebug("Failed to send plugin logs. Unexpected response code: " + code);
                    adapter.LogDebug(body);
                }, (pluginLogsApiError) =>
                {
                    adapter.LogDebug("Failed to send plugin logs. Unexpected Tebex API error: " + pluginLogsApiError);
                }, (pluginLogsServerErrorCode, pluginLogsServerErrorResponse) =>
                {
                    adapter.LogDebug("Failed to send plugin logs. Unexpected server error: " + pluginLogsServerErrorResponse);
                });
        }
    }
    public class TebexTelemetry
    {
        private string _serverSoftware;
        private string _serverVersion;
        private string _runtimeVersion;

        public TebexTelemetry(String serverSoftware, String serverVersion, String runtimeVersion)
        {
            _serverSoftware = serverSoftware;
            _serverVersion = serverVersion;
            _runtimeVersion = runtimeVersion;
        }
    
        public string GetServerSoftware()
        {
            return _serverSoftware;
        }

        public string GetRuntimeVersion()
        {
            return _runtimeVersion;
        }

        public string GetServerVersion()
        {
            return _serverVersion;
        }
    }   
    public class TebexApi
    {
        public static readonly string TebexApiBase = "https://plugin.tebex.io/";
        public static readonly string TebexTriageUrl = "https://plugin-logs.tebex.io/";
        
        public static TebexApi Instance => _apiInstance.Value;
        public static BaseTebexAdapter Adapter { get; private set; }

        // Singleton instance for the API
        private static readonly Lazy<TebexApi> _apiInstance = new Lazy<TebexApi>(() => new TebexApi());

        public TebexApi()
        {
        }

        public void InitAdapter(BaseTebexAdapter adapter)
        {
            Adapter = adapter;
            adapter.Init();
        }
        
        // Used so that we don't depend on Oxide
        public enum HttpVerb
        {
            DELETE,
            GET,
            PATCH,
            POST,
            PUT,
        }

        public delegate void ApiSuccessCallback(int code, string body);

        public delegate void ApiErrorCallback(TebexError error);

        public delegate void ServerErrorCallback(int code, string body);

        public class TebexError
        {
            [JsonProperty("error_code")] public int ErrorCode { get; set; }
            [JsonProperty("error_message")] public string ErrorMessage { get; set; } = "";
        }

        private static void Send(string endpoint, string body, HttpVerb method = HttpVerb.GET,
            ApiSuccessCallback onSuccess = null, ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Adapter.MakeWebRequest(TebexApiBase + endpoint, body, method, onSuccess, onApiError, onServerError);
        }

        #region Events
        
        public class TebexJoinEventInfo
        {
            [JsonProperty("username_id")] /* steam64ID */
            public string UsernameId { get; private set; }
            [JsonProperty("event_type")]
            public string EventType { get; private set; }
            [JsonProperty("event_date")]
            public DateTime EventDate { get; private set; }
            [JsonProperty("ip")]
            public string IpAddress { get; private set; }

            public TebexJoinEventInfo(string usernameId, string eventType, DateTime eventDate, string ipAddress)
            {
                UsernameId = usernameId;
                EventType = eventType;
                EventDate = eventDate;
                IpAddress = AnonymizeIp(ipAddress);
            }
        }
        
        public static string AnonymizeIp(string ipIn)
        {
            int lastOctetStart = ipIn.LastIndexOf('.');
            if (lastOctetStart < 0)
            {
                return ipIn;
            }
            
            return ipIn.Substring(0, lastOctetStart) + ".x";
        }
        
        public void PlayerJoinEvent(List<TebexJoinEventInfo> events, ApiSuccessCallback onSuccess, ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Send("events", JsonConvert.SerializeObject(events), HttpVerb.POST, onSuccess, onApiError,
                onServerError);
        }
        
        #endregion
        
        #region Information

        public class TebexAccountInfo
        {
            [JsonProperty("id")] public int Id { get; set; }
            [JsonProperty("domain")] public string Domain { get; set; } = "";
            [JsonProperty("name")] public string Name { get; set; } = "";
            [JsonProperty("currency")] public TebexCurrency Currency { get; set; }
            [JsonProperty("online_mode")] public bool OnlineMode { get; set; }
            [JsonProperty("game_type")] public string GameType { get; set; } = "";
            [JsonProperty("log_events")] public bool LogEvents { get; set; }
        }

        public class TebexCurrency
        {
            [JsonProperty("iso_4217")] public string Iso4217 { get; set; } = "";
            [JsonProperty("symbol")] public string Symbol { get; set; } = "";
        }

        public class TebexServerInfo
        {
            [JsonProperty("id")] public int Id { get; set; }
            [JsonProperty("name")] public string Name { get; set; } = "";
        }

        public class TebexStoreInfo
        {
            [JsonProperty("account")] public TebexAccountInfo AccountInfo { get; set; }
            [JsonProperty("server")] public TebexServerInfo ServerInfo { get; set; }
        }

        public class Category
        {
            [JsonProperty("id")] public int Id { get; set; }
            [JsonProperty("order")] public int Order { get; set; }
            [JsonProperty("name")] public string Name { get; set; } = "";
            [JsonProperty("only_subcategories")] public bool OnlySubcategories { get; set; }
            [JsonProperty("subcategories")] public List<Category> Subcategories { get; set; }
            [JsonProperty("packages")] public List<Package> Packages { get; set; }
            [JsonProperty("gui_item")] public object GuiItem { get; set; }
        }

        public class PackageSaleData
        {
            [JsonProperty("active")] public bool Active { get; set; }
            [JsonProperty("discount")] public double Discount { get; set; }
        }

        public class Package
        {
            [JsonProperty("id")] public int Id { get; set; }

            [JsonProperty("name")] public string Name { get; set; } = "";

            [JsonProperty("order")] public string Order { get; set; } = "";

            [JsonProperty("image")] public string Image { get; set; }

            [JsonProperty("price")] public double Price { get; set; }

            [JsonProperty("sale")] public PackageSaleData Sale { get; set; }

            [JsonProperty("expiry_length")] public int ExpiryLength { get; set; }

            [JsonProperty("expiry_period")] public string ExpiryPeriod { get; set; } = "";

            [JsonProperty("type")] public string Type { get; set; } = "";

            [JsonProperty("category")] public Category Category { get; set; }

            [JsonProperty("global_limit")] public int GlobalLimit { get; set; }

            [JsonProperty("global_limit_period")] public string GlobalLimitPeriod { get; set; } = "";

            [JsonProperty("user_limit")] public int UserLimit { get; set; }

            [JsonProperty("user_limit_period")] public string UserLimitPeriod { get; set; } = "";

            [JsonProperty("servers")] public List<TebexServerInfo> Servers { get; set; }

            [JsonProperty("required_packages")] public List<object> RequiredPackages { get; set; } //TODO

            [JsonProperty("require_any")] public bool RequireAny { get; set; }

            [JsonProperty("create_giftcard")] public bool CreateGiftcard { get; set; }

            [JsonProperty("show_until")] public string ShowUntil { get; set; }

            [JsonProperty("gui_item")] public string GuiItem { get; set; } = "";

            [JsonProperty("disabled")] public bool Disabled { get; set; }

            [JsonProperty("disable_quantity")] public bool DisableQuantity { get; set; }

            [JsonProperty("custom_price")] public bool CustomPrice { get; set; }

            [JsonProperty("choose_server")] public bool ChooseServer { get; set; }

            [JsonProperty("limit_expires")] public bool LimitExpires { get; set; }

            [JsonProperty("inherit_commands")] public bool InheritCommands { get; set; }

            [JsonProperty("variable_giftcard")] public bool VariableGiftcard { get; set; }

            // Description is not provided unless verbose=true is passed to the Packages endpoint
            [JsonProperty("description")] public string Description { get; set; } = "";

            public string GetFriendlyPayFrequency()
            {
                switch (Type)
                {
                    case "single": return "One-Time";
                    case "subscription": return $"Each {ExpiryLength} {ExpiryPeriod}";
                    default: return "???";
                }
            }
        }

        // Data returned when sending a package to /checkout
        public class CheckoutUrlPayload
        {
            [JsonProperty("url")] public string Url { get; set; } = "";
            [JsonProperty("expires")] public string Expires { get; set; } = "";
        }

        public delegate void Callback(int code, string body);

        public void Information(ApiSuccessCallback success, ApiErrorCallback error = null)
        {
            Send("information", "", HttpVerb.GET, success, error);
        }

        #endregion

        #region Command Queue

        /**
             * Response received from /queue
             */
        public class CommandQueueResponse
        {
            [JsonProperty("meta")] public CommandQueueMeta Meta { get; set; }
            [JsonProperty("players")] public List<DuePlayer> Players { get; set; }
        }

        /**
             * Metadata received from /queue
             */
        public class CommandQueueMeta
        {
            [JsonProperty("execute_offline")] public bool ExecuteOffline { get; set; }

            [JsonProperty("next_check")] public int NextCheck { get; set; }

            [JsonProperty("more")] public bool More { get; set; }
        }

        /**
             * A due player is one returned by /queue to indicate we have some commands to run.
             */
        public class DuePlayer
        {
            [JsonProperty("id")] public int Id { get; set; }

            [JsonProperty("name")] public string Name { get; set; } = "";

            [JsonProperty("uuid")] public string UUID { get; set; } = "";
        }


        /**
             * The response recieved from /queue/online-commands
             */
        public class OnlineCommandsResponse
        {
            [JsonProperty("player")] public OnlineCommandsPlayer Player { get; set; }
            [JsonProperty("commands")] public List<Command> Commands { get; set; }
        }

        public class OnlineCommandsPlayer
        {
            [JsonProperty("id")] public string Id { get; set; }
            [JsonProperty("username")] public string Username { get; set; }
            [JsonProperty("meta")] public OnlineCommandPlayerMeta Meta { get; set; }
        }

        public class OnlineCommandPlayerMeta
        {
            [JsonProperty("avatar")] public string Avatar { get; set; } = "";
            [JsonProperty("avatarfull")] public string AvatarFull { get; set; } = "";
            [JsonProperty("steamID")] public string SteamId { get; set; } = "";
        }

        public class CommandConditions
        {
            [JsonProperty("delay")] public int Delay { get; set;  }
            [JsonProperty("slots")] public int Slots { get; set; }
        }

        public class OfflineCommandsMeta
        {
            [JsonProperty("limited")] public string Limited { get; set; }
        }
        public class OfflineCommandsResponse
        {
            [JsonProperty("meta")] public OfflineCommandsMeta Meta { get; set;  }
            [JsonProperty("commands")] public List<Command> Commands { get; set;  }
        }
        public class Command
        {
            [JsonProperty("id")] public int Id { get; set; }
            [JsonProperty("command")] public string CommandToRun { get; set; } = "";
            [JsonProperty("payment", NullValueHandling=NullValueHandling.Ignore)] public long Payment { get; set; }
            [JsonProperty("package", NullValueHandling=NullValueHandling.Ignore)] public long PackageRef { get; set; }
            [JsonProperty("conditions")] public CommandConditions Conditions { get; set; } = new CommandConditions();
            [JsonProperty("player")] public PlayerInfo Player { get; set; }
        }

        /**
             * List the players who have commands due to be executed when they next login to the game server.
             * This endpoint also returns any offline commands to be processed and the amount of seconds to wait before performing the queue check again.
             * All clients should strictly follow the response of `next_check`, failure to do so would result in your secret key being revoked or IP address being banned from accessing the API.
             */
        public void GetCommandQueue(ApiSuccessCallback onSuccess = null, ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Send("queue", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        /**
             * Gets commands that can be executed on the player even if they are offline.
             */
        public void GetOfflineCommands(ApiSuccessCallback onSuccess = null, ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Send($"queue/offline-commands", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        /**
             * Gets commands that can be executed for the given player if they are online.
             */
        public void GetOnlineCommands(int playerId, ApiSuccessCallback onSuccess, ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Send($"queue/online-commands/{playerId}", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        private class DeleteCommandsPayload
        {
            /**
                 * An array of one or more command IDs to delete.
                 */
            [JsonProperty("ids")]
            public int[] Ids { get; set; }
        }

        /**
             * Deletes one or more commands that have been executed on the game server.
             * An empty response with the status code of 204 No Content will be returned on completion.
             */
        public void DeleteCommands(int[] ids, ApiSuccessCallback onSuccess, ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            var payload = new DeleteCommandsPayload
            {
                Ids = ids
            };
            Send("queue", JsonConvert.SerializeObject(payload), HttpVerb.DELETE, onSuccess, onApiError,
                onServerError);
        }

        #endregion

        #region Listing

        /**
             * Response from /listing containing the categories and their packages.
             */
        public class ListingsResponse
        {
            [JsonProperty("categories")] public List<Category> categories { get; set; }
        }

        /**
             * Get the categories and packages which should be displayed to players in game. The returned order of this endpoint
             * does not reflect the desired order of the category/packages - please order based on the order object.
             */
        public void GetListing(ApiSuccessCallback onSuccess = null, ApiErrorCallback onError = null,
            ServerErrorCallback onServerError = null)
        {
            Send("listing", "", HttpVerb.GET, onSuccess, onError, onServerError);
        }

        #endregion

        #region Packages

        /**
             * Get a list of all packages on the webstore. Pass verbose=true to include descriptions of the packages.
             * API returns a list of JSON encoded Packages.
             */
        public void GetAllPackages(bool verbose, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Send(verbose ? "packages?verbose=true" : "packages", "", HttpVerb.GET, onSuccess, onApiError,
                onServerError);
        }

        /**
             * Gets a specific package from the webstore by its ID. Returns JSON-encoded Package object.
             */
        public void GetPackage(string packageId, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Send($"package/{packageId}", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        /*
        // Updates a package on the webstore.
        public void UpdatePackage(string packageId, Package package, ApiSuccessCallback onSuccess = null, ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
        {
            //NOOP
        }
        */

        #endregion

        #region Community Goals

        // Retrieves all community goals from the account.
        public void GetCommunityGoals(ApiSuccessCallback onSuccess = null, ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Send("community_goals", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        // Retrieves a specific community goal.
        public void GetCommunityGoal(int goalId, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Send($"community_goals/{goalId}", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        #endregion

        #region Payments

        /** Payload for /payments to retrieve all payments with quantity limit */
        public class PaymentsPayload
        {
            [JsonProperty("limit")] public int Limit { get; set; } = 100;
        }

        /**
             * Retrieve the latest payments (up to a maximum of 100) made on the webstore.
             */
        public void GetAllPayments(int limit = 100, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
        {
            var payload = new PaymentsPayload
            {
                Limit = limit
            };

            if (limit > 100)
            {
                limit = 100;
            }

            Send($"payments", JsonConvert.SerializeObject(payload), HttpVerb.GET, onSuccess, onApiError,
                onServerError);
        }

        /**
             * Return all payments as a page, at the given page number.
             */
        public void GetAllPaymentsPaginated(int pageNumber, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
        {
            Send($"payments?paged={pageNumber}", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        /**
             * Retrieve a specific payment by transaction id.
             */
        public void GetPayment(string transactionId, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
        {
            Send($"payments/{transactionId}", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        /**
            // Returns an array of fields (custom variables, etc) required to be entered for a manual payment to be created for a package.
            public void GetRequiredPaymentFields(Package package)
            {
                //var response = client.SendAsyncRequest($"payments/fields/{package.Id}", HttpMethod.Get);
            }
            
              //Create a manual payment in the same way as is possible from the control panel. One or more packages should be added to the payment,
              //and the package commands will be processed in the same way as would be for a standard manual payment.
                public void CreatePayment()
                {
                    Send($"payments", HttpMethod.Post);
                }

                // Updates a payment
                public void UpdatePayment(string transactionId)
                {
                   Send($"payments/{transactionId}", HttpMethod.Put);
                }

                // Create a note against a payment.
                public void CreatePaymentNote(string transactionId, string note)
                {
                   Send($"payments/{transactionId}/note", HttpMethod.Post);
                }
            */

        #endregion

        #region Checkout

        private class CreateCheckoutPayload
        {
            [JsonProperty("package_id")] public int PackageId { get; set; }

            [JsonProperty("username")] public string Username { get; set; } = "";
        }

        /**
             * Creates a URL which will take the player to a checkout area in order to purchase the given item.
             */
        public void CreateCheckoutUrl(int packageId, string username, ApiSuccessCallback success,
            ApiErrorCallback error = null)
        {
            var payload = new CreateCheckoutPayload
            {
                PackageId = packageId,
                Username = username
            };

            Send("checkout", JsonConvert.SerializeObject(payload), HttpVerb.POST, success, error);
        }

        #endregion

        #region Gift Cards

        public class GiftCard
        {
            //TODO            
        }

        public void GetAllGiftCards(ApiSuccessCallback onSuccess = null, ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Send("gift-cards", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        public void GetGiftCard(string giftCardId, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
        {
            Send($"gift-cards/{giftCardId}", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        public class CreateGiftCardPayload
        {
            [JsonProperty("expires_at")] public string ExpiresAt { get; set; } = "";
            [JsonProperty("note")] public string Note { get; set; } = "";
            [JsonProperty("amount")] public double Amount { get; set; }
        }

        public void CreateGiftCard(string expiresAt, string note, int amount, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
        {
            var payload = new CreateGiftCardPayload
            {
                ExpiresAt = expiresAt,
                Note = note,
                Amount = amount
            };
            Send("gift-cards", JsonConvert.SerializeObject(payload), HttpVerb.POST, onSuccess, onApiError,
                onServerError);
        }

        public void VoidGiftCard(string giftCardId, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
        {
            Send($"gift-cards/{giftCardId}", "", HttpVerb.DELETE, onSuccess, onApiError, onServerError);
        }

        public class TopUpGiftCardPayload
        {
            [JsonProperty("amount")] public string Amount { get; set; } = "";
        }

        public void TopUpGiftCard(string giftCardId, double amount, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
        {
            var payload = new TopUpGiftCardPayload
            {
                Amount = $"{amount}"
            };
            Send($"gift-cards/{giftCardId}", JsonConvert.SerializeObject(payload), HttpVerb.PUT);
        }

        #endregion

        #region Coupons

        public void GetAllCoupons(ApiSuccessCallback onSuccess = null, ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Send("coupons", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        public void GetCouponById(string couponId, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
        {
            Send($"coupons/{couponId}", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        /**
            public void CreateCoupon(ApiSuccessCallback onSuccess = null, ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
            {
                Send("coupons", HttpMethod.Post);
            }

            public void DeleteCoupon(string couponId, ApiSuccessCallback onSuccess = null, ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
            {
               Send($"gift-cards/{couponId}", HttpMethod.Delete);
            }*/

        #endregion

        #region Bans

        public void GetAllBans(ApiSuccessCallback onSuccess = null, ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            //var response = client.SendAsyncRequest("bans", HttpMethod.Get);
            Send("bans", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        public class CreateBanPayload
        {
            [JsonProperty("reason")] public string Reason { get; set; }
            [JsonProperty("ip")] public string IP { get; set; }

            /** Username or UUID of the player to ban */
            [JsonProperty("user")]
            public string User { get; set; }
        }

        public void CreateBan(string reason, string ip, string userId, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
        {
            var payload = new CreateBanPayload
            {
                Reason = reason,
                IP = ip,
                User = userId
            };
            Send("bans", JsonConvert.SerializeObject(payload), HttpVerb.POST, onSuccess, onApiError,
                onServerError);
        }

        #endregion

        #region Sales

        public void GetAllSales(ApiSuccessCallback onSuccess = null, ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Send("sales", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        #endregion

        #region Player Lookup

        /**
             * Root object returned by the /user endpoint, containing PlayerInfo
             */
        public class UserInfoResponse
        {
            [JsonProperty("player")] public PlayerInfo Player { get; set; }

            [JsonProperty("banCount")] public int BanCount { get; set; }

            [JsonProperty("chargebackRate")] public int ChargebackRate { get; set; }

            [JsonProperty("payments")] public List<PaymentInfo> Payments { get; set; }

            [JsonProperty("purchaseTotals")] public object[] PurchaseTotals { get; set; }
        }

        public class PaymentInfo
        {
            [JsonProperty("txn_id")] public string TransactionId { get; set; }

            [JsonProperty("time")] public long Time { get; set; }

            [JsonProperty("price")] public double Price { get; set; }

            [JsonProperty("currency")] public string Currency { get; set; }

            [JsonProperty("status")] public int Status { get; set; }
        }

        /**
             * A player's information returned by the /user endpoint
             */
        public class PlayerInfo
        {
            [JsonProperty("id")] public string Id { get; set; }

            //FIXME sometimes referred to as `name` or `username` alternatively?
            [JsonProperty("name")] public string Username { get; set; }

            [JsonProperty("meta")] public OnlineCommandPlayerMeta Meta { get; set; }

            /** Only populated by offline commands */
            [JsonProperty("uuid")]
            public string Uuid { get; set; } = "";
            
            [JsonProperty("plugin_username_id")] public int PluginUsernameId { get; set; }
        }

        public void GetUser(string targetUserId, ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null,
            ServerErrorCallback onServerError = null)
        {
            Send($"user/{targetUserId}", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
        }

        #endregion

        #region Customer Purchases

        public class PackagePurchaseInfo
        {
            [JsonProperty("id")]
            public int Id { get; set; }

            [JsonProperty("name")]
            public string Name { get; set; }
        }

        public class CustomerPackagePurchaseRecord
        {
            [JsonProperty("txn_id")]
            public string TransactionId { get; set; }

            [JsonProperty("date")]
            public DateTime Date { get; set; }

            [JsonProperty("quantity")]
            public int Quantity { get; set; }

            [JsonProperty("package")]
            public PackagePurchaseInfo Package { get; set; }
        }
        
        // Return a list of all active (non-expired) packages that a customer has purchased.
        // If packageId is provided, filter down to a single package ID, if you want to check if a specific package has been purchased. 
        public void GetActivePackagesForCustomer(string userId, int? packageId = null,
            ApiSuccessCallback onSuccess = null,
            ApiErrorCallback onApiError = null, ServerErrorCallback onServerError = null)
        {
            if (packageId == null)
            {
                Send($"player/{userId}/packages", "", HttpVerb.GET, onSuccess, onApiError, onServerError);
            }
            else
            {
                Send($"player/{userId}/packages?package={packageId}", "", HttpVerb.GET, onSuccess, onApiError,
                    onServerError);
            }
        }

        #endregion
    }
    public class TebexPlatform
    {
        private String _gameId;
        private String _pluginVersion;
        private TebexTelemetry _telemetry;
        
        public TebexPlatform(String gameId, String pluginVersion, TebexTelemetry _telemetry)
        {
            this._pluginVersion = pluginVersion;
            this._telemetry = _telemetry;
            this._gameId = gameId;
        }
    
        public TebexTelemetry GetTelemetry()
        {
            return _telemetry;
        }

        public string GetPluginVersion()
        {
            return _pluginVersion;
        }

        public string GetGameId()
        {
            return _gameId;
        }
    }    
	}


// --- End of file: TebexPlugin.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/temporary-barricades ---
// --- Original File Path: T/TemporaryBarricades/TemporaryBarricades.cs ---

﻿using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
namespace Oxide.Plugins
{
    [Info("Temporary Barricades", "Norn", "0.0.4")]
    [Description("Remove defensive barricades after a set time")]
    public class TemporaryBarricades : RustPlugin
    {
        private void Init()
        {
            Puts($"Loaded {config.barricadePrefabs.Count.ToString()} barricade prefabs.");
            Puts($"Removing entities after {config.removeAfter.ToString()} seconds.");
            if(config.debugMode) { PrintWarning("Debug mode is active."); }
        }

        private ConfigFile config;
        public class ConfigFile
        {
            [JsonProperty(PropertyName = "BarricadePrefabs")]
            public List<string> barricadePrefabs;

            [JsonProperty(PropertyName = "RemoveAfter")]
            public int removeAfter;

            [JsonProperty(PropertyName = "DebugMode")]
            public bool debugMode;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                    removeAfter = 1800,
                    debugMode = false,
                    barricadePrefabs = new List<string>
                    {
                        "wall.external.high.stone",
                        "wall.external.high.wood",
                        "barricade.stone",
                        "barricade.sandbags",
                        "barricade.concrete"
                    }
                };
            }
        }

        private void VerifyConfig()
        {
            int updateCount = 0;
            if (Config["BarricadePrefabs"] == null) { config.barricadePrefabs = ConfigFile.DefaultConfig().barricadePrefabs; updateCount++; }
            if (Config["RemoveAfter"] == null) { config.removeAfter = ConfigFile.DefaultConfig().removeAfter; updateCount++; }
            if (Config["DebugMode"] == null) { config.debugMode = ConfigFile.DefaultConfig().debugMode; updateCount++; }
            if (updateCount != 0) { Puts($"Updating configuration with {updateCount} new changes."); SaveConfig(); }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<ConfigFile>();
            VerifyConfig();
            if (config == null) { LoadDefaultConfig(); }
        }

        protected override void LoadDefaultConfig() => config = ConfigFile.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config); 

        private void OnEntityBuilt(Planner builder, GameObject gameObject)
        {
            if (builder == null || gameObject == null) { return; }
            BaseEntity entity = gameObject.GetComponent<BaseEntity>();
            if (config.debugMode) { Puts($"[DEBUG] => {entity.ShortPrefabName}"); }
            if (entity == null) { return; }
            if (config.barricadePrefabs.Contains(entity.ShortPrefabName))
            {
                BasePlayer player = builder.GetOwnerPlayer();
                if (player == null) return;
                if (player.IsBuildingAuthed()) return;
                InvokeHandler.Invoke(entity, delegate { entity.Kill(); }, config.removeAfter);
            }
        }
    }
}

// --- End of file: TemporaryBarricades.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/toxic-crossbow ---
// --- Original File Path: T/ToxicCrossbow/ToxicCrossbow.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Toxic Crossbow", "DezLife", "0.0.8")]
    [Description("A crossbow that has the ability to fire one charge of a radiation arrow!")]
    class ToxicCrossbow : CovalencePlugin
    {
        #region Var
        ItemDefinition itemAmmo = null;
        #endregion

        #region Config
        private Configuration config;

        private class Configuration
        {
            [JsonProperty("SkinID for the item")]
            public ulong SkinID;
            [JsonProperty("DisplayName for the item")]
            public string DisplayName;
            [JsonProperty("The amount of radiation will be given every 3 seconds")]
            public float Radiations;
            [JsonProperty("Radius of radiation")]
            public float RadiationsRadius;
            [JsonProperty("Exposure time in seconds")]
            public int RadiationsTime;
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                SkinID = 1956876693,
                DisplayName = "Toxic crossbow",
                Radiations = 10,
                RadiationsRadius = 30,
                RadiationsTime = 30
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        #endregion  

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PlayerNot"] = "Player not found!",
                ["TheGiveSucc"] = "The player was successfully issued {0}!",
                ["YouGiveSucc"] = "You have successfully received {0}",
                ["NoPerm"] = "You are not authorized to use this command.",
                ["Invalidsyntax"] = "Use toxiccrossbow.give <steamid or name>",
            }, this);
        }
        #endregion

        #region Hook
        private void OnServerInitialized()
        {
            itemAmmo = ItemManager.FindItemDefinition("arrow.fire");
        }
        void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (attacker == null || info == null)
                return;

            if (info.Weapon?.skinID == config.SkinID && info.damageProperties?.name == "Damage.Arrow")
            {
                Item item = info.Weapon.GetItem();
                item.skin = 0;
                item.name = "Crossbow";

                var pos = info.HitPositionOnRay();
                timer.Repeat(1, config.RadiationsTime, () =>
                {
                    List<BasePlayer> players = Facepunch.Pool.GetList<BasePlayer>();                  
                    Vis.Entities(pos, config.RadiationsRadius, players);
                    for (int i = 0; i < players.Count; i++)
                        players[i].metabolism.radiation_poison.value += config.Radiations;
                    Facepunch.Pool.FreeList(ref players);
                });
            }
        }
        #endregion

        #region Metods
        private void CreateItem(BasePlayer target)
        {
            Item item = ItemManager.CreateByName("crossbow", 1, config.SkinID);
            item.name = config.DisplayName;
            item.condition = 0.1f;
            var weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon != null && itemAmmo != null)
            {
                weapon.primaryMagazine.ammoType = itemAmmo;
                weapon.primaryMagazine.contents = 1;
            }
            target.GiveItem(item);
        }

        #endregion

        #region Commands

        [Command("toxiccrossbow.give")]
        private void ConsoleCommandBlade(IPlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                player.Reply(lang.GetMessage("NoPerm", this, player.Id));
                return;
            }
            if (args.Length == 0)
            {
                player.Reply(lang.GetMessage("Invalidsyntax", this, player.Id));
                return;
            }
            var targets = players.FindPlayer(args[0])?.Object as BasePlayer;
            if (targets == null)
            {
                player.Reply(lang.GetMessage("PlayerNot", this, player.Id));
                return;
            }
            CreateItem(targets);
            player.Reply(string.Format(lang.GetMessage("TheGiveSucc", this, player.Id), config.DisplayName));
            targets.ChatMessage(string.Format(lang.GetMessage("YouGiveSucc", this, targets.UserIDString), config.DisplayName));
        }
        #endregion
    }
}

// --- End of file: ToxicCrossbow.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/twitch-commands ---
// --- Original File Path: T/TwitchCommands/TwitchCommands.cs ---

// Requires: Twitch

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Twitch Commands", "Wulf", "1.0.0")]
    [Description("Runs commands when a player follows/unfollows on Twitch")]
    class TwitchCommands : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        class Configuration
        {
            [JsonProperty("Run commands on player follow")]
            public bool RunFollowCommands { get; set; } = false;

            [JsonProperty("Commands to perform on follow", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> FollowCommands = new List<string> { "twitchexample1", "twitchexample2 $player.id" };

            [JsonProperty("Run commands on player unfollow")]
            public bool RunUnfollowCommands { get; set; } = false;

            [JsonProperty("Commands to perform on unfollow", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> UnfollowCommands = new List<string> { "twitchexample3 $player.name", "twitchexample4 $player.address" };

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Initialization

        private void Init()
        {
            if (!config.RunFollowCommands)
            {
                Unsubscribe(nameof(OnTwitchFollow));
            }
            if (!config.RunUnfollowCommands)
            {
                Unsubscribe(nameof(OnTwitchUnfollow));
            }
        }

        #endregion Initialization

        #region Hook Handling

        private void OnTwitchFollow(IPlayer player)
        {
            foreach (string command in config.FollowCommands)
            {
                server.Command(ReplacePlaceholders(command, player));
            }
        }

        private void OnTwitchUnfollow(IPlayer player)
        {
            foreach (string command in config.UnfollowCommands)
            {
                server.Command(ReplacePlaceholders(command, player));
            }
        }

        #endregion Hook Handling

        #region Helpers

        private string ReplacePlaceholders(string command, IPlayer player)
        {
            return command
                .Replace("$player.id", player.Id)
                .Replace("$player.name", player.Name)
                .Replace("$player.address", player.Address)
                .Replace("$player.position", player.Position().ToString());
        }

        #endregion Helpers
    }
}


// --- End of file: TwitchCommands.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/turret-info ---
// --- Original File Path: T/TurretInfo/TurretInfo.cs ---

﻿using System;
using System.Reflection;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("TurretInfo", "ninco90", "1.2.0", ResourceId = 2678)]
    class TurretInfo : RustPlugin
    {
        #region Fields
        private DynamicConfigFile restorationdata;
        private StoredData storedData;
        #endregion

        #region Oxide Hooks       
        void Init(){
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(this.Title);
            lang.RegisterMessages(MessagesEN, this);
            lang.RegisterMessages(MessagesES, this, "es");
            permission.RegisterPermission("turretinfo.use", this);
            permission.RegisterPermission("turretinfo.notify", this);
            permission.RegisterPermission("turretinfo.admin", this); 
        }
        #endregion

        #region StoredData
        class StoredData{
            public Dictionary<string, List<string>> Kills = new Dictionary<string, List<string>>();
            public StoredData() { }
        }

        class SpawnInfo {
            public SpawnInfo() { }
            public string UserId;
        }

        void PlayerKillsAdd(string steamid, string timeleft){
            if (!storedData.Kills.ContainsKey(timeleft))
                storedData.Kills.Add(timeleft, new List<string>());
            storedData.Kills[timeleft].Add(steamid);
            Interface.Oxide.DataFileSystem.WriteObject(this.Title, storedData);
        }
        #endregion

        #region Functions
        private BaseEntity FindEntity(BasePlayer player){
            var currentRot = Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward;
            Vector3 eyesAdjust = new Vector3(0f, 1.5f, 0f);
            var rayResult = Ray(player.transform.position + eyesAdjust, currentRot);
            if (rayResult is BaseEntity){
                var target = rayResult as BaseEntity;
                return target;
            }
            return null;
        }

        private object Ray(Vector3 Pos, Vector3 Aim){
            var hits = Physics.RaycastAll(Pos, Aim);
            float distance = 100f;
            object target = null;
            foreach (var hit in hits){
                if (hit.collider.GetComponentInParent<BaseEntity>() != null){
                    if (hit.distance < distance){
                        distance = hit.distance;
                        target = hit.collider.GetComponentInParent<BaseEntity>();
                    }
                }
            }
            return target;
        }

        private bool IsNPC(BasePlayer player){
            if (player == null) return false;
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L))
                return true;
			
            return false;
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info){
            if (entity == null) return;
            if (info == null) return;
            if (info.Initiator is AutoTurret && entity is BasePlayer){
                BasePlayer target = info.HitEntity.ToPlayer();
				if (IsNPC(target)) return;
                BasePlayer owner = BasePlayer.FindByID(info.Initiator.OwnerID);
                if (config.GS_LOG){
                    Puts(String.Format(GetMessage("killplayer"), target.displayName, owner.displayName));
                }
                if (permission.UserHasPermission(owner.UserIDString, "turretinfo.notify")){
                    if(config.GS_CHAT_GLOBAL){
                        PrintToChat(GetMessage("prefix") + String.Format(GetMessage("killplayer"), target.displayName, owner.displayName));
                    } else if(config.GS_CHAT_PRIVATE){
                        SendReply(owner, GetMessage("prefix") + String.Format(GetMessage("killplayer"), target.displayName, owner.displayName));
                    }
                }
                PlayerKillsAdd(target.userID.ToString(), info.Initiator.net.ID.ToString());
            } else {
                if (entity.ShortPrefabName == "autoturret_deployed"){
                    BasePlayer owner = BasePlayer.FindByID(entity.OwnerID);
                    if (info.Initiator as BasePlayer){
                        //Puts("Un jugador destruye la torreta");
                        BasePlayer players = BasePlayer.FindByID(info.Initiator.ToPlayer().userID);
                        if (config.GS_LOG){
                            Puts(String.Format(GetMessage("killturretplayer"), players.displayName, owner.displayName));
                        }
                        if (permission.UserHasPermission(owner.UserIDString, "turretinfo.notify")){
                            if(config.GS_CHAT_GLOBAL){
                                PrintToChat(GetMessage("prefix") + String.Format(GetMessage("killturretplayer"), players.displayName, owner.displayName));
                            } else if(config.GS_CHAT_PRIVATE){
                                SendReply(owner, GetMessage("prefix") + String.Format(GetMessage("killturretplayer"), players.displayName, owner.displayName));
                            }
                        }
                    } else {
                        if (config.GS_LOG){
                            Puts(String.Format(GetMessage("killturret"), owner.displayName));
                        }
                        if (permission.UserHasPermission(owner.UserIDString, "turretinfo.notify")){
                            if(config.GS_CHAT_GLOBAL){
                                PrintToChat(GetMessage("prefix") + String.Format(GetMessage("killturret"), owner.displayName));
                            } else if(config.GS_CHAT_PRIVATE){
                                SendReply(owner, GetMessage("prefix") + String.Format(GetMessage("killturret"), owner.displayName));
                            }
                        }
                    }
                    if (config.GS_GUI && permission.UserHasPermission(owner.UserIDString, "turretinfo.notify")){
                        CuiTurretDestroy(owner);
                        Effect.server.Run("assets/prefabs/npc/autoturret/effects/targetacquired.prefab", owner.transform.position);
                        timer.Once(6, () =>{
                            CuiHelper.DestroyUi(owner, "BlockMsg");
                        });
                    }
                }
            }
        }

        private BaseEntity GetViewEntity(BasePlayer player){
            RaycastHit hit;
            var didHit = Physics.Raycast(player.eyes.HeadRay(), out hit, 5);
            return didHit ? hit.GetEntity() : null;
        }
        #endregion

        #region Chat Commands
        [ChatCommand("turret")]
        void cmdAuth(BasePlayer player, string command, string[] args){
            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, "turretinfo.use")){
                if (args.Length == 0){
                    SendReply(player, msg("prefixbig", player.UserIDString) + String.Format(GetMessage("help"), Version.ToString()));
                } else {
                    var entity = FindEntity(player);
                    if (entity == null || (!entity.GetComponent<AutoTurret>())){
                        SendReply(player, msg("noturret", player.UserIDString));
                        return;
                    }

                    if (entity.OwnerID != player.userID){
                        if (config.GS_TEAM && entity.OwnerID > 0 && player.currentTeam > 0){
                            if (player.Team == null && !player.Team.members.Contains(entity.OwnerID)){
                                return;
                            }
                        } else if (!permission.UserHasPermission(player.UserIDString, "turretinfo.admin")){
                            SendReply(player, msg("noadmin", player.UserIDString));
                            return;
                        }
                    }

                    switch (args[0].ToLower()){
                        case "auth":
                            if (config.GS_EFFECT){
                                Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.shock.prefab", new Vector3(entity.transform.position.x, entity.transform.position.y + 0.8f, entity.transform.position.z));
                            }
                            SendReply(player, msg("prefixbig", player.UserIDString) + msg("autorizados", player.UserIDString));
                            int list = 1;
                            foreach (ProtoBuf.PlayerNameID pnid in entity.GetComponent<AutoTurret>().authorizedPlayers){
                                SendReply(player, "#" + list + " - " + pnid.username.ToString() + " (SteamID: " + pnid.userid.ToString() + ")");
                                list++;
                            }
                            return;
                        case "kills":
                            if (config.GS_EFFECT){
                                Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.shock.prefab", new Vector3(entity.transform.position.x, entity.transform.position.y + 0.8f, entity.transform.position.z));
                            }
                            SendReply(player, msg("prefixbig", player.UserIDString) + msg("kills", player.UserIDString));
                            if (storedData.Kills.ContainsKey(entity.net.ID.ToString())){
                                int i = 1;
                                foreach (var point in storedData.Kills[entity.net.ID.ToString()]){
                                    var targetPlayer = BasePlayer.Find(storedData.Kills[entity.net.ID.ToString()][i - 1]);
                                    SendReply(player, "#" + i + " - " + targetPlayer.displayName + " (SteamID: " + storedData.Kills[entity.net.ID.ToString()][i - 1] + ")");
                                    i++;
                                }
                            } else {
                                SendReply(player, msg("nokills", player.UserIDString));
                            }
                            return;
                        case "clear":
                            if (config.GS_EFFECT){
                                Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.shock.prefab", new Vector3(entity.transform.position.x, entity.transform.position.y + 0.8f, entity.transform.position.z));
                            }
                            SendReply(player, msg("prefixbig", player.UserIDString) + msg("clear", player.UserIDString));
                            storedData.Kills.Remove(entity.net.ID.ToString());
                            return;
                        case "clearall":
                            if (permission.UserHasPermission(player.UserIDString, "turretinfo.admin")){
                                if (config.GS_EFFECT){
                                    Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.shock.prefab", new Vector3(entity.transform.position.x, entity.transform.position.y + 0.8f, entity.transform.position.z));
                                }
                                storedData.Kills.Clear();
                                SendReply(player, msg("prefixbig", player.UserIDString) + msg("clearall", player.UserIDString));
                            } else {
                                SendReply(player, msg("noadmin", player.UserIDString));
                            }
                            return;
                        default:
                            break;
                    }
                }
            }          
        }
        #endregion

        #region GUI
        private void CuiTurretDestroy(BasePlayer player){
            CuiHelper.DestroyUi(player, "BlockMsg");

            var elements = new CuiElementContainer();
            var BlockMsg = elements.Add(new CuiPanel {
                Image = {
                    Color = "0.80 0.10 0.10 0.60"
                },
                RectTransform = {
                    AnchorMin = "0.41 0.12",
                    AnchorMax = "0.57 0.17"
                }
            }, "Hud", "BlockMsg");
            elements.Add(new CuiElement {
                Parent = BlockMsg,
                Components = {
                        new CuiRawImageComponent {
                            Sprite = "assets/content/textures/generic/fulltransparent.tga",
                            Url = "https://image.prntscr.com/image/Euu4ok39Qo_IBrAEmbSePQ.png",
                            Color = "0 0 0 0.70"
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0 0",
                            AnchorMax = "0.997 0.98"
                        }
                    }
            });
            elements.Add(new CuiElement {
                Parent = BlockMsg,
                Components = {
                        new CuiRawImageComponent {
                            Sprite = "assets/content/textures/generic/fulltransparent.tga",
                            Url = "https://vignette.wikia.nocookie.net/play-rust/images/f/f9/Auto_Turret_icon.png/revision/latest?cb=20151106062203",
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.03 0.05",
                            AnchorMax = "0.25 1.5"
                        }
                    }
            });
            elements.Add(new CuiLabel {
                RectTransform = {
                        AnchorMin = "0.28 0",
                        AnchorMax = "0.84 1"
                    },
                Text = {
                        Text = "TURRET DESTROYED",
                        FontSize = 12,
                        Align = TextAnchor.MiddleCenter,
                    }
            }, BlockMsg);
            CuiHelper.AddUi(player, elements);
        }
        #endregion

        #region Config
        private static ConfigData config;

        private class ConfigData{
            [JsonProperty(PropertyName = "CHAT GLOBAL | Show when someone dies or someone destroys the turret in Global Chat. [true,false]")]
            public bool GS_CHAT_GLOBAL;
            [JsonProperty(PropertyName = "CHAT PRIVATE | Only show the owner when someone dies by the turret or destroys it. [true,false]")]
            public bool GS_CHAT_PRIVATE;
            [JsonProperty(PropertyName = "GUI | Display GUI Turret Destroy [true,false]")]
            public bool GS_GUI;
            [JsonProperty(PropertyName = "EFFECT | Show effect when using [true,false]")]
            public bool GS_EFFECT;
            [JsonProperty(PropertyName = "LOG | Show Show log in console [true,false]")]
            public bool GS_LOG;
            [JsonProperty(PropertyName = "TEAM SUPPORT | Allows teammates to use commands [true,false]")]
            public bool GS_TEAM;
        }

        private ConfigData GetDefaultConfig() {
            return new ConfigData {
                GS_CHAT_GLOBAL = true,
                GS_CHAT_PRIVATE = true,
                GS_GUI = true,
                GS_EFFECT = true,
                GS_LOG = true,
                GS_TEAM = true,
            };
        }

        protected override void LoadConfig(){
            base.LoadConfig();
            try {
                config = Config.ReadObject<ConfigData>();
                if (config == null){
                    LoadDefaultConfig();
                }
            } catch {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig(){
            config = GetDefaultConfig();
        }

        protected override void SaveConfig(){
            Config.WriteObject(config);
        }
        #endregion

        #region Messaging
        string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);
        string msg(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        Dictionary<string, string> MessagesEN = new Dictionary<string, string> {
            {"prefix", "<color=#00b8ff>TurretInfo: </color>"},
            {"prefixbig", "<size=24><color=#00b8ff>TurretInfo</color></size>\n"},
            {"noturret", "You need to look at an Autoturret."},
            {"noadmin", "You can not consult something that does not belong to you."},
            {"autorizados", "<size=16>List of authorized players in this turret.</size>"},
            {"kills", "<size=16>List of players killed by this turret.</size>"},
            {"nokills", "Currently the turret has not killed any player."},
            {"clear", "<size=16>The list of players killed by this turret has been cleared.</size>"},
            {"clearall", "<size=16>The list of players killed by all the turrets has been cleared.</size>"},
            {"killplayer", "<color=#fb4c4c>{0}</color> has died due to an AutoTurret placed by <color=#3cb958>{1}</color>."},
            {"killturret", "Someone has destroyed an AutoTurret placed by <color=#3cb958>{0}</color>."},
            {"killturretplayer", "<color=#fb4c4c>{0}</color> has destroyed an AutoTurret placed by <color=#3cb958>{1}</color>."},
            {"help", "<size=16>Developed by: ninco90 | v{0}</size>\n" +
                "Look at an AutoTurret and present the following commands:\n" +
                "<color=#fb4c4c>/turret auth</color> - Check the authorized players.\n" +
                "<color=#fb4c4c>/turret kills</color> - Check the players killed.\n" +
                "<color=#fb4c4c>/turret clear</color> - Clean the list of players killed.\n" +
                "<color=#fb4c4c>/turret clearall</color> - Clean all lists (Admin only)."}
        };
        Dictionary<string, string> MessagesES = new Dictionary<string, string> {
            {"prefix", "<color=#00b8ff>TurretInfo: </color>"},
            {"prefixbig", "<size=24><color=#00b8ff>TurretInfo</color></size>\n"},
            {"noturret", "Necesita mirar una Autoturret."},
            {"noadmin", "No puedes consultar algo que no te pertenece."},
            {"autorizados", "<size=16>Lista de los jugadores autorizados en esta torreta.</size>"},
            {"kills", "<size=16>Lista de los jugadores matados por esta torreta.</size>"},
            {"nokills", "Actualmente la torreta no ha matado a ningún jugador."},
            {"clear", "<size=16>La lista de los jugadores matados por esta torreta se ha limpiado.</size>"},
            {"clearall", "<size=16>La lista de los jugadores matados por todas las torretas se ha limpiado.</size>"},
            {"killplayer", "<color=#fb4c4c>{0}</color> ha muerto por culpa de una Torreta Automática colocada por <color=#3cb958>{1}</color>."},
            {"killturret", "Alguien ha destruido una Torreta Automática colocada por <color=#3cb958>{0}</color>."},
            {"killturretplayer", "<color=#fb4c4c>{0}</color> ha destruido una Torreta Automática colocada por <color=#3cb958>{1}</color>."},
            {"help", "<size=16>Desarrollado por: ninco90 | v{0}</size>\n" +
                "Mira una AutoTurret y introduce los siguientes comandos:\n" +
                "<color=#fb4c4c>/turret auth</color> - Comprueba los jugadores autorizados.\n" +
                "<color=#fb4c4c>/turret kills</color> - Comprueba los jugadores asesinados.\n" +
                "<color=#fb4c4c>/turret clear</color> - Limpia la lista de jugadores asesinados.\n" +
                "<color=#fb4c4c>/turret clearall</color> - Limpia todas las listas (Sólo Admin)."}
        };
        #endregion
    }
}

// --- End of file: TurretInfo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/turret-switches ---
// --- Original File Path: T/TurretSwitches/TurretSwitches.cs ---

using UnityEngine;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Turret Switches", "ziptie", 1.4)]
    [Description("Spawns switches on turrets and SAM sites for players with permission.")]
    public class TurretSwitches : CovalencePlugin
    {
        #region Config
        public static TurretSwitchesConfig config;
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }
        private TurretSwitchesConfig GetDefaultConfig()
        {
            return new TurretSwitchesConfig();
        }
        private void Init()
        {
            TurretSwitches.config = Config.ReadObject<TurretSwitchesConfig>();
            RegisterPermissions();
            AddSwitchesToAllTurrets();
        }
        #endregion

        #region Localisation
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SwitchNoPermission"] = "You do not have permission to toggle this switch.",
            }, this);
        }
        #endregion

        #region Permissions
        public const string TurretPermission = "turretswitches.turret";
        public const string SAMPermission = "turretswitches.sam";
        private void RegisterPermissions()
        {
            permission.RegisterPermission(TurretPermission, this);
            permission.RegisterPermission(SAMPermission, this);
        }
        #endregion

        #region Hooks
        object OnSwitchToggle(IOEntity entity, BasePlayer player)
        {
            if (entity.HasComponent<TurretSwitch>())
            {
                TurretSwitch ts = entity.GetComponent<TurretSwitch>();
                ElectricSwitch s = entity as ElectricSwitch;
                if (ts.CanToggleTurret(player))
                {
                    ts.ToggleTurret(!s.IsOn());
                    if (config.PlaySoundEffects)
                        PlayEffect("assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab", player.transform.position);
                    return null;
                }
                if (config.PlaySoundEffects)
                    PlayEffect("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                player.IPlayer.Reply(lang.GetMessage("SwitchNoPermission", this, player.UserIDString));
                return false;
            }
            if (entity.HasComponent<SAMSwitch>())
            {
                SAMSwitch ts = entity.GetComponent<SAMSwitch>();
                ElectricSwitch s = entity as ElectricSwitch;
                if (ts.CanToggleSamSite(player))
                {
                    ts.ToggleTurret(!s.IsOn());
                    if (config.PlaySoundEffects)
                        PlayEffect("assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab", player.transform.position);
                    return null;
                }
                if (config.PlaySoundEffects)
                    PlayEffect("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                player.IPlayer.Reply(lang.GetMessage("SwitchNoPermission", this, player.UserIDString));
                return false;
            }
            return null;
        }
        void OnEntitySpawned(AutoTurret entity)
        {
            ElectricSwitch s = GameManager.server.CreateEntity("assets/prefabs/io/electric/switches/simpleswitch/simpleswitch.prefab", new Vector3(0, -0.65f, .3f), Quaternion.identity) as ElectricSwitch;
            s.Spawn();
            s.SetParent(entity);
            s.gameObject.AddComponent<TurretSwitch>().Turret = entity;
            s.SetFlag(IOEntity.Flag_HasPower, true);
            s.InitializeHealth(float.MaxValue, float.MaxValue);
            GameObject.Destroy(s.GetComponent<GroundWatch>());
            GameObject.Destroy(s.GetComponent<DestroyOnGroundMissing>());
            switches.Add(s);
        }
        void OnEntitySpawned(SamSite entity)
        {
            ElectricSwitch s = GameManager.server.CreateEntity("assets/prefabs/io/electric/switches/simpleswitch/simpleswitch.prefab", new Vector3(0, -0.65f, .95f), Quaternion.identity) as ElectricSwitch;
            s.Spawn();
            s.SetParent(entity);
            s.gameObject.AddComponent<SAMSwitch>().SamSite = entity;
            s.SetFlag(IOEntity.Flag_HasPower, true);
            s.InitializeHealth(float.MaxValue, float.MaxValue);
            GameObject.Destroy(s.GetComponent<GroundWatch>());
            GameObject.Destroy(s.GetComponent<DestroyOnGroundMissing>());
            switches.Add(s);
        }
        void Unload()
        {
            config = null;
            KillAllSwitches();
        }
        #endregion

        #region Helpers
        public void PlayEffect(string EffectPath, Vector3 position)
        {
            Effect.server.Run(EffectPath, position);
        }
        public IList<ElectricSwitch> switches = new List<ElectricSwitch>();
        public void KillAllSwitches()
        {
            foreach (var item in switches)
            {
                item.AdminKill();
            }
        }
        public void AddSwitchesToAllTurrets()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                if (entity.PrefabName == "assets/prefabs/npc/autoturret/autoturret_deployed.prefab")
                {
                    ElectricSwitch s = GameManager.server.CreateEntity("assets/prefabs/io/electric/switches/simpleswitch/simpleswitch.prefab", new Vector3(0, -0.65f, .3f), Quaternion.identity) as ElectricSwitch;
                    s.Spawn();
                    s.SetParent((BaseEntity)entity);
                    s.gameObject.AddComponent<TurretSwitch>().Turret = entity.GetComponent<AutoTurret>();
                    s.SetFlag(IOEntity.Flag_HasPower, true);
                    s.InitializeHealth(float.MaxValue, float.MaxValue);
                    GameObject.Destroy(s.GetComponent<GroundWatch>());
                    GameObject.Destroy(s.GetComponent<DestroyOnGroundMissing>());
                    switches.Add(s);
                }
                if (entity is SamSite)
                {
                    ElectricSwitch s = GameManager.server.CreateEntity("assets/prefabs/io/electric/switches/simpleswitch/simpleswitch.prefab", new Vector3(0, -0.65f, .95f), Quaternion.identity) as ElectricSwitch;
                    s.Spawn();
                    s.SetParent((BaseEntity)entity);
                    s.gameObject.AddComponent<SAMSwitch>().SamSite = entity.GetComponent<SamSite>();
                    s.SetFlag(IOEntity.Flag_HasPower, true);
                    s.InitializeHealth(float.MaxValue, float.MaxValue);
                    GameObject.Destroy(s.GetComponent<GroundWatch>());
                    GameObject.Destroy(s.GetComponent<DestroyOnGroundMissing>());
                }
            }
        }
        #endregion
    }
    #region Other Classes
    public class TurretSwitch : MonoBehaviour
    {
        public AutoTurret Turret;

        public bool CanToggleTurret(BasePlayer player)
        {
            if (TurretSwitches.config.RequiresPermission && !player.IPlayer.HasPermission(TurretSwitches.TurretPermission))
                return false;

            if (TurretSwitches.config.NeedsBuildingPrivilegeToUseSwitch && Turret.GetBuildingPrivilege() != null)
                return Turret.GetBuildingPrivilege().authorizedPlayers.ToList().Exists(x => x.userid == player.userID);

            if (Turret == null)
                return false;

            if (Turret.GetBuildingPrivilege() == null)
                return true;

            return true;
        }
        public void ToggleTurret(bool toggle)
        {
            if (Turret == null)
                return;
            Turret.SetFlag(IOEntity.Flag_HasPower, toggle);
            Turret.SetIsOnline(toggle);
        }
    }
    public class SAMSwitch : MonoBehaviour
    {
        public SamSite SamSite;
        public bool CanToggleSamSite(BasePlayer player)
        {
            if (TurretSwitches.config.RequiresPermission && !player.IPlayer.HasPermission(TurretSwitches.SAMPermission))
                return false;

            if (TurretSwitches.config.NeedsBuildingPrivilegeToUseSwitch && SamSite.GetBuildingPrivilege() != null)
                return SamSite.GetBuildingPrivilege().authorizedPlayers.ToList().Exists(x => x.userid == player.userID);

            if (SamSite == null)
                return false;

            if (SamSite.GetBuildingPrivilege() == null)
                return true;

            return true;
        }
        public void ToggleTurret(bool toggle)
        {
            if (SamSite == null)
                return;
            SamSite.SetFlag(IOEntity.Flag_HasPower, toggle);
        }
    }
    public class TurretSwitchesConfig
    {
        public bool NeedsBuildingPrivilegeToUseSwitch = true;
        public bool RequiresPermission = true;
        public bool PlaySoundEffects = true;
    }
    #endregion
}

// --- End of file: TurretSwitches.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tech-tree-control ---
// --- Original File Path: T/TechTreeControl/TechTreeControl.cs ---

﻿using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using static TechTreeData;

namespace Oxide.Plugins
{
    [Info("Tech Tree Control", "WhiteThunder", "0.5.0")]
    [Description("Allows customizing Tech Tree research requirements.")]
    internal class TechTreeControl : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin PopupNotifications;

        private const string PermissionAnyOrderLevel1 = "techtreecontrol.anyorder.level1";
        private const string PermissionAnyOrderLevel2 = "techtreecontrol.anyorder.level2";
        private const string PermissionAnyOrderLevel3 = "techtreecontrol.anyorder.level3";
        private const string PermissionAnyOrderIO = "techtreecontrol.anyorder.io";

        private readonly object True = true;
        private readonly object False = false;

        private Configuration _config;

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionAnyOrderLevel1, this);
            permission.RegisterPermission(PermissionAnyOrderLevel2, this);
            permission.RegisterPermission(PermissionAnyOrderLevel3, this);
            permission.RegisterPermission(PermissionAnyOrderIO, this);

            _config.Init(this);

            if (!_config.IsCustomCurrencyEnabledAndValid)
            {
                Unsubscribe(nameof(OnTechTreeNodeUnlock));
            }
        }

        private void OnServerInitialized()
        {
            if (_config.EnablePopupNotifications && PopupNotifications == null)
            {
                LogWarning("PopupNotifications integration is enabled in the config, but the PopupNotifications plugin isn't loaded.");
            }
        }

        private object OnTechTreeNodeUnlock(Workbench workbench, NodeInstance node, BasePlayer player)
        {
            var currencyAmountOverride = _config.GetResearchCostOverride(node.itemDef);
            if (currencyAmountOverride is int currencyAmount)
            {
                var taxRate = ConVar.Server.GetTaxRateForWorkbenchUnlock(workbench.Workbenchlevel);
                if (taxRate > 0)
                {
                    currencyAmount += Mathf.CeilToInt(currencyAmount * (taxRate / 100f));
                }
            }
            else
            {
                currencyAmount = Workbench.ScrapForResearch(node.itemDef, workbench.Workbenchlevel, out var tax);
                currencyAmount += tax;
            }

            var itemid = _config.CustomCurrency.ItemId;
            if (player.inventory.GetAmount(itemid) >= currencyAmount)
            {
                player.inventory.Take(null, itemid, currencyAmount);
                player.blueprints.Unlock(node.itemDef);
                Interface.CallHook("OnTechTreeNodeUnlocked", workbench, node, player);
            }

            return False;
        }

        private object CanUnlockTechTreeNode(BasePlayer player, NodeInstance node, TechTreeData techTree)
        {
            var blueprintRuleset = _config.GetPlayerBlueprintRuleset(this, player.UserIDString);
            if (blueprintRuleset == null)
                return null;

            if (node.itemDef != null && !blueprintRuleset.IsAllowed(node.itemDef))
            {
                var message = GetMessage(player.UserIDString,
                    blueprintRuleset.IsOptional(node.itemDef)
                        ? LangEntry.BlueprintDisallowedOptional
                        : LangEntry.BlueprintDisallowed);

                if (_config.EnablePopupNotifications)
                {
                    PopupNotifications?.Call("CreatePopupNotification", message, player);
                }

                if (_config.EnableChatFeedback)
                {
                    player.ChatMessage(message);
                }

                return False;
            }

            return null;
        }

        private object CanUnlockTechTreeNodePath(BasePlayer player, NodeInstance node, TechTreeData techTree)
        {
            if (HasPermissionToUnlockAny(player, techTree))
                return True;

            var blueprintRuleset = _config.GetPlayerBlueprintRuleset(this, player.UserIDString);
            if (blueprintRuleset == null)
                return null;

            if (node.itemDef != null && !blueprintRuleset.HasPrerequisites(node.itemDef))
                return True;

            if (HasUnlockPath(player, node, techTree, blueprintRuleset))
                return True;

            return null;
        }

        private object OnResearchCostDetermine(ItemDefinition itemDefinition)
        {
            return _config.GetResearchCostOverride(itemDefinition);
        }

        #endregion

        #region Helper Methods

        public static void LogError(string message) => Interface.Oxide.LogError($"[Tech Tree Control] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Tech Tree Control] {message}");

        private static bool HasUnlockPath(BasePlayer player, NodeInstance node, TechTreeData techTree, BlueprintRuleset blueprintRuleset)
        {
            if (node.inputs.Count == 0)
                return true;

            var hasUnlockPath = false;

            foreach (var inputNodeId in node.inputs)
            {
                var inputNode = techTree.GetByID(inputNodeId);
                if (inputNode.itemDef == null)
                {
                    // This input node appears to be an entry node, so consider it unlocked.
                    return true;
                }

                if (!techTree.HasPlayerUnlocked(player, inputNode) && !blueprintRuleset.IsOptional(inputNode.itemDef))
                {
                    // This input node does not provide an unlock path.
                    // Continue iterating the other input nodes in case they provide an unlock path.
                    continue;
                }

                if (HasUnlockPath(player, inputNode, techTree, blueprintRuleset))
                {
                    hasUnlockPath = true;
                }
            }

            return hasUnlockPath;
        }

        private bool HasPermissionToUnlockAny(BasePlayer player, TechTreeData techTree)
        {
            if (techTree.name == "TechTreeT3")
                return permission.UserHasPermission(player.UserIDString, PermissionAnyOrderLevel3);

            if (techTree.name == "TechTreeT2")
                return permission.UserHasPermission(player.UserIDString, PermissionAnyOrderLevel2);

            if (techTree.name == "TechTreeT0")
                return permission.UserHasPermission(player.UserIDString, PermissionAnyOrderLevel1);

            if (techTree.name == "TechTreeIO")
                return permission.UserHasPermission(player.UserIDString, PermissionAnyOrderIO);

            return false;
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class CustomCurrency
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Item short name")]
            public string ItemShortName = "scrap";

            [JsonIgnore]
            public int ItemId;

            [JsonIgnore]
            public bool IsEnabledAndValid => Enabled && ItemId != 0;

            public void Init()
            {
                if (!Enabled)
                    return;

                var itemDefinition = ItemManager.FindItemDefinition(ItemShortName);
                if (itemDefinition == null)
                {
                    LogWarning($"Invalid item short name in config: {ItemShortName}");
                }
                else
                {
                    ItemId = itemDefinition.itemid;
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class BlueprintRuleset
        {
            public static readonly BlueprintRuleset DefaultRuleset = new();

            [JsonProperty("Name")]
            private string Name;

            [JsonProperty("Optional blueprints")]
            private string[] OptionalBlueprints = Array.Empty<string>();

            [JsonProperty("OptionalBlueprints")]
            private string[] DeprecatedOptionalBlueprints { set => OptionalBlueprints = value; }

            [JsonProperty("Allowed blueprints", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private string[] AllowedBlueprints;

            [JsonProperty("AllowedBlueprints")]
            private string[] DeprecatedAllowedBlueprints { set => AllowedBlueprints = value; }

            [JsonProperty("Disallowed blueprints", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private string[] DisallowedBlueprints;

            [JsonProperty("DisallowedBlueprints")]
            private string[] DeprecatedDisallowedBlueprints { set => DisallowedBlueprints = value; }

            [JsonProperty("Blueprints with no prerequisites")]
            private string[] BlueprintsWithNoPrerequisites = Array.Empty<string>();

            [JsonProperty("BlueprintsWithNoPrerequisites")]
            private string[] DeprecatedBlueprintsWithNoPrerequisites { set => BlueprintsWithNoPrerequisites = value; }

            public string Permission { get; private set; }
            private HashSet<int> _optionalBlueprints = new();
            private HashSet<int> _allowedBlueprints = new();
            private HashSet<int> _disallowedBlueprints = new();
            private HashSet<int> _blueprintsWithNoPrerequisites = new();

            public void Init(TechTreeControl plugin)
            {
                if (!string.IsNullOrWhiteSpace(Name))
                {
                    Permission = $"{nameof(TechTreeControl)}.ruleset.{Name}".ToLower();
                    plugin.permission.RegisterPermission(Permission, plugin);
                }

                CacheItemIds(OptionalBlueprints, _optionalBlueprints);
                CacheItemIds(AllowedBlueprints, _allowedBlueprints);
                CacheItemIds(DisallowedBlueprints, _disallowedBlueprints);
                CacheItemIds(BlueprintsWithNoPrerequisites, _blueprintsWithNoPrerequisites);
            }

            public bool HasPrerequisites(ItemDefinition itemDefinition)
            {
                return !_blueprintsWithNoPrerequisites.Contains(itemDefinition.itemid);
            }

            public bool IsAllowed(ItemDefinition itemDefinition)
            {
                if (AllowedBlueprints != null)
                    return _allowedBlueprints.Contains(itemDefinition.itemid);

                if (DisallowedBlueprints != null)
                    return !_disallowedBlueprints.Contains(itemDefinition.itemid);

                return true;
            }

            public bool IsOptional(ItemDefinition itemDefinition)
            {
                return _optionalBlueprints.Contains(itemDefinition.itemid);
            }

            private static void CacheItemIds(IEnumerable<string> shortNameList, HashSet<int> cachedItemIds)
            {
                if (shortNameList == null)
                    return;

                foreach (var itemShortName in shortNameList)
                {
                    var itemDefinition = ItemManager.FindItemDefinition(itemShortName);
                    if (itemDefinition == null)
                    {
                        LogError($"Invalid item short name in config: {itemShortName}");
                        continue;
                    }

                    cachedItemIds.Add(itemDefinition.itemid);
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Enable chat feedback")]
            public bool EnableChatFeedback = true;

            [JsonProperty("Enable PopupNotifications integration")]
            public bool EnablePopupNotifications;

            [JsonProperty("Research costs")]
            private Dictionary<string, int> ResearchCosts = new();

            [JsonProperty("Custom currency")]
            public CustomCurrency CustomCurrency = new();

            [JsonProperty("ResearchCosts")]
            private Dictionary<string, int> DeprecatedResearchCosts { set => ResearchCosts = value; }

            [JsonProperty("Blueprint rulesets")]
            private BlueprintRuleset[] BlueprintRulesets = Array.Empty<BlueprintRuleset>();

            [JsonProperty("BlueprintRulesets")]
            private BlueprintRuleset[] DeprecatedBlueprintRulesets { set => BlueprintRulesets = value; }

            private Dictionary<int, object> _researchCostByItemId = new();

            [JsonIgnore]
            public bool IsCustomCurrencyEnabledAndValid => CustomCurrency is { IsEnabledAndValid: true };

            public void Init(TechTreeControl plugin)
            {
                CustomCurrency?.Init();

                if (BlueprintRulesets != null)
                {
                    foreach (var ruleset in BlueprintRulesets)
                    {
                        ruleset.Init(plugin);
                    }
                }

                if (ResearchCosts != null)
                {
                    foreach (var entry in ResearchCosts)
                    {
                        var itemDefinition = ItemManager.FindItemDefinition(entry.Key);
                        if (itemDefinition == null)
                        {
                            LogError($"Invalid item short name in config: {entry.Key}");
                            continue;
                        }

                        _researchCostByItemId[itemDefinition.itemid] = entry.Value;
                    }
                }
            }

            public object GetResearchCostOverride(ItemDefinition itemDefinition)
            {
                return _researchCostByItemId.TryGetValue(itemDefinition.itemid, out var costOverride)
                    ? costOverride
                    : null;
            }

            public BlueprintRuleset GetPlayerBlueprintRuleset(TechTreeControl plugin, string userIdString)
            {
                if (BlueprintRulesets != null)
                {
                    for (var i = BlueprintRulesets.Length - 1; i >= 0; i--)
                    {
                        var ruleset = BlueprintRulesets[i];
                        if (ruleset.Permission != null
                            && plugin.permission.UserHasPermission(userIdString, ruleset.Permission))
                            return ruleset;
                    }
                }

                return BlueprintRuleset.DefaultRuleset;
            }
        }

        private Configuration GetDefaultConfig() => new();

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private class LangEntry
        {
            public static readonly List<LangEntry> AllLangEntries = new();

            public static readonly LangEntry BlueprintDisallowed = new("BlueprintDisallowed", "You don't have permission to unlock that blueprint.");
            public static readonly LangEntry BlueprintDisallowedOptional = new("BlueprintDisallowed.Optional", "You don't have permission to unlock that blueprint, but it can be skipped.");

            public string Name;
            public string English;

            public LangEntry(string name, string english)
            {
                Name = name;
                English = english;

                AllLangEntries.Add(this);
            }
        }

        private string GetMessage(string playerId, LangEntry langEntry) =>
            lang.GetMessage(langEntry.Name, this, playerId);

        private void ChatMessage(BasePlayer player, LangEntry langEntry) =>
            player.ChatMessage(GetMessage(player.UserIDString, langEntry));

        protected override void LoadDefaultMessages()
        {
            var englishLangKeys = new Dictionary<string, string>();

            foreach (var langEntry in LangEntry.AllLangEntries)
            {
                englishLangKeys[langEntry.Name] = langEntry.English;
            }

            lang.RegisterMessages(englishLangKeys, this, "en");
        }

        #endregion
    }
}


// --- End of file: TechTreeControl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tc-map-markers ---
// --- Original File Path: T/TcMapMarkers/TcMapMarkers.cs ---

﻿using UnityEngine;
using CompanionServer.Handlers;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("TC Map Markers", "1AK1", "1.1.2")]
    [Description("Shows custom map markers for all cupboards on the server.")]
    internal class TcMapMarkers : CovalencePlugin
    {
        [PluginReference] private Plugin Friends, Clans;

        #region Vars

        private int count;
        private const string permUse = "tcmapmarkers.use";
        public List<MapMarkerGenericRadius> TCMarkers = new List<MapMarkerGenericRadius>();

        #endregion Vars

        #region Config       

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Map Marker Options")]
            public MapMarkerOptions MapMarker { get; set; }

            [JsonProperty(PropertyName = "Owned Markers Options")]
            public OwnedMarkersOptions OwnedMarkers { get; set; }

            [JsonProperty(PropertyName = "Other Markers Options")]
            public OtherMarkersOptions OtherMarkers { get; set; }

            [JsonProperty(PropertyName = "Teams Markers Options")]
            public TeamsMarkersOptions TeamsMarkers { get; set; }

            [JsonProperty(PropertyName = "Friends Markers Options")]
            public FriendsMarkersOptions FriendsMarkers { get; set; }

            [JsonProperty(PropertyName = "Clans Markers Options")]
            public ClansMarkersOptions ClansMarkers { get; set; }

            public class MapMarkerOptions
            {
                [JsonProperty(PropertyName = "Prefab Path")]
                public string PREFAB_MARKER { get; set; }

                [JsonProperty(PropertyName = "Show to all? (true/false)")]
                public bool visibleToAll { get; set; }

                [JsonProperty(PropertyName = "Enable Teams? (true/false)")]
                public bool TeamsUse { get; set; }

                [JsonProperty(PropertyName = "Enable Friends? (true/false)")]
                public bool FriendsUse { get; set; }

                [JsonProperty(PropertyName = "Enable Clans? (true/false)")]
                public bool ClansUse { get; set; }

            }

            public class OwnedMarkersOptions
            {
                [JsonProperty(PropertyName = "Color1 (hex)")]
                public string OwnedColor1 { get; set; }

                [JsonProperty(PropertyName = "Color2 (hex)")]
                public string OwnedColor2 { get; set; }

                [JsonProperty(PropertyName = "Alpha")]
                public float OwnedAlpha { get; set; }

                [JsonProperty(PropertyName = "Radius")]
                public float OwnedRadius { get; set; }
            }

            public class OtherMarkersOptions
            {
                [JsonProperty(PropertyName = "Color1 (hex)")]
                public string OtherColor1 { get; set; }

                [JsonProperty(PropertyName = "Color2 (hex)")]
                public string OtherColor2 { get; set; }

                [JsonProperty(PropertyName = "Alpha")]
                public float OtherAlpha { get; set; }

                [JsonProperty(PropertyName = "Radius")]
                public float OtherRadius { get; set; }
            }

            public class TeamsMarkersOptions
            {
                [JsonProperty(PropertyName = "Color1 (hex)")]
                public string TeamsColor1 { get; set; }

                [JsonProperty(PropertyName = "Color2 (hex)")]
                public string TeamsColor2 { get; set; }

                [JsonProperty(PropertyName = "Alpha")]
                public float TeamsAlpha { get; set; }

                [JsonProperty(PropertyName = "Radius")]
                public float TeamsRadius { get; set; }
            }

            public class FriendsMarkersOptions
            {
                [JsonProperty(PropertyName = "Color1 (hex)")]
                public string FriendsColor1 { get; set; }

                [JsonProperty(PropertyName = "Color2 (hex)")]
                public string FriendsColor2 { get; set; }

                [JsonProperty(PropertyName = "Alpha")]
                public float FriendsAlpha { get; set; }

                [JsonProperty(PropertyName = "Radius")]
                public float FriendsRadius { get; set; }
            }

            public class ClansMarkersOptions
            {
                [JsonProperty(PropertyName = "Color1 (hex)")]
                public string ClansColor1 { get; set; }

                [JsonProperty(PropertyName = "Color2 (hex)")]
                public string ClansColor2 { get; set; }

                [JsonProperty(PropertyName = "Alpha")]
                public float ClansAlpha { get; set; }

                [JsonProperty(PropertyName = "Radius")]
                public float ClansRadius { get; set; }
            }

        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();
            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                MapMarker = new ConfigData.MapMarkerOptions
                {
                    PREFAB_MARKER = "assets/prefabs/tools/map/genericradiusmarker.prefab",
                    visibleToAll = true,
                    FriendsUse = true

                },
                OwnedMarkers = new ConfigData.OwnedMarkersOptions
                {
                    OwnedColor1 = "#00FF00",
                    OwnedColor2 = "#00FF00",
                    OwnedAlpha = 1f,
                    OwnedRadius = 0.08f
                },
                OtherMarkers = new ConfigData.OtherMarkersOptions
                {
                    OtherColor1 = "#FF0000",
                    OtherColor2 = "#FF0000",
                    OtherAlpha = 1f,
                    OtherRadius = 0.08f
                },
                TeamsMarkers = new ConfigData.TeamsMarkersOptions
                {
                    TeamsColor1 = "#0000FF",
                    TeamsColor2 = "#0000FF",
                    TeamsAlpha = 1f,
                    TeamsRadius = 0.08f
                },
                FriendsMarkers = new ConfigData.FriendsMarkersOptions
                {
                    FriendsColor1 = "#0000FF",
                    FriendsColor2 = "#0000FF",
                    FriendsAlpha = 1f,
                    FriendsRadius = 0.08f
                },
                ClansMarkers = new ConfigData.ClansMarkersOptions
                {
                    ClansColor1 = "#0000FF",
                    ClansColor2 = "#0000FF",
                    ClansAlpha = 1f,
                    ClansRadius = 0.08f
                }
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        #endregion Config

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PlayersOnly"] = "Command '{0}' can only be used by players",
                ["UsageTcMap"] = "Usage {0} <clear|update|showtoall|>",
                ["MarkersRemoved"] = "All map markers has been removed",
                ["MarkersSpawned"] = "Spawned {0} map markers",
                ["MarkersVisibleAdmin"] = "Map marker are now visible to ADMINS only",
                ["MarkersVisibleAll"] = "Map marker are now visible to ALL"
            }, this);
        }

        #endregion Localization

        #region Oxide Hooks

        private void Init()
        {
            AddCovalenceCommand("tcmap", "CommandTCMap");
            permission.RegisterPermission(permUse, this);
        }

        private void OnServerInitialized(bool initial)
        {
            LoadMapMarkers();
        }

        private void Unload()
        {
            RemoveMapMarkers();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }
            foreach (var marker in TCMarkers)
            {
                if(marker != null)
                {
                    marker.SendUpdate();
                }           
            }
            
        }

        object CanNetworkTo(MapMarkerGenericRadius marker, BasePlayer player)
        {
            if (!TCMarkers.Contains(marker)) return null;

            if (!configData.MapMarker.visibleToAll && !player.IPlayer.HasPermission(permUse)) return false;

            switch (marker.name)
            {
                case "owner":
                    if (marker.OwnerID == player.userID) return null;
                    else return false;
                case "team":
                    if(configData.MapMarker.TeamsUse && player.Team != null && player.Team.members.Contains(marker.OwnerID)) return null;
                    else return false;
                case "friend":
                    if(configData.MapMarker.FriendsUse && Friends != null && Friends.IsLoaded && Friends.Call<bool>("AreFriends", player.userID, marker.OwnerID)) return null;
                    else return false;
                case "clan":
                    if (configData.MapMarker.ClansUse && Clans != null && Clans.IsLoaded && Clans.Call<bool>("IsClanMember", player.UserIDString, marker.OwnerID.ToString())) return null;
                    else return false;
                default:
                    return null;
            }
        }
        
        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            var cupboard = go.GetComponent<BuildingPrivlidge>();
            if (cupboard == null)
            {
                return;
            }

            CreateMapMarker(cupboard, "other", configData.OtherMarkers.OtherColor1, configData.OtherMarkers.OtherColor2, configData.OtherMarkers.OtherAlpha, configData.OtherMarkers.OtherRadius);

            if (configData.MapMarker.TeamsUse)
            {
                CreateMapMarker(cupboard, "team", configData.TeamsMarkers.TeamsColor1, configData.TeamsMarkers.TeamsColor2, configData.TeamsMarkers.TeamsAlpha, configData.TeamsMarkers.TeamsRadius);
            }

            if (configData.MapMarker.FriendsUse && Friends != null && Friends.IsLoaded)
            {
                CreateMapMarker(cupboard, "friend", configData.FriendsMarkers.FriendsColor1, configData.FriendsMarkers.FriendsColor2, configData.FriendsMarkers.FriendsAlpha, configData.FriendsMarkers.FriendsRadius);
            }

            if (configData.MapMarker.ClansUse && Clans != null && Clans.IsLoaded)
            {
                CreateMapMarker(cupboard, "clan", configData.ClansMarkers.ClansColor1, configData.ClansMarkers.ClansColor2, configData.ClansMarkers.ClansAlpha, configData.ClansMarkers.ClansRadius);
            }

            CreateMapMarker(cupboard, "owner", configData.OwnedMarkers.OwnedColor1, configData.OwnedMarkers.OwnedColor2, configData.OwnedMarkers.OwnedAlpha, configData.OwnedMarkers.OwnedRadius);
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            if (!(entity is BuildingPrivlidge)) return;
            var cupboard = (BuildingPrivlidge)entity;

            foreach (var marker in TCMarkers)
            {  
                if(marker == null)
                {
                    return;
                }

                if (marker.transform.position == cupboard.transform.position)
                {
                    marker.Kill();
                    marker.SendUpdate();
                }
            }
        }

        #endregion Oxide Hooks

        #region Core

        private void LoadMapMarkers()
        {
            
            count = 0;
            foreach (var entity in BaseNetworkable.serverEntities)
            {                
                if ((entity is BuildingPrivlidge))
                {
                    var cupboard = (BuildingPrivlidge)entity;
                    CreateMapMarker(cupboard, "other", configData.OtherMarkers.OtherColor1, configData.OtherMarkers.OtherColor2, configData.OtherMarkers.OtherAlpha, configData.OtherMarkers.OtherRadius);

                    if (configData.MapMarker.TeamsUse)
                    {
                        CreateMapMarker(cupboard, "team", configData.TeamsMarkers.TeamsColor1, configData.TeamsMarkers.TeamsColor2, configData.TeamsMarkers.TeamsAlpha, configData.TeamsMarkers.TeamsRadius);
                    }

                    if (configData.MapMarker.FriendsUse && Friends != null && Friends.IsLoaded)
                    {
                        CreateMapMarker(cupboard, "friend", configData.FriendsMarkers.FriendsColor1, configData.FriendsMarkers.FriendsColor2, configData.FriendsMarkers.FriendsAlpha, configData.FriendsMarkers.FriendsRadius);
                    }

                    if (configData.MapMarker.ClansUse && Clans != null && Clans.IsLoaded)
                    {
                        CreateMapMarker(cupboard, "clan", configData.ClansMarkers.ClansColor1, configData.ClansMarkers.ClansColor2, configData.ClansMarkers.ClansAlpha, configData.ClansMarkers.ClansRadius);
                    }

                    CreateMapMarker(cupboard, "owner", configData.OwnedMarkers.OwnedColor1, configData.OwnedMarkers.OwnedColor2, configData.OwnedMarkers.OwnedAlpha, configData.OwnedMarkers.OwnedRadius);
                    count++;
                }
            }      
            Puts(Lang("MarkersSpawned", null, count.ToString()));
        }

        private void RemoveMapMarkers()
        {
            foreach (var marker in TCMarkers)
            {
                if (marker != null)
                {
                    marker.Kill();
                    marker.SendUpdate();
                }
            }
            TCMarkers.Clear();
        }

        private void CreateMapMarker(BuildingPrivlidge cupboard, string type, string color1, string color2, float alpha, float radius)
        {
            MapMarkerGenericRadius mapMarker = GameManager.server.CreateEntity(configData.MapMarker.PREFAB_MARKER, cupboard.transform.position) as MapMarkerGenericRadius;

            if (mapMarker != null)
            {
                mapMarker.alpha = alpha;
                if (!ColorUtility.TryParseHtmlString(color1, out mapMarker.color1))
                {
                    mapMarker.color1 = Color.black;
                    PrintError($"Invalid map marker color1: {color1}");
                }

                if (!ColorUtility.TryParseHtmlString(color2, out mapMarker.color2))
                {
                    mapMarker.color2 = Color.white;
                    PrintError($"Invalid map marker color2: {color2}");
                }

                mapMarker.name = type;
                mapMarker.radius = radius;
                mapMarker.OwnerID = cupboard.OwnerID;
                TCMarkers.Add(mapMarker);
                mapMarker.Spawn();
                mapMarker.SendUpdate();

            }
        }

        #endregion Core

        #region Commands

        private void CommandTCMap(IPlayer player, string command, string[] args)
        {

            if (player.IsServer)
            {
                Message(player, "PlayersOnly", command);
                return;
            }

            if (!player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args == null || args.Length <= 0)
            {
                Message(player, "UsageTcMap", command);
                return;
            }

            switch (args[0].ToLower())
            {
                case "help":

                    Message(player, "UsageTcMap", command);
                    return;

                case "clear":

                    RemoveMapMarkers();
                    Message(player, "MarkersRemoved");
                    return;

                case "update":

                    RemoveMapMarkers();
                    LoadMapMarkers();
                    Message(player, "MarkersSpawned", count.ToString());
                    return;

                case "showtoall":

                    if (configData.MapMarker.visibleToAll)
                    {
                        configData.MapMarker.visibleToAll = false;
                        RemoveMapMarkers();
                        LoadMapMarkers();
                        Message(player, "MarkersVisibleAdmin");
                    }
                    else
                    {
                        configData.MapMarker.visibleToAll = true;
                        RemoveMapMarkers();
                        LoadMapMarkers();
                        Message(player, "MarkersVisibleAll");

                    }
                    return;
            }
        }

        #endregion Commands

        #region Helpers


        private void Message(IPlayer player, string key, params object[] args)
        {
            if (player.IsConnected)
            {
                player.Message(Lang(key, player.Id, args));
            }
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        #endregion Helpers

    }
}

// --- End of file: TcMapMarkers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tc-options ---
// --- Original File Path: T/TcOptions/TcOptions.cs ---

﻿using System;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Collections.Generic;


namespace Oxide.Plugins
{
    [Info("Tc Options", "Sapnu Puas", "1.0.4")]
    [Description("Add a code lock and loot to tc when placed")]
    public class TcOptions : RustPlugin
    {
        private const string PermissionUse = "tcoptions.use";

        #region[Load/Unload]
        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
        }
        private void OnServerInitialized()
        {
            LoadLockData();
        }
       
        void OnNewSave(string filename)
        {
            LoadConfig();
            LocknetID = new List<NetworkableId>();
            Puts("Wiping Data Files!!");
        }

        private void Unload()
        {
            SaveLockData();
        }

        #endregion[Load/Unload]

        #region[Assets]
        private const string codelockprefab = "assets/prefabs/locks/keypad/lock.code.prefab";
        private const string Prefab_CodeLock_UnlockEffect = "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab";
        private const string Prefab_CodeLock_LockEffect = "assets/prefabs/locks/keypad/effects/lock.code.lock.prefab";
        #endregion[Assets]

        #region [Localisation]
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Blocked"] = "you cannot remove this code lock !!"

            }, this);
        }
        #endregion [Localisation]

        #region[Hooks]
        void OnEntitySpawned(BaseEntity ent)
        {
            var output = ent.GetComponent<StorageContainer>();
            ulong player = ent.OwnerID;
            if (ent == null || ent.OwnerID == 0 || ent.IsDestroyed) return;
            if (!permission.UserHasPermission(ent?.OwnerID.ToString(), PermissionUse)) return;
           
            if (config.Tc.ContainsKey(ent.ShortPrefabName) && ent.OwnerID != 0)
            {
                if (config.Tcsettings.AddLock)
                {
                    AddLock(ent, player);
                }
                if (config.Tcsettings.AddLoot)
                {
                    SpawnTcLoot(output);
                }
            }
        }
        void OnEntityKill(BaseLock baseLock)
        {
            if (LocknetID.Contains(baseLock.net.ID))
            {
                LocknetID.Remove(baseLock.net.ID);
                SaveLockData();
            }
        }
      
        object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (baseLock == null) return false;
            if (baseLock.OwnerID != player.userID)
            {
                return null;
            }
            if (baseLock.OwnerID == player.userID)
            {
                return true;
            }
            return null;
        }
        object CanUnlock(BasePlayer player, BaseLock baseLock)
        {
            if (baseLock == null) return false;
            if (baseLock.OwnerID != player.userID)
            {
                return null;
            }
            if (baseLock.OwnerID == player.userID)
            {
                Unlock(baseLock);
                return true;
            }

            return null;
        }
        object CanPickupLock(BasePlayer player, BaseLock baseLock)
        {
            if (LocknetID.Contains(baseLock.net.ID))
            {
                player.SendConsoleCommand("showtoast", 1, lang.GetMessage("Blocked", this, player.UserIDString));

                return true;
            }
            return null;

        }
        #endregion[Hooks]

        #region [Config]

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();

                if (config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = Configuration.DefaultConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Settings")]
            public _tcsettings Tcsettings = new _tcsettings();

            [JsonProperty("Loot for")]
            public Dictionary<string, List<Loot>> Tc;

            public class _tcsettings
            {
                [JsonProperty("Add Codelock ?")]
                public bool AddLock = true;

                [JsonProperty("Add loot to toolcupboard ?")]
                public bool AddLoot = true;

            }
            
            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    Tc = new Dictionary<string, List<Loot>>
                    {
                        ["cupboard.tool.deployed"] = new List<Loot>//tc
                        {
                            new Loot
                            {
                                ShortName = "wood",
                                Amount = 2000,
                            },
                            new Loot
                            {
                                ShortName = "stones",
                                Amount = 3000,
                            },
                            new Loot
                            {
                                ShortName = "metal.fragments",
                                Amount = 1000,
                            },
                            new Loot
                            {
                                ShortName = "metal.refined",
                                Amount = 100,
                            },
                        },
                    },
                };
            }
        }
        public class Loot
        {
            [JsonProperty("ShortName")]
            public string ShortName;

            [JsonProperty("Amount")]
            public int Amount;
        }

        #endregion[Config]

        #region[Methods]
        void AddLock(BaseEntity ent, ulong playerid)
        {
            CodeLock codeLock = GameManager.server.CreateEntity(codelockprefab) as CodeLock;
            codeLock.Spawn();
            codeLock.OwnerID = ent.OwnerID;
            codeLock.code = UnityEngine.Random.Range(1111, 9999).ToString();
            codeLock.SetParent(ent, ent.GetSlotAnchorName(BaseEntity.Slot.Lock));
            ent.SetSlot(BaseEntity.Slot.Lock, codeLock);
            codeLock.whitelistPlayers.Add(ent.OwnerID);
            codeLock.SetFlag(BaseEntity.Flags.Locked, true);
            codeLock.enableSaving = false;
            codeLock.SendNetworkUpdateImmediate(true);
            Effect.server.Run(Prefab_CodeLock_LockEffect, codeLock, 0, Vector3.zero, Vector3.forward);
            LocknetID.Add(codeLock.net.ID);
            SaveLockData();
        }
        private void Unlock(BaseLock baseLock)
        {
            baseLock.SetFlag(BaseEntity.Flags.Locked, false);
            Effect.server.Run(Prefab_CodeLock_UnlockEffect, baseLock, 0, Vector3.zero, Vector3.forward);
        }
        private void SpawnTcLoot(StorageContainer container)
        {
            List<Loot> items;
            if (!config.Tc.TryGetValue(container.ShortPrefabName, out items))
            {
                return;
            }
            ItemContainer itemcontainer = container.GetComponent<StorageContainer>().inventory;
            foreach (var value in items)
            {
                var amount = value.Amount;
                var shortName = value.ShortName;
                var item = ItemManager.CreateByName(shortName, amount);
                if (itemcontainer == null || item == null) continue;
                item.MoveToContainer(itemcontainer, -1, true, true);
                item.parent = itemcontainer;
                item.MarkDirty();
            }
        }
        #endregion[Methods]

        #region[Data]
        private void SaveLockData()
        {
            if (LocknetID != null)
                Interface.Oxide.DataFileSystem.WriteObject($"{Name}/LockIds", LocknetID);
          
        }
        private void LoadLockData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Name}/LockIds"))
            {
                LocknetID = Interface.Oxide.DataFileSystem.ReadObject<List<NetworkableId>>($"{Name}/LockIds");
            }
            else
            {
                LocknetID = new List<NetworkableId>();
                Puts("creating a new Lock data file");
                SaveLockData();
            }
        }
        [JsonProperty("lock ids")]
        private List<NetworkableId> LocknetID = new List<NetworkableId>();

        #endregion[Data]

    }
}

// --- End of file: TcOptions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/trashcan ---
// --- Original File Path: T/Trashcan/Trashcan.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Linq;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Trashcan", "Smallo", "1.0.4")]
    [Description("Turn a Large Wood Box into a trashcan")]
    public class Trashcan : CovalencePlugin
    {
		#region Variables
        private ConfigData config;
		private int defaultMin = 225;
		private int defaultMax = 285;
		private int sizeIncrement = 62;
		private string breakEffect = "assets/bundled/prefabs/fx/entities/loot_barrel/gib.prefab";
		private const string trashCommandPermission = "trashcan.use";
        #endregion
		
		#region NoEscape
        [PluginReference] private Plugin NoEscape;
        private bool CurrentlyRaidBlocked(BasePlayer player)
        {
            return NoEscape?.Call<bool>("IsRaidBlocked", player) ?? false;
        }
        #endregion
		
		#region Startup		
		private void Loaded()
		{
			if (NoEscape == null || !NoEscape.IsLoaded)
				LogError("'No Escape' is not loaded, it is required for the raid block part of the script. If you intend to use the raid block config option please get 'No Escape' at https://umod.org/plugins/no-escape");
		}
		#endregion
		
		#region Configuration
        private class ConfigData
        {
            [JsonProperty(PropertyName = "SkinID")]
            public ulong TrashSkinID = 1595211850;

            [JsonProperty(PropertyName = "Trashcan Storage Slots")]
            public int TrashStorageSlots = 12;
			
            [JsonProperty("Enable Effects")]
            public bool EnableEffects = true;
			
            [JsonProperty("Lock Box While In Use (This prevents someone else from deleting your items)")]
            public bool LockBox = true;
			
            [JsonProperty("Disable During Raid Block (Requires No Escape plugin)")]
            public bool RaidBlock = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            config = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion Configuration
		
		#region localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TrashHeadText"] = "TRASHCAN",
                ["TrashSubText"] = "<color=#FF4433>Warning:</color> When you close this menu, everything in the storage will be deleted!",
                ["TrashNoBoxText"] = "<color=#FFFF00>Trash Can:</color> You do not have a Large Wooden Box in your hand.",
                ["TrashNoItemText"] = "<color=#FFFF00>Trash Can:</color> You do not have anything in your hand.",
                ["TrashCreatedText"] = "<color=#FFFF00>Trash Can:</color> You have turned your currently held Large Wooden Box into a trashcan.",
                ["TrashAlreadyText"] = "<color=#FFFF00>Trash Can:</color> This Large Wooden Box is already a trashcan.",
                ["RaidBlockedText"] = "<color=#FFFF00>Trash Can:</color> You are currently raid blocked, your items will not be deleted until you reuse the box after the raid is over."
            }, this);
        }
        #endregion localization
		
		#region Hooks
		private void OnLootEntity(BasePlayer player, StorageContainer storageContainer)
		{
			var baseEntity = storageContainer as BaseEntity;
			if (baseEntity.skinID != config.TrashSkinID)
				return;
			
			var itemContainer = storageContainer.inventory as ItemContainer;
			itemContainer.capacity = config.TrashStorageSlots;
			int addAmount = (RoundUp(config.TrashStorageSlots, 6) / 6) - 1;
			
			if (config.LockBox)
				itemContainer.entityOwner.SetFlag(BaseEntity.Flags.Locked, true);
			
			CreateUI(addAmount, player);
		}
		
		private void OnPlayerLootEnd(PlayerLoot inventory)
        {
            var player = inventory.baseEntity;
            if (player == null) return;
			
            foreach (ItemContainer container in inventory.containers)
			{
				if (container == null) continue;
				if (container.entityOwner == null) continue;
				
				if (container.entityOwner.skinID == config.TrashSkinID) {
					CuiHelper.DestroyUi(player, "TrashOverlay");
					int itemCount = container.itemList.Count;
					
					if (config.RaidBlock && CurrentlyRaidBlocked(player) && itemCount > 0) {
						if (config.LockBox)
							container.entityOwner.SetFlag(BaseEntity.Flags.Locked, false);
						
						player.ChatMessage(lang.GetMessage("RaidBlockedText",this, player.UserIDString));
						return;
					}
					
					if (!container.entityOwner.IsBusy()) {
						if (config.EnableEffects && itemCount > 0)
							Effect.server.Run(breakEffect, container.entityOwner.GetNetworkPosition());
						
						if (config.LockBox)
							container.entityOwner.SetFlag(BaseEntity.Flags.Locked, false);
						
						container.Clear();
					}
				}
			}
        }
		
		#endregion
		
		#region UI
		private CuiPanel TrashPanel(string anchorMin, string anchorMax, string color = "0 0 0 0", string offsetMin = "0", string offsetMax = "0")
        {
            return new CuiPanel
            {
                Image =
                {
                    Color = color
                },
                RectTransform =
                {
					OffsetMin = offsetMin,
					OffsetMax = offsetMax,
                    AnchorMin = anchorMin,
                    AnchorMax = anchorMax
                }
            };
        }
		
		private CuiLabel TrashLabel(string text, int i, float height, TextAnchor align = TextAnchor.MiddleLeft, int fontSize = 13, string xMin = "0", string xMax = "1", string color = "1.0 1.0 1.0 1.0")
        {
            return new CuiLabel
            {
                Text =
                {
                    Text = text,
                    FontSize = fontSize,
                    Align = align,
                    Color = color
                },
                RectTransform =
                {
                    AnchorMin = $"{xMin} {1 - height * i + i * 0.002f}",
                    AnchorMax = $"{xMax} {1 - height * (i - 1) + i * 0.002f}"
                }
            };
        }
		#endregion
		
		#region Functions
		private void CreateUI(int addAmount, BasePlayer player){
			CuiElementContainer TrashUI = new CuiElementContainer();
			TrashUI.Add(TrashPanel("0.5 0", "0.5 0", "1 0.96 0.88 0.15", $"192.5 {defaultMin + (sizeIncrement * addAmount)}", $"572.5 {defaultMax + (sizeIncrement * addAmount)}"), "Hud.Menu", "TrashOverlay");
			TrashUI.Add(TrashPanel("0 0.5", "1 1", "0.6 0.6 0.6 0.25"), "TrashOverlay", "TrashTextHeading");
			TrashUI.Add(TrashLabel(lang.GetMessage("TrashHeadText", this, player.UserIDString), 1, 1, TextAnchor.MiddleCenter, 18, "0", "1", "0.97 0.92 0.88 1"), "TrashTextHeading");
			TrashUI.Add(TrashPanel("0 0", "1 0.5", "0 0 0 0"), "TrashOverlay", "TrashTextSubtitle");
			TrashUI.Add(TrashLabel(lang.GetMessage("TrashSubText", this, player.UserIDString), 1, 1, TextAnchor.MiddleCenter, 11, "0", "1", "0.97 0.92 0.88 1"), "TrashTextSubtitle");
			CuiHelper.AddUi(player, TrashUI);
		}
		
		private int RoundUp(int numToRound, int multiple)
		{
			if (multiple == 0)
				return numToRound;

			int remainder = numToRound % multiple;
			if (remainder == 0)
				return numToRound;

			return numToRound + multiple - remainder;
		}
        #endregion
		
		#region Commands
		[Command("trash"), Permission(trashCommandPermission)]
		private void TrashCmd(IPlayer player, string command, string[] args)
        {
			BasePlayer bPlayer = player.Object as BasePlayer;
			
			var activeItem = bPlayer.GetActiveItem() as Item;
			string userString = bPlayer.UserIDString;
			if (activeItem == null) {
				bPlayer.ChatMessage(lang.GetMessage("TrashNoItemText", this, userString));
				return;
			}
			
			if (activeItem.info.shortname != "box.wooden.large") {
				bPlayer.ChatMessage(lang.GetMessage("TrashNoBoxText", this, userString));
				return;
			}
			
			if (activeItem.skin == config.TrashSkinID)
			{
				bPlayer.ChatMessage(lang.GetMessage("TrashAlreadyText", this, userString));
				return;
			}
			
			bPlayer.ChatMessage(lang.GetMessage("TrashCreatedText", this, userString));
			activeItem.skin = config.TrashSkinID;
            activeItem.MarkDirty();
		}
        #endregion
    }
}

// --- End of file: Trashcan.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/fishing ---
// --- Original File Path: T/Tsuri/Tsuri.cs ---

using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Fishing", "Colon Blow", "1.4.11")]
    class Fishing : RustPlugin
    {

        // tweaks for null checks
        // delcared access modifiers

        #region Loadup

        private Dictionary<ulong, string> GuiInfo = new Dictionary<ulong, string>();

        private void Loaded()
        {
            lang.RegisterMessages(messages, this);
            permission.RegisterPermission("fishing.allowed", this);
            permission.RegisterPermission("fishing.makepole", this);
        }

        #endregion

        #region Configuration

        private static PluginConfig config;

        private class PluginConfig
        {
            public GlobalSettings globalSettings { get; set; }
            public DefaultCatchSettings defaultCatchSettings { get; set; }
            public FishCatchSettings fishCatchSettings { get; set; }
            public LootCatchSettings lootCatchSettings { get; set; }

            public class GlobalSettings
            {
                [JsonProperty(PropertyName = "Global - Show Fish Catch Indicator")] public bool ShowFishCatchIcon { get; set; }
                [JsonProperty(PropertyName = "Global - Enable Random Item Condition Loss when Spear/Bow Fishing ? ")] public bool enableRandomLootBox { get; set; }
                [JsonProperty(PropertyName = "Global - Enable Timer when Spear Fishing Pole ? ")] public bool enableSpearTimer { get; set; }
                [JsonProperty(PropertyName = "Global - Enable Timer when Casting Fishing Pole ? ")] public bool enableCastTimer { get; set; }
                [JsonProperty(PropertyName = "Global - Enable Random Item Condition Loss when Spear/Bow Fishing ?")] public bool enableConditionLoss { get; set; }
                [JsonProperty(PropertyName = "Global - Random Item Conditon Loss Max percent : ")] public float conditionLossMax { get; set; }
                [JsonProperty(PropertyName = "Global - Random Item Conditon Loss Min percent : ")] public float conditionLossMin { get; set; }
                [JsonProperty(PropertyName = "Global - Allow Bonus from Weapons ? ")] public bool enableWeaponModifer { get; set; }
                [JsonProperty(PropertyName = "Global - Allow Bonus from Attire ? ")] public bool enableAttireModifer { get; set; }
                [JsonProperty(PropertyName = "Global - Allow Bonus from Items ? ")] public bool enableItemModifier { get; set; }
                [JsonProperty(PropertyName = "Global - Allow Bonus from Time of Day ? ")] public bool enableTimeModifier { get; set; }
                [JsonProperty(PropertyName = "Global - Seconds to Wait after Fishing Attempt with Casting Pole, if enabled (default 6 second) : ")] public float timeReCastPole { get; set; }
                [JsonProperty(PropertyName = "Global - Seconds to Wait after Fishing Attempt with Spear/Bow, if enabled (default 6 seconds) : ")] public float timeReAttack { get; set; }
                [JsonProperty(PropertyName = "Global - Random chests will despawn themselves after this amount of time (default 200 seconds) : ")] public float lootBoxDespawnTime { get; set; }
            }

            public class DefaultCatchSettings
            {
                [JsonProperty(PropertyName = "Catch Chance - Starting default chance to catch something (Percentage)")] public int chanceDefaultAMT { get; set; }
                [JsonProperty(PropertyName = "Catch Chance - Bonus - From Weapon (Percentage)")] public int chanceBonusWeaponAMT { get; set; }
                [JsonProperty(PropertyName = "Catch Chance - Bonus - From Attire (Percentage)")] public int chanceBonusAttireAMT { get; set; }
                [JsonProperty(PropertyName = "Catch Chance - Bonus - From Item (Percentage)")] public int chacneBonusItemAMT { get; set; }
                [JsonProperty(PropertyName = "Catch Chance - Bonus - From Time of Day (Percentage)")] public int chanceBonusTimeAMT { get; set; }

                [JsonProperty(PropertyName = "Attire Bonus - if player is wearing this, gets attire bonus (default Boonie Hat) ")] public int attireBonusID { get; set; }
                [JsonProperty(PropertyName = "Item Bonus - if player has in inventory this, get item bonus (default Pookie Bear ")] public int itemBonusID { get; set; }

                [JsonProperty(PropertyName = "Time Bonus 1 - if current time is after the hour of : ")] public int timeBonus1After { get; set; }
                [JsonProperty(PropertyName = "Time Bonus 1 - and current time is before the hour of : ")] public int timeBonus1Before { get; set; }
                [JsonProperty(PropertyName = "Time Bonus 2 - if current time is after the hour of : ")] public int timeBonus2After { get; set; }
                [JsonProperty(PropertyName = "Time Bonus 2 - and current time is before the hour of : ")] public int timeBonus2Before { get; set; }
            }

            public class FishCatchSettings
            {
                [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Common Fish 1 ")] public int common1catchchance { get; set; }
                [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Common Fish 2 ")] public int common2catchchance { get; set; }
                [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a UnCommon Fish ")] public int uncommoncatchchance { get; set; }
                [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Rare Fish ")] public int rarecatchchance { get; set; }
                [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Loot Box ")] public int randomitemchance { get; set; }

                [JsonProperty(PropertyName = "Amount - Common Fish 1 - When this is caught, Amount of Catch ")] public int common1catchamount { get; set; }
                [JsonProperty(PropertyName = "Amount - Common Fish 2 - When this is caught, Amount of Catch ")] public int common2catchamount { get; set; }
                [JsonProperty(PropertyName = "Amount - Uncommon Fish - When this is caught, Amount of Catch ")] public int uncommoncatchamount { get; set; }
                [JsonProperty(PropertyName = "Amount - Rare Fish - When this is caught, Amount of Catch ")] public int rarecatchamount { get; set; }

                [JsonProperty(PropertyName = "ItemID - Common Fish 1 - Item ID of Catch (default is Minnows)")] public int common1catchitemid { get; set; }
                [JsonProperty(PropertyName = "ItemID - Common Fish 2 - Item ID of Catch (default is Small Trout)")] public int common2catchitemid { get; set; }
                [JsonProperty(PropertyName = "ItemID - Uncommon Fish - Item ID of Catch (default is Small Trout)")] public int uncommoncatchitemid { get; set; }
                [JsonProperty(PropertyName = "ItemID - Rare Fish - Item ID of Catch (default is Small Trout)")] public int rarecatchitemid { get; set; }

                [JsonProperty(PropertyName = "Icon - Common Fish 1 - Icon URL to show when this fish is caught (if enabled) ")] public string common1iconurl { get; set; }
                [JsonProperty(PropertyName = "Icon - Common Fish 2 - Icon URL to show when this fish is caught (if enabled) ")] public string common2iconurl { get; set; }
                [JsonProperty(PropertyName = "Icon - Uncommon Fish - Icon URL to show when this fish is caught (if enabled) ")] public string uncommoniconurl { get; set; }
                [JsonProperty(PropertyName = "Icon - Rare Fish - Icon URL to show when this fish is caught (if enabled) ")] public string rareiconurl { get; set; }
            }

            public class LootCatchSettings
            {
                [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 1 ")] public int randomlootprefab1chance { get; set; }
                [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 2 ")] public int randomlootprefab2chance { get; set; }
                [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 3 ")] public int randomlootprefab3chance { get; set; }
                [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 4 ")] public int randomlootprefab4chance { get; set; }
                [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 5 ")] public int randomlootprefab5chance { get; set; }

                [JsonProperty(PropertyName = "Chest Type 1 - Prefab string ")] public string randomlootprefab1 { get; set; }
                [JsonProperty(PropertyName = "Chest Type 2 - Prefab string ")] public string randomlootprefab2 { get; set; }
                [JsonProperty(PropertyName = "Chest Type 3 - Prefab string ")] public string randomlootprefab3 { get; set; }
                [JsonProperty(PropertyName = "Chest Type 4 - Prefab string ")] public string randomlootprefab4 { get; set; }
                [JsonProperty(PropertyName = "Chest Type 5 - Prefab string ")] public string randomlootprefab5 { get; set; }

                [JsonProperty(PropertyName = "Icon - Icon URL to show when this fish is caught (if enabled)")] public string randomitemiconurl { get; set; }
            }

            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                globalSettings = new PluginConfig.GlobalSettings
                {
                    ShowFishCatchIcon = true,
                    enableRandomLootBox = true,
                    enableSpearTimer = true,
                    enableCastTimer = true,
                    enableConditionLoss = true,
                    conditionLossMax = 5f,
                    conditionLossMin = 1f,
                    enableWeaponModifer = true,
                    enableAttireModifer = true,
                    enableItemModifier = true,
                    enableTimeModifier = true,
                    timeReCastPole = 6f,
                    timeReAttack = 6f,
                    lootBoxDespawnTime = 200f,
                },
                defaultCatchSettings = new PluginConfig.DefaultCatchSettings
                {
                    chanceDefaultAMT = 10,
                    chanceBonusWeaponAMT = 10,
                    chanceBonusAttireAMT = 10,
                    chacneBonusItemAMT = 10,
                    chanceBonusTimeAMT = 10,

                    attireBonusID = -23994173,
                    itemBonusID = -1651220691,

                    timeBonus1After = 6,
                    timeBonus1Before = 8,

                    timeBonus2After = 16,
                    timeBonus2Before = 19,
                },
                fishCatchSettings = new PluginConfig.FishCatchSettings
                {
                    common1catchchance = 40,
                    common2catchchance = 30,
                    uncommoncatchchance = 20,
                    rarecatchchance = 8,
                    randomitemchance = 2,

                    common1catchamount = 5,
                    common2catchamount = 1,
                    uncommoncatchamount = 2,
                    rarecatchamount = 5,

                    common1catchitemid = -542577259,
                    common2catchitemid = -1878764039,
                    uncommoncatchitemid = -1878764039,
                    rarecatchitemid = -1878764039,

                    common1iconurl = "http://i.imgur.com/rBEmhpg.png",
                    common2iconurl = "http://i.imgur.com/HftxU00.png",
                    uncommoniconurl = "http://i.imgur.com/xReDQM1.png",
                    rareiconurl = "http://i.imgur.com/jMZxGf1.png",
                },
                lootCatchSettings = new PluginConfig.LootCatchSettings
                {
                    randomlootprefab1chance = 40,
                    randomlootprefab2chance = 5,
                    randomlootprefab3chance = 15,
                    randomlootprefab4chance = 20,
                    randomlootprefab5chance = 20,
                    randomlootprefab1 = "assets/bundled/prefabs/radtown/crate_basic.prefab",
                    randomlootprefab2 = "assets/bundled/prefabs/radtown/crate_elite.prefab",
                    randomlootprefab3 = "assets/bundled/prefabs/radtown/crate_mine.prefab",
                    randomlootprefab4 = "assets/bundled/prefabs/radtown/crate_normal.prefab",
                    randomlootprefab5 = "assets/bundled/prefabs/radtown/crate_normal_2.prefab",
                    randomitemiconurl = "http://i.imgur.com/y2scGmZ.png",
                }
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created!!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Localization

        private string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            ["missedfish"] = "You Missed the fish....",
            ["notlookingatwater"] = "You must be aiming at water !!!!",
            ["notstandinginwater"] = "You must be standing in water !!!!",
            ["alreadyfishing"] = "You are already fishing !!",
            ["toosoon"] = "Please wait to try that again !!",
            ["cantmove"] = "You must stay still while fishing !!!",
            ["wrongweapon"] = "You are not holding a fishing pole !!!",
            ["correctitem"] = "You must be holding a spear to make a fishing pole !! ",
            ["commonfish1"] = "You Got a Savis Island Swordfish",
            ["commonfish2"] = "You Got a Hapis Island RazorJaw",
            ["uncommonfish1"] = "You Got a Colon BlowFish",
            ["rarefish1"] = "You Got a Craggy Island Dorkfish",
            ["randomitem"] = "You found something in the water !!!",
            ["chancetext1"] = "Your chance to catch a fish is : ",
            ["chancetext2"] = "at Current time of : "
        };

        #endregion

        #region Commands

        [ChatCommand("castpole")]
        private void cmdChatcastfishingpole(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player, "fishing.allowed")) return;
            if (ValidateCastFish(player)) ProcessCastFish(player);
        }

        [ConsoleCommand("castpole")]
        private void cmdConsoleCastFishingPole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!IsAllowed(player, "fishing.allowed")) return;
                if (ValidateCastFish(player)) ProcessCastFish(player);
            }
        }

        [ChatCommand("fishchance")]
        private void cmdChatfishchance(BasePlayer player, string command, string[] args)
        {
            int catchchance = CatchFishModifier(player);
            SendReply(player, lang.GetMessage("chancetext1", this) + catchchance + "%\n");
        }

        [ChatCommand("makepole")]
        private void cmdChatMakeFishingPole(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player, "fishing.makepole")) return;
            MakeFishingPole(player);
        }

        [ConsoleCommand("makepole")]
        private void cmdConsoleMakeFishingPole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!IsAllowed(player, "fishing.makepole")) return;
                MakeFishingPole(player);
            }
        }

        #endregion

        #region Craft Fishing Pole

        private void MakeFishingPole(BasePlayer player)
        {
            Item activeItem = player.GetActiveItem();
            if (activeItem != null && (activeItem.info.shortname.Contains("spear") || activeItem.info.shortname.Contains("fishingrod")))
            {
                activeItem.Remove(0f);
                ulong skinid = 1393234529;
                if (activeItem.info.shortname == "spear.stone") skinid = 1393231089;
                Item pole = ItemManager.CreateByItemID(1569882109, 1, skinid);
                if (!player.inventory.GiveItem(pole, null))
                {
                    pole.Drop(player.eyes.position, Vector3.forward, new Quaternion());
                    SendInfoMessage(player, "No Room in Inventory, Dropped New Fishing Pole !!", 5f);
                    return;
                }
                SendInfoMessage(player, "New Fishing Pole Placed in your Inventory !!", 5f);
                return;
            }
            SendReply(player, msg("correctitem", player.UserIDString));
        }

        #endregion

        #region Cast Fishing Process

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            var isfishing = player.GetComponent<FishingControl>();
            if (isfishing)
            {
                if (input.WasJustPressed(BUTTON.FORWARD)) isfishing.playermoved = true;
                if (input.WasJustPressed(BUTTON.BACKWARD)) isfishing.playermoved = true;
                if (input.WasJustPressed(BUTTON.RIGHT)) isfishing.playermoved = true;
                if (input.WasJustPressed(BUTTON.LEFT)) isfishing.playermoved = true;
                if (input.WasJustPressed(BUTTON.JUMP)) isfishing.playermoved = true;
            }
            if (UsingCastRod(player) && input.WasJustPressed(BUTTON.FIRE_PRIMARY))
            {

                if (ValidateCastFish(player)) ProcessCastFish(player);
            }
        }

        private bool ValidateCastFish(BasePlayer player)
        {
            if (IsFishing(player)) { SendReply(player, msg("alreadyfishing", player.UserIDString)); return false; }
            if (HasFishingCooldown(player)) { SendReply(player, msg("toosoon", player.UserIDString)); return false; }
            if (!LookingAtWater(player)) { SendReply(player, msg("notlookingatwater", player.UserIDString)); return false; }
            return true;
        }

        private void ProcessCastFish(BasePlayer player)
        {
            Vector3 castPointSpawn = new Vector3();
            RaycastHit castPointHit;
            if (Physics.Raycast(player.eyes.HeadRay(), out castPointHit, 50f, UnityEngine.LayerMask.GetMask("Water"))) castPointSpawn = castPointHit.point;
            var addfishing = player.gameObject.AddComponent<FishingControl>();
            addfishing.SpawnBobber(castPointSpawn);
        }

        #endregion

        #region Cast Fishing Control

        private class FishingControl : MonoBehaviour
        {
            private BasePlayer player;
            public string anchormaxstr;
            private Fishing fishing;
            public float counter;
            private BaseEntity bobber;
            public bool playermoved;
            private Vector3 bobberpos;

            private void Awake()
            {
                fishing = new Fishing();
                player = base.GetComponentInParent<BasePlayer>();
                counter = config.globalSettings.timeReCastPole;
                if (!config.globalSettings.enableCastTimer || counter < 0.1f) counter = 0.1f;
                playermoved = false;
            }

            public void SpawnBobber(Vector3 pos)
            {
                float waterheight = TerrainMeta.WaterMap.GetHeight(pos);

                pos = new Vector3(pos.x, waterheight, pos.z);
                var createdPrefab = GameManager.server.CreateEntity("assets/prefabs/tools/fishing rod/bobber/bobber.prefab", pos, Quaternion.identity);
                bobber = createdPrefab?.GetComponent<BaseEntity>();
                bobber.enableSaving = false;
                bobber.transform.eulerAngles = new Vector3(270, 0, 0);
                bobber?.Spawn();
                bobberpos = bobber.transform.position;
            }

            private void FixedUpdate()
            {
                bobberpos = bobber.transform.position;
                if (counter <= 0f) { RollForFish(bobberpos); return; }
                if (playermoved) { PlayerMoved(); return; }
                counter = counter - 0.1f;
                fishingindicator(player, counter);
            }

            private void PlayerMoved()
            {
                if (bobber != null && !bobber.IsDestroyed) { bobber.Invoke("KillMessage", 0.1f); }
                fishing.SendReply(player, fishing.msg("cantmove", player.UserIDString));
                OnDestroy();
            }

            private void RollForFish(Vector3 pos)
            {
                if (player != null) fishing.FishChanceRoll(player, pos);
                if (bobber != null && !bobber.IsDestroyed) { bobber.Invoke("KillMessage", 0.1f); }
                OnDestroy();
            }

            private string GetGUIString(float counter)
            {
                string guistring = "0.60 0.145";
                var getrefreshtime = config.globalSettings.timeReCastPole;
                if (counter < getrefreshtime * 0.1) { guistring = "0.42 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.2) { guistring = "0.44 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.3) { guistring = "0.46 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.4) { guistring = "0.48 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.5) { guistring = "0.50 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.6) { guistring = "0.52 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.7) { guistring = "0.54 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.8) { guistring = "0.56 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.9) { guistring = "0.58 0.145"; return guistring; }
                return guistring;
            }

            public void fishingindicator(BasePlayer player, float counter)
            {
                DestroyCui(player);
                string anchormaxstr = GetGUIString(counter);
                var fishingindicator = new CuiElementContainer();

                fishingindicator.Add(new CuiButton
                {
                    Button = { Command = $"", Color = "0.0 0.0 1.0 0.6" },
                    RectTransform = { AnchorMin = "0.40 0.125", AnchorMax = anchormaxstr },
                    Text = { Text = (""), FontSize = 14, Color = "1.0 1.0 1.0 0.6", Align = TextAnchor.MiddleRight }
                }, "Overall", "FishingGui");
                CuiHelper.AddUi(player, fishingindicator);
            }

            private void DestroyCui(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, "FishingGui");
            }

            public void OnDestroy()
            {
                DestroyCui(player);
                Destroy(this);
            }
        }

        #endregion

        #region Spear Fishing Process

        private void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
        {
            if (attacker == null || hitInfo == null) return;
            if (IsAllowed(attacker, "fishing.allowed") || IsAllowed(attacker, "fishing.unlimited"))
            {
                if (HasFishingCooldown(attacker)) { SendReply(attacker, msg("toosoon", attacker.UserIDString)); return; }
                if (UsingSpearRod(hitInfo))
                {
                    if (LookingAtWater(attacker) || attacker.IsHeadUnderwater())
                    {
                        ProcessSpearFish(attacker, hitInfo);
                    }
                }
            }
        }

        private void ProcessSpearFish(BasePlayer attacker, HitInfo hitInfo)
        {
            if (config.globalSettings.enableConditionLoss)
            {
                float maxloss = 1f - (config.globalSettings.conditionLossMax / 100f);
                float minloss = 1f - (config.globalSettings.conditionLossMin / 100f);
                Item activeItem = attacker.GetActiveItem();
                if (activeItem != null) activeItem.condition = activeItem.condition * UnityEngine.Random.Range(minloss, maxloss);
            }
            if (attacker != null && hitInfo.HitPositionWorld != null) FishChanceRoll(attacker, hitInfo.HitPositionWorld);
            if (config.globalSettings.enableSpearTimer) attacker.gameObject.AddComponent<SpearFishingControl>();
        }

        #endregion

        #region Spear Fishing Control

        private class SpearFishingControl : MonoBehaviour
        {
            private BasePlayer player;
            public string anchormaxstr;
            private Fishing fishing;
            public float counter;

            private void Awake()
            {
                fishing = new Fishing();
                player = base.GetComponentInParent<BasePlayer>();
                counter = config.globalSettings.timeReAttack;
                if (!config.globalSettings.enableSpearTimer || counter < 0.1f) counter = 0.1f;
            }

            private void FixedUpdate()
            {
                if (counter <= 0f) OnDestroy();
                counter = counter - 0.1f;
                fishingindicator(player, counter);
            }

            private string GetGUIString(float counter)
            {
                string guistring = "0.60 0.145";
                var getrefreshtime = config.globalSettings.timeReAttack;
                if (counter < getrefreshtime * 0.1) { guistring = "0.42 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.2) { guistring = "0.44 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.3) { guistring = "0.46 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.4) { guistring = "0.48 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.5) { guistring = "0.50 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.6) { guistring = "0.52 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.7) { guistring = "0.54 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.8) { guistring = "0.56 0.145"; return guistring; }
                if (counter < getrefreshtime * 0.9) { guistring = "0.58 0.145"; return guistring; }
                return guistring;
            }

            public void fishingindicator(BasePlayer player, float counter)
            {
                DestroyCui(player);
                var getrefreshtime = config.globalSettings.timeReAttack;
                string anchormaxstr = GetGUIString(counter);
                var fishingindicator = new CuiElementContainer();

                fishingindicator.Add(new CuiButton
                {
                    Button = { Command = $"", Color = "1.0 0.0 0.0 0.6" },
                    RectTransform = { AnchorMin = "0.40 0.125", AnchorMax = anchormaxstr },
                    Text = { Text = (""), FontSize = 14, Color = "1.0 1.0 1.0 0.6", Align = TextAnchor.MiddleRight }
                }, "Overall", "FishingGui");
                CuiHelper.AddUi(player, fishingindicator);
            }

            private void DestroyCui(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, "FishingGui");
            }

            public void OnDestroy()
            {
                DestroyCui(player);
                Destroy(this);
            }
        }

        #endregion

        #region Fish Catch Process

        private void FishChanceRoll(BasePlayer player, Vector3 hitloc)
        {
            int roll = IntUtil.Random(1, 101);
            int totatchance = CatchFishModifier(player);

            if (roll < totatchance)
            {
                FishTypeRoll(player, hitloc);
                return;
            }
            else
                SendReply(player, msg("missedfish", player.UserIDString));
            return;
        }

        private int CatchFishModifier(BasePlayer player)
        {
            int chances = new int();
            chances = config.defaultCatchSettings.chanceDefaultAMT;
            if (config.globalSettings.enableWeaponModifer)
            {
                Item activeItem = player.GetActiveItem();
                if (activeItem != null)
                {
                    if (activeItem.info.shortname == "spear.stone" || activeItem.skin == 1393231089 || activeItem.info.shortname == "crossbow" || activeItem.info.shortname == "bow.compound")
                    {
                        chances += config.defaultCatchSettings.chanceBonusWeaponAMT;
                    }
                }
            }
            if (config.globalSettings.enableAttireModifer)
            {
                int hasBoonieOn = player.inventory.containerWear.GetAmount(config.defaultCatchSettings.attireBonusID, true);
                if (hasBoonieOn > 0) chances += config.defaultCatchSettings.chanceBonusAttireAMT;
            }
            if (config.globalSettings.enableItemModifier)
            {
                int hasPookie = player.inventory.containerMain.GetAmount(config.defaultCatchSettings.itemBonusID, true);
                if (hasPookie > 0) chances += config.defaultCatchSettings.chacneBonusItemAMT;
            }
            if (config.globalSettings.enableTimeModifier)
            {
                var currenttime = TOD_Sky.Instance.Cycle.Hour;
                if ((currenttime < config.defaultCatchSettings.timeBonus1Before && currenttime > config.defaultCatchSettings.timeBonus1After) || (currenttime < config.defaultCatchSettings.timeBonus2Before && currenttime > config.defaultCatchSettings.timeBonus2After)) chances += config.defaultCatchSettings.chanceBonusTimeAMT;
            }
            int totalchance = chances;
            return totalchance;
        }

        private void FishTypeRoll(BasePlayer player, Vector3 hitloc)
        {
            int totalfishtypechance = config.fishCatchSettings.rarecatchchance + config.fishCatchSettings.uncommoncatchchance + config.fishCatchSettings.common1catchchance + config.fishCatchSettings.common2catchchance;
            var fishtyperoll = IntUtil.Random(1, totalfishtypechance + 1);
            if (config.globalSettings.enableRandomLootBox)
            {
                if (fishtyperoll < config.fishCatchSettings.randomitemchance)
                {
                    catchFishCui(player, config.lootCatchSettings.randomitemiconurl);
                    SendReply(player, msg("randomitem", player.UserIDString));
                    SpawnLootBox(player, hitloc);
                    return;
                }
            }
            if (fishtyperoll < config.fishCatchSettings.rarecatchchance)
            {
                catchFishCui(player, config.fishCatchSettings.rareiconurl);
                SendReply(player, msg("rarefish1", player.UserIDString));
                player.inventory.GiveItem(ItemManager.CreateByItemID(config.fishCatchSettings.rarecatchitemid, config.fishCatchSettings.rarecatchamount));
                player.Command("note.inv", config.fishCatchSettings.rarecatchitemid, config.fishCatchSettings.rarecatchamount);
                return;
            }
            if (fishtyperoll < config.fishCatchSettings.rarecatchchance + config.fishCatchSettings.uncommoncatchchance)
            {
                catchFishCui(player, config.fishCatchSettings.uncommoniconurl);
                SendReply(player, msg("uncommonfish1", player.UserIDString));
                player.inventory.GiveItem(ItemManager.CreateByItemID(config.fishCatchSettings.uncommoncatchitemid, config.fishCatchSettings.uncommoncatchamount));
                player.Command("note.inv", config.fishCatchSettings.uncommoncatchitemid, config.fishCatchSettings.uncommoncatchamount);
                return;
            }
            if (fishtyperoll < config.fishCatchSettings.rarecatchchance + config.fishCatchSettings.uncommoncatchchance + config.fishCatchSettings.common2catchchance)
            {
                catchFishCui(player, config.fishCatchSettings.common2iconurl);
                SendReply(player, msg("commonfish2", player.UserIDString));
                player.inventory.GiveItem(ItemManager.CreateByItemID(config.fishCatchSettings.common2catchitemid, config.fishCatchSettings.common2catchamount));
                player.Command("note.inv", config.fishCatchSettings.common2catchitemid, config.fishCatchSettings.common2catchamount);
                return;
            }
            if (fishtyperoll < config.fishCatchSettings.rarecatchchance + config.fishCatchSettings.uncommoncatchchance + config.fishCatchSettings.common2catchchance + config.fishCatchSettings.common1catchchance)
            {
                catchFishCui(player, config.fishCatchSettings.common1iconurl);
                SendReply(player, msg("commonfish1", player.UserIDString));
                player.inventory.GiveItem(ItemManager.CreateByItemID(config.fishCatchSettings.common1catchitemid, config.fishCatchSettings.common1catchamount));
                player.Command("note.inv", config.fishCatchSettings.common1catchitemid, config.fishCatchSettings.common1catchamount);
                return;
            }
        }

        #endregion

        #region Fish Loot Process

        private void SpawnLootBox(BasePlayer player, Vector3 hitloc)
        {
            var randomlootprefab = config.lootCatchSettings.randomlootprefab1;
            var rlroll = IntUtil.Random(1, 6);
            if (rlroll == 1) randomlootprefab = config.lootCatchSettings.randomlootprefab1;
            if (rlroll == 2) randomlootprefab = config.lootCatchSettings.randomlootprefab2;
            if (rlroll == 3) randomlootprefab = config.lootCatchSettings.randomlootprefab3;
            if (rlroll == 4) randomlootprefab = config.lootCatchSettings.randomlootprefab4;
            if (rlroll == 5) randomlootprefab = config.lootCatchSettings.randomlootprefab5;

            var createdPrefab = GameManager.server.CreateEntity(randomlootprefab, hitloc);
            BaseEntity treasurebox = createdPrefab?.GetComponent<BaseEntity>();
            treasurebox.enableSaving = false;
            treasurebox?.Spawn();
            timer.Once(config.globalSettings.lootBoxDespawnTime, () => CheckTreasureDespawn(treasurebox));
        }

        private void CheckTreasureDespawn(BaseEntity treasurebox)
        {
            if (treasurebox != null) treasurebox.Kill(BaseNetworkable.DestroyMode.None);
        }

        #endregion

        #region Helpers

        private bool IsFishing(BasePlayer baseplayer)
        {
            var isfishing = baseplayer.GetComponent<FishingControl>();
            if (isfishing) return true;
            return false;
        }

        private bool HasFishingCooldown(BasePlayer baseplayer)
        {
            var incooldown = baseplayer.GetComponent<SpearFishingControl>();
            if (incooldown) return true;
            return false;
        }

        private bool UsingCastRod(BasePlayer player)
        {
            Item activeItem = player.GetActiveItem();
            if (activeItem != null && activeItem.info.shortname.Contains("fishingrod")) return true;
            return false;
        }

        private bool UsingSpearRod(HitInfo hitInfo)
        {
            if (hitInfo.WeaponPrefab.ToString().Contains("spear") || hitInfo.WeaponPrefab.ToString().Contains("bow")) return true;
            return false;
        }

        private bool LookingAtWater(BasePlayer player)
        {
            float waterHitDistance = 0;
            float groundHitDistance = 100f;
            UnityEngine.Ray ray = new UnityEngine.Ray(player.eyes.position, player.eyes.HeadForward());

            var rayHitWaterLayer = UnityEngine.Physics.RaycastAll(ray, 25f, UnityEngine.LayerMask.GetMask("Water"));
            var rayHitGroundLayer = UnityEngine.Physics.RaycastAll(ray, 25f, UnityEngine.LayerMask.GetMask("Terrain", "World", "Construction"));

            foreach (var hit in rayHitWaterLayer)
            {
                waterHitDistance = hit.distance;
            }
            foreach (var hit in rayHitGroundLayer)
            {
                groundHitDistance = hit.distance;
            }
            if (waterHitDistance > 0 && groundHitDistance == null) return true;
            if (waterHitDistance < groundHitDistance && waterHitDistance > 0) return true;
            return false;
        }

        private void SendInfoMessage(BasePlayer player, string message, float time)
        {
            player?.SendConsoleCommand("gametip.showgametip", message);
            timer.Once(time, () => player?.SendConsoleCommand("gametip.hidegametip"));
        }

        private bool IsAllowed(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;
            return false;
        }

        private class IntUtil
        {
            private static System.Random random;

            private static void Init()
            {
                if (random == null) random = new System.Random();
            }
            public static int Random(int min, int max)
            {
                Init();
                return random.Next(min, max);
            }
        }

        #endregion

        #region Hooks

        private void OnPlayerRespawned(BasePlayer player)
        {
            var isfishing = player.GetComponent<FishingControl>();
            if (isfishing) isfishing.OnDestroy();
            var hascooldown = player.GetComponent<SpearFishingControl>();
            if (hascooldown) hascooldown.OnDestroy();
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var isfishing = player.GetComponent<FishingControl>();
            if (isfishing) isfishing.OnDestroy();
            var hascooldown = player.GetComponent<SpearFishingControl>();
            if (hascooldown) hascooldown.OnDestroy();
        }

        private void Unload()
        {
            DestroyAll<FishingControl>();
            DestroyAll<SpearFishingControl>();
            foreach (var player in BasePlayer.activePlayerList)
            {
                string guiInfo;
                if (GuiInfo.TryGetValue(player.userID, out guiInfo)) CuiHelper.DestroyUi(player, guiInfo);
            }
        }

        private void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        #endregion

        #region GUI

        private void catchFishCui(BasePlayer player, string fishicon)
        {
            if (config.globalSettings.ShowFishCatchIcon) FishingGui(player, fishicon);
        }

        private void FishingGui(BasePlayer player, string fishicon)
        {
            DestroyCui(player);

            var elements = new CuiElementContainer();
            GuiInfo[player.userID] = CuiHelper.GetGuid();

            if (config.globalSettings.ShowFishCatchIcon)
            {
                elements.Add(new CuiElement
                {
                    Name = GuiInfo[player.userID],
                    Parent = "Overlay",
                    Components =
                    {
                        new CuiRawImageComponent { Color = "1 1 1 1", Url = fishicon, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent { AnchorMin = "0.220 0.03",  AnchorMax = "0.260 0.10" }
                    }
                });
            }

            CuiHelper.AddUi(player, elements);
            timer.Once(1f, () => DestroyCui(player));
        }


        private void DestroyCui(BasePlayer player)
        {
            string guiInfo;
            if (GuiInfo.TryGetValue(player.userID, out guiInfo)) CuiHelper.DestroyUi(player, guiInfo);
        }

        #endregion
    }
}

// --- End of file: Tsuri.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/teleport ---
// --- Original File Path: T/Teleport/Teleport.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Teleport", "Orf1", "1.0.1")]
    [Description("Lets players with permission teleport to any specified position.")]
    class Teleport : CovalencePlugin
    {
        private void Init()
        {
            permission.RegisterPermission("teleport.use", this);
            LoadDefaultMessages();
        }
        [Command("teleport")]
        private void SetCommand(IPlayer player, string command, string[] args)
        {
            if (player.HasPermission("teleport.use"))
            {
                if (args.Length == 3)
                {
                    try
                    {
                        float x = Int32.Parse(args[0]);
                        float y = Int32.Parse(args[1]);
                        float z = Int32.Parse(args[2]);
                        
                        var newPos = new GenericPosition(x, y, z);
                        player.Teleport(newPos);

                        string message = lang.GetMessage("Success", this, player.Id);
                        player.Message(message);
                    }
                    catch (FormatException)
                    {
                        string message = lang.GetMessage("InvalidUsage", this, player.Id);
                        player.Message(message);
                    }
                }
                else
                {
                    string message = lang.GetMessage("InvalidUsage", this, player.Id);
                    player.Message(message);
                }
            }
            else
            {
                string message = lang.GetMessage("NoPermission", this, player.Id);
                player.Message(message);
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Success"] = "You have teleported successfully.",
                ["NoPermission"] = "You do not have permission to use this command!",
                ["InvalidUsage"] = "Invalid usage. /teleport [x] [y] [z]"
            }, this);
        }
    }
}

// --- End of file: Teleport.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/turret-manager ---
// --- Original File Path: T/TurretManager/TurretManager.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core.Plugins;
using ProtoBuf;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Turret Manager", "OrangeDoggo", "1.2.0")]
    [Description("Allows you to place down a turret fast & easy. (Auto fill up turret,Auto auth self (or/and friends)")]
    internal class TurretManager : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private Plugin Friends;

        private Configuration PluginConfig;

        private const string autoFillPerm = "turretmanager.autofill";
        private const string autoAuthPerm = "turretmanager.autoauth";
        private const string autoTogglePerm = "turretmanager.autotoggle";

        private ItemDefinition ammoToLoad;
        private ItemDefinition gunToLoad;

        #endregion

        #region Hooks

        private void Init()
        {
            if (!PluginConfig.LockAutoFilledTurrets)
            {
                Unsubscribe(nameof(OnEntityDeath));
                Unsubscribe(nameof(OnTurretToggle));
                Unsubscribe(nameof(CanMoveItem));
            }
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(autoFillPerm, this);
            permission.RegisterPermission(autoAuthPerm, this);
            permission.RegisterPermission(autoTogglePerm, this);

            gunToLoad = ItemManager.FindItemDefinition(PluginConfig.GunShortName);
            if (gunToLoad == null)
            {
                LogError("Invalid item for Gun");
                return;
            };

            if (gunToLoad.category != ItemCategory.Weapon)
                LogError($"Item '{gunToLoad.shortname}' isn't a valid weapon!");
            else
                ammoToLoad = (ItemManager.Create(gunToLoad).GetHeldEntity() as BaseProjectile)?.primaryMagazine.ammoType;
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            BasePlayer ownerPlayer = plan?.GetOwnerPlayer();
            if (ownerPlayer == null)
                return;

            BaseEntity entity = go?.ToBaseEntity();
            if (entity == null)
                return;

            AutoTurret turret = entity as AutoTurret;
            if (turret == null)
                return;

            if (HasPermission(ownerPlayer, autoAuthPerm))
            {
                if (PluginConfig.AutoAuthFriends && Friends != null)
                {
                    string[] friendsList = Friends.Call<string[]>("GetFriendList", ownerPlayer.userID);
                    if (friendsList != null)
                    {
                        foreach (string friendUserId in friendsList)
                        {
                            BasePlayer friend = BasePlayer.Find(friendUserId);
                            if (friend == null) continue;

                            if (turret.authorizedPlayers.All(x => x.userid != friend.userID))
                            {
                                turret.authorizedPlayers.Add(new PlayerNameID
                                {
                                    userid = friend.userID,
                                    username = friend.UserIDString
                                });
                            }
                        }
                    }
                }

                if (turret.authorizedPlayers.All(player => player.userid != ownerPlayer.userID))
                {
                    turret.authorizedPlayers.Add(new PlayerNameID
                    {
                        userid = ownerPlayer.userID, 
                        username = ownerPlayer.UserIDString
                    });
                }
            }

            if (HasPermission(ownerPlayer, autoFillPerm))
            {
                if (ammoToLoad != null && gunToLoad != null)
                {
                    var weaponItem = ItemManager.Create(gunToLoad);
                    weaponItem.MoveToContainer(turret.inventory, 0);

                    var heldWeapon = weaponItem.GetHeldEntity() as BaseProjectile;
                    heldWeapon.primaryMagazine.contents = 0;

                    turret.UpdateAttachedWeapon();
                    turret.CancelInvoke(turret.UpdateAttachedWeapon);

                    var weapon = turret.GetAttachedWeapon();
                    weapon.primaryMagazine.contents = weapon.primaryMagazine.capacity;

                    for (var i = 0; i < PluginConfig.AmountOfStacks; i++)
                    {
                        ItemManager.Create(ammoToLoad, PluginConfig.AmmoStackSize).MoveToContainer(turret.inventory, i + 1);
                    }

                    if (PluginConfig.LockAutoFilledTurrets)
                        turret.inventory.SetFlag(ItemContainer.Flag.IsLocked, true);
                }
                else
                {
                    LogError("{0} definition is null. Please contact the plugin author if this happens again.", ammoToLoad == null ? "Weapon ammo" : gunToLoad == null ? "Weapon" : ammoToLoad == null && gunToLoad == null ? "Weapon and Ammo" : "");
                }
            }

            if (HasPermission(ownerPlayer, autoTogglePerm))
            {
                turret.SetOnline();
                var turretSwitch = turret.GetComponentInChildren<ElectricSwitch>();
                if (turretSwitch != null)
                    turretSwitch.SetSwitch(true);
            }

            turret.SendNetworkUpdateImmediate();
        }

        private void OnEntityDeath(AutoTurret turret)
        {
            if (turret != null && IsTurretLocked(turret))
                turret.inventory.Kill();
        }

        private void OnTurretToggle(AutoTurret turret)
        {
            // Remove items if powering down while locked and out of ammo
            // Otherwise, the turret would be unusable other than picking it up
            if (turret != null && turret.IsOnline() && IsTurretLocked(turret) && GetTotalAmmo(turret) == 0)
            {
                turret.inventory.Clear();
                turret.inventory.SetFlag(ItemContainer.Flag.IsLocked, false);
            }
        }

        private object CanMoveItem(Item item)
        {
            if (item.parent == null) return null;

            var turret = item.parent.entityOwner as AutoTurret;
            if (turret == null) return null;

            // Fix issue where right-clicking an item in a locked turret inventory allows moving it
            if (item.parent.IsLocked())
                return false;

            return null;
        }

        #endregion

        #region Helper Methods

        private bool HasPermission(BasePlayer player, string perm) =>
            permission.UserHasPermission(player.UserIDString, perm) || PluginConfig.AdminBypass && (permission.UserHasGroup(player.UserIDString, "admin"));

        private bool IsTurretLocked(AutoTurret turret) =>
            turret.inventory != null && turret.inventory.HasFlag(ItemContainer.Flag.IsLocked);

        private int GetTotalAmmo(AutoTurret turret)
        {
            if (turret == null || turret.inventory == null)
                return 0;

            var weapon = turret.GetAttachedWeapon();
            if (weapon == null)
                return 0;

            // AutoTurret.GetTotalAmmo() only includes the reserve ammo, not the loaded ammo
            return weapon.primaryMagazine.contents + turret.GetTotalAmmo();
        }

        #endregion

        #region Configuration

        internal class Configuration : SerializableConfiguration
        {
            [JsonProperty("Gun (Shortname)")]
            public string GunShortName = "rifle.ak";

            [JsonProperty("Ammo amount")]
            public int AmmoStackSize = 128;

            [JsonProperty("Stack amount")]
            public int AmountOfStacks = 6;

            [JsonProperty("Lock auto filled turrets (true/false)")]
            public bool LockAutoFilledTurrets = false;

            [JsonProperty("Auto Authorize Friends (Requires Friends API)")]
            public bool AutoAuthFriends = false;

            [JsonProperty("Admin Bypass")]
            public bool AdminBypass = false;
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Boilerplate

        internal class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        internal static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(Configuration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => PluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                PluginConfig = Config.ReadObject<Configuration>();
                if (PluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(PluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(PluginConfig, true);
        }

        #endregion
    }
}


// --- End of file: TurretManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/team-info ---
// --- Original File Path: T/TeamInfo/TeamInfo.cs ---

using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Team Info", "Lorddy", "0.1.7")]
    [Description("Get Team Info")]
    public class TeamInfo : RustPlugin
    {
        #region Fields

        private const string PERMISSION_USE = "teaminfo.use";

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CmdHelp1"] = "<color=orange>/teaminfo <name|ID></color> - Show team info",
                ["PlayerNotFound"] = "Player Not Found",
                ["TeamNotFound"] = "Player {0} has no team",
                ["NoPerm"] = "You don't have permission to use this command",
                ["Result1"] = "<color=orange>TeamID:</color> {0}",
                ["Result2"] = "\n<color=orange>Leader:</color> {0}",
                ["Result3"] = "\n<color=orange>Name:</color> {0}",
                ["Result4"] = "\n<color=orange>Start Time:</color> {0}",
                ["Result5"] = "\n<color=orange>Life Time:</color> {0}",
                ["Result6"] = "\n<color=orange>Teammates:</color> {0}",
            }, this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PERMISSION_USE, this);
        }

        #endregion

        #region Helpers

        private string FormatSeconds(double seconds)
        {
            TimeSpan timeSpan = TimeSpan.FromSeconds((float) seconds);
            int days = timeSpan.Days;
            int hours = timeSpan.Hours + (days * 24);
            int mins = timeSpan.Minutes;
            int secs = timeSpan.Seconds;

            if (hours > 0)
                return $"{hours:00}:{mins:00}:{secs:00}s";

            if (mins > 0)
                return $"{mins:00}:{secs:00}s";

            return $"{secs:00}s";
        }

        #endregion

        #region Commands

        [ChatCommand("teaminfo")]
        private void TeamInfoCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                PrintToChat(player, lang.GetMessage("NoPerm", this, player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                PrintToChat(player, lang.GetMessage("CmdHelp1", this, player.UserIDString));
                return;
            }

            BasePlayer target = BasePlayer.FindAwakeOrSleeping(args[0]);

            if (target == null)
            {
                PrintToChat(player, lang.GetMessage("PlayerNotFound", this, player.UserIDString));
                return;
            }

            RelationshipManager.PlayerTeam targetTeam = target.Team;

            if (targetTeam == null)
            {
                PrintToChat(player, lang.GetMessage("TeamNotFound", this, player.UserIDString), target.displayName);
                return;
            }

            string result = string.Empty;
            string teamMembers = string.Join(", ", targetTeam.members.Select(teamMember => covalence.Players.FindPlayerById(teamMember.ToString())?.Name ?? "NA"));
            result += string.Format(lang.GetMessage("Result1", this, player.UserIDString), targetTeam.teamID);
            result += string.Format(lang.GetMessage("Result2", this, player.UserIDString), targetTeam.GetLeader()?.displayName ?? "NA");
            result += string.Format(lang.GetMessage("Result3", this, player.UserIDString), targetTeam.teamName ?? "NA");
            result += string.Format(lang.GetMessage("Result4", this, player.UserIDString), DateTime.Now.AddSeconds(-targetTeam.teamLifetime));
            result += string.Format(lang.GetMessage("Result5", this, player.UserIDString), FormatSeconds(targetTeam.teamLifetime));
            result += string.Format(lang.GetMessage("Result6", this, player.UserIDString), teamMembers);

            PrintToChat(player, result);
        }

        #endregion
    }
}

// --- End of file: TeamInfo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tank-turrets ---
// --- Original File Path: T/TankTurrets/TankTurrets.cs ---

﻿using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using System;
using System.Text;
using Oxide;
using Oxide.Game;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("TankTurrets", "Shadow", "1.0.10")]
    [Description("use tank for turret")]
    class TankTurrets : RustPlugin
    {
		[PluginReference] Plugin Vanish;

        #region Variable
        private const string permissionNameKILL = "tankturrets.kill";
        private const string permissionNamePOINT = "tankturrets.point";
        private const string permissionNameSPAWN = "tankturrets.spawn";
        private const string permissionNameREMOVE = "tankturrets.remove";
        private Dictionary<string, int> TankTurret = new Dictionary<string, int>();
        private Dictionary<uint, string> npcCreated = new Dictionary<uint, string>();
        private string npcPrefab = "assets/prefabs/npc/m2bradley/bradleyapc.prefab";
        int npcCoolDown;
        #endregion


        #region Initialize
        protected override void LoadDefaultConfig()
        {
            //
            npcCoolDown = Convert.ToInt32(GetVariable("NPC", "Time to respawn after death", "60"));
            SaveConfig();


        }
       private void Init()
        {
            permission.RegisterPermission(permissionNameKILL, this);
            permission.RegisterPermission(permissionNamePOINT, this);
            permission.RegisterPermission(permissionNameSPAWN, this);
            permission.RegisterPermission(permissionNameREMOVE, this);
            LoadDefaultConfig();
            lang.RegisterMessages(new Dictionary<string, string>

            {
                //chat
                ["Delete"] = "Removing all Tank Points",
                ["StartSpawn"] = "Start spawning all TANK on their points",
                ["EndSpawn"] = "All TANK spawned on their points",
                ["Added"] = "Added TANK point to Data-file!",
                ["AddPoint"] = "No points found! Add new!",
                ["KillTank"] = "All Tanks its Removed!"
            }, this);
            TankTurret = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, int>>("TankTurret");
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("TankTurret"))
            {
                Puts(msg("AddPoint"));
                return;
            }
            TankTurret = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, int>>("TankTurret");

        }

        #region Kill

        void Unload()
        {

            foreach (var check in npcCreated)
            BaseNetworkable.serverEntities.Find(check.Key).Kill();
            Puts(msg("KillTank"));
            Interface.Oxide.ReloadPlugin("TankTurrets");
        }

        #endregion

        #region Delete

        void Delete()
        {
            foreach (var check in npcCreated)
            BaseNetworkable.serverEntities.Find(check.Key).Kill();
            Interface.Oxide.DataFileSystem.WriteObject("TankTurret", npcCreated);
            Puts(msg("Delete"));
            Interface.Oxide.ReloadPlugin("TankTurrets");

        }


        #endregion



        #region Function

        void startSpawn(string position = null)
        {
            BaseEntity entity = null;
            if (position != null)
            {
                timer.Once(npcCoolDown, () =>
                {
                    entity = GameManager.server.CreateEntity(npcPrefab, position.ToVector3());
                    entity.Spawn();
                    npcCreated.Add(entity.net.ID, position);

                });
                return;
            }
            foreach (var check in TankTurret)
            {
                entity = GameManager.server.CreateEntity(npcPrefab, check.Key.ToVector3());
                if (entity != null)
                    entity.Spawn();
                npcCreated.Add(entity.net.ID, check.Key);

            }
            Puts(msg("EndSpawn"));
        }

		private bool CanBradleyApcTarget(BradleyAPC bradley, BaseEntity target)
		{
			if (target is NPCPlayer)
			{
				return false;
			}
			
			var player = target as BasePlayer;
			
			if (player != null)
			{
				var canNetwork = Vanish?.Call("IsInvisible", player);
							
				if (canNetwork is bool)
				{
					if ((bool) canNetwork)
					{
						return false;
					}
				}
							
			}
			return true;
		}
        #endregion

        #region Hook
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (npcCreated.ContainsKey(entity.net.ID))
            {
                startSpawn(npcCreated[entity.net.ID]);
                npcCreated.Remove(entity.net.ID);

            }
        }



        #endregion


        [ConsoleCommand("tankspawn")]
        void CmdBotCount(ConsoleSystem.Arg arg)
        {
            startSpawn();

        }


        [ConsoleCommand("killtank")]
        void CmdBotKill(ConsoleSystem.Arg arg)
        {

            Unload();

        }

        [ConsoleCommand("wipepoint")]
        void CmdBotWipe(ConsoleSystem.Arg arg)
        {
            Delete();
        }


        [ChatCommand("tankspawn")]
        void npcSpawn(BasePlayer player)
        {
           if (!permission.UserHasPermission(player.UserIDString, permissionNameSPAWN))
               return;
           {
            startSpawn();
              {
               player.ChatMessage(msg("EndSpawn", player.UserIDString));
              }
           }
        }

        [ChatCommand("wipepoint")]
        void npcWipe(BasePlayer player)
        {
           if (!permission.UserHasPermission(player.UserIDString, permissionNameREMOVE))
               return;
           {
            Delete();
              {
               player.ChatMessage(msg("Delete", player.UserIDString));
              }
           }
        }
        [ChatCommand("tankpoint")]
        void npcMain(BasePlayer player, string command, string[] args)
        {
           if (!permission.UserHasPermission(player.UserIDString, permissionNamePOINT))
                return;
           {

            int amount = 1;
            if (args.Length == 1 && Int32.Parse(args[0]) > 0)
                amount = Int32.Parse(args[0]);
            TankTurret.Add(player.transform.position.ToString(), amount);
            Puts(msg("Added"));
              {
               Interface.Oxide.DataFileSystem.WriteObject("TankTurret", TankTurret);
               player.ChatMessage(msg("Added", player.UserIDString));

              }
           }           
        }
        


        [ChatCommand("killtank")]
        void BotKill(BasePlayer player, string command, string[] args)
        {
           if (!permission.UserHasPermission(player.UserIDString, permissionNameKILL))
               return;
           {

           Unload();
              {
            player.ChatMessage(msg("KillTank", player.UserIDString));
              }
           }
        }

        #endregion

        #region Helper

        string msg(string key, string id = null) => lang.GetMessage(key, this, id);

        object GetVariable(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
            }
            return value;
        }
        #endregion
    }
}

// --- End of file: TankTurrets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/team-offline-doors ---
// --- Original File Path: T/TeamOfflineDoors/TeamOfflineDoors.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Team Offline Doors", "Gargoyle", "0.8.5")]
    [Description("Closes team doors and stashes when the last team member goes offline")]
    class TeamOfflineDoors : RustPlugin
    {
        #region Configuration

        private bool CloseDoors = true;
        private bool HideStash  = true;

        #endregion

        #region Hooks

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (player.currentTeam != 0UL)
            {
                RelationshipManager.PlayerTeam theTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                int online = 0;

                foreach (var member in theTeam.members)
                {
                    if (member == player.userID) continue;
                
                    foreach (BasePlayer ingame in BasePlayer.activePlayerList)
                    {
                        if (ingame.userID == member)
                        {
                            online++;
                            break;
                        }
                    }

                    if (online > 0) break;
                }

                if (online == 0)
                {
                    foreach (var member in theTeam.members)
                    {
                        if (CloseDoors) DoClose(member);
                        if (HideStash) DoHide(member);
                    }
                }
            }
            else
            {
                if (CloseDoors) DoClose(player.userID);   
                if (HideStash) DoHide(player.userID);   
            }
        }
        
        #endregion

        #region Commands

        private void DoClose(ulong playerId)
        {
            List<Door> list = Resources.FindObjectsOfTypeAll<Door>().Where(x => x.OwnerID == playerId).ToList();
            if (list.Count == 0) return;

            foreach (var item in list)
            {
                if (item.IsOpen()) item.CloseRequest();    
            }
        }

        private void DoHide(ulong playerId)
        {
            List<StashContainer> list = Resources.FindObjectsOfTypeAll<StashContainer>().Where(x => x.OwnerID == playerId).ToList();
            if (list.Count == 0) return;

            foreach (var item in list)
            {
                if (!item.IsHidden()) item.SetHidden(true);
            }
        }

        #endregion
    }
}


// --- End of file: TeamOfflineDoors.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tc-manager ---
// --- Original File Path: T/TCManager/TCManager.cs ---

﻿/// <summary>
/// Author: S0N_0F_BISCUIT
/// Permissions:
///		tcmanager.upkeep - Allows player to use the /upkeep command
///		tcmanager.taxrate - Allows player to use the /taxrate command
///		tcmanager.openinv - Allows player to use the /openinv command
///		tcmanager.auth - Allows player to use the /auth command
///	Chat Commands:
///		/upkeep [0-4] - Get the current building's upkeep requirements. If a grade is provided get the current building's upkeep at that levle.
///		/taxrate - Get the resource tax rate used to calculate the upkeep
///		/tcinv - Opens the inventory of the building privlege's tool cupboard
///		/auth <player_name> - Authorizes the given player on the current tool cupboard
/// </summary>
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("TC Manager", "S0N_0F_BISCUIT", "1.0.4")]
    [Description("Manage your tool cupboard remotely")]
    class TCManager : RustPlugin
    {
        #region Variables
        [PluginReference]
        Plugin MasterLock, GameTipAPI;
        #endregion

        #region Localization
        /// <summary>
        /// Load messages relayed to player
        /// </summary>
        protected override void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoBuildingPrivilege"] = "You are not within a building privlege.",
                ["NoAuthorization"] = "You are not authorized in this building privlege.",
                ["NoCommandPermission"] = "You do not have permission to use this command!",
                ["UpkeepUsage"] = "Usage: /upkeep [0|1|2|3|4]",
                ["DefaultCostHeader"] = "Upkeep Cost",
                ["GradedCostHeader"] = "Maintenance Costs (Grade: {0})",
                ["ItemCost"] = "{0}: {1}",
                ["Line"] = "----------------------------------",
                ["TaxUsage"] = "Usage: /taxrate",
                ["TaxRate"] = "Tax Rate: {0}%",
                ["CantLoot"] = "Can't loot right now",
                ["AuthUsage"] = "Usage: /tcauth <player name>",
                ["AuthorizePlayer"] = "Successfully authorized {0}.",
                ["PlayerNotFound"] = "Unable to find player {0}.",
                ["MultiplePlayers"] = "Multiple players found: {0}",
                ["Tooltip /tcinv"] = "Use /tcinv to access your tool cupboard remotely.",
                ["Tooltip /auth"] = "Use /tcauth \"player name\" to authorize another player.",
                ["UnauthUsage"] = "Usage: /tcunauth <player name>",
                ["UnauthorizePlayer"] = "Successfully unauthorized {0}"
            }, this);
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Plugin initialization
        /// </summary>
        private void Init()
        {
            // Permissions
            permission.RegisterPermission("tcmanager.upkeep", this);
            permission.RegisterPermission("tcmanager.taxrate", this);
            permission.RegisterPermission("tcmanager.openinv", this);
            permission.RegisterPermission("tcmanager.auth", this);
        }
        #endregion

        #region Config Handling
        /// <summary>
        /// Load default config file
        /// </summary>
        protected override void LoadDefaultConfig()
        {
            Config["Display Tooltips"] = ConfigValue("Display Tooltips");
        }
        /// <summary>
        /// Get stored config value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        private object ConfigValue(string value)
        {
            switch (value)
            {
                case "Display Tooltips":
                    if (Config[value] == null)
                        return true;
                    else
                        return Config[value];

                default:
                    return null;
            }
        }
        #endregion

        #region Chat Commands
        /// <summary>
        /// Calculate the upkeep cost for the building
        /// </summary>
        /// <param name="player"></param>
        /// <param name="command"></param>
        /// <param name="args"></param>
        [ChatCommand("upkeep")]
        void CalculateUpkeepCost(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "tcmanager.upkeep") && !player.IsAdmin)
            {
                player.ChatMessage(Lang("NoCommandPermission", player.UserIDString));
                return;
            }

            BuildingPrivlidge privilege = player.GetBuildingPrivilege();
            if (!privilege)
            {
                player.ChatMessage(Lang("NoBuildingPrivilege", player.UserIDString));
                return;
            }

            if (!privilege.IsAuthed(player) && !player.IsAdmin)
            {
                player.ChatMessage(Lang("NoAuthorization", player.UserIDString));
                return;
            }

            if (args.Length == 0) // Default
            {
                List<ItemAmount> itemAmounts = Facepunch.Pool.GetList<ItemAmount>();
                privilege.CalculateUpkeepCostAmounts(itemAmounts);
                player.ChatMessage(Lang("DefaultCostHeader", player.UserIDString));
                player.ChatMessage(Lang("Line", player.UserIDString));
                foreach (ItemAmount amount in itemAmounts)
                {
                    player.ChatMessage(Lang("ItemCost", player.UserIDString, amount.itemDef.displayName.translated, Math.Ceiling(amount.amount)));
                }
                Facepunch.Pool.FreeList(ref itemAmounts);
            }
            else
            {
                BuildingGrade.Enum grade = BuildingGrade.Enum.None;
                switch (args[0].ToLower())
                {
                    case "0":
                        grade = BuildingGrade.Enum.Twigs;
                        break;
                    case "1":
                        grade = BuildingGrade.Enum.Wood;
                        break;
                    case "2":
                        grade = BuildingGrade.Enum.Stone;
                        break;
                    case "3":
                        grade = BuildingGrade.Enum.Metal;
                        break;
                    case "4":
                        grade = BuildingGrade.Enum.TopTier;
                        break;
                    default:
                        player.ChatMessage(Lang("UpkeepUsage", player.UserIDString));
                        return;
                }

                List<ItemAmount> itemAmounts = Facepunch.Pool.GetList<ItemAmount>();
                BuildingManager.Building building = privilege.GetBuilding();
                foreach (BuildingBlock block in building.buildingBlocks)
                {
                    BuildingGrade.Enum original = block.grade;
                    block.grade = grade;
                    block.CalculateUpkeepCostAmounts(itemAmounts, privilege.CalculateUpkeepCostFraction());
                    block.grade = original;
                }
                player.ChatMessage(Lang("GradedCostHeader", player.UserIDString, grade));
                player.ChatMessage(Lang("Line", player.UserIDString));
                foreach (ItemAmount amount in itemAmounts)
                {
                    player.ChatMessage(Lang("ItemCost", player.UserIDString, amount.itemDef.displayName.translated, Math.Ceiling(amount.amount)));
                }
                Facepunch.Pool.FreeList(ref itemAmounts);
            }
        }
        /// <summary>
        /// Calculate the tax rate on the building
        /// </summary>
        /// <param name="player"></param>
        /// <param name="command"></param>
        /// <param name="args"></param>
        [ChatCommand("taxrate")]
        void GetTaxBracket(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "tcmanager.taxrate") && !player.IsAdmin)
            {
                player.ChatMessage(Lang("NoCommandPermission", player.UserIDString));
                return;
            }

            BuildingPrivlidge privilege = player.GetBuildingPrivilege();
            if (!privilege)
            {
                player.ChatMessage(Lang("NoBuildingPrivilege", player.UserIDString));
                return;
            }

            if (!privilege.IsAuthed(player) && !player.IsAdmin)
            {
                player.ChatMessage(Lang("NoAuthorization", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("TaxRate", player.UserIDString, CalculateTaxRate(privilege)));
        }
        /// <summary>
        /// Open the current tool cupboard inventory
        /// </summary>
        /// <param name="player"></param>
        /// <param name="command"></param>
        /// <param name="args"></param>
        [ChatCommand("tcinv")]
        void OpenToolCupboard(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "tcmanager.openinv") && !player.IsAdmin)
            {
                player.ChatMessage(Lang("NoCommandPermission", player.UserIDString));
                return;
            }

            BuildingPrivlidge privilege = player.GetBuildingPrivilege();
            if (!privilege)
            {
                player.ChatMessage(Lang("NoBuildingPrivilege", player.UserIDString));
                return;
            }

            if (!privilege.IsAuthed(player) && !player.IsAdmin)
            {
                player.ChatMessage(Lang("NoAuthorization", player.UserIDString));
                return;
            }

            player.EndLooting();
            timer.Once(0.1f, delegate ()
            {
                LootContainer(player, privilege);
            });
        }
        /// <summary>
        /// Authorize given player on tool cupboard
        /// </summary>
        /// <param name="player"></param>
        /// <param name="command"></param>
        /// <param name="args"></param>
        [ChatCommand("tcauth")]
        void AuthorizePlayer(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "tcmanager.auth") && !player.IsAdmin)
            {
                player.ChatMessage(Lang("NoCommandPermission", player.UserIDString));
                return;
            }

            BuildingPrivlidge privilege = player.GetBuildingPrivilege();
            if (!privilege)
            {
                player.ChatMessage(Lang("NoBuildingPrivilege", player.UserIDString));
                return;
            }
            if (!privilege.IsAuthed(player) && !player.IsAdmin)
            {
                player.ChatMessage(Lang("NoAuthorization", player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                player.ChatMessage(Lang("AuthUsage", player.UserIDString));
                return;
            }

            List<BasePlayer> playerList = FindPlayer(args[0]);

            if (playerList.Count == 1)
            {
                BasePlayer newPlayer = playerList[0];
                privilege.authorizedPlayers.Add(new ProtoBuf.PlayerNameID() { userid = newPlayer.userID, username = newPlayer.displayName });
                privilege.SendNetworkUpdateImmediate();
                player.ChatMessage(Lang("AuthorizePlayer", player.UserIDString, newPlayer.displayName));
                if (MasterLock)
                    MasterLock.Call("AddAuthorization", privilege, newPlayer, player);
            }
            else if (playerList.Count == 0)
            {
                player.ChatMessage(Lang("PlayerNotFound", player.UserIDString, args[0].ToString()));
            }
            else
            {
                String playerNames = String.Empty;
                foreach (BasePlayer bPlayer in playerList)
                {
                    if (!String.IsNullOrEmpty(playerNames))
                        playerNames += ", ";
                    playerNames += bPlayer.displayName;
                }
                player.ChatMessage(Lang("MultiplePlayers", player.UserIDString, playerNames));
            }
        }
        /// <summary>
        /// Un-authorize given player on tool cupboard
        /// </summary>
        /// <param name="player"></param>
        /// <param name="command"></param>
        /// <param name="args"></param>
        [ChatCommand("tcunauth")]
        void UnauthorizePlayer(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "tcmanager.auth") && !player.IsAdmin)
            {
                player.ChatMessage(Lang("NoCommandPermission", player.UserIDString));
                return;
            }
            BuildingPrivlidge privilege = player.GetBuildingPrivilege();
            if (!privilege)
            {
                player.ChatMessage(Lang("NoBuildingPrivilege", player.UserIDString));
                return;
            }
            if (!privilege.IsAuthed(player) && !player.IsAdmin)
            {
                player.ChatMessage(Lang("NoAuthorization", player.UserIDString));
                return;
            }
            if (args.Length == 0)
            {
                player.ChatMessage(Lang("UnauthUsage", player.UserIDString));
                return;
            }

            var playerList = FindPlayer(args[0]);

            if (playerList.Count() == 1)
            {
                BasePlayer newPlayer = playerList[0];
                var removePlayer = privilege.authorizedPlayers.Find(x => x.username == newPlayer.displayName);
                if (removePlayer != null)
                {
                    privilege.authorizedPlayers.Remove(removePlayer);
                    privilege.SendNetworkUpdateImmediate();
                    if (MasterLock)
                        MasterLock.Call("RemoveAuthorization", privilege, newPlayer);
                }
                player.ChatMessage(Lang("UnauthorizePlayer", player.UserIDString, newPlayer.displayName));
            }
            else if (playerList.Count == 0)
            {
                player.ChatMessage(Lang("PlayerNotFound", player.UserIDString, args[0].ToString()));
            }
            else
            {
                String playerNames = String.Empty;
                foreach (BasePlayer bPlayer in playerList)
                {
                    if (!String.IsNullOrEmpty(playerNames))
                        playerNames += ", ";
                    playerNames += bPlayer.displayName;
                }
                player.ChatMessage(Lang("MultiplePlayers", player.UserIDString, playerNames));
            }
        }
        #endregion

        #region Hooks
        /// <summary>
        /// Set code on new lock in master lock privilege area
        /// </summary>
        /// <param name="entity"></param>
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!(bool)Config["Display Tooltips"])
                return;

            if (entity is BuildingPrivlidge)
            {
                BasePlayer player = BasePlayer.FindByID((entity as BuildingPrivlidge).OwnerID);
                DisplayTooltips(player);
            }
        }
        #endregion

        #region Helpers
        /// <summary>
        /// Get string and format from lang file
        /// </summary>
        /// <param name="key"></param>
        /// <param name="userId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string Lang(string key, string userId = null, params object[] args) => string.Format(lang.GetMessage(key, this, userId), args);
        /// <summary>
        /// Calculate the tax rate
        /// </summary>
        /// <param name="privlidge"></param>
        /// <returns></returns>
        private double CalculateTaxRate(BuildingPrivlidge privlidge)
        {
            BuildingPrivlidge.UpkeepBracket[] upkeepBrackets = new List<BuildingPrivlidge.UpkeepBracket>()
            {
                new BuildingPrivlidge.UpkeepBracket(ConVar.Decay.bracket_0_blockcount, ConVar.Decay.bracket_0_costfraction),
                new BuildingPrivlidge.UpkeepBracket(ConVar.Decay.bracket_1_blockcount, ConVar.Decay.bracket_1_costfraction),
                new BuildingPrivlidge.UpkeepBracket(ConVar.Decay.bracket_2_blockcount, ConVar.Decay.bracket_2_costfraction),
                new BuildingPrivlidge.UpkeepBracket(ConVar.Decay.bracket_3_blockcount, ConVar.Decay.bracket_3_costfraction)
            }.ToArray();

            BuildingManager.Building building = privlidge.GetBuilding();
            if (building == null || !building.HasBuildingBlocks())
                return ConVar.Decay.bracket_0_costfraction;

            int count = building.buildingBlocks.Count;
            int a = count;
            for (int index = 0; index < upkeepBrackets.Length; ++index)
            {
                BuildingPrivlidge.UpkeepBracket upkeepBracket = upkeepBrackets[index];
                upkeepBracket.blocksTaxPaid = 0.0f;
                if (a > 0)
                {
                    int num = index != upkeepBrackets.Length - 1 ? Mathf.Min(a, upkeepBrackets[index].objectsUpTo) : a;
                    a -= num;
                    upkeepBracket.blocksTaxPaid = num * upkeepBracket.fraction;
                }
            }
            float num1 = 0.0f;
            for (int index = 0; index < upkeepBrackets.Length; ++index)
            {
                BuildingPrivlidge.UpkeepBracket upkeepBracket = upkeepBrackets[index];
                if (upkeepBracket.blocksTaxPaid > 0.0)
                    num1 += upkeepBracket.blocksTaxPaid;
                else
                    break;
            }
            return Math.Ceiling((num1 / count) * 100);
        }
        /// <summary>
        /// Loot the given container
        /// </summary>
        /// <param name="player"></param>
        /// <param name="container"></param>
        /// <returns></returns>
        private bool LootContainer(BasePlayer player, StorageContainer container)
        {
            if (container.IsLocked())
            {
                player.ChatMessage(Lang("CantLoot", player.UserIDString));
                return false;
            }

            if (!container.CanOpenLootPanel(player, container.panelName))
                return false;

            container.SetFlag(BaseEntity.Flags.Open, true, false);
            player.inventory.loot.StartLootingEntity(container, false);
            player.inventory.loot.AddContainer(container.inventory);
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", container.panelName);
            container.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            return true;
        }
        /// <summary>
        /// Find players with the given name
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        private List<BasePlayer> FindPlayer(string name)
        {
            var playerList = from x in BasePlayer.allPlayerList where x.displayName.ToLower().Contains(name.ToLower()) select x;

            return playerList.ToList();
        }
        /// <summary>
        /// Display a game tip to the given player
        /// </summary>
        /// <param name="player"></param>
        /// <param name="tip"></param>
        private void DisplayTooltips(BasePlayer player)
        {
            if (player == null)
                return;

            if (GameTipAPI)
            {
                GameTipAPI.CallHook("ShowGameTip", player, Lang("Tooltip /tcinv", player.UserIDString), 5f);
                GameTipAPI.CallHook("ShowGameTip", player, Lang("Tooltip /auth", player.UserIDString), 5f);
            }
            else
            {
                player.SendConsoleCommand("gametip.hidegametip");
                player.SendConsoleCommand("gametip.showgametip", Lang("Tooltip /tcinv", player.UserIDString));
                timer.Once(5f, () =>
                {
                    player?.SendConsoleCommand("gametip.hidegametip");
                    player.SendConsoleCommand("gametip.showgametip", Lang("Tooltip /auth", player.UserIDString));
                    timer.Once(5f, () => player?.SendConsoleCommand("gametip.hidegametip"));
                });
            }
        }
        #endregion
    }
}

// --- End of file: TCManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/targetable-drones ---
// --- Original File Path: T/TargetableDrones/TargetableDrones.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Rust.Ai;
using UnityEngine;
using VLB;
using static SamSite;
using HumanNpc = global::HumanNPC;

namespace Oxide.Plugins
{
    [Info("Targetable Drones", "WhiteThunder", "1.2.8")]
    [Description("Allows RC drones to be targeted by Auto Turrets and SAM Sites.")]
    internal class TargetableDrones : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin Clans, Friends, DroneScaleManager, IQGuardianDrone;

        private const string PermissionUntargetable = "targetabledrones.untargetable";

        private const BaseEntity.Flags UntargetableFlag = BaseEntity.Flags.Reserved10;

        private Configuration _config;

        private readonly object True = true;

        private float? SqrScanRadius;

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionUntargetable, this);

            Unsubscribe(nameof(OnEntitySpawned));

            if (!_config.EnableSamTargeting)
            {
                Unsubscribe(nameof(OnSamSiteTargetScan));
                Unsubscribe(nameof(OnSamSiteTarget));
            }

            if (!_config.EnableTurretTargeting)
            {
                Unsubscribe(nameof(OnEntityEnter));
                Unsubscribe(nameof(OnTurretTarget));
                Unsubscribe(nameof(OnDroneScaled));
            }
        }

        private void OnServerInitialized()
        {
            if (_config.OnServerInitialized() && !_config.UsingDefaults)
            {
                SaveConfig();
            }

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null)
                    continue;

                OnEntitySpawned(drone);
            }

            Subscribe(nameof(OnEntitySpawned));

            if (!_config.EnableTurretTargeting && !_config.NPCTargetingSettings.DamageMultiplierEnabled)
            {
                Unsubscribe(nameof(OnEntityTakeDamage));
            }
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null || !IsDroneEligible(drone))
                    continue;

                if (_config.EnableTurretTargeting)
                {
                    TurretTargetComponent.RemoveFromDrone(this, drone);
                }

                if (_config.EnableSamTargeting)
                {
                    SAMTargetComponent.RemoveFromDrone(drone);
                }

                if (_config.NPCTargetingSettings.Enabled)
                {
                    NPCTargetComponent.RemoveFromDrone(drone);
                }
            }

            // Just in case since this is static.
            SAMTargetComponent.DroneComponents.Clear();
        }

        private void OnEntitySpawned(Drone drone)
        {
            if (!IsDroneEligible(drone))
                return;

            if (_config.EnableTurretTargeting)
            {
                TurretTargetComponent.AddToDroneIfMissing(this, drone);
            }

            if (_config.EnableSamTargeting)
            {
                SAMTargetComponent.AddToDroneIfMissing(this, drone);
            }

            if (_config.NPCTargetingSettings.Enabled)
            {
                NPCTargetComponent.AddToDrone(this, drone);
            }
        }

        // Avoid unwanted trigger interactions.
        private object OnEntityEnter(TriggerBase trigger, Drone drone)
        {
            if (trigger is PlayerDetectionTrigger)
            {
                // Only allow interaction with Laser Detectors.
                // This avoids NREs with HBHF sensors or anything unknown.
                if (trigger.GetComponentInParent<BaseEntity>() is LaserDetector)
                    return null;

                return True;
            }

            if (trigger is TargetTrigger)
            {
                // Only allow interaction with Auto Turrets.
                // This avoids NREs with flame turrets, shotgun traps, tesla coils, or anything unknown.
                if (trigger.GetComponentInParent<BaseEntity>() is AutoTurret)
                    return null;

                return True;
            }

            return null;
        }

        private static ulong GetDroneControllerOrOwnerId(Drone drone)
        {
            var controllerSteamId = drone.ControllingViewerId?.SteamId ?? 0;
            if (controllerSteamId != 0)
                return controllerSteamId;

            var droneTurret = GetDroneTurret(drone);
            if ((object)droneTurret != null)
            {
                controllerSteamId = droneTurret.ControllingViewerId?.SteamId ?? 0;
                if (controllerSteamId != 0)
                    return controllerSteamId;

                var turretOwnerId = droneTurret.OwnerID;
                if (turretOwnerId != 0)
                    return turretOwnerId;
            }

            return drone.OwnerID;
        }

        private object OnTurretTarget(AutoTurret turret, Drone drone)
        {
            if (drone == null || drone.IsDestroyed)
                return null;

            if (!ShouldTurretTargetDrone(turret, drone))
                return True;

            return null;
        }

        private void OnSamSiteTargetScan(SamSite samSite, List<ISamSiteTarget> targetList)
        {
            if (SAMTargetComponent.DroneComponents.Count == 0)
                return;

            var samSitePosition = samSite.transform.position;
            SqrScanRadius ??= Mathf.Pow(targetTypeVehicle.scanRadius, 2);

            foreach (var droneComponent in SAMTargetComponent.DroneComponents)
            {
                // Distance checking is way more efficient than collider checking, even with hundreds of drones.
                if ((samSitePosition - droneComponent.Position).sqrMagnitude <= SqrScanRadius.Value)
                {
                    targetList.Add(droneComponent);
                }
            }
        }

        private object OnSamSiteTarget(SamSite samSite, SAMTargetComponent droneComponent)
        {
            var drone = droneComponent.Drone;
            if (drone == null || drone.IsDestroyed)
                return null;

            if (!ShouldSamSiteTargetDrone(samSite, drone)
                || ExposedHooks.OnSamSiteTarget(samSite, drone) is false)
                return True;

            return null;
        }

        private void OnEntityTakeDamage(Drone drone, HitInfo hitInfo)
        {
            if (hitInfo == null)
                return;

            // Multiply damage taken by NPCs.
            var humanNpc = hitInfo.Initiator as HumanNpc;
            if ((object)humanNpc != null)
            {
                if (!_config.NPCTargetingSettings.DamageMultiplierEnabled
                    || !_config.NPCTargetingSettings.IsAllowed(humanNpc))
                    return;

                hitInfo.damageTypes.ScaleAll(_config.NPCTargetingSettings.DamageMultiplier);
                return;
            }

            // Make drone turrets retaliate against other turrets.
            var turret = hitInfo.Initiator as AutoTurret;
            if ((object)turret != null)
            {
                if (turret == null || turret.IsDestroyed)
                    return;

                // Ignore if this drone does not have a turret since it can't retaliate.
                var droneTurret = GetDroneTurret(drone);
                if (droneTurret == null)
                    return;

                // Ignore if the turret damaged its owner drone.
                if (droneTurret == turret)
                    return;

                // Ignore if the turret is not online or has an existing visible target.
                if (!droneTurret.IsOnline()
                    || droneTurret.HasTarget() && droneTurret.targetVisible)
                    return;

                var attackerDrone = GetParentDrone(turret);
                if (attackerDrone != null)
                {
                    // If the attacker turret is on a drone, target that drone.
                    droneTurret.SetTarget(attackerDrone);
                    return;
                }

                // Shoot back at the turret.
                droneTurret.SetTarget(turret);
                return;
            }
        }

        private void OnDroneScaled(Drone drone, BaseEntity rootEntity, float scale, float previousScale)
        {
            if (scale == 1 || rootEntity.IsDestroyed)
                return;

            TurretTargetComponent.AddToRootEntityIfMissing(drone, rootEntity);
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnSamSiteTarget(SamSite samSite, Drone drone)
            {
                return Interface.CallHook("OnSamSiteTarget", samSite, drone);
            }
        }

        #endregion

        #region Helper Methods

        public static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Targetable Drones] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Targetable Drones] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Targetable Drones] {message}");

        private static bool SameTeam(ulong userId, ulong otherUserId)
        {
            return RelationshipManager.ServerInstance.FindPlayersTeam(userId)?.members.Contains(otherUserId) ?? false;
        }

        private static bool IsDroneEligible(Drone drone)
        {
            return drone is not DeliveryDrone && !drone.HasFlag(UntargetableFlag);
        }

        private static Drone GetParentDrone(BaseEntity entity)
        {
            var sphereEntity = entity.GetParentEntity() as SphereEntity;
            return sphereEntity != null ? sphereEntity.GetParentEntity() as Drone : null;
        }

        private static AutoTurret GetDroneTurret(Drone drone)
        {
            return drone.GetSlot(BaseEntity.Slot.UpperModifier) as AutoTurret;
        }

        private static void RemoveFromAutoTurretTriggers(BaseEntity entity)
        {
            if (entity.triggers == null || entity.triggers.Count == 0)
                return;

            foreach (var trigger in entity.triggers.ToArray())
            {
                if (trigger is not TargetTrigger)
                    continue;

                var autoTurret = trigger.gameObject.ToBaseEntity() as AutoTurret;
                if (autoTurret != null && autoTurret.targetTrigger == trigger)
                {
                    trigger.RemoveEntity(entity);
                }
            }
        }

        private bool IsTargetableIQGuardianDrone(Drone drone)
        {
            return IQGuardianDrone?.Call("IsValidDrone", drone) is true;
        }

        private bool IsDroneBeingControlled(Drone drone)
        {
            // Valid IQGuardian Drones are considered to be controlled.
            return drone.IsBeingControlled || IsTargetableIQGuardianDrone(drone);
        }

        private bool IsPlayerTargetExempt(ulong userId)
        {
            return userId != 0 && permission.UserHasPermission(userId.ToString(), PermissionUntargetable);
        }

        private bool IsTargetExempt(Drone drone)
        {
            return drone.isGrounded || drone.InSafeZone() || IsPlayerTargetExempt(GetDroneControllerOrOwnerId(drone));
        }

        private BaseEntity GetRootEntity(Drone drone)
        {
            return DroneScaleManager?.Call("API_GetRootEntity", drone) as BaseEntity;
        }

        private bool HasFriend(ulong userId, ulong otherUserId)
        {
            return Friends?.Call("HasFriend", userId, otherUserId) is true;
        }

        private bool SameClan(ulong userId, ulong otherUserId)
        {
            return Clans?.Call("IsClanMember", userId.ToString(), otherUserId.ToString()) is true;
        }

        private bool AreAllies(ulong userId, ulong otherUserId)
        {
            return Clans?.Call("IsAllyPlayer", userId.ToString(), otherUserId.ToString()) is true;
        }

        private bool ShouldTurretTargetDrone(AutoTurret turret, Drone drone)
        {
            // Drones are not inherently hostile.
            // TODO: Revisit this for player-deployed sentry turrets
            if (turret is NPCAutoTurret)
                return false;

            if (IsTargetExempt(drone))
                return false;

            // Don't allow a drone turret to target its parent drone.
            if (GetParentDrone(turret) == drone)
                return false;

            // Skip auth/team/friends/clan logic for drones that have no apparent controller/owner (likely NPC drones).
            var droneControllerOrOwnerId = GetDroneControllerOrOwnerId(drone);
            if (droneControllerOrOwnerId == 0)
                return true;

            // Direct authorization trumps anything else.
            if (turret.IsAuthed(droneControllerOrOwnerId))
                return false;

            // In case the owner lost authorization, don't share with team/friends/clan.
            if (turret.OwnerID == 0 || !turret.IsAuthed(turret.OwnerID))
                return true;

            if (turret.OwnerID == droneControllerOrOwnerId
                || _config.DefaultSharingSettings.Team && SameTeam(turret.OwnerID, droneControllerOrOwnerId)
                || _config.DefaultSharingSettings.Friends && HasFriend(turret.OwnerID, droneControllerOrOwnerId)
                || _config.DefaultSharingSettings.Clan && SameClan(turret.OwnerID, droneControllerOrOwnerId)
                || _config.DefaultSharingSettings.Allies && AreAllies(turret.OwnerID, droneControllerOrOwnerId))
                return false;

            return true;
        }

        private bool ShouldSamSiteTargetDrone(SamSite samSite, Drone drone)
        {
            if (samSite.staticRespawn || samSite.OwnerID == 0)
                return true;

            var droneOwnerId = GetDroneControllerOrOwnerId(drone);
            if (droneOwnerId == 0)
                return true;

            if (samSite.OwnerID == droneOwnerId
                || _config.DefaultSharingSettings.Team && SameTeam(samSite.OwnerID, droneOwnerId)
                || _config.DefaultSharingSettings.Friends && HasFriend(samSite.OwnerID, droneOwnerId)
                || _config.DefaultSharingSettings.Clan && SameClan(samSite.OwnerID, droneOwnerId)
                || _config.DefaultSharingSettings.Allies && AreAllies(samSite.OwnerID, droneOwnerId))
                return false;

            return true;
        }

        #endregion

        #region Custom Targeting

        private class NPCTargetTriggerComponent : TriggerBase
        {
            public static NPCTargetTriggerComponent AddToDrone(TargetableDrones plugin, Drone drone, GameObject host)
            {
                var component = host.AddComponent<NPCTargetTriggerComponent>();
                component._plugin = plugin;
                component._drone = drone;
                component.interestLayers = Rust.Layers.Mask.Player_Server;
                return component;
            }

            private const int LayerMask = Rust.Layers.Mask.Default
                | Rust.Layers.Mask.Vehicle_Detailed
                | Rust.Layers.Mask.World
                | Rust.Layers.Mask.Construction
                | Rust.Layers.Mask.Terrain
                | Rust.Layers.Mask.Vehicle_Large
                | Rust.Layers.Mask.Tree;

            private TargetableDrones _plugin;
            private Drone _drone;
            private Action _checkTriggerContents;

            private NPCTargetTriggerComponent()
            {
                _checkTriggerContents = CheckTriggerContents;
            }

            public void CheckTriggerContents()
            {
                if (!HasAnyEntityContents)
                {
                    CancelInvoke(_checkTriggerContents);
                    return;
                }

                foreach (var entity in entityContents)
                {
                    var humanNpc = entity as HumanNpc;
                    if (humanNpc == null)
                        continue;

                    var memory = GetMemory(entity, out var senses);
                    if (memory == null)
                        continue;

                    if (IsTargetableBy(humanNpc))
                    {
                        AddToMemory(memory, senses);
                    }
                    else
                    {
                        RemoveFromMemory(memory);
                    }
                }
            }

            public override GameObject InterestedInObject(GameObject obj)
            {
                obj = base.InterestedInObject(obj);
                if (obj == null)
                    return null;

                var humanNpc = obj.ToBaseEntity() as HumanNpc;
                if (humanNpc == null || GetMemory(humanNpc) == null)
                    return null;

                if (!_plugin._config.NPCTargetingSettings.IsAllowed(humanNpc))
                    return null;

                return humanNpc.gameObject;
            }

            public override void OnEntityEnter(BaseEntity entity)
            {
                base.OnEntityEnter(entity);

                if (!HasAnyEntityContents || !entityContents.Contains(entity))
                    return;

                if (!IsInvoking(_checkTriggerContents))
                {
                    InvokeRepeating(_checkTriggerContents, UnityEngine.Random.Range(0, 1), 1);
                }
            }

            public override void OnEntityLeave(BaseEntity entity)
            {
                base.OnEntityLeave(entity);
                var memory = GetMemory(entity);
                if (memory != null)
                {
                    RemoveFromMemory(memory);
                }
            }

            private SimpleAIMemory GetMemory(BaseEntity entity, out AIBrainSenses senses)
            {
                var brain = (entity as HumanNpc)?.Brain;
                senses = brain?.Senses;
                return senses?.Memory;
            }

            private SimpleAIMemory GetMemory(BaseEntity entity)
            {
                return GetMemory(entity, out _);
            }

            private bool IsTargetableBy(HumanNpc humanNpc)
            {
                if (!_plugin.IsDroneBeingControlled(_drone))
                    return false;

                var eyesPosition = humanNpc.isMounted
                    ? humanNpc.eyes.worldMountedPosition
                    : humanNpc.IsDucked()
                        ? humanNpc.eyes.worldCrouchedPosition
                        : !humanNpc.IsCrawling()
                            ? humanNpc.eyes.worldStandingPosition
                            : humanNpc.eyes.worldCrawlingPosition;

                var layerMask = LayerMask;

                if (humanNpc.AdditionalLosBlockingLayer != 0)
                {
                    layerMask |= 1 << humanNpc.AdditionalLosBlockingLayer;
                }

                return humanNpc.IsVisibleSpecificLayers(_drone.CenterPoint(), eyesPosition, layerMask);
            }

            private bool AddToMemory(SimpleAIMemory memory, AIBrainSenses senses)
            {
                if (_drone.ControllingViewerId.HasValue
                    && _plugin.IsPlayerTargetExempt(_drone.ControllingViewerId.Value.SteamId))
                    return false;

                if (!memory.LOS.Add(_drone))
                    return false;

                senses.LastThreatTimestamp = Time.realtimeSinceStartup;

                memory.All.Add(new SimpleAIMemory.SeenInfo
                {
                    Entity = _drone,
                    Position = _drone.transform.position,
                    Timestamp = Time.realtimeSinceStartup,
                });

                memory.Players.Add(_drone);
                memory.Targets.Add(_drone);
                memory.Threats.Add(_drone);
                return true;
            }

            private bool RemoveFromMemory(SimpleAIMemory memory)
            {
                if (!memory.LOS.Remove(_drone))
                    return false;

                for (var i = 0; i < memory.All.Count; i++)
                {
                    var seenInfo = memory.All[i];
                    if (seenInfo.Entity == _drone)
                    {
                        memory.All.RemoveAt(i);
                        break;
                    }
                }

                memory.Players.Remove(_drone);
                memory.Targets.Remove(_drone);
                memory.Threats.Remove(_drone);
                return true;
            }

            private void OnDestroy()
            {
                if (HasAnyEntityContents)
                {
                    foreach (var entity in entityContents)
                    {
                        var memory = GetMemory(entity);
                        if (memory == null)
                            continue;

                        RemoveFromMemory(memory);
                    }
                }
            }
        }

        private class NPCTargetComponent : FacepunchBehaviour
        {
            public static void AddToDrone(TargetableDrones plugin, Drone drone)
            {
                var component = drone.gameObject.AddComponent<NPCTargetComponent>();

                var child = drone.gameObject.CreateChild();
                child.layer = (int)Rust.Layer.Trigger;

                // HACK: Prevent the drone's sweep test from using incorporating the child collider.
                child.AddComponent<Rigidbody>().isKinematic = true;

                var collider = child.AddComponent<SphereCollider>();
                collider.isTrigger = true;
                collider.radius = plugin._config.NPCTargetingSettings.MaxRange;

                component._trigger = NPCTargetTriggerComponent.AddToDrone(plugin, drone, child);
            }

            public static void RemoveFromDrone(Drone drone)
            {
                DestroyImmediate(drone.gameObject.GetComponent<NPCTargetComponent>());
            }

            private NPCTargetTriggerComponent _trigger;

            private void OnDestroy()
            {
                if (_trigger != null)
                {
                    Destroy(_trigger.gameObject);
                }
            }
        }

        private class TurretTargetComponent : EntityComponent<BaseEntity>
        {
            public static void AddToRootEntityIfMissing(Drone drone, BaseEntity rootEntity)
            {
                rootEntity.GetOrAddComponent<TurretTargetComponent>().InitForDrone(drone);
            }

            public static void AddToDroneIfMissing(TargetableDrones plugin, Drone drone)
            {
                // Must be added to the drone itself since the root entity (SphereEntity) is not a BaseCombatEntity.
                drone.GetOrAddComponent<TurretTargetComponent>().InitForDrone(drone);

                // Add to the root entity to ensure consistency with side effect of landing on cargo ship.
                var rootEntity = plugin.GetRootEntity(drone);
                if (rootEntity != null)
                {
                    AddToRootEntityIfMissing(drone, rootEntity);
                }
            }

            private static void RemoveFromEntity(BaseEntity entity)
            {
                var turretComponent = entity.GetComponent<TurretTargetComponent>();
                if (turretComponent != null)
                {
                    DestroyImmediate(turretComponent);
                    RemoveFromAutoTurretTriggers(entity);
                }
            }

            public static void RemoveFromDrone(TargetableDrones plugin, Drone drone)
            {
                RemoveFromEntity(drone);

                var rootEntity = plugin.GetRootEntity(drone);
                if (rootEntity != null)
                {
                    RemoveFromEntity(rootEntity);
                }
            }

            private Drone _ownerDrone;
            private GameObject _child;

            private TurretTargetComponent InitForDrone(Drone drone)
            {
                _ownerDrone = drone;
                AddChildLayerForAutoTurrets();
                return this;
            }

            private void AddChildLayerForAutoTurrets()
            {
                _child = gameObject.CreateChild();
                _child.layer = (int)Rust.Layer.Player_Server;

                var triggerCollider = _child.gameObject.AddComponent<BoxCollider>();
                triggerCollider.size = _ownerDrone.bounds.extents;
                triggerCollider.isTrigger = true;
            }

            private void OnDestroy()
            {
                if (_child != null)
                {
                    Destroy(_child);
                }
            }
        }

        private class SAMTargetComponent : FacepunchBehaviour, ISamSiteTarget
        {
            public static HashSet<SAMTargetComponent> DroneComponents = new();

            public static void AddToDroneIfMissing(TargetableDrones plugin, Drone drone)
            {
                var component = drone.GetOrAddComponent<SAMTargetComponent>();
                component._plugin = plugin;
            }

            public static void RemoveFromDrone(Drone drone)
            {
                var samComponent = drone.GetComponent<SAMTargetComponent>();
                if (samComponent != null)
                {
                    DestroyImmediate(samComponent);
                }
            }

            public Drone Drone { get; private set; }
            private TargetableDrones _plugin;
            private Transform _transform;

            private void Awake()
            {
                Drone = GetComponent<Drone>();
                _transform = transform;
                DroneComponents.Add(this);
            }

            public Vector3 Position => _transform.position;

            public SamTargetType SAMTargetType => targetTypeVehicle;

            public bool isClient => false;

            public bool IsValidSAMTarget(bool isStaticSamSite)
            {
                if (_plugin.IsTargetExempt(Drone))
                    return false;

                return isStaticSamSite
                    ? _plugin._config.EnableStaticSAMTargeting
                    : _plugin._config.EnablePlayerSAMTargeting;
            }

            public Vector3 CenterPoint() => Drone.CenterPoint();

            public Vector3 GetWorldVelocity() => Drone.body.velocity;

            public bool IsVisible(Vector3 position, float distance) => Drone.IsVisible(position, distance);

            private void OnDestroy() => DroneComponents.Remove(this);
        }

        #endregion

        #region Configuration

        private class CaseInsensitiveDictionary<TValue> : Dictionary<string, TValue>
        {
            public CaseInsensitiveDictionary() : base(StringComparer.OrdinalIgnoreCase) {}

            public CaseInsensitiveDictionary(IEnumerable<KeyValuePair<string, TValue>> collection)
                : base(collection, StringComparer.OrdinalIgnoreCase) {}
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class NPCTargetingSettings
        {
            [JsonProperty("MaxRange")]
            public float MaxRange = 45;

            [JsonProperty("DamageMultiplier")]
            public float DamageMultiplier = 4f;

            [JsonProperty("EnabledByNpcPrefab")]
            private CaseInsensitiveDictionary<bool> EnabledByNpcPrefabName = new();

            private Dictionary<uint, bool> EnabledByNpcPrefabId = new();

            public bool Enabled { get; private set; }

            public bool DamageMultiplierEnabled => Enabled && DamageMultiplier != 1;

            public bool IsAllowed(BaseEntity entity)
            {
                return EnabledByNpcPrefabId.TryGetValue(entity.prefabID, out var canTarget) && canTarget;
            }

            public bool OnServerInitialized()
            {
                var changed = AddMissingNpcPrefabs();

                foreach (var (prefabPath, value) in EnabledByNpcPrefabName)
                {
                    var humanNpc = GameManager.server.FindPrefab(prefabPath)?.GetComponent<HumanNpc>();
                    if (humanNpc == null)
                    {
                        LogWarning($"Invalid HumanNPC prefab in config: {prefabPath}");
                        continue;
                    }

                    EnabledByNpcPrefabId[humanNpc.prefabID] = value;
                    Enabled = true;
                }

                return changed;
            }

            private bool AddMissingNpcPrefabs()
            {
                var changed = false;

                foreach (var prefabPath in GameManifest.Current.entities)
                {
                    var humanNpc = GameManager.server.FindPrefab(prefabPath)?.GetComponent<HumanNpc>();
                    if (humanNpc == null)
                        continue;

                    if (humanNpc.GetComponent<ScientistBrain>()?.HostileTargetsOnly ?? false)
                        continue;

                    if (!EnabledByNpcPrefabName.ContainsKey(prefabPath))
                    {
                        EnabledByNpcPrefabName[prefabPath.ToLower()] = false;
                        changed = true;
                    }
                }

                if (changed)
                {
                    EnabledByNpcPrefabName = new CaseInsensitiveDictionary<bool>(EnabledByNpcPrefabName.OrderBy(entry => entry.Key));
                }

                return changed;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class SharingSettings
        {
            [JsonProperty("Team")]
            public bool Team = false;

            [JsonProperty("Friends")]
            public bool Friends = false;

            [JsonProperty("Clan")]
            public bool Clan = false;

            [JsonProperty("Allies")]
            public bool Allies = false;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("EnableTurretTargeting")]
            public bool EnableTurretTargeting = true;

            [JsonProperty("EnablePlayerSAMTargeting")]
            public bool EnablePlayerSAMTargeting = true;

            [JsonProperty("EnableStaticSAMTargeting")]
            public bool EnableStaticSAMTargeting = true;

            [JsonProperty("EnableSAMTargeting")]
            public bool DeprecatedEnableSAMTargeting
            {
                set
                {
                    EnablePlayerSAMTargeting = value;
                    EnableStaticSAMTargeting = value;
                }
            }

            [JsonProperty("NPCTargeting")]
            public NPCTargetingSettings NPCTargetingSettings = new();

            [JsonProperty("DefaultSharingSettings")]
            public SharingSettings DefaultSharingSettings = new();

            [JsonIgnore]
            public bool EnableSamTargeting => EnablePlayerSAMTargeting || EnableStaticSAMTargeting;

            public bool OnServerInitialized()
            {
                return NPCTargetingSettings.OnServerInitialized();
            }
        }

        private Configuration GetDefaultConfig() => new();

        #endregion

        #region Configuration Helpers

        [JsonObject(MemberSerialization.OptIn)]
        private class BaseConfiguration
        {
            public bool UsingDefaults;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
                if (_config != null)
                {
                    _config.UsingDefaults = true;
                }
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion
    }
}


// --- End of file: TargetableDrones.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/toll-buttons ---
// --- Original File Path: T/TollButtons/TollButtons.cs ---

using System;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins {
    [Info("Toll Buttons", "KajWithAJ", "0.3.0")]
    [Description("Make players pay toll to press a button using their RP points.")]
    class TollButtons : RustPlugin {

        [PluginReference]
        private readonly Plugin Economics, ServerRewards;

        private const string PermissionUse = "tollbuttons.use";
        private const string PermissionAdmin = "tollbuttons.admin";
        private const string PermissionExclude = "tollbuttons.exclude";

        private StoredData storedData = new StoredData();

        private void Init() {
            permission.RegisterPermission(PermissionUse, this);
            permission.RegisterPermission(PermissionAdmin, this);
            permission.RegisterPermission(PermissionExclude, this);
        }

        private void OnServerInitialized() {
            if (ServerRewards == null && Economics == null) {
                PrintError("ServerRewards nor Economics are loaded, at least one of those is required");
            }

            SaveConfig();
            LoadData();
        }

        private void Unload()
        {
            SaveData();
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new configuration file");
            Config["TransferTollToOwner"] = false;
            Config["MaximumPrice"] = 0;
            Config["Valuta"] = "serverrewards";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ButtonNotFound"] = "No button found",
                ["NoTollSetPermission"] = "You do not have permission to use this command.",
                ["NoButtonOwnership"] = "This button is not yours.",
                ["TollSet"] = "A toll of {0} RP was set for this button.",
                ["InsufficientFunds"] = "Insufficient fonds! You need {0} RP to press this button",
                ["TollPaid"] = "You've been charged {0} RP for pressing this button",
                ["MaximumPrice"] = "The maximum amount to configure as toll is set at {0}",
                ["InvalidNumber"] = "Provide a valid number."
            }, this);
        }

        [ChatCommand("toll")]
        private void ChatCmdCheckButton(BasePlayer player, string command, string[] args)
        {
            RaycastHit hit;
            var raycast = Physics.Raycast(player.eyes.HeadRay(), out hit, 2f, 2097409);
            BaseEntity button = raycast ? hit.GetEntity() : null;
            if (button == null || button as PressButton == null) {
                string message = lang.GetMessage("ButtonNotFound", this, player.UserIDString);
                player.ChatMessage(string.Format(message));
                return;
            }

            if (args.Length >=1 ) {
                if (!permission.UserHasPermission(player.UserIDString, PermissionUse)) {
                    string message = lang.GetMessage("NoTollSetPermission", this, player.UserIDString);
                    player.ChatMessage(string.Format(message));
                    return;
                }
                
                if (!permission.UserHasPermission(player.UserIDString, PermissionAdmin) && button.OwnerID != player.userID) {
                    player.ChatMessage(string.Format(lang.GetMessage("NoButtonOwnership", this, player.UserIDString)));
                    return;
                }

                int cost = 0;
                if (!int.TryParse(args[0], out cost))
                {
                    player.ChatMessage(string.Format(lang.GetMessage("InvalidNumber", this, player.UserIDString)));
                    return;
                }

                int maximumPrice = (int) Config["MaximumPrice"];

                if (maximumPrice > 0 && cost > maximumPrice) {
                    player.ChatMessage(string.Format(lang.GetMessage("MaximumPrice", this, player.UserIDString), maximumPrice));
                    return;
                }

                if (!storedData.TollButtons.ContainsKey(button.net.ID.Value)) {
                    ButtonData buttonData = new ButtonData();
                    buttonData.cost = cost;
                    buttonData.ownerID = player.UserIDString;
                    storedData.TollButtons.Add(button.net.ID.Value, buttonData);
                } else {
                    storedData.TollButtons[button.net.ID.Value].cost = cost;
                }

                player.ChatMessage(string.Format(lang.GetMessage("TollSet", this, player.UserIDString), cost));
            } else {
                int cost = CheckButtonCost(button as PressButton);
                player.ChatMessage(string.Format(lang.GetMessage("TollSet", this, player.UserIDString), cost));
            }
        }

        private object OnButtonPress(PressButton button, BasePlayer player)
        {
            if (button.OwnerID == 0) return null;

            int cost = CheckButtonCost(button);

            if (cost > 0) {
                if (permission.UserHasPermission(player.UserIDString, PermissionExclude)) {
                    return null;
                }

                if (button.OwnerID != player.userID) {
                    string valuta = (string) Config["Valuta"];

                    if (!TryPay(player, valuta, cost)) {
                        player.ChatMessage(string.Format(lang.GetMessage("InsufficientFunds", this, player.UserIDString), cost));
                        return true;
                    } else {
                        player.ChatMessage(string.Format(lang.GetMessage("TollPaid", this, player.UserIDString), cost));

                        if ((bool) Config["TransferTollToOwner"] == true) {
                            Transfer(button.OwnerID.ToString(), valuta, cost);
                        }

                        return null;
                    }
                } else {
                    return null;
                }
            } else {
                return null;
            }
        }

        private int CheckButtonCost(PressButton button) {
            if (!storedData.TollButtons.ContainsKey(button.net.ID.Value)) {
                return 0;
            } else {
                return storedData.TollButtons[button.net.ID.Value].cost;
            }
        }

        private void Transfer(string beneficiary, string valuta, int amount) {
            switch (valuta.ToLower()) {
                case "economics":
                    Economics?.Call("Deposit", beneficiary, (double)amount);
                    break;

                case "serverrewards":
                    ServerRewards?.Call("AddPoints", beneficiary, amount);
                    break;
            }
        }

        private bool TryPay(BasePlayer player, string valuta, int price) {
            if (!CanPay(player, valuta, price)) {
                return false;
            }

            switch (valuta.ToLower()) {
                case "economics":
                    Economics?.Call("Withdraw", player.userID, (double)price);
                    break;

                case "serverrewards":
                    ServerRewards?.Call("TakePoints", player.userID, price);
                    break;
            }
            return true;
        }

        private bool CanPay(BasePlayer player, string valuta, int cost) {
            int missingAmount = CheckBalance(valuta, cost, player.userID);
            return missingAmount <= 0;
        }

        private int CheckBalance(string valuta, int price, ulong playerId) {
            switch (valuta.ToLower()) {
                case "serverrewards":
                    var points = ServerRewards?.Call("CheckPoints", playerId);
                    if (points is int) {
                        var n = price - (int)points;
                        return n <= 0 ? 0 : n;
                    }
                    return price;
                case "economics":
                    var balance = Economics?.Call("Balance", playerId);
                    if (balance is double){
                        var n = price - (double)balance;
                        return n <= 0 ? 0 : (int)Math.Ceiling(n);
                    }
                    return price;
                default:
                    PrintError($"Valuta {valuta} not recognized.");
                    return price;
            }
        }

        private class StoredData
        {
            public readonly Dictionary<ulong, ButtonData> TollButtons = new Dictionary<ulong, ButtonData>();
        }

        private class ButtonData
        {
            public int cost = 0;
            public string ownerID = "";
        }

        private void LoadData() => storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Name);

        private void SaveData() => Interface.GetMod().DataFileSystem.WriteObject(this.Name, storedData);

        private void OnServerSave() => SaveData();

        private void OnNewSave(string name)
        {
            PrintWarning("Map wipe detected - clearing TollButtons...");

            storedData.TollButtons.Clear();
            SaveData();
        }
    }
}


// --- End of file: TollButtons.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/turret-limits ---
// --- Original File Path: T/TurretLimits/TurretLimits.cs ---

﻿using ConVar;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{

    [Info("Turret Limits", "Whispers88, gsuberland", "1.2.3")]
    [Description("Limits the number of autoturrets, flame turrets, and shotgun traps that can be deployed per building.")]

    class TurretLimits : RustPlugin
    {
        private const string AutoTurretPrefabString = "autoturret";
        private const string FlameTurretPrefabString = "flameturret";
        private const string ShotgunTrapPrefabString = "guntrap";
        private const string SamSitePrefabString = "sam_site_turret";

        private bool ConfigChanged = false;
        private struct Configuration
        {

            public static int AutoTurretLimit = 3;

            public static int FlameTurretLimit = 3;

            public static int ShotgunTrapLimit = 3;

            public static int SamSiteLimit = 3;

            public static bool DisableAllTurrets = false;
            public static bool AllowAdminBypass = false;
        }

        private void Init()
        {
            LoadConfig();
            Sentry.interferenceradius = float.MinValue;
            Sentry.maxinterference = int.MaxValue;
            AutoTurret.interferenceUpdateList.Clear();

        }

        private new void LoadConfig()
        {
            GetConfig(ref Configuration.DisableAllTurrets, "Config", "Disable All Turrets");
            GetConfig(ref Configuration.AllowAdminBypass, "Config", "Admin Can Bypass Build Restrictions");

            GetConfig(ref Configuration.AutoTurretLimit, "Limits", "Individual Control", "AutoTurret", "Maximum");

            GetConfig(ref Configuration.FlameTurretLimit, "Limits", "Individual Control", "Flame Turret", "Maximum");

            GetConfig(ref Configuration.ShotgunTrapLimit, "Limits", "Individual Control", "Shotgun Trap", "Maximum");

            GetConfig(ref Configuration.SamSiteLimit, "Limits", "Individual Control", "Sam Site Turret", "Maximum");


            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new config file...");
            LoadConfig();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoAdminLimits"] = "Admins do not have turret limits enabled.",
                ["CannotDeployWithoutTC"] = "Cannot deploy turret without tool cupboard access.",
                ["TurretsDisabled"] = "Turrets are disabled on this server.",

                ["TurretLimitReached_AutoTurret"] = "Autoturret limit reached. You have already deployed {0} or more autoturrets in this base.",

                ["TurretLimitReached_FlameTurret"] = "Flame turret limit reached. You have already deployed {0} or more flame turrets in this base.",

                ["TurretLimitReached_ShotgunTrap"] = "Shotgun trap limit reached. You have already deployed {0} or more shotgun traps in this base.",

                ["TurretLimitReached_SamSite"] = "Sam Site Turret limit reached. You have already deployed {0} or more shotgun traps in this base.",
            }, this);
        }

        private void GetConfig<T>(ref T variable, params string[] path)
        {
            if (path.Length == 0)
            {
                return;
            }

            if (Config.Get(path) == null)
            {
                Config.Set(path.Concat(new object[] { variable }).ToArray());
                PrintWarning($"Added field to config: {string.Join("/", path)}");
            }

            variable = (T)Convert.ChangeType(Config.Get(path), typeof(T));
        }

        object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            // is the player trying to build a turret of some sort?
            // have to use a string comparison check here (rather than `is AutoTurret` or whatever) because the entity has not yet spawned
            bool isAutoTurret = prefab?.deployable?.fullName?.Contains(AutoTurretPrefabString) ?? false;
            bool isFlameTurret = prefab?.deployable?.fullName?.Contains(FlameTurretPrefabString) ?? false;
            bool isShotgunTrap = prefab?.deployable?.fullName?.Contains(ShotgunTrapPrefabString) ?? false;
            bool isSamSite = prefab?.deployable?.fullName?.Contains(SamSitePrefabString) ?? false;

            if (isAutoTurret || isFlameTurret || isShotgunTrap || isSamSite)
            {
                // sanity check the above values
                int sanityCheck = (isAutoTurret ? 1 : 0) + (isFlameTurret ? 1 : 0) + (isShotgunTrap ? 1 : 0) + (isSamSite ? 1 : 0);
                if (sanityCheck != 1)
                {
                    throw new Exception("Somehow multiple turret types were detected.");
                }
                var player = planner.GetOwnerPlayer();
                if (!player.IsBuildingAuthed() || !target.entity?.GetBuildingPrivilege())
                {
                    SendReply(player, lang.GetMessage("CannotDeployWithoutTC", this, player.IPlayer.Id));
                    return false;
                }
                var cupboard = target.entity?.GetBuildingPrivilege();
                var building = cupboard.GetBuilding();
                List<BaseEntity> nearby = new List<BaseEntity>();
                if (Configuration.AllowAdminBypass && player.IsAdmin)
                {
                    SendReply(player, lang.GetMessage("NoAdminLimits", this, player.IPlayer.Id));
                    return null;
                }

                // are turrets completely disabled?
                if (Configuration.DisableAllTurrets)
                {
                    SendReply(player, lang.GetMessage("TurretsDisabled", this, player.IPlayer.Id));
                    return null;
                }

                if (isFlameTurret)
                {
                    int flameturrets = building.decayEntities.Count(e => e is FlameTurret);
                    if (flameturrets + 1 > Configuration.FlameTurretLimit)
                    {
                        SendReply(player, lang.GetMessage("TurretLimitReached_FlameTurret", this, player.IPlayer.Id), (flameturrets));
                        return false;
                    }
                }
                else if (isShotgunTrap)
                {
                    int guntraps = building.decayEntities.Count(e => e is GunTrap);
                    if (guntraps + 1 > Configuration.ShotgunTrapLimit)
                    {
                        SendReply(player, lang.GetMessage("TurretLimitReached_ShotgunTrap", this, player.IPlayer.Id), (guntraps));
                        return false;
                    }
                }
                else if (isAutoTurret)
                {
                    int turrets = 0;
                    Vis.Entities(player.transform.position, 30f, nearby, LayerMask.GetMask("Deployed"), QueryTriggerInteraction.Ignore);
                    if (nearby == null) return null;
                    foreach (var ent in nearby.Distinct().ToList())
                    {
                        if (ent is AutoTurret && ent.GetBuildingPrivilege().GetBuilding().ID == building.ID)
                        {
                            turrets++;
                        }

                    }
                    if (turrets >= Configuration.AutoTurretLimit)
                    {
                        SendReply(player, lang.GetMessage("TurretLimitReached_AutoTurret", this, player.IPlayer.Id), (turrets));
                        return false;
                    }
                }
                else if (isSamSite)
                {
                    int samsites = 0;
                    Vis.Entities(player.transform.position, 30f, nearby, LayerMask.GetMask("Deployed"), QueryTriggerInteraction.Ignore);
                    if (nearby == null) return null;
                    foreach (var ent in nearby.Distinct().ToList())
                    {
                        if (ent is SamSite && ent.GetBuildingPrivilege().GetBuilding().ID == building.ID)
                        {
                            samsites++;
                        }

                    }
                    if (samsites >= Configuration.SamSiteLimit)
                    {
                        SendReply(player, lang.GetMessage("TurretLimitReached_SamSite", this, player.IPlayer.Id), (samsites));
                        return false;
                    }
                }

            }
            return null;
        }
    }
}


// --- End of file: TurretLimits.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/team-chat ---
// --- Original File Path: T/TeamChat/TeamChat.cs ---

﻿using UnityEngine;
using System.Text;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info( "Team Chat", "Waggy", "1.0.2" )]
    [Description( "Allows you to send messages to only those in your team" )]

    class TeamChat : RustPlugin
    {
        #region Commands

        [ChatCommand( "team" )]
        void SendMessageToTeam( BasePlayer player, string command, string[] args )
        {
            var currentTeam = player.currentTeam;

            if ( currentTeam == 0 )
            {
                player.ChatMessage( $"<color=#{config.ErrorMessageColor}>" + lang.GetMessage( "NotPartOfTeam", this, player.UserIDString + "</color>" ) );
                return;
            }

            var teamMessage = string.Join( " ", args );

            if ( teamMessage.Length == 0 )
            {
                player.ChatMessage( $"<color=#{config.ErrorMessageColor}>" + lang.GetMessage( "NoMessage", this, player.UserIDString + "</color>" ) );
                return;
            }

            RelationshipManager.PlayerTeam team = RelationshipManager.Instance.FindTeam( currentTeam );

            if ( team == null )
            {
                player.ChatMessage( $"<color=#{config.ErrorMessageColor}>" + lang.GetMessage( "NotPartOfTeam", this, player.UserIDString + "</color>" ) );
                return;
            }

            var players = team.members;

            if ( team.members.Count <= 1 )
            {
                player.ChatMessage( $"<color=#{config.ErrorMessageColor}>" + lang.GetMessage( "noteammembers", this, player.UserIDString + "</color>" ) );
                return;
            }

            var nameColor = config.PlayerNameColor;
            if ( player.IsAdmin )
            {
                nameColor = config.AdminNameColor;
            }

            var message = string.Format( $"<color=#{config.TeamHeaderColor}>" + lang.GetMessage( "TeamHeader", this, player.UserIDString ), "</color>" + $"<color=#{nameColor}>" + player.displayName + "</color>", teamMessage );

            foreach ( var teamMember in players )
            {
                SendChatMessage( player, teamMember, message );
            }

            Puts( message.ToString() );
        }

        void MessageToTeam( BasePlayer player, string command, string[] args )
        {
            SendMessageToTeam( player, command, args );
        }

        public void SendChatMessage( BasePlayer speaker, ulong target, string message )
        {
            RelationshipManager.FindByID( target )?.SendConsoleCommand( "chat.add", speaker.userID, message );
        }

        #endregion

        #region Config and Lang

        private ConfigData config;

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject( new ConfigData(), true );
        }

        private void Init()
        {
            config = Config.ReadObject<ConfigData>();

            if ( config.TeamShorthandCommand )
            {
                cmd.AddChatCommand( "t", this, MessageToTeam );
            }
        }

        private new void SaveConfig()
        {
            Config.WriteObject( config, true );
        }

        public class ConfigData
        {
            [JsonProperty( "Team Header Color ( the (TEAM) part of the message )" )]
            public string TeamHeaderColor = "00FF00";

            [JsonProperty( "Error Message Color" )]
            public string ErrorMessageColor = "FF0000";

            [JsonProperty( "Player Name Color (non-admin)" )]
            public string PlayerNameColor = "54A8FF";

            [JsonProperty( "Admin Name Color" )]
            public string AdminNameColor = "A8FF54";

            [JsonProperty( "Enable /t ( works the same as /team )" )]
            public bool TeamShorthandCommand = true;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages( new Dictionary<string, string>
            {
                { "NotPartOfTeam", "ERROR: You are not part of a team!" },
                { "NoMessage", "ERROR: Please include a message!" },
                { "NoTeamMembers", "ERROR: There's nobody else in your team!" },
                { "TeamHeader", "(TEAM) {0}: {1}" },
            }, this );
        }

        #endregion
    }

    namespace TeamChatEx
    {
        public static class TeamChatEx
        {
            private static StringBuilder coloredTextBuilder = new StringBuilder();
            public static string ChangeColor( this string text, Color color )
            {
                coloredTextBuilder.Clear();
                coloredTextBuilder.Append( "<color=#" )
                    .Append( ( (byte)( color.r * 255 ) ).ToString( "X2" ) )
                    .Append( ( (byte)( color.g * 255 ) ).ToString( "X2" ) )
                    .Append( ( (byte)( color.b * 255 ) ).ToString( "X2" ) )
                    .Append( '>' )
                    .Append( text )
                    .Append( "</color>" );
                return coloredTextBuilder.ToString();
            }
        }
    }
}

// --- End of file: TeamChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tool-cupboard-extender ---
// --- Original File Path: T/TcExtender/TcExtender.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Rust;

namespace Oxide.Plugins
{
    [Info("Tool Cupboard Extender", "MJSU", "0.0.1")]
    [Description("Extends the range of the tool cupboard")]
    internal class TcExtender : RustPlugin
    {
        #region Class Fields
        private PluginConfig _pluginConfig; //Plugin Config

        private const string UsePermission = "tcextender.use";

        private float _maxRange;
        private readonly Hash<ulong, float> _playerRangeCache = new Hash<ulong, float>();
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Ranges = config.Ranges ?? new Hash<string, float>
            {
                [UsePermission] = 16f
            };
            return config;
        }
        
        private void OnServerInitialized()
        {
            _maxRange = _pluginConfig.Ranges.Values.Max();
            
            foreach (KeyValuePair<string,float> ranges in _pluginConfig.Ranges)
            {
                permission.RegisterPermission(ranges.Key, this);
                if (ranges.Value < 16f)
                {
                    PrintWarning($"{ranges.Key} permission has a range less than 16.0 which is not allowed!");
                }
            }
        }
        #endregion

        #region Permission Hooks

        private void OnUserPermissionGranted(string playerId, string permName)
        {
            _playerRangeCache.Remove(ulong.Parse(playerId));
        }
        
        private void OnUserPermissionRevoked(string playerId, string permName)
        {
            _playerRangeCache.Remove(ulong.Parse(playerId));
        }
        
        private void OnUserGroupAdded(string playerId, string groupName)
        {
            _playerRangeCache.Remove(ulong.Parse(playerId));
        }
        
        private void OnUserGroupRemoved(string playerId, string groupName)
        {
            _playerRangeCache.Remove(ulong.Parse(playerId));
        }

        private void OnGroupPermissionGranted(string groupName, string permName)
        {
           _playerRangeCache.Clear();
        }
        
        private void OnGroupPermissionRevoked(string groupName, string permName)
        {
            _playerRangeCache.Clear();
        }
        #endregion

        #region uMod Hook

        private BuildingPrivlidge OnBuildingPrivilege(BaseEntity entity, OBB obb)
        {
            BuildingBlock block = null;
            BuildingPrivlidge bp = null;
            List<BuildingBlock> blocks = Pool.GetList<BuildingBlock>();
            Vis.Entities(obb.position, _maxRange + obb.extents.magnitude, blocks, Layers.Construction);
            for (int i = 0; i < blocks.Count; i++)
            {
                BuildingBlock item = blocks[i];
                if (item.isServer == entity.isServer 
                    && item.IsOlderThan(block) 
                    && obb.Distance(item.WorldSpaceBounds()) <= GetPlayerRange(item.OwnerID))
                {
                    BuildingManager.Building building = item.GetBuilding();
                    if (building != null)
                    {
                        BuildingPrivlidge buildingTc = building.GetDominatingBuildingPrivilege();
                        if (buildingTc != null)
                        {
                            block = item;
                            bp = buildingTc;
                        }
                    }
                }
            }
            
            Pool.FreeList(ref blocks);
            return bp;
        }
        #endregion

        #region Helper Methods
        private float GetPlayerRange(ulong playerId)
        {
            if (_playerRangeCache.ContainsKey(playerId))
            {
                return _playerRangeCache[playerId];
            }
        
            foreach (KeyValuePair<string, float> rangePerm in _pluginConfig.Ranges.OrderByDescending(pr => pr.Value))
            {
                if (HasPermission(playerId, rangePerm.Key))
                {
                    _playerRangeCache[playerId] = rangePerm.Value;
                    return rangePerm.Value;
                }
            }

            _playerRangeCache[playerId] = 16f;
            return 16f;
        }
        
        private bool HasPermission(ulong playerId, string perm) => permission.UserHasPermission(playerId.ToString(), perm);
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Permission Ranges (Meters)")]
            public Hash<string, float> Ranges { get; set; }
        }
        #endregion
    }
}


// --- End of file: TcExtender.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/temperature-extender ---
// --- Original File Path: T/TemperatureExtender/TemperatureExtender.cs ---

using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Temperature Extender", "MJSU", "1.0.2")]
    [Description("Extends the range of temperature and comfort")]
    public class TemperatureExtender : RustPlugin
    {
        #region Class Fields
        private PluginConfig _pluginConfig; //Plugin Config
        private readonly Hash<string, EntitySettings> _defaultSettings = new Hash<string, EntitySettings>();

        private bool _init;
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.EntitySettings = config.EntitySettings ?? new Hash<string, EntitySettings>();
            return config;
        }
        
        private void OnServerInitialized()
        {
            foreach (string prefab in FileSystem.Backend.cache.Keys)
            {
                GameObject go = GameManager.server.FindPrefab(prefab);
                BaseCombatEntity entity = go?.GetComponent<BaseCombatEntity>();
                if (entity == null)
                {
                    continue;
                }
                
                AddSetting(_pluginConfig.EntitySettings, entity, false);
                AddSetting(_defaultSettings, entity, true);
            }
            
            Config.WriteObject(_pluginConfig);
            
            UpdateAllEntities(_pluginConfig.EntitySettings);

            _init = true;
        }

        private void AddSetting(Hash<string, EntitySettings> settings, BaseCombatEntity entity, bool enabled)
        {
            TriggerTemperature temp = entity.GetComponentInChildren<TriggerTemperature>();
            TriggerComfort comfort = entity.GetComponentInChildren<TriggerComfort>();

            if (temp == null && comfort == null)
            {
                return;
            }
            
            if (settings.ContainsKey(entity.ShortPrefabName))
            {
                return;
            }

            EntitySettings setting = new EntitySettings
            {
                Enabled = enabled
            };
            
            settings[entity.ShortPrefabName] = setting;

            if (temp != null)
            {
                setting.Temperature = GetTemperatureSettings(temp);
            }

            if (comfort != null)
            {
                setting.Comfort = GetComfortSettings(comfort);
            }
        }

        private void Unload()
        {
            UpdateAllEntities(_defaultSettings);
        }
        #endregion

        #region uMod Hooks

        private void OnEntitySpawned(BaseCombatEntity entity)
        {
            if (!_init)
            {
                return;
            }
            
            UpdateEntity(entity, _pluginConfig.EntitySettings);
        }

        #endregion

        #region Entity Methods

        private void UpdateAllEntities(Hash<string, EntitySettings> settings)
        {
            foreach (BaseCombatEntity entity in BaseNetworkable.serverEntities.OfType<BaseCombatEntity>())
            {
                UpdateEntity(entity, settings);
            }
        }

        private void UpdateEntity(BaseCombatEntity entity, Hash<string, EntitySettings> settings)
        {
            EntitySettings setting = settings[entity.ShortPrefabName];
            if (setting == null || !setting.Enabled)
            {
                return;
            }

            TriggerTemperature temp = entity.GetComponentInChildren<TriggerTemperature>(true);
            if (temp != null && setting.Temperature != null)
            {
                SphereCollider sphere = temp.GetComponent<SphereCollider>();
                temp.Temperature = setting.Temperature.Temperature;
                temp.minSize = setting.Temperature.MinRange;
                sphere.radius = setting.Temperature.TriggerRadius;
                temp.triggerSize = sphere.radius * entity.transform.localScale.y * setting.Temperature.FalloffRate;
            }
            
            TriggerComfort comfort = entity.GetComponentInChildren<TriggerComfort>(true);
            if (comfort != null)
            {
                SphereCollider sphere = comfort.GetComponent<SphereCollider>();
                comfort.baseComfort = setting.Comfort.BaseComfort;
                comfort.minComfortRange = setting.Comfort.MinRange;
                sphere.radius = setting.Comfort.TriggerRadius;
                comfort.triggerSize = sphere.radius * entity.transform.localScale.y * setting.Comfort.FalloffRate;
            }
        }

        private TemperatureSettings GetTemperatureSettings(TriggerTemperature temp)
        {
            SphereCollider sphere = temp.GetComponent<SphereCollider>();
            return new TemperatureSettings
            {
                Temperature = temp.Temperature,
                MinRange = temp.minSize,
                TriggerRadius = sphere.radius,
                FalloffRate = temp.triggerSize / sphere.radius
            };
        }

        private ComfortSettings GetComfortSettings(TriggerComfort comfort)
        {
            SphereCollider sphere = comfort.GetComponent<SphereCollider>();
            return new ComfortSettings
            {
                BaseComfort = comfort.baseComfort,
                MinRange = comfort.minComfortRange,
                TriggerRadius = sphere.radius,
                FalloffRate = comfort.triggerSize / sphere.radius
            };
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Entity Settings")]
            public Hash<string, EntitySettings> EntitySettings { get; set; }
        }

        private class EntitySettings
        {
            public TemperatureSettings Temperature { get; set; }
            public ComfortSettings Comfort { get; set; }
            public bool Enabled { get; set; }
        }
        
        private class TemperatureSettings
        {
            [JsonProperty(PropertyName = "Max temperature")]
            public float Temperature { get; set; }
            
            [JsonProperty(PropertyName = "Temperature range (Meters)")]
            public float TriggerRadius { get; set; }
            
            [JsonProperty(PropertyName = "Temperature falloff rate multiplier ( > 1 falls off slower < 1 falls off quicker)")]
            public float FalloffRate { get; set; }
            
            [JsonProperty(PropertyName = "Minimum range from entity before temperature takes effect")]
            public float MinRange { get; set; }
        }
        
        private class ComfortSettings
        {
            [JsonProperty(PropertyName = "Max comfort")]
            public float BaseComfort { get; set; }
            
            [JsonProperty(PropertyName = "Comfort range (Meters)")]
            public float TriggerRadius { get; set; }
            
            [JsonProperty(PropertyName = "Comfort falloff rate multiplier ( > 1 falls off slower < 1 falls off quicker)")]
            public float FalloffRate { get; set; }
            
            [JsonProperty(PropertyName = "Minimum range from entity before temperature takes effect")]
            public float MinRange { get; set; }
        }
        #endregion
    }
}

// --- End of file: TemperatureExtender.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/team-loot ---
// --- Original File Path: T/TeamLoot/TeamLoot.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Team Loot", "Synvy", "1.1.1")]
    [Description("Prevents players outside of your team from looting your body.")]
    public class TeamLoot : RustPlugin
    {
        #region Initialize

        private const string bypass = "teamloot.bypass";

        private void Init()
        {
            permission.RegisterPermission(bypass, this);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["WarningMessage"] = "You do not have permission to loot this player!"

            }, this);
        }

        #endregion Initialize

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty("Show warning message")]
            public bool showWarningMessage = true;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<Configuration>();

                if (_config == null)
                {
                    throw new JsonException();
                }

                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    SaveConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        #endregion Configuration

        #region Hooks

        private object CanLootPlayer(BasePlayer target, BasePlayer looter)
        {
            if (!HasPerm(looter.UserIDString, bypass))
            {
                if (target is not NPCPlayer)
                {
                    if (looter.userID != target.userID)
                    {
                        if (looter.currentTeam == 0UL)
                        {
                            if (_config.showWarningMessage)
                            {
                                PrintWarningMessage(looter, "WarningMessage");
                            }

                            return false;
                        }
                    }
                    else if ((looter.currentTeam != 0UL) && !looter.Team.members.Contains(target.userID))
                    {
                        if (_config.showWarningMessage)
                        {
                            PrintWarningMessage(looter, "WarningMessage");
                        }

                        return false;
                    }
                }         
            }

            return null;
        }

        private object CanLootEntity(BasePlayer player, DroppedItemContainer container)
        {
            var target = BasePlayer.FindAwakeOrSleeping(container.playerSteamID.ToString());

            if (target == null || target is NPCPlayer)
            {
                return null;
            }

            if (!HasPerm(player.UserIDString, bypass))
            {
                if (player.userID != target.userID)
                {
                    if (player.currentTeam == 0UL)
                    {
                        if (_config.showWarningMessage)
                        {
                            PrintWarningMessage(player, "WarningMessage");
                        }

                        return false;
                    }
                    else if ((player.currentTeam != 0UL) && !player.Team.members.Contains(target.userID))
                    {
                        if (_config.showWarningMessage)
                        {
                            PrintWarningMessage(player, "WarningMessage");
                        }

                        return false;
                    }
                }
            }

            return null;
        }

        private object CanLootEntity(BasePlayer player, LootableCorpse corpse)
        {
            var target = BasePlayer.FindAwakeOrSleeping(corpse.playerSteamID.ToString());

            if (target == null || target is NPCPlayer)
            {
                return null;
            }

            if (!HasPerm(player.UserIDString, bypass))
            {
                if (player.userID != target.userID)
                {
                    if (player.currentTeam == 0UL)
                    {
                        if (_config.showWarningMessage)
                        {
                            PrintWarningMessage(player, "WarningMessage");
                        }

                        return false;
                    }
                    else if ((player.currentTeam != 0UL) && !player.Team.members.Contains(target.userID))
                    {
                        if (_config.showWarningMessage)
                        {
                            PrintWarningMessage(player, "WarningMessage");
                        }

                        return false;
                    }
                }
            }

            return null;
        }

        #endregion Hooks

        #region Helpers

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private string GetLang(string langKey, string playerId = null, params object[] args) => string.Format(lang.GetMessage(langKey, this, playerId), args);

        private void PrintWarningMessage(BasePlayer player, string message)
        {
            PrintToChat(player, GetLang(message, player.UserIDString));
        }

        #endregion Helpers
    }
}

// --- End of file: TeamLoot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/telekinesis ---
// --- Original File Path: T/Telekinesis/Telekinesis.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Telekinesis", "WhiteThunder", "3.3.0")]
    [Description("Allows players to move and rotate objects in place.")]
    internal class Telekinesis : CovalencePlugin
    {
        #region Fields

        private static Telekinesis _pluginInstance;
        private static Configuration _config;

        private const string PermissionAdmin = "telekinesis.admin";
        private const string PermissionRulesetFormat = "telekinesis.ruleset.{0}";

        private TelekinesisManager _telekinesisManager;
        private UndoManager _undoManager;

        private readonly object True = true;
        private readonly object False = false;

        public Telekinesis()
        {
            _undoManager = new UndoManager(timer);
            _telekinesisManager = new TelekinesisManager(_undoManager);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginInstance = this;

            permission.RegisterPermission(PermissionAdmin, this);

            foreach (var ruleset in _config.Rulesets)
            {
                if (ruleset.Permission != null)
                {
                    permission.RegisterPermission(ruleset.Permission, this);
                }
            }
        }

        private void Unload()
        {
            _telekinesisManager.StopAll();

            _config = null;
            _pluginInstance = null;
        }

        #endregion

        #region API

        [HookMethod(nameof(API_IsBeingControlled))]
        public object API_IsBeingControlled(Component component)
        {
            return _telekinesisManager.IsBeingControlled(component) ? True : False;
        }

        [HookMethod(nameof(API_IsUsingTelekinesis))]
        public object API_IsUsingTelekinesis(BasePlayer player)
        {
            return _telekinesisManager.IsUsingTelekinesis(player) ? True : False;
        }

        [HookMethod(nameof(API_StartAdminTelekinesis))]
        public bool API_StartAdminTelekinesis(BasePlayer player, Component component)
        {
            return _telekinesisManager.TryStartTelekinesis(player, component, PlayerRuleset.AdminRuleset);
        }

        [HookMethod(nameof(API_StopPlayerTelekinesis))]
        public void API_StopPlayerTelekinesis(BasePlayer player)
        {
            _telekinesisManager.StopPlayerTelekinesis(player);
        }

        [HookMethod(nameof(API_StopTargetTelekinesis))]
        public void API_StopTargetTelekinesis(Component target)
        {
            _telekinesisManager.StopTargetTelekinesis(target);
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            // Allow plugins to provide an entity that doesn't have a collider.
            public static Component OnTelekinesisFindFailed(BasePlayer player)
            {
                return Interface.CallHook("OnTelekinesisFindFailed", player) as Component;
            }

            // Allow plugins to replace the target entity with a more suitable one (e.g., the parent entity).
            public static Tuple<Component, Component> OnTelekinesisStart(BasePlayer player, Component component)
            {
                var result = Interface.CallHook("OnTelekinesisStart", player, component);
                if (result is Tuple<BaseEntity, BaseEntity> entityTuple)
                    return new Tuple<Component, Component>(entityTuple.Item1, entityTuple.Item2);

                if (result is Tuple<Component, Component> componentTuple)
                    return componentTuple;

                var resultEntity = result as BaseEntity;
                if (resultEntity != null)
                    return new Tuple<Component, Component>(resultEntity, resultEntity);

                return new Tuple<Component, Component>(component, component);
            }

            // Allow plugins to prevent telekinesis based on arbitrary circumstances.
            public static bool CanStartTelekinesis(BasePlayer player, Component moveComponent, Component rotateComponent, out string errorMessage)
            {
                errorMessage = null;

                var hookResult = Interface.CallHook("CanStartTelekinesis", player, moveComponent, rotateComponent);
                if (hookResult is false)
                    return false;

                errorMessage = hookResult as string;
                return errorMessage == null;
            }

            // Notify plugins that telekinesis started.
            public static void OnTelekinesisStarted(BasePlayer player, Component moveComponent, Component rotateComponent)
            {
                Interface.CallHook("OnTelekinesisStarted", player, moveComponent, rotateComponent);
            }

            // Notify plugins that telekinesis stopped.
            public static void OnTelekinesisStopped(BasePlayer player, Component moveComponent, Component rotateComponent)
            {
                Interface.CallHook("OnTelekinesisStopped", player, moveComponent, rotateComponent);
            }
        }

        #endregion

        #region Commands

        [Command("telekinesis", "tls")]
        private void CommandTelekinesis(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer)
                return;

            var ruleset = _config.GetPlayerRuleset(permission, player.Id);
            if (ruleset == null)
            {
                ReplyToPlayer(player, Lang.ErrorNoPermission);
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
                return;

            if (args.Length > 0 && args[0] == "undo")
            {
                if (_undoManager.TryUndo(basePlayer.userID, out var previousMoveComponent, out var previousRotateComponent))
                {
                    if (_telekinesisManager.IsUsingTelekinesis(basePlayer))
                    {
                        _telekinesisManager.StopPlayerTelekinesis(basePlayer);
                    }
                    else
                    {
                        ExposedHooks.OnTelekinesisStopped(basePlayer, previousMoveComponent, previousRotateComponent);
                    }

                    ReplyToPlayer(player, Lang.UndoSuccess);
                }
                else
                {
                    ReplyToPlayer(player, Lang.ErrorUndoNotFound);
                }

                return;
            }

            if (_telekinesisManager.IsUsingTelekinesis(basePlayer))
            {
                _telekinesisManager.StopPlayerTelekinesis(basePlayer);
                return;
            }

            Component component = GetLookEntity(basePlayer);
            if (component == null)
            {
                component = ExposedHooks.OnTelekinesisFindFailed(basePlayer);
                if (component == null)
                {
                    ReplyToPlayer(player, Lang.ErrorNoEntityFound);
                    return;
                }
            }

            if (!ruleset.CanMovePlayers && component is BasePlayer)
            {
                ChatMessageWithPrefix(basePlayer, Lang.ErrorCannotMovePlayers);
                return;
            }

            if (ruleset.MaxDistance > 0 && Vector3.Distance(basePlayer.eyes.position, component.transform.position) > ruleset.MaxDistance)
            {
                ChatMessageWithPrefix(basePlayer, Lang.ErrorMaxDistance);
                return;
            }

            if (ruleset.RequiresOwnership && component is BaseEntity entity && entity.OwnerID != basePlayer.userID)
            {
                ChatMessageWithPrefix(basePlayer, Lang.ErrorNotOwned);
                return;
            }

            if (!ruleset.CanUseWhileBuildingBlocked && IsBuildingBlocked(basePlayer, component))
            {
                ChatMessageWithPrefix(basePlayer, Lang.ErrorBuildingBlocked);
                return;
            }

            if (component is BaseVehicleModule vehicleModule)
            {
                if (vehicleModule.Vehicle != null)
                {
                    component = vehicleModule.Vehicle;
                }
            }

            _telekinesisManager.TryStartTelekinesis(basePlayer, component, ruleset);
        }

        #endregion

        #region Helper Methods

        private static Vector3 TransformPoint(Vector3 origin, Vector3 localPosition, Quaternion rotation)
        {
            return origin + rotation * localPosition;
        }

        private static Vector3 InverseTransformPoint(Vector3 origin, Vector3 worldPosition, Quaternion rotation)
        {
            return Quaternion.Inverse(rotation) * (worldPosition - origin);
        }

        private static BaseEntity GetLookEntity(BasePlayer player, int layerMask = Physics.DefaultRaycastLayers, float maxDistance = 15)
        {
            return Physics.Raycast(player.eyes.HeadRay(), out var hit, maxDistance, layerMask, QueryTriggerInteraction.Ignore)
                ? hit.GetEntity()
                : null;
        }

        private static void BroadcastEntityTransformChange(BaseEntity entity, Transform transform = null)
        {
            transform ??= entity.transform;

            var wasSyncPosition = entity.syncPosition;
            entity.syncPosition = true;
            entity.TransformChanged();
            entity.syncPosition = wasSyncPosition;

            transform.hasChanged = false;

            if (entity is StabilityEntity)
            {
                // Not great for performance, but can be optimized later.
                entity.TerminateOnClient(BaseNetworkable.DestroyMode.None);
                entity.SendNetworkUpdateImmediate();

                foreach (var child in entity.children)
                {
                    child.SendNetworkUpdateImmediate();
                }
            }
        }

        private static void RemoveActiveItem(BasePlayer player)
        {
            var activeItem = player.GetActiveItem();
            if (activeItem == null)
                return;

            var slot = activeItem.position;
            activeItem.RemoveFromContainer();
            player.inventory.SendUpdatedInventory(PlayerInventory.Type.Belt, player.inventory.containerBelt);

            var playerPosition = player.transform.position;

            // Use server manager to ensure the invoke isn't canceled (player invoke or oxide timer could be).
            ServerMgr.Instance.Invoke(() =>
            {
                if (!activeItem.MoveToContainer(player.inventory.containerBelt, slot)
                    && !player.inventory.GiveItem(activeItem))
                {
                    activeItem.DropAndTossUpwards(playerPosition);
                }
            }, 0.2f);
        }

        private static bool IsBuildingBlocked(BasePlayer player, Component component)
        {
            if (component is BaseEntity entity)
            {
                return player.IsBuildingBlocked(entity.WorldSpaceBounds());
            }

            return player.IsBuildingBlocked(component.transform.position, Quaternion.identity, new Bounds());
        }

        #endregion

        #region TelekinesisManager

        private class TelekinesisManager
        {
            private UndoManager _undoManager;
            private Dictionary<BasePlayer, TelekinesisComponent> _playerComponents = new();

            public TelekinesisManager(UndoManager undoManager)
            {
                _undoManager = undoManager;
            }

            public void Register(TelekinesisComponent component)
            {
                _playerComponents[component.Player] = component;
                ExposedHooks.OnTelekinesisStarted(component.Player, component.MoveComponent, component.RotateComponent);
            }

            public void Unregister(TelekinesisComponent component)
            {
                _playerComponents.Remove(component.Player);
                ExposedHooks.OnTelekinesisStopped(component.Player, component.MoveComponent, component.RotateComponent);
            }

            public bool IsBeingControlled(Component component)
            {
                if (component == null || component is BaseEntity { IsDestroyed: true })
                    return false;

                return TelekinesisComponent.GetForComponent(component) != null;
            }

            public bool IsUsingTelekinesis(BasePlayer player)
            {
                return GetPlayerTelekinesisTarget(player) != null;
            }

            public bool TryStartTelekinesis(BasePlayer player, Component component, PlayerRuleset ruleset)
            {
                // Prevent multiple players from simultaneously controlling the entity.
                if (IsBeingControlled(component))
                {
                    _pluginInstance.ChatMessageWithPrefix(player, Lang.ErrorAlreadyBeingControlled);
                    return false;
                }

                // Prevent the player from simultaneously controlling multiple entities.
                if (IsUsingTelekinesis(player))
                {
                    _pluginInstance.ChatMessageWithPrefix(player, Lang.ErrorAlreadyUsingTelekinesis);
                    return false;
                }

                // Allow plugins to swap out the entities.
                var (moveComponent, rotateComponent) = ExposedHooks.OnTelekinesisStart(player, component);

                // Allow plugins to prevent telekinesis on specific entities.
                if (!ExposedHooks.CanStartTelekinesis(player, moveComponent, rotateComponent, out var errorMessage))
                {
                    if (errorMessage != null)
                    {
                        player.ChatMessage(errorMessage);
                    }
                    else
                    {
                        _pluginInstance.ChatMessageWithPrefix(player, Lang.ErrorBlockedByPlugin);
                    }

                    return false;
                }

                var restorePoint = _undoManager.SavePosition(player.userID, moveComponent, rotateComponent);
                TelekinesisComponent.AddToComponent(moveComponent, rotateComponent, this, player, ruleset, restorePoint);
                RemoveActiveItem(player);

                var modeMessage = _pluginInstance.GetModeMessage(player, TelekinesisMode.MovePlayerOffset);
                _pluginInstance.ChatMessageWithPrefix(player, Lang.InfoEnabled, modeMessage);

                return true;
            }

            public void StopPlayerTelekinesis(BasePlayer player)
            {
                GetPlayerTelekinesisTarget(player)?.DestroyImmediate();
            }

            public void StopTargetTelekinesis(Component component)
            {
                TelekinesisComponent.GetForComponent(component)?.DestroyImmediate();
            }

            public void StopAll()
            {
                foreach (var component in _playerComponents.Values.ToArray())
                {
                    component.DestroyImmediate();
                }
            }

            private TelekinesisComponent GetPlayerTelekinesisTarget(BasePlayer player)
            {
                return _playerComponents.GetValueOrDefault(player);
            }
        }

        #endregion

        #region Undo Manager

        private class RestorePoint
        {
            private static bool IsComponentValid(Component component)
            {
                return component != null && component is not BaseEntity { IsDestroyed: true };
            }

            private const float ExpirationSeconds = 300;

            public bool IsValid => IsComponentValid(_moveComponent) && IsComponentValid(_rotateComponent);

            private PluginTimers _pluginTimers;
            private Component _moveComponent;
            private Component _rotateComponent;
            private Vector3 _localPosition;
            private Quaternion _localRotation;
            private Action _cleanup;
            private Timer _timer;

            public RestorePoint(PluginTimers pluginTimers, Component moveComponent, Component rotateComponent, Action cleanup)
            {
                _pluginTimers = pluginTimers;

                _moveComponent = moveComponent;
                _rotateComponent = rotateComponent;
                _localPosition = moveComponent.transform.localPosition;
                _localRotation = rotateComponent is BasePlayer rotatePlayer
                    ? Quaternion.Euler(rotatePlayer.viewAngles)
                    : rotateComponent.transform.localRotation;
                _cleanup = cleanup;
            }

            public bool TryRestore(out Component moveComponent, out Component rotateComponent)
            {
                moveComponent = _moveComponent;
                rotateComponent = _rotateComponent;

                if (!IsValid)
                {
                    Destroy();
                    return false;
                }

                _moveComponent.transform.localPosition = _localPosition;

                if (_rotateComponent is BasePlayer rotatePlayer)
                {
                    rotatePlayer.viewAngles = _localRotation.eulerAngles;
                }
                else
                {
                    _rotateComponent.transform.localRotation = _localRotation;
                }

                if (_moveComponent is BaseEntity moveEntity)
                {
                    BroadcastEntityTransformChange(moveEntity);
                }

                if (_rotateComponent != _moveComponent && _rotateComponent is BaseEntity rotateEntity)
                {
                    BroadcastEntityTransformChange(rotateEntity);
                }

                Destroy();
                return true;
            }

            public void StartExpirationTimer()
            {
                if (!IsValid)
                    return;

                _timer = _pluginTimers.Once(ExpirationSeconds, _cleanup);
            }

            public void Destroy()
            {
                _timer?.Destroy();
                _cleanup();
            }
        }

        private class UndoManager
        {
            private Dictionary<ulong, RestorePoint> _playerRestorePoints = new();
            private PluginTimers _pluginTimers;

            public UndoManager(PluginTimers pluginTimers)
            {
                _pluginTimers = pluginTimers;
            }

            public RestorePoint SavePosition(ulong userId, Component moveComponent, Component rotateComponent)
            {
                GetRestorePoint(userId)?.Destroy();

                var restorePoint = new RestorePoint(_pluginTimers, moveComponent, rotateComponent, () => _playerRestorePoints.Remove(userId));
                _playerRestorePoints[userId] = restorePoint;
                return restorePoint;
            }

            public bool TryUndo(ulong userId, out Component moveComponent, out Component rotateComponent)
            {
                var restorePoint = GetRestorePoint(userId);
                if (restorePoint == null)
                {
                    moveComponent = null;
                    rotateComponent = null;
                    return false;
                }

                return restorePoint.TryRestore(out moveComponent, out rotateComponent);
            }

            private RestorePoint GetRestorePoint(ulong userId)
            {
                return _playerRestorePoints.GetValueOrDefault(userId);
            }
        }

        #endregion

        #region Telekinesis Component

        private enum TelekinesisMode
        {
            MovePlayerOffset,
            MoveY,
            RotateX,
            RotateY,
            RotateZ,
        }

        private class TelekinesisComponent : FacepunchBehaviour
        {
            private class RigidbodyRestorePoint
            {
                private Rigidbody _rigidBody;
                private bool _useGravity;
                private bool _isKinematic;

                public static RigidbodyRestorePoint CreateRestore(Rigidbody rigidbody)
                {
                    if (rigidbody == null)
                        return null;

                    if (!rigidbody.useGravity && rigidbody.isKinematic)
                        return null;

                    var restore = new RigidbodyRestorePoint
                    {
                        _rigidBody = rigidbody,
                        _useGravity = rigidbody.useGravity,
                        _isKinematic = rigidbody.isKinematic,
                    };

                    rigidbody.useGravity = false;
                    rigidbody.isKinematic = true;

                    return restore;
                }

                public void Restore()
                {
                    if (_rigidBody == null)
                        return;

                    _rigidBody.useGravity = _useGravity;
                    _rigidBody.isKinematic = _isKinematic;
                }
            }

            private const float ModeChangeDelay = 0.25f;

            public static void AddToComponent(Component moveComponent, Component rotateComponent, TelekinesisManager manager, BasePlayer player, PlayerRuleset ruleset, RestorePoint restorePoint) =>
                moveComponent.gameObject.AddComponent<TelekinesisComponent>().Init(moveComponent, rotateComponent, manager, player, ruleset, restorePoint);

            public static TelekinesisComponent GetForComponent(Component component) =>
                component.gameObject.GetComponent<TelekinesisComponent>();

            public Component MoveComponent { get; private set; }
            public Component RotateComponent { get; private set; }
            public BasePlayer Player { get; private set; }

            private Transform _moveTransform;
            private Transform _rotateTransform;
            private PlayerRuleset _ruleset;
            private TelekinesisManager _manager;
            private RestorePoint _restorePoint;
            private float _maxDistanceSquared;

            private TelekinesisMode _mode = TelekinesisMode.MovePlayerOffset;
            private float _lastBuildingBlockCheck = UnityEngine.Time.time;

            // Keep track of when the component is destroyed for an explicit reason, to avoid sending an extra notification.
            private bool _wasDestroyedForExplicitReason;

            // Keep track of where the entity is relative to the player eyes.
            // This precise offset is maintained throughout the movement session.
            private Vector3 _headOffset;

            // Keep track of last time the entity moved in order to time it out.
            private float _lastMoved;

            // Keep track of the last mode change to avoid changing mode too rapidly.
            private float _lastChangedMode = UnityEngine.Time.time;

            // Keep track of original rigid body settings so they can be restored.
            private RigidbodyRestorePoint _rigidbodyRestore;

            public TelekinesisComponent Init(Component moveComponent, Component rotateComponent, TelekinesisManager manager, BasePlayer player, PlayerRuleset ruleset, RestorePoint restorePoint)
            {
                MoveComponent = moveComponent;
                RotateComponent = rotateComponent;
                _moveTransform = MoveComponent.transform;
                _rotateTransform = RotateComponent.transform;
                Player = player;

                _ruleset = ruleset;
                _maxDistanceSquared = Mathf.Pow(ruleset.MaxDistance, 2);
                _manager = manager;
                _manager.Register(this);
                _restorePoint = restorePoint;

                _lastMoved = UnityEngine.Time.realtimeSinceStartup;
                _headOffset = InverseTransformPoint(player.eyes.position, _moveTransform.position, player.eyes.rotation);

                _rigidbodyRestore = RigidbodyRestorePoint.CreateRestore(GetComponent<Rigidbody>());

                // Use facepunch invoke handler instead of Update() to avoid overhead incurred by calling from native.
                InvokeRepeating(TrackedUpdate, 0, 0);

                return this;
            }

            public void DestroyImmediate(string reason = null)
            {
                if (reason != null && Player != null)
                {
                    Player.ChatMessage(reason);
                    _wasDestroyedForExplicitReason = true;
                }

                DestroyImmediate(this);
            }

            private void MaybeSwitchMode(float now)
            {
                if (_lastChangedMode + ModeChangeDelay > now
                    || !Player.serverInput.IsDown(BUTTON.RELOAD))
                    return;

                _lastChangedMode = now;

                if (Player.serverInput.IsDown(BUTTON.SPRINT))
                {
                    switch (_mode)
                    {
                        case TelekinesisMode.RotateZ:
                            _mode = TelekinesisMode.RotateY;
                            break;
                        case TelekinesisMode.RotateY:
                            _mode = TelekinesisMode.RotateX;
                            break;
                        case TelekinesisMode.RotateX:
                            _mode = TelekinesisMode.MoveY;
                            break;
                        case TelekinesisMode.MoveY:
                            _mode = TelekinesisMode.MovePlayerOffset;
                            break;
                        case TelekinesisMode.MovePlayerOffset:
                            // Can't rotate players on the Z axis, so skip RotateZ.
                            _mode = RotateComponent is BasePlayer
                                ? TelekinesisMode.RotateY
                                : TelekinesisMode.RotateZ;
                            break;
                    }
                }
                else
                {
                    switch (_mode)
                    {
                        case TelekinesisMode.MovePlayerOffset:
                            _mode = TelekinesisMode.MoveY;
                            break;
                        case TelekinesisMode.MoveY:
                            _mode = TelekinesisMode.RotateX;
                            break;
                        case TelekinesisMode.RotateX:
                            _mode = TelekinesisMode.RotateY;
                            break;
                        case TelekinesisMode.RotateY:
                            // Can't rotate players on the Z axis, so skip RotateZ.
                            _mode = RotateComponent is BasePlayer
                                ? TelekinesisMode.MovePlayerOffset
                                : TelekinesisMode.RotateZ;
                            break;
                        case TelekinesisMode.RotateZ:
                            _mode = TelekinesisMode.MovePlayerOffset;
                            break;
                    }
                }

                _pluginInstance.SendModeChatMessage(Player, _mode);
            }

            private float GetSensitivityMultiplier(SpeedSettings speedSettings)
            {
                if (Player.serverInput.IsDown(BUTTON.SPRINT))
                    return speedSettings.Fast;

                if (Player.serverInput.IsDown(BUTTON.DUCK))
                    return speedSettings.Slow;

                return speedSettings.Normal;
            }

            private void SetHeadOffset(Vector3 newHeadOffset)
            {
                // Verify max distance isn't being exceeded.
                if (_maxDistanceSquared > 0 && newHeadOffset.sqrMagnitude > _maxDistanceSquared)
                    return;

                _headOffset = newHeadOffset;
            }

            private float GetMoveAdjustment(float deltaTimeAndDirection)
            {
                return deltaTimeAndDirection * GetSensitivityMultiplier(_config.MoveSensitivity);
            }

            private float GetRotationAdjustment(float deltaTimeAndDirection)
            {
                return 50f * deltaTimeAndDirection * GetSensitivityMultiplier(_config.RotateSensitivity);
            }

            private void RotateViewAngles(BasePlayer rotatePlayer)
            {
                var rotation = _rotateTransform.rotation;
                rotatePlayer.viewAngles = rotation.eulerAngles;

                if (rotatePlayer is NPCShopKeeper shopKeeper)
                {
                    shopKeeper.initialFacingDir = rotation * Vector3.forward;
                }
            }

            private void MaybeMoveOrRotate(float now)
            {
                var direction = Player.serverInput.IsDown(BUTTON.FIRE_PRIMARY)
                    ? 1 : Player.serverInput.IsDown(BUTTON.FIRE_SECONDARY)
                    ? -1 : 0;

                var eyeRotation = Player.eyes.rotation;
                var rotatePlayer = RotateComponent as BasePlayer;

                if (direction != 0)
                {
                    var delta = UnityEngine.Time.deltaTime * direction;

                    switch (_mode)
                    {
                        case TelekinesisMode.MovePlayerOffset:
                        {
                            SetHeadOffset(_headOffset + new Vector3(0, 0, GetMoveAdjustment(delta)));
                            break;
                        }

                        case TelekinesisMode.MoveY:
                        {
                            SetHeadOffset(_headOffset + Quaternion.Inverse(eyeRotation) * new Vector3(0, GetMoveAdjustment(delta), 0));
                            break;
                        }

                        case TelekinesisMode.RotateX:
                        {
                            var rotateAngle = GetRotationAdjustment(delta);
                            _rotateTransform.Rotate(rotateAngle, 0, 0);
                            if (rotatePlayer is not null)
                            {
                                RotateViewAngles(rotatePlayer);
                            }

                            break;
                        }

                        case TelekinesisMode.RotateY:
                        {
                            var rotateAngle = -GetRotationAdjustment(delta);
                            _rotateTransform.Rotate(0, rotateAngle, 0);
                            if (rotatePlayer is not null)
                            {
                                RotateViewAngles(rotatePlayer);
                            }

                            break;
                        }

                        case TelekinesisMode.RotateZ:
                        {
                            // Can't rotate players on the Z axis.
                            if (rotatePlayer is null)
                            {
                                _rotateTransform.Rotate(0, 0, GetRotationAdjustment(delta));
                            }

                            break;
                        }
                    }
                }

                var eyePosition = Player.eyes.position;
                var desiredPosition = TransformPoint(eyePosition, _headOffset, eyeRotation);

                if (!_ruleset.CanUseWhileBuildingBlocked && _lastBuildingBlockCheck + _config.BuildingBlockedCheckFrequency < now)
                {
                    _lastBuildingBlockCheck = now;

                    var bounds = MoveComponent is BaseEntity moveEntity
                        ? moveEntity.bounds
                        : new Bounds();

                    // Perform the building block check at the entity location.
                    if (Player.IsBuildingBlocked(new OBB(desiredPosition, _moveTransform.lossyScale, _moveTransform.rotation, bounds)))
                    {
                        DestroyImmediate(_pluginInstance?.GetMessageWithPrefix(Player, Lang.InfoDisableBuildingBlocked));
                        return;
                    }
                }

                if (_moveTransform.position != desiredPosition)
                {
                    if ((desiredPosition - _moveTransform.position).sqrMagnitude > 0.0001f)
                    {
                        // Interpolate over longer distances (> 0.01) so the movement is less jumpy.
                        _moveTransform.position = Vector3.Lerp(_moveTransform.position, desiredPosition, UnityEngine.Time.deltaTime * 15);
                    }
                    else
                    {
                        // Don't interpolate when really close, so that the position eventually matches.
                        _moveTransform.position = desiredPosition;
                    }
                }

                var hasChanged = false;

                if (_moveTransform.hasChanged)
                {
                    if (MoveComponent is BaseEntity moveEntity)
                    {
                        BroadcastEntityTransformChange(moveEntity, _moveTransform);
                    }

                    hasChanged = true;
                }

                if (_rotateTransform.hasChanged)
                {
                    if (RotateComponent is BaseEntity rotateEntity)
                    {
                        BroadcastEntityTransformChange(rotateEntity, _rotateTransform);
                    }

                    hasChanged = true;
                }

                if (hasChanged)
                {
                    _lastMoved = UnityEngine.Time.realtimeSinceStartup;
                }
                else if (_lastMoved + _config.IdleTimeout < UnityEngine.Time.realtimeSinceStartup)
                {
                    DestroyImmediate(_pluginInstance?.GetMessageWithPrefix(Player, Lang.InfoDisableInactivity));
                    return;
                }
            }

            private void DoUpdate()
            {
                if (Player == null
                    || Player.IsDestroyed
                    || Player.IsDead()
                    || !Player.IsConnected
                    || (RotateComponent != MoveComponent && RotateComponent == null))
                {
                    DestroyImmediate();
                    return;
                }

                var now = UnityEngine.Time.time;

                MaybeSwitchMode(now);
                MaybeMoveOrRotate(now);
            }

            private void TrackedUpdate()
            {
                _pluginInstance?.TrackStart();
                DoUpdate();
                _pluginInstance?.TrackEnd();
            }

            private void OnDestroy()
            {
                _rigidbodyRestore?.Restore();
                _restorePoint?.StartExpirationTimer();
                MoveComponent.GetComponent<Buoyancy>()?.Wake();
                _manager.Unregister(this);

                if (!_wasDestroyedForExplicitReason && Player != null)
                {
                    _pluginInstance?.ChatMessageWithPrefix(Player, Lang.InfoDisabled);
                }
            }
        }

        #endregion

        #region Configuration

        private class PlayerRuleset
        {
            public static PlayerRuleset AdminRuleset = new()
            {
                CanMovePlayers = true,
                CanUseWhileBuildingBlocked = true,
                RequiresOwnership = false,
                MaxDistance = 0,
            };

            [JsonProperty("Permission suffix")]
            public string PermissionSuffix;

            [JsonProperty("Can move players")]
            public bool CanMovePlayers;

            [JsonProperty("Can use while building blocked")]
            public bool CanUseWhileBuildingBlocked;

            [JsonProperty("Requires ownership")]
            public bool RequiresOwnership;

            [JsonProperty("Max distance")]
            public float MaxDistance;

            private string _cachedPermission;

            [JsonIgnore]
            public string Permission
            {
                get
                {
                    if (_cachedPermission == null && !string.IsNullOrWhiteSpace(PermissionSuffix))
                    {
                        _cachedPermission = string.Format(PermissionRulesetFormat, PermissionSuffix);
                    }

                    return _cachedPermission;
                }
            }
        }

        private class SpeedSettings
        {
            [JsonProperty("Slow")]
            public float Slow = 0.2f;

            [JsonProperty("Normal")]
            public float Normal = 1;

            [JsonProperty("Fast")]
            public float Fast = 5;
        }

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("Enable message prefix")]
            public bool EnableMessagePrefix = true;

            [JsonProperty("Idle timeout (seconds)")]
            public float IdleTimeout = 60;

            [JsonProperty("Building privilege check frequency (seconds)")]
            public float BuildingBlockedCheckFrequency = 0.25f;

            [JsonProperty("Move sensitivity")]
            public SpeedSettings MoveSensitivity = new();

            [JsonProperty("Rotate sensitivity")]
            public SpeedSettings RotateSensitivity = new();

            [JsonProperty("Rulesets")]
            public PlayerRuleset[] Rulesets =
            {
                new()
                {
                    PermissionSuffix = "restricted",
                    CanMovePlayers = false,
                    CanUseWhileBuildingBlocked = false,
                    RequiresOwnership = true,
                    MaxDistance = 3,
                },
            };

            public PlayerRuleset GetPlayerRuleset(Permission permission, string userIdString)
            {
                if (permission.UserHasPermission(userIdString, PermissionAdmin))
                    return PlayerRuleset.AdminRuleset;

                if (Rulesets == null)
                    return null;

                for (var i = Rulesets.Length - 1; i >= 0; i--)
                {
                    var ruleset = Rulesets[i];
                    var perm = ruleset.Permission;
                    if (perm != null && permission.UserHasPermission(userIdString, perm))
                        return ruleset;
                }

                return null;
            }
        }

        private Configuration GetDefaultConfig() => new();

        #endregion

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Localization

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetMessageWithPrefix(string playerId, string messageName, params object[] args)
        {
            var message = GetMessage(playerId, messageName, args);

            if (_config.EnableMessagePrefix)
            {
                message = GetMessage(playerId, Lang.MessagePrefix) + message;
            }

            return message;
        }

        private string GetMessageWithPrefix(BasePlayer player, string messageName, params object[] args) =>
            GetMessageWithPrefix(player.UserIDString, messageName, args);

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(GetMessageWithPrefix(player.Id, messageName, args));

        private void ChatMessageWithPrefix(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(GetMessageWithPrefix(player.UserIDString, messageName, args));

        private string GetModeLangKey(TelekinesisMode mode)
        {
            switch (mode)
            {
                case TelekinesisMode.MovePlayerOffset:
                    return Lang.MovePlayerOffset;

                case TelekinesisMode.MoveY:
                    return Lang.ModeMoveY;

                case TelekinesisMode.RotateX:
                    return Lang.ModeRotateX;

                case TelekinesisMode.RotateY:
                    return Lang.ModeRotateY;

                case TelekinesisMode.RotateZ:
                    return Lang.ModeRotateZ;

                default:
                    return Enum.GetName(typeof(TelekinesisMode), mode);
            }
        }

        private string GetModeName(BasePlayer player, TelekinesisMode mode) =>
            GetMessage(player.UserIDString, GetModeLangKey(mode));

        private string GetModeMessage(BasePlayer player, TelekinesisMode mode) =>
            GetMessage(player.UserIDString, Lang.ModeChanged, GetModeName(player, mode));

        private void SendModeChatMessage(BasePlayer player, TelekinesisMode mode) =>
            ChatMessageWithPrefix(player, GetModeMessage(player, mode));

        private static class Lang
        {
            public const string ErrorNoPermission = "Error.NoPermission";
            public const string ErrorNoEntityFound = "Error.NoEntityFound";
            public const string ErrorAlreadyBeingControlled = "Error.AlreadyBeingControlled";
            public const string ErrorAlreadyUsingTelekinesis = "Error.AlreadyUsingTelekinesis";
            public const string ErrorBlockedByPlugin = "Error.BlockedByPlugin";
            public const string ErrorCannotMovePlayers = "Error.CannotMovePlayers";
            public const string ErrorNotOwned = "Error.NotOwned";
            public const string ErrorBuildingBlocked = "Error.BuildingBlocked";
            public const string ErrorMaxDistance = "Error.MaxDistance";

            public const string MessagePrefix = "MessagePrefix";
            public const string InfoEnabled = "Info.Enabled";
            public const string InfoDisabled = "Info.Disabled";
            public const string InfoDisableInactivity = "Info.Disabled.Inactivity";
            public const string InfoDisableBuildingBlocked = "Info.Disabled.BuildingBlocked";

            public const string ErrorUndoNotFound = "Undo.Error.NotFound";
            public const string UndoSuccess = "Undo.Success";

            public const string ModeChanged = "Mode.Changed";
            public const string MovePlayerOffset = "Mode.MovePlayerOffset";
            public const string ModeMoveY = "Mode.OffsetY";
            public const string ModeRotateX = "Mode.RotateX";
            public const string ModeRotateY = "Mode.RotateY";
            public const string ModeRotateZ = "Mode.RotateZ";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ErrorNoPermission] = "You don't have permission to do that.",
                [Lang.ErrorNoEntityFound] = "No entity found.",
                [Lang.ErrorAlreadyBeingControlled] = "That entity is already being controlled.",
                [Lang.ErrorAlreadyUsingTelekinesis] = "You are already using telekinesis.",
                [Lang.ErrorBlockedByPlugin] = "Another plugin blocked telekinesis.",
                [Lang.ErrorCannotMovePlayers] = "You are not allowed to use telekinesis on players.",
                [Lang.ErrorNotOwned] = "That do not own that entity.",
                [Lang.ErrorBuildingBlocked] = "You are not allowed to use telekinesis while building blocked.",
                [Lang.ErrorMaxDistance] = "You are not allowed to use telekinesis that far away.",

                [Lang.MessagePrefix] = "<color=#0ff>[Telekinesis]</color>: ",
                [Lang.InfoEnabled] = "Telekinesis has been enabled.\n{0}",
                [Lang.InfoDisabled] = "Telekinesis has been disabled.",
                [Lang.InfoDisableInactivity] = "Telekinesis has been disabled due to inactivity.",
                [Lang.InfoDisableBuildingBlocked] = "Telekinesis has been disabled because you are building blocked.",

                [Lang.ErrorUndoNotFound] = "No undo data found.",
                [Lang.UndoSuccess] = "Your last telekinesis movement was undone.",

                [Lang.ModeChanged] = "Current mode: {0}",
                [Lang.MovePlayerOffset] = "Move away/toward",
                [Lang.ModeMoveY] = "Move up/down",
                [Lang.ModeRotateX] = "Rotate around X axis (pitch)",
                [Lang.ModeRotateY] = "Rotate around Y axis (yaw)",
                [Lang.ModeRotateZ] = "Rotate around Z axis (roll)",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: Telekinesis.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tools-gather-manager ---
// --- Original File Path: T/ToolsGatherManager/ToolsGatherManager.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Tools Gather Manager", "hoppel", "1.0.5")]
    [Description("Adjusts the gather rate from certain tools")]
    public class ToolsGatherManager : RustPlugin
    {
        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            var player = entity as BasePlayer;
            if (!player || !HasPerm(player))
                return;

            var activeItem = player.GetActiveItem();
            if (activeItem != null)
            {
                var toolName = activeItem.info.shortname;
                if (config.tools.ContainsKey(toolName))
                {
                    item.amount = (int)(item.amount * config.tools[toolName]);

                    if (TOD_Sky.Instance.IsNight)
                    {
                        item.amount = (int)(item.amount * config.nightrate);
                    }
                    else if (TOD_Sky.Instance.IsDay)
                    {
                        item.amount = (int)(item.amount * config.dayrate);
                    }
                }
            }
        }

        private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            OnDispenserGather(dispenser, player, item);
        }

        #region config

        private const string permName = "toolsgathermanager.allow";

        private void RegisterToolPermissions()
        {
            foreach (var def in ItemManager.GetItemDefinitions())
            {
                if (def.category == ItemCategory.Tool)
                {
                    permission.RegisterPermission(this.Name.ToLower() + "." + def.shortname, this);
                }
            }
        }

        private bool HasPerm(BasePlayer player)
        {
            if (config.usetoolpermissions)
                return HasToolPermission(player);

            return permission.UserHasPermission(player.UserIDString, permName);
        }

        private bool HasToolPermission(BasePlayer player)
        {
            var activeItem = player.GetActiveItem();
            if (activeItem?.info == null)
                return false;

            return permission.UserHasPermission(player.UserIDString, this.Name.ToLower() + "." + activeItem.info.shortname);
        }

        private void Init()
        {
            permission.RegisterPermission(permName, this);
            RegisterToolPermissions();
        }

        private static Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Permissions for every Tool")]
            public bool usetoolpermissions = false;

            [JsonProperty(PropertyName = "Night Gatherrate")]
            public float nightrate = 1;

            [JsonProperty(PropertyName = "Day Gatherrate")]
            public float dayrate = 1;

            [JsonProperty(PropertyName = "Tools")]
            public Dictionary<string, float> tools;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    tools = new Dictionary<string, float>()
                    {
                        ["bone.club"] = 1,
                        ["knife.bone"] = 1,
                        ["longsword"] = 1,
                        ["mace"] = 1,
                        ["machete"] = 1,
                        ["salvaged.cleaver"] = 1,
                        ["salvaged.sword"] = 1,
                        ["hatchet"] = 1,
                        ["pickaxe"] = 1,
                        ["rock"] = 1,
                        ["axe.salvaged"] = 1,
                        ["hammer.salvaged"] = 1,
                        ["icepick.salvaged"] = 1,
                        ["stonehatchet"] = 1,
                        ["stone.pickaxe"] = 1,
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = Configuration.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion config
    }
}


// --- End of file: ToolsGatherManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/team-deathmatch ---
// --- Original File Path: T/TeamDeathmatch/TeamDeathmatch.cs ---

﻿// Requires: EventManager
using Newtonsoft.Json;
using Oxide.Plugins.EventManagerEx;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("TeamDeathmatch", "k1lly0u", "0.4.2"), Description("Team Deathmatch event mode for EventManager")]
    class TeamDeathmatch : RustPlugin, IEventPlugin
    {
        #region Oxide Hooks
        private void OnServerInitialized()
        {
            EventManager.RegisterEvent(Title, this);

            GetMessage = Message;
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void Unload()
        {
            if (!EventManager.IsUnloading)
                EventManager.UnregisterEvent(Title);
            
            Configuration = null;
        }
        #endregion

        #region Event Checks
        public bool InitializeEvent(EventManager.EventConfig config) => EventManager.InitializeEvent<TeamDeathmatchEvent>(this, config);

        public bool CanUseClassSelector => true;

        public bool RequireTimeLimit => true;

        public bool RequireScoreLimit => false;

        public bool UseScoreLimit => true;

        public bool UseTimeLimit => true;

        public bool IsTeamEvent => true;

        public void FormatScoreEntry(EventManager.ScoreEntry scoreEntry, ulong langUserId, out string score1, out string score2)
        {
            score1 = string.Format(Message("Score.Kills", langUserId), scoreEntry.value1);
            score2 = string.Format(Message("Score.Deaths", langUserId), scoreEntry.value2);
        }

        public List<EventManager.EventParameter> AdditionalParameters { get; } = new List<EventManager.EventParameter>
        {            
            new EventManager.EventParameter
            {
                DataType = "bool",
                Field = "closeOnStart",
                Input = EventManager.EventParameter.InputType.Toggle,
                IsRequired = false,
                Name = "Close Event On Start",
                DefaultValue = false
            }
        };

        public string ParameterIsValid(string fieldName, object value) => null;
        #endregion

        #region Event Classes
        public class TeamDeathmatchEvent : EventManager.BaseEventGame
        {
            public EventManager.Team winningTeam;

            private int teamAScore;
            private int teamBScore;

            internal override void PrestartEvent()
            {
                if (Config.GetParameter<bool>("closeEventOnStart"))
                    CloseEvent();

                base.PrestartEvent();
            }

            protected override void StartEvent()
            {                
                BalanceTeams();
                base.StartEvent();
            }

            protected override EventManager.Team GetPlayerTeam(BasePlayer player)
            {
                if (GetTeamCount(EventManager.Team.A) > GetTeamCount(EventManager.Team.B))
                    return EventManager.Team.B;
                return EventManager.Team.A;
            }

            internal override int GetTeamScore(EventManager.Team team) => team == EventManager.Team.B ? teamBScore : teamAScore;
            
            internal override void OnPlayerTakeDamage(EventManager.BaseEventPlayer eventPlayer, HitInfo hitInfo)
            {
                EventManager.BaseEventPlayer attacker = EventManager.GetUser(hitInfo.InitiatorPlayer);
                if (attacker == null || eventPlayer.Team != attacker.Team)
                {
                    base.OnPlayerTakeDamage(eventPlayer, hitInfo);
                    return;
                }

                if (GodmodeEnabled || eventPlayer.IsDead || eventPlayer.IsInvincible)
                {
                    EventManager.ClearDamage(hitInfo);
                    return;
                }

                if (Configuration.FriendlyFireModifier != 1f)
                    hitInfo.damageTypes.ScaleAll(Configuration.FriendlyFireModifier);

                eventPlayer.OnTakeDamage(attacker.Player.userID);
            }

            internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker = null, HitInfo info = null)
            {
                if (victim == null)
                    return;

                victim.OnPlayerDeath(attacker, Configuration.RespawnTime);

                if (attacker != null && victim != attacker && victim.Team != attacker.Team)
                {
                    int score;
                    if (attacker.Team == EventManager.Team.B)
                        score = teamBScore += 1;
                    else score = teamAScore += 1;

                    attacker.OnKilledPlayer(info);

                    if (Config.ScoreLimit > 0 && score >= Config.ScoreLimit)
                    {
                        winningTeam = attacker.Team;
                        InvokeHandler.Invoke(this, EndEvent, 0.1f);
                        return;
                    }
                }

                UpdateScoreboard();
                base.OnEventPlayerDeath(victim, attacker);
            }

            protected override void GetWinningPlayers(ref List<EventManager.BaseEventPlayer> winners)
            {
                if (winningTeam < EventManager.Team.None)
                {
                    if (eventPlayers.Count > 0)
                    {                        
                        for (int i = 0; i < eventPlayers.Count; i++)
                        {
                            EventManager.BaseEventPlayer eventPlayer = eventPlayers[i];
                            if (eventPlayer == null)
                                continue;

                            if (eventPlayer.Team == winningTeam)
                                winners.Add(eventPlayer);                            
                        }
                    }
                }
            }

            #region Scoreboards
            protected override void BuildScoreboard()
            {
                scoreContainer = EMInterface.CreateScoreboardBase(this);

                int index = -1;
                EMInterface.CreatePanelEntry(scoreContainer, string.Format(GetMessage("Score.Team", 0UL), teamAScore, TeamAColor, TeamBColor, teamBScore), index += 1);

                if (Config.ScoreLimit > 0)
                    EMInterface.CreatePanelEntry(scoreContainer, string.Format(GetMessage("Score.Limit", 0UL), Config.ScoreLimit), index += 1);

                EMInterface.CreateScoreEntry(scoreContainer, string.Empty, "K", "D", index += 1);

                for (int i = 0; i < Mathf.Min(scoreData.Count, 15); i++)
                {
                    EventManager.ScoreEntry score = scoreData[i];
                    EMInterface.CreateScoreEntry(scoreContainer, $"<color={(score.team == EventManager.Team.A ? TeamAColor : TeamBColor)}>{score.displayName}</color>", ((int)score.value1).ToString(), ((int)score.value2).ToString(), i + index + 1);
                }
            }

            protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer) => eventPlayer.Kills;

            protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer) => eventPlayer.Deaths;

            protected override void SortScores(ref List<EventManager.ScoreEntry> list)
            {
                list.Sort(delegate (EventManager.ScoreEntry a, EventManager.ScoreEntry b)
                {
                    int primaryScore = a.value1.CompareTo(b.value1);

                    if (primaryScore == 0)
                        return a.value2.CompareTo(b.value2) * -1;

                    return primaryScore;
                });
            }
            #endregion
        }
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Respawn time (seconds)")]
            public int RespawnTime { get; set; }

            [JsonProperty(PropertyName = "Friendly fire damage modifier (0.0 is no damage, 1.0 is normal damage)")]
            public float FriendlyFireModifier { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                RespawnTime = 5,
                FriendlyFireModifier = 1.0f,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (Configuration.Version < new Core.VersionNumber(0, 4, 1))
                Configuration.FriendlyFireModifier = baseConfig.FriendlyFireModifier;

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Localization
        public string Message(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId != 0U ? playerId.ToString() : null);

        private static Func<string, ulong, string> GetMessage;

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Score.Kills"] = "Kills: {0}",
            ["Score.Deaths"] = "Deaths: {0}",
            ["Score.Name"] = "Kills",
            ["Score.Limit"] = "Score Limit : {0}",
            ["Score.Team"] = "{0} : <color={1}>Team A</color> | <color={2}>Team B</color> : {3}"
        };
        #endregion
    }
}


// --- End of file: TeamDeathmatch.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/terrain-violation-fix ---
// --- Original File Path: T/TerrainViolationFix/TerrainViolationFix.cs ---

﻿namespace Oxide.Plugins
{
    [Info("Terrain Violation Fix", "Tryhard", "1.0.3")]
    [Description("Disables inside terrain violation 200 kicks for admins")]
    public class TerrainViolationFix : RustPlugin
    {
        private void Init() => permission.RegisterPermission("TerrainViolationFix.on", this);

        private object OnPlayerViolation(BasePlayer player, AntiHackType type)
        {
            if (type == AntiHackType.InsideTerrain && permission.UserHasPermission(player.UserIDString, "TerrainViolationFix.on")) return false;
            return null;
        }
    }
}

// --- End of file: TerrainViolationFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/turret-weapons ---
// --- Original File Path: T/TurretWeapons/TurretWeapons.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Turret Weapons", "Iv Misticos", "1.0.1")]
    [Description("Control weapons placement in turrets")]
    class TurretWeapons : CovalencePlugin
    {
        #region Configuration
        
        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Weapons Allowed", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, bool> Weapons = new Dictionary<string, bool>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();
        
        #endregion
        
        #region Hooks

        private void OnServerInitialized()
        {
            foreach (var item in ItemManager.itemList)
            {
                var proj = item.GetComponent<ItemModEntity>()?.entityPrefab?.Get()?.GetComponent<BaseProjectile>();
                if (proj != null)
                {
                    bool isAllowed;
                    if (!_config.Weapons.TryGetValue(item.shortname, out isAllowed))
                    {
                        _config.Weapons[item.shortname] = false;
                        proj.usableByTurret = false;
                        continue;
                    }

                    proj.usableByTurret = isAllowed;
                }
            }
            
            SaveConfig();

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                if (entity is HeldEntity)
                    OnEntitySpawned(entity as HeldEntity);
            }
        }

        private void OnEntitySpawned(HeldEntity entity)
        {
            var proj = entity.GetComponent<BaseProjectile>();
            if (proj == null)
                return;

            proj.usableByTurret = true;
        }
        
        #endregion
    }
}

// --- End of file: TurretWeapons.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tell-me-x ---
// --- Original File Path: T/TellMeX/TellMeX.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using Rust;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Tell Me X", "Krungh Crow", "1.0.1")]
    [Description("Calculate X and get Bonus Ammo, RP Points, Economics")]
    public class TellMeX : RustPlugin

    #region Changelogs and ToDo
    /***********************************************************************************************************************
    *
    *    THANKS to BuzZ[PHOQUE] to creator of this plugin
    *    
    *    v1.0.1 : Added amount of minimum players to be online to start the game
    *    v1.0.1 : Added Battlepass support
    *             Added clear data on unload
    *             Reorganised cfg (delete old cfg before updating)
    *
    ************************************************************************************************************************/
    #endregion

    {
        [PluginReference]
        Plugin Battlepass, ServerRewards, Economics, GUIAnnouncements;

        #region declaration des variables

        float TellMeXRate = 600f;                       // FREQUENCY OF THE GAME IN SECONDS / FREQUENCE DU JEU EN SECONDES
        float TellMeXLength = 25f;                      // DURATION OF THE GAME IN SECONDS / DUREE DU JEU EN SECONDES
        int MinPlayer = 1;
        //const float TellMeXLength = Lengthf;          // FUTURE CUSTOM DURATION OF THE GAME IN SECONDS / DUREE DU JEU EN SECONDES
        float TellMeXEndTime;                           // FOR WHEN IT ENDS. VALUE GIVEN AT START VOID                                                         
        float NextTellMeXTime;                          // FOR TIME UNTIL NEXT GAME                                   
        bool TellMeXIsOn;                               // TRUE WHEN GAME IS ON
        bool OnReloading;                               // if ServerRewards Plugin reloads
        int QuantityToWin;                              // RANDOMISED QUANTITY TO APPLY TO RANDOMISED ITEM TO WIN

        List<ulong> TellMeXPlayerIDs;                   // TO STORE PLAYERIDS THAT TRIED TO FIND X
        private string Math = "";                       // TO
        private string XToFind = "";       
        private string ItemWon = "";
        private string ItemToWin = "";
        private string ToWait;
        private bool ConfigChanged;
        
        #endregion

        #region CUSTOMISABLES    
        // POUR LA CUSTOMISATION DU PLUGIN


        private string Prefix = "[TellMeX] ";           // CHAT PLUGIN PREFIX
        private string PrefixColor = "#47ff6f";         // CHAT PLUGIN PREFIX COLOR
        private string ChatColor = "#a0ffb5";           // CHAT MESSAGE COLOR
        ulong SteamIDIcon = 76561198842176097;          // SteamID FOR PLUGIN ICON - STEAM PROFILE CREATED FOR THIS PLUGIN / 76561198842176097 /
        private string WinnerColor = "#4fffc7";         // WINNER NAME COLOR
        private string MathColor = "#e2ffe9";           // MATH COLOR
        private bool UseServerRewards = true;
        private bool UseEconomics = false;
        private bool UseBattlepass = false;
        bool useBattlepass1 = false;
        bool useBattlepass2 = false;
        bool useBattlepassloss = false;
        int battlepassWinReward1 = 20;
        int battlepassWinReward2 = 20;
        int battlepassLossReward1 = 10;
        int battlepassLossReward2 = 10;
        private bool UseGUI = false;
        //int Rate=25;                                  // FUTURE CUSTOM RATE OF THE GAME
        //int Length=25;                                // FUTURE CUSTOM DURATION OF THE GAME
        int RPOnWin = 5;                                // RP POINTS ADDED ON WIN
        int RPOnLose = 1;                               // RP ADDED ON LOSE   
        int EcoOnWin = 5;                                // RP POINTS ADDED ON WIN
        int EcoOnLose = 1;                               // RP ADDED ON LOSE   

        #endregion

        #region DICTIONNAIRES

        // DICTIONNAIRE ITEMS TO RANDOMIZE
        private Dictionary<int, string> Item = new Dictionary<int, string>() 
        {
            [0] = "ammo.pistol",
            [1] = "ammo.pistol.fire",
            [2] = "ammo.pistol.hv",
            [3] = "ammo.rifle",
            [4] = "ammo.rifle.explosive",
            [5] = "ammo.rifle.hv",
            [6] = "ammo.rifle.incendiary",
            [7] = "ammo.shotgun",
            [8] = "ammo.shotgun.slug",
            [9] = "ammo.handmade.shell",            
        };

        // DICTIONNAIRE QUANTITY TO RANDOMIZE
        private Dictionary<int, int> Quantity = new Dictionary<int, int>()
        {
            [0] = 5,
            [1] = 10,
            [2] = 15,
            [3] = 20,           
            [4] = 25,           
            [5] = 30,           
        };

        // DICTIONNAIRE DES DIFFERENTS CALCULS
        private Dictionary<int, string> Calculs = new Dictionary<int, string>()
        {
            [0] = "({X} x {Y}) + {Z}",
            [1] = "{X} x ({Y} - {Z})",
            [2] = "{X} x ({Y} + {Z})",
            [3] = "{X} + ({Y} x {Z})",
            [4] = "{X} - ({Y} x {Z})",
            [5] = "({X} x {Y}) - {Z}",
            [6] = "{X} x {Y} x {Z}",            
        };

        #endregion

        #region MESSAGES / LANG
        // MESSAGES TO CALL - ENGLISH VERSION

        void LoadDefaultMessages()
        {

            lang.RegisterMessages(new Dictionary<string, string>
            {

                {"StartTellMeXMsg", "X ="},
                {"CommandTellMeXMsg", "CALCULATE X AND TELL IT TO ME ! (example: <color=yellow>/x 1234</color>)"},
                {"NextTellMeXMsg", "Next 'Tell Me X' will start in "},
                {"AlreadyTellMeXMsg", "You've already played !\nTry again in "},
                {"InvalidTellMeXMsg", "Invalid guess.\nTry something like <color=yellow>/x 1234</color>"},
                {"NotNumericTellMeXMsg", "It is not a number !\nTry something like <color=yellow>/x 1234</color>"},
                {"WonTellMeXMsg", "did find X\nand has won :"},
                {"EndTellMeXMsg", "X was "},
                {"ExpiredTellMeXMsg", "was not found in time !"},
                {"LoseTellMeXMsg", "X is not equal to this..."},
                {"LoseTellMeXRPMsg", "X is not equal to this... BUT for playing you won "},
                {"SorryErrorMsg", "Sorry an error has occured ! Please Tell Krungh Crow about this Thank you !. Item to give was null. gift was : "},

            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {

                {"StartTellMeXMsg", "X ="},
                {"CommandTellMeXMsg", "CALCULEZ LA VALEUR DE X ET DONNEZ LA MOI ! (exemple: <color=yellow>/x 1234</color>)"},
                {"NextTellMeXMsg", "Le prochain calcul se fera dans "},
                {"AlreadyTellMeXMsg", "Vous avez déjà essayé !\nEssayez de nouveau dans "},
                {"InvalidTellMeXMsg", "Valeur invalide.\nEssayez dans ce format<color=yellow>/x 1234</color>"},
                {"NotNumericTellMeXMsg", "Ce n'est pas un nombre !\nUtilisez ce format <color=yellow>/x 1234</color>"},
                {"WonTellMeXMsg", "a trouvé(e) X\net a remporté(e) :"},
                {"EndTellMeXMsg", "X était "},
                {"ExpiredTellMeXMsg", "n'a pas été trouvé à temps !"},
                {"LoseTellMeXMsg", "X n'est pas égal à ce nombre..."},
                {"LoseTellMeXRPMsg", "X n'est pas égal à ce nombre... MAIS pour la participation, vous avez gagné "},
                {"SorryErrorMsg", "Désolé, une erreur a eue lieu. Touchez en un mot à Krungh Crow, Merci ! L'objet à donner été 'nul'. Le cadeau était : "},


            }, this, "fr");
        }


        #endregion

        #region SERVER REWARDS PLUGIN VERIFICATION DU .CS ET WARNING
        void Loaded()
        {
            if (UseServerRewards == true)
            {
                if (ServerRewards == false)
                {
                    PrintError("ServerRewards.cs is not present. Change your config option to disable RP rewards and reload TellMeX. Thank you.");
                }
            }

            if (UseEconomics == true)
            {
                if (Economics == false)
                {
                    PrintError("Economics.cs is not present. Change your config option to disable $ rewards and reload TellMeX. Thank you.");
                }
            }

            if (UseBattlepass == true || useBattlepass1 == true || useBattlepass2 == true)
            {
                if (Battlepass == false) PrintError("Battlepass is not installed. Change your config option to disable Battlepass settings and reload TellMeC. Thank you.");
            }
        }

        #endregion

        #region Unload
        void Unload()
        {
            if (TellMeXPlayerIDs != null)
            {
                TellMeXIsOn = false;
                TellMeXPlayerIDs.Clear();
            }
        }
        #endregion


        #region CONFIG

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }


        private void LoadVariables()
        {

            Prefix = Convert.ToString(GetConfig("Message Settings", "Prefix", "[TellMeX] "));                      // CHAT PLUGIN PREFIX
            PrefixColor = Convert.ToString(GetConfig("Message Settings", "PrefixColor", "#47ff6f"));               // CHAT PLUGIN PREFIX COLOR
            ChatColor = Convert.ToString(GetConfig("Message Settings", "ChatColor", "#a0ffb5"));                   // CHAT MESSAGE COLOR
            SteamIDIcon = Convert.ToUInt64(GetConfig("Message Settings", "SteamIDIcon", 76561198842176097));            // SteamID FOR PLUGIN ICON - STEAM PROFILE CREATED FOR THIS PLUGIN / 76561198842176097 /
            WinnerColor = Convert.ToString(GetConfig("Message Settings", "Color For Winner Name", "#4fffc7"));     // WINNER NAME COLOR
            MathColor = Convert.ToString(GetConfig("Message Settings", "Color Of Math Expression", "#e2ffe9"));
            UseGUI = Convert.ToBoolean(GetConfig("Message Settings", "Use GuiAnnouncement on win", "false"));
            UseServerRewards = Convert.ToBoolean(GetConfig("Rewards Settings", "Use Server Rewards", true));
            RPOnWin = Convert.ToInt32(GetConfig("Rewards Settings", "RP Points on Win", 5));
            RPOnLose = Convert.ToInt32(GetConfig("Rewards Settings", "RP Points on Lose", 1));
            UseEconomics = Convert.ToBoolean(GetConfig("Rewards Settings", "Use Economics", false));
            EcoOnWin = Convert.ToInt32(GetConfig("Rewards Settings", "Economics on Win", 5));
            EcoOnLose = Convert.ToInt32(GetConfig("Rewards Settings", "Economics on Lose", 1));
            TellMeXRate = Convert.ToSingle(GetConfig("Game repeater", "Rate in seconds", "600"));
            TellMeXLength = Convert.ToSingle(GetConfig("Game length", "in seconds", "25"));
            MinPlayer = Convert.ToInt32(GetConfig("Online Settings", "Minimum amount of players to be online to start the game", "1"));
            //Battlepass
            UseBattlepass = Convert.ToBoolean(GetConfig("Reward Battlepass Settings", "Use Battlepass", false));
            useBattlepass1 = Convert.ToBoolean(GetConfig("Reward Battlepass Settings", "Use Battlepass 1st currency", false));
            useBattlepass2 = Convert.ToBoolean(GetConfig("Reward Battlepass Settings", "Use Battlepass 2nd currency", false));
            useBattlepassloss = Convert.ToBoolean(GetConfig("Reward Battlepass Settings", "Use Battlepass on loss", false));
            battlepassWinReward1 = Convert.ToInt32(GetConfig("Reward Battlepass Settings", "Amount 1st currency (win)", 20));
            battlepassWinReward2 = Convert.ToInt32(GetConfig("Reward Battlepass Settings", "Amount 2nd currency (win)", 20));
            battlepassLossReward1 = Convert.ToInt32(GetConfig("Reward Battlepass Settings", "Amount 1st currency (loss)", 10));
            battlepassLossReward2 = Convert.ToInt32(GetConfig("Reward Battlepass Settings", "Amount 2nd currency (loss)", 10));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

        #endregion

        #region INITIALISATION
        // INITIALISATION
		private void OnServerInitialized()
        {
        LoadVariables();
        NextTellMeXTime = Time.time + TellMeXRate;
        TellMeXPlayerIDs = new List<ulong>();
        }
        #endregion

        #region ON TICK
        // ON TICKET 
        void OnTick()
        {            
            // si TMX est off + next <timer
            if(!TellMeXIsOn && NextTellMeXTime < Time.time)
            {
                if (BasePlayer.activePlayerList.Count >= MinPlayer)
                {
                    StartTellMeX();
                }
                else
                {
                    return;
                }
                //StartTellMeX();                                                
            }
            
            if(TellMeXIsOn && TellMeXEndTime < Time.time)
            {
                TellMeXExpired();
            }
        }
        #endregion

        #region ON EXPIRATION
        // EXPIRATION 
        void TellMeXExpired()
        {
            // ExpiredTellMeXMsg = "was not found in time !";
            Server.Broadcast($"<color={ChatColor}> X ({XToFind}) {lang.GetMessage("ExpiredTellMeXMsg", this)} </color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon); 
            TellMeXIsOn = false;
            NextTellMeXTime = Time.time + TellMeXRate;
            TellMeXPlayerIDs.Clear();
        }
        #endregion

        #region START DU CALCUL
        // START DU CALCUL
        private void StartTellMeX()
        {
            
            TellMeXIsOn = true;

            TellMeXEndTime = Time.time + TellMeXLength;

            int RandomCalcul = Core.Random.Range(0, 7);                         // NOMBRE CHOIX CALCUL
            int RandomItem = Core.Random.Range(0, 10);                          // NOMBRE CHOIX ITEM
            int RandomQuantity = Core.Random.Range(0, 6);                       // NOMBRE CHOIX QUANTITE
            Math = Calculs[RandomCalcul];                                       // RESULTAT CHOIX CACUL
            ItemToWin = Item[RandomItem];                                       // RESULTAT CHOIX ITEM
            QuantityToWin = Quantity[RandomQuantity];                           // RESULTAT CHOIX QUANTITE
            int X = Core.Random.Range(2, 20);                                   // X AU HASARD
            int Y = Core.Random.Range(2, 20);                                   // Y AU HASARD
            int Z = Core.Random.Range(2, 20);                                   // Z AU HASARD
            Math = Math.Replace("{X}", X.ToString()).Replace("{Y}", Y.ToString()).Replace("{Z}", Z.ToString()); // REMPLACE LES VALEURS DANS LE CALCUL
            XToFind = DoMath(X, Y, Z, RandomCalcul);                            // EXECUTE DOMATH AVEC LES VALEURS XYZ ET LE RANDOM POUR AVOIR X
            if (XToFind == "")                                                  // SI LE X FINAL EST VIDE -> MESSAGE D ERREUR AVEC INFOS
            {
                PrintWarning($"Contact BuzZ[PHOQUE] with this :\nMath Error !\ncalcul n°{RandomCalcul} with X = {X}; Y = {Y}; Z = {Z}");
                if (BasePlayer.activePlayerList.Count >= MinPlayer)
                {
                    StartTellMeX();
                }
                else
                {
                    return;
                }
                //StartTellMeX();
            }
            BroadcastMath(true);                                                // DURANT LE START ON ENVOI LE MESSAGE BROADCAST DU CALCUL A FAIRE
            Puts($"TellMeX started, X = {Math} = {XToFind}");                   // ENVOI A LA CONSOLE LE CALCUL ET SON RESULTAT X

        }
        private string DoMath(int X, int Y, int Z, int RandomCalcul)            // EXECUTE LE CALCUL SUIVANT LE CAS DU RANDOM ET RETOURNE LE RESULTAT
        {
            switch (RandomCalcul)
            {
                case 0:
                    return $"{(X * Y) + Z}";
                case 1:
                    return $"{X * (Y - Z)}";
                case 2:
                    return $"{X * (Y + Z)}";
                case 3:
                    return $"{X + (Y * Z)}";
                case 4 :
                    return $"{X - (Y * Z)}";
                case 5 :
                    return $"{(X * Y) - Z}";
                case 6 :
                    return $"{X * Y * Z}";
                default:
                    return "";
            }
        }

        #endregion

        #region CHAT COMMAND /x /X


        [ChatCommand("x")]                                                              // SUR COMMANDE CHAT /x ou /X
        private void TellMeXCommand(BasePlayer player, string command, string[] args)
        {
            if (TellMeXIsOn == false)                                                           // SI GAME !ON, DISPLAY NEXT
            {
                float ToNext = Time.time - NextTellMeXTime;                             // CALCUL INTERVALLE EN SECONDES
                ToWait = ToNext.ToString("######;######");                              // ARRONDI ET SUPPRESSION DU NEGATIF
                // NextTellMeXMsg = "Next 'Tell Me X' will start in ";
                Player.Message(player, $"<color={ChatColor}> {lang.GetMessage("NextTellMeXMsg", this, player.UserIDString)} {ToWait} seconds</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }
            if (TellMeXPlayerIDs.Contains(player.userID))                                // CHECK IF ALREADY PLAYED
            {
                float ToNext = TellMeXRate - (Time.time - NextTellMeXTime) + TellMeXRate; //v0.2
                ToWait = ToNext.ToString("######");
                // AlreadyTellMeXMsg = "You've already played !\nTry again in ";
                Player.Message(player, $"<color={ChatColor}> {lang.GetMessage("AlreadyTellMeXMsg", this, player.UserIDString)} {ToWait} seconds</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }
    
            if(args.Length != 1)                                                        // si les arguments sont vides        
            {
                // InvalidTellMeXMsg = "Invalid guess.\nTry something like <color=yellow>/x 1234</color>";
                Player.Message(player, $"<color={ChatColor}> {lang.GetMessage("InvalidTellMeXMsg", this, player.UserIDString)} </color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);                
                return;
            }
    
            int PlayerNumber;                                                           // déclaration de l integer PlayerNumber
            
            bool isNumeric = int.TryParse(args[0], out PlayerNumber);                   // si c est numerique, on arrondi les args de la commande pour en sortir le PLayerNumber
            
            if(!isNumeric)                                                              // if chat is not numeric      
            {
                // NotNumericTellMeXMsg par defaut : ""
                Player.Message(player, $"<color={ChatColor}> {lang.GetMessage("NotNumericTellMeXMsg", this, player.UserIDString)} </color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }

            if (args.Contains(XToFind))                                                 // WINNER SI X EST DANS LES ARGS DE LA COMMANDE PLAYER
            {
                TellMeXIsOn = false;                                                    // GAME IS !ON
                NextTellMeXTime = Time.time + TellMeXRate;                              // NEXT TIME = TIMER + RATE
                TellMeXPlayerIDs.Clear();                                               // VIDE LA LISTE DES JOUEURS
                GivePlayerGift(player, ItemToWin);                                      // EXECUTE GIVEPLAYER AVEC player ET ItemToWin



                string message = $"<color={ChatColor}> <color={WinnerColor}>{player.displayName}</color> {lang.GetMessage("WonTellMeXMsg", this, player.UserIDString)} [{ItemWon}]</color>";

                if (UseServerRewards == true)
                {
                    if (ServerRewards == true)
                    {
                        message = $"{message} + <color=#ffe556>[{RPOnWin}.RP]</color>";
                        ServerRewards?.Call("AddPoints", player.userID, (int)RPOnWin);          // HOOK VERS PLUGIN ServerRewards POUR ADD RPWin
                        if (UseGUI == true)
                        {
                            GUIAnnouncements?.Call("CreateAnnouncement", ($"{player.displayName} {lang.GetMessage("WonTellMeXMsg", this, player.UserIDString)} [{ItemWon}] + [{RPOnWin}.RP]"), "blue", "yellow");
                        }
                    }
                }            

                else if (UseEconomics == true)
                {
                    if (Economics == true)
                    {
                        double amount = Convert.ToDouble(EcoOnWin);
                        message = $"{message} + <color=#ffe556>[{EcoOnWin}.$]</color>";
                        Economics.Call("Deposit", player.userID, amount);          // HOOK VERS PLUGIN Economics POUR ADD EcoWin
                        if (UseGUI == true)
                        {
                            GUIAnnouncements?.Call("CreateAnnouncement", ($"{player.displayName} {lang.GetMessage("WonTellMeXMsg", this, player.UserIDString)} [{ItemWon}] + [{EcoOnWin}.$]"), "blue", "yellow");
                        }
                    }

                }
                else if (UseBattlepass == true)
                {
                    if (useBattlepass1)
                    {
                        Battlepass?.Call("AddFirstCurrency", player.userID, battlepassWinReward1);
                        {
                            message = $"{message} + <color=#ffe556>[{battlepassWinReward1}.BP1]</color>";
                            if (UseGUI == true)
                            {
                                GUIAnnouncements?.Call("CreateAnnouncement", ($"{player.displayName} {lang.GetMessage("WonTellMeXMsg", this, player.UserIDString)} [{ItemWon}] + [{battlepassWinReward1}.BP1]"), "blue", "yellow");
                            }
                        }
                    }

                    else if (useBattlepass2)
                    {
                        Battlepass?.Call("AddSecondCurrency", player.userID, battlepassWinReward2);
                        {
                            message = $"{message} + <color=#ffe556>[{battlepassWinReward2}.BP2]</color>";
                            if (UseGUI == true)
                            {
                                GUIAnnouncements?.Call("CreateAnnouncement", ($"{player.displayName} {lang.GetMessage("WonTellMeXMsg", this, player.UserIDString)} [{ItemWon}] + [{battlepassWinReward2}.BP2]"), "blue", "yellow");
                            }
                        }
                    }
                }

                Server.Broadcast($"{message}",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon); 

                BroadcastMath(false);                                                   // PASSE LE VOID BROADCAST A FALSE
            }
            else                                                                        // WE COULD SAY LOSER
            {            

                string message = $"<color={ChatColor}> {lang.GetMessage("LoseTellMeXMsg", this, player.UserIDString)} </color>";

                if (UseServerRewards == true)
                {
                    if (ServerRewards == true)
                    {
                    message = $"{message} + <color=#ffe556>[{RPOnLose}.RP]</color>";
                    ServerRewards?.Call("AddPoints", player.userID, (int)RPOnLose);          // HOOK VERS PLUGIN ServerRewards POUR ADD RPWin
                    }

                }            

                if (UseEconomics == true)
                {
                    if (Economics == true)
                    {
                    double amount = Convert.ToDouble(EcoOnLose);
                    message = $"{message} + <color=#ffe556>[{EcoOnLose}.$]</color>";
                    Economics.Call("Deposit", player.userID, amount);          // HOOK VERS PLUGIN Economics POUR ADD EcoWin
                    }

                }
                else if (UseBattlepass == true)
                {
                    if (useBattlepass1)
                    {
                        Battlepass?.Call("AddFirstCurrency", player.userID, battlepassLossReward1);
                        {
                            message = $"{message} + <color=#ffe556>[{battlepassLossReward1}.$]</color>";
                        }
                    }

                    if (useBattlepass2)
                    {
                        Battlepass?.Call("AddSecondCurrency", player.userID, battlepassLossReward2);
                        {
                            message = $"{message} + <color=#ffe556>[{battlepassLossReward2}.$]</color>";
                        }
                    }
                }
                Player.Message(player, $"{message}",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                TellMeXPlayerIDs.Add(player.userID);                                   // ADD PLAYER TO THOSE WHO TRIED TO FIND X

            }
        }

        #endregion

        #region BROADCAST MATH CALCUL

        private void BroadcastMath(bool start)
        {
            if (start)                                                                  // SI START On -> BROADCAST StartMsg                                                       
            {
            Server.Broadcast($"<color={ChatColor}> {lang.GetMessage("StartTellMeXMsg", this)} <color={MathColor}>{Math}</color>\n{lang.GetMessage("CommandTellMeXMsg", this)} </color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
//            Server.Broadcast($"<color={ChatColor}> {lang.GetMessage("StartTellMeXMsg", this)} <color={MathColor}>{Math}</color>\n{lang.GetMessage("CommandTellMeXMsg", this)} </color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);

            }
            else                                                                        // SINON -> BROADCAST EndMsg                                                                    
            {
            Server.Broadcast($"<color={ChatColor}> {lang.GetMessage("EndTellMeXMsg", this)} {XToFind}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
            }
        }
        #endregion

        #region GIVE TO PLAYER

        private void GivePlayerGift(BasePlayer player, string gift)
        {
            Item item = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(gift).itemid,QuantityToWin);
            if (item == null)
            {
            Player.Message(player, $"<color={ChatColor}> {lang.GetMessage("SorryErrorMsg", this)} {ItemToWin}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);               
            return;
            }
            player.GiveItem(item);
            ItemWon = $"{QuantityToWin} x {gift}";
        }

        #endregion

    }
}


// --- End of file: TellMeX.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/timed-progression ---
// --- Original File Path: T/TimedProgression/TimedProgression.cs ---

﻿using Rust;
using Facepunch.Extend;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using System;
using System.Globalization;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
using System.Linq;
using System.ComponentModel;
using ProtoBuf;
using Random = System.Random;
using Oxide.Core.Libraries.Covalence;
using System.Text;


namespace Oxide.Plugins
{
    [Info("Timed Progression", "mothball187", "0.1.2")]
    [Description("Restricts crafting and looting of items based on configurable tiers, unlocked over configurable time periods")]
    class TimedProgression : CovalencePlugin
    {
        [PluginReference] private Plugin DiscordCore, GUIAnnouncements;

        #region Fields

        private DynamicConfigFile timeData;
        private DynamicConfigFile items;
        Random rnd = new Random();
        private PluginConfig config;
        private DateTime wipeStart;

        #endregion Fields

        #region Commands

        [Command("checkphase")]
        private void CheckPhase(IPlayer player, string command, string[] args)
        {
            NotifyPhaseInfo(player);
        }

        [Command("listitems")]
        private void ListItemsCmd(IPlayer player, string command, string[] args)
        {
            ListItems(player: player);
        }

        [Command("timedprogression.setthreshold")]
        private void SetThreshold(IPlayer player, string command, string[] args)
        {
            if(!player.HasPermission("timedprogression.configure"))
            {
                player.Reply(lang.GetMessage("NeedPermission", this, player.Id));
                return;
            }

            if(args.Length < 2)
            {
                player.Reply(lang.GetMessage("SetThresholdError", this, player.Id));
                return;
            }

            Int32 phase;
            if(!Int32.TryParse(args[0], out phase))
            {
                player.Reply(lang.GetMessage("SetThresholdError", this, player.Id));
                return;
            }

            Int32 minutes;
            if(!Int32.TryParse(args[1], out minutes))
            {
                player.Reply(lang.GetMessage("SetThresholdError", this, player.Id));
                return;
            }

            config.thresholds[phase - 1] = minutes;
            SaveConfig();
            player.Reply(string.Format(lang.GetMessage("SetThreshold", this, player.Id), phase, minutes));
        }

        [Command("timedprogression.setphase")]
        private void SetPhase(IPlayer player, string command, string[] args)
        {
            if(!player.HasPermission("timedprogression.configure"))
            {
                player.Reply(lang.GetMessage("NeedPermission", this, player.Id));
                return;
            }

            if(args.Length < 1)
            {
                player.Reply(lang.GetMessage("SetPhaseError", this, player.Id));
                return;
            }

            Int32 phase;
            if(!Int32.TryParse(args[0], out phase))
            {
                player.Reply(lang.GetMessage("SetPhaseError", this, player.Id));
                return;
            }

            timeData["currentPhase"] = phase;
            timeData.Save();

            RefreshVendingMachines();
            player.Reply(string.Format(lang.GetMessage("SetPhase", this, player.Id), phase));
            NotifyPhaseChange();
        }


        [Command("timedprogression.setwipetime")]
        private void SetWipeTime(IPlayer player, string command, string[] args)
        {
            if(!player.HasPermission("timedprogression.configure"))
            {
                player.Reply(lang.GetMessage("NeedPermission", this, player.Id));
                return;
            }

            if(args.Length < 1)
            {
                player.Reply(lang.GetMessage("SetWipeTimeError", this, player.Id));
                return;
            }

            DateTime dt;
            if(!DateTime.TryParse(args[0], out dt))
            {
                player.Reply(string.Format(lang.GetMessage("SetWipeTimeError", this, player.Id), args[0]));
                return;
            }

            player.Reply(string.Format(lang.GetMessage("SetWipeTime", this, player.Id), dt));
            timeData["wipeTime"] = args[0];
            timeData.Save();
        }



        #endregion Commands

        #region Configuration

        class PluginConfig
        {
            public List<long> thresholds;
            public string botChannel;
        }

        protected void LoadDefaultItemsConfig()
        {
            items["Weapon", "pistol.revolver"] = 1;
            items["Weapon", "shotgun.double"] = 1;
            items["Weapon", "pistol.m92"] = 3;
            items["Weapon", "pistol.python"] = 2;
            items["Weapon", "pistol.semiauto"] = 2;
            items["Weapon", "rifle.ak"] = 3;
            items["Weapon", "rifle.bolt"] = 3;
            items["Weapon", "rifle.l96"] = 3;
            items["Weapon", "rifle.lr300"] = 3;
            items["Weapon", "rifle.m39"] = 3;
            items["Weapon", "rifle.semiauto"] = 2;
            items["Weapon", "shotgun.pump"] = 2;
            items["Weapon", "shotgun.spas12"] = 3;
            items["Weapon", "smg.2"] = 2;
            items["Weapon", "smg.mp5"] = 3;
            items["Weapon", "smg.thompson"] = 2;
            items["Weapon", "lmg.m249"] = 3;
            items["Weapon", "rocket.launcher"] = 2;
            items["Weapon", "multiplegrenadelauncher"] = 2;
            items["Weapon", "grenade.beancan"] = 1;

            items["Attire", "wood.armor.jacket"] = 1;
            items["Attire", "wood.armor.pants"] = 1;
            items["Attire", "wood.armor.helmet"] = 1;
            items["Attire", "roadsign.gloves"] = 2;
            items["Attire", "roadsign.jacket"] = 2;
            items["Attire", "coffeecan.helmet"] = 2;
            items["Attire", "roadsign.kilt"] = 2;
            items["Attire", "metal.facemask"] = 3;
            items["Attire", "metal.plate.torso"] = 3;

            items["Items", "workbench2"] = 2;
            items["Items", "workbench3"] = 3;

            items["Tool", "explosive.satchel"] = 1;
            items["Tool", "explosive.timed"] = 3;

            items["HeavyAmmo", "ammo.rocket.hv"] = 1;
            items["HeavyAmmo", "ammo.rocket.basic"] = 3;
            items["HeavyAmmo", "ammo.grenadelauncher.he"] = 3;

            items.Save();
        }

        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig();
            config.thresholds = new List<long>();
            config.thresholds.Add(60 * 24 * 2); // 2 days
            config.thresholds.Add(60 * 24 * 4); // 4 days
            config.botChannel = "bots";
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Oxide Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SetThresholdError"] = "Error handling setthreshold command",
                ["SetThreshold"] = "Threshold {0} set to {1}",
                ["SetPhaseError"] = "Error handling setphase command",
                ["SetPhase"] = "Phase set to {0}",
                ["SetWipeTimeError"] = "Failed to parse supplied date string {0}",
                ["SetWipeTime"] = "Wipe time set to {0}",
                ["NotifyPlayer"] = "{0} is currently locked!",
                ["PhaseInfo1"] = "Current phase: {0}",
                ["PhaseInfo2"] = "Time left in this phase: {0}",
                ["ListItems"] = "{0} unlocks in phase {1}, in {2}",
                ["AllUnlocked"] = "All items unlocked!",
                ["NotifyPhaseChange"] = "ATTENTION: PHASE {0} HAS BEGUN",
                ["NeedPermission"] = "You must have the 'timedprogression.configure' permission to use this command.",
                ["ConfigError"] = "Failed to load config file (is the config file corrupt?) ({0})"
            }, this);
        }

        private void OnNewSave(string filename)
        {
            timeData["wipeTime"] = DateTime.Now.ToString();
            timeData["currentPhase"] = 1;
            timeData.Save();
            timer.Once(150f, RefreshVendingMachines);  
        }
		
        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            UpdateContainer(entity);
        }

        private void NotifyPlayer(ItemDefinition itemdef, BasePlayer player)
        {
            string msg = string.Format(lang.GetMessage("NotifyPlayer", this, player.UserIDString), itemdef.displayName.english);
            player.ChatMessage(msg);
            GUIAnnouncements?.Call("CreateAnnouncement", msg, "Purple", "Yellow", player);
        }

        /*
        private object CanWearItem(PlayerInventory inventory, Item item, int targetSlot)
        {
            BasePlayer player = inventory.GetComponent<BasePlayer>();
            if(player.IsNpc)
                return null;

            if(!CanHaveItem(item.info))
            {
                DestroyItem(item);
                NotifyPlayer(item.info, player);
                return false;
            }
            return null;
        }

        private object CanEquipItem(PlayerInventory inventory, Item item, int targetPos)
        {
            BasePlayer player = inventory.GetComponent<BasePlayer>();
            if(player.IsNpc)
                return null;

            if(!CanHaveItem(item.info))
            {
                DestroyItem(item);
                NotifyPlayer(item.info, player);
                return false;
            }
            return null;
        }
        */

        private ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer container, Item item, int targetPos)
        {
            BasePlayer player = container.GetOwnerPlayer();
            if(player == null || player.IsNpc || player.IsAdmin)
                return null;

            if(CanHaveItem(item.info))
                return null;

            ReplaceItem(item.info, item.amount).MoveToContainer(container, -1, false);
            item.Remove(0f);
            return ItemContainer.CanAcceptResult.CannotAccept;
        }

        private object CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount)
        {
            if(CanHaveItem(bp.targetItem))
                return  null;

            NotifyPlayer(bp.targetItem, itemCrafter.GetComponent<BasePlayer>());
            return false;
        }

        private void NotifyPhaseInfo(IPlayer player)
        {
            int cp = (int)timeData["currentPhase"];
            player.Message(string.Format(lang.GetMessage("PhaseInfo1", this, player.Id), cp));
            if(cp - 1 >= config.thresholds.Count)
                return;

            DateTime wt = DateTime.Parse((string)timeData["wipeTime"]);
            TimeSpan elapsed = DateTime.Now - wt;
            string timeLeft = FormatTimeSpan(config.thresholds[cp - 1] - (long)elapsed.TotalMinutes);
            player.Message(string.Format(lang.GetMessage("PhaseInfo2", this, player.Id), timeLeft));
        }

        private object OnVendingTransaction(VendingMachine machine, BasePlayer buyer, int sellOrderId, int numberOfTransactions)
        {
            ProtoBuf.VendingMachine.SellOrder sellOrder = machine.sellOrders.sellOrders[sellOrderId];
            /*
            List<global::Item> list = machine.inventory.FindItemsByItemID(sellOrder.itemToSellID);
            if (list == null && list.Count == 0)
                return null;

            if(CanHaveItem(list[0].info))
                return null;

            if(buyer != null)
                NotifyPlayer(list[0].info, buyer);

            */

            ItemDefinition itemDef = ItemManager.FindItemDefinition(sellOrder.itemToSellID);
            if(itemDef == null)
                return null;

            if(CanHaveItem(itemDef))
                return null;

            if(buyer != null)
                NotifyPlayer(itemDef, buyer);

            return false;

        }

        private void OnPlayerConnected(BasePlayer player)
        {
            NotifyPhaseInfo(player.IPlayer);
        }

        private void OnServerInitialized()
        {
            if(DiscordCore != null)
                OnDiscordCoreReady();
        }

        #endregion Oxide Hooks

        private void BuildPhaseItemsStrings(Dictionary<string, object> catItems, ref Dictionary<int, StringBuilder> phaseItems)
        {
            foreach(string name in catItems.Keys)
            {
                int phase = (int)catItems[name];
                if(phase < 2)
                    continue;

                ItemDefinition itemdef = ItemManager.FindItemDefinition(name);
                if(itemdef == null)
                    continue;

                StringBuilder sb;
                if(phaseItems.TryGetValue(phase, out sb))
                {
                    sb.Append(", ");
                    sb.Append(itemdef.displayName.english);
                }
                else
                    phaseItems[phase] = new StringBuilder(itemdef.displayName.english);
            }

        }

        private void ListItems(IPlayer player=null, string channelId=null)
        {
            DateTime wt = DateTime.Parse((string)timeData["wipeTime"]);
            int cp = (int)timeData["currentPhase"];
            Dictionary<int, StringBuilder> phaseItems = new Dictionary<int, StringBuilder>();
            foreach (ItemCategory category in (ItemCategory[]) Enum.GetValues(typeof(ItemCategory)))
            {
                if(items[category.ToString("f")] == null)
                    continue;

                BuildPhaseItemsStrings(items[category.ToString("f")] as Dictionary<string, object>, ref phaseItems);
            }

            if(items["HeavyAmmo"] != null)
                BuildPhaseItemsStrings(items["HeavyAmmo"] as Dictionary<string, object>, ref phaseItems);

            bool messageSent = false;
            foreach(int phase in phaseItems.Keys)
            {
                if(cp < phase)
                {
                    TimeSpan elapsed = DateTime.Now - wt;
                    string timeLeft = FormatTimeSpan(config.thresholds[phase - 2] - (long)elapsed.TotalMinutes);
                    if(player != null)
                        player.Message(string.Format(lang.GetMessage("ListItems", this, player.Id), phaseItems[phase].ToString(), phase, timeLeft));
                    else if(DiscordCore != null && channelId != null)
                        SendMessage(channelId, string.Format(lang.GetMessage("ListItems", this), phaseItems[phase].ToString(), phase, timeLeft));
                    messageSent = true;
                }
            }

            if(!messageSent)
            {
                if(player != null)
                    player.Message(lang.GetMessage("AllUnlocked", this, player.Id));
                else if(DiscordCore != null && channelId != null)
                    SendMessage(channelId, lang.GetMessage("AllUnlocked", this));
            }
        }

        private void SendMessage(string channelId, string message)
        {
            DiscordCore.Call("SendMessageToChannel", channelId, $"{message}");
        }

        private object HandleListItems(IPlayer player, string channelId, string cmd, string[] args)
        {
            ListItems(channelId: channelId);
            return null;
        }

        private void OnDiscordCoreReady()
        {
            if (!(DiscordCore?.Call<bool>("IsReady") ?? false))
                return;

            DiscordCore.Call("RegisterCommand", "listitems", this, new Func<IPlayer, string, string, string[], object>(HandleListItems), "Show next items to unlock", null, true);
        }

        private string FormatTimeSpan(long minutes)
        {
            TimeSpan t = TimeSpan.FromMinutes( minutes );
            string answer = string.Format("{0:D2}d:{1:D2}h:{2:D2}m",
                t.Days, 
                t.Hours, 
                t.Minutes);
            return answer;
        }

        private bool ItemIsHeavyAmmo(ItemDefinition itemdef)
        {
            return (itemdef.category == ItemCategory.Ammunition && (itemdef.shortname.Contains("rocket") || itemdef.shortname.Contains("grenade")));
        }

        private string GetCategoryString(ItemDefinition itemdef)
        {
            string itemCategory;
            if(ItemIsHeavyAmmo(itemdef))
                itemCategory = "HeavyAmmo";
            else
                itemCategory = itemdef.category.ToString("f");

            return itemCategory;
        }

        private bool CanHaveItem(ItemDefinition itemdef)
        {
            string itemCategory = GetCategoryString(itemdef);

            //Puts($"{itemdef.shortname} is of the {itemCategory} category");
            if(items[itemCategory, itemdef.shortname] != null)
            {
                if((int)timeData["currentPhase"] < (int)items[itemCategory, itemdef.shortname])
                    return false;
            }
            return true;
        }

        private void DestroyItem(Item item)
        {
            //item.RemoveFromContainer();
            item.Remove(0f);
            //inventory.GetContainer(PlayerInventory.Type.Main).MarkDirty();
            //(inventory as BaseEntity).SendNetworkUpdate();
            ItemManager.DoRemoves();
        }

        private Item ReplaceItem(ItemDefinition itemdef, int amount)
        {
            List<string> itemPool = new List<string>();
            string cat = GetCategoryString(itemdef);
            
            Dictionary<string, object> catItems = items[cat] as Dictionary<string, object>;
            int currentPhase = (int)timeData["currentPhase"];
            while(currentPhase >= 1 && itemPool.Count == 0)
            {
                foreach(string name in catItems.Keys)
                {                    
                    if((int)items[cat, name] == currentPhase)
                        itemPool.Add(name);
                }

                currentPhase--;
            }

            if(itemPool.Count == 0)
            {
                //Puts($"Couldn't find replacement for {itemdef.shortname}");
                return null;
            }

            //Puts($"Replacing {itemdef.shortname}");
            return ItemManager.CreateByName(itemPool[rnd.Next(itemPool.Count)], amount);
        }
		
		void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
		{
			if(entity is LootContainer)
				UpdateContainer(entity as BaseEntity);
		}

        private void UpdateContainer(BaseEntity container)
        {
            ItemContainer inventory = null;

            if (container is LootContainer)
            {
                //Puts($"Checking a LootContainer");
                inventory = (container as LootContainer).inventory;
                (container as LootContainer).minSecondsBetweenRefresh = -1;
                (container as LootContainer).maxSecondsBetweenRefresh = 0;
                (container as LootContainer).CancelInvoke("SpawnLoot");

            }
            else if(container is StorageContainer)
            {
                //Puts($"Checking a StorageContainer");
                inventory = (container as StorageContainer).inventory;
            }
            else if(container is DroppedItemContainer)
            {
                //Puts($"Checking a DroppedItemContainer");
                inventory = (container as DroppedItemContainer).inventory;
            }
            else if(container is NPCPlayerCorpse)
            {
                //Puts($"Checking a NPCPlayerCorpse");
                inventory = (container as NPCPlayerCorpse).containers[0];
            }
            else
            {
                Puts($"Unhandled type: {container.GetType()}");
                return;
            }
     
            bool updated = false;
            List<Item> itemsToRemove = new List<Item>();
            List<Item> itemsToAdd = new List<Item>();

            foreach(Item item in inventory.itemList)
            {
                if(!CanHaveItem(item.info))
                {
                    Item itemToAdd = ReplaceItem(item.info, item.amount);
                    if(itemToAdd != null)
                        itemsToAdd.Add(itemToAdd);

                    itemsToRemove.Add(item);
                    updated = true;
                }
            }

            if(updated)
            {
                foreach(Item item in itemsToRemove)
                {
                    //item.RemoveFromContainer();
                    //DestroyItem(item);
                    item.Remove(0f);
                }

                ItemManager.DoRemoves();

                foreach(Item item in itemsToAdd)
                {
                    item.MoveToContainer(inventory, -1, false);
                }

                //inventory.MarkDirty();
                container.SendNetworkUpdate();
                return;
            }
            return;
        }

        // in case the user puts rockets/grenades in the Ammunition category
        private void FixHeavyAmmoCategory()
        {
            if(items["Ammunition"] == null)
                return;
			
            Dictionary<string, object> ammoItems = new Dictionary<string, object>(items["Ammunition"] as Dictionary<string, object>);
            foreach(string shortname in ammoItems.Keys)
                items[GetCategoryString(ItemManager.FindItemDefinition(shortname)), shortname] = items["Ammunition", shortname];

            items.Save();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            if (!Config.Exists())
                LoadDefaultConfig();
            else
            {
                try
                {
                    config = Config.ReadObject<PluginConfig>();
                }
                catch (Exception ex)
                {
                    RaiseError(string.Format(lang.GetMessage("ConfigError", this), ex.Message));
                }
            }

            SaveConfig();
        }

        private void Init()
        {
            TimeZoneInfo.ClearCachedData();
            permission.RegisterPermission("timedprogression.configure", this);
            timeData = Interface.Oxide.DataFileSystem.GetDatafile("TimedProgression/timeData");
            items = Interface.Oxide.DataFileSystem.GetDatafile("TimedProgression/items");
            if(items["Weapon"] == null)
            {
                Puts("Loading default config");
                LoadDefaultItemsConfig();
            }

            FixHeavyAmmoCategory();

            if(timeData["currentPhase"] == null)
                timeData["currentPhase"] = 1;

            if(timeData["wipeTime"] == null)
                timeData["wipeTime"] = DateTime.Now.ToString();

            timer.Every(60f, UpdateLoop);
            timer.Once(150f, RefreshVendingMachines);           
        }

        private void UpdateLoop()
        {
            if((int)timeData["currentPhase"] - 1 == config.thresholds.Count)
                return;

            if((DateTime.Now - DateTime.Parse((string)timeData["wipeTime"])).TotalMinutes < config.thresholds[(int)timeData["currentPhase"] - 1])
                return;

            timeData["currentPhase"] = (int)timeData["currentPhase"] + 1;
            NotifyPhaseChange();
            RefreshVendingMachines();

        }

        private void Unload()
        {
            timeData.Save();
        }

        private void OnServerSave()
        {
            timeData.Save();
        }

        private void NotifyPhaseChange()
        {
            string msg;
            foreach (var player in BasePlayer.activePlayerList)
            {
                msg = string.Format(lang.GetMessage("NotifyPhaseChange", this, player.UserIDString), (int)timeData["currentPhase"]);
                player.ChatMessage(msg);
                GUIAnnouncements?.Call("CreateAnnouncement", msg, "Purple", "Yellow", player);
            }

            if(DiscordCore != null)
                SendMessage(config.botChannel, string.Format(lang.GetMessage("NotifyPhaseChange", this), (int)timeData["currentPhase"]));
        }

        private void RefreshVendingMachines()
        {
            foreach(var entity in BaseNetworkable.serverEntities)
            {
                if (entity is NPCVendingMachine)
                {
                    MyInstallFromVendingOrders((entity as NPCVendingMachine));
                }
            }
        }

        private void MyInstallFromVendingOrders(NPCVendingMachine machine)
        {
            if(machine.vendingOrders == null)
                return;

            machine.ClearSellOrders();
            machine.inventory.Clear();
            ItemManager.DoRemoves();
            foreach(NPCVendingOrder.Entry entry in machine.vendingOrders.orders)
            {
                if(CanHaveItem(ItemManager.FindItemDefinition(entry.sellItem.itemid)))
                    machine.AddItemForSale(entry.sellItem.itemid, entry.sellItemAmount, entry.currencyItem.itemid, 
                                           entry.currencyAmount, machine.GetBPState(entry.sellItemAsBP, entry.currencyAsBP));
            }
        }

    }
}


// --- End of file: TimedProgression.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/twitch-auth ---
// --- Original File Path: T/TwitchAuth/TwitchAuth.cs ---

// Requires: Twitch

using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Twitch Auth", "Wulf", "1.0.0")]
    [Description("Allows players to authorize themselves as a Twitch follower")]
    class TwitchAuth : CovalencePlugin
    {
        #region Configuration

        /*private Configuration config;

        public class Configuration
        {
            [JsonProperty("Kick players if not following")]
            public bool KickIfNotFollowing { get; set; } = true;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }*/

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandTwitchAuth"] = "twitchauth",
                ["FollowOnTwitch"] = "Please follow @ twitch.tv/{0}",
                ["Followed"] = "Thanks for following on Twitch!",
                ["IsExcluded"] = "{0} is excluded from checks",
                ["IsFollowing"] = "{0} is a Twitch follower",
                ["NotFollowing"] = "{0} is not a Twitch follower",
                ["TryAgainLater"] = "Currently unavailable, please try again later",
                ["UsageAuth"] = "Usage: {0} <twitch user name>"
            }, this);
        }

        #endregion Localization

        #region Initialization

        [PluginReference]
        private Plugin Twitch;

        //private const string permExclude = "twitchauth.exclude";
        //private const string permNoKick = "twitchauth.nokick";

        private string TwitchChannel;

        private void Init()
        {
            AddLocalizedCommand(nameof(CommandTwitchAuth));

            //permission.RegisterPermission(permExclude, this);
            //permission.RegisterPermission(permNoKick, this);
        }

        private void OnServerInitialized()
        {
            TwitchChannel = Twitch.Call<string>("GetChannel");
        }

        #endregion Initialization

        /*private void OnUserConnected(IPlayer player)
        {
            if (player.HasPermission(permExclude))
            {
                Log(GetLang("IsExcluded", null, player.Name));
                return;
            }

            Action<bool> callback = following =>
            {
                if (!following && config.KickIfNotFollowing && !player.HasPermission(permNoKick))
                {
                    // TODO: Give a grace period to auth before kick
                    player.Kick(GetLang("FollowOnTwitch", player.Id, TwitchChannel));
                }
            };
            Twitch.Call("IsFollowing", player.Name, player, callback);
        }*/

        #region Commands

        private void CommandTwitchAuth(IPlayer player, string command, string[] args)
        {
            if (args.Length < 1)
            {
                Message(player, "UsageAuth", command);
                return;
            }

            string loginOrUserId = args[0];
            Match urlMatch = Regex.Match(args[0], ".*/([^/]+)$");
            if (urlMatch.Success)
            {
                loginOrUserId = urlMatch.Groups[1].ToString();
                LogWarning(loginOrUserId);
            }

            Action<bool?> callbackFollows = following =>
            {
                if (following != null && (bool)following)
                {
                    Message(player, "Followed");
                }
                else
                {
                    Message(player, "FollowOnTwitch", TwitchChannel);
                }
            };
            Twitch.Call("IsFollowing", loginOrUserId, player, callbackFollows);
        }

        #endregion Commands

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: TwitchAuth.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/teams-logger ---
// --- Original File Path: T/TeamsLogger/TeamsLogger.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Teams Logger", "Ujiou", "1.5.1")]
    [Description("Simple plugin to log team events.")]
    class TeamsLogger : CovalencePlugin
    {
        #region Config & Data   
        private class PluginData
        {
            public bool FirstStart { get; set; } = true;
        }

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "CONSOLE SETTINGS")]
            public ConsoleSettings conSettings { get; set; }

            [JsonProperty(PropertyName = "FILE SETTINGS")]
            public FileSettings fileSettings { get; set; }

            [JsonProperty(PropertyName = "DISCORD SETTINGS")]
            public DiscordSettings disSettings { get; set; }

            public class ConsoleSettings
            {
                [JsonProperty(PropertyName = "Log to Console")]
                public bool logToConsole { get; set; } = true;

                [JsonProperty(PropertyName = "On Logged Colors (1 - Red, 2 - Yellow, 3 - White)")]
                public int consColorScheme = 3;

                [JsonProperty(PropertyName = "Anti-Spam Measure (Seconds)")]
                public float conAntiSpamMeasure { get; set; } = 3.0f;
            }

            public class FileSettings
            {
                [JsonProperty(PropertyName = "Log to Files")]
                public bool logToFile { get; set; } = false;

                [JsonProperty(PropertyName = "Anti-Spam Measure (Seconds)")]
                public float fileAntiSpamTime { get; set; } = 3.0f;
            }

            public class DiscordSettings
            {
                [JsonProperty(PropertyName = "Log to Discord")]
                public bool logToDiscord { get; set; } = false;

                [JsonProperty(PropertyName = "Anti-Spam Measure (Seconds)")]
                public float discordTime { get; set; } = 3.0f;

                [JsonProperty(PropertyName = "Discord Rate Limit")]
                public int discordTimeout { get; set; } = 360;

                [JsonProperty("Webhook URL")]
                public string discordURL { get; set; } = "---DISCORD WEBHOOK HERE---";
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    throw new JsonException();
            }
            catch
            {
                LoadDefaultConfig();
                SaveConfig();
            }
        }
        void SaveConfig() => Config.WriteObject(configData, true);

        protected override void LoadDefaultConfig()
        {
            LogWarning("Creating a new config file.");
            configData = LoadBaseConfig();
            SaveConfig();
        }

        private ConfigData LoadBaseConfig()
        {
            return new ConfigData
            {
                conSettings = new ConfigData.ConsoleSettings { },
                fileSettings = new ConfigData.FileSettings { },
                disSettings = new ConfigData.DiscordSettings { }
            };
        }
        #endregion

        #region Hooks
        private void Init() { if (IsFirstRun()) LogCurrentTeams(); }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(new DefaultLocalization(), this); // Load Default Messages

        private void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team) => KeyType(player,
                "OnTeamCreated", team.teamID, player.displayName, player.userID);

        private void OnTeamInvite(BasePlayer inviter, BasePlayer target) => KeyType(inviter,
               "OnTeamInvite", inviter.Team.teamID, inviter.displayName, inviter.userID, target.displayName, target.userID);

        private void OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player) => KeyType(player,
              "OnTeamAcceptInvite", team.teamID, player.displayName, player.userID, team.GetLeader().displayName);

        private void OnTeamRejectInvite(BasePlayer rejector, RelationshipManager.PlayerTeam team) => KeyType(rejector,
               "OnTeamRejectInvite", team.teamID, rejector.displayName, rejector.userID, team.GetLeader());

        private void OnTeamPromote(RelationshipManager.PlayerTeam team, BasePlayer newLeader) => KeyType(newLeader,
               "OnTeamPromote", team.teamID, newLeader.displayName, newLeader.userID);

        private void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player) => KeyType(player,
               "OnTeamLeave", team.teamID, player.displayName, player.userID, player.userID == team.teamLeader);

        private void OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong target) => KeyType(player,
                "OnTeamKick", team.teamID, target, player.displayName);

        private void OnTeamDisbanded(RelationshipManager.PlayerTeam team) => KeyType(team.GetLeader(),
                "OnTeamDisbanded", team.teamID, team.GetLeader().displayName, team.GetLeader().userID);
        #endregion

        #region Helpers
        List<ulong> discordID = new List<ulong>();
        List<ulong> fileID = new List<ulong>();
        List<ulong> playerId = new List<ulong>();
        private readonly Dictionary<string, string> headers = new Dictionary<string, string> { { "Content-Type", "application/json" } };

        private void PrintToConsole(BasePlayer player, string log)
        {
            if (playerId.Contains(player.userID)) return;
            playerId.Add(player.userID);
            timer.Once(configData.conSettings.conAntiSpamMeasure, () => playerId.Remove(player.userID));
            switch (configData.conSettings.consColorScheme)
            {
                case 1:
                    LogError(log);
                    return;
                case 2:
                    LogWarning(log);
                    return;
                case 3:
                    Puts(log);
                    return;
                default:
                    Puts("There was an issue with loading the config. You need to set the value to:");
                    LogError("1 - Red");
                    LogWarning("2 - Yellow");
                    Puts("3 - White");
                    return;
            }
        }

        private void PrintToFile(BasePlayer player, string log)
        {
            var timestamp = DateTime.UtcNow.ToString("hh:mm:ss");
            log = $"{timestamp} | {log}";
            if (fileID.Contains(player.userID)) return;
            fileID.Add(player.userID);
            timer.Once(configData.fileSettings.fileAntiSpamTime, () => fileID.Remove(player.userID));
            LogToFile("common", log, this);
        }

        private void PrintToDiscord(BasePlayer player, string log)
        {
            if (!configData.disSettings.logToDiscord) return;
            if (string.IsNullOrEmpty(configData.disSettings.discordURL))
            {
                LogError("You need to provide a valid URL!");
                return;
            }
            var timestamp = DateTime.Now.ToString("HH:mm:ss");
            if (discordID.Contains(player.userID)) return;
            discordID.Add(player.userID);
            timer.Once(configData.disSettings.discordTime, () => discordID.Remove(player.userID));
            webrequest.Enqueue(configData.disSettings.discordURL, "{\"content\": \"" + timestamp + " | " + log + "\"}", (code, response) => { }, this, RequestMethod.POST, headers, configData.disSettings.discordTimeout);

        }

        private void KeyType(BasePlayer player, string key, params object[] args) => PrintingMessages(player, this[key, args]);

        private void PrintingMessages(BasePlayer player, string log)
        {
            if (configData.conSettings.logToConsole) PrintToConsole(player, log);
            if (configData.fileSettings.logToFile) PrintToFile(player, log);
            if (configData.disSettings.logToDiscord) PrintToDiscord(player, log);
        }

        #region Logging Previously Create Teams
        private void OtherType(string key, params object[] args) => OtherMessages(this[key, args]);

        private bool IsFirstRun()
        {
            var dataFileName = $"{GetType().Name}.{nameof(PluginData)}";
            var data = Interface.uMod.DataFileSystem.ReadObject<PluginData>(dataFileName);
            if (data.FirstStart)
            {
                data.FirstStart = false;
                Interface.uMod.DataFileSystem.WriteObject(dataFileName, data);
                return true;
            }
            return false;
        }

        private string GetUserInfo(ulong userId)
        {
            var user = covalence.Players.FindPlayerById(userId.ToString());
            return user == null ? userId.ToString() : $"{user.Name} ({userId})";
        }

        private void LogCurrentTeams()
        {
            var teams = RelationshipManager.ServerInstance.teams;
            foreach (var team in teams)
            {
                OtherType("CurrentTeam", team.Key, string.Join(", ", team.Value.members.Select(GetUserInfo)));
            }
        }

        private void OtherPrintToFile(string log)
        {
            var timestamp = DateTime.UtcNow.ToString("hh:mm:ss");
            log = $"{timestamp} | {log}";
            LogToFile("common", log, this);
        }

        private void OtherPrintToDiscord(string log)
          {
            if (!configData.disSettings.logToDiscord) return;
            if (string.IsNullOrEmpty(configData.disSettings.discordURL))
            {
                LogError("You need to provide a valid URL!");
                return;
            }
            var timestamp = DateTime.Now.ToString("HH:mm:ss");
            webrequest.Enqueue(configData.disSettings.discordURL, "{\"content\": \"" + timestamp + " | " + log + "\"}", (code, response) => { }, this, RequestMethod.POST, headers, configData.disSettings.discordTimeout);
        }

        private void OtherPrintToConsole(string log)
        {
            switch (configData.conSettings.consColorScheme) {
                case 1:
                    LogError(log);
                    return;
                case 2:
                    LogWarning(log);
                    return;
                case 3:
                    Puts(log);
                    return;
                default:
                    break;
            }
        }

        private void OtherMessages(string log)
        {
            if (configData.conSettings.logToConsole) OtherPrintToConsole(log);
            if (configData.fileSettings.logToFile) OtherPrintToFile(log);
            if (configData.disSettings.logToDiscord) OtherPrintToDiscord(log);
        }

        #endregion

        private string this[string key, params object[] args] => args?.Any() == true ? string.Format(lang.GetMessage(key, this), args) : lang.GetMessage(key, this);
        #endregion

        #region Localization
        private class DefaultLocalization : Dictionary<string, string>
        {
            public DefaultLocalization()
            {
                this["OnTeamCreated"] = "OnTeamCreated | Team ID: {0} | Player: '{1}' ({2}) created a new team.";
                this["OnTeamDisbanded"] = "OnTeamDisbanded | Team ID: {0} | Team Leader: '{1}' ({2}).";
                this["OnTeamLeave"] = "OnTeamLeave | Team ID: {0} | Player: '{1}' ({2}, is leader: {3}).";
                this["OnTeamInvite"] = "OnTeamInvite | Team ID: {0} | Player '{1}' ({2}) sent invite to {3} ({4}).";
                this["OnTeamRejectInvite"] = "OnTeamRejectInvite | Team ID: {0} | Player: '{1}' ({2}) rejected invite from {3}.";
                this["OnTeamPromote"] = "OnTeamPromote | Team ID: {0} | Player: '{1}' ({2}) is the new leader.";
                this["OnTeamKick"] = "OnTeamKick | Team ID: {0} | {1} was kicked. | Team Leader: {2}";
                this["OnTeamAcceptInvite"] = "OnTeamAcceptInvite | Team ID: {0} | Player: '{1}' ({2}) accepted invite from {3}.";
                this["CurrentTeam"] = "CurrentTeams: {0} | Previously created team with members: {1}";
            }
        }
        #endregion
    }
}

// --- End of file: TeamsLogger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/taser ---
// --- Original File Path: T/Taser/Taser.cs ---

using Newtonsoft.Json;

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Taser", "Kopter", "2.0.2")]
    [Description("Transforms a Semi-Automatic Pistol into a Taser")]

    public class Taser : RustPlugin
    {
        #region Variables

        private ItemDefinition taserAmmoType;

        private const string useTaserPermission = "taser.use";

        private const string taserAffectPermission = "taser.affect";

        private const string lootPlayerPermission = "taser.loot";

        private const string revivePlayerPermission = "taser.revive";

        private const string semiAutoPistolShortname = "pistol_semiauto.entity";

        private const string screamSound = "assets/bundled/prefabs/fx/player/beartrap_scream.prefab";

        private const string shockEffect = "assets/prefabs/locks/keypad/effects/lock.code.shock.prefab";

        private List<ulong> woundedPlayers = new List<ulong> { };

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            taserAmmoType = ItemManager.FindItemDefinition("ammo.pistol.hv");

            permission.RegisterPermission(useTaserPermission, this);
            permission.RegisterPermission(taserAffectPermission, this);
            permission.RegisterPermission(lootPlayerPermission, this);
            permission.RegisterPermission(revivePlayerPermission, this);

            woundedPlayers.Clear();
        }

        private void OnWeaponReload(BaseProjectile projectile, BasePlayer player)
        {
            if (projectile == null || player == null)
                return;

            if (!permission.UserHasPermission(player.UserIDString, useTaserPermission))
                return;

            if (projectile.ShortPrefabName != semiAutoPistolShortname)
                return;

            projectile.primaryMagazine.capacity = (projectile.primaryMagazine.ammoType == taserAmmoType)
                ? config.NumberOfRounds
                : projectile.primaryMagazine.definition.builtInSize;
        }

        private object OnEntityTakeDamage(BasePlayer victim, HitInfo hitInfo)
        {
            if (victim == null || victim.IsNpc || hitInfo == null)
                return null;

            if (config.AffectPermissionNeeded && !permission.UserHasPermission(victim.UserIDString, taserAffectPermission))
                return null;

            if (woundedPlayers.Contains(victim.userID))
                return false;

            var weaponName = hitInfo.WeaponPrefab?.ShortPrefabName;

            if (weaponName == null || weaponName != semiAutoPistolShortname)
                return null;

            var weaponAmmo = hitInfo.Weapon as BaseProjectile;

            if (weaponAmmo == null || weaponAmmo.primaryMagazine.ammoType != taserAmmoType)
                return null;

            var attacker = victim.lastAttacker as BasePlayer ?? hitInfo.InitiatorPlayer;

            if (attacker == null || !permission.UserHasPermission(attacker.UserIDString, useTaserPermission))
                return null;

            if (config.MaxDistance > 0 && (int)hitInfo.ProjectileDistance > config.MaxDistance)
                return false;

            victim.BecomeWounded();

            woundedPlayers.Add(victim.userID);

            Effect.server.Run(shockEffect, hitInfo.HitPositionWorld);

            Timer screamSoundTimer = null;

            if (config.PlayScream)
            {
                Effect.server.Run(screamSound, victim.transform.position);

                screamSoundTimer = timer.Every(4f, () =>
                {
                    if (victim == null || !woundedPlayers.Contains(victim.userID.Get()))
                        screamSoundTimer?.Destroy();

                    else Effect.server.Run(screamSound, victim.transform.position);
                });
            }

            timer.Once(config.WoundedTime, () =>
            {
                victim?.StopWounded();

                woundedPlayers.Remove(victim.userID.Get());

                screamSoundTimer?.Destroy();
            });

            return false;
        }

        private object CanLootPlayer(BasePlayer target, BasePlayer looter)
        {
            if (target == null || looter == null)
                return null;

            if (!woundedPlayers.Contains(target.userID.Get()))
                return null;

            if (config.LootPermissionNeeded && !permission.UserHasPermission(looter.UserIDString, lootPlayerPermission))
                return false;

            return null;
        }

        private object OnPlayerAssist(BasePlayer target, BasePlayer reviver)
        {
            if (target == null || reviver == null)
                return null;

            if (!woundedPlayers.Contains(target.userID.Get()))
                return null;

            if (config.RevivePermissionNeeded && !permission.UserHasPermission(reviver.UserIDString, revivePlayerPermission))
                return false;

            woundedPlayers.Remove(target.userID.Get());

            return null;
        }

        private void Unload()
        {
            taserAmmoType = null;

            foreach (var player in BasePlayer.activePlayerList)
                if (woundedPlayers.Contains(player.userID.Get()) && player.IsWounded())
                    player.StopWounded();

            woundedPlayers.Clear();
        }

        #endregion

        #region Config

        private ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Number Of Taser Rounds")]
            public int NumberOfRounds = 1;

            [JsonProperty(PropertyName = "Wounded Time (In Seconds)")]
            public float WoundedTime = 10;

            [JsonProperty(PropertyName = "Max Distance where the Taser will work (If 0, a max distance will not be applied)")]
            public int MaxDistance = 0;

            [JsonProperty(PropertyName = "Play a Scream Sound while the player is tased")]
            public bool PlayScream = false;

            [JsonProperty(PropertyName = "Requires a permission to be affected by the taser")]
            public bool AffectPermissionNeeded = false;

            [JsonProperty(PropertyName = "Requires permission to loot a player affected by the taser")]
            public bool LootPermissionNeeded = true;

            [JsonProperty(PropertyName = "Requires permission to revive a player affected by the taser")]
            public bool RevivePermissionNeeded = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                    LoadDefaultConfig();
            }

            catch
            {
                PrintError("Configuration file is corrupt, check your config file at https://jsonlint.com/!");
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new ConfigData();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
    }
}


// --- End of file: Taser.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/timed-command-blocker ---
// --- Original File Path: T/TimedCommandBlocker/TimedCommandBlocker.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using System.Text;
using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Timed Command Blocker", "MON@H", "1.3.1")]
    [Description("Block commands temporarily or permanently")]
    public class TimedCommandBlocker : RustPlugin
    {
        #region Variables

        private const string PermissionUse = "timedcommandblocker.use";
        private const string PermissionImmunity = "timedcommandblocker.immunity";
        private readonly List<BlockedCommand> _blockedCommands = new List<BlockedCommand>();
        private readonly StringBuilder _sb = new StringBuilder();

        private class BlockedCommand
        {
            public string Command { get; set; }
            public double BlockDuration { get; set; }
            public TimeSpan GetTimeUntilUnlock()
            {
                return SaveRestore.SaveCreatedTime.AddSeconds(BlockDuration) - DateTime.Now;
            }
        }

        #endregion Variables

        #region Initialization

        private void Init()
        {
            UnsubscribeHooks();

            permission.RegisterPermission(PermissionUse, this);
            permission.RegisterPermission(PermissionImmunity, this);

            LoadDefaultMessages();
        }

        private void OnServerInitialized()
        {
            if (_configData.BlockedCommands.Count > 0)
            {
                foreach (BlockedCommand blockedCommand in _configData.BlockedCommands)
                {
                    if (blockedCommand.BlockDuration < 0 || blockedCommand.GetTimeUntilUnlock().TotalSeconds > 0)
                    {
                        _blockedCommands.Add(blockedCommand);
                    }
                }

                if (_blockedCommands.Count > 0)
                {
                    _blockedCommands.Sort((a, b) => a.Command.CompareTo(b.Command));

                    SubscribeHooks();
                }
            }
        }

        #endregion Initialization

        #region Configuration

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Enable logging")]
            public bool LoggingEnabled = false;

            [JsonProperty(PropertyName = "Chat steamID icon")]
            public ulong SteamIDIcon = 0;

            [JsonProperty(PropertyName = "Сommand color")]
            public string ChatCommandColor = "#FFFF00";

            [JsonProperty(PropertyName = "Remaining blocking time color")]
            public string ChatCommandArgumentColor = "#FFA500";

            [JsonProperty(PropertyName = "Blocked commands (command: seconds)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<BlockedCommand> BlockedCommands = new List<BlockedCommand>()
            {
                new BlockedCommand {
                    Command = "Blocked for 1 day",
                    BlockDuration = 86400
                },
                new BlockedCommand {
                    Command = "Blocked permanently",
                    BlockDuration = -1
                },
                new BlockedCommand {
                    Command = "Not blocked",
                    BlockDuration = 0
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration

        #region Localization

        private string Lang(string key, string userIDString = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, userIDString), args);
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception:\n{ex}");
                throw;
            }
        }

        private static class LangKeys
        {
            public static class Format
            {
                private const string Base = nameof(Format) + ".";
                public const string Days = Base + nameof(Days);
                public const string Hours = Base + nameof(Hours);
                public const string Minutes = Base + nameof(Minutes);
                public const string Day = Base + nameof(Day);
                public const string Hour = Base + nameof(Hour);
                public const string Minute = Base + nameof(Minute);
                public const string Prefix = Base + nameof(Prefix);
                public const string Second = Base + nameof(Second);
                public const string Seconds = Base + nameof(Seconds);
            }
            
            public static class Info
            {
                private const string Base = nameof(Info) + ".";
                public const string Blocked = Base + nameof(Blocked);
                public const string Timed = Base + nameof(Timed);
            }
        }


        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Format.Day] = "day",
                [LangKeys.Format.Days] = "days",
                [LangKeys.Format.Hour] = "hour",
                [LangKeys.Format.Hours] = "hours",
                [LangKeys.Format.Minute] = "minute",
                [LangKeys.Format.Minutes] = "minutes",
                [LangKeys.Format.Prefix] = "<color=#00FF00>[Timed Command Blocker]</color>: ",
                [LangKeys.Format.Second] = "second",
                [LangKeys.Format.Seconds] = "seconds",
                [LangKeys.Info.Blocked] = "Command <color={0}>{1}</color> is blocked.",
                [LangKeys.Info.Timed] = "Command <color={0}>{1}</color> is blocked.\nUnblocking in {2}.",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Format.Day] = "день",
                [LangKeys.Format.Days] = "дней",
                [LangKeys.Format.Hour] = "час",
                [LangKeys.Format.Hours] = "часов",
                [LangKeys.Format.Minute] = "минуту",
                [LangKeys.Format.Minutes] = "минут",
                [LangKeys.Format.Prefix] = "<color=#00FF00>[Временная блокировка команд]</color>: ",
                [LangKeys.Format.Second] = "сукунду",
                [LangKeys.Format.Seconds] = "секунд",
                [LangKeys.Info.Blocked] = "Команда <color={0}>{1}</color> заблокирована.",
                [LangKeys.Info.Timed] = "Команда <color={0}>{1}</color> заблокирована.\nРазблокировка через: {2}.",
            }, this, "ru");
        }

        #endregion Localization

        #region Oxide Hooks

        private object OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (player != null)
            {
                if (args != null && args.Length != 0)
                {
                    foreach (string arg in args)
                    {
                        command += $" {arg}";
                    }
                }

                return HandleCommand(player, command);
            }

            return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (player != null && arg.cmd.FullName != "chat.say")
            {
                string command = arg.cmd.Name;
                string fullCommand = arg.cmd.FullName;

                if (!string.IsNullOrEmpty(arg.FullString))
                {
                    command += $" {arg.FullString}";
                    fullCommand += $" {arg.FullString}";
                }

                return HandleCommand(player, command) ?? HandleCommand(player, fullCommand);
            }

            return null;
        }

        #endregion Oxide Hooks

        #region Core

        private object HandleCommand(BasePlayer player, string command)
        {
            if (permission.UserHasPermission(player.UserIDString, PermissionUse)
            && !permission.UserHasPermission(player.UserIDString, PermissionImmunity))
            {
                for (int i = 0; i < _blockedCommands.Count; i++)
                {
                    BlockedCommand blockedCommand = _blockedCommands[i];

                    if (command.StartsWith(blockedCommand.Command, StringComparison.OrdinalIgnoreCase))
                    {
                        if (blockedCommand.BlockDuration < 0)
                        {
                            Log($"{player.userID} {player.displayName} command blocked: {command}");
                            PlayerSendMessage(player, Lang(LangKeys.Info.Blocked, player.UserIDString, _configData.ChatCommandColor, command));
                            return true;
                        }

                        TimeSpan timeRemaining = blockedCommand.GetTimeUntilUnlock();

                        if (timeRemaining.TotalSeconds > 0)
                        {
                            Log($"{player.userID} {player.displayName} command blocked: {command} for: {timeRemaining.TotalSeconds.ToString("F0")} seconds");
                            PlayerSendMessage(player, Lang(LangKeys.Info.Timed, player.UserIDString, _configData.ChatCommandColor, command, GetFormattedDurationTime(timeRemaining, player.UserIDString)));
                            return true;
                        }

                        _blockedCommands.Remove(blockedCommand);
                        break;
                    }
                }

                if (_blockedCommands.Count == 0)
                {
                    UnsubscribeHooks();
                }
            }

            return null;
        }

        #endregion Core

        #region Helpers

        private void UnsubscribeHooks()
        {
            Unsubscribe(nameof(OnPlayerCommand));
            Unsubscribe(nameof(OnServerCommand));
        }

        private void SubscribeHooks()
        {
            Subscribe(nameof(OnPlayerCommand));
            Subscribe(nameof(OnServerCommand));
        }


        private string GetFormattedDurationTime(TimeSpan time, string id = null)
        {
            _sb.Clear();

            if (time.Days > 0)
            {
                BuildTime(_sb, time.Days == 1 ? LangKeys.Format.Day : LangKeys.Format.Days, id, time.Days);
            }

            if (time.Hours > 0)
            {
                BuildTime(_sb, time.Hours == 1 ? LangKeys.Format.Hour : LangKeys.Format.Hours, id, time.Hours);
            }

            if (time.Minutes > 0)
            {
                BuildTime(_sb, time.Minutes == 1 ? LangKeys.Format.Minute : LangKeys.Format.Minutes, id, time.Minutes);
            }

            BuildTime(_sb, time.Seconds == 1 ? LangKeys.Format.Second : LangKeys.Format.Seconds, id, time.Seconds);

            return _sb.ToString();
        }

        private void BuildTime(StringBuilder sb, string lang, string playerId, int value)
        {
            sb.Append("<color=#FFA500>");
            sb.Append(value);
            sb.Append("</color> ");
            sb.Append(Lang(lang, playerId));
            sb.Append(" ");
        }

        private void PlayerSendMessage(BasePlayer player, string message)
        {
            player.SendConsoleCommand("chat.add", 2, _configData.SteamIDIcon, string.IsNullOrEmpty(Lang(LangKeys.Format.Prefix, player.UserIDString)) ? message : Lang(LangKeys.Format.Prefix, player.UserIDString) + message);
        }

        private void Log(string text)
        {
            if (_configData.LoggingEnabled)
            {
                LogToFile("log", $"{DateTime.Now.ToString("HH:mm:ss")} {text}", this);                
            }
        }

        #endregion Helpers
    }
}

// --- End of file: TimedCommandBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/true-smoke-rockets ---
// --- Original File Path: T/TrueSmokeRockets/TrueSmokeRockets.cs ---

﻿using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("True Smoke Rockets", "VisEntities", "1.1.0")]
    [Description("Functional smoke rockets that produce a smoke cloud upon explosion.")]
    public class TrueSmokeRockets : RustPlugin
    {
        #region Fields

        private static Configuration _config;

        private const string SMOKE_ROCKET_PREFAB = "assets/prefabs/ammo/rocket/rocket_smoke.prefab";
        private const string SMOKE_GRENADE_PREFAB = "assets/prefabs/tools/smoke grenade/grenade.smoke.deployed.prefab";

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Smoke Duration Seconds")]
            public float SmokeDurationSeconds { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                SmokeDurationSeconds = 30f,
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Unload()
        {
            _config = null;
        }

        private void OnEntityKill(TimedExplosive explosive)
        {
            if (explosive == null)
                return;
            
            if (explosive.PrefabName != SMOKE_ROCKET_PREFAB)
                return;

            SmokeGrenade smokeGrenade = GameManager.server.CreateEntity(SMOKE_GRENADE_PREFAB, explosive.transform.position, Quaternion.identity) as SmokeGrenade;
            if (smokeGrenade != null)
            {
                smokeGrenade.smokeDuration = _config.SmokeDurationSeconds;
                smokeGrenade.Spawn();
            }
        }

        #endregion Oxide Hooks
    }
}


// --- End of file: TrueSmokeRockets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tea-modifiers ---
// --- Original File Path: T/TeaModifiers/TeaModifiers.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Tea Modifiers", "MJSU", "2.1.2")]
    [Description("Allows the modification of tea buffs on items")]
    internal class TeaModifiers : RustPlugin
    {
        #region Class Fields
        private PluginConfig _pluginConfig; //Plugin Config
        
        private const string BasePermission = "teamodifiers.";
        private const string UsePermission = BasePermission + "use";
        
        private readonly Hash<ulong, float> _playerGlobalDurationCache = new Hash<ulong, float>();
        private readonly Hash<Modifier.ModifierType, Hash<ulong, float>> _globalTypeValueCache = new Hash<Modifier.ModifierType, Hash<ulong, float>>();
        private readonly Hash<ulong, float> _playerGlobalValueCache = new Hash<ulong, float>();
        private readonly Hash<string, Hash<ulong, float>> _playerDurationCache = new Hash<string, Hash<ulong, float>>();
        private readonly Hash<string, Hash<ulong, float>> _playerValueCache = new Hash<string, Hash<ulong, float>>();
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Modifiers = config.Modifiers ?? new Hash<string, List<ModifierData>>();
            config.GlobalDurationMultiplier = config.GlobalDurationMultiplier ?? new Hash<string, float>
            {
                [UsePermission] = 1f
            };
            
            config.GlobalAmountMultiplier = config.GlobalAmountMultiplier ?? new Hash<string, float>
            {
                [UsePermission] = 1f
            };
            
            config.GlobalModifierMultiplier = config.GlobalModifierMultiplier ?? new Hash<Modifier.ModifierType, Hash<string, float>>();
            
            foreach (Modifier.ModifierType type in Enum.GetValues(typeof(Modifier.ModifierType)).Cast<Modifier.ModifierType>())
            {
                if (!config.GlobalModifierMultiplier.ContainsKey(type))
                {
                    config.GlobalModifierMultiplier[type] = new Hash<string, float>
                    {
                        [UsePermission] = 1f
                    };
                }
            }

            return config;
        }
        
        private void OnServerInitialized()
        {
            bool changed = false;
            foreach (ItemDefinition def in ItemManager.itemList)
            {
                ItemModConsumable consume = def.GetComponent<ItemModConsumable>();
                if (!consume || consume.modifiers == null|| consume.modifiers.Count == 0)
                {
                    continue;
                }

                //Load saved modifiers
                List<ModifierData> modifiers = _pluginConfig.Modifiers[def.shortname];
                
                //Currently no modifiers saved. Save them now.
                if (modifiers == null)
                {
                    modifiers = consume.modifiers.Select(m => new ModifierData
                    {
                        Duration = new Hash<string, float> {[UsePermission] = m.duration},
                        Type = m.type,
                        Amount = new Hash<string, float> {[UsePermission] = m.value},
                    }).ToList();
                    _pluginConfig.Modifiers[def.shortname] = modifiers;
                    changed = true;
                }

                foreach (ModifierData data in modifiers)
                {
                    ModifierDefintion existing = consume.modifiers.FirstOrDefault(m => m.type == data.Type);
                    if (existing != null)
                    {
                        data.DefaultAmount = existing.value;
                        data.DefaultDuration = existing.duration;
                    }
                }
            }

            //If changes occured update config
            if (changed)
            {
                Config.WriteObject(_pluginConfig);
            }

            RegisterPermissions();
        }

        private void RegisterPermissions()
        {
            HashSet<string> perms = new HashSet<string> { UsePermission };
            foreach (List<ModifierData> item in _pluginConfig.Modifiers.Values)
            {
                foreach (ModifierData modifier in item)
                {
                    foreach (string key in modifier.Amount.Keys)
                    {
                        perms.Add(key);
                    }

                    foreach (string key in modifier.Duration.Keys)
                    {
                        perms.Add(key);
                    }
                }
            }

            foreach (Hash<string, float> modifier in _pluginConfig.GlobalModifierMultiplier.Values)
            {
                foreach (string key in modifier.Keys)
                {
                    perms.Add(key);
                }
            }

            foreach (string key in _pluginConfig.GlobalAmountMultiplier.Keys)
            {
                perms.Add(key);
            }

            foreach (string key in _pluginConfig.GlobalDurationMultiplier.Keys)
            {
                perms.Add(key);
            }

            foreach (string perm in perms)
            {
                permission.RegisterPermission(perm, this);
            }
        }
        #endregion
        
        #region Permission Hooks
        private void OnUserPermissionGranted(string playerId, string permName)
        {
            ulong id = ulong.Parse(playerId);
            _playerGlobalDurationCache.Remove(id);
            _globalTypeValueCache.Clear();
            _playerGlobalValueCache.Remove(id);
            _playerDurationCache.Clear();
            _playerValueCache.Clear();
        }
        
        private void OnUserPermissionRevoked(string playerId, string permName)
        {
            ulong id = ulong.Parse(playerId);
            _playerGlobalDurationCache.Remove(id);
            _globalTypeValueCache.Clear();
            _playerGlobalValueCache.Remove(id);
            _playerDurationCache.Clear();
            _playerValueCache.Clear();
        }
        
        private void OnUserGroupAdded(string playerId, string groupName)
        {
            ulong id = ulong.Parse(playerId);
            _playerGlobalDurationCache.Remove(id);
            _globalTypeValueCache.Clear();
            _playerGlobalValueCache.Remove(id);
            _playerDurationCache.Clear();
            _playerValueCache.Clear();
        }
        
        private void OnUserGroupRemoved(string playerId, string groupName)
        {
            ulong id = ulong.Parse(playerId);
            _playerGlobalDurationCache.Remove(id);
            _globalTypeValueCache.Clear();
            _playerGlobalValueCache.Remove(id);
            _playerDurationCache.Clear();
            _playerValueCache.Clear();
        }

        private void OnGroupPermissionGranted(string groupName, string permName)
        {
            _playerGlobalValueCache.Clear();
            _globalTypeValueCache.Clear();
            _playerGlobalDurationCache.Clear();
            _playerDurationCache.Clear();
            _playerValueCache.Clear();
        }
        
        private void OnGroupPermissionRevoked(string groupName, string permName)
        {
            _playerGlobalDurationCache.Clear();
            _globalTypeValueCache.Clear();
            _playerGlobalValueCache.Clear();
            _playerDurationCache.Clear();
            _playerValueCache.Clear();
        }
        #endregion

        #region Hooks
        private object OnPlayerAddModifiers(BasePlayer player, Item item, ItemModConsumable consumable)
        {
            if (!HasPermission(player, UsePermission))
            {
                return null;
            }

            string shortname = item.info.shortname;
            List<ModifierData> modifiers = _pluginConfig.Modifiers[item.info.shortname];
            if (modifiers == null)
            {
                return null;
            }

            if (Interface.Oxide.CallHook("CanApplyTeaModifier", player, item, consumable) != null)
            {
                return null;
            }

            List<ModifierDefintion> mods = Pool.GetList<ModifierDefintion>();
            for (int index = 0; index < modifiers.Count; index++)
            {
                ModifierData modifier = modifiers[index];
                if (Interface.Oxide.CallHook("CanApplyTeaModifierType", player, item, modifier.Type) != null)
                {
                    continue;
                }
                
                mods.Add(new ModifierDefintion
                {
                    source = Modifier.ModifierSource.Tea,
                    type = modifier.Type,
                    duration = GetPlayerDuration(player, shortname, modifier),
                    value = GetPlayerValue(player, shortname, modifier)
                });
            }

            player.modifiers.Add(mods);
            
            Pool.FreeList(ref mods);
            return true;
        }
        
        #endregion

        #region API
        private bool HasModifiers(string shortName)
        {
            return _pluginConfig.Modifiers[shortName] != null;
        }
        
        private float GetTeaDuration(BasePlayer player, string shortName, Modifier.ModifierType type)
        {
            ModifierData data = GetDataForItemType(shortName, type);
            if (data == null)
            {
                return 0;
            }
            
            return GetPlayerDuration(player, shortName, data);
        }

        private float GetTeaValue(BasePlayer player, string shortName, Modifier.ModifierType type)
        {
            ModifierData data = GetDataForItemType(shortName, type);
            if (data == null)
            {
                return 0;
            }

            return GetPlayerValue(player, shortName, data);
        }
        #endregion

        #region Helper Methods
        public float GetPlayerDuration(BasePlayer player, string shortName, ModifierData modifier)
        {
            float globalDuration = GetPermissionValue(player, _pluginConfig.GlobalDurationMultiplier, 1f, _playerGlobalDurationCache);
            
            Hash<ulong, float> durationCache = _playerDurationCache[shortName];
            if (durationCache == null)
            {
                durationCache = new Hash<ulong, float>();
                _playerDurationCache[shortName] = durationCache;
            }
            
            float duration = GetPermissionValue(player, modifier.Duration, modifier.DefaultDuration, durationCache);
            return globalDuration * duration;
        }
        
        public float GetPlayerValue(BasePlayer player, string shortName, ModifierData modifier)
        {
            float globalValue = GetPermissionValue(player, _pluginConfig.GlobalAmountMultiplier, 1f, _playerGlobalValueCache);
            
            Hash<ulong, float> typeCache = _globalTypeValueCache[modifier.Type];
            if (typeCache == null)
            {
                typeCache = new Hash<ulong, float>();
                _globalTypeValueCache[modifier.Type] = typeCache;
            }
            
            float globalTypeValue = GetPermissionValue(player, _pluginConfig.GlobalModifierMultiplier[modifier.Type], 1f, typeCache);
            
            Hash<ulong, float> valueCache = _playerValueCache[shortName];
            if (valueCache == null)
            {
                valueCache = new Hash<ulong, float>();
                _playerValueCache[shortName] = valueCache;
            }

            float playerValue = GetPermissionValue(player, modifier.Amount, modifier.DefaultAmount, valueCache);
            return globalValue * globalTypeValue * playerValue;
        }
        
        public ModifierData GetDataForItemType(string shortName, Modifier.ModifierType type)
        {
            List<ModifierData> modifiers = _pluginConfig.Modifiers[shortName];
            if (modifiers == null || modifiers.Count == 0)
            {
                return null;
            }
            
            foreach (ModifierData modifier in modifiers)
            {
                if (modifier.Type == type)
                {
                    return modifier;
                }
            }

            return null;
        }
        
        public float GetPermissionValue(BasePlayer player, Hash<string, float> permissions, float defaultValue, Hash<ulong, float> cache)
        {
            if (cache != null && cache.ContainsKey(player.userID))
            {
                return cache[player.userID];
            }
            
            foreach (KeyValuePair<string,float> perm in permissions.OrderByDescending(p => p.Value))
            {
                if (HasPermission(player, perm.Key))
                {
                    if (cache != null)
                    {
                        cache[player.userID] = perm.Value;
                    }
                    return perm.Value;
                }
            }
            
            if (cache != null)
            {
                cache[player.userID] = defaultValue;
            }
            
            return defaultValue;
        }

        public bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Global Duration Multiplier")]
            public Hash<string, float> GlobalDurationMultiplier { get; set; }
            
            [JsonProperty(PropertyName = "Global Amount Multiplier")]
            public Hash<string, float> GlobalAmountMultiplier { get; set; }
            
            [JsonProperty(PropertyName = "Global Modifier Type Amount Multiplier")]
            public Hash<Modifier.ModifierType, Hash<string, float>> GlobalModifierMultiplier { get; set; }
            
            [JsonProperty(PropertyName = "Item List Modifiers")]
            public Hash<string, List<ModifierData>> Modifiers { get; set; }
        }

        public class ModifierData
        {
            [JsonProperty(PropertyName = "Modifier Duration (Seconds)")]
            public Hash<string, float> Duration { get; set; }

            [JsonProperty(PropertyName = "Modifier Amount")]
            public Hash<string, float> Amount { get; set; }

            [JsonProperty(PropertyName = "Modifer Type")]
            [JsonConverter(typeof(StringEnumConverter))]
            public Modifier.ModifierType Type { get; set; }

            [JsonIgnore]
            public float DefaultDuration { get; set; } = 1f;
            
            [JsonIgnore]
            public float DefaultAmount { get; set; } = 1f;
        }
        #endregion
    }
}


// --- End of file: TeaModifiers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tool-cupboard-turrets ---
// --- Original File Path: T/ToolCupboardTurrets/ToolCupboardTurrets.cs ---

﻿using UnityEngine;

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Tool Cupboard Turrets", "0x89A", "1.3.1")]
    [Description("Turrets only attack building blocked players")]

    class ToolCupboardTurrets : RustPlugin
    {
        private const string turretsIgnore = "toolcupboardturrets.ignore";
        private const string turretsNeverIgnore = "toolcupboardturrets.neverIgnore";

        #region -Init-

        void Init()
        {
            permission.RegisterPermission(turretsIgnore, this);
            permission.RegisterPermission(turretsNeverIgnore, this);

            if (!_config.samSitesAffected && !_config.staticSamSitesAffected)
                Unsubscribe(nameof(OnSamSiteTarget));

            if (!_config.autoturretsAffected && !_config.shotgunTrapsAffected && !_config.flameTrapsAffected && !_config.NPCTurretsAffected)
                Unsubscribe(nameof(CanBeTargeted));
        }

        #endregion

        #region -Hooks-

        object CanBeTargeted(BasePlayer player, BaseCombatEntity entity)
        {
            if (player == null || string.IsNullOrEmpty(player.UserIDString))
                return null;

            if (permission.UserHasPermission(player.UserIDString, turretsIgnore))
                return true;

            if (permission.UserHasPermission(player.UserIDString, turretsNeverIgnore))
                return null;

            AutoTurret autoTurret = entity as AutoTurret;

            if (autoTurret != null && !(entity is NPCAutoTurret) && _config.autoturretsAffected)
            {
                if (!IsAuthedOnOwnerTc(entity, player))
                {
                    return null;
                }

                return true;
            }

            if (entity is NPCAutoTurret && _config.NPCTurretsAffected)
            {
                if (!IsAuthedOnOwnerTc(entity, player))
                {
                    return null;
                }

                return true;
            }

            if ((entity is FlameTurret && _config.flameTrapsAffected) || (entity is GunTrap && _config.shotgunTrapsAffected) && !player.IsBuildingBlocked())
            {
                return true;
            }

            return null;
        }

        object OnSamSiteTarget(SamSite samsite, BaseHelicopter target)
        {
            BasePlayer player = target.GetDriver();
            if (player == null)
            {
          