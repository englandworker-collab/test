      return null;
            }

            if (permission.UserHasPermission(player.UserIDString, turretsIgnore))
            {
                return true;
            }

            //If not affected, default behaviour
            if ((samsite.ShortPrefabName == "sam_site_turret_deployed" && !_config.samSitesAffected) ||
                (samsite.ShortPrefabName == "sam_static" && !_config.staticSamSitesAffected))
            {
                return null;
            }

            BuildingPrivlidge privilege = samsite.GetBuildingPrivilege();
            if (privilege == null || privilege.IsAuthed(player) || !player.IsBuildingBlocked())
            {
                return false;
            }

            return null;
        }

        #endregion

        private bool IsAuthedOnOwnerTc(BaseEntity entity, BasePlayer player)
        {
            BuildingPrivlidge privilege = entity.GetBuildingPrivilege();

            Vector3 entityPosition = entity.transform.position;

            return privilege != null && privilege.IsAuthed(player) &&
                   player.IsVisible(new Vector3(entityPosition.x, entityPosition.y + 0.8f, entityPosition.z), player.CenterPoint());
        }

        #region -Configuration-

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Auto-turrets affected")]
            public bool autoturretsAffected = true;

            [JsonProperty(PropertyName = "shotgun traps affected")]
            public bool shotgunTrapsAffected = true;

            [JsonProperty(PropertyName = "flame traps affected")]
            public bool flameTrapsAffected = true;

            [JsonProperty(PropertyName = "Sam sites affected")]
            public bool samSitesAffected = true;

            [JsonProperty(PropertyName = "Launch site sams affected")]
            public bool staticSamSitesAffected = false;

            [JsonProperty(PropertyName = "Outpost turrets affected")]
            public bool NPCTurretsAffected = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new System.Exception();
                SaveConfig();
            }
            catch
            {
                PrintWarning("Error loading config (either corrupt or does not exist), using default values");

                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion
    }
}

// --- End of file: ToolCupboardTurrets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tell-my-vote ---
// --- Original File Path: T/TellMyVote/TellMyVote.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Tell My Vote", "Spiikesan", "1.2.2")]
    [Description("A Cui panel for players to vote at admin polls")]

    /*======================================================================================================================= 
    *
    *   SET UP TO - 4 QUESTIONS / 3 ANSWERS - IN CONFIG FILE, AND USE TELLMYVOTE CUI TO VOTE AND CHECK COUNTS
    *   THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
    *   
    *   1.0.0   20190906    code refresh
    *
    *   permission : tellmyvote.admin
    *   chat commands   /{PanelCommand}     /myvote_poll X Y [args]
    *   It is case sensitive
    *   
    *   example :   /myvote_poll 1 0 question       ---> set "question" for poll#1 title
    *               /myvote_poll 1 1 first choice   ---> set "first choice" for poll#1 answer#1 
    *               /myvote_poll 1 2 second choice   ---> set "second choice" for poll#1 answer#2
    *
    *   if question is set empty ---> the whole poll won't be displayed
    *   if answer is set empty ---> the answer line won't be displayed
    *
    *   POLL#1      (myvote_poll 1 0 [args])               POLL#3      (myvote_poll 3 0 [args])
    *   answer#1    (myvote_poll 1 1 [args])               answer#1    (myvote_poll 3 1 [args])          
    *   answer#2    (myvote_poll 1 2 [args])               answer#2    (myvote_poll 3 2 [args])
    *   answer#3    (myvote_poll 1 3 [args])               answer#3    (myvote_poll 3 3 [args])
    *
    *   POLL#2      (myvote_poll 2 0 [args])               POLL#4      (myvote_poll 4 0 [args])
    *   answer#1    (myvote_poll 2 1 [args])               answer#1    (myvote_poll 4 1 [args])          
    *   answer#2    (myvote_poll 2 2 [args])               answer#2    (myvote_poll 4 2 [args])
    *   answer#3    (myvote_poll 2 3 [args])               answer#3    (myvote_poll 4 3 [args])
    *=======================================================================================================================*/

    public class TellMyVote : RustPlugin
    {

        /*
         * For left to right alignment, we need to satisfy the following generic formula :
         * MARGIN_LR * 2 + SEP_POLL + ( SEP_IN + SIZE_SUBCOL_1 + SIZE_SUBCOL_2 ) * 2 = 1.00
         *
         * For top to bottom alignment, we need to satisfy the following generic formula :
         * MARGIN_TB * 2 + SEP_POLL + SEP_IN * 6 + SIZE_ROW * 8 = 1.00
         *
         */

        const float MARGIN_LR = 0.03f; // Left / Right borders margins.
        const float MARGIN_TB = 0.05f; // Top / Bottom borders margins.
        const float SEP_POLL = 0.04f; // Polls separator
        const float SEP_IN = 0.01f; // In-between rows and columns separators.

        const float SIZE_SUBCOL_1 = 0.34f; // Answer button width
        const float SIZE_SUBCOL_2 = 0.10f; // count button width
        const float SIZE_ROW = 0.08f; // Each row height

        const float PollWidth = SIZE_SUBCOL_1 + SIZE_SUBCOL_2 + SEP_IN;
        const float PollHeight = SIZE_ROW * 4 + SEP_IN * 3;

        //precalculate rows and columns coordinates from floats to "x.xx" strings
        string[] pos_rows = new string[16];
        string[] pos_cols = new string[8];

        const string HelpButtonTxt = "0.0 1.0 1.0 0.5";
        const string HelpButtonColor = "0.0 0.5 1.0 0.5";
        const string PanelColor = "0.0 0.0 0.0 0.8";
        const string buttonCloseColor = "0.6 0.26 0.2 1";
        const string QuestionColor = "1.0 1.0 1.0 1.0";
        const string AnswerColor = "0.5 1.0 0.5 0.5";
        const string CountColor = "0.0 1.0 1.0 0.5";
        const bool debug = false;
        const string TMVAdmin = "tellmyvote.admin";
        const string DataFilename = "TellMyVote";

        bool ClearDataOnWipe = false;

        string MyVotePanel;
        string MyVoteInfoPanel;

        string Prefix = "[TMV] :";                      // CHAT PLUGIN PREFIX
        string PrefixColor = "#c12300";                 // CHAT PLUGIN PREFIX COLOR
        string ChatColor = "#ffcd7c";                   // CHAT MESSAGE COLOR

        string PanelTitle = "Tell My Vote Panel";
        string PanelCommand = "myvote";

        string BannerColor = "0.5 1.0 0.5 0.5";
        float BannerSizeX = 0.6f;
        float BannerSizeY = 0.05f;
        float BannerPositionX = 0.2f;
        float BannerPositionY = 0.1f;
        bool BannerMsgEnabled = true;
        bool ChatMsgEnabled = false;
        string BannerAnchorMin = "0.20 0.85";
        string BannerAnchorMax = "0.80 0.90";

        ulong SteamIDIcon = 76561198049668039;          // SteamID FOR PLUGIN ICON
        float VoteDurationMax = 0.0f;
        private bool ConfigChanged;

        float BannerShowTimer = 30;
        float BannerHideTimer = 30;

        string[,] polls = new string[4, 4];
        private Timer tmvbanner;

        void Init()
        {
            LoadVariables();
            permission.RegisterPermission(TMVAdmin, this);
            GenerateCoordinates();
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(DataFilename);
        }

        #region CONFIG

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void OnNewSave(string filename)
        {
            if (ClearDataOnWipe)
            {
                if (Interface.Oxide.DataFileSystem.ExistsDatafile(DataFilename))
                {
                    Interface.Oxide.DataFileSystem.GetFile(DataFilename).Clear();
                    Interface.Oxide.DataFileSystem.GetFile(DataFilename).Save();

                    Puts($"Server wipe detected, '{DataFilename}.json' wiped as well.");
                }
            }
        }

        private void GenerateCoordinates()
        {
            //Vote polls
            for (int i = 0; i < pos_rows.Length; i++)
            {
                int polls = i / 8;         // 0, 0, 0, 0, 0, 0, 0, 0, 1...
                int rows = i % 8;         //0, 1, 2, 3, 4, 5, 6, 7, 0...
                pos_rows[pos_rows.Length - i - 1] = FormatFloat((MARGIN_TB //y coordinates are inverted...
                                + polls * (PollHeight + SEP_IN) //Polls separation (is 0 for i in [0...7])
                                + (rows / 2f) * SEP_IN
                                + ((rows + 1) / 2f) * SIZE_ROW //Rows end : 0, 1, 1, 2, 2, 3, 3, 4, 0...
                              ));
                if (debug) { Puts($"pos_rows[{pos_rows.Length - i - 1}] = {pos_rows[pos_rows.Length - i - 1]}"); }
            }

            for (int i = 0; i < pos_cols.Length; i++)
            {
                int polls = i / 4;           // 0, 0, 0, 0, 1, 1, 1, 1
                int columns = i % 4;         // 0, 1, 2, 3, 0, 1, 2, 4
                int subcolumn = columns / 2; // 0, 0, 1, 1, 0, 0, 1, 1
                                                                                                                           // 0.03, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03
                float L1 = polls * (PollWidth + SEP_POLL); //Poll separation (is 0 for i in [0..3])                        // 0.00, 0.00, 0.00, 0.00, 0.49, 0.49, 0.49, 0.49
                float L2 = (subcolumn) * (SIZE_SUBCOL_1 + SEP_IN); //Answer or Result column begins                        // 0.00, 0.00, 0.35, 0.35, 0.00, 0.00, 0.35, 0.35
                float L3 = (columns % 2) * (subcolumn == 1 ? SIZE_SUBCOL_2 : SIZE_SUBCOL_1); //Answer or Result column end // 0.00, 0.34, 0.00, 0.10, 0.00, 0.34, 0.00, 0.10
                                                                                                                           // 0.03, 0.37, 0.38, 0.48, 0.53, 0.86, 0.87, 0.97
                pos_cols[i] = FormatFloat(MARGIN_LR + L1 + L2 + L3);                                                                                                 
                if (debug) { Puts($"pos_col[{i}] = {pos_cols[i]}, L1={L1}, L2={L2}, L3={L3}"); }
            }

            //Banner
            BannerAnchorMin = FormatFloat(BannerPositionX) + " " + FormatFloat(1.0f - (BannerPositionY + BannerSizeY));
            BannerAnchorMax = FormatFloat(BannerPositionX + BannerSizeX) + " " + FormatFloat(1.0f - BannerPositionY);
        }

        private void LoadVariables()
        {
            SteamIDIcon = Convert.ToUInt64(GetConfig("Settings", "SteamIDIcon", 76561198049668039));        // SteamID FOR PLUGIN ICON
            ClearDataOnWipe = Convert.ToBoolean(GetConfig("Settings", "Clear data on server wipe", false));
            VoteDurationMax = Convert.ToSingle(GetConfig("Settings", "Max duration of votes, (in seconds)", 0.0f));

            ChatMsgEnabled = Convert.ToBoolean(GetConfig("Chat Settings", "Chat announcement", true));
            Prefix = Convert.ToString(GetConfig("Chat Settings", "Prefix", "[TMV] :"));                     // CHAT PLUGIN PREFIX
            PrefixColor = Convert.ToString(GetConfig("Chat Settings", "PrefixColor", "#c12300"));           // CHAT PLUGIN PREFIX COLOR
            ChatColor = Convert.ToString(GetConfig("Chat Settings", "ChatColor", "#ffcd7c"));               // CHAT  COLOR

            BannerShowTimer = Convert.ToSingle(GetConfig("Banner Settings", "Vote Banner will display every (in seconds)", "10"));
            BannerHideTimer = Convert.ToSingle(GetConfig("Banner Settings", "Banner hide (in seconds)", "10"));
            BannerMsgEnabled = Convert.ToBoolean(GetConfig("Banner Settings", "Banner Enabled", true));
            BannerColor = Convert.ToString(GetConfig("Banner Settings", "Banner color", "0.5 1.0 0.5 0.5"));
            BannerPositionX = Convert.ToSingle(GetConfig("Banner Settings", "Banner position X", "0.2"));
            BannerPositionY = Convert.ToSingle(GetConfig("Banner Settings", "Banner position Y", "0.1"));
            BannerSizeX = Convert.ToSingle(GetConfig("Banner Settings", "Banner size X", "0.6"));
            BannerSizeY = Convert.ToSingle(GetConfig("Banner Settings", "Banner size Y", "0.05"));

            PanelTitle = Convert.ToString(GetConfig("Panel Settings", "Title", "Tell My Vote Panel"));
            PanelCommand = Convert.ToString(GetConfig("Panel Settings", "Command", "myvote"));


            for (int poll = 0; poll < polls.GetLength(0); poll++)
            {
                for (int answer = 0; answer < polls.GetLength(1); answer++)
                {
                    string dataValue = answer > 0 ? "Answer#" + answer : "Question";
                    string defaultValue = answer > 0 ? "set answer here" : "set your question here";
                    polls[poll, answer] = Convert.ToString(GetConfig("Poll #" + (poll + 1), dataValue, defaultValue));
                }
            }

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

        private void SetConfig(string menu, string datavalue, string value)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            if (data.ContainsKey(datavalue))
                data[datavalue] = value;
            SaveConfig();
        }

        #endregion

        void Loaded()
        {
            cmd.AddChatCommand(PanelCommand, this, "TellMyVotePanel");
            if (storedData.myVoteIsON)
            {
                PopUpVote("start");
            }
        }

        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject(DataFilename, storedData);
            if (tmvbanner != null) tmvbanner.Destroy();
        }

        #region MESSAGES

        protected override void LoadDefaultMessages()
        {

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoPermMsg", "You don't have admin permission."},
                {"AdminPermMsg", "You are allowed as admin. You can start/end/clear the votes."},
                {"QAlreadyMsg", "You already have voted for this Question"},
                {"VoteLogMsg", "Thank you, we recorded your vote for Question"},
                {"VoteBannerMsg", "To help our community : please vote with /{0} or click here"},
                {"VoteChatMsg", "To help our community : please vote with /{0}"},
                {"TMVoffMsg", "Vote session is now over."},
                {"PurgeMsg", "Counters has been reset"},
                {"Info01Msg", "Players with admin permission can start/end/clear votes from main panel"},
                {"Info02Msg", "Questions/Answers has to be set from TellMyVote.json config file or with chat command /myvote_poll."},
                {"Info03Msg", "IF A QUESTION IS SET EMPTY : it and its answers won't be displayed."},
                {"Info04Msg", "IF AN ANSWER IS SET EMPTY : its button won't be displayed."},
                {"HowToMsg", "Please use this format :\n/myvote_poll 1 0 here the words for the poll#1 title - check plugin webpage"},

            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoPermMsg", "Vous n'avez pas la permission."},
                {"AdminPermMsg", "Vous êtes admin. et avez accès aux commandes start/end/clear."},
                {"QAlreadyMsg", "Vous avez déjà voté à cette question."},
                {"VoteLogMsg", "Merci, nous avons enregistré votre choix."},
                {"VoteBannerMsg", "Pour aider la communauté : votez avec /{0} ou cliquez ici"},
                {"VoteChatMsg", "Pour aider la communauté : votez avec /{0} ou cliquez ici"},
                {"TMVoffMsg", "Le sondage est maintenant terminé."},
                {"PurgeMsg", "Les compteurs sont remis à zéro."},
                {"Info01Msg", "La permission .admin permet de lancer/stopper/purger depuis le panneau principal"},
                {"Info02Msg", "Les Questions/Réponses sont à définir depuis le fichier de config TellMyVote.json ou avec la commande chat /myvote_poll."},
                {"Info03Msg", "SI UNE QUESTION EST LAISSÉE VIDE : elle et ses questions ne seront pas affichées."},
                {"Info04Msg", "SI UNE REPONSE EST VIDE : son bouton ne s'affichera pas."},
                {"HowToMsg", "S'il vous plait utilisez ce format :\n/myvote_poll 1 0 taper ici le titre#1 - consultez la page du plugin"},

            }, this, "fr");
        }

        #endregion

        class StoredData
        {
            public List<ulong>[,] votes = new List<ulong>[4, 3] {
                {
                    new List<ulong>(),
                    new List<ulong>(),
                    new List<ulong>()
                },
                {
                    new List<ulong>(),
                    new List<ulong>(),
                    new List<ulong>()
                },
                {
                    new List<ulong>(),
                    new List<ulong>(),
                    new List<ulong>()
                },
                {
                    new List<ulong>(),
                    new List<ulong>(),
                    new List<ulong>()
                }
            };
            public bool myVoteIsON;

            public StoredData()
            {
            }
        }
        private StoredData storedData;

        #region CHAT SET Q/A

        [ChatCommand("myvote_poll")]
        private void TellMyVotePollSet(BasePlayer player, string command, string[] args)
        {
            bool isadmin = permission.UserHasPermission(player.UserIDString, TMVAdmin);
            string sentence = string.Empty;

            if (isadmin == false)
            {
                if (debug) { Puts($"-> NOT ADMIN access to set polls"); }
                Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("NoPermMsg", this, player.UserIDString)}</color>", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
            }
            else if (args.Length == 0)
            {
                Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("HowToMsg", this, player.UserIDString)}</color>", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                if (debug) { Puts($"-> SETTING POLLS with no arguments"); }
            }
            else if (args.Length == 1)
            {
                try
                {
                    int pollnum = int.Parse(args[0]);

                    if (pollnum >= 1 && pollnum <= 4)
                    {
                        polls[pollnum - 1, 0] = string.Empty;
                        SetConfig("Poll #" + pollnum, "Question", string.Empty);
                        Player.Message(player, $"Poll#{args[0]} has been set to empty", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                        if (debug) { Puts($"-> SETTING POLL {args[0]}, with no arguments"); }
                    }
                }
                catch (Exception e)
                {
                    Puts("TellMyVotePollSet: An error occured: " + e);
                }
            }
            else
            {
                sentence = string.Join(" ", args.Skip(2));
                try
                {
                    int pollnum = int.Parse(args[0]);
                    int parameter = int.Parse(args[1]);

                    if (pollnum >= 1 && pollnum <= 4 &&
                        parameter >= 0 && parameter <= 3)
                    {
                        string parameterName = "Question";

                        polls[pollnum - 1, parameter] = sentence;

                        if (parameter > 0) parameterName = "Answer#" + parameter;
                        SetConfig("Poll #" + pollnum, parameterName, sentence);
                        Player.Message(player, $"Poll#{pollnum} {parameterName} has been set to : {sentence}", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);

                    }
                }
                catch (Exception e)
                {
                    Puts("TellMyVotePollSet: An error occured: " + e);
                }
            }
        }

        void PlayerMessage(BasePlayer player, string poll, string answer, string sentence)
        {
            Player.Message(player, $"Poll#{poll}/Answer#{answer} has been set to : {sentence}", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
        }

        #endregion

        #region VOTING

        private bool VoteNeeded(ulong playerID, int pollNum)
        {
            if (polls[pollNum, 0].Length == 0) return false;
            for (int i = 0; i < storedData.votes.GetLength(1); i++)
            {
                if (storedData.votes[pollNum, i].Contains(playerID))
                    return false;
            }
            return true;
        }

        private bool VoteNeeded(ulong playerID)
        {
            bool playerVoteNeeded = false;

            for (int i = 0; i < storedData.votes.GetLength(0) && !playerVoteNeeded; i++)
            {
                playerVoteNeeded = VoteNeeded(playerID, i);
                if (debug) { Puts($"-> {playerID} Poll #{i} vote needed = {playerVoteNeeded}"); }
            }
            return playerVoteNeeded;
        }

        [ConsoleCommand("TellMyVote")]
        private void MySurveySpotOnly(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            ulong playerID = player.userID;
            int answernumber;

            try
            {
                answernumber = int.Parse(arg.Args.FirstOrDefault()) - 1;
                if (answernumber >= 0 && answernumber < 12)
                {
                    int pollnum = answernumber / 3;
                    int parameter = answernumber % 3;
                    if (storedData.myVoteIsON == false)
                    {
                        Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("TMVoffMsg", this, player.UserIDString)} </color>", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                    }
                    else
                    {

                        if (VoteNeeded(playerID, pollnum))
                        {
                            if (debug) { Puts($"-> answernumber = {answernumber + 1} - POLL #{pollnum + 1} vote recorded on {parameter + 1}"); }
                            storedData.votes[pollnum, parameter].Add(playerID);
                            Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("VoteLogMsg", this, player.UserIDString)} #{pollnum + 1}</color>", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                            RefreshMyVotePanel(player);
                        }
                        else
                        {
                            if (debug) { Puts($"-> answernumber = {answernumber + 1} - POLL #{pollnum + 1} - already voted"); }
                            Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("QAlreadyMsg", this, player.UserIDString)} #{pollnum + 1}</color>", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Puts("MySurveySpotOnly: An error occured: " + e);
            }
        }
        #endregion

        #region REFRESH VOTE PANEL

        private void RefreshMyVotePanel(BasePlayer player)
        {
            if (!VoteNeeded(player.userID))
            {
                CuiHelper.DestroyUi(player, "MyVoteBanner_" + player.UserIDString);
            }
            TellMyVotePanel(player, null, null);
        }
        #endregion

        #region CHANGE STATUS

        [ConsoleCommand("TellMyVoteChangeStatus")]
        private void TellMyVoteChangeStatus(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            ulong playerID = player.userID;
            if (arg.Args.Contains("start"))
            {
                if (debug) { Puts($"-> START OF MY VOTE"); }
                if (storedData.myVoteIsON)
                {
                    if (debug) { Puts($"-> START ASKED, BUT MY VOTE ALREADY ON."); }
                    return;
                }
                storedData.myVoteIsON = true;
                PopUpVote("start");
                RefreshMyVotePanel(player);
                if (VoteDurationMax > float.Epsilon)
                {
                    timer.Once(VoteDurationMax, () =>
                    {
                        arg.Args = new string[] { "end" };
                        TellMyVoteChangeStatus(arg);
                    });
                }
            }
            else if (arg.Args.Contains("end"))
            {
                if (debug) { Puts($"-> END OF MY VOTE SESSION"); }
                if (storedData.myVoteIsON == false)
                {
                    if (debug) { Puts($"-> END ASKED, BUT MY ALREADY OFF."); }
                    return;
                }
                storedData.myVoteIsON = false;
                RefreshMyVotePanel(player);
                PopUpVote("end");
            }
            else if (arg.Args.Contains("purge"))
            {
                if (debug) { Puts($"-> PURGE OF DATAS"); }
                Purge();
                RefreshMyVotePanel(player);
                Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("PurgeMsg", this, player.UserIDString)}</color>", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
            }
            else if (arg.Args.Contains("info"))
            {
                if (debug) { Puts($"-> DISPLAY INFO PANEL"); }
                CuiHelper.DestroyUi(player, MyVotePanel);
                TellMyVoteInfoPanel(player);
            }
            else if (arg.Args.Contains("back"))
            {
                if (debug) { Puts($"-> BACK TO MAIN MY VOTE PANEL"); }
                CuiHelper.DestroyUi(player, MyVoteInfoPanel);
                TellMyVotePanel(player, null, null);
            }
        }
        #endregion

        private void Purge()
        {
            foreach (var polls in storedData.votes)
            {
                polls.Clear();
            }
        }

        #region POPUP BANNER

        private void PopUpPlayer(BasePlayer player, string state)
        {
            string bannertxt = string.Empty;
            string chattxt = string.Empty;

            if (VoteNeeded(player.userID) || state == "end")
            {
                if (state == "start")
                {
                    bannertxt = $"{string.Format(lang.GetMessage("VoteBannerMsg", this, player.UserIDString), PanelCommand)}";
                    chattxt = $"{string.Format(lang.GetMessage("VoteChatMsg", this, player.UserIDString), PanelCommand)}";
                }
                else if (state == "end")
                {
                    bannertxt = chattxt = $"{lang.GetMessage("TMVoffMsg", this, player.UserIDString)}";
                }

                if (ChatMsgEnabled)
                {
                    Player.Message(player, $"<color={ChatColor}>{chattxt}</color>", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                }
                if (BannerMsgEnabled)
                {
                    CuiHelper.DestroyUi(player, "MyVoteBanner_" + player.UserIDString);
                    CuiElementContainer CuiElement = new CuiElementContainer();
                    var MyVoteBanner = CuiElement.Add(new CuiPanel { Image = { Color = BannerColor }, RectTransform = { AnchorMin = BannerAnchorMin, AnchorMax = BannerAnchorMax }, CursorEnabled = false }, "Hud", "MyVoteBanner_" + player.UserIDString);
                    var closeButton = new CuiButton { Button = { Close = MyVoteBanner, Color = "0.0 0.0 0.0 0.6" }, RectTransform = { AnchorMin = "0.90 0.01", AnchorMax = "0.99 0.99" }, Text = { Text = "X", FontSize = 18, Align = TextAnchor.MiddleCenter } };
                    CuiElement.Add(closeButton, MyVoteBanner);
                    CuiElement.Add(new CuiButton
                    {
                        Button = { Command = $"chat.say /{PanelCommand}", Color = "0.0 0.0 0.0 0.0" },
                        Text = { Text = $"{bannertxt}", FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "0.0 0.0 0.0 1" },
                        RectTransform = { AnchorMin = "0.10 0.10", AnchorMax = "0.90 0.90" }
                    }, MyVoteBanner);
                    CuiHelper.AddUi(player, CuiElement);
                    timer.Once(state == "start" ? BannerHideTimer : BannerHideTimer / 3f, () =>
                    {
                        CuiHelper.DestroyUi(player, MyVoteBanner);
                    });
                }
            }
        }

        private void PopUpVote(string newstate)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList.Where(pl => pl.IsConnected))
            {
                PopUpPlayer(player, newstate);
            }
            if (newstate == "start")
            {
                if (tmvbanner == null)
                {
                    tmvbanner = timer.Every(BannerShowTimer, () =>
                    {
                        PopUpVote("start");
                    });
                }
            }
            else
            {
                if (tmvbanner != null)
                {
                    tmvbanner.Destroy();
                    tmvbanner = null;
                }
            }
        }

        #endregion

        #region INFOPANEL

        private void TellMyVoteInfoPanel(BasePlayer player)
        {
            const string PanelColor = "0.0 0.0 0.0 0.8";
            const string buttonCloseColor = "0.6 0.26 0.2 1";
            string information = $"{lang.GetMessage("Info01Msg", this, player.UserIDString)}\n\n{lang.GetMessage("Info02Msg", this, player.UserIDString)}\n\n\n\n{lang.GetMessage("Info03Msg", this, player.UserIDString)}\n\n{lang.GetMessage("Info04Msg", this, player.UserIDString)}";
            bool isadmin = permission.UserHasPermission(player.UserIDString, TMVAdmin);
            if (isadmin)
            {
                if (debug) { Puts($"-> ADMIN access to info panel"); }
                Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("AdminPermMsg", this, player.UserIDString)}</color>", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
            }
            else
            {
                if (debug) { Puts($"-> NOT ADMIN access to info panel"); }
                Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("NoPermMsg", this, player.UserIDString)}</color>", $"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
            }
            CuiHelper.DestroyUi(player, "MyVoteInfoPanel_" + player.UserIDString);
            var CuiElement = new CuiElementContainer();
            MyVoteInfoPanel = CuiElement.Add(new CuiPanel { Image = { Color = $"{PanelColor}" }, RectTransform = { AnchorMin = "0.25 0.25", AnchorMax = "0.75 0.80" }, CursorEnabled = true }, "Hud", "MyVoteInfoPanel_" + player.UserIDString);
            var closeButton = new CuiButton { Button = { Close = MyVoteInfoPanel, Color = $"{buttonCloseColor}" }, RectTransform = { AnchorMin = "0.85 0.85", AnchorMax = "0.95 0.95" }, Text = { Text = "[X]\nClose", FontSize = 16, Align = TextAnchor.MiddleCenter } };
            CuiElement.Add(closeButton, MyVoteInfoPanel);
            var BackButton = CuiElement.Add(new CuiButton
            {
                Button = { Command = "TellMyVoteChangeStatus back", Color = $"0.0 0.5 1.0 0.5" },
                RectTransform = { AnchorMin = $"0.78 0.85", AnchorMax = $"0.83 0.95" },
                Text = { Text = "BACK", Color = "1.0 1.0 1.0 0.8", FontSize = 10, Align = TextAnchor.MiddleCenter }
            }, MyVoteInfoPanel);
            var TextIntro = CuiElement.Add(new CuiLabel
            {
                Text = { Color = "1.0 1.0 1.0 1.0", Text = PanelTitle, FontSize = 22, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.30 0.87", AnchorMax = "0.70 0.95" }
            }, MyVoteInfoPanel);
            var ButtonAnswer1 = CuiElement.Add(new CuiButton
            {
                Button = { Command = string.Empty, Color = $"0.5 1.0 0.5 0.5" },
                RectTransform = { AnchorMin = $"0.05 0.05", AnchorMax = $"0.95 0.70" },
                Text = { Text = $"{information}", Color = "0.0 0.0 0.0 1", FontSize = 14, Align = TextAnchor.MiddleCenter }
            }, MyVoteInfoPanel);
            CuiHelper.AddUi(player, CuiElement);
        }
        #endregion

        #region TELLMYVOTE PANEL START

        private void TellMyVotePanel(BasePlayer player, string command, string[] args)
        {
            string StatusColor = string.Empty;
            string Status = string.Empty;
            bool isadmin = permission.UserHasPermission(player.UserIDString, TMVAdmin);
            if (storedData.myVoteIsON)
            {
                Status = "SESSION IS OPEN : CHOOSE YOUR ANSWERS !";
                StatusColor = "0.2 1.0 0.2 0.8";
            }
            if (storedData.myVoteIsON == false)
            {
                Status = "SESSION HAS ENDED.";
                StatusColor = "1.0 0.1 0.1 0.8";
            }

            #endregion

            #region PANEL AND CLOSE BUTTON

            var CuiElement = new CuiElementContainer();
            CuiHelper.DestroyUi(player, "MyVotePanel_" + player.UserIDString);
            MyVotePanel = CuiElement.Add(new CuiPanel
            {
                Image = { Color = $"{PanelColor}" },
                RectTransform = { AnchorMin = "0.25 0.25", AnchorMax = "0.75 0.80" },
                CursorEnabled = true
            }, "Hud", "MyVotePanel_" + player.UserIDString);
            CuiElement.Add(new CuiButton
            {
                Button = { Close = MyVotePanel, Color = $"{buttonCloseColor}" },
                RectTransform = { AnchorMin = "0.85 0.85", AnchorMax = "0.95 0.95" },
                Text = { Text = "[X]\nClose", FontSize = 16, Align = TextAnchor.MiddleCenter }
            }, MyVotePanel);
            CuiElement.Add(new CuiButton
            {
                Button = { Command = "TellMyVoteChangeStatus info", Color = $"{HelpButtonColor}" },
                RectTransform = { AnchorMin = $"0.78 0.85", AnchorMax = $"0.83 0.95" },
                Text = { Text = "?", Color = $"{HelpButtonTxt}", FontSize = 18, Align = TextAnchor.MiddleCenter }
            }, MyVotePanel);
            CuiElement.Add(new CuiLabel
            {
                Text = { Color = "1.0 1.0 1.0 1.0", Text = $"<i>version {Version}</i>", FontSize = 11, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.78 0.78", AnchorMax = "0.95 0.84" }
            }, MyVotePanel);
            CuiElement.Add(new CuiLabel
            {
                Text = { Color = "1.0 1.0 1.0 1.0", Text = PanelTitle, FontSize = 22, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.30 0.87", AnchorMax = "0.70 0.95" }
            }, MyVotePanel);
            CuiElement.Add(new CuiLabel
            {
                Text = { Color = $"{StatusColor}", Text = $"{Status}", FontSize = 16, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.23 0.78", AnchorMax = "0.77 0.86" }
            }, MyVotePanel);
            if (isadmin)
            {
                CuiElement.Add(new CuiButton
                {
                    Button = { Command = "TellMyVoteChangeStatus start", Color = "0.2 0.6 0.2 0.8" },
                    RectTransform = { AnchorMin = $"0.05 0.85", AnchorMax = $"0.15 0.95" },
                    Text = { Text = "START", Color = "1.0 1.0 1.0 1.0", FontSize = 10, Align = TextAnchor.MiddleCenter }
                }, MyVotePanel);
                CuiElement.Add(new CuiButton
                {
                    Button = { Command = "TellMyVoteChangeStatus end", Color = "1.0 0.2 0.2 0.8" },
                    RectTransform = { AnchorMin = $"0.16 0.85", AnchorMax = $"0.22 0.95" },
                    Text = { Text = "END", Color = "1.0 1.0 1.0 1.0", FontSize = 10, Align = TextAnchor.MiddleCenter }
                }, MyVotePanel);
                CuiElement.Add(new CuiButton
                {
                    Button = { Command = "TellMyVoteChangeStatus purge", Color = "1.0 0.5 0.0 0.8" },
                    RectTransform = { AnchorMin = $"0.05 0.78", AnchorMax = $"0.22 0.84" },
                    Text = { Text = "RESET COUNTERS", Color = "1.0 1.0 1.0 1.0", FontSize = 10, Align = TextAnchor.MiddleCenter }
                }, MyVotePanel);
            }

            #endregion

            #region POLLS DRAWING
            for (int y = 0; y < polls.GetLength(0); y++)
            {
                if (polls[y, 0].Length > 0)
                {
                    int midY = y / 2; // 0, 0, 1, 1
                    int YpollIndex = midY * 4; // 0, 0, 4, 4
                    int XpollIndex = (y % 2) * 8; // 0, 8, 0, 8
                    string column1Begin = pos_cols[YpollIndex];
                    string column1End = pos_cols[YpollIndex + 1];
                    string column2Begin = pos_cols[YpollIndex + 2];
                    string column2End = pos_cols[YpollIndex + 3];
                    string row1Begin = pos_rows[XpollIndex + 1];
                    string row1End = pos_rows[XpollIndex];
                    CuiElement.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = $"{column1Begin} {row1Begin}", AnchorMax = $"{column2End} {row1End}" },
                        Text = { Text = $"#{y + 1}. {polls[y, 0]}", Color = $"{QuestionColor}", FontSize = 16, Align = TextAnchor.MiddleLeft }
                    }, MyVotePanel);

                    for (int x = 1; x < polls.GetLength(1); x++)
                    {
                        if (polls[y, x].Length > 0)
                        {
                            int xRowIndex = XpollIndex + x * 2;
                            string rowBegin = pos_rows[xRowIndex + 1];
                            string rowEnd = pos_rows[xRowIndex];
                            CuiElement.Add(new CuiButton
                            {
                                Button = { Command = $"TellMyVote {y * 3 + x}", Color = $"{AnswerColor}" },
                                RectTransform = { AnchorMin = $"{column1Begin} {rowBegin}", AnchorMax = $"{column1End} {rowEnd}" },
                                Text = { Text = $"{polls[y, x]}", Color = "0.0 0.0 0.0 1", FontSize = 14, Align = TextAnchor.MiddleCenter }
                            }, MyVotePanel);

                            CuiElement.Add(new CuiButton
                            {
                                Button = { Command = string.Empty, Color = $"{CountColor}" },
                                RectTransform = { AnchorMin = $"{column2Begin} {rowBegin}", AnchorMax = $"{column2End} {rowEnd}" },
                                Text = { Text = $"{storedData.votes[y, x - 1].Count}", Color = "0.0 0.0 0.0 1", FontSize = 14, Align = TextAnchor.MiddleCenter }
                            }, MyVotePanel);
                        }
                    }

                }
            }
            CuiHelper.AddUi(player, CuiElement);
        }
        #endregion

        #region UTILS

        private string FormatFloat(float f) => f.ToString("F", CultureInfo.InvariantCulture);

        #endregion
    }
}


// --- End of file: TellMyVote.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/troll-system ---
// --- Original File Path: T/TrollSystem/TrollSystem.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Troll System", "Grave", "0.6.0")]
    [Description("A easier way to troll someone in Rust! The commands available are banning and muting, /tmute, /tunmute, /tban, /tunban, and they all annouce in the chat. Example: /tmute Bill - Announces Grave muted Bill, as I sent the command. This works with unmuting and banning/unbanning.")]
    class TrollSystem : CovalencePlugin
    {
        private void Init()
        {
            permission.RegisterPermission("trollsystem.ban", this);
            permission.RegisterPermission("trollsystem.unban", this);
            permission.RegisterPermission("trollsystem.mute", this);
            permission.RegisterPermission("trollsystem.unmute", this);
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BanMessage"] = "{Banner} banned {Bannedname}",
                ["UnBanMessage"] = "{UnBanner} unbanned {Bannedname}",
                ["MuteMessage"] = "{Muter} muted {Mutedname}",
                ["UnMuteMessage"] = "{UnMuter} unmuted {Mutedname}"
            }, this);
        }
       

        [Command("tban"),Permission("trollsystem.ban")]
        private void Cmdtban(IPlayer player, string command, string[] args)
        {
            server.Broadcast($"{player.Name} banned {string.Join(" ", args)}");
            string message = lang.GetMessage("BanMessage", this, player.Id)
     .Replace("{Banner}", player.Name)
     .Replace("{Bannedname}", string.Join(" ", args));
            Puts(message);
        }

        [Command("tunban"),Permission("trollsystem.unban")]
        private void Cmdtunban(IPlayer player, string command, string[] args)
        {
            server.Broadcast($"{player.Name} unbanned {string.Join(" ", args)}");
            string message = lang.GetMessage("UnBanMessage", this, player.Id)
     .Replace("{UnBanner}", player.Name)
     .Replace("{Bannedname}", string.Join(" ", args));
            Puts(message);
        }

        [Command("tmute"),Permission("trollsystem.mute")]
        private void Cmdtmute(IPlayer player, string command, string[] args)
        {
            server.Broadcast($"{player.Name} muted {string.Join(" ", args)}");
            string message = lang.GetMessage("MuteMessage", this, player.Id)
                .Replace("{Muter}", player.Name)
                .Replace("{Mutedname}", string.Join(" ", args));
            Puts(message);

        }
        [Command("tunmute"), Permission("trollsystem.unmute")]
        private void Cmdtunmute(IPlayer player, string command, string[] args)
        {
            server.Broadcast($"{player.Name} unmuted {string.Join(" ", args)}");
            string message = lang.GetMessage("UnMuteMessage", this, player.Id)
                .Replace("{UnMuter}", player.Name)
                .Replace("{Mutedname}", string.Join(" ", args));
            Puts(message);

        }

    }
}


// --- End of file: TrollSystem.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/terrain-blocker ---
// --- Original File Path: T/TerrainBlocker/TerrainBlocker.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Terrain Blocker", "Slut", "2.0.0")]
    class TerrainBlocker : RustPlugin
    {
        Configuration config;
        public class Configuration
        {
            [JsonProperty("Blocked Colliders")]
            public string[] BlockedColliders { get; set; }
            [JsonProperty("Blacklist/Whitelist")]
            public Blacklist blacklist;
            public class Blacklist
            {
                [JsonProperty("Prefabs (Leave empty to ignore)")]
                public string[] Prefabs { get; set; }
                [JsonProperty("Blacklist = True | Whitelist = False")]
                public bool _Blacklist { get; set; }
            }
            public static Configuration LoadDefaults()
            {
                return new Configuration
                {
                    BlockedColliders = new string[]
                    {
                        "iceberg",
                        "ice_berg",
                        "ice_sheet",
                        "icesheet",
                    },
                    blacklist = new Blacklist
                    {
                        Prefabs = new string[]
                        {
                            "prefab.fullname"
                        },
                        _Blacklist = true
                    }
                };
            }
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new configuration!");
            config = Configuration.LoadDefaults();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<Configuration>();
        }
        protected override void SaveConfig() => Config.WriteObject(config);

        private void Loaded()
        {
            permission.RegisterPermission(adminPermission, this);
        }
        const string adminPermission = "icebergblocker.admin";

        private object CanBuild(Planner plan, Construction prefab)
        {
            var player = plan.GetOwnerPlayer();
            Vector3 pos = plan.transform.position;
            if (player != null && !permission.UserHasPermission(player.UserIDString, adminPermission))
            {
                List<Collider> list = new List<Collider>();
                Vis.Colliders(pos, 5f, list);
                if (list.Any(x => config.BlockedColliders.Any(x.name.StartsWith)))
                {
                    if (config.blacklist.Prefabs.Length > 0)
                    {
                        bool contains = config.blacklist.Prefabs.Contains(prefab.fullName);
                        if ((config.blacklist._Blacklist && !contains) || (!config.blacklist._Blacklist && contains))
                        {
                            return null;
                        }
                    }
                    return false;
                }
            }
            return null;
        }
    }
}


// --- End of file: TerrainBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/third-person ---
// --- Original File Path: T/ThirdPerson/ThirdPerson.cs ---

﻿using System;

namespace Oxide.Plugins
{
    [Info("ThirdPerson", "Wulf,Rick", "0.1.5", ResourceId = 1424)]
    [Description("Allows any player with permission to use third-person view.")]

    class ThirdPerson : RustPlugin
    {
        // Do NOT edit this file, instead edit ThirdPerson.json in server/<identity>/oxide/config

        #region Configuration

        string ChatCommand => GetConfig("ChatCommand", "view");
        string NoPermission => GetConfig("NoPermission", "Sorry, you can't use 'view' right now");

        protected override void LoadDefaultConfig()
        {
            Config["ChatCommand"] = ChatCommand;
            Config["NoPermission"] = NoPermission;

            SaveConfig();
        }

        #endregion

        #region General Setup

        void Loaded()
        {
            LoadDefaultConfig();

            permission.RegisterPermission("thirdperson.allowed", this);
            cmd.AddChatCommand(ChatCommand, this, "ViewChatCmd");
        }

        #endregion

        void OnPlayerConnected(BasePlayer player)
        {
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
        }

        #region Chat Command

        void ViewChatCmd(BasePlayer player)
        {
            if (!HasPermission(player, "thirdperson.allowed"))
            {
                SendReply(player, NoPermission);
                return;
            }

            player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, !player.HasPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode));
        }

        #endregion

        #region Helper Methods

        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        #endregion
    }
}

// --- End of file: ThirdPerson.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/translation-api ---
// --- Original File Path: T/TranslationAPI/TranslationAPI.cs ---

//#define DEBUG

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries;

namespace Oxide.Plugins
{
    [Info("Translation API", "Wulf", "2.0.0")]
    [Description("Plugin API for translating messages using free or paid translation services")]
    public class TranslationAPI : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        private class Configuration
        {
            [JsonProperty("API key (if required)")]
            public string ApiKey = string.Empty;

            [JsonProperty("Translation service")]
            public string Service = "google";

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Initialization

        private static readonly Regex GoogleRegex = new Regex(@"\[\[\[""((?:\s|.)+?)"",""(?:\s|.)+?""");
        private static readonly Regex MicrosoftRegex = new Regex("\"(.*)\"");

        private void Init()
        {
            if (string.IsNullOrEmpty(config.ApiKey) && config.Service.ToLower() != "google")
            {
                LogWarning("Invalid API key, please check that it is set and valid");
            }
        }

        #endregion Initialization

        #region Translation API

        private string lastOutput;

        /// <summary>
        /// Translates text from one language to another language
        /// </summary>
        /// <param name="text"></param>
        /// <param name="to"></param>
        /// <param name="from"></param>
        /// <param name="callback"></param>
        private void Translate(string text, string to, string from = "auto", Action<string> callback = null)
        {
            string apiKey = config.ApiKey;
            string service = config.Service.ToLower();
            to = to.Contains("-") ? to.Split('-')[0].ToLower() : to.ToLower();
            from = from.Contains("-") ? from.Split('-')[0].ToLower() : from.ToLower();

            if (string.IsNullOrEmpty(config.ApiKey) && service != "google")
            {
                LogOutput("Invalid API key, please check that it is set and valid");
                return;
            }

            switch (service)
            {
                case "google":
                    {
                        // Reference: https://cloud.google.com/translate/docs/basic/quickstart

                        string url = string.IsNullOrEmpty(apiKey)
                            ? $"https://translate.googleapis.com/translate_a/single?client=gtx&tl={to}&sl={from}&dt=t&q={Uri.EscapeUriString(text)}"
                            : $"https://www.googleapis.com/language/translate/v2?key={apiKey}&target={to}&source={from}&q={Uri.EscapeUriString(text)}";

                        // TODO: Update to support newer Google Translate API
                        // https://translation.googleapis.com/language/translate/v2
                        // -H "Authorization: Bearer "$(gcloud auth application-default print-access-token)
                        // -H "Content-Type: application/json; charset=utf-8"
                        /*
                        {
                          "data": {
                          "translations": [{
                            "translatedText": "text here"
                          }]
                          }
                        }
                        */

                        webrequest.Enqueue(url, null, (code, response) => // TODO: {} for POST necessary?
                        {
                            if (code != 200 || string.IsNullOrEmpty(response) || response.Equals("[null,null,\"\"]"))
                            {
                                LogOutput($"No valid response received from {service.Titleize()}, try again later");
                                callback?.Invoke(text);
                                return;
                            }

                            Callback(code, response, text, callback);
                        }, this);
                        break;
                    }

                case "bing":
                case "microsoft":
                    {
                        // Reference: https://www.microsoft.com/en-us/translator/getstarted.aspx
                        // Supported language codes: https://msdn.microsoft.com/en-us/library/hh456380.aspx
                        // TODO: Implement the new access token method for Bing/Microsoft

                        webrequest.Enqueue($"http://api.microsofttranslator.com/V2/Ajax.svc/Detect?appId={apiKey}&text={Uri.EscapeUriString(text)}", null, (c, r) =>
                        {
                            if (string.IsNullOrEmpty(r) || r.Contains("<html>"))
                            {
                                LogOutput($"No valid response received from {service.Titleize()}, try again later");
                                callback?.Invoke(text);
                                return;
                            }

                            if (r.Contains("ArgumentException: Invalid appId"))
                            {
                                LogOutput("Invalid API key, please check that it is valid and try again");
                                callback?.Invoke(text);
                                return;
                            }

                            if (r.Contains("ArgumentOutOfRangeException: 'to' must be a valid language"))
                            {
                                LogOutput($"Invalid language code, please check that it is valid and try again (to: {to}, from: {from})");
                                callback?.Invoke(text);
                                return;
                            }

                            string url = $"http://api.microsofttranslator.com/V2/Ajax.svc/Translate?appId={apiKey}&to={to}&from={r}&text={Uri.EscapeUriString(text)}";
                            webrequest.Enqueue(url, null, (code, response) =>
                            {
                                if (string.IsNullOrEmpty(response) || response.Contains("<html>"))
                                {
                                    LogOutput($"No valid response received from {service.Humanize()}, try again later");
                                    callback?.Invoke(text);
                                    return;
                                }

                                if (response.Contains("ArgumentOutOfRangeException: 'from' must be a valid language"))
                                {
                                    LogOutput($"Invalid language code, please check that it is valid and try again (to: {to}, from: {from})");
                                    callback?.Invoke(text);
                                    return;
                                }

                                Callback(code, response, text, callback);
                            }, this);
                        }, this, RequestMethod.POST);
                        break;
                    }

                case "yandex":
                    {
                        // Reference (old): https://tech.yandex.com/keys/get/?service=trnsl
                        // Reference (new): https://cloud.yandex.com/docs/translate/operations/translate

                        webrequest.Enqueue($"https://translate.yandex.net/api/v1.5/tr.json/detect?key={apiKey}&hint={from}&text={Uri.EscapeUriString(text)}", null, (c, r) =>
                        {
                            if (string.IsNullOrEmpty(r))
                            {
                                LogOutput($"No valid response received from {service.Humanize()}, try again later");
                                callback?.Invoke(text);
                                return;
                            }

                            if (c == 502 || r.Contains("Invalid parameter: hint"))
                            {
                                LogOutput($"Invalid language code, please check that it is valid and try again (to: {to}, from: {from})");
                                callback?.Invoke(text);
                                return;
                            }

                            from = (string)JObject.Parse(r).GetValue("lang");
                            string url = $"https://translate.yandex.net/api/v1.5/tr.json/translate?key={apiKey}&lang={from}-{to}&text={Uri.EscapeUriString(text)}";
                            webrequest.Enqueue(url, null, (code, response) =>
                            {
                                if (string.IsNullOrEmpty(response))
                                {
                                    LogOutput($"No valid response received from {service.Humanize()}, try again later");
                                    callback?.Invoke(text);
                                    return;
                                }

                                if (c == 501 || c == 502 || response.Contains("The specified translation direction is not supported") || r.Contains("Invalid parameter: lang"))
                                {
                                    LogOutput($"Invalid language code, please check that it is valid and try again (to: {to}, from: {from})");
                                    callback?.Invoke(text);
                                    return;
                                }

                                Callback(code, response, text, callback);
                            }, this, RequestMethod.POST);
                        }, this);
                        break;
                    }

                default:
                    LogOutput($"Translation service '{service}' is not a valid setting");
                    break;
            }
        }

        private void Callback(int code, string response, string text, Action<string> callback = null)
        {
            if (code != 200 || string.IsNullOrEmpty(response))
            {
                LogOutput($"Translation failed! {config.Service.Titleize()} responded with: {response} ({code})");
                return;
            }

            string translated = null;
            string service = config.Service.ToLower();

            if (service == "google" && string.IsNullOrEmpty(config.ApiKey))
            {
                translated = GoogleRegex.Match(response).Groups[1].ToString();
            }
            else if (service == "google" && !string.IsNullOrEmpty(config.ApiKey))
            {
                translated = (string)JObject.Parse(response)["data"]["translations"]["translatedText"];
            }
            else if (service == "microsoft" || service.ToLower() == "bing")
            {
                translated = MicrosoftRegex.Match(response).Groups[1].ToString();
            }
            else if (service == "yandex")
            {
                translated = (string)JObject.Parse(response).GetValue("text").First;
            }
#if DEBUG
            LogWarning($"Using {service.Titleize()} to translate");
            LogWarning("----------------------------------------");
            LogWarning($"Original: {text}");
            LogWarning($"Translated: {translated}");
            LogWarning("----------------------------------------");
            if (translated == text)
            {
                LogWarning("Translated text is the same as original text");
            }
#endif
            callback?.Invoke(string.IsNullOrEmpty(translated) ? text : Regex.Unescape(translated));
        }

        private void LogOutput(string text)
        {
            if (text != lastOutput)
            {
                LogWarning(text);
                lastOutput = text;
            }
        }

        #endregion Translation API
    }
}


// --- End of file: TranslationAPI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tool-blocker ---
// --- Original File Path: T/ToolBlocker/ToolBlocker.cs ---

﻿using System.Collections.Generic;

namespace Oxide.Plugins
{
	[Info("Tool Blocker", "NubbbZ", "1.0.0")]
	[Description("Blocks the use of certain tools on gather of flesh, trees, ore")]
	class ToolBlocker : CovalencePlugin
	{
		#region Variables
		List<object> FleshBlockedTools;
		List<object> TreeBlockedTools;
		List<object> NodeBlockedTools;

		private const string bypass = "toolblocker.bypass";
		#endregion

		#region Configuration
		protected override void LoadDefaultConfig()
		{
			LogWarning("Creating a new configuration file");

			Config["corpses"] = new List<string>() {
			"knife.bone",
			"knife.combat"
			};
			Config["trees"] = new List<string>() {
			"stonehatchet",
			"hatchet",
			"axe.salvaged"
			};
			Config["nodes"] = new List<string>() {
			"stone.pickaxe",
			"pickaxe",
			"icepick.salvaged"
			};
		}
		#endregion

		#region Localization
		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["Blocked"] = "You are not allowed to use a {0} to gather {1}!"
			}, this);
		}
		#endregion

		#region Hook
		private void Init()
		{
			permission.RegisterPermission(bypass, this);
		}
		object OnMeleeAttack(BasePlayer player, HitInfo info)
		{
			FleshBlockedTools = (List<object>)Config["corpses"];
			TreeBlockedTools = (List<object>)Config["trees"];
			NodeBlockedTools = (List<object>)Config["nodes"];
			string tool = player.GetHeldEntity().GetItem().info.displayName.english;

			if (player.IPlayer.HasPermission(bypass) == false)
			{
				if (info.HitEntity != null)
				{
					if (info.HitEntity.HasTrait(BaseEntity.TraitFlag.Alive) == false)
					{
						if (info.HitEntity.GetType().FullName == "BaseCorpse")
						{
							if (FleshBlockedTools.Contains(player.GetHeldEntity().GetItem().info.shortname))
							{
								player.IPlayer.Reply(string.Format(lang.GetMessage("Blocked", this, player.IPlayer.Id), tool, "Corpses"));
								return true;
							}
						}
						if (info.HitEntity.GetType().FullName == "TreeEntity")
						{
							string Gather = info.HitEntity.GetComponent<ResourceDispenser>().gatherType.ToString();
							if (TreeBlockedTools.Contains(player.GetHeldEntity().GetItem().info.shortname))
							{
								player.IPlayer.Reply(string.Format(lang.GetMessage("Blocked", this, player.IPlayer.Id), tool, Gather));
								return true;
							}
						}
						if (info.HitEntity.GetType().FullName == "OreResourceEntity")
						{
							string Gather = info.HitEntity.GetComponent<ResourceDispenser>().gatherType.ToString();
							if (NodeBlockedTools.Contains(player.GetHeldEntity().GetItem().info.shortname))
							{
								player.IPlayer.Reply(string.Format(lang.GetMessage("Blocked", this, player.IPlayer.Id), tool, Gather));
								return true;
							}
						}
					}
				}
			}
			return null;
		}
		#endregion
	}
}

// --- End of file: ToolBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/turret-lock ---
// --- Original File Path: T/TurretLock/TurretLock.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Turret Lock", "redBDGR", "1.0.2")]
    [Description("Gives players the ability to lock their turrets")]
    class TurretLock : RustPlugin
    {
        private bool Changed;
        private const string codeLockPrefab = "assets/prefabs/locks/keypad/lock.code.prefab";
        private const string effectDenied = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";
        private const string effectDeployed = "assets/prefabs/locks/keypad/effects/lock-code-deploy.prefab";
        private const string permissionName = "turretlock.use";

        private bool doEffects;

        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permissionName, this);
            LoadVariables();

            lang.RegisterMessages(new Dictionary<string, string>
            {
                //chat
                ["No Permission"] = "You are not allowed to use this command",
                ["Not Allowed"] = "You are not allowed to do this because you must be authorised to the turrets codelock",
                ["Not Enough Items"] = "You need a codelock in your inventory to lock this turret",
                ["Already Has Codelock"] = "This turret already has a codelock",
                ["Not A Turret"] = "This entity is not a turret",
            }, this);
        }

        private void LoadVariables()
        {
            doEffects = Convert.ToBoolean(GetConfig("Settings", "Do Effects", true));

            if (!Changed) return;

            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
        {
            return CheckTurretNoSphereCast(turret, player);
        }

        private object OnTurretDeauthorize(AutoTurret turret, BasePlayer player)
        {
            return CheckTurretNoSphereCast(turret, player);
        }

        private object OnTurretShutdown(AutoTurret turret)
        {
            return CheckTurret(turret);
        }

        private object OnTurretStartup(AutoTurret turret)
        {
            return CheckTurret(turret);
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (!entity.GetComponent<AutoTurret>())
                return;

            if (CheckTurretNoSphereCast(entity.GetComponent<AutoTurret>(), player) == null)
                return;

            NextTick(player.EndLooting);
        }

        private void OnTurretModeToggle(AutoTurret turret)
        {
            if (CheckTurret(turret) == null)
                return;

            turret.SetPeacekeepermode(!turret.PeacekeeperMode());
        }

        private object OnTurretClearList(AutoTurret turret, BasePlayer player)
        {
            if (CheckTurretNoSphereCast(turret, player) == null)
                return null;

            return true;
        }

        #endregion

        #region Chat Commands

        [ChatCommand("lockturret")]
        private void LockTurretCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
            {
                player.ChatMessage(msg("No Permission", player.UserIDString));
                return;
            }

            RaycastHit hit;
            if (!UnityEngine.Physics.Raycast(player.eyes.HeadRay(), out hit, 5f))
                return;

            BaseEntity turretEntity = hit.GetEntity();
            if (turretEntity is AutoTurret)
            {
                if (turretEntity.GetComponentInChildren<CodeLock>())
                {
                    player.ChatMessage(msg("Already Has Codelock", player.UserIDString));
                    return;
                }

                Item codelockItem = InventoryContainsCodelock(player);
                if (codelockItem != null)
                {
                    AddCodelock(hit.GetEntity().GetComponent<AutoTurret>());
                    RemoveThink(codelockItem);
                }
                else
                {
                    player.ChatMessage(msg("Not Enough Items", player.UserIDString));
                }
            }
            else
            {
                player.ChatMessage(msg("Not A Turret", player.UserIDString));
                return;
            }
        }

        #endregion

        #region Methods / Helpers

        private void AddCodelock(AutoTurret turret)
        {
            BaseEntity ent = GameManager.server.CreateEntity(codeLockPrefab, turret.transform.position);
            if (!ent)
                return;

            ent.Spawn();
            ent.SetParent(turret);
            ent.transform.localEulerAngles = new Vector3(0, 160, 0);
            ent.transform.localPosition = new Vector3(0.27f, 0.37f, 0.1f);
            //CodeLock _lock = ent.GetComponent<CodeLock>();
            ent.SendNetworkUpdateImmediate();
            if (doEffects)
                Effect.server.Run(effectDeployed, ent.transform.position);
        }

        private static BasePlayer FindBasePlayer(Vector3 pos)
        {
            RaycastHit[] hits = UnityEngine.Physics.SphereCastAll(pos, 4f, Vector3.up);
            return (from hit in hits where hit.GetEntity()?.GetComponent<BasePlayer>() select hit.GetEntity()?.GetComponent<BasePlayer>()).FirstOrDefault();
        }

        private object CheckTurretNoSphereCast(AutoTurret turret, BasePlayer player)
        {
            CodeLock _lock = turret.GetComponentInChildren<CodeLock>();
            if (!_lock) return null;

            if (_lock.code == string.Empty)
                return null;

            if (_lock.whitelistPlayers.Contains(player.userID))
                return null;

            player.ChatMessage(msg("Not Allowed", player.UserIDString));
            if (doEffects)
                Effect.server.Run(effectDenied, _lock.transform.position);
            return true;
        }

        private object CheckTurret(AutoTurret turret)
        {
            CodeLock _lock = turret.GetComponentInChildren<CodeLock>();
            if (!_lock)
                return null;

            BasePlayer player = FindBasePlayer(turret.transform.position);
            if (player == null)
                return null;

            if (_lock.code == string.Empty)
                return null;

            if (_lock.whitelistPlayers.Contains(player.userID))
                return null;

            player.ChatMessage(msg("Not Allowed", player.UserIDString));
            if (doEffects)
                Effect.server.Run(effectDenied, _lock.transform.position);
            return true;
        }

        private Item InventoryContainsCodelock(BasePlayer player)
        {
            foreach(Item item in player.inventory.containerBelt.itemList)
                if (item.info.shortname == "lock.code")
                    return item;

            foreach(Item item in player.inventory.containerMain.itemList)
                if (item.info.shortname == "lock.code")
                    return item;

            return null;
        }

        private void RemoveThink(Item item)
        {
            if (item.amount == 1)
            {
                item.RemoveFromContainer();
                item.RemoveFromWorld();
                item.Remove();
            }
            else if (item.amount >= 2)
            {
                item.amount--;
                item.MarkDirty();
            }
            else
                Puts("Player had > 1 items in their inventory");
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (data.TryGetValue(datavalue, out value)) return value;
            value = defaultValue;
            data[datavalue] = value;
            Changed = true;
            return value;
        }

        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);

        #endregion
    }
}


// --- End of file: TurretLock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tell-me-c ---
// --- Original File Path: T/TellMeC/TellMeC.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using System.Globalization;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Tell Me C", "Krungh Crow", "1.1.4")]
    [Description("Tell THE correct color combination you see, and get Ammo and RP or Eco Points")]
    public class TellMeC: RustPlugin

    #region Changelogs and ToDo
    /*==============================================================================================================
    *    
    *    THANKS to BuzZ[PHOQUE] the original creator of this plugin
    *    
    *    v1.1.2 :   changed timer calls on checkup
    *    v1.1.3 :   Possible fix for timers not starting
    *               Added clear data on unload
    *               Added support for Battlepass
    *    v1.1.4 :   Fixed double calls
    *    
     ==============================================================================================================*/
    #endregion

    {
        [PluginReference]     
        Plugin Battlepass, ServerRewards, Economics, GUIAnnouncements;

        #region Variables

        string ColorToFind;
        string WinWord;
        List<ulong> TellMeCPlayerIDs; 
        private bool ConfigChanged;
        private string ItemWon = "";
        private string ItemToWin = "";
        int QuantityToWin;
        bool TellMeCIsOn;
        string MixC;
        string finalsentence;
        float TellMeCRate = 600;
        float TellMeCLength = 25;
        private string ToWait;

        bool debug = false;

        string Prefix = "<color=purple>[Color Game]</color> ";
        ulong SteamIDIcon = 76561198842641699;// STEAM PROFILE CREATED FOR THIS PLUGIN : ID = 76561198842641699
        string WinnerColor = "yellow";
        private bool UseServerRewards = false;
        private bool UseEconomics = false;
        private bool UseBattlepass = false;
        bool useBattlepass1 = false;
        bool useBattlepass2 = false;
        bool useBattlepassloss = false;
        int battlepassWinReward1 = 20;
        int battlepassWinReward2 = 20;
        int battlepassLossReward1 = 10;
        int battlepassLossReward2 = 10;
        int PointsOnWin = 250;
        int PointsOnLoss = 25;
        int MinPlayer = 1;
        private bool UseGUI = false;


        #endregion

        #region Librarys

        Dictionary<int, string> Item = new Dictionary<int, string>()
        {
            [0] = "ammo.pistol",
            [1] = "ammo.pistol.fire",
            [2] = "ammo.pistol.hv",
            [3] = "ammo.rifle",
            [4] = "ammo.rifle.explosive",
            [5] = "ammo.rifle.hv",
            [6] = "ammo.rifle.incendiary",
            [7] = "ammo.shotgun",
            [8] = "ammo.shotgun.slug",
            [9] = "ammo.handmade.shell",            
        };

        Dictionary<int, int> Quantity = new Dictionary<int, int>()
        {
            [0] = 5,
            [1] = 10,
            [2] = 15,
            [3] = 20,           
            [4] = 25,           
            [5] = 30,           
        };

        Dictionary<string, string> colorRGB = new Dictionary<string, string>()
        {
               { "#2d2d2d" , "black" },
               { "#00c5e8" , "blue" },
               { "#54ff68" , "green" },
               { "#a3a3a3" , "grey" },
               { "#ffb163" , "orange" },
               { "#bf64fc", "purple" },
               { "#ff726b" ,"red" },
               { "white" , "white" },
               { "#fffc75" ,"yellow" },   
        };
        
        Dictionary<string, string> randomed = new Dictionary<string, string>();    
        List<String> mixRGB = new List<string>();
        List<String> mixTOSEE = new List<string>();

        #endregion

        #region LanguageAPI

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"StartTellMeCMsg", "Find the correct color match you see !\n(ex: <color=yellow>/color white</color>)"},
                {"NextTellMeCMsg", "The game restarts every "},
                {"AlreadyTellMeCMsg", "You have already played this round !\n"},
                {"InvalidTellMeCMsg", "Invalid entry.\nTry something like /c white"},
                {"WonTellMeCMsg", "found the color match !\nand has won :"},
                {"EndTellMeCMsg", "The correct color match was "},
                {"ExpiredTellMeCMsg", "was not found in time !"},
                {"LoseTellMeCMsg", "This is NOT THE CORRECT COLOR MATCH... for trying you won "},
                {"SorryErrorMsg", "Sorry an error has occured ! Please Tell <color=red>Krungh Crow</color> about this Thank you !. Item to give was null. gift was : "},

            }, this, "en");
        }

        #endregion

        #region CONFIG

        protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            Prefix = Convert.ToString(GetConfig("Message Settings", "Prefix", "<color=purple>[Color Game]</color> "));
            SteamIDIcon = Convert.ToUInt64(GetConfig("Message Settings", "SteamIDIcon", "76561198842641699"));
            WinnerColor = Convert.ToString(GetConfig("Message Settings", "Color For Winner Name", "yellow"));
            UseGUI = Convert.ToBoolean(GetConfig("Message Settings", "Use GuiAnnouncement on win", "false"));
            UseServerRewards = Convert.ToBoolean(GetConfig("Rewards Settings", "Use Server Rewards", "false"));
            UseEconomics = Convert.ToBoolean(GetConfig("Rewards Settings", "Use Economics", "false"));
            PointsOnWin = Convert.ToInt32(GetConfig("Rewards Settings", "Points on Win", "250"));
            PointsOnLoss = Convert.ToInt32(GetConfig("Rewards Settings", "Points on Loss", "25"));
            TellMeCRate = Convert.ToSingle(GetConfig("Game repeater", "Rate in seconds", "600"));
            TellMeCLength = Convert.ToSingle(GetConfig("Game length", "in seconds", "25"));
            MinPlayer = Convert.ToInt32(GetConfig("Online Settings", "Minimum amount of players to be online to start the game", "1"));
            //Battlepass
            UseBattlepass = Convert.ToBoolean(GetConfig("Reward Battlepass Settings", "Use Battlepass", false));
            useBattlepass1 = Convert.ToBoolean(GetConfig("Reward Battlepass Settings", "Use Battlepass 1st currency", false));
            useBattlepass2 = Convert.ToBoolean(GetConfig("Reward Battlepass Settings", "Use Battlepass 2nd currency", false));
            useBattlepassloss = Convert.ToBoolean(GetConfig("Reward Battlepass Settings", "Use Battlepass on loss", false));
            battlepassWinReward1 = Convert.ToInt32(GetConfig("Reward Battlepass Settings", "Amount 1st currency (win)", 20));
            battlepassWinReward2 = Convert.ToInt32(GetConfig("Reward Battlepass Settings", "Amount 2nd currency (win)", 20));
            battlepassLossReward1 = Convert.ToInt32(GetConfig("Reward Battlepass Settings", "Amount 1st currency (loss)", 10));
            battlepassLossReward2 = Convert.ToInt32(GetConfig("Reward Battlepass Settings", "Amount 2nd currency (loss)", 10));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

        #endregion

        #region SERVER REWARDS PLUGIN VERIFICATION DU .CS ET ERROR
        void Loaded()
        {
            if (UseServerRewards == true)
            {
                if (ServerRewards == false) PrintError("ServerRewards is not installed. Change your config option to disable ServerRewards and reload TellMeC. Thank you.");
            }
            if (UseEconomics == true)
            {
                if (Economics == false) PrintError("Economics is not installed. Change your config option to disable Economics and reload TellMeC. Thank you.");
            }
            if (UseBattlepass == true || useBattlepass1 == true || useBattlepass2 == true)
            {
                if (Battlepass == false) PrintError("Battlepass is not installed. Change your config option to disable Battlepass settings and reload TellMeC. Thank you.");
            }

            if (TellMeCLength >= TellMeCRate) PrintError("Game length is bigger than game rate. Change your config options in seconds and reload TellMeC. Thank you.");
        }

        void Unload()
        {
            if (TellMeCPlayerIDs != null)
            {
                TellMeCIsOn = false;
                TellMeCPlayerIDs.Clear();
            }
        }

        #endregion

        #region EXPIRATION

        void TellMeCExpired()
        {
            Server.Broadcast($"Color {MixC} {lang.GetMessage("ExpiredTellMeCMsg", this)}",Prefix, SteamIDIcon); 
            TellMeCIsOn = false;    
            TellMeCPlayerIDs.Clear();
        }
        #endregion

        #region ON SERVER INIT

		private void Init()
        {
            randomed.Clear();
            mixRGB.Clear();
            mixTOSEE.Clear();
            LoadVariables();
        }

        private void OnServerInitialized()
        {
            timer.Every(TellMeCRate, () =>
            {
                //Puts($"Trigger for check each {TellMeCRate} sec");
                if (TellMeCIsOn == false)
                {
                    if (BasePlayer.activePlayerList.Count >= MinPlayer && (TellMeCIsOn == false))
                    {
                        //Puts("Trigger for check when minimum players is online");
                        {
                            StartTellMeC();
                        }
                    }
                    else
                    {
                        //Puts("Noone online or TellMeCIsON");
                        return;
                    }
                }
                else if (TellMeCIsOn == true)
                {
                    return;
                    //Puts("TellMeCIsON");
                }
            });
        }
        #endregion

        #region TELLMEC

        private void StartTellMeC()
        {
            TellMeCPlayerIDs = new List<ulong>();
            string ColorToFound = Randomizer();
            ColorToFind = ColorToFound;
            colorRGB.TryGetValue(ColorToFind, out WinWord);               
            if (debug) Puts($" Win value in RGB : {ColorToFind}; in clear to see {WinWord}");
            MixC = $"<color={ColorToFind}>{WinWord}</color>";
            BuildMix();
            string[] mixRGBstring = mixRGB.ToArray();
            string[] mixTOSEEstring = mixTOSEE.ToArray();
            List<string> mixTOSEEconvert = new List<string>();
            int MixRound = 1;
            int MixDisplayed = 15;
            int MixToRandom = 15;
            List<string> mixtodisplay = new List<string>();
            mixtodisplay.Add(MixC);
            for (MixRound = 1; MixRound <= MixDisplayed; MixRound++)
            {
                int round = MixRound -1;
                string tosee;
                string WordZ = mixTOSEEstring[round];
                colorRGB.TryGetValue(WordZ, out tosee);
                mixTOSEEconvert.Add(tosee);
            }
            string[] mixTOSEEclear = mixTOSEEconvert.ToArray();
            MixRound=1;
            for (MixRound = 1; MixRound <= MixDisplayed; MixRound++)
            {
                int round = MixRound -1;
                string MixYold;
                string ColorY = mixRGBstring[round];
                string WordY = mixTOSEEclear[round];
                string MixY = $"<color={ColorY}> {WordY}</color>";
                mixtodisplay.Add(MixY);
                if (debug) Puts($"STEP {MixRound} MIX DONE : {MixY}");
            }
            if (debug) Puts($"MIX C FOR THE WINNER TO SEE {MixC}");
            List<string> sentence = new List<string>();
            MixRound=1;
            int lines = mixtodisplay.Count;
            if (debug) Puts($"nombre a display {lines.ToString()}");
            for (MixRound = 1; MixRound <= lines; MixRound++)
            {   
                MixRound=MixRound -1;
                int RandomLine = Core.Random.Range(0, lines);
                string mixed = mixtodisplay[RandomLine];
                if (debug)
                {
                    Puts($"lignes restantes {lines.ToString()}");
                    Puts($"string mixed {mixed}");
                }
                lines = mixtodisplay.Count - 1;
                sentence.Add(mixed);
                mixtodisplay.RemoveAt(RandomLine);
            }
            string[] sentenceTOSEE = sentence.ToArray();
            finalsentence =$"{sentenceTOSEE[0]}, {sentenceTOSEE[1]}, {sentenceTOSEE[2]}, {sentenceTOSEE[3]}, {sentenceTOSEE[4]}, {sentenceTOSEE[5]}, {sentenceTOSEE[6]}, {sentenceTOSEE[7]}\n{sentenceTOSEE[8]}, {sentenceTOSEE[9]}, {sentenceTOSEE[10]}, {sentenceTOSEE[11]}, {sentenceTOSEE[12]}, {sentenceTOSEE[13]}, {sentenceTOSEE[14]}, {sentenceTOSEE[15]}";
            if (debug) Puts($"{finalsentence}");
            BroadcastSentence(true);
            Puts($"Color Game has started. The color to match is : {WinWord}");
            TellMeCIsOn = true;
            timer.Once(TellMeCLength, () =>
            {
                if (TellMeCIsOn) TellMeCExpired();
            });
            int RandomQuantity = Core.Random.Range(0,6);
            int RandomItem = Core.Random.Range(0,10);
            ItemToWin = Item[RandomItem];
            QuantityToWin = Quantity[RandomQuantity];
        }

        #endregion

        #region BUILD THE MIX

        public void BuildMix()
        {
            int MixRound = 1;
            int WordsDisplayed = 14;
            for (MixRound = 1; MixRound <= WordsDisplayed; MixRound++)
            {
                string ColorX = Randomizer();
                string WordX = Randomizer();
                string IsAlready;
                if (ColorX == WordX)
                {
                    MixRound = MixRound -1;
                    WordsDisplayed = WordsDisplayed +1;
                    if (debug) Puts($"STEP {MixRound} , EQUALITY.");
                    continue;
                }
                mixRGB.Add(ColorX);
                mixTOSEE.Add(WordX);
                if (debug) Puts($"STEP {MixRound} , PAIR {ColorX} - {WordX} ADDED TO DICO.");
            }
        }

        string Randomizer()
        {
            int RandomRGB;
            RandomRGB = Core.Random.Range(0, 8);
            List<String> RGBKeys = colorRGB.Keys.ToList();
            string[] RGBstring = RGBKeys.ToArray();
            string ColorToFinder = RGBstring[RandomRGB];
            return(ColorToFinder);
        }

        #endregion

        #region BROADCAST

        // BROADCAST

        void BroadcastSentence(bool start)
        {
            if (start) Server.Broadcast($"{lang.GetMessage("StartTellMeCMsg", this)}\n{finalsentence}",Prefix, SteamIDIcon);
            else Server.Broadcast($"{lang.GetMessage("EndTellMeCMsg", this)} {MixC}",Prefix, SteamIDIcon);
        }        

        #endregion

        #region CHAT COMMAND /color

        [ChatCommand("color")]
        void TellMeCCommand(BasePlayer player, string command, string[] args)
        {
            if (!TellMeCIsOn)
            {
                Player.Message(player, $"{lang.GetMessage("NextTellMeCMsg", this, player.UserIDString)} {TellMeCRate} seconds",Prefix, SteamIDIcon);
                return;
            }

            if(TellMeCPlayerIDs.Contains(player.userID))
            {
                Player.Message(player, $"{lang.GetMessage("AlreadyTellMeCMsg", this, player.UserIDString)}",Prefix, SteamIDIcon);
                return;
            }

            if(args.Length != 1)
            {
                Player.Message(player, $"{lang.GetMessage("InvalidTellMeCMsg", this, player.UserIDString)}",Prefix, SteamIDIcon);                
                return;
            }
            string answer = args[0];
            if (answer.ToLower().Contains(WinWord))
            {
                TellMeCIsOn = false;
                TellMeCPlayerIDs.Clear();
                GivePlayerGift(player, ItemToWin);
                if (UseServerRewards == true)
                {
                    ServerRewards?.Call("AddPoints", player.userID, (int)PointsOnWin);
                    Server.Broadcast($"<color={WinnerColor}>{player.displayName}</color> {lang.GetMessage("WonTellMeCMsg", this, player.UserIDString)} [{ItemWon}] + [{PointsOnWin}.RP]", Prefix, SteamIDIcon);
                    if (UseGUI == true)
                    {
                        GUIAnnouncements?.Call("CreateAnnouncement", ($"{player.displayName} {lang.GetMessage("WonTellMeCMsg", this, player.UserIDString)} [{ItemWon}] + [{PointsOnWin}.RP]"), "blue", "yellow");
                    }
                }
                else if (UseEconomics == true)
                {
                    if ((bool)Economics?.Call("Deposit", player.userID, (double)PointsOnWin))
                        Server.Broadcast($"<color={WinnerColor}>{player.displayName}</color> {lang.GetMessage("WonTellMeCMsg", this, player.UserIDString)} [{ItemWon}] + [{PointsOnWin}.$]", Prefix, SteamIDIcon);
                    if (UseGUI == true)
                    {
                        GUIAnnouncements?.Call("CreateAnnouncement", ($"{player.displayName} {lang.GetMessage("WonTellMeCMsg", this, player.UserIDString)} [{ItemWon}] + [{PointsOnWin}.$]"), "blue", "yellow");
                    }
                }
                else if (UseBattlepass == true)
                {
                    if (useBattlepass1)
                    {
                        Battlepass?.Call("AddFirstCurrency", player.userID, battlepassWinReward1);
                        {
                            Server.Broadcast($"<color={WinnerColor}>{player.displayName}</color> {lang.GetMessage("WonTellMeCMsg", this, player.UserIDString)} [{ItemWon}] + [{battlepassWinReward1}.BP1]", Prefix, SteamIDIcon);
                            if (UseGUI == true)
                            {
                                GUIAnnouncements?.Call("CreateAnnouncement", ($"{player.displayName} {lang.GetMessage("WonTellMeCMsg", this, player.UserIDString)} [{ItemWon}] + [{battlepassWinReward1}.BP1]"), "blue", "yellow");
                            }
                        }
                    }

                    else if (useBattlepass2)
                    {
                        Battlepass?.Call("AddSecondCurrency", player.userID, battlepassWinReward2);
                        {
                            Server.Broadcast($"<color={WinnerColor}>{player.displayName}</color> {lang.GetMessage("WonTellMeCMsg", this, player.UserIDString)} [{ItemWon}] + [{battlepassWinReward2}.BP2]", Prefix, SteamIDIcon);
                            if (UseGUI == true)
                            {
                                GUIAnnouncements?.Call("CreateAnnouncement", ($"{player.displayName} {lang.GetMessage("WonTellMeCMsg", this, player.UserIDString)} [{ItemWon}] + [{battlepassWinReward2}.BP2]"), "blue", "yellow");
                            }
                        }
                    }
                }
                else
                {
                    Server.Broadcast($"<color={WinnerColor}>{player.displayName}</color> {lang.GetMessage("WonTellMeCMsg", this, player.UserIDString)} [{ItemWon}]", Prefix, SteamIDIcon);
                }
                BroadcastSentence(false);
            }
            else
            {        
                if (UseServerRewards)
                {                
                    ServerRewards?.Call("AddPoints", player.userID, (int)PointsOnLoss);
                    Player.Message(player, $"{lang.GetMessage("LoseTellMeCMsg", this, player.UserIDString)} [{PointsOnLoss}.RP]",Prefix, SteamIDIcon);               
                }
                else if (UseEconomics)
                {
                    if ((bool)Economics?.Call("Deposit", player.userID, (double)PointsOnLoss))
                    Player.Message(player, $"{lang.GetMessage("LoseTellMeCMsg", this, player.UserIDString)} [{PointsOnLoss}.RP]", Prefix, SteamIDIcon);
                }
                else if (UseBattlepass == true)
                {
                    if (useBattlepass1)
                    {
                        Battlepass?.Call("AddFirstCurrency", player.userID, battlepassLossReward1);
                        {
                            Player.Message(player, $"{lang.GetMessage("LoseTellMeCMsg", this, player.UserIDString)} [{battlepassLossReward1}.BP1]", Prefix, SteamIDIcon);
                        }
                    }

                    if (useBattlepass2)
                    {
                        Battlepass?.Call("AddSecondCurrency", player.userID, battlepassLossReward2);
                        {
                            Player.Message(player, $"{lang.GetMessage("LoseTellMeCMsg", this, player.UserIDString)} [{battlepassLossReward2}.BP2]", Prefix, SteamIDIcon);
                        }
                    }
                }
                TellMeCPlayerIDs.Add(player.userID);
            }
        }

        #endregion

        #region GIVE TO PLAYER
        void GivePlayerGift(BasePlayer player, string gift)
        {
            Item item = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(gift).itemid,QuantityToWin);
            if (item == null)
            {
                Player.Message(player, $"{lang.GetMessage("SorryErrorMsg", this)} {ItemToWin}",Prefix, SteamIDIcon);               
                return;
            }
            player.GiveItem(item);
            ItemWon = $"{QuantityToWin} x {gift}";
        }
        #endregion
    }
}

// --- End of file: TellMeC.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/team-ping ---
// --- Original File Path: T/TeamPing/TeamPing.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Team Ping", "Gonzi", "2.0.2")]
    [Description("Creates a Ping with name of the player who sent the ping and distance to it for all team members.")]
    public class TeamPing : RustPlugin
    {
        #region Fields

        private float mapSize;
        private string permName = "teamping.use";
        private readonly Hash<string, float> cooldowns = new Hash<string, float>();

        #endregion Fields

        #region Configuration

        private Configuration config;

        public class Configuration
        {
            // need permission or not
            public bool requiresPermission;

            // cooldown too wait until next ping (in seconds)
            public int pingCooldown;

            // time to show (in seconds)
            public int timeToShow;

            // max distance for ping (in meters)
            public int maxDistance;

            public string pluginChatPrefix;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    requiresPermission = false,
                    pingCooldown = 15,
                    timeToShow = 10,
                    maxDistance = 250,
                    pluginChatPrefix = "<color=#5af>[TEAM PING]</color>"
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception e)
            {
                Puts("{0} Exception caught.", e);
                PrintError("The configuration file is corrupted, creating a new one...");
                LoadDefaultConfig();
            }

            SaveConfig();
            return;
        }

        protected override void LoadDefaultConfig() => config = Configuration.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Hooks

        private void OnServerInitialized()
        {
            mapSize = TerrainMeta.Size.x / 2;
        }

        private void Init()
        {
            if (config.requiresPermission) permission.RegisterPermission(permName, this);
        }

        protected override void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["cooldown"] = "Not so fast! (Cooldown aktive)"
            }, this);

            // German
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["cooldown"] = "Nicht so schnell! (Cooldown noch aktiv)"
            }, this, "de");
        }

        #endregion Hooks

        #region Commands

        [ConsoleCommand("teamping")]
        private void Ping(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player.Team == null || player.Team.members.Count == 1) return; // if player does not have any team members no ping allowed
            if (config.requiresPermission && !permission.UserHasPermission(player.IPlayer.Id, permName)) return;
            {
                RaycastHit hit;

                if (!Physics.Raycast(DetermineHeadRay(player), out hit, config.maxDistance)) return;

                // check if cooldown is active, if not new cooldown starts to prevent spamming
                if (!cooldowns.ContainsKey(player.UserIDString)) cooldowns.Add(player.UserIDString, 0f);
                if (cooldowns[player.UserIDString] + config.pingCooldown > Interface.Oxide.Now)
                {
                    player.IPlayer.Message(config.pluginChatPrefix + " " + Lang("cooldown", player.UserIDString));
                    return;
                }

                cooldowns[player.UserIDString] = Interface.Oxide.Now;

                foreach (BasePlayer p in BasePlayer.activePlayerList)
                {
                    // check if is same team, if yes draw the ping for all members
                    if (CheckSameTeam(player.userID, p.userID))
                    {
                        double distance = Math.Round(Vector3.Distance(p.transform.position, new Vector3(hit.point.x, hit.point.y, hit.point.z)), 2);
                        string text = "<size=20><color=#ff0000>Ping from </color><color=#0000ff>" + player.displayName + "</color>\n" + distance + " Meters \n<color=#ff0000>▼</color></size>";
                        if (player.IsAdmin)
                        {
                            p.SendConsoleCommand("ddraw.text", config.timeToShow, Color.yellow, new Vector3(hit.point.x, hit.point.y + 0.3f, hit.point.z), text);
                        }
                        else
                        {
                            // player doenst have permissions for ddraw.text so give and revoke it.
                            SetAdminFlag(p, true);
                            p.SendConsoleCommand("ddraw.text", config.timeToShow, Color.yellow, new Vector3(hit.point.x, hit.point.y + 0.3f, hit.point.z), text);
                            SetAdminFlag(p, false);
                        }
                    }
                }
            }
        }

        #endregion Commands

        #region Util

        private bool CheckSameTeam(ulong ply1Id, ulong ply2Id)
        {
            RelationshipManager.PlayerTeam t1;
            RelationshipManager.PlayerTeam t2;
            if (!RelationshipManager.ServerInstance.playerToTeam.TryGetValue(ply1Id, out t1)) return false;
            if (!RelationshipManager.ServerInstance.playerToTeam.TryGetValue(ply2Id, out t2)) return false;
            return t1.teamID == t2.teamID;
        }

        private void SetAdminFlag(BasePlayer player, bool state)
        {
            player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, state);
            player.SendNetworkUpdateImmediate();
        }

        private Ray DetermineHeadRay(BasePlayer player)
        {
            var computerStation = player.GetMounted() as ComputerStation;
            if (computerStation != null)
            {
                var controlledEntity = computerStation.currentlyControllingEnt.Get(serverside: true);
                var drone = controlledEntity as Drone;
                if (drone != null)
                    return new Ray(drone.transform.position, drone.transform.forward);

                var cctv = controlledEntity as CCTV_RC;
                if (cctv != null)
                {
                    var direction = Quaternion.Euler(0, cctv.yaw.transform.localEulerAngles.y, -cctv.pitch.transform.localEulerAngles.x) * cctv.transform.forward;
                    return new Ray(cctv.transform.position + direction, direction);
                }
            }

            return player.eyes.HeadRay();
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion Util
    }
}

// --- End of file: TeamPing.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/teleport-gun ---
// --- Original File Path: T/TeleportGun/TeleportGun.cs ---

﻿using System;
using System.Collections.Generic;

using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Teleport Gun", "2CHEVSKII", "0.2.0")]
    [Description("Shoot something to teleport to it!")]
    class TeleportGun : CovalencePlugin
    {

        #region -Hooks-


        void Init()
        {
            permission.RegisterPermission(PERMISSION_USE, this);
            LoadConfigVariables();
        }

        protected override void LoadDefaultConfig() { }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(defaultMessages, this, "en");

        void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            Item item;
            if (enabledplayers.TryGetValue(attacker.IPlayer, out item) && info.Weapon?.GetItem() == item)
            {
                attacker.MovePosition(info.HitPositionWorld);
            }
        }

        void OnActiveItemChanged(BasePlayer player)
        {
            if (enabledplayers.ContainsKey(player.IPlayer) && autodisable)
            {
                Disable(player);
            }
        }


        #endregion

        #region -Fields-


        bool autodisable = true;
        int autodisabletimer = 0;
        const string PERMISSION_USE = "teleportgun.use";
        const string CHAT_PREFIX = "Chat prefix";
        const string ENABLED = "Enabled";
        const string DISABLED = "Disabled";
        const string WRONG_ITEM = "Wrong item";
        const string NO_PERMISSION = "No permission";
        Dictionary<string, string> defaultMessages = new Dictionary<string, string>
        {
            [CHAT_PREFIX] = "<color=yellow>[</color>TELEPORT GUN<color=yellow>]</color>",
            [ENABLED] = "<color=#47FF11>E</color>nabled teleport gun<color=#47FF11>.</color>",
            [DISABLED] = "<color=red>D</color>isabled teleport gun<color=red>.</color>",
            [NO_PERMISSION] = "<color=red>Y</color>ou have no permission to use teleport gun<color=red>!</color>",
            [WRONG_ITEM] = "<color=yellow>A</color>ctive item must be a gun<color=yellow>!</color>"
        };
        Dictionary<IPlayer, Item> enabledplayers = new Dictionary<IPlayer, Item>();
        Dictionary<BasePlayer, Timer> timers = new Dictionary<BasePlayer, Timer>();

        #endregion

        #region -Command-


        [Command("tpgun")]
        void CmdTpGun(IPlayer player, string command, string[] args)
        {
            if (enabledplayers.ContainsKey(player))
            {
                Disable((BasePlayer)player.Object);
            }
            else if (!player.HasPermission(PERMISSION_USE))
            {
                Replier(player, NO_PERMISSION);
            }
            else Enable((BasePlayer)player.Object);
        }


        #endregion

        #region -Helpers-

        void Enable(BasePlayer player)
        {
            var heldEnt = player.GetHeldEntity();

            if (heldEnt is BaseProjectile)
            {
                enabledplayers.Add(player.IPlayer, heldEnt.GetItem());
                if (autodisabletimer > 0)
                    timers.Add(player, timer.Once(Convert.ToSingle(autodisabletimer), () => Disable(player)));
                Replier(player, ENABLED);
            }
            else Replier(player, WRONG_ITEM);
        }

        void Disable(BasePlayer player)
        {
            enabledplayers.Remove(player.IPlayer);
            if(timers.ContainsKey(player))
            {
                timers[player].Destroy();
                timers.Remove(player);
            }
            Replier(player, DISABLED);
        }

        void LoadConfigVariables()
        {
            CheckConfig("Auto disable when active item changed", ref autodisable);
            CheckConfig("Auto disable after timer (seconds)", ref autodisabletimer);
            SaveConfig();
        }

        void CheckConfig<T>(string key, ref T value)
        {
            if (Config[key] is T)
                value = (T)Config[key];
            else
                Config[key] = value;
        }

        void Replier(BasePlayer player, string message) => Replier(player.IPlayer, message);
        void Replier(IPlayer player, string message) => player.Message(lang.GetMessage(message, this, player.Id), lang.GetMessage(CHAT_PREFIX, this, player.Id));


        #endregion

    }
}


// --- End of file: TeleportGun.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tickets ---
// --- Original File Path: T/Tickets/Tickets.cs ---

﻿using Oxide.Plugins.TicketsExtensions;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using System.Reflection;
using System.Linq;
using Oxide.Core;
using System;

namespace Oxide.Plugins
{
    [Info("Tickets", "LaserHydra", "3.1.3")]
    [Description("Allows players to send tickets to admin")]
    public class Tickets : CovalencePlugin
    {
        #region Variable Declaration

        [PluginReference]
        private Plugin Slack, PushAPI, EmailAPI;

        public static Tickets Instance;

        public string ChatTitle;
        public string SlackChannel;

        public bool UseSlack;
        public bool UseEmailAPI;
        public bool UsePushAPI;

        public bool NotifyReply;
        public bool NotifyCreated;
        public bool NotifyClosed;
        public bool NotifyWiped;

        public string OpenStatus;
        public string ClosedStatus;

        #endregion

        #region Classes

        [AttributeUsage(AttributeTargets.Method)]
        private class CommandInfo : Attribute
        {
            protected string[] Commands;

            public static string[] GetCommands(IPlayer player, MethodBase method)
            {
                Attribute[] attributes = GetCustomAttributes(method);

                if (attributes.Any((a) => a is CommandInfo))
                {
                    CommandInfo commandInfo = (CommandInfo)attributes.First((a) => a is CommandInfo && !(a is AdminCommandInfo));
                    AdminCommandInfo adminCommandInfo = (AdminCommandInfo)attributes.First((a) => a is AdminCommandInfo);

                    string[] commands = null;

                    if (commandInfo != null)
                        commands = commandInfo.Commands;

                    if (adminCommandInfo != null && player.HasPermission("tickets.admin"))
                    {
                        if (commands == null)
                            commands = adminCommandInfo.Commands;
                        else
                            commands = commands.Concat(adminCommandInfo.Commands).ToArray();
                    }

                    return commands;
                }

                return new string[0];
            }

            public CommandInfo(params string[] commands)
            {
                this.Commands = commands;
            }
        }

        private class AdminCommandInfo : CommandInfo
        {
            public AdminCommandInfo(params string[] commands)
            {
                this.Commands = commands;
            }
        }

        private class Ticket
        {
            public static List<Ticket> All = new List<Ticket>();
            public static List<Ticket> Unread => All.Where((t) => !t.Read).ToList();

            public static List<Ticket> GetPlayerTickets(IPlayer player) => All.Where((t) => t.Creator.ID == player.Id).ToList();
            public static List<Ticket> GetOpenTickets() => All.Where((t) => !t.Closed).ToList();
            public static List<Ticket> GetClosedTickets() => All.Where((t) => t.Closed).ToList();

            public int ID;
            public bool Closed;
            public bool Read;
            public AuthorInfo Creator;
            public Position Position;
            public List<Reply> Replies = new List<Reply>();
            internal string FormattedReplies => string.Join(Environment.NewLine, Replies.Select((r) => r.ToString()).ToArray());

            public static int LastID => All.Count == 0 ? 0 : All.OrderByDescending(ticket => ticket.ID).ToList()[0].ID;

            public static Ticket Find(int id) => All.Find((t) => t.ID == id);

            public static Ticket Find(IPlayer player, int id) => All.Find((t) => t.ID == id && t.Creator.ID == player.Id);

            public static Ticket Create(IPlayer player, string message)
            {
                Ticket ticket = new Ticket(player);
                All.Add(ticket);

                ticket.Reply(player, message, true);

                return ticket;
            }

            public void Reply(IPlayer player, string message, bool justCreated = false)
            {
                var reply = new Reply
                {
                    Author = AuthorInfo.FromPlayer(player),
                    Message = message,
                    Date = Date.Now
                };

                Replies.Add(reply);

                Updated();

                if (!justCreated)
                    Instance.OnTicketReplied(this, reply);
                else
                    Instance.OnTicketCreated(this, reply);
            }

            public void Close(IPlayer player)
            {
                Closed = true;
                Updated();

                Instance.OnTicketClosed(this, player);
            }

            public string InsertDataToString(string str)
            {
                Dictionary<string, object> data = new Dictionary<string, object>
                {
                    { "{ID}", ID },
                    { "{Position}", Position },
                    { "{Replies}", FormattedReplies },
                    { "{Creator}", Creator },
                    { "{Status}", Closed ? Instance.ClosedStatus : Instance.OpenStatus }
                };

                foreach (var kvp in data)
                    str = str.Replace(kvp.Key, kvp.Value.ToString());

                return str;
            }

            public static void Updated() => Instance.SaveData(All);

            public Ticket()
            {
                ID = LastID + 1;
            }

            public Ticket(IPlayer player)
            {
                Creator = AuthorInfo.FromPlayer(player);
                ID = LastID + 1;
                Position = Position.FromGeneric(player.Position());
            }
        }

        private struct Reply
        {
            public AuthorInfo Author;
            public string Message;
            public Date Date;

            public override string ToString()
            {
                string str = Instance.LangMsg("Reply");

                Dictionary<string, object> data = new Dictionary<string, object>
                {
                    { "{Author}", Author },
                    { "{Message}", Message },
                    { "{Date}", Date }
                };

                foreach (var kvp in data)
                    str = str.Replace(kvp.Key, kvp.Value.ToString());

                return str;
            }
        }

        private struct AuthorInfo
        {
            public string Name;
            public string ID;

            internal static AuthorInfo FromPlayer(IPlayer player) => new AuthorInfo
            {
                Name = player.Name,
                ID = player.Id
            };

            public override string ToString() => $"{Name} ({ID})";
        }

        private class Position
        {
            public float X;
            public float Y;
            public float Z;

            public GenericPosition ToGeneric() => new GenericPosition(X, Y, Z);

            public static Position FromGeneric(GenericPosition genericPosition) => new Position
            {
                X = genericPosition.X,
                Y = genericPosition.Y,
                Z = genericPosition.Z
            };
        }

        private class Date
        {
            public int Second = 0;
            public int Minute = 0;
            public int Hour = 0;
            public int Day = 1;
            public int Month = 1;
            public int Year = 1;

            internal DateTime DateTime => new DateTime(Year, Month, Day, Hour, Minute, Second);

            internal static Date Now => FromDateTime(DateTime.Now);

            internal static Date FromDateTime(DateTime dateTime) => new Date
            {
                Second = dateTime.Second,
                Minute = dateTime.Minute,
                Hour = dateTime.Hour,
                Day = dateTime.Day,
                Month = dateTime.Month,
                Year = dateTime.Year
            };

            public override string ToString()
            {
                string str = Instance.LangMsg("Date Format");

                Dictionary<string, object> data = new Dictionary<string, object>
                {
                    { "{Year}", Year },
                    { "{Month}", Month },
                    { "{Day}", Day },
                    { "{Hour}", Hour },
                    { "{Minute}", Minute },
                    { "{Second}", Second }
                };

                foreach (var kvp in data)
                    str = str.Replace(kvp.Key, kvp.Value.ToString());

                return str;
            }
        }

        #endregion

        #region Hooks

        private void Loaded()
        {
            Instance = this;

            permission.RegisterPermission("tickets.admin", this);
            permission.RegisterPermission("tickets.wipe", this);

            LoadData(out Ticket.All);
            LoadMessages();
            LoadConfig();
        }

        private void OnTicketReplied(Ticket ticket, Reply reply)
        {
            if (NotifyReply)
            {
                string message = ticket.InsertDataToString(LangMsg("Reply Notification"));
                message = message.Replace("{Reply}", reply.ToString());

                Notify(message);
            }
        }

        private void OnTicketCreated(Ticket ticket, Reply reply)
        {
            if (NotifyCreated)
            {
                string message = ticket.InsertDataToString(LangMsg("Created Notification"));
                message = message.Replace("{Reply}", reply.ToString());

                Notify(message);
            }
        }

        private void OnTicketClosed(Ticket ticket, IPlayer player)
        {
            if (NotifyClosed)
                Notify(ticket.InsertDataToString(LangMsg("Closed Notification")).Replace("{Admin}", player.Name));
        }

        #endregion

        #region Loading

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configurationfile...");

        private new void LoadConfig()
        {
            ChatTitle = GetConfig<string>("Title", "[#262626][[#C4FF00]Tickets[/#]][/#]");
            SlackChannel = GetConfig<string>("Slack Channel", "general");

            UseSlack = GetConfig<bool>("Use Slack", false);
            UseEmailAPI = GetConfig<bool>("Use Email API", false);
            UsePushAPI = GetConfig<bool>("Use Push API", false);

            NotifyReply = GetConfig<bool>("Notify About Replies", true);
            NotifyCreated = GetConfig<bool>("Notify About New Tickets", true);
            NotifyClosed = GetConfig<bool>("Notify About Closing", true);
            NotifyWiped = GetConfig<bool>("Notify About Wipes", true);

            OpenStatus = GetConfig<string>("Open Sign", "[#262626][[#C4FF00]OPEN[/#]][/#]");
            ClosedStatus = GetConfig<string>("Closed Sign", "[#262626][[#red]CLOSED[/#]][/#]");

            SaveConfig();
        }

        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Ticket List Item"] = "{Status} [#C4FF00]Ticket #{ID}[/#] by {Creator}",
                ["Ticket List Empty"] = "{Title} There are no tickets.",
                ["Ticket Created"] = "{Title} You have successfully created a ticket (#{ID})",
                ["Ticket View"] = "{Title} {Status} Viewing Ticket #{ID} by {Creator}:" + Environment.NewLine + Environment.NewLine + "{Replies}",
                ["Reply"] = "[#C4FF00]{Author}[/#] - {Date}" + Environment.NewLine + "{Message}",
                ["Date Format"] = "{Day}.{Month}.{Year} {Hour}:{Minute}",
                ["Ticket Closed"] = "{Title} You successfully closed ticket #{ID}.",
                ["Replied To Ticket"] = "{Title} You replied to ticket #{ID}.",
                ["Teleported To Ticket"] = "{Title} You teleported to ticket #{ID}.",
                ["Teleported Not Found"] = "{Title} Ticket #{ID} could not be found.",
                ["Reply Notification"] = "New Reply to Ticket #{ID}:" + Environment.NewLine + "{Reply}",
                ["Created Notification"] = "New Ticket #{ID}:" + Environment.NewLine + "{Reply}",
                ["Closed Notification"] = "Ticket #{ID} was closed by {Admin}",
                ["Wiped Notification"] = "{Admin} has deleted all existing tickets.",
                ["Ticket Is Closed"] = "{Title} Ticket #{ID} is closed. No further replies are allowed.",
                ["Already Closed"] = "{Title} Ticket is closed already.",
                ["Wiped"] = "All existing tickets have been deleted."
            }, this);
        }

        #endregion

        #region Commands

        [Command("ticket"),
         CommandInfo("view <ID> | view ticket", "create <Message> | write a new ticket", "reply <ID> <Message> | reply to a ticket", "list | list tickets"),
         AdminCommandInfo("listclosed | list closed tickets", "close <ID> | close a ticket", "teleport <ID> | teleport to a ticket's source position")]
        private void ticketCmd(IPlayer player, string cmd, string[] args)
        {
            if (args.Length == 0)
            {
                player.ReplySafe(GetCommandInfo(player, "ticket"));
                return;
            }

            bool admin = player.HasPermission("tickets.admin");
            Ticket ticket;
            int id;

            switch (args[0])
            {
                case "view":

                    if (args.Length < 2)
                    {
                        player.ReplySafe("Syntax: ticket view <ID>");
                        return;
                    }

                    if (!int.TryParse(args[1], out id))
                    {
                        player.ReplySafe($"Invalid ID Format. {id} is no valid number!");
                        return;
                    }

                    ticket = admin ? Ticket.Find(id) : Ticket.Find(player, id);

                    if (ticket == null)
                    {
                        player.ReplySafe(LangMsg("Ticket Not Found", player.Id));
                        return;
                    }

                    player.ReplySafe(ticket.InsertDataToString(LangMsg("Ticket View", player.Id)));

                    break;

                case "create":

                    if (args.Length < 2)
                    {
                        player.ReplySafe("Syntax: ticket create <Message>");
                        return;
                    }

                    ticket = Ticket.Create(player, string.Join(" ", args.Skip(1).ToArray()));
                    player.ReplySafe(ticket.InsertDataToString(LangMsg("Ticket Created", player.Id)));

                    break;

                case "reply":

                    if (args.Length < 3)
                    {
                        player.ReplySafe("Syntax: ticket reply <ID> <Message>");
                        return;
                    }

                    if (!int.TryParse(args[1], out id))
                    {
                        player.ReplySafe($"Invalid ID Format. {id} is no valid number!");
                        return;
                    }

                    ticket = admin ? Ticket.Find(id) : Ticket.Find(player, id);

                    if (ticket == null)
                    {
                        player.ReplySafe(LangMsg("Ticket Not Found", player.Id));
                        return;
                    }

                    if (ticket.Closed)
                    {
                        if (admin)
                            ticket.Closed = false;
                        else
                        {
                            player.ReplySafe(ticket.InsertDataToString(LangMsg("Ticket Is Closed", player.Id)));
                            return;
                        }
                    }

                    ticket.Reply(player, string.Join(" ", args.Skip(2).ToArray()));
                    player.ReplySafe(ticket.InsertDataToString(LangMsg("Replied To Ticket", player.Id)));

                    break;

                case "list":

                    List<Ticket> tickets = admin ? Ticket.GetOpenTickets() : Ticket.GetPlayerTickets(player);
                    string[] ticketListItems = tickets.Select((t) => t.InsertDataToString(LangMsg("Ticket List Item", player.Id))).ToArray();

                    player.ReplySafe(ticketListItems.Length == 0 ? LangMsg("Ticket List Empty", player.Id) : string.Join(Environment.NewLine, ticketListItems));

                    break;

                // Admin Commands

                case "listclosed":

                    if (!admin)
                        goto default;

                    List<Ticket> closedTickets = Ticket.GetClosedTickets();
                    string[] closedTicketListItems = closedTickets.Select((t) => t.InsertDataToString(LangMsg("Ticket List Item", player.Id))).ToArray();

                    player.ReplySafe(closedTicketListItems.Length == 0 ? LangMsg("Ticket List Empty", player.Id) : string.Join(Environment.NewLine, closedTicketListItems));

                    break;

                case "close":

                    if (!admin)
                        goto default;

                    if (args.Length < 2)
                    {
                        player.ReplySafe("Syntax: ticket close <ID>");
                        return;
                    }

                    if (!int.TryParse(args[1], out id))
                    {
                        player.ReplySafe($"Invalid ID Format. {id} is no valid number!");
                        return;
                    }

                    ticket = admin ? Ticket.Find(id) : Ticket.Find(player, id);

                    if (ticket == null)
                    {
                        player.ReplySafe(LangMsg("Ticket Not Found", player.Id));
                        return;
                    }

                    if (ticket.Closed)
                    {
                        player.ReplySafe(LangMsg("Already Closed", player.Id));
                        return;
                    }

                    ticket.Close(player);
                    player.ReplySafe(ticket.InsertDataToString(LangMsg("Ticket Closed", player.Id)));

                    break;

                case "teleport":

                    if (!admin)
                        goto default;

                    if (args.Length < 2)
                    {
                        player.ReplySafe("Syntax: ticket teleport <ID>");
                        return;
                    }

                    if (!int.TryParse(args[1], out id))
                    {
                        player.ReplySafe($"Invalid ID Format. {id} is no valid number!");
                        return;
                    }

                    ticket = admin ? Ticket.Find(id) : Ticket.Find(player, id);

                    if (ticket == null)
                    {
                        player.ReplySafe(LangMsg("Ticket Not Found", player.Id));
                        return;
                    }

                    player.Teleport(ticket.Position.X, ticket.Position.Y, ticket.Position.Z);
                    player.ReplySafe(ticket.InsertDataToString(LangMsg("Teleported To Ticket", player.Id)));

                    break;

                case "wipe":

                    if (!player.HasPermission("tickets.wipe"))
                        goto default;

                    Ticket.All.Clear();
                    SaveData(Ticket.All);

                    player.ReplySafe(LangMsg("Wiped", player.Id));

                    if (NotifyWiped)
                        Notify(LangMsg("Wiped Notification").Replace("{Admin}", player.Name));

                    break;

                default:
                    // Fancy line:
                    player.ReplySafe(GetCommandInfo(player, "ticket"));
                    break;
            }
        }

        #endregion

        #region Format Helpers

        public static string StripTags(string original) => Formatter.ToPlaintext(original);

        public static string FormatText(string original) => Instance.covalence.FormatText(original);

        #endregion

        #region Lang Helper

        private string LangMsg(string key, string id = null) => lang.GetMessage(key, this, id).Replace("{Title}", ChatTitle);

        #endregion

        #region Command Helper

        private string GetCommandInfo(IPlayer player, string command)
        {
            MethodBase mb = typeof(Tickets).GetMethod(command + "Cmd", BindingFlags.NonPublic | BindingFlags.Instance);

            if (mb == null)
                return string.Empty;

            string[] commands = CommandInfo.GetCommands(player, mb);

            for (int i = 0; i < commands.Length; i++)
                commands[i] = (player.IsServer || player.LastCommand == CommandType.Console ? $"{command} " : $"/{command} ") + commands[i];

            return string.Join(Environment.NewLine, commands);
        }

        #endregion

        #region Notifying Helpers

        private static void Notify(string message)
        {
            Instance.Puts(StripTags(message));
            MessageAdmins(message);
            MessageOther(message);
        }

        private static void MessageAdmins(string message)
        {
            foreach (var player in Instance.players.Connected.Where(p => p.IsAdmin || Instance.permission.UserHasPermission(p.Id, "tickets.admin")))
                player.ReplySafe(message);
        }

        private static void MessageOther(string message)
        {
            if (Instance.UseSlack)
                Instance.Slack?.Call("Message", message, Instance.SlackChannel);

            if (Instance.UseEmailAPI)
                Instance.EmailAPI?.Call("EmailMessage", "Tickets", message);

            if (Instance.UsePushAPI)
                Instance.PushAPI?.Call("PushMessage", "Tickets", message);
        }

        #endregion

        #region Config Helpers

        private T GetConfig<T>(params object[] pathAndValue)
        {
            List<string> pathL = pathAndValue.Select((v) => v.ToString()).ToList();
            pathL.RemoveAt(pathAndValue.Length - 1);
            string[] path = pathL.ToArray();

            if (Config.Get(path) == null)
            {
                Config.Set(pathAndValue);
                PrintWarning($"Added field to config: {string.Join("/", path)}");
            }

            return (T) Convert.ChangeType(Config.Get(path), typeof(T));
        }

        #endregion

        #region Data Helpers

        private string DataFileName => Title.Replace(" ", string.Empty);

        private void LoadData<T>(out T data, string filename = null) => data = Interface.Oxide.DataFileSystem.ReadObject<T>(filename == null ? DataFileName : $"{DataFileName}/{filename}");

        private void SaveData<T>(T data, string filename = null) => Interface.Oxide.DataFileSystem.WriteObject(filename == null ? DataFileName : $"{DataFileName}/{filename}", data);

        #endregion
    }
}

#region Extension

namespace Oxide.Plugins.TicketsExtensions
{
    internal static class Extend
    {
        public static void ReplySafe(this IPlayer player, string message) =>
            player.Reply(player.IsServer ? Tickets.StripTags(message) : Tickets.FormatText(message));
    }
}

#endregion

// --- End of file: Tickets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/timed-permissions ---
// --- Original File Path: T/TimedPermissions/TimedPermissions.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text.RegularExpressions;
using System;

namespace Oxide.Plugins
{
    [Info("Timed Permissions", "LaserHydra", "1.6.0")]
    [Description("Allows you to grant permissions or groups for a specific time")]
    class TimedPermissions : CovalencePlugin
    {
        private const string AdminPermission = "timedpermissions.use";
        private const string AdvancedAdminPermission = "timedpermissions.advanced";
        
        private static TimedPermissions _plugin;
        private static List<PlayerInformation> _playerInformationCollection = new List<PlayerInformation>();

        private Regex _timeSpanPattern = new Regex(@"(?:(?<days>\d{1,3})d)?(?:(?<hours>\d{1,3})h)?(?:(?<minutes>\d{1,3})m)?", RegexOptions.Compiled | RegexOptions.IgnoreCase);
        private Configuration _config;
        
        #region Hooks & Loading

        private void Loaded()
        {
            _plugin = this;

            LoadData(ref _playerInformationCollection);

            if (_playerInformationCollection == null)
            {
                _playerInformationCollection = new List<PlayerInformation>();
                SaveData(_playerInformationCollection);
            }

            _plugin.timer.Repeat(60, 0, () =>
            {
                for (int i = _playerInformationCollection.Count - 1; i >= 0; i--)
                {
                    PlayerInformation playerInformation = _playerInformationCollection[i];
                    playerInformation.Update();
                }
            });
        }

        private void OnUserConnected(IPlayer player)
        {
            PlayerInformation.Get(player.Id)?.EnsureAllAccess();
        }

        private void OnNewSave(string filename)
        {
            LoadConfig(); // Ensure config is loaded at this point

            if (_config.WipeDataOnNewSave)
            {
                string backupFileName;
                ResetAllAccess(out backupFileName);

                PrintWarning($"New save file detected: all groups and permissions revoked and data cleared. Backup created at {backupFileName}.json");
            }
        }

        #endregion

        #region Commands

        [Command("pinfo")]
        private void CmdPlayerInfo(IPlayer player, string cmd, string[] args)
        {
            IPlayer target;

            if (args.Length == 0 || !player.HasPermission(AdminPermission))
                target = player;
            else
                target = FindPlayer(args[0], player);

            if (target == null)
                return;

            var information = PlayerInformation.Get(target.Id);

            if (information == null)
            {
                player.Reply(GetMessage("Player Has No Info", player.Id));
            }
            else
            {
                string msg = GetMessage("Player Info", player.Id);

                msg = msg.Replace("{player}", $"{information.Name} ({information.Id})");
                msg = msg.Replace("{groups}", string.Join(", ", (from g in information.Groups select $"{g.Value} until {g.ExpireDate.ToLongDateString() + " " + g.ExpireDate.ToShortTimeString()} UTC").ToArray()));
                msg = msg.Replace("{permissions}", string.Join(", ", (from p in information.Permissions select $"{p.Value} until {p.ExpireDate.ToLongDateString() + " " + p.ExpireDate.ToShortTimeString()} UTC").ToArray()));

                player.Reply(msg);
            }
        }

        [Command("grantperm"), Permission(AdminPermission)]
        private void CmdGrantPerm(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 3)
            {
                player.Reply(GetMessage("Syntax : grantperm", player.Id));
                return;
            }

            IPlayer target = FindPlayer(args[0], player);
            TimeSpan duration;

            if (target == null)
                return;

            if (!TryParseTimeSpan(args[2], out duration))
            {
                player.Reply(GetMessage("Invalid Time Format", player.Id));
                return;
            }

            PlayerInformation.GetOrCreate(target).AddPermission(args[1].ToLower(), DateTime.UtcNow + duration);
        }

        [Command("revokeperm"), Permission(AdminPermission)]
        private void CmdRevokePerm(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 2)
            {
                player.Reply(GetMessage("Syntax : revokeperm", player.Id));
                return;
            }

            IPlayer target = FindPlayer(args[0], player);

            if (target == null)
                return;

            PlayerInformation information = PlayerInformation.Get(target.Id);
            
            if (information == null || !information.Permissions.Any(p => p.Value == args[1].ToLower()))
            {
                player.Reply(GetMessage("User Doesn't Have Permission", player.Id).Replace("{target}", target.Name).Replace("{permission}", args[1].ToLower()));
                return;
            }

            information.RemovePermission(args[1].ToLower());
        }

        [Command("addgroup"), Permission(AdminPermission)]
        private void CmdAddGroup(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 3)
            {
                player.Reply(GetMessage("Syntax : addgroup", player.Id));
                return;
            }

            IPlayer target = FindPlayer(args[0], player);
            TimeSpan duration;

            if (target == null)
                return;

            if (!TryParseTimeSpan(args[2], out duration))
            {
                player.Reply(GetMessage("Invalid Time Format", player.Id));
                return;
            }

            PlayerInformation.GetOrCreate(target).AddGroup(args[1], DateTime.UtcNow + duration);
        }

        [Command("removegroup"), Permission(AdminPermission)]
        private void CmdRemoveGroup(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 2)
            {
                player.Reply(GetMessage("Syntax : removegroup", player.Id));
                return;
            }

            IPlayer target = FindPlayer(args[0], player);

            if (target == null)
                return;

            PlayerInformation information = PlayerInformation.Get(target.Id);

            if (information == null || !information.Groups.Any(p => p.Value == args[1].ToLower()))
            {
                player.Reply(GetMessage("User Isn't In Group", player.Id).Replace("{target}", target.Name).Replace("{group}", args[1].ToLower()));
                return;
            }

            information.RemoveGroup(args[1].ToLower());
        }

        [Command("timedpermissions_resetaccess"), Permission(AdvancedAdminPermission)]
        private void CmdResetAccess(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 1 || !args[0].Equals("yes", StringComparison.InvariantCultureIgnoreCase))
            {
                player.Reply(GetMessage("Syntax : resetaccess", player.Id));
                player.Reply(GetMessage("Reset Access Warning", player.Id));

                return;
            }

            string backupFileName;
            ResetAllAccess(out backupFileName);

            player.Reply(GetMessage("Access Reset Successfully", player.Id).Replace("{filename}", backupFileName));
        }

        #endregion

        #region Helper Methods

        private void ResetAllAccess(out string backupFileName)
        {
            backupFileName = $"{nameof(TimedPermissions)}_Backups/{DateTime.UtcNow.Date:yyyy-MM-dd}_{DateTime.UtcNow:T}";
            SaveData(_playerInformationCollection, backupFileName); // create backup of current data

            foreach (PlayerInformation playerInformation in _playerInformationCollection)
                playerInformation.RemoveAllAccess();

            _playerInformationCollection = new List<PlayerInformation>();
            SaveData(_playerInformationCollection);
        }

        #region Time Helper

        private bool TryParseTimeSpan(string source, out TimeSpan date)
        {
            var match = _timeSpanPattern.Match(source);

            if (!match.Success)
            {
                date = default(TimeSpan);
                return false;
            }

            if (!match.Groups[0].Value.Equals(source))
            {
                date = default(TimeSpan);
                return false;
            }

            Group daysGroup = match.Groups["days"];
            Group hoursGroup = match.Groups["hours"];
            Group minutesGroup = match.Groups["minutes"];

            int days = daysGroup.Success
                ? int.Parse(daysGroup.Value)
                : 0;
            int hours = hoursGroup.Success
                ? int.Parse(hoursGroup.Value)
                : 0;
            int minutes = minutesGroup.Success
                ? int.Parse(minutesGroup.Value)
                : 0;

            if (days + hours + minutes == 0)
            {
                date = default(TimeSpan);
                return false;
            }

            date = new TimeSpan(days, hours, minutes, 0);
            return true;
        }

        #endregion

        #region Finding Helper

        private IPlayer FindPlayer(string nameOrId, IPlayer player)
        {
            if (IsConvertibleTo<ulong>(nameOrId) && nameOrId.StartsWith("7656119") && nameOrId.Length == 17)
            {
                IPlayer result = players.All.ToList().Find(p => p.Id == nameOrId);

                if (result == null)
                    player.Reply($"Could not find player with ID '{nameOrId}'");

                return result;
            }

            List<IPlayer> foundPlayers = new List<IPlayer>();

            foreach (IPlayer current in players.Connected)
            {
                if (string.Equals(current.Name, nameOrId, StringComparison.CurrentCultureIgnoreCase))
                    return current;

                if (current.Name.ToLower().Contains(nameOrId.ToLower()))
                    foundPlayers.Add(current);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    player.Reply($"Could not find player with name '{nameOrId}'");
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    string[] names = (from current in foundPlayers select current.Name).ToArray();
                    player.Reply("Multiple matching players found: \n" + string.Join(", ", names));
                    break;
            }

            return null;
        }

        #endregion

        #region Conversion Helper

        private static bool IsConvertibleTo<T>(object obj)
        {
            try
            {
                var temp = (T)Convert.ChangeType(obj, typeof(T));
                return true;
            }
            catch
            {
                return false;
            }
        }

        #endregion

        #region Data Helper

        private static void LoadData<T>(ref T data, string filename = null) =>
            data = Interface.Oxide.DataFileSystem.ReadObject<T>(filename ?? nameof(TimedPermissions));

        private static void SaveData<T>(T data, string filename = null) =>
            Interface.Oxide.DataFileSystem.WriteObject(filename ?? nameof(TimedPermissions), data);

        #endregion

        #region Message Wrapper

        public static string GetMessage(string key, string id) => _plugin.lang.GetMessage(key, _plugin, id);

        #endregion

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "You don't have permission to use this command.",
                ["Invalid Time Format"] = "Invalid Time Format: Ex: 1d12h30m | d = days, h = hours, m = minutes",
                ["Player Has No Info"] = "There is no info about this player.",
                ["Player Info"] = "Information for <color=#C4FF00>{player}</color>:" + Environment.NewLine +
                                  "<color=#C4FF00>Groups</color>: {groups}" + Environment.NewLine +
                                  "<color=#C4FF00>Permissions</color>: {permissions}",
                ["User Doesn't Have Permission"] = "{target} does not have permission '{permission}'.",
                ["User Isn't In Group"] = "{target} isn't in group '{group}'.",
                ["Reset Access Warning"] = "This command will reset all access data and create a backup. Please confirm by calling the command with 'yes' as parameter",
                ["Access Reset Successfully"] = "All groups and permissions revoked and data cleared. Backup created at {filename}.json",
                ["Syntax : revokeperm"] = "Syntax: revokeperm <player|steamid> <permission>",
                ["Syntax : grantperm"] = "Syntax: removegroup <player|steamid> <group>",
                ["Syntax : removegroup"] = "Syntax: removegroup <player|steamid> <group>",
                ["Syntax : addgroup"] = "Syntax: addgroup <player|steamid> <group> <time Ex: 1d12h30m>",
                ["Syntax : resetaccess"] = "Syntax: timedpermissions_resetaccess [yes]",

            }, this);
        }

        #endregion

        #region Configuration

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class Configuration
        {
            [JsonProperty("Wipe Data on New Save (Limited to Certain Games)")]
            public bool WipeDataOnNewSave { get; private set; } = false;
        }

        #endregion

        #region Data Structures

        private class PlayerInformation
        {
            [JsonProperty("Id")]
            public string Id { get; set; }

            [JsonProperty("Name")]
            public string Name { get; set; }

            [JsonProperty("Permissions")]
            private readonly List<ExpiringAccessValue> _permissions = new List<ExpiringAccessValue>();

            [JsonProperty("Groups")]
            private readonly List<ExpiringAccessValue> _groups = new List<ExpiringAccessValue>();

            [JsonIgnore]
            public ReadOnlyCollection<ExpiringAccessValue> Permissions => _permissions.AsReadOnly();

            [JsonIgnore]
            public ReadOnlyCollection<ExpiringAccessValue> Groups => _groups.AsReadOnly();

            public static PlayerInformation Get(string id) => _playerInformationCollection.FirstOrDefault(p => p.Id == id);

            public static PlayerInformation GetOrCreate(IPlayer player)
            {
                PlayerInformation information = Get(player.Id);

                if (information == null)
                {
                    information = new PlayerInformation(player);

                    _playerInformationCollection.Add(information);
                    SaveData(_playerInformationCollection);
                }

                return information;
            }

            #region Permissions

            public void AddPermission(string permission, DateTime expireDate)
            {
                ExpiringAccessValue existingAccess = _permissions.FirstOrDefault(p => p.Value == permission);

                if (existingAccess != null)
                {
                    Interface.CallHook("OnTimedPermissionExtended", Id, permission, existingAccess.ExpireDate - DateTime.UtcNow);

                    existingAccess.ExpireDate += expireDate - DateTime.UtcNow;

                    _plugin.Puts($"{Name} ({Id}) - Permission time extended: {permission} to {existingAccess.ExpireDate - DateTime.UtcNow}");
                }
                else
                {
                    Interface.CallHook("OnTimedPermissionGranted", Id, permission, expireDate - DateTime.UtcNow);

                    _permissions.Add(new ExpiringAccessValue(permission, expireDate));

                    _plugin.permission.GrantUserPermission(Id, permission, null);

                    _plugin.Puts($"{Name} ({Id}) - Permission granted: {permission} for {expireDate - DateTime.UtcNow}");
                }

                SaveData(_playerInformationCollection);
            }

            public void RemovePermission(string permission)
            {
                ExpiringAccessValue accessValue = _permissions.FirstOrDefault(p => p.Value == permission);

                if (accessValue == null)
                    throw new ArgumentException("Player does not have access to the given permission", nameof(permission));

                _permissions.Remove(accessValue);
                _plugin.permission.RevokeUserPermission(Id, accessValue.Value);

                _plugin.Puts($"{Name} ({Id}) - Permission removed: {accessValue.Value}");

                if (_groups.Count == 0 && _permissions.Count == 0)
                    _playerInformationCollection.Remove(this);

                SaveData(_playerInformationCollection);
            }

            #endregion

            #region Groups

            public void AddGroup(string group, DateTime expireDate)
            {
                ExpiringAccessValue existingAccess = _groups.FirstOrDefault(g => g.Value == group);

                if (existingAccess != null)
                {
                    Interface.CallHook("OnTimedGroupExtended", Id, group, existingAccess.ExpireDate - DateTime.UtcNow);

                    existingAccess.ExpireDate += expireDate - DateTime.UtcNow;

                    _plugin.Puts($"{Name} ({Id}) - Group time extended: {group} to {existingAccess.ExpireDate - DateTime.UtcNow}");
                }
                else
                {
                    Interface.CallHook("OnTimedGroupAdded", Id, group, expireDate - DateTime.UtcNow);

                    _groups.Add(new ExpiringAccessValue(group, expireDate));

                    _plugin.permission.AddUserGroup(Id, group);

                    _plugin.Puts($"{Name} ({Id}) - Added to group: {group} for {expireDate - DateTime.UtcNow}");
                }

                SaveData(_playerInformationCollection);
            }

            public void RemoveGroup(string group)
            {
                var accessValue = _groups.FirstOrDefault(g => g.Value == group);

                if (accessValue == null)
                    throw new ArgumentException("Player does not have access to the given group", nameof(group));

                _groups.Remove(accessValue);
                _plugin.permission.RemoveUserGroup(Id, accessValue.Value);

                _plugin.Puts($"{Name} ({Id}) - Removed from group: {accessValue.Value}");

                if (_groups.Count == 0 && _permissions.Count == 0)
                    _playerInformationCollection.Remove(this);

                SaveData(_playerInformationCollection);
            }

            #endregion

            #region Other

            public void RemoveAllAccess()
            {
                foreach (ExpiringAccessValue permission in _permissions)
                    _plugin.permission.RevokeUserPermission(Id, permission.Value);

                _permissions.Clear();

                foreach (ExpiringAccessValue group in _groups)
                    _plugin.permission.RemoveUserGroup(Id, group.Value);

                _groups.Clear();
            }

            public void EnsureAllAccess()
            {
                foreach (ExpiringAccessValue permission in _permissions)
                    _plugin.permission.GrantUserPermission(Id, permission.Value, null);

                foreach (ExpiringAccessValue group in _groups)
                    _plugin.permission.AddUserGroup(Id, group.Value);
            }

            public void Update()
            {
                foreach (ExpiringAccessValue permission in _permissions.ToList())
                    if (permission.IsExpired)
                        RemovePermission(permission.Value);

                foreach (ExpiringAccessValue group in _groups.ToList())
                    if (group.IsExpired)
                        RemoveGroup(group.Value);
            }

            #endregion

            public override int GetHashCode() => Id.GetHashCode();

            private PlayerInformation(IPlayer player)
            {
                Id = player.Id;
                Name = player.Name;
            }

            [JsonConstructor]
            private PlayerInformation()
            {
            }
        }

        private class ExpiringAccessValue
        {
            [JsonProperty]
            public string Value { get; private set; }

            [JsonProperty]
            public DateTime ExpireDate { get; set; }

            [JsonIgnore]
            public bool IsExpired => DateTime.Compare(DateTime.UtcNow, ExpireDate) > 0;

            public override int GetHashCode() => Value.GetHashCode();

            public ExpiringAccessValue(string value, DateTime expireDate)
            {
                Value = value;
                ExpireDate = expireDate;
            }

            public ExpiringAccessValue()
            {
            }
        }

        #endregion
    }
}

// --- End of file: TimedPermissions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/temporary-bags ---
// --- Original File Path: T/TemporaryBags/TemporaryBags.cs ---

﻿using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("TemporaryBags", "Kappasaurus", "1.0.1")]

    class TemporaryBags : RustPlugin
    {
        private const string SleepingBag = "sleepingbag_leather_deployed";
        private const string ExcludePermission = "temporarybags.exclude";

        void Init()
        {
            permission.RegisterPermission("temporarybags.exclude", this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Remove Message"] = "<size=12>Bag removed...</size>",
                ["Place Message"] = "<size=12>Please notem sleeping bags are <i>one time use</i> items, if you'd like an infinite respawn points make a bed.</size>"

            }, this);
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            var player = plan.GetOwnerPlayer();
            var entity = go.ToBaseEntity();

            if (permission.UserHasPermission(player.UserIDString, ExcludePermission))
                return;

            if (entity.ShortPrefabName == "sleepingbag_leather_deployed")
                PrintToChat(player, lang.GetMessage("Place Message", this, player.UserIDString));
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, ExcludePermission))
                return;

            var entities = new List<BaseEntity>();
            Vis.Entities(player.transform.position, 0.1f, entities);

            foreach (var entity in entities)
                if (entity.ShortPrefabName == SleepingBag)
                {
                    PrintToChat(lang.GetMessage("Remove Message", this, player.UserIDString));
                    entity.Kill();
                    return;
                }
        }
    }
}

// --- End of file: TemporaryBags.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/timed-workbench ---
// --- Original File Path: T/TimedWorkbench/TimedWorkbench.cs ---

﻿using Oxide.Core;
using Oxide.Core.Configuration;

using Newtonsoft.Json;

using System;
using System.IO;

using System.Diagnostics;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Timed Workbench", "DizzasTeR", "1.0.4")]
    [Description("Unlocks Workbenches level 2 and 3 later in the wipe")]
    class TimedWorkbench : CovalencePlugin
    {
        #region Vars
        private Configuration config;

        private Timer timer_WB2, timer_WB3;

        private long ID_WORKBENCH_LEVEL_2 = -41896755;
        private long ID_WORKBENCH_LEVEL_3 = -1607980696;

        #region Permission Strings
        private string PERMISSION_ADMIN     = "timedworkbench.admin";
        private string PERMISSION_SKIPLOCK  = "timedworkbench.skiplock";
        private string PERMISSION_INFO      = "timedworkbench.info";
        private string PERMISSION_TOGGLE    = "timedworkbench.toggle";
        private string PERMISSION_MODIFY    = "timedworkbench.modifytime";
        private string PERMISSION_RELOAD    = "timedworkbench.reload";
        private string PERMISSION_WIPE      = "timedworkbench.wipe";
        #endregion Permission Strings
        #endregion Vars

        #region Localization
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "No access",
                ["SyntaxError"] = "Syntax Error!",
                ["RequestPBInfo"] = "Timed Mode {0}. WB2 {1}. WB3 {2}",
                ["ToggleResponse"] = "TimedWorkbench is now {0}",
                //
                ["ModifiedWorkbench"] = "WB {0} now unlocks in {1} seconds after wipe",
                ["InvalidWorkbench"] = "Invalid workbench specified!",
                //["CannotCraft"] = "Cannot craft this item ({0} seconds remaining)",
                //
                ["ReloadConfig"] = "Config has been reloaded",
                ["PluginWipe"] = "Plugin wiped",

            }, this);
        }

        private void SendMessage(IPlayer player, string langCode, params string[] args)
        {
            string msg = string.Format(lang.GetMessage(langCode, this, player.IsServer ? null : player.Id), args);
            if (player.IsServer)
                msg = msg.Replace("<color=red>", "").Replace("<color=green>", "").Replace("</color>", "");

            player.Reply(msg);
        }
        #endregion Localization

        #region Hooks
        private void Init()
        {
            // Permissions
            permission.RegisterPermission(PERMISSION_ADMIN, this);
            permission.RegisterPermission(PERMISSION_SKIPLOCK, this);
            permission.RegisterPermission(PERMISSION_INFO, this);
            permission.RegisterPermission(PERMISSION_TOGGLE, this);
            permission.RegisterPermission(PERMISSION_MODIFY, this);
            permission.RegisterPermission(PERMISSION_RELOAD, this);
            permission.RegisterPermission(PERMISSION_WIPE, this);

            permission.GrantGroupPermission("admin", PERMISSION_ADMIN, this);

            foreach (ItemBlueprint bp in ItemManager.GetBlueprints())
            {
                if (bp.targetItem.itemid == ID_WORKBENCH_LEVEL_2 || bp.targetItem.itemid == ID_WORKBENCH_LEVEL_3)
                {
                    bp.defaultBlueprint = true;
                    bp.userCraftable = true;
                }
            }
        }

        private void OnNewSave(string filename)
        {
            // Update the LastWipe in config as a new wipe was detected.
            config.LastWipe = DateTime.Now;
            SaveConfig();
        }

        private bool CanCraft(PlayerBlueprints playerBlueprints, ItemDefinition itemDefinition, int skinItemId)
        {
            if (config.TimedMode && itemDefinition.itemid == ID_WORKBENCH_LEVEL_2 || itemDefinition.itemid == ID_WORKBENCH_LEVEL_3)
            {
                IPlayer player = playerBlueprints._baseEntity.IPlayer;
                if (player != null && !player.HasPermission(PERMISSION_SKIPLOCK))
                {
                    double secondsPassed = (DateTime.Now - config.LastWipe).TotalSeconds;
                    double secondsLeft = (itemDefinition.itemid == ID_WORKBENCH_LEVEL_2 ? config.WB2Seconds : config.WB3Seconds) - secondsPassed;
                    if (secondsLeft > 0)
                        return false;
                }
            }
            return true;
        }

        #endregion Hooks

        #region Commands

        [Command("twinfo")]
        private void CMD_PassiveBenchInfo(IPlayer player, string command, string[] args)
        {
            if (!player.IsServer && !player.HasPermission(PERMISSION_ADMIN) && !player.HasPermission(PERMISSION_INFO))
            {
                SendMessage(player, "NoPermission");
                return;
            }

            string PassiveMode = config.TimedMode ? "<color=green>on</color>" : "<color=red>off</color>";
            string WB2Status = (DateTime.Now - config.LastWipe).TotalSeconds < config.WB2Seconds ? "<color=red>locked</color>" : "<color=green>unlocked</color>";
            string WB3Status = (DateTime.Now - config.LastWipe).TotalSeconds < config.WB3Seconds ? "<color=red>locked</color>" : "<color=green>unlocked</color>";
            SendMessage(player, "RequestPBInfo", PassiveMode, WB2Status, WB3Status);
        }

        [Command("twtoggle")]
        private void CMD_Toggle(IPlayer player, string command, string[] args)
        {
            if (!player.IsServer && !player.HasPermission(PERMISSION_ADMIN) && !player.HasPermission(PERMISSION_TOGGLE))
            {
                SendMessage(player, "NoPermission");
                return;
            }

            config.TimedMode = !config.TimedMode;
            SaveConfig();

            string status = config.TimedMode ? "<color=green>enabled</color>" : "<color=red>disabled</color>";
            SendMessage(player, "ToggleResponse", status);
        }

        [Command("setwbtime")]
        private void CMD_SetWBTime(IPlayer player, string command, string[] args)
        {
            if (!player.IsServer && !player.HasPermission(PERMISSION_ADMIN) && !player.HasPermission(PERMISSION_MODIFY))
            {
                SendMessage(player, "NoPermission");
                return;
            }

            if (args.Length < 2)
            {
                player.Reply(string.Format(lang.GetMessage("SyntaxError", this, player.Id), command));
                return;
            }

            if (args[0] != "2" && args[0] != "3")
            {
                player.Reply(string.Format(lang.GetMessage("InvalidWorkbench", this, player.Id), command));
                return;
            }

            long seconds = Convert.ToInt64(args[1]);
            if (seconds <= 0)
                seconds = 1;

            if (args[0] == "2")
                config.WB2Seconds = seconds;
            else // if its not 2, then its 3.
                config.WB3Seconds = seconds;

            SaveConfig();
            SendMessage(player, "ModifiedWorkbench", args[0], args[1]);
        }

        [Command("twreload")]
        private void CMD_Reload(IPlayer player, string command, string[] args)
        {
            if (!player.IsServer && !player.HasPermission(PERMISSION_ADMIN) && !player.HasPermission(PERMISSION_RELOAD))
            {
                SendMessage(player, "NoPermission");
                return;
            }

            LoadConfig();
            SendMessage(player, "ReloadConfig");
        }

        [Command("twwipe")]
        private void CMD_Wiped(IPlayer player, string command, string[] args)
        {
            if (!player.IsServer && !player.HasPermission(PERMISSION_ADMIN) && !player.HasPermission(PERMISSION_WIPE))
            {
                SendMessage(player, "NoPermission");
                return;
            }

            // update LastWipe for plugin
            config.LastWipe = DateTime.Now;
            SaveConfig();

            SendMessage(player, "PluginWipe");
        }

        #endregion Commands

        #region Configuration
        public class Configuration
        {
            [JsonProperty(PropertyName = "Timed Mode")]
            public bool TimedMode { get; set; } = true;

            [JsonProperty(PropertyName = "Last Wipe")]
            public DateTime LastWipe { get; set; } = DateTime.Now;

            [JsonProperty(PropertyName = "How many seconds after wipe to unlock WB2")]
            public long WB2Seconds { get; set; } = 60 * 60 * 24 * 2;

            [JsonProperty(PropertyName = "How many seconds after wipe to unlock WB3")]
            public long WB3Seconds { get; set; } = 60 * 60 * 24 * 3;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            Puts($"Config file not found, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration
    }
}

// --- End of file: TimedWorkbench.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/the-gathering ---
// --- Original File Path: T/TheGathering/TheGathering.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("The Gathering", "Razor", "2.1.0")]
    [Description("Gives players a gather multiplier for wearing certain clothes")]
    public class TheGathering : RustPlugin
    {
        public bool debug = false;
        ItemTypes itemData;
        private DynamicConfigFile ITEMDATA;
        private const string adminAllow = "thegathering.admin";
        static TheGathering _instance;
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Nope"] = "<color=#ce422b>You are not allowed to use this command</color>",
                ["Help"] = "<color=#ce422b>Error: /tg <add/remove></color>",
                ["HelpAdd"] = "<color=#ce422b>Error: /tg add <\"Item Custom Name\"> <itemID> <skinID> do not forget the quotes around your custom name.</color>",
                ["SkinIdUsed"] = "<color=#ce422b>SkinID {0} is already in use. Edit it in the datafile.</color>",
                ["ItemAdded"] = "<color=#ce422b>You just added a new item with skinID {0} to the datafile</color>",
                ["ItemRemoved"] = "<color=#ce422b>You have just removed skinID {0}</color>",
                ["ItemRemovedNoFind"] = "<color=#ce422b>We could not find skinID {0} in the datafile</color>",
                ["HelpRemove"] = "<color=#ce422b>Error: /tg remove <skinID></color>",
                ["item"] = "<color=#ce422b>You just gave yourself {0} </color>",
                ["Noitem"] = "<color=#ce422b>Could not find item {0} </color>"

            }, this);
        }

        private void RegisterPermissions()
        {
            permission.RegisterPermission(adminAllow, this);
        }
         
        void Unload() => _instance = null;

        void Init()
        {
            ITEMDATA = Interface.Oxide.DataFileSystem.GetFile(Name + "/Items");
            LoadData();
            RegisterPermissions();
            SaveItemData();
        }

        void LoadData()
        {
            try
            {
                itemData = Interface.Oxide.DataFileSystem.ReadObject<ItemTypes>(Name + "/Items");
            }
            catch
            {
                Puts("Couldn't load item data, creating new Item file");
                itemData = new ItemTypes();
            }
        }

        class ItemTypes
        {
            public Dictionary<ulong, ItemInfo> Items = new Dictionary<ulong, ItemInfo>();
        }

        class ItemInfo
        {
            public string ItemName;
            public int ItemID;
            public int RateMultiplier;
            public int SpawnChance;
            public bool SpawnInContainers;
            public float ConditionLoss;
            public List<string> LootContainers = new List<string>();
        }

        void SaveItemData()
        {
            ITEMDATA.WriteObject(itemData);
        }

        void OnLootSpawn(LootContainer container)
        {
            if (container.ShortPrefabName == "stocking_large_deployed" ||
                container.ShortPrefabName == "stocking_small_deployed") return;
            foreach (var itemsConfig in itemData.Items)
            {
                foreach (var LootContainers in itemData.Items[itemsConfig.Key].LootContainers)
                {
                    if (LootContainers.Contains(container.ShortPrefabName))
                    {
                        if (!itemData.Items[itemsConfig.Key].SpawnInContainers) return;
                        if (UnityEngine.Random.Range(0, 100) < itemData.Items[itemsConfig.Key].SpawnChance)
                        {
                            if (container.inventory.itemList.Count == container.inventory.capacity)
                            {
                                container.inventory.capacity++;
                            }
                            var theitem = itemData.Items[itemsConfig.Key].ItemID;
                            Item i = ItemManager.CreateByItemID(theitem, 1, itemsConfig.Key);
                            i.name = itemData.Items[itemsConfig.Key].ItemName;
                            i.MoveToContainer(container.inventory);
                            if (debug) PrintWarning(itemData.Items[itemsConfig.Key].ItemName + " Spawned in container " + LootContainers);
                        }
                    }
                }
            }
        }

        private bool? CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (item.GetItem() == null || targetItem.GetItem() == null)
                return null;

            if (itemData.Items.ContainsKey(item.GetItem().skin))
                if (item.GetItem().skin != targetItem.GetItem().skin)
                    return false;

            return null;
        }

        private bool? CanStackItem(Item item, Item targetItem)
        {
            if (itemData.Items.ContainsKey(item.skin))
                if (item.skin != targetItem.skin)
                    return false;

            return null;
        }

        void OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity entity)
        {
            int totals = 0;
            foreach (Item customware in player.inventory.containerWear.itemList.ToList())
            {
                if (itemData.Items.ContainsKey(customware.skin))
                {
                    if (!customware.hasCondition)
                        totals = totals + itemData.Items[customware.skin].RateMultiplier;
                    else if (customware.hasCondition && customware.condition != 0)
                    {
                        totals = totals + itemData.Items[customware.skin].RateMultiplier;
                        customware.LoseCondition(itemData.Items[customware.skin].ConditionLoss);
                    }
                }
            }
            if (totals == 0) return;
            item.amount *= totals;
        }

        void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (player == null || dispenser == null || item == null) return;
            int totals = 0;
            foreach (Item customware in player.inventory.containerWear.itemList.ToList())
            {
                if (itemData.Items.ContainsKey(customware.skin))
                {
                    if (!customware.hasCondition)
                        totals = totals + itemData.Items[customware.skin].RateMultiplier;
                    else if (customware.hasCondition && customware.condition != 0)
                    {
                        totals = totals + itemData.Items[customware.skin].RateMultiplier;
                        customware.LoseCondition(itemData.Items[customware.skin].ConditionLoss);
                    }
                }
            }
            if (totals == 0) return;
            item.amount *= totals;
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (dispenser == null || player == null) return;
            int totals = 0;
            foreach (Item customware in player.inventory.containerWear.itemList.ToList())
            {
                if (itemData.Items.ContainsKey(customware.skin))
                {
                    if (!customware.hasCondition)
                        totals = totals + itemData.Items[customware.skin].RateMultiplier;
                    else if (customware.hasCondition && customware.condition != 0)
                    {
                        totals = totals + itemData.Items[customware.skin].RateMultiplier;
                        customware.LoseCondition(itemData.Items[customware.skin].ConditionLoss);
                    }
                }
            }
            if (totals == 0) return;
            item.amount *= totals;
        }

        [ChatCommand("tg")]
        void MasterGatherItems(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, adminAllow))
            {
                SendReply(player, lang.GetMessage("Nope", this, player.UserIDString));
                return;
            }

            if (args.Length <= 0)
            {
                SendReply(player, lang.GetMessage("Help", this, player.UserIDString));
                return;
            }

            switch (args[0].ToLower())
            {
                case "add":
                    if (args.Length != 4)
                    {
                        SendReply(player, lang.GetMessage("HelpAdd", this, player.UserIDString));
                        return;
                    }

                    var ids = default(int);
                    if (!int.TryParse(args[2], out ids))
                    {
                        SendReply(player, lang.GetMessage("HelpAdd", this, player.UserIDString));
                        return;
                    }

                    var Skinids = default(ulong);
                    if (!ulong.TryParse(args[3], out Skinids))
                    {
                        SendReply(player, lang.GetMessage("HelpAdd", this, player.UserIDString));
                        return;
                    }

                    var setup = new ItemInfo { ItemName = args[1], RateMultiplier = 2, SpawnChance = 2, SpawnInContainers = false, ItemID = ids, LootContainers = { "crate_basic", "crate_normal", "crate_normal_2" } };
                    if (itemData.Items.ContainsKey(Skinids))
                    {
                        SendReply(player, lang.GetMessage("SkinIdUsed", this, player.UserIDString), Skinids.ToString());
                        return;
                    }
                    else
                    {
                        itemData.Items.Add(Skinids, setup);
                        SaveItemData();
                        SendReply(player, lang.GetMessage("ItemAdded", this, player.UserIDString), Skinids.ToString());
                    }
                    return;

                case "remove":

                    if (args.Length != 2)
                    {
                        SendReply(player, lang.GetMessage("HelpAdd", this, player.UserIDString));
                        return;
                    }
                    var Skinid = default(ulong);
                    if (!ulong.TryParse(args[1], out Skinid))
                    {
                        SendReply(player, lang.GetMessage("HelpRemove", this, player.UserIDString));
                        return;
                    }
                    if (itemData.Items.ContainsKey(Skinid))
                    {
                        itemData.Items.Remove(Skinid);
                        SaveItemData();
                        SendReply(player, lang.GetMessage("ItemRemoved", this, player.UserIDString), Skinid.ToString());
                    }
                    else
                    {
                        SendReply(player, lang.GetMessage("ItemRemovedNoFind", this, player.UserIDString), Skinid.ToString());
                    }
                    return;

                case "get":
                    if (args.Length != 2)
                    {
                        return;
                    }
                    string getItem = args[1].ToLower();

                    foreach (var itemconfig in itemData.Items.ToList())
                    {
                        if (itemconfig.Value == null)
                            continue;

                        if (itemconfig.Value.ItemName.ToLower() == getItem)
                        {
                            int itemid = itemconfig.Value.ItemID;
                            string name = itemconfig.Value.ItemName;
                            var item = ItemManager.CreateByItemID(itemid, 1, itemconfig.Key);
                            if (item == null)
                                continue;
                            item.name = name;
                            player.GiveItem(item);
                            SendReply(player, lang.GetMessage("item", this, player.UserIDString), getItem);
                            return;
                        }
                    }
                    SendReply(player, lang.GetMessage("Noitem", this, player.UserIDString), getItem);
                    return;

                    SendReply(player, lang.GetMessage("Help", this, player.UserIDString));
                default:
                    break;
            }
        }
    }
}



// --- End of file: TheGathering.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/turret-pacifier ---
// --- Original File Path: T/TurretPacifier/TurretPacifier.cs ---

namespace Oxide.Plugins
{
    [Info("Turret Pacifier", "The Friendly Chap", "0.0.3")]
    [Description("Prevents AutoTurret from targeting innocents")]
    class TurretPacifier : RustPlugin
    {
        private object CanBeTargeted(BasePlayer player, AutoTurret turret)
        {
            return !player.IsNpc && !player.IsHostile() ? false : (object)null;
        }
    }
}


// --- End of file: TurretPacifier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/target-practice ---
// --- Original File Path: T/TargetPractice/TargetPractice.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("TargetPractice", "k1lly0u", "0.2.2")]
    class TargetPractice : RustPlugin
    {
        #region Fields
        private StatisticsData statistics;

        private Hash<ulong, Queue<TargetHitInfo>> playerUI = new Hash<ulong, Queue<TargetHitInfo>>();

        private readonly Vector3 localBullseye = new Vector3(-0.02269989f, 0.7262592f, 0.2032242f);

        private const float RADIUS_BULLSEYE = 0.03f;
        private const float RADIUS_INNER_1 = 0.11f;
        private const float RADIUS_INNER_2 = 0.19f;
        private const float RADIUS_INNER_3 = 0.29f;
        private const float RADIUS_OUTER = 0.36f;

        private const uint TARGET_BONE_ID = 365102685;
        private const uint BULLSEYE_BONE_ID = 2528224745;

        private const string POPUP_ELEMENT = "tpui.popup.{0}";
        private const string POPUP_FORMAT = "{0}pts @ {1}m";

        private const string ADMIN_PERMISSION = "targetpractice.admin";

        private enum Hit { Bullseye, Yellow, Red, Blue, Edge }

        private static string[] HitColors;

        private FieldInfo _knockdownHealth = typeof(ReactiveTarget).GetField("knockdownHealth", BindingFlags.Public | BindingFlags.NonPublic);
        private FieldInfo _lastToggleTime = typeof(ReactiveTarget).GetField("lastToggleTime", BindingFlags.Public | BindingFlags.NonPublic);
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            lang.RegisterMessages(Messages, this);

            Unsubscribe(nameof(OnEntitySpawned));

            permission.RegisterPermission(ADMIN_PERMISSION, this);

            HitColors = new string[5];
            HitColors[0] = UI.Color("95c055", 0.95f);
            HitColors[1] = UI.Color("dac15f", 0.95f);
            HitColors[2] = UI.Color("cb3427", 0.95f);
            HitColors[3] = UI.Color("30778a", 0.95f);
            HitColors[4] = UI.Color("72544b", 0.95f);
        }

        private void OnServerInitialized()
        {
            LoadData();

            if (Configuration.Target.KnockdownHealth != 100f) 
            {
                Subscribe(nameof(OnEntitySpawned));
                foreach (BaseNetworkable entity in BaseNetworkable.serverEntities)
                {
                    if (entity is ReactiveTarget)
                        OnEntitySpawned(entity as ReactiveTarget);
                }
            }
        }

        private void OnServerSave() => SaveData();

        private void OnEntitySpawned(ReactiveTarget reactiveTarget) => _knockdownHealth.SetValue(reactiveTarget, Configuration.Target.KnockdownHealth);

        private void OnEntityTakeDamage(ReactiveTarget reactiveTarget, HitInfo info)
        {
            if (info.HitBone != TARGET_BONE_ID && info.HitBone != BULLSEYE_BONE_ID)
                return;

            if (info.InitiatorPlayer == null)
                return;
            
            BasePlayer player = info.InitiatorPlayer;

            Item weapon = player.GetActiveItem();
            if (weapon == null || !Configuration.Weapons.Contains(weapon.info.shortname))
                return;

            Hit hit;
            float score = 0;
            
            if (info.HitBone.Equals(BULLSEYE_BONE_ID))
            {
                hit = Hit.Bullseye;
                score = Configuration.Scores[hit];
            }
            else
            {
                Vector3 bullseyeWorld = reactiveTarget.transform.TransformPoint(localBullseye);

                score = EvaluateScore(Vector3.Distance(bullseyeWorld, info.HitPositionWorld), out hit);
            }

            if (Configuration.Target.ResetTime != 6f)
            {
                float knockdownHealth = (float)_knockdownHealth.GetValue(reactiveTarget);

                if (knockdownHealth <= 0f)
                {
                    reactiveTarget.CancelInvoke(reactiveTarget.ResetTarget);
                    reactiveTarget.Invoke(() => ResetTarget(reactiveTarget), Configuration.Target.ResetTime);
                }
            }

            double d = Math.Round(Vector3Ex.Distance2D(player.transform.position, reactiveTarget.transform.position), 2, MidpointRounding.AwayFromZero);
            TargetHitInfo targetHitInfo = new TargetHitInfo(player.userID, hit, score, d, FormatWeaponName(weapon));

            GetUIComponent(player).Enqueue(targetHitInfo);

            if (statistics.AddScore(player, targetHitInfo) && Configuration.Notify)
                BroadcastTopScore(player.displayName, targetHitInfo);
        }

        private void Unload()
        {
            foreach (PlayerInterface ui in UnityEngine.Object.FindObjectsOfType<PlayerInterface>())
                UnityEngine.Object.Destroy(ui);

            HitColors = null;
            Configuration = null;
        }
        #endregion

        #region Functions
        private float EvaluateScore(float f, out Hit hit)
        {
            if (f < RADIUS_BULLSEYE)            
                hit = Hit.Bullseye;  
            else if (f < RADIUS_INNER_1)            
                hit = Hit.Yellow;            
            else if (f < RADIUS_INNER_2)            
                hit = Hit.Red;            
            else if (f < RADIUS_INNER_3)            
                hit = Hit.Blue;            
            else hit = Hit.Edge;

            return Configuration.Scores[hit];
        }

        private void ResetTarget(ReactiveTarget reactiveTarget)
        {
            if (!reactiveTarget.IsKnockedDown() || !reactiveTarget.CanToggle())            
                return;

            _lastToggleTime.SetValue(reactiveTarget, UnityEngine.Time.realtimeSinceStartup);
            reactiveTarget.SetFlag(BaseEntity.Flags.On, true, false, true);
            _knockdownHealth.SetValue(reactiveTarget, Configuration.Target.KnockdownHealth);
            reactiveTarget.MarkDirtyForceUpdateOutputs();
        }

        private string FormatWeaponName(Item item)
        {            
            string str = item.info.displayName.english;

            if (item.contents?.itemList?.Count > 0)            
                str += string.Format(" ({0})", item.contents?.itemList.Select(x => x.info.displayName.english).ToSentence());
            
            return str;
        }

        private void ChatMessage(BasePlayer player, string key, params object[] args)
        {
            if (args?.Length == 0)
                player.ChatMessage(Msg(key, player.UserIDString));
            else player.ChatMessage(string.Format(Msg(key, player.UserIDString), args));
        }

        private void BroadcastTopScore(string playerName, TargetHitInfo targetHitInfo)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                string score = string.Format(Msg("Notification.ServerScoreFormat", player.UserIDString), player.displayName, targetHitInfo.distance, (Hit)targetHitInfo.hit, targetHitInfo.score, targetHitInfo.weapon);

                ChatMessage(player, "Notification.NewTopScore", score);
            }
        }
        #endregion

        #region Player UI Component
        private PlayerInterface GetUIComponent(BasePlayer player) =>  player.GetComponent<PlayerInterface>() ?? player.gameObject.AddComponent<PlayerInterface>();
        
        private class PlayerInterface : MonoBehaviour
        {
            internal BasePlayer Player { get; private set; }

            internal List<TimedPopup> queue = Facepunch.Pool.GetList<TimedPopup>();

            internal List<string> elements = Facepunch.Pool.GetList<string>();

            private void Awake()
            {
                Player = GetComponent<BasePlayer>();
            }

            private void OnDestroy()
            {
                elements.ForEach(x => CuiHelper.DestroyUi(Player, x));

                Facepunch.Pool.FreeList(ref queue);
                Facepunch.Pool.FreeList(ref elements);
            }

            internal void Enqueue(TargetHitInfo targetHitInfo)
            {
                queue.Add(new TimedPopup(UnityEngine.Time.time + Configuration.Popup.Lifetime, targetHitInfo));
                
                if (elements.Count < Configuration.Popup.Limit)
                {                    
                    string element = CreatePopup(Player, targetHitInfo, elements.Count);
                    elements.Add(element);

                    if (!InvokeHandler.IsInvoking(Player, TimedRefresh))
                        InvokeHandler.Invoke(Player, TimedRefresh, Configuration.Popup.Lifetime);
                }
            }

            private void TimedRefresh()
            {
                elements.ForEach(x => CuiHelper.DestroyUi(Player, x));
                elements.Clear();

                float time = UnityEngine.Time.time;
                for (int i = queue.Count - 1; i >= 0; i--)
                {
                    if (time >= queue[i].expiry)
                        queue.RemoveAt(i);
                }

                if (queue.Count == 0)
                {
                    Destroy(this);
                    return;
                }

                float nextRefreshTime = float.PositiveInfinity;

                for (int i = 0; i < Mathf.Min(queue.Count, Configuration.Popup.Limit); i++)
                {
                    TimedPopup timedPopup = queue[i];
                    if (timedPopup.expiry < nextRefreshTime)
                        nextRefreshTime = timedPopup.expiry - time;

                    string element = CreatePopup(Player, timedPopup.targetHitInfo, i);
                    elements.Add(element);
                }

                InvokeHandler.Invoke(Player, TimedRefresh, nextRefreshTime);
            }

            internal struct TimedPopup
            {
                internal float expiry;
                internal TargetHitInfo targetHitInfo;

                internal TimedPopup(float expiry, TargetHitInfo targetHitInfo)
                {
                    this.expiry = expiry;
                    this.targetHitInfo = targetHitInfo;
                }
            }
        }
        #endregion

        #region UI         
        public static class UI
        {
            public static CuiElementContainer Container(string panelName, string color, UI4 dimensions, bool useCursor = false, string parent = "Overlay")
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"},
                            RectTransform = {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax()},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName.ToString()
                    }
                };
                return container;
            }

            public static void Image(ref CuiElementContainer container, string panel, string url, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent { Url = url },
                        new CuiRectTransformComponent { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }

            public static void Panel(ref CuiElementContainer container, string panel, string color, UI4 dimensions)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    CursorEnabled = false
                },
                panel.ToString());
            }

            public static void Label(ref CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text, Font = "robotocondensed-regular.ttf" },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel.ToString());

            }

            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.Substring(1);
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }

        public class UI4
        {
            public float xMin, yMin, xMax, yMax;
            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }
            public string GetMin() => $"{xMin} {yMin}";
            public string GetMax() => $"{xMax} {yMax}";
        }
        #endregion

        #region UI Creation      
        private static readonly UI4 IconPosition = new UI4(0f, 0f, 0.1f, 1f);
        private static readonly UI4 TextPosition = new UI4(0.15f, 0f, 1f, 1f);

        private static string CreatePopup(BasePlayer player, TargetHitInfo info, int position)
        {
            string panel = string.Format(POPUP_ELEMENT, position);

            CuiElementContainer container = UI.Container(panel, HitColors[0], CalculateAnchor(position));

            if (info.IsBullseye())
                UI.Image(ref container, panel, Configuration.Bullseye, IconPosition);
            else UI.Panel(ref container, panel, HitColors[(int)info.hit], IconPosition);

            UI.Label(ref container, panel, string.Format(POPUP_FORMAT, info.score, info.distance), 12, TextPosition, TextAnchor.MiddleLeft);

            CuiHelper.AddUi(player, container);
            return panel;
        }

        private static UI4 CalculateAnchor(int index, float xMin = 0.839f, float yMin = 0.208f, float xDim = 0.148f, float yDim = 0.027f, float spacing = 0.01f)
        {
            float y = yMin + ((yDim + spacing) * index);
            return new UI4(xMin, y, xMin + xDim, y + yDim);
        }

        [ProtoContract]
        private struct TargetHitInfo
        {
            [ProtoMember(1)]
            public string userId;

            [ProtoMember(2)]
            public int hit;

            [ProtoMember(3)]
            public float score;

            [ProtoMember(4)]
            public double distance;

            [ProtoMember(5)]
            public string weapon;

            [ProtoMember(6)]
            public double rangedScore;

            public TargetHitInfo(ulong userId, Hit hit, float score, double distance, string weapon)
            {
                this.userId = userId.ToString();
                this.hit = (int)hit;
                this.score = score;
                this.distance = distance;
                this.weapon = weapon;

                rangedScore = distance * Configuration.Scores[hit];
            }

            internal bool IsBullseye() => (Hit)hit == Hit.Bullseye;
        }
        #endregion

        #region Commands
        [ChatCommand("target")]
        private void cmdTarget(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                ChatMessage(player, "Message.Prefix");
                ChatMessage(player, "Chat.Help1");
                ChatMessage(player, "Chat.Help2");
                ChatMessage(player, "Chat.Help4");

                if (permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION))
                    ChatMessage(player, "Chat.Help3");

                return;
            }

            switch (args[0].ToLower())
            {
                case "top":
                    {
                        List<TargetHitInfo> list = statistics._sortedScores;
                        if (list.Count > 0)
                        {
                            string scores = string.Empty;

                            for (int i = 0; i < Mathf.Min(10, list.Count); i++)
                            {
                                TargetHitInfo targetHitInfo = list[i];

                                scores += string.Format(Msg("Notification.ServerScoreFormat", player.UserIDString), covalence.Players.FindPlayerById(targetHitInfo.userId).Name ?? targetHitInfo.userId, targetHitInfo.distance, (Hit)targetHitInfo.hit, targetHitInfo.score, targetHitInfo.weapon);
                            }

                            ChatMessage(player, "Notification.TopServer", scores);
                        }
                        else ChatMessage(player, "Notification.NoScores");
                    }
                    return;

                case "pb":
                    {
                        List<TargetHitInfo> list;
                        if (statistics.GetUserTopHits(player.userID, out list))
                        {
                            string scores = string.Empty;

                            for (int i = 0; i < Mathf.Min(10, list.Count); i++)
                            {
                                TargetHitInfo targetHitInfo = list[i];

                                scores += string.Format(Msg("Notification.PBScoreFormat", player.UserIDString), targetHitInfo.distance, (Hit)targetHitInfo.hit, targetHitInfo.score, targetHitInfo.weapon);
                            }

                            ChatMessage(player, "Notification.TopPB", scores);
                        }
                        else ChatMessage(player, "Notification.NoScores");
                    }
                    return;

                case "scores":
                    {
                        ulong userId = 0UL;
                        string displayName = string.Empty;
                        if (args.Length > 1)
                        {
                            Core.Libraries.Covalence.IPlayer iPlayer = covalence.Players.FindPlayer(args[1]);
                            if (iPlayer != null)
                            {
                                Debug.Log("found player");
                                userId = ulong.Parse(iPlayer.Id);
                                displayName = iPlayer.Name;
                            }
                        }
                        else
                        {
                            userId = player.userID;
                            displayName = player.displayName;
                        }

                        if (userId == 0UL)
                        {
                            ChatMessage(player, "Notification.NoUserFound", args[1]);
                            return;
                        }

                        string scoreStr = Msg("Notification.StatsFormat", player.UserIDString);
                        if (statistics.FindUserScores(userId, ref scoreStr))
                            ChatMessage(player, "Notification.StatsForUser", displayName, scoreStr);
                        else ChatMessage(player, "Notification.NoDataFound", displayName);
                    }
                    return;

                case "wipe":
                    if (!permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION))
                        return;

                    statistics._players.Clear();
                    statistics._sortedScores.Clear();
                    SaveData();

                    ChatMessage(player, "Notification.WipedScores");
                    return;

                default:
                    ChatMessage(player, "Notification.InvalidSyntax");
                    break;
            }
        }
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Score Values")]
            public Hash<Hit, float> Scores { get; set; }

            [JsonProperty(PropertyName = "Popup Options")]
            public PopupOptions Popup { get; set; }

            [JsonProperty(PropertyName = "Target Options")]
            public TargetOptions Target { get; set; }

            [JsonProperty(PropertyName = "Send server wide notification if the top server score has been beaten")]
            public bool Notify { get; set; }

            [JsonProperty(PropertyName = "Weapons allowed to be used for scoring")]
            public string[] Weapons { get; set; }

            [JsonProperty(PropertyName = "Bullseye image URL")]
            public string Bullseye { get; set; }

            public class TargetOptions
            {
                [JsonProperty(PropertyName = "Amount of damage to take to be knocked down")]
                public float KnockdownHealth { get; set; }

                [JsonProperty(PropertyName = "Amount of time it takes to reset the target")]
                public float ResetTime { get; set; }
            }

            public class PopupOptions
            {
                [JsonProperty(PropertyName = "Popup lifetime (seconds)")]
                public int Lifetime { get; set; }

                [JsonProperty(PropertyName = "Maximum active popup elements")]
                public int Limit { get; set; }
            }

            public class ScoreValues
            {
                public int Bullseye { get; set; }
                public int Yellow { get; set; }
                public int Red { get; set; }
                public int Blue { get; set; }
                public int Edge { get; set; }
            }
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Notify = true,
                Popup = new ConfigData.PopupOptions
                {
                    Lifetime = 5,
                    Limit = 15,
                },
                Scores = new Hash<Hit, float>
                {
                    [Hit.Bullseye] = 5f,
                    [Hit.Yellow] = 4f,
                    [Hit.Red] = 3f,
                    [Hit.Blue] = 2f,
                    [Hit.Edge] = 1f,
                },               
                Target = new ConfigData.TargetOptions
                {
                    KnockdownHealth = 100f,
                    ResetTime = 6f
                },
                Weapons = new string[]
                {
                    "rifle.ak",
                    "rifle.bolt",
                    "rifle.l96",
                    "rifle.lr300",
                    "rifle.m39",
                    "rifle.semiauto",
                    "lmg.m249",
                    "bow.compound",
                    "bow.hunting",
                    "crossbow",
                    "smg.2",
                    "smg.thompson",
                    "smg.mp5",
                    "pistol.semiauto",
                    "pistol.revolver",
                    "pistol.m92",
                    "pistol.pythn",
                    "pistol.nailgun",                    
                },
                Bullseye = "https://www.chaoscode.io/oxide/Images/bullseye.png",
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (Configuration.Version < new VersionNumber(0, 2, 0))
                Configuration = baseConfig;

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management
        private void SaveData() => ProtoStorage.Save<StatisticsData>(statistics, Title);

        private void LoadData()
        {
            statistics = ProtoStorage.Load<StatisticsData>(Title);

            if (statistics == null || statistics._sortedScores == null || statistics._players == null)
                statistics = new StatisticsData();
        }

        [ProtoContract]
        private class StatisticsData
        {
            [ProtoMember(1)]
            public Hash<ulong, List<TargetHitInfo>> _players = new Hash<ulong, List<TargetHitInfo>>();

            [ProtoMember(2)]
            public List<TargetHitInfo> _sortedScores = new List<TargetHitInfo>();

            [JsonIgnore]
            private CompareScore comparer;

            public StatisticsData()
            {
                comparer = new CompareScore();
            }
            
            public bool AddScore(BasePlayer player, TargetHitInfo targetHitInfo)
            {
                List<TargetHitInfo> list;
                if (!_players.TryGetValue(player.userID, out list))
                    list = _players[player.userID] = new List<TargetHitInfo>();

                int search = list.BinarySearch(targetHitInfo, (IComparer<TargetHitInfo>)comparer);
                if (search < 0)
                    list.Insert(~search, targetHitInfo);

                search = _sortedScores.BinarySearch(targetHitInfo, (IComparer<TargetHitInfo>)comparer);
                if (search < 0)
                    _sortedScores.Insert(~search, targetHitInfo);

                if (~search == 0)
                    return true;

                return false;
            }

            public bool GetUserTopHits(ulong playerId, out List<TargetHitInfo> list) => _players.TryGetValue(playerId, out list);

            public bool FindUserScores(ulong playerId, ref string format)
            {
                List<TargetHitInfo> list;
                if (!_players.TryGetValue(playerId, out list))                                   
                    return false;

                float totalScore = list.Sum(x => x.score);

                format = string.Format(format, string.Format(POPUP_FORMAT, list[0].score, list[0].distance), totalScore, list.Count, (float)list.Sum(x => x.distance) / list.Count, totalScore / list.Count);
                
                return true;
            }
            
            private class CompareScore : IComparer<TargetHitInfo>
            {
                public int Compare(TargetHitInfo a, TargetHitInfo b)
                {
                    if (TargetHitInfo.ReferenceEquals(a, b))
                        return 0;
                    else return a.rangedScore.CompareTo(b.rangedScore) * -1;                    
                }
            }
        }
        #endregion

        #region Localization
        private string Msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Message.Prefix"] = "<color=#ce422b>[ Target Practice ]</color> ",

            ["Chat.Help1"] = "<color=#ce422b>/target top</color> - Display the top 10 scores on the server",
            ["Chat.Help2"] = "<color=#ce422b>/target pb</color> - Display your personal top 10 scores",
            ["Chat.Help3"] = "<color=#ce422b>/target wipe</color> - Wipes all score data",
            ["Chat.Help4"] = "<color=#ce422b>/target scores <opt:playername></color> - Check your stats/score, or enter a players name to view their stats/score",

            ["Notification.InvalidSyntax"] = "Invalid syntax! Type <color=#ce422b>/target</color> for help",
            ["Notification.WipedScores"] = "All scores have been wiped",
            ["Notification.NoScores"] = "You do not have any scores saved",

            ["Notification.TopPB"] = "<color=#ce422b>[ Target Practice ]</color> - Personal Best\n{0}",
            ["Notification.PBScoreFormat"] = "\nDistance: <color=#ce422b>{0}</color> | Hit: <color=#ce422b>{1}</color> | Score: <color=#ce422b>{2}</color>\nWeapon: <color=#ce422b>{3}</color>\n",

            ["Notification.TopServer"] = "<color=#ce422b>[ Target Practice ]</color> - Server Best\n{0}",
            ["Notification.ServerScoreFormat"] = "\n<color=#ce422b>{0}</color> | Distance: <color=#ce422b>{1}</color> | Hit: <color=#ce422b>{2}</color>\nScore: <color=#ce422b>{3}</color> | Weapon: <color=#ce422b>{4}</color>\n",

            ["Notification.NewTopScore"] = "<color=#ce422b>[ Target Practice ]</color> - A new top score has been set!\n{0}",

            ["Notification.NoUserFound"] = "Unable to find player with partial name: <color=#ce422b>{0}</color>",
            ["Notification.NoDataFound"] = "No data saved for player: <color=#ce422b>{0}</color>",
            ["Notification.StatsForUser"] = "<color=#ce422b>[ Target Practice ]</color> - Stats for <color=#ce422b>{0}</color>\n{1}",
            ["Notification.StatsFormat"] = "\nBest Score: <color=#ce422b>{0}</color>\nTotal Score: <color=#ce422b>{1}</color>\nTotal Hits: <color=#ce422b>{2}</color>\nAvg Distance: <color=#ce422b>{3}</color>\nAvg Score: <color=#ce422b>{4}</color>\n",
        };
        #endregion
    }
}


// --- End of file: TargetPractice.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tree-planter ---
// --- Original File Path: T/TreePlanter/TreePlanter.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core.Libraries.Covalence;
using Oxide.Plugins.TreePlanterEx;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Tree Planter", "Bazz3l", "1.2.2")]
    [Description("Buy and plant trees in building authed areas using in-game currency.")]
    public class TreePlanter : CovalencePlugin
    {
        [PluginReference] Plugin ServerRewards, Economics, Clans;

        #region Fields

        private const string PERM_USE = "treeplanter.use";
        private PluginConfig _config;

        #endregion

        #region Config

        protected override void LoadDefaultConfig() => _config = PluginConfig.DefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    throw new JsonException();
                }

                if (_config.ToDictionary().Keys
                    .SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys)) return;

                PrintWarning("Loaded updated config.");

                SaveConfig();
            }
            catch
            {
                PrintWarning("Loaded default config.");

                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        private class PluginConfig
        {
            [JsonProperty("UseServerRewards (use server rewards as currency)")]
            public bool UseServerRewards;

            [JsonProperty("UseEconomics (use economics as currency)")]
            public bool UseEconomics;

            [JsonProperty("UseCurrency (use custom items as currency, by specifying the CurrencyItem)")]
            public bool UseCurrency;

            [JsonProperty("CurrencyItem (set an item id to use as currency, default is set to scrap)")]
            public int CurrencyItem;

            [JsonProperty("CurrencySkinID (set an skin id to use as currency, default is set to 0)")]
            public ulong CurrencySkinID;

            [JsonProperty("EnableOwner (enables owners to chop down trees)")]
            public bool EnableOwner;

            [JsonProperty("EnableClan (enables clan members to chop down trees)")]
            public bool EnableClan;

            [JsonProperty("BlockedAgriItems (specify which items should only be placed in a planter box)")]
            public Dictionary<string, bool> AgriBlocked;

            [JsonProperty("TreeConfigs (list of available trees to purchase)")]
            public List<TreeConfig> TreeConfigs;

            [JsonIgnore]
            private Dictionary<string, TreeConfig> _availableConfigs;

            [JsonIgnore]
            public Dictionary<string, TreeConfig> AvailableConfigs
            {
                get {
                    if (_availableConfigs != null) return _availableConfigs;

                    _availableConfigs = new Dictionary<string, TreeConfig>(StringComparer.InvariantCultureIgnoreCase);

                    TreeConfigs.ForEach(x => _availableConfigs[x.Name] = x);

                    return _availableConfigs;
                }
            }

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    UseServerRewards = false,
                    UseEconomics = false,
                    UseCurrency = true,
                    EnableOwner = false,
                    EnableClan = false,
                    CurrencyItem = -932201673,

                    AgriBlocked = new Dictionary<string, bool>
                    {
                        {"seed.black.berry", true},
                        {"seed.blue.berry", true},
                        {"seed.green.berry", true},
                        {"seed.yellow.berry", true},
                        {"seed.white.berry", true},
                        {"seed.red.berry", true},
                        {"seed.corn", true},
                        {"clone.corn", true},
                        {"seed.pumpkin", true},
                        {"clone.pumpkin", true},
                        {"seed.hemp", true},
                        {"clone.hemp", true}
                    },

                    TreeConfigs = new List<TreeConfig>
                    {
                        new TreeConfig("oak a",
                            "assets/bundled/prefabs/autospawn/resource/v3_temp_field/oak_e.prefab"),
                        new TreeConfig("oak b",
                            "assets/bundled/prefabs/autospawn/resource/v3_temp_field_large/oak_b.prefab"),
                        new TreeConfig("oak c",
                            "assets/bundled/prefabs/autospawn/resource/v3_temp_field_large/oak_c.prefab"),

                        new TreeConfig("birch a",
                            "assets/bundled/prefabs/autospawn/resource/v3_temp_forest/birch_large_temp.prefab"),
                        new TreeConfig("birch b",
                            "assets/bundled/prefabs/autospawn/resource/v3_temp_beachside/birch_small_temp.prefab"),
                        new TreeConfig("birch c",
                            "assets/bundled/prefabs/autospawn/resource/v2_temp_forest/birch_large_temp.prefab"),

                        new TreeConfig("douglas a",
                            "assets/bundled/prefabs/autospawn/resource/v3_temp_forest_pine/douglas_fir_a.prefab"),
                        new TreeConfig("douglas b",
                            "assets/bundled/prefabs/autospawn/resource/v3_temp_forest_pine/douglas_fir_b.prefab"),
                        new TreeConfig("douglas c",
                            "assets/bundled/prefabs/autospawn/resource/v3_temp_forest_pine/douglas_fir_c.prefab"),

                        new TreeConfig("palm a",
                            "assets/bundled/prefabs/autospawn/resource/v3_arid_beachside/palm_tree_small_a_entity.prefab"),
                        new TreeConfig("palm b",
                            "assets/bundled/prefabs/autospawn/resource/v3_arid_beachside/palm_tree_small_b_entity.prefab"),
                        new TreeConfig("palm c",
                            "assets/bundled/prefabs/autospawn/resource/v3_arid_beachside/palm_tree_small_c_entity.prefab"),

                        new TreeConfig("swamp a",
                            "assets/bundled/prefabs/autospawn/resource/swamp-trees/swamp_tree_a.prefab"),
                        new TreeConfig("swamp b",
                            "assets/bundled/prefabs/autospawn/resource/swamp-trees/swamp_tree_b.prefab"),
                        new TreeConfig("swamp c",
                            "assets/bundled/prefabs/autospawn/resource/swamp-trees/swamp_tree_c.prefab"),

                        new TreeConfig("pine a",
                            "assets/bundled/prefabs/autospawn/resource/v3_temp_forest_pine/pine_a.prefab"),
                        new TreeConfig("pine b",
                            "assets/bundled/prefabs/autospawn/resource/v3_temp_field/pine_b.prefab"),
                        new TreeConfig("pine c",
                            "assets/bundled/prefabs/autospawn/resource/v3_temp_forest_pine/pine_c.prefab"),
                    }
                };
            }

            public TreeConfig FindAvailableConfig(string name)
            {
                if (string.IsNullOrEmpty(name)) return null;

                TreeConfig treeItem;

                return AvailableConfigs.TryGetValue(name, out treeItem) ? treeItem : null;
            }
        }

        private class TreeConfig
        {
            [JsonProperty("Name", Order = 0)] public string Name;

            [JsonProperty("Cost", Order = 1)] public int Cost = 10;

            [JsonProperty("Amount", Order = 2)] public int Amount = 1;

            [JsonProperty("Prefab", Order = 3)] public string Prefab;

            public TreeConfig(string name, string prefab)
            {
                Name = name;
                Prefab = prefab;
            }

            public void GiveItem(BasePlayer player)
            {
                Item item = ItemManager.CreateByName("clone.hemp", Amount);
                item.name = Name;
                item.text = Name;
                item.info.stackable = 1;
                player.GiveItem(item);
            }

            public static void RefundItem(BasePlayer player, Item item, GrowableGenes growableGenes)
            {
                Item refund = ItemManager.CreateByName(item.info.shortname, 1);
                refund.instanceData = new ProtoBuf.Item.InstanceData { };
                refund.instanceData.dataInt = GrowableGeneEncoding.EncodeGenesToInt(growableGenes);
                player.GiveItem(refund);
            }
        }

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Message.Prefix", "<color=#DC143C>Tree Planter</color>: "},
                {"Message.Info", "Please select one of the following."},
                {"Message.Item", "{0} | ${1}"},
                {"Message.Authed", "You must have build privilege."},
                {"Message.Balance", "You don't have enough for that."},
                {"Message.Planter", "Must be planted in a planter."},
                {"Message.Ground", "Must be planted in the ground."},
                {"Message.Planted", "<color=#FFC55C>{0}</color> was successfully planted."},
                {"Message.Received", "You've purchased <color=#FFC55C>{0}x</color> <color=#FFC55C>{1}</color>."},
                {"Error.NotFound", "No item found by that name."}
            }, this);
        }

        #endregion

        #region Oxide

        private void OnServerInitialized() => AddCovalenceCommand("tree", nameof(TreeCommand), PERM_USE);

        private object OnMeleeAttack(BasePlayer player, HitInfo info)
        {
            if (player == null || info.HitEntity == null)
                return null;

            TreeEntity entity = info.HitEntity as TreeEntity;

            if (entity == null || entity.OwnerID == 0)
                return null;

            if (!IsEntityOwner(entity.OwnerID, player.userID))
                return true;

            return null;
        }

        private void OnEntityBuilt(Planner plan, GameObject gameObject)
        {
            BasePlayer player = plan.GetOwnerPlayer();
            if (player == null || !HasPermission(player, PERM_USE)) return;

            GrowableEntity growableEntity = gameObject.GetComponent<GrowableEntity>();

            Item item = player.GetActiveItem();
            if (item == null) return;

            NextFrame(() =>
            {
                TreeConfig treeConfig = _config.FindAvailableConfig(item.name);

                if (treeConfig != null && growableEntity != null && growableEntity.GetParentEntity() is PlanterBox)
                    TryPlantTree(player, item, growableEntity, treeConfig);
                else if (treeConfig != null && growableEntity != null)
                    TryPlantTree(player, item, growableEntity, treeConfig);
                else if (growableEntity == null || !(growableEntity.GetParentEntity() is PlanterBox))
                    TryPlantSeed(player, item, growableEntity);
            });
        }

        #endregion

        #region Core

        private void TryPlantTree(BasePlayer player, Item item, GrowableEntity entity, TreeConfig treeItem)
        {
            if (player == null || item == null) return;

            if (entity.GetParentEntity() is PlanterBox)
            {
                treeItem.GiveItem(player);
                KillSeed(entity);
                player.ChatMessage(Lang("Message.Ground", player.UserIDString));
                return;
            }

            if (!player.IsBuildingAuthed())
            {
                treeItem.GiveItem(player);
                KillSeed(entity);
                player.ChatMessage(Lang("Message.Authed", player.UserIDString));
                return;
            }

            KillSeed(entity);
            PlantTree(player, entity, treeItem.Prefab);

            player.ChatMessage(Lang("Message.Planted", player.UserIDString, item.name.TitleCase()));
        }

        private void TryPlantSeed(BasePlayer player, Item item, GrowableEntity entity)
        {
            if (player == null || item == null || IsBlockedAgri(item.info.shortname)) return;

            TreeConfig.RefundItem(player, item, entity.Genes);

            KillSeed(entity);

            player.ChatMessage(Lang("Message.Planter", player.UserIDString));
        }

        private void PlantTree(BasePlayer player, GrowableEntity plant, string prefabName)
        {
            BaseEntity entity = GameManager.server.CreateEntity(prefabName, plant.ServerPosition, Quaternion.identity);
            if (entity == null) return;
            entity.OwnerID = player.userID;
            entity.Spawn();
        }

        private void ListTrees(BasePlayer player)
        {
            StringBuilder stringBuilder = new StringBuilder(Lang("Message.Prefix", player.UserIDString));
            stringBuilder.Append(Lang("Message.Info", player.UserIDString));
            stringBuilder.AppendLine();

            _config.TreeConfigs.ForEach(x =>
            {
                stringBuilder.Append(Lang("Message.Item", player.UserIDString, x.Name, x.Cost));
                stringBuilder.AppendLine();
            });

            player.ChatMessage(stringBuilder.ToString());
        }

        private void KillSeed(GrowableEntity plant)
        {
            if (!IsValid(plant)) return;

            plant.Kill();
        }

        private bool TakeCurrency(BasePlayer player, int treeCost)
        {
            if (treeCost == 0)
                return true;

            if (_config.UseServerRewards && ServerRewards != null)
                return ServerRewards.Call<object>("TakePoints", player.userID, treeCost) != null;

            if (_config.UseEconomics && Economics != null)
                return Economics.Call<bool>("Withdraw", player.userID, (double) treeCost);

            if (_config.UseCurrency && HasAmount(player, treeCost))
            {
                TakeAmount(player, treeCost);
                return true;
            }

            return false;
        }

        #endregion

        #region Command

        private void TreeCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                ListTrees(player.ToBasePlayer());
                return;
            }

            TreeConfig treeConfig = _config.FindAvailableConfig(string.Join(" ", args));

            if (treeConfig == null)
            {
                player.Message(Lang("Error.NotFound", player.Id));
                return;
            }

            if (!TakeCurrency(player.ToBasePlayer(), treeConfig.Cost))
            {
                player.Message(Lang("Message.Balance", player.Id));
                return;
            }

            treeConfig.GiveItem(player.ToBasePlayer());

            player.Message(Lang("Message.Received", player.Id, treeConfig.Amount, treeConfig.Name));
        }

        #endregion

        #region Helpers

        private bool HasPermission(BasePlayer player, string permName)
            => permission.UserHasPermission(player.UserIDString, permName);

        private bool IsValid(BaseEntity entity)
            => entity.IsValid() && !entity.IsDestroyed;

        private bool SameClan(ulong userID, ulong targetID)
        {
            string playerClan = Clans?.Call<string>("GetClanOf", userID);
            if (string.IsNullOrEmpty(playerClan)) return false;

            string targetClan = Clans?.Call<string>("GetClanOf", targetID);
            if (string.IsNullOrEmpty(targetClan)) return false;

            return playerClan == targetClan;
        }

        private bool IsBlockedAgri(string shortname) => !(_config.AgriBlocked.ContainsKey(shortname) && _config.AgriBlocked[shortname]);

        private bool IsEntityOwner(ulong userID, ulong ownerID)
        {
            if (_config.EnableOwner && userID == ownerID)
                return true;

            if (_config.EnableClan && !SameClan(userID, ownerID))
                return false;

            return true;
        }

        private string Lang(string key, string id = null, params object[] args) =>
            string.Format(lang.GetMessage(key, this, id), args);

        #endregion

        #region Inventory Methods | Needed To Check For Skinned Scrap

        bool HasAmount(BasePlayer player, int amount)
            => GetAmount(player.inventory, _config.CurrencyItem, _config.CurrencySkinID) >= amount;

        void TakeAmount(BasePlayer player, int amount)
            => TakeAmount(player.inventory, _config.CurrencyItem, _config.CurrencySkinID, amount);

        int GetAmount(PlayerInventory inventory, int itemid, ulong skinID = 0UL)
        {
            if (itemid == 0)
                return 0;

            int num = 0;

            if (inventory.containerMain != null)
                num += GetAmount(inventory.containerMain, itemid, skinID, true);

            if (inventory.containerBelt != null)
                num += GetAmount(inventory.containerBelt, itemid, skinID, true);

            return num;
        }

        int GetAmount(ItemContainer container, int itemid, ulong skinID = 0UL, bool usable = false)
        {
            int num = 0;

            foreach (Item obj in container.itemList)
            {
                if (obj.info.itemid == itemid && obj.skin == skinID && (!usable || !obj.IsBusy()))
                    num += obj.amount;
            }

            return num;
        }

        int TakeAmount(PlayerInventory inventory, int itemid, ulong skinID, int amount)
        {
            int num1 = 0;

            if (inventory.containerMain != null)
            {
                int num2 = TakeAmount(inventory.containerMain, itemid, amount, skinID);
                num1 += num2;
                amount -= num2;
            }

            if (amount <= 0)
                return num1;

            if (inventory.containerBelt != null)
            {
                int num2 = TakeAmount(inventory.containerBelt, itemid, amount, skinID);
                num1 += num2;
            }

            return num1;
        }

        int TakeAmount(ItemContainer container, int itemid, int amount, ulong skinID)
        {
            int num1 = 0;

            if (amount == 0)
                return num1;

            List<Item> list = Facepunch.Pool.GetList<Item>();

            foreach (Item obj in container.itemList)
            {
                if (obj.info.itemid != itemid || obj.skin != skinID) continue;

                int num2 = amount - num1;

                if (num2 <= 0) continue;

                if (obj.amount > num2)
                {
                    obj.MarkDirty();
                    obj.amount -= num2;
                    num1 += num2;
                    Item byItemId = ItemManager.CreateByItemID(itemid);
                    byItemId.amount = num2;
                    byItemId.CollectedForCrafting(container.playerOwner);
                    break;
                }

                if (obj.amount <= num2)
                {
                    num1 += obj.amount;

                    list.Add(obj);
                }

                if (num1 == amount)
                    break;
            }

            list.ForEach(obj =>
            {
                if (obj == null) return;

                obj.RemoveFromContainer();
                obj.Remove();
            });

            ItemManager.DoRemoves();

            Facepunch.Pool.FreeList(ref list);

            return num1;
        }

        #endregion
    }

    namespace TreePlanterEx
    {
        public static class PlayerEx
        {
            public static BasePlayer ToBasePlayer(this IPlayer player) => player?.Object as BasePlayer;
        }
    }
}

// --- End of file: TreePlanter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tcmap ---
// --- Original File Path: T/TCMap/TCMap.cs ---

﻿
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    /*
     * TODO List:
     * ----------
     * - Players can only see the markers of the TCs they're authorized on
     * 
     * BUGS:
     * ------
     * 
     * */

    [Info("TCMap", "TheBandolero", "1.0.1", ResourceId = 0)]
    [Description("Shows all tool cupboards in the game map, and hovering over the TC mark shows a tooltip with the name of the players authorized in it.")]
    public class TCMap : RustPlugin
    {
        private const string Prefab = "cupboard.tool.deployed";
        private List<BaseEntity> listOfTCs = new List<BaseEntity>();
        private List<AuthPlayer> listOfAuthPlayers = new List<AuthPlayer>();
        private List<int> listMarkersIDs = new List<int>();
        private bool showToAllPlayers = false;

        void Init()
        {
            permission.RegisterPermission("tcmap.admin", this);
        }

        void OnServerInitialized()
        {
            DoTheMagic();
        }

        object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            timer.Once(0.5f, () =>
            {
                KillAllMarkers();
                DoTheMagic();
            });
            return null;
        }

        object OnCupboardDeauthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            timer.Once(0.5f, () =>
            {
                KillAllMarkers();
                DoTheMagic();
            });
            return null;
        }

        object OnCupboardClearList(BuildingPrivlidge privilege, BasePlayer player)
        {
            timer.Once(0.5f, () =>
            {
                KillAllMarkers();
                DoTheMagic();
            });
            return null;
        }

        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity != null && entity.ShortPrefabName == Prefab)
            {
                KillAllMarkers();
                DoTheMagic();
            }
        }

        void Unload()
        {
            KillAllMarkers();
        }

        private void DoTheMagic ()
        {
            int count = 0;
            //listMarkersIDs = new List<int>();
            //listOfTCs = new List<BaseEntity>();
            listOfTCs = GetTCList();

            foreach (BaseEntity tc in listOfTCs)
            {
                if (tc != null)
                {
                    count++;
                    bool isFirst = true;
                    string authPlayersNamesForMarker = "";
                    //PrintWarning("TC nº" + count + " with ID: " + tc.GetInstanceID().ToString() + " and Position: " + tc.ServerPosition);

                    listOfAuthPlayers = GetAuthList(tc, count);
                    if (listOfAuthPlayers != null && listOfAuthPlayers.Any())
                    {
                        foreach (AuthPlayer authPlayer in listOfAuthPlayers)
                        {
                            if (isFirst)
                            {
                                isFirst = false;
                                authPlayersNamesForMarker += authPlayer.GetAuthPlayerName();
                            }
                            else
                            {
                                authPlayersNamesForMarker += "\n" + authPlayer.GetAuthPlayerName();
                            }

                            /*PrintWarning("PlayerName: " + authPlayer.GetAuthPlayerName() + " --- PlayerID: " + authPlayer.GetAuthPlayerID() + " --- Owner: " + authPlayer.GetPlayerIsOwner()
                                + " --- CurrentlyOnline: " + authPlayer.GetAuthPlayerOnline());*/
                        }
                        PutTCMarksOnMap(tc.ServerPosition, authPlayersNamesForMarker);
                        listOfAuthPlayers.Clear();
                    }                    
                }
            }
        }

        private List<BaseEntity> GetTCList()
        {
            List<BaseEntity> tcList = new List<BaseEntity>();

            foreach (var tcb in GameObject.FindObjectsOfType<BaseEntity>())
            {
                if (tcb != null && IsCupboardEntity(tcb))
                {
                    tcList.Add(tcb);
                }
            }
            return tcList;
        }

        private bool IsCupboardEntity(BaseEntity entity) => entity != null && entity.ShortPrefabName == Prefab;

        private List<AuthPlayer> GetAuthList(BaseEntity tc, int count)
        {
            if (tc != null)
            {
                var tcPrivilege = tc.gameObject.GetComponentInParent<BuildingPrivlidge>();
                if (tcPrivilege != null)
                {
                    if (tcPrivilege.authorizedPlayers == null || tcPrivilege.authorizedPlayers.Count == 0)
                    {
                        PrintWarning("No players authorized in this TC.");
                        List<AuthPlayer> authList = new List<AuthPlayer>();
                        return authList;
                    }
                    else
                    {
                        List<AuthPlayer> authList = new List<AuthPlayer>();
                        foreach (ProtoBuf.PlayerNameID playerNameID in tcPrivilege.authorizedPlayers)
                        {
                            if (playerNameID != null)
                            {
                                bool isOwner = false;

                                if (playerNameID.userid == tc.OwnerID)
                                {
                                    isOwner = true;
                                }
                                authList.Add(new AuthPlayer(playerNameID.userid, playerNameID.username, isOwner, IsPlayerOnline(playerNameID.userid)));
                            }                                
                        }

                        return authList;
                    }
                }
                return null;                
            }
            return null;            
        }

        private bool IsPlayerOnline(ulong tcPlayerID)
        {
            if (BasePlayer.FindByID(tcPlayerID) != null)
            {
                return true;
            }
            return false;
        }

        private class AuthPlayer
        {
            private ulong playerID;
            private string playerName;
            private bool isOwner;
            private bool playerOnline;

            public AuthPlayer(ulong pID, string pName, bool pIsOwner, bool pOnline)
            {
                playerID = pID;
                playerName = pName;
                isOwner = pIsOwner;
                playerOnline = pOnline;
            }

            public ulong GetAuthPlayerID()
            {
                return playerID;
            }

            public void SetAuthPlayerID(ulong pID)
            {
                playerID = pID;
            }

            public string GetAuthPlayerName()
            {
                return playerName;
            }

            public void SetAuthPlayerID(string pName)
            {
                playerName = pName;
            }

            public bool GetPlayerIsOwner()
            {
                return isOwner;
            }

            public void SetPlayerIsOwner(bool pIsOwner)
            {
                isOwner = pIsOwner;
            }

            public bool GetAuthPlayerOnline()
            {
                return playerOnline;
            }

            public void SetAuthPlayerOnline(bool pOnline)
            {
                playerOnline = pOnline;
            }
        }

        // MAP MARKERS
        private void PutTCMarksOnMap(Vector3 tcPos, string markerAuthNames)
        {
            MapMarkerGenericRadius m = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", tcPos) as MapMarkerGenericRadius;
            m.alpha = 1.0f;
            m.color1 = Color.black;
            m.color2 = Color.black;
            m.radius = 2.5f;

            MapMarkerGenericRadius m2 = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", tcPos) as MapMarkerGenericRadius;
            m2.alpha = 1.0f;
            m2.color1 = Color.cyan;
            m2.color2 = Color.black;
            m2.radius = 2.0f;

            VendingMachineMapMarker m3 = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", tcPos) as VendingMachineMapMarker;
            m3.markerShopName = markerAuthNames;

            m3.Spawn();
            m.Spawn();
            m.SendUpdate();
            m2.Spawn();
            m2.SendUpdate();

            listMarkersIDs.Add(m.GetInstanceID());
            listMarkersIDs.Add(m2.GetInstanceID());
            listMarkersIDs.Add(m3.GetInstanceID());
        }

        object CanNetworkTo(BaseNetworkable entity, BasePlayer player)
        {
            if (entity == null || player == null) return null;
            //if ((entity.ShortPrefabName == "genericradiusmarker" || entity.ShortPrefabName == "vending_mapmarker") && !player.IsAdmin) return false;
            if (!showToAllPlayers)
            {
                if ((entity.ShortPrefabName == "genericradiusmarker" || entity.ShortPrefabName == "vending_mapmarker") && !permission.UserHasPermission(player.userID.ToString(), "tcmap.admin")) return false;
            }            
            return null;
        }

        private void KillAllMarkers()
        {
            foreach (var mark in GameObject.FindObjectsOfType<MapMarkerGenericRadius>())
            {
                if (listMarkersIDs.Contains(mark.GetInstanceID())){
                    mark.Kill();
                    mark.SendUpdate();
                }
            }
            foreach (var mark in GameObject.FindObjectsOfType<VendingMachineMapMarker>())
            {
                if (listMarkersIDs.Contains(mark.GetInstanceID()))
                {
                    mark.Kill();
                }
            }

            listMarkersIDs.Clear();
            listOfAuthPlayers.Clear();
            listOfTCs.Clear();
        }

        // CHAT COMMANDS
        [ChatCommand("tcmap"), Permission("tcmap.admin")]
        private void TCMapChatCommands(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.userID.ToString(), "tcmap.admin"))
            {
                if (args == null || args.Length == 0)
                {

                }
                else if (args[0].Equals("clear"))
                {
                    KillAllMarkers();
                    player.ChatMessage("<color=#ffa500ff>TCMap markers <b>REMOVED!</b></color>");
                }
                else if (args[0].Equals("update"))
                {
                    KillAllMarkers();
                    DoTheMagic();
                    player.ChatMessage("<color=#ffa500ff>TCMap markers <b>UPDATED!</b></color>");
                }
                else if (args[0].Equals("showtoall"))
                {
                    if (showToAllPlayers)
                    {
                        showToAllPlayers = false;
                        KillAllMarkers();
                        DoTheMagic();
                        player.ChatMessage("<color=#ffa500ff>TCMap show everyone: </color><b>" + showToAllPlayers + "</b>");
                    }
                    else
                    {
                        showToAllPlayers = true;
                        KillAllMarkers();
                        DoTheMagic();
                        player.ChatMessage("<color=#ffa500ff>TCMap show everyone: </color><b>" + showToAllPlayers + "</b>");
                    }
                }
                else if (args[0].Equals("help"))
                {
                    player.ChatMessage("<color=#ffa500ff><b><size=22>TCMapHelp</size></b></color>"
                        + "\n\n<color=#add8e6ff><b>/tcmap clear</b></color>  Removes all TC marks from map."
                        + "\n<color=#add8e6ff><b>/tcmap update</b></color>  Updates all TC marks on the map."
                        + "\n<color=#add8e6ff><b>/tcmap showtoall</b></color>  Shows all TC marks to ALL players."
                        + "\n<color=#add8e6ff><b>/tcmap help</b></color>  Shows this help menu."
                        + "\n\n<color=#ffa500ff><b><size=20>•</size></b></color> <color=#add8e6ff><b>Show to all is set to: </b></color> " + showToAllPlayers);
                }
            }
        }

    }    
}

// --- End of file: TCMap.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/turbo-gather ---
// --- Original File Path: T/TurboGather/TurboGather.cs ---

﻿/*
 * TODO:
 * 
 * - finish /cancelturbo
 * - add GUI start / finish to other methods other than just StartTurbo for the /turbo command (admin given turbo, Global turbo and animal turbo)
 */

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using System.Globalization;
using UnityEngine;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("Turbo Gather", "redBDGR", "1.1.12")]
    [Description("Lets players activate a resouce gather boost for a certain amount of time")]
    class TurboGather : RustPlugin
    {
        #region Data

        //
        // Shoutouts to k1lly0u for help with the database stuff
        //

        private DynamicConfigFile turboGatherData;
        StoredData storedData;

        Dictionary<string, Information> cacheDictionary = new Dictionary<string, Information>();
        Dictionary<string, bool> GUIinfo = new Dictionary<string, bool>();

        static List<object> Animals()
        {
            var al = new List<object>();
            al.Add("player");
            al.Add("boar");
            al.Add("horse");
            al.Add("stag");
            al.Add("chicken");
            al.Add("wolf");
            al.Add("bear");
            return al;
        }
        List<object> TurboAnimals;

        List<string> turboweapons = new List<string>();

        class StoredData
        {
            public Dictionary<string, Information> turboGatherInformation = new Dictionary<string, Information>();
        }

        class Information
        {
            public bool turboEnabled;
            public double activeAgain;
            public double turboEndTime;
            public bool adminTurboGiven;
            public double adminMultiplierGiven;
        }

        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                EndGUI(player);
            SaveData();
        }

        void OnServerSave()
        {
            SaveData();
        }

        void SaveData()
        {
            storedData.turboGatherInformation = cacheDictionary;
            turboGatherData.WriteObject(storedData);
        }

        void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(this.Title);
                cacheDictionary = storedData.turboGatherInformation;
            }
            catch
            {
                Puts("Failed to load data, creating new file");
                storedData = new StoredData();
            }
        }
        #endregion

        #region Config / Lang

        bool Changed = false;

        // default
        public float activeTime = 30.0f;
        public double cooldownTime = 600.0;
        public double boostMultiplier = 1.0;

        public double endTime;

        public const string permissionName = "turbogather.use";
        public const string permissionNameVIP = "turbogather.vip";
        public const string permissionNameANIMAL = "turbogather.animal";
        public const string permissionNameADMIN = "turbogather.admin";

        // vip
        public float activeTimeVIP = 30.0f;
        public double cooldownTimeVIP = 600.0;
        public double boostMultiplierVIP = 1.0;

        // global
        public bool globalBoostEnabled = false;
        public float activeTimeGLOBAL;
        public double boostMultiplierGLOBAL;

        // animal
        public float activeTimeANIMAL = 30.0f;
        public double boostMultiplierANIMAL = 1.0;

        // gather modes
        public bool dispenserEnabled = true;
        public bool pickupEnabled = true;
        public bool quarryEnabled = true;

        public bool activateTurboOnAnimalKill = false;

        public string PrefixName = "[<color=#0080ff>TurboGather</color>]";

        public bool effectEnabled = true;
        public const string effect = "assets/prefabs/locks/keypad/effects/lock.code.shock.prefab";

        public bool GUIEnabled = true;
        public string minAnchor = "0.77 0.025";
        public string maxAnchor = "0.85 0.13";

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        //
        // Shoutouts to fujikura
        //

        void LoadVariables()
        {
            boostMultiplier = Convert.ToSingle(GetConfig("Options", "Boost multiplier", 1.0f));
            activeTime = Convert.ToSingle(GetConfig("Options", "Active time", 30.0f));
            cooldownTime = Convert.ToSingle(GetConfig("Options", "Cooldown time", 600.0f));

            boostMultiplierVIP = Convert.ToSingle(GetConfig("Options", "Boost multiplier VIP", 1.0f));
            activeTimeVIP = Convert.ToSingle(GetConfig("Options", "Active time VIP", 30.0f));
            cooldownTimeVIP = Convert.ToSingle(GetConfig("Options", "Cooldown time VIP", 600.0f));

            boostMultiplierANIMAL = Convert.ToSingle(GetConfig("Options", "Boost multiplier ANIMAL", 1.0f));
            activeTimeANIMAL = Convert.ToSingle(GetConfig("Options", "Active time ANIMAL", 30.0f));

            dispenserEnabled = Convert.ToBoolean(GetConfig("Settings", "Dispensers enabled", true));
            pickupEnabled = Convert.ToBoolean(GetConfig("Settings", "Pickups enabled", true));
            quarryEnabled = Convert.ToBoolean(GetConfig("Settings", "Quarries enabled", true));

            PrefixName = Convert.ToString(GetConfig("Settings", "Prefix Name", "[<color=#0080ff>TurboGather</color>]"));

            effectEnabled = Convert.ToBoolean(GetConfig("Settings", "Effect Enabled", true));

            TurboAnimals = (List<object>)GetConfig("Settings", "Enabled animals", Animals());

            activateTurboOnAnimalKill = Convert.ToBoolean(GetConfig("Settings", "Activate Turbo on Animal Kill", false));

            GUIEnabled = Convert.ToBoolean(GetConfig("Settings", "GUI Enabled", GUIEnabled));
            minAnchor = Convert.ToString(GetConfig("Settings", "GUI Min Anchor", ""));
            maxAnchor = Convert.ToString(GetConfig("Settings", "GUI Max Anchor", ""));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        void Loaded()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                //chat
                ["BoostStart"] = "<color=#00FFFF>Engaging turbo gather! (x{0} resources for {1}s) </color>",
                ["BoostEnd"] = "<color=#00FFFF>Your ability has ended! (available again in {0}s) </color>",
                ["NoPermissions"] = "<color=#B20000>You do not have the required permissions to use this command! </color>",
                ["AlreadyInUse"] = "<color=#B20000>Your ability is already in use!</color>",
                ["OnCooldown"] = "<color=#B20000>You are currently on cooldown! ({0}s remaining) </color>",
                ["CooldownEnded"] = "<color=#00FFFF>Your cooldown has ended! </color>",
                ["AdminInvalidSyntax"] = "<color=#B20000>Invalid syntax! /giveturbo <playername> <length> <multiplier> </color>",
                ["PlayerOffline"] = "<color=#B20000>The playername / ID you entered is not online or invalid! </color>",
                ["PlayerGivenTurbo"] = "<color=#00FFFF>{0}'s TurboGather has been activated! (x{1} for {2}s) </color>",
                ["PlayerGivenTurbo(CONSOLE)"] = "{0}'s TurboGather has been activated! (x{1} for {2}s)",
                ["AdminBoostEnd"] = "<color=#00FFFF>Your admin applied ability has ended! </color>",
                ["AdminBoostStart"] = "<color=#00FFFF>An admin has given you turbo gather! (x{0} resources for {1}s) </color>",
                ["AnimalBoostEnd"] = "<color=#00FFFF>Your ability has ended!</color>",
                ["InvalidSyntaxGlobal"] = "<color=#B20000>Invalid syntax! /globalturbo <length> <multiplier> </color>",
                ["GlobalTurboInvoke"] = "<color=#00FFFF>An admin has started a global turbogather! (x{0} resources for {1}s!)</color>",
                ["GlobalTurboEnd"] = "<color=#00FFFF>Global turbogather has ended!</color>",

            }, this);

            turboGatherData = Interface.Oxide.DataFileSystem.GetFile("TurboGather");
        }

        #endregion

        #region Init

        void Init()
        {
            LoadVariables();
            permission.RegisterPermission(permissionName, this);
            permission.RegisterPermission(permissionNameVIP, this);
            permission.RegisterPermission(permissionNameADMIN, this);
            permission.RegisterPermission(permissionNameANIMAL, this);
            LoadData();
            AddWeapons();

            foreach (var key in cacheDictionary.Keys)
            {
                if (cacheDictionary[key].turboEndTime < GrabCurrentTime())
                {
                    BasePlayer player = BasePlayer.Find(key);
                    if (player == null) return;
                    if (permission.UserHasPermission(player.UserIDString, permissionNameADMIN) || permission.UserHasPermission(player.UserIDString, permissionName) || permission.UserHasPermission(player.UserIDString, permissionNameVIP) || permission.UserHasPermission(player.UserIDString, permissionNameANIMAL))
                        cacheDictionary[key].turboEnabled = false;
                    else
                        cacheDictionary.Remove(key);
                }
                else
                    cacheDictionary[key].turboEnabled = true;

            }
        }

        void AddWeapons()
        {
            turboweapons.Add("rock.entity");
            turboweapons.Add("hatchet.entity");
            turboweapons.Add("pickaxe.entity");
            turboweapons.Add("stone_pickaxe.entity");
            turboweapons.Add("stonehatchet.entity");
            turboweapons.Add("icepick_salvaged.entity");
            turboweapons.Add("axe_salvaged.entity");
            turboweapons.Add("hammer_salvaged.entity");
        }

        #endregion

        // handling animal / player killing
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!activateTurboOnAnimalKill) return;
            if (!(info?.Initiator is BasePlayer)) return;
            BasePlayer player = info.InitiatorPlayer;
            if (!permission.UserHasPermission(info.InitiatorPlayer.UserIDString, permissionNameANIMAL)) return;
            if (cacheDictionary.ContainsKey(info.InitiatorPlayer.UserIDString))
            {
                if (TurboAnimals.Contains(entity.ShortPrefabName))
                    StartAnimalTurbo(player);
            }
            else
                if (TurboAnimals.Contains(entity.ShortPrefabName))
                {
                    cacheDictionary.Add(player.UserIDString, new Information { turboEnabled = false, activeAgain = GrabCurrentTime(), turboEndTime = 0 });
                    StartAnimalTurbo(player);
                }
        }

        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            EndGUI(player);
        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (!effectEnabled) return;
            if (info?.HitEntity == null) return;
            if (cacheDictionary.ContainsKey(attacker.UserIDString))
                if (cacheDictionary[attacker.UserIDString].turboEnabled || cacheDictionary[attacker.UserIDString].adminTurboGiven || globalBoostEnabled)
                    if (turboweapons.Contains(info.Weapon.ShortPrefabName))
                    {
                        Effect.server.Run(effect, info.HitPositionWorld);
                        return;
                    }
            return;
        }

        #region Dispenser & Pickups

        void DoGather(BasePlayer player, Item item)
        {
            if (player == null) return;
            if (globalBoostEnabled)
            {
                item.amount = (int)(item.amount * boostMultiplierGLOBAL);
                return;
            }
            if (cacheDictionary.ContainsKey(player.UserIDString))
            {
                if (cacheDictionary[player.UserIDString].adminTurboGiven == true)
                {
                    if (cacheDictionary[player.UserIDString].turboEndTime > GrabCurrentTime())
                        item.amount = (int)(item.amount * cacheDictionary[player.UserIDString].adminMultiplierGiven);
                    else if (cacheDictionary[player.UserIDString].turboEndTime < GrabCurrentTime())
                        cacheDictionary[player.UserIDString].adminTurboGiven = false;
                }
                else
                {
                    if (permission.UserHasPermission(player.UserIDString, permissionName))
                        if (cacheDictionary[player.UserIDString].turboEnabled == true)
                            if (cacheDictionary[player.UserIDString].turboEndTime > GrabCurrentTime())
                            {
                                if (permission.UserHasPermission(player.UserIDString, permissionNameVIP))
                                {
                                    item.amount = (int)(item.amount * boostMultiplierVIP);
                                    return;
                                }
                                item.amount = (int)(item.amount * boostMultiplier);
                            }
                            else if (cacheDictionary[player.UserIDString].turboEndTime < GrabCurrentTime())
                                cacheDictionary[player.UserIDString].turboEnabled = false;
                            else if (permission.UserHasPermission(player.UserIDString, permissionNameVIP))
                                if (cacheDictionary[player.UserIDString].turboEnabled == true)
                                {
                                    if (cacheDictionary[player.UserIDString].turboEndTime > GrabCurrentTime())
                                        item.amount = (int)(item.amount * boostMultiplierVIP);
                                    else if (cacheDictionary[player.UserIDString].turboEndTime < GrabCurrentTime())
                                        cacheDictionary[player.UserIDString].turboEnabled = false;
                                }

                }
            }
        }

        // Dispensers
        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (dispenserEnabled)
                if (entity.ToPlayer() is BasePlayer)
                    DoGather(entity.ToPlayer(), item);
        }

        // collectables / pickups
        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (pickupEnabled == true)
                DoGather(player, item);
        }

        // quarries
        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            if (quarryEnabled == true)
            {
                BasePlayer player = BasePlayer.FindByID(quarry.OwnerID) ?? BasePlayer.FindSleeping(quarry.OwnerID);
                DoGather(player, item);
            }
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (dispenserEnabled)
                DoGather(player, item);
        }
        #endregion

        #region Command

        // if (OnEntityDeath = animal / player)
        void StartAnimalTurbo(BasePlayer player)
        {
            if (cacheDictionary.ContainsKey(player.UserIDString))
            {
                endTime = GrabCurrentTime() + activeTimeANIMAL;
                cacheDictionary[player.UserIDString].turboEnabled = true; /*  */ cacheDictionary[player.UserIDString].activeAgain = endTime; /*  */ cacheDictionary[player.UserIDString].turboEndTime = GrabCurrentTime() + activeTimeANIMAL;
                SendReply(player, PrefixName + " " + string.Format(msg("BoostStart", player.UserIDString), boostMultiplierANIMAL, activeTimeANIMAL));

                timer.Once(activeTimeANIMAL, () =>
                {
                    if (player == null) return;
                    cacheDictionary[player.UserIDString].turboEnabled = false;
                    SendReply(player, PrefixName + " " + msg("AnimalBoostEnd", player.UserIDString));
                });
            }
            else return;
        }

        // if player executes the chat command
        void StartTurbo(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, permissionNameVIP))
                endTime = GrabCurrentTime() + cooldownTimeVIP + activeTimeVIP;
            else
                endTime = GrabCurrentTime() + cooldownTime + activeTime;
            cacheDictionary[player.UserIDString].turboEnabled = true;
            cacheDictionary[player.UserIDString].activeAgain = endTime;
            cacheDictionary[player.UserIDString].turboEndTime = GrabCurrentTime() + activeTime;
            if (GUIEnabled)
                StartGui(player);

            if (permission.UserHasPermission(player.UserIDString, permissionNameVIP))
            {
                SendReply(player, PrefixName + " " + string.Format(msg("BoostStart", player.UserIDString), boostMultiplierVIP, activeTimeVIP));

                timer.Once(activeTimeVIP, () =>
                {
                    if (player == null) return;
                    cacheDictionary[player.UserIDString].turboEnabled = false;
                    SendReply(player, PrefixName + " " + string.Format(msg("BoostEnd", player.UserIDString), cooldownTimeVIP));
                    EndGUI(player);
                    float cooldownFloat = Convert.ToSingle(cooldownTimeVIP);

                    timer.Once(cooldownFloat, () =>
                    {
                        if (player != null)
                            SendReply(player, PrefixName + " " + msg("CooldownEnded", player.UserIDString));
                    });
                });
            }
            else
            {
                SendReply(player, PrefixName + " " + string.Format(msg("BoostStart", player.UserIDString), boostMultiplier, activeTime));

                timer.Once(activeTime, () =>
                {
                    if (player == null) return;
                    cacheDictionary[player.UserIDString].turboEnabled = false;
                    SendReply(player, PrefixName + " " + string.Format(msg("BoostEnd", player.UserIDString), cooldownTime));
                    EndGUI(player);
                    float cooldownFloat = Convert.ToSingle(cooldownTime);

                    timer.Once(cooldownFloat, () =>
                    {
                        if (player != null)
                            SendReply(player, PrefixName + " " + msg("CooldownEnded", player.UserIDString));
                    });
                });
            }
            return;
        }

        // chat command /turbo
        [ChatCommand("turbo")]
        void TurboCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
            {
                if (!permission.UserHasPermission(player.UserIDString, permissionNameVIP))
                {
                    SendReply(player, msg("NoPermissions", player.UserIDString));
                    return;
                }
            }

            if (cacheDictionary.ContainsKey(player.UserIDString))
            {
                if (GrabCurrentTime() > cacheDictionary[player.UserIDString].activeAgain)
                {
                    if (cacheDictionary[player.UserIDString].turboEnabled == false)
                        StartTurbo(player);

                    else if (cacheDictionary[player.UserIDString].turboEnabled == true)
                    {
                        cacheDictionary[player.UserIDString].turboEnabled = false;
                        StartTurbo(player);
                    }
                }
                else if (cacheDictionary[player.UserIDString].turboEnabled == true)
                    SendReply(player, PrefixName + " " + msg("AlreadyInUse", player.UserIDString));
                else
                {
                    double cooldownTimeLeft = cacheDictionary[player.UserIDString].activeAgain - GrabCurrentTime();
                    SendReply(player, PrefixName + " " + string.Format(msg("OnCooldown", player.UserIDString), (int)cooldownTimeLeft));
                }
            }
            else if (!cacheDictionary.ContainsKey(player.UserIDString))
            {
                cacheDictionary.Add(player.UserIDString, new Information { turboEnabled = false, activeAgain = GrabCurrentTime(), turboEndTime = 0 });
                StartTurbo(player);
            }
            return;
        }

        // chat command for cancelling your own, or another players turbo

            //
            // WORK ON THIS
            //
        [ChatCommand("cancelturbo")]
        void CancelturboCMD(BasePlayer player, string command, string[] args)
        {
            if (args.Length > 0)
            {
                if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN)) return;

                BasePlayer targetplayer = FindPlayer(args[0]);
                if (cacheDictionary.ContainsKey(targetplayer.UserIDString))
                {
                    cacheDictionary[targetplayer.UserIDString].adminTurboGiven = false;
                    cacheDictionary[targetplayer.UserIDString].turboEnabled = false;
                }
            }
            else
            {
                if (cacheDictionary.ContainsKey(player.UserIDString))
                {
                    cacheDictionary[player.UserIDString].adminTurboGiven = false;
                    cacheDictionary[player.UserIDString].turboEnabled = false;
                    // do other things with setting time and cancelling
                }
            }
        }

        //chat command /giveturbo
        [ChatCommand("giveturbo")]
        void GiveturboCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
            {
                SendReply(player, msg("NoPermissions", player.UserIDString));
                return;
            }

            if (args.Length == 3)
            {
                BasePlayer targetPlayer = FindPlayer(args[0]);
                string dictionaryPlayerName = targetPlayer.UserIDString;
                float playerActiveLengthInput = float.Parse(args[1]);
                double playerMultiplierInput = Convert.ToDouble(args[2]);

                if (targetPlayer != null)
                {
                    if (!cacheDictionary.ContainsKey(dictionaryPlayerName))
                        cacheDictionary.Add(targetPlayer.UserIDString, new Information { turboEnabled = false, activeAgain = GrabCurrentTime(), turboEndTime = GrabCurrentTime() + playerActiveLengthInput, adminTurboGiven = true, adminMultiplierGiven = playerMultiplierInput });
                    else
                    {
                        cacheDictionary[dictionaryPlayerName].turboEndTime = GrabCurrentTime() + playerActiveLengthInput;
                        cacheDictionary[dictionaryPlayerName].adminMultiplierGiven = Convert.ToDouble(args[2]);
                        cacheDictionary[dictionaryPlayerName].adminTurboGiven = true;
                    }
                    SendReply(player, PrefixName + " " + string.Format(msg("PlayerGivenTurbo", player.UserIDString), targetPlayer.displayName, playerMultiplierInput, playerActiveLengthInput));
                    targetPlayer.ChatMessage(PrefixName + " " + string.Format(msg("AdminBoostStart", targetPlayer.UserIDString), playerMultiplierInput, playerActiveLengthInput));

                    timer.Once(Convert.ToSingle(playerActiveLengthInput), () =>
                    {
                        cacheDictionary[dictionaryPlayerName].adminTurboGiven = false;
                        if (targetPlayer == null || !targetPlayer.IsConnected) return;
                        targetPlayer.ChatMessage(PrefixName + " " + string.Format(msg("AdminBoostEnd", targetPlayer.UserIDString)));
                    });
                }
                else
                    SendReply(player, PrefixName + " " + string.Format(msg("PlayerOffline", player.UserIDString)));
            }
            else
                SendReply(player, PrefixName + " " + string.Format(msg("AdminInvalidSyntax")));
            return;
        }

        // chat command /global turbo
        [ChatCommand("globalturbo")]
        void GlobalturboCMD(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
            {
                if (globalBoostEnabled)
                {
                    SendReply(player, "Global turbo is already enabled!");
                    return;
                }
                if (args.Length == 2)
                {
                    activeTimeGLOBAL = Convert.ToSingle(args[0]);
                    boostMultiplierGLOBAL = Convert.ToDouble(args[1]);
                    globalBoostEnabled = true;
                    PrintToChat(PrefixName + " " + string.Format(msg("GlobalTurboInvoke"), boostMultiplierGLOBAL, activeTimeGLOBAL));
                    timer.Once(activeTimeGLOBAL, () =>
                    {
                        if (globalBoostEnabled)
                        {
                            PrintToChat(PrefixName + " " + string.Format(msg("GlobalTurboEnd")));
                            globalBoostEnabled = false;
                        }
                    });
                }
                else
                    SendReply(player, PrefixName + " " + string.Format(msg("InvalidSyntaxGlobal")));
            }
            else
                SendReply(player, PrefixName + " " + string.Format(msg("NoPermissions", player.UserIDString)));
            return;
        }

        // console command for starting / stopping global turbogather
        [ConsoleCommand("globalturbo")]
        void GlobalturboconsoleCMD(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            //start
            if (arg.Args != null && arg.Args[0] == "start")
            {
                if (arg.Args.Length == 3)
                {
                    if (globalBoostEnabled)
                        Puts("Global turbo is already enabled!");
                    else
                    {
                        globalBoostEnabled = true;
                        activeTimeGLOBAL = Convert.ToSingle(arg.Args[1]);
                        boostMultiplierGLOBAL = Convert.ToDouble(arg.Args[2]);
                        PrintToChat(string.Format(msg("GlobalTurboInvoke"), boostMultiplierGLOBAL, activeTimeGLOBAL));
                        Puts("Global Turbo has been activated! ( " + boostMultiplierGLOBAL + "x for " + activeTimeGLOBAL + "s )");
                        timer.Once(activeTimeGLOBAL, () =>
                        {
                            if (globalBoostEnabled)
                            {
                                PrintToChat(string.Format(msg("GlobalTurboEnd")));
                                globalBoostEnabled = false;
                            }
                        });
                    }
                }
                else Puts("Invalid syntax! /globalturbo start <length> <multiplier>");
            }
            //end
            else if (arg.Args != null && arg.Args[0] == "end")
            {
                if (globalBoostEnabled)
                {
                    globalBoostEnabled = false;
                    PrintToChat(string.Format(msg("GlobalTurboEnd")));
                }
                else
                    Puts("Global turbo is already disabled!");
            }
            else if (arg.Args == null || arg.Args.Length == 0)
            {
                Puts("Invalid syntax! /globalturbo <start/end>");
            }
        }

        // cancelling globalturbo (emergency?)
        [ChatCommand("cancelglobalturbo")]
        void CancelglobalturboCMD(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, permissionNameADMIN))
            {
                if (args == null || args.Length <= 0)
                {
                    if (globalBoostEnabled)
                    {
                        globalBoostEnabled = false;
                        PrintToChat(PrefixName + " " + msg("GlobalTurboEnd"));
                    }
                    else
                        SendReply(player, "Global turbo is already disabled!");
                }
                return;
            }
            else
                SendReply(player, PrefixName + " " + msg("NoPermissions", player.UserIDString));
        }

        // console command giveturbo
        [ConsoleCommand("giveturbo")]
        void GiveturboconsoleCMD(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            if (arg.Args == null || arg.Args.Length != 3)
            {
                Puts("Invalid syntax! giveturbo <playername> <length> <multiplier>");
                return;
            }
            else
            {
                string playerNameInput = arg.Args[0];
                BasePlayer player = FindPlayer(playerNameInput);
                float playerActiveLengthInput = float.Parse(arg.Args[1]);
                double playerInputMultiplier = Convert.ToDouble(arg.Args[2]);

                if (player != null)
                {
                    if (!cacheDictionary.ContainsKey(player.UserIDString))
                        cacheDictionary.Add(player.UserIDString, new Information { turboEnabled = false, activeAgain = GrabCurrentTime(), turboEndTime = GrabCurrentTime() + playerActiveLengthInput, adminTurboGiven = true, adminMultiplierGiven = playerInputMultiplier });
                    else
                    {
                        cacheDictionary[player.UserIDString].turboEndTime = GrabCurrentTime() + playerActiveLengthInput;
                        cacheDictionary[player.UserIDString].adminMultiplierGiven = playerInputMultiplier;
                        cacheDictionary[player.UserIDString].adminTurboGiven = true;
                    }

                    Puts(string.Format(msg("PlayerGivenTurbo(CONSOLE)"), player.UserIDString, playerInputMultiplier, playerActiveLengthInput));
                    player.ChatMessage(string.Format(msg("AdminBoostStart", playerNameInput), playerInputMultiplier, playerActiveLengthInput));

                    timer.Once(Convert.ToSingle(playerActiveLengthInput), () =>
                    {
                        if (player == null) return;
                        player.ChatMessage(string.Format(msg("AdminBoostEnd", playerNameInput)));
                        cacheDictionary[player.UserIDString].adminTurboGiven = false;
                    });
                }
                else
                    Puts("The playername / ID you entered is not online or invalid!");
            }
            return;
        }

        #endregion

        #region UI

        private string PanelOnScreen = "OnScreen";
        private string Panel = "TGPanel";

        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent,
                    panel
                }
            };
                return NewElement;
            }

            static public void CreateImage(ref CuiElementContainer element, string panel, string imageURL, string aMin, string aMax)
            {
                element.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent { Url = imageURL, Color = "1 1 1 1" },
                        new CuiRectTransformComponent {AnchorMax = aMax, AnchorMin = aMin }
                    }
                });
            }
        }

        #endregion

        #region Extras

        void StartGui(BasePlayer player)
        {
            if (GUIinfo.ContainsKey(player.UserIDString))
            {
                if (!GUIinfo[player.UserIDString])
                {
                    var element = UI.CreateElementContainer(Panel, "1 1 1 0", "0 0", "1 1", false);
                    UI.CreateImage(ref element, Panel, "http://i.imgur.com/eLFi2Gd.png", minAnchor, maxAnchor);
                    CuiHelper.AddUi(player, element);
                    GUIinfo[player.UserIDString] = true;
                }
                return;
            }
            else
            {
                var element = UI.CreateElementContainer(Panel, "1 1 1 0", "0 0", "1 1", false);
                UI.CreateImage(ref element, Panel, "http://i.imgur.com/eLFi2Gd.png", minAnchor, maxAnchor);
                CuiHelper.AddUi(player, element);
                GUIinfo[player.UserIDString] = true;
            }
            return;
        }

        void EndGUI(BasePlayer player)
        {
            if (GUIinfo.ContainsKey(player.UserIDString))
            {
                if (GUIinfo[player.UserIDString])
                {
                    CuiHelper.DestroyUi(player, Panel);
                    GUIinfo[player.UserIDString] = false;
                }
            }
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        string msg(string key, string id = null) => lang.GetMessage(key, this, id);

        private static BasePlayer FindPlayer(string nameOrId)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrId)
                    return activePlayer;
                if (activePlayer.displayName.Contains(nameOrId, CompareOptions.OrdinalIgnoreCase))
                    return activePlayer;
                if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress == nameOrId)
                    return activePlayer;
            }
            return null;
        }

        #endregion

    }
}

// --- End of file: TurboGather.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tickrate-limiter ---
// --- Original File Path: T/TickrateLimiter/TickrateLimiter.cs ---

﻿//#define DEBUG
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
	[Info("Tickrate Limiter", "2CHEVSKII", "0.1.2")]
	[Description("Limits current maximum tickrate based on player count to improve overall performance")]
	internal class TickrateLimiter : CovalencePlugin
	{
		#region -Fields-

		private int _defaultClValue;
		private int _defaultSvValue;
		private Dictionary<int, TickrateValues> TickrateCurve { get; set; }

		#endregion

		#region -Configuration-

		private Dictionary<int, TickrateValues> GetDefaultCurve => new Dictionary<int, TickrateValues>
		{
			{0, new TickrateValues(20, 30)},
			{50, new TickrateValues(16, 20)},
			{150, new TickrateValues(5, 10)}
		};

		protected override void LoadDefaultConfig()
		{
			TickrateCurve = GetDefaultCurve;

			PrintWarning("Creating default configuration file...");

			SaveConfig();
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				TickrateCurve = Config.ReadObject<Dictionary<int, TickrateValues>>();

				if (TickrateCurve == null)
					throw new JsonException("Could not load configuration...");

				Puts("Configuration loaded...");
			}
			catch
			{
				LoadDefaultConfig();
			}
		}

		protected override void SaveConfig()
		{
			Config.WriteObject(TickrateCurve, true);
		}

		#endregion

		#region -Hooks-

		private void OnServerInitialized()
		{
			_defaultClValue = Player.tickrate_cl;
			_defaultSvValue = Player.tickrate_sv;

			OnPlayerCountUpdate();
		}

		private void OnPlayerConnected()
		{
			NextTick(() => OnPlayerCountUpdate());
		}

		private void OnPlayerDisconnected()
		{
			NextTick(() => OnPlayerCountUpdate());
		}

		private void Unload()
		{
			Player.tickrate_sv = _defaultSvValue;
			Player.tickrate_cl = _defaultClValue;
		}

		#endregion

		#region -Functions-

		private void OnPlayerCountUpdate()
		{
			var closest = TickrateCurve.OrderByDescending(x => x.Key)
				.First(z => z.Key <= BasePlayer.activePlayerList.Count).Value;

			Player.tickrate_sv = closest.Server;
			Player.tickrate_cl = closest.Client;

#if DEBUG
			PrintWarning(
				$"Tickrate values adjusted for the playercount {BasePlayer.activePlayerList.Count}:\n Client rate: {Player.tickrate_cl} Server rate: " +
				$"{Player.tickrate_sv}");
#endif
		}

		#endregion

		#region -Component-

		private class TickrateValues
		{
			public readonly int Client;
			public readonly int Server;

			public TickrateValues(int server, int client)
			{
				this.Server = server;
				this.Client = client;
			}
		}	

		#endregion
	}
}

// --- End of file: TickrateLimiter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/timed-events ---
// --- Original File Path: T/TimedEvents/TimedEvents.cs ---

using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Timed Events", "Orange", "1.1.5")]
    [Description("Triggers various types of events like Airdrops, Helicopters and same")]
    public class TimedEvents : RustPlugin
    {
        #region Vars

        private const string prefabCH47 = "assets/prefabs/npc/ch47/ch47scientists.entity.prefab";
        private const string prefabPlane = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";
        private const string prefabShip = "assets/content/vehicles/boats/cargoship/cargoshiptest.prefab";
        private const string prefabPatrol = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";

        #endregion
        
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            SpawnTank(true);
            SpawnShip(true);
            SpawnPatrol(true);
            SpawnPlane(true);
            SpawnCH47(true);
        }
        
        private object OnEventTrigger(TriggeredEventPrefab info)
        {
            var prefabs = UnityEngine.Object.FindObjectsOfType<TriggeredEventPrefab>();
            foreach (var obj in prefabs)
            {
                var name = obj.targetPrefab.resourcePath;
                if (name.Contains("patrol") && config.patrol.disableDefault == true)
                {
                    return true;
                }

                if (name.Contains("ship") && config.ship.disableDefault == true)
                {
                    return true;
                }

                if (name.Contains("plane") && config.plane.disableDefault == true)
                {
                    return true;
                }

                if (name.Contains("ch47") && config.ch47.disableDefault == true)
                {
                    return true;
                }
            }

            return null;
        }
        #endregion

        #region Core

        private void SpawnTank(bool skipSpawn = false)
        {
            if (Online() >= config.tank.playersMin && skipSpawn == false)
            {
                BradleySpawner.singleton?.SpawnBradley();
            }

            var time = Core.Random.Range(config.tank.timerMin, config.tank.timerMax);
            timer.Once(time, () => SpawnTank());
        }

        private void SpawnShip(bool skipSpawn = false)
        {
            if (Online() >= config.ship.playersMin && skipSpawn == false)
            {
                var amount = Core.Random.Range(config.ship.spawnMin, config.ship.spawnMax);

                for (var i = 0; i < amount; i++)
                {
                    var x = TerrainMeta.Size.x;
                    var vector3 = Vector3Ex.Range(-1f, 1f);
                    vector3.y = 0.0f;
                    vector3.Normalize();
                    var worldPos = vector3 * (x * 1f);
                    worldPos.y = TerrainMeta.WaterMap.GetHeight(worldPos);
                    var entity = GameManager.server.CreateEntity(prefabShip, worldPos);
                    entity?.Spawn();
                }
            }

            var time = Core.Random.Range(config.ship.timerMin, config.ship.timerMax);
            timer.Once(time, () => SpawnShip());
        }

        private void SpawnPatrol(bool skipSpawn = false)
        {
            if (Online() >= config.patrol.playersMin && skipSpawn == false)
            {
                var amount = Core.Random.Range(config.patrol.spawnMin, config.patrol.spawnMax);
            
                for (var i = 0; i < amount; i++)
                {
                    var position = new Vector3(ConVar.Server.worldsize, 100, ConVar.Server.worldsize) - new Vector3(50f, 0f, 50f);
                    var entity = GameManager.server.CreateEntity(prefabPatrol, position);
                    entity?.Spawn();
                }
            }
            
            var time = Core.Random.Range(config.patrol.timerMin, config.patrol.timerMax);
            timer.Once(time, () => SpawnPatrol());
        }

        private void SpawnPlane(bool skipSpawn = false)
        {
            if (Online() >= config.plane.playersMin && skipSpawn == false)
            {
                var amount = Core.Random.Range(config.plane.spawnMin, config.plane.spawnMax);
            
                for (var i = 0; i < amount; i++)
                {
                    var position = new Vector3(ConVar.Server.worldsize, 100, ConVar.Server.worldsize) - new Vector3(50f, 0f, 50f);
                    var entity = GameManager.server.CreateEntity(prefabPlane, position);
                    entity?.Spawn();
                }
            }
            
            var time = Core.Random.Range(config.plane.timerMin, config.plane.timerMax);
            timer.Once(time, () => SpawnPlane());
        }
        
        private void SpawnCH47(bool skipSpawn = false)
        {
            if (Online() >= config.ch47.playersMin && skipSpawn == false)
            {
                var amount = Core.Random.Range(config.ch47.spawnMin, config.ch47.spawnMax);
            
                for (var i = 0; i < amount; i++)
                {
                    var position = new Vector3(ConVar.Server.worldsize, 100, ConVar.Server.worldsize) - new Vector3(50f, 0f, 50f);
                    var entity = GameManager.server.CreateEntity(prefabCH47, position) as CH47HelicopterAIController;
                    entity?.TriggeredEventSpawn();
                    entity?.Spawn();
                }
            }
            
            var time = Core.Random.Range(config.ch47.timerMin, config.ch47.timerMax);
            timer.Once(time, () => SpawnCH47());
        }

        private int Online()
        {
            return BasePlayer.activePlayerList.Count;
        }

        #endregion

        #region Configuration

        private static ConfigData config;
        
        private class ConfigData
        {    
            [JsonProperty(PropertyName = "1. Cargo plane settings:")]
            public EventSettings plane;
            
            [JsonProperty(PropertyName = "2. Patrol Helicopter settings:")]
            public EventSettings patrol;
            
            [JsonProperty(PropertyName = "3. Bradley APC settings:")]
            public EventSettings tank;
            
            [JsonProperty(PropertyName = "4. CH47 settings:")]
            public EventSettings ch47;
            
            [JsonProperty(PropertyName = "5. Cargo ship settings:")]
            public EventSettings ship;
        }
        
        private class EventSettings
        {
            [JsonProperty(PropertyName = "1. Disable default spawns")]
            public bool disableDefault;
                
            [JsonProperty(PropertyName = "2. Minimal respawn time (in seconds)")]
            public int timerMin;
                
            [JsonProperty(PropertyName = "3. Maximal respawn time (in seconds)")]
            public int timerMax;
                
            [JsonProperty(PropertyName = "4. Minimal amount that spawned by once")]
            public int spawnMin;
                
            [JsonProperty(PropertyName = "5. Maximal amount that spawned by once")]
            public int spawnMax;
                
            [JsonProperty(PropertyName = "6. Minimal players to start event")]
            public int playersMin;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                plane = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                },
                patrol = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                },
                tank = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                },
                ch47 = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                },
                ship = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: TimedEvents.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/troll-cheaters ---
// --- Original File Path: T/TrollCheaters/TrollCheaters.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Troll Cheaters", "x0x58x", "0.2.0")]
    [Description("Troll Cheaters with Op Guns and other troll commands")]
    class TrollCheaters : RustPlugin
    {
        #region Init
        ConfigData configData;
        private static string rocketGUI = @"
        [
          {
            ""name"": ""87cb-9615-bede"",
            ""parent"": ""Hud"",
            ""components"": [
              {
                ""type"": ""UnityEngine.UI.RawImage"",
                ""color"": ""1 1 1 1"",
                ""url"": ""http://www.rigormortis.be/wp-content/uploads/rust-icon-512.png""
              },
              {
                ""type"": ""RectTransform"",
                ""anchormin"": ""0 0.965"",
                ""anchormax"": ""0.02 1""
              }
            ]
          }
        ]
        ";
        private static string blueScreen = @"
        [
          {
            ""name"": ""6b26-3034-e391"",
            ""parent"": ""Overlay"",
            ""components"": [
              {
                ""type"": ""UnityEngine.UI.RawImage"",
                ""color"": ""1 1 1 1"",
                ""url"": ""https://i0.wp.com/www.novabach.com/wp-content/uploads/2021/03/Blue-Screen-of-death.jpg?fit=1280%2C720&ssl=1""
              },
              {
                ""type"": ""RectTransform"",
                ""anchormin"": ""0 0"",
                ""anchormax"": ""1 1""
              }
            ]
          }
        ]
        ";
        void Init()
        {
            permission.RegisterPermission("trollcheaters.admin", this);
            permission.RegisterPermission("trollcheaters.rspeed", this);
            permission.RegisterPermission("trollcheaters.dropban", this);
            permission.RegisterPermission("trollcheaters.rdban", this);
            permission.RegisterPermission("trollcheaters.bscreen", this);
            LoadPlayerData();
        }

        #endregion

        #region Config      
        //Assistance Ujiou#6646
        protected override void LoadDefaultConfig() => configData = LoadBaseConfig();
        protected override void SaveConfig() => Config.WriteObject(configData, true);
        private string Lang(string langKey, BasePlayer player, params object[] args) => string.Format(lang.GetMessage(langKey, this, player.UserIDString), args);


        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();

                if (configData == null)
                    throw new JsonException();
                SaveConfig();
            }
            catch
            {
                LoadDefaultConfig();
                SaveConfig();
            }
        }
        private ConfigData LoadBaseConfig()
        {
            return new ConfigData
            {
                settings = new ConfigData.Settings
                {
                    status = false,
                    speed = 1000,
                },
                Version = Version
            };
        }
        class ConfigData
        {

            [JsonProperty(PropertyName = "Settings")]
            public Settings settings { get; set; }

            public class Settings
            {
                [JsonProperty(PropertyName = "Troll Cheaters Status")]
                public bool status { get; set; }
                [JsonProperty(PropertyName = "Rocket Speed")]
                public int speed { get; set; }
                [JsonProperty(PropertyName = "Player")]
                public object player { get; set; }
            }
            [JsonProperty(PropertyName = "Version: ")]
            public Core.VersionNumber Version { get; set; }
        }
        //Assistance Ujiou#6646

        private Dictionary<ulong, TCInfo> tcInfo = new Dictionary<ulong, TCInfo>();

        private void SavePlayerData()
        {
            if (tcInfo != null)
                Interface.Oxide.DataFileSystem.WriteObject($"{Name}/TCInfo", tcInfo);
        }

        private void LoadPlayerData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Name}/TCInfo"))
            {
                tcInfo = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, TCInfo>>($"{Name}/TCInfo");
            }
            else
            {
                tcInfo = new Dictionary<ulong, TCInfo>();
                SavePlayerData();
            }
        }

        public class TCInfo
        {
            [JsonProperty(PropertyName = "Name: ")]
            public string Name { get; set; }

        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Perms"] = "No perms",
                ["status"] = "Troll Cheaters Status: {0}",
                ["validNum"] = "Please enter a valid number",
                ["validPrefab"] = "Dang something changed or wrong prefab??",
                ["dExist"] = "Whatever you're targeting doesn't exist.",
                ["cheater"] = "This cheater is already on the list >:(",
                ["saveCheater"] = "Saving user data to the file...",
                ["notCheater"] = "This is not a cheater.",
                ["removeCheater"] = "Deleting user data from the file...",
                ["rocketSpeed"] = "Rocket Speed set to {0}",
                ["noUser"] = "No user found please look at the user with your crosshair",
            }, this);
        }
        #endregion

        #region Commands

        #region ChatCommand trocket
        [ChatCommand("trocket")]
        void trocket(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), "trollcheaters.admin"))
            {
                string perms = lang.GetMessage("Perms", this, player.UserIDString);
                SendReply(player, perms);
                return;
            }
            else
            {
                configData.settings.status = !configData.settings.status;
                string status = Lang("status", player, configData.settings.status);

                SendReply(player, status);
                if (configData.settings.status)
                {
                    CuiHelper.AddUi(player, rocketGUI);
                }
                else
                {
                    CuiHelper.DestroyUi(player, "87cb-9615-bede");
                }
            }
        }

        #endregion

        #region ChatCommand rspeed
        [ChatCommand("rspeed")]
        void rspeed(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), "trollcheaters.rspeed"))
            {
                string perms = lang.GetMessage("Perms", this, player.UserIDString);
                SendReply(player, perms);
                return;
            }

            if (args.Length > 0)
            {
                int a;
                bool res;
                res = int.TryParse(args[0], out a);
                if (res && a > 0)
                {
                    configData.settings.speed = a;
                    SaveConfig();
                    SendReply(player, Lang("rocketSpeed", player, configData.settings.speed));
                }
                else
                {
                    string valid = lang.GetMessage("validNum", this, player.UserIDString);
                    SendReply(player, valid);
                    return;


                }
            }
            else
            {
                string valid = lang.GetMessage("validNum", this, player.UserIDString);
                SendReply(player, valid);
                return;
            }

        }
        #endregion

        #region ChatCommand dropban
        [ChatCommand("dropban")]
        void dropban(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), "trollcheaters.dropban"))
            {
                string perms = lang.GetMessage("Perms", this, player.UserIDString);
                SendReply(player, perms);
                return;
            }
            else
            {

                RaycastHit hit;
                if (!Physics.Raycast(player.eyes.HeadRay(), out hit, float.MaxValue, LayerMask.GetMask("Player (Server)")))
                {
                    string noUser = lang.GetMessage("noUser", this, player.UserIDString);
                    player.ChatMessage(noUser);
                    return;
                }
                else
                {
                    var entity = hit.GetEntity() as BasePlayer;
                    if (entity == null)
                    {
                        string dExist = lang.GetMessage("dExist", this, player.UserIDString);
                        player.ChatMessage(dExist);
                        return;

                    }
                    else
                    {
                        string cheater = lang.GetMessage("cheater", this, player.UserIDString);
                        string saveCheater = lang.GetMessage("saveCheater", this, player.UserIDString);
                        if (!tcInfo.ContainsKey(entity.userID))
                        {
                            tcInfo.Add(entity.userID, new TCInfo() { Name = entity.displayName });
                            SavePlayerData();
                            player.ChatMessage(saveCheater);
                            ripCheater(entity);
                        }
                        else
                        {
                            player.ChatMessage(cheater);
                            return;
                        }
                    }
                }
            }
        }
        #endregion

        #region ChatCommand rdban
        [ChatCommand("rdban")]
        void rdban(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), "trollcheaters.rdban"))
            {
                string perms = lang.GetMessage("Perms", this, player.UserIDString);
                SendReply(player, perms);
                return;
            }
            else
            {

                RaycastHit hit;
                if (!Physics.Raycast(player.eyes.HeadRay(), out hit, float.MaxValue, LayerMask.GetMask("Player (Server)")))
                {
                    string noUser = lang.GetMessage("noUser", this, player.UserIDString);
                    player.ChatMessage(noUser);
                    return;
                }
                else
                {
                    var entity = hit.GetEntity() as BasePlayer;
                    if (entity == null)
                    {
                        string dExist = lang.GetMessage("dExist", this, player.UserIDString);
                        player.ChatMessage(dExist);
                        return;
                    }
                    else
                    {
                        string notCheater = lang.GetMessage("notCheater", this, player.UserIDString);
                        string removeCheater = lang.GetMessage("removeCheater", this, player.UserIDString);
                        if (!tcInfo.ContainsKey(entity.userID))
                        {
                            player.ChatMessage(notCheater);
                            return;
                        }
                        else
                        {
                            tcInfo.Remove(entity.userID);
                            SavePlayerData();
                            player.ChatMessage(removeCheater);
                        }
                    }
                }
            }
        }
        #endregion

        #region Blue Screen
        [ChatCommand("bscreen")]
        void bscreen(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), "trollcheaters.bscreen"))
            {
                string perms = lang.GetMessage("Perms", this, player.UserIDString);
                SendReply(player, perms);
                return;
            }
            RaycastHit hit;
            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, float.MaxValue, LayerMask.GetMask("Player (Server)")))
            {
                string noUser = lang.GetMessage("noUser", this, player.UserIDString);
                player.ChatMessage(noUser);
                return;
            }
            var entity = hit.GetEntity() as BasePlayer;
            if (entity == null)
            {
                string dExist = lang.GetMessage("dExist", this, player.UserIDString);
                player.ChatMessage(dExist);
                return;

            }
            else
            {
                CuiHelper.AddUi(entity, blueScreen);
                timer.Repeat(0.2f, 100, () =>
                {
                    RunEffect(entity.transform.position, "assets/bundled/prefabs/fx/headshot.prefab", entity);
                });
            }            
        }

        [ChatCommand("rbscreen")]
        void rbscreen(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), "trollcheaters.bscreen"))
            {
                string perms = lang.GetMessage("Perms", this, player.UserIDString);
                SendReply(player, perms);
                return;
            }
            RaycastHit hit;
            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, float.MaxValue, LayerMask.GetMask("Player (Server)")))
            {
                string noUser = lang.GetMessage("noUser", this, player.UserIDString);
                player.ChatMessage(noUser);
                return;
            }
            var entity = hit.GetEntity() as BasePlayer;
            if (entity == null)
            {
                string dExist = lang.GetMessage("dExist", this, player.UserIDString);
                player.ChatMessage(dExist);
                return;

            }
            else
            {
                CuiHelper.DestroyUi(entity, "6b26-3034-e391");
            }
        }
        #endregion

        #endregion

        #region Hooks
        void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles)
        {
            if (permission.UserHasPermission(player.userID.ToString(), "trollcheaters.admin") && configData.settings.status)
            {
                var prop = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_basic.prefab",
                    player.eyes.position + player.eyes.BodyForward().normalized,
                    player.eyes.rotation
                    );

                ServerProjectile sProjectile = prop.GetComponent<ServerProjectile>();
                if (sProjectile == null)
                {
                    string validPrefab = lang.GetMessage("validPrefab", this, player.UserIDString);
                    PrintWarning(validPrefab);
                    return;
                }
                else
                {
                    sProjectile.InitializeVelocity(player.eyes.HeadForward().normalized * configData.settings.speed);
                    sProjectile.gravityModifier = 0;
                    prop.Spawn();
                }

            }
        }
        object OnItemPickup(BasePlayer player)
        {
            if (tcInfo.ContainsKey(player.userID))
            {
                ripCheater(player);
            }
            return null;
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (configData.settings.status)
            {
                CuiHelper.AddUi(player, rocketGUI);
            }
            else
            {
                CuiHelper.DestroyUi(player, "87cb-9615-bede");
            }
        }
        object OnItemCraft(ItemCraftTask task, BasePlayer player, Item item)
        {
            if (tcInfo.ContainsKey(player.userID))
            {
                ripCheater(player);
            }
            return null;
        }
        object OnActiveItemChange(BasePlayer player, Item oldItem, uint newItemId)
        {
            if (tcInfo.ContainsKey(player.userID))
            {
                ripCheater(player);
            }
            return null;
        }
        void Loaded(BasePlayer player)
        {
            if (configData.settings.status)
            {
                CuiHelper.AddUi(player, rocketGUI);
            }
            else
            {
                CuiHelper.DestroyUi(player, "87cb-9615-bede");
            }
        }
        void ripCheater(BasePlayer player)
        {
            DropUtil.DropItems(player.inventory.containerMain, player.transform.position);
            DropUtil.DropItems(player.inventory.containerBelt, player.transform.position);
            DropUtil.DropItems(player.inventory.containerWear, player.transform.position);
        }
        void RunEffect(Vector3 position, string prefab, BasePlayer player = null)
        {
            var effect = new Effect();
            effect.Init(Effect.Type.Generic, position, Vector3.zero);
            effect.pooledString = prefab;

            if (player != null)
            {
                EffectNetwork.Send(effect, player.net.connection);
            }
            else
            {
                EffectNetwork.Send(effect);
            }
        }
        #endregion
    }
}

// --- End of file: TrollCheaters.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/team-leader-online ---
// --- Original File Path: T/TeamLeaderOnline/TeamLeaderOnline.cs ---

﻿/* MIT License

Copyright (c) 2024 PureForce

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. */

using Oxide.Core;
using System.Collections.Generic;
using ProtoBuf;
using UnityEngine;
using System.Linq;
using CompanionServer.Handlers;

namespace Oxide.Plugins
{
    [Info("Team Leader Online", "PureForce", "1.0.0")]
    [Description("Ensures the team leader position is always held by an online team member.")]
    internal class TeamLeaderOnline : RustPlugin
    {
        private Dictionary<ulong, ulong> teamPendingLeader = new Dictionary<ulong, ulong>();
        private Dictionary<ulong, ulong> teamLeaderPriority = new Dictionary<ulong, ulong>();


        #region Messages
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Admin.Promote.Fail"] = "Failed to promote user {0}.",
                ["Admin.Promote.Success"] = "User {0} now has leader priority.",
                ["Admin.Promote.Syntax"] = "Syntax: /tlo.promote <steamId>",
                ["Claim.Fail"] = "Failed to claim team.",
                ["Claim.LeaderExists"] = "Your team already has a priority leader.",
                ["Claim.Success"] = "You now have team leader priority.",
                ["Claim.Suggest"] = "Claim your team's priority leader position with <color=#AAFF00>/tlo.claim</color> this grants you leader position on login regardless of who currently has it. Only the priority leader can promote another team member to the priority leader position.",
                ["InvalidSteamId"] = "Invalid SteamId.",
                ["NoActivePlayerFound"] = "No active player found.",
                ["NoPermission"] = "You do not have permission.",
                ["NoPlayerTeam"] = "No player team found.",
            }, this);
        }

        private string GetMessage(string key, BasePlayer player = null)
        {
            string userId = player?.UserIDString;
            return lang.GetMessage(key, this, userId);
        }
        #endregion


        #region Saved Data
        private bool dataChanged = false;
        private const string FILE_LEADER_PRIORITY = "TeamLeaderOnline/LeaderPriority";

        private void SaveData()
        {
            dataChanged = false;
            WriteObject(FILE_LEADER_PRIORITY, teamLeaderPriority);
        }

        private void LoadData()
        {
            teamLeaderPriority = ReadObject<Dictionary<ulong, ulong>>(FILE_LEADER_PRIORITY);
        }

        private void OnServerSave()
        {
            if (!dataChanged)
                return;

            SaveData();
        }

        private void WriteObject<T>(string name, T value)
        {
            Interface.Oxide.DataFileSystem.WriteObject<T>(name, value);
        }

        private T ReadObject<T>(string name)
        {
            return Interface.Oxide.DataFileSystem.ReadObject<T>(name);
        }
        #endregion


        #region Permissions
        private const string PERM_ADMIN = "teamleaderonline.admin";
        private const string PERM_CLAIM = "teamleaderonline.claim";

        private bool HasAdminPermission(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, PERM_ADMIN);
        }

        private bool HasPermissionToClaim(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, PERM_CLAIM);
        }
        #endregion


        #region Commands
        [ChatCommand("tlo.claim")]
        private void ChatCommand_ClaimLeader(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (!HasPermissionToClaim(player))
            {
                PrintToChat(player, GetMessage("NoPermission", player));
                return;
            }

            if (player.Team == null)
            {
                PrintToChat(player, GetMessage("NoPlayerTeam", player));
                return;
            }

            ulong teamId = player.Team.teamID;
            if (TeamHasPriorityLeader(teamId))
            {
                PrintToChat(player, GetMessage("Claim.LeaderExists", player));
                return;
            }

            bool success = SetTeamLeader(player.Team, player.userID, true);
            string msg = success ? "Claim.Success" : "Claim.Fail";
            PrintToChat(player, GetMessage(msg, player));
        }

        [ChatCommand("tlo.promote")]
        private void ChatCommand_Promote(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (!HasAdminPermission(player))
            {
                PrintToChat(player, GetMessage("NoPermission", player));
                return;
            }

            if (args == null || args.Length != 1)
            {
                PrintToChat(player, GetMessage("Admin.Promote.Syntax", player));
                return;
            }

            ulong targetId;
            if (!ulong.TryParse(args[0], out targetId) || !targetId.IsSteamId())
            {
                PrintToChat(player, GetMessage("InvalidSteamId", player));
                return;
            }

            BasePlayer target = BasePlayer.activePlayerList.FirstOrDefault(x => x.userID == targetId);
            if (target == null)
            {
                PrintToChat(player, GetMessage("NoActivePlayerFound", player));
                return;
            }

            if (target.Team == null)
            {
                PrintToChat(player, GetMessage("NoPlayerTeam", player));
                return;
            }

            bool success = SetTeamLeader(target.Team, target.userID, true);
            string msg = success ? "Admin.Promote.Success" : "Admin.Promote.Fail";
            PrintToChat(player, GetMessage(msg, player), target.userID);
        }

        [ConsoleCommand("tlo.promote")]
        private void ConsoleCommand_Promote(ConsoleSystem.Arg arg)
        {
            if (arg == null)
                return;

            if (!arg.IsRcon)
            {
                BasePlayer player = arg.Player();
                if (player != null && !HasAdminPermission(player)) 
                {
                    arg.ReplyWith(GetMessage("NoPermission"));
                    return;
                }
            }

            if (arg.Args == null || arg.Args.Length != 1)
            {
                arg.ReplyWith(GetMessage("Admin.Promote.Syntax"));
                return;
            }

            ulong targetId;
            if (!ulong.TryParse(arg.Args[0], out targetId) || !targetId.IsSteamId())
            {
                arg.ReplyWith(GetMessage("InvalidSteamId"));
                return;
            }

            BasePlayer target = BasePlayer.activePlayerList.FirstOrDefault(x => x.userID == targetId);
            if (target == null)
            {
                arg.ReplyWith(GetMessage("NoActivePlayerFound"));
                return;
            }

            if (target.Team == null)
            {
                arg.ReplyWith(GetMessage("NoPlayerTeam"));
                return;
            }

            bool success = SetTeamLeader(target.Team, target.userID, true);
            string msg = success ? "Admin.Promote.Success" : "Admin.Promote.Fail";
            arg.ReplyWith(string.Format(GetMessage(msg), target.userID));
        }
        #endregion


        #region Initialization
        private void Init()
        {
            LoadData();
        }

        private void OnServerInitialized(bool initial)
        {
            permission.RegisterPermission(PERM_ADMIN, this);
            permission.RegisterPermission(PERM_CLAIM, this);

            if (ShouldWipeTeamData())
            {
                teamLeaderPriority.Clear();
                teamPendingLeader.Clear();
                SaveData();
            }

            if (teamPendingLeader.Count == 0)
            {
                Unsubscribe("OnTeamUpdated");
            }

            if (!initial)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    OnPlayerConnected(player);
                }
            }
        }
        #endregion


        #region Team-Related Hooks
        private void OnPlayerConnected(BasePlayer player)
        {
            var team = player?.Team;
            if (team == null || player.userID == team.teamLeader)
                return;

            if (!TeamHasPriorityLeader(team.teamID) && HasPermissionToClaim(player))
                PrintToChat(player, GetMessage("Claim.Suggest", player));

            if (!IsLeaderOnline(team) || HasLeaderPriority(team, player.userID))
                SetTeamLeader(team, player.userID);
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var team = player?.Team;
            if (team == null || player.userID != team.teamLeader)
                return;

            var teammate = GetEligibleOnlineTeammate(team);
            if (teammate == null)
                return;

            SetTeamLeader(team, teammate.userid);
        }

        private void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team)
        {
            if (player == null || team == null)
                return;

            SetLeaderPriority(team.teamID, player.userID);
        }

        private void OnTeamDisbanded(RelationshipManager.PlayerTeam team)
        {
            if (team == null)
                return;

            teamLeaderPriority.Remove(team.teamID);
            teamPendingLeader.Remove(team.teamID);
        }

        private void OnTeamPromote(RelationshipManager.PlayerTeam team, BasePlayer candidate)
        {
            if (team == null || candidate == null)
                return;

            if (!HasLeaderPriority(team, team.teamLeader))
                return;

            teamPendingLeader[team.teamID] = candidate.userID;
            Subscribe("OnTeamUpdated");
        }

        private void OnTeamUpdated(ulong teamId, PlayerTeam team, BasePlayer player)
        {
            ulong pendingLeader;
            if (!teamPendingLeader.TryGetValue(teamId, out pendingLeader) || team.teamLeader != pendingLeader)
                return;

            SetLeaderPriority(team.teamID, team.teamLeader);
            teamPendingLeader.Remove(teamId);
            if (teamPendingLeader.Count == 0)
                Unsubscribe("OnTeamUpdated");
        }

        private object OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong target)
        {
            if (HasLeaderPriority(team, target))
                return true;

            return null;
        }

        private void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            if (HasLeaderPriority(team, player.userID))
                RemoveLeaderPriority(team.teamID);
        }
        #endregion


        #region Team Methods
        private bool ShouldWipeTeamData()
        {
            RelationshipManager manager = RelationshipManager.ServerInstance;
            bool noTeams = manager != null && manager.teams.Count == 0;
            return noTeams && teamLeaderPriority.Count > 0;
        }

        private bool TeamHasPriorityLeader(ulong teamId)
        {
            return teamLeaderPriority.ContainsKey(teamId);
        }

        private bool HasLeaderPriority(RelationshipManager.PlayerTeam team, ulong userId)
        {
            ulong leaderPriority;
            teamLeaderPriority.TryGetValue(team.teamID, out leaderPriority);
            return userId == leaderPriority;
        }

        private bool IsLeaderOnline(RelationshipManager.PlayerTeam team)
        {
            var members = team.GetOnlineMemberConnections();
            return members != null && members.Exists((x) => x.userid == team.teamLeader && x.connected);
        }

        private Network.Connection GetEligibleOnlineTeammate(RelationshipManager.PlayerTeam team)
        {
            var members = team.GetOnlineMemberConnections();
            if (members == null)
                return null;

            return members.Find((x) => x.userid != team.teamLeader && x.connected);
        }

        private bool SetTeamLeader(RelationshipManager.PlayerTeam team, ulong userid, bool setPriority = false)
        {
            if (!team.members.Contains(userid))
                return false;

            team.SetTeamLeader(userid);
            if (setPriority)
                SetLeaderPriority(team.teamID, userid);

            return true;
        }

        private void SetLeaderPriority(ulong teamId, ulong playerId)
        {
            teamLeaderPriority[teamId] = playerId;
            dataChanged = true;
        }

        private void RemoveLeaderPriority(ulong teamId)
        {
            teamLeaderPriority.Remove(teamId);
            dataChanged = true;
        }
        #endregion
    }
}

// --- End of file: TeamLeaderOnline.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/timed-execute ---
// --- Original File Path: T/TimedExecute/TimedExecute.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Timed Execute", "PaiN & misticos", "0.7.4")]
    [Description("Execute commands every (x) seconds.")]
    class TimedExecute : CovalencePlugin
    {
        public static TimedExecute Plugin;

        public enum Types
        {
            RealTime,
            InGameTime,
            Repeater,
            TimerOnce
        };

        Timer ptimer;

        #region Classes
        class Timers
        {
            public static List<Timer> AllTimers = new List<Timer>();
            public static Timer InGame;
            public static Timer Real;
            public static Timer Repeat;
            public static Timer Once;

            public static void ResetTimer(Types type)
            {
                switch (type)
                {
                    case Types.InGameTime:
                        RunTimer(Types.InGameTime);
                        break;

                    case Types.RealTime:
                        RunTimer(Types.RealTime);
                        break;

                    case Types.Repeater:
                        RunTimer(Types.Repeater);
                        break;

                    case Types.TimerOnce:
                        RunTimer(Types.TimerOnce);
                        break;
                }
            }

            public static void RunTimer(Types type)
            {
				float timeinterval = 1f;
				#if RUST
                timeinterval = 4.5f;
				#endif
				
                switch (type)
                {
                    case Types.InGameTime:
                         if (InGame != null) InGame.Destroy();
                         Plugin.Puts("The InGame timer has started");
                         AllTimers.Add(InGame = Plugin.timer.Repeat(timeinterval, 0, () =>
                         {
                             foreach (var cmd in Plugin.Config["InGameTime-Timer"] as Dictionary<string, object>)
                                 if (Plugin.covalence.Server.Time.ToShortTimeString() == cmd.Key)
                                 {
                                     Plugin.covalence.Server.Command(cmd.Value.ToString());
                                     Plugin.Puts(string.Format("ran CMD: {0}", cmd.Value));
                                 }
                         }
                         ));
                         break;
                     
                    case Types.RealTime:
                        if (Real != null) Real.Destroy();
                        Plugin.Puts("The RealTime timer has started");
                        AllTimers.Add(Real = Plugin.timer.Repeat(1, 0, () =>
                        {
                            foreach (var cmd in Plugin.Config["RealTime-Timer"] as Dictionary<string, object>)
                                if (System.DateTime.Now.ToString("HH:mm:ss") == cmd.Key.ToString())
                                {
                                    Plugin.covalence.Server.Command(cmd.Value.ToString());
                                    Plugin.Puts(string.Format("ran CMD: {0}", cmd.Value));
                                }
                        }
                        ));
                        break;

                    case Types.Repeater:
                        if (Repeat != null) Repeat.Destroy();
                        Plugin.Puts("The Repeat timer has started");
                        foreach (var cmd in Plugin.Config["TimerRepeat"] as Dictionary<string, object>)
                        {
                            Repeat = Plugin.timer.Repeat(Convert.ToSingle(cmd.Value), 0, () => {
                                Plugin.covalence.Server.Command(cmd.Key);
                                Plugin.Puts(string.Format("ran CMD: {0}", cmd.Key));
                            });
                        }
                        AllTimers.Add(Repeat);
                        break;

                    case Types.TimerOnce:
                        if (Once != null) Once.Destroy();
                        Plugin.Puts("The Timer-Once timer has started");
                        foreach (var cmd in Plugin.Config["TimerOnce"] as Dictionary<string, object>)
                        {
                            Once = Plugin.timer.Once(Convert.ToSingle(cmd.Value), () => {
                                Plugin.covalence.Server.Command(cmd.Key);
                                Plugin.Puts(string.Format("ran CMD: {0}", cmd.Key));
                            });
                        }
                        AllTimers.Add(Once);
                        break;
                }
            }

            public static void DestroyAll()
            {
                foreach (Timer tim in AllTimers)
                    if (tim != null)
                        tim.Destroy();
            }

            public static void RunAll()
            {
                if (Convert.ToBoolean(Plugin.Config["EnableInGameTime-Timer"]) == true)
                    RunTimer(Types.InGameTime);

                if (Convert.ToBoolean(Plugin.Config["EnableRealTime-Timer"]) == true)
                    RunTimer(Types.RealTime);

                if (Convert.ToBoolean(Plugin.Config["EnableTimerRepeat"]) == true)
                    RunTimer(Types.Repeater);

                if (Convert.ToBoolean(Plugin.Config["EnableTimerOnce"]) == true)
                    RunTimer(Types.TimerOnce);
            }
        }
        #endregion

        void OnServerInitialized()
        {
            Plugin = this;
            Timers.RunAll();

        }

        void Unload()
        {
            Timers.DestroyAll();
            Plugin = null;
        }

        Dictionary<string, object> repeatcmds = new Dictionary<string, object>();
        Dictionary<string, object> chaincmds = new Dictionary<string, object>();
        Dictionary<string, object> realtimecmds = new Dictionary<string, object>();
        Dictionary<string, object> ingamecmds = new Dictionary<string, object>();

        protected override void LoadDefaultConfig()
        {
            repeatcmds.Add("command1 arg", 300);
            repeatcmds.Add("command2 'msg'", 300);
            Puts("Creating a new configuration file!");
            if (Config["TimerRepeat"] == null) Config["TimerRepeat"] = repeatcmds;

            chaincmds.Add("command1 'msg'", 60);
            chaincmds.Add("command2 'msg'", 120);
            chaincmds.Add("command3 arg", 180);
            chaincmds.Add("reset.timeronce", 181);
            if (Config["TimerOnce"] == null) Config["TimerOnce"] = chaincmds;

            if (Config["EnableTimerRepeat"] == null) Config["EnableTimerRepeat"] = true;
            if (Config["EnableTimerOnce"] == null) Config["EnableTimerOnce"] = true;
            if (Config["EnableRealTime-Timer"] == null) Config["EnableRealTime-Timer"] = true;
            if (Config["EnableInGameTime-Timer"] == null) Config["EnableInGameTime-Timer"] = true;

            realtimecmds.Add("16:00:00", "command1 arg");
            realtimecmds.Add("16:30:00", "command2 arg");
            realtimecmds.Add("17:00:00", "command3 arg");
            realtimecmds.Add("18:00:00", "command4 arg");
            if (Config["RealTime-Timer"] == null) Config["RealTime-Timer"] = realtimecmds;

            ingamecmds.Add("01:00", "weather rain");
            ingamecmds.Add("12:00", "command 1");
            ingamecmds.Add("15:00", "command 2");
            if (Config["InGameTime-Timer"] == null) Config["InGameTime-Timer"] = ingamecmds;
        }

        [Command("reset.timeronce", "resettimeronce")]
        void cmdReset(IPlayer player, string cmd, string[] args)
        {
            if (player.IsAdmin)
                Timers.ResetTimer(Types.TimerOnce);
        }
    }
}

// --- End of file: TimedExecute.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/time-of-day ---
// --- Original File Path: T/TimeOfDay/TimeOfDay.cs ---

﻿using Oxide.Core.Plugins;
using Oxide.Core;
using System;
using System.Text;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("TimeOfDay", "FuJiCuRa", "2.3.4")]
    [Description("Does alter day and night duration.")]
    public class TimeOfDay : RustPlugin
    {
		bool Changed;
		bool Initialized;
		int componentSearchAttempts;
		TOD_Time timeComponent;
		bool activatedDay;

		int authLevelCmds;
		int authLevelFreeze;
		int dayLength;
		int nightLength;
		int presetDay;
		int presetMonth;
		int presetYear;
		bool setPresetDate;
		bool freezeDate;
		bool autoSkipNight;
		bool autoSkipDay;
		bool logAutoSkipConsole;
		bool freezeTimeOnload;
		float timeToFreeze;
		
		object GetConfig(string menu, string datavalue, object defaultValue)
		{
			var data = Config[menu] as Dictionary<string, object>;
			if (data == null)
			{
				data = new Dictionary<string, object>();
				Config[menu] = data;
				Changed = true;
			}
			object value;
			if (!data.TryGetValue(datavalue, out value))
			{
				value = defaultValue;
				data[datavalue] = value;
				Changed = true;
			}
			return value;
		}

		void LoadVariables()
		{
			dayLength =  System.Convert.ToInt32(GetConfig("Settings", "dayLength", 30));
			nightLength =  System.Convert.ToInt32(GetConfig("Settings", "nightLength", 30));
			freezeDate = System.Convert.ToBoolean(GetConfig("Settings", "freezeDate", false));
			authLevelCmds = System.Convert.ToInt32(GetConfig("Settings", "authLevelCmds", 1));
			authLevelFreeze = System.Convert.ToInt32(GetConfig("Settings", "authLevelFreeze", 2));
			autoSkipNight = System.Convert.ToBoolean(GetConfig("Settings", "autoSkipNight", false));
			autoSkipDay = System.Convert.ToBoolean(GetConfig("Settings", "autoSkipDay", false));
			logAutoSkipConsole = System.Convert.ToBoolean(GetConfig("Settings", "logAutoSkipConsole", true));
			
			presetDay =  System.Convert.ToInt32(GetConfig("DatePreset", "presetDay", 1));
			presetMonth =  System.Convert.ToInt32(GetConfig("DatePreset", "presetMonth", 1));
			presetYear =  System.Convert.ToInt32(GetConfig("DatePreset", "presetYear", 2020));
			setPresetDate = System.Convert.ToBoolean(GetConfig("DatePreset", "setPresetDate", false));
			
			freezeTimeOnload = System.Convert.ToBoolean(GetConfig("TimeFreeze", "freezeTimeOnload", false));
			timeToFreeze = System.Convert.ToSingle(GetConfig("TimeFreeze", "timeToFreeze", 12.0));

			if (!Changed) return;
			SaveConfig();
			Changed = false;
		}

		protected override void LoadDefaultConfig()
		{
			Config.Clear();
			LoadVariables();
		}

		void Loaded()
		{
			LoadVariables();
			Initialized = false;
		}

		void Unload()
		{
			if (timeComponent == null || !Initialized) return;
			timeComponent.OnSunrise -= OnSunrise;
            timeComponent.OnSunset -= OnSunset;
			timeComponent.OnDay -= OnDay;
			timeComponent.OnHour -= OnHour;
		}

		void OnServerInitialized()
		{
			if (TOD_Sky.Instance == null)
            {
				componentSearchAttempts++;
                if (componentSearchAttempts < 10)
                    timer.Once(1, OnServerInitialized);
                else
                    PrintWarning("Could not find required component after 10 attempts. Plugin disabled");
                return;
            }
            timeComponent = TOD_Sky.Instance.Components.Time;
            if (timeComponent == null)
            {
                PrintWarning("Could not fetch time component. Plugin disabled");
                return;
            }
			if (setPresetDate)
			{
				TOD_Sky.Instance.Cycle.Day = presetDay;
				TOD_Sky.Instance.Cycle.Month = presetMonth;
				TOD_Sky.Instance.Cycle.Year = presetYear;
			}
			SetTimeComponent();
			if (freezeTimeOnload)
				StartupFreeze();
		}

        void SetTimeComponent()
        {
            timeComponent.ProgressTime = true;
            timeComponent.UseTimeCurve = false;
            timeComponent.OnSunrise += OnSunrise;
			timeComponent.OnSunset += OnSunset;
			timeComponent.OnDay += OnDay;
			timeComponent.OnHour += OnHour;
			Initialized = true;
            if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime && TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunsetTime)
                OnSunrise();
            else
                OnSunset();
        }
		
		void StartupFreeze()
		{
			if (!Initialized) return;
			timeComponent.ProgressTime = false;
			ConVar.Env.time = timeToFreeze;
		}

        void OnDay()
        {
			if (Initialized && freezeDate)
				--TOD_Sky.Instance.Cycle.Day;
		}

        void OnHour()
        {
			if (!Initialized) return;
			if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime && TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunsetTime && !activatedDay)
			{
				OnSunrise();
				return;
			}
			if ((TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunsetTime || TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunriseTime) && activatedDay)
			{
				OnSunset();
				return;
			}
		}

        void OnSunrise()
        {
			if (!Initialized) return;
			if (autoSkipDay && !autoSkipNight)
			{
				TOD_Sky.Instance.Cycle.Hour = TOD_Sky.Instance.SunsetTime;
				if (logAutoSkipConsole)
					Puts("Daytime autoskipped");
				OnSunset();
				return;
			}
			timeComponent.DayLengthInMinutes = dayLength * (24.0f / (TOD_Sky.Instance.SunsetTime - TOD_Sky.Instance.SunriseTime));
			if (!activatedDay)
				Interface.CallHook("OnTimeSunrise");
			activatedDay = true;
        }

        void OnSunset()
        {
			if (!Initialized) return;
			if (autoSkipNight)
			{
				float timeToAdd = (24 - TOD_Sky.Instance.Cycle.Hour) + TOD_Sky.Instance.SunriseTime;
				TOD_Sky.Instance.Cycle.Hour += timeToAdd;
				if (logAutoSkipConsole)
					Puts("Nighttime autoskipped");
				OnSunrise();
				return;
			}
			timeComponent.DayLengthInMinutes = nightLength * (24.0f / (24.0f - (TOD_Sky.Instance.SunsetTime - TOD_Sky.Instance.SunriseTime)));
			if (activatedDay)
				Interface.CallHook("OnTimeSunset");
			activatedDay = false;
        }
		
		[ConsoleCommand("tod.daylength")]
        void ConsoleDayLength(ConsoleSystem.Arg arg)
        {
            if (!Initialized) return;
			if (arg.Connection != null && arg.Connection.authLevel < authLevelCmds) return;
			if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, $"Current 'dayLength' setting is '{dayLength}'");
                return;
            }
			
			int newDaylength = 0;
			if (int.TryParse(arg.Args[0], out newDaylength))
			{
				if (newDaylength < 1)
				{
					SendReply(arg, $"The new daylength must be greater zero");
					return;
				}
			}
			dayLength = newDaylength;
			SendReply(arg, $"The 'dayLength' has been set to '{dayLength}'");
			
			if (TOD_Sky.Instance.IsDay)
				OnSunrise();
			else
				OnSunset();
			Config["Settings", "dayLength"] = dayLength;
			SaveConfig();
		}
		
		[ConsoleCommand("tod.nightlength")]
        void ConsoleNightLength(ConsoleSystem.Arg arg)
        {
            if (!Initialized) return;
			if (arg.Connection != null && arg.Connection.authLevel < authLevelCmds) return;
			if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, $"Current 'nightLength' setting is '{nightLength}'");
                return;
            }
			
			int newNightlength = 0;
			if (int.TryParse(arg.Args[0], out newNightlength))
			{
				if (newNightlength < 1)
				{
					SendReply(arg, $"The new nightlength must be greater zero");
					return;
				}
			}
			nightLength = newNightlength;
			SendReply(arg, $"The 'nightLength' has been set to '{nightLength}'");
			if (TOD_Sky.Instance.IsDay)
				OnSunrise();
			else
				OnSunset();
			Config["Settings", "nightLength"] = nightLength;
			SaveConfig();
		}
		
		[ConsoleCommand("tod.freezetime")]
        void ConsoleFreezeTime(ConsoleSystem.Arg arg)
        {
            if (!Initialized) return;
			if (arg.Connection != null && arg.Connection.authLevel < authLevelFreeze) return;

			timeComponent.ProgressTime = !timeComponent.ProgressTime;
			
			if (timeComponent.ProgressTime)
				SendReply(arg, $"The game time was unfreezed");
			else
				SendReply(arg, $"The game time was freezed");
		}

		[ConsoleCommand("tod.skipday")]
        void ConsoleSkipDay(ConsoleSystem.Arg arg)
        {
            if (!Initialized) return;
			if (arg.Connection != null && arg.Connection.authLevel < authLevelCmds) return;
			if (TOD_Sky.Instance.IsNight)
			{
				SendReply(arg, $"Night is already active");
				return;
			}
			OnSunset();
			TOD_Sky.Instance.Cycle.Hour = TOD_Sky.Instance.SunsetTime;
			SendReply(arg, $"Current daytime skipped");
		}

		[ConsoleCommand("tod.skipnight")]
        void ConsoleSkipNight(ConsoleSystem.Arg arg)
        {
            if (!Initialized) return;
			if (arg.Connection != null && arg.Connection.authLevel < authLevelCmds) return;
			if (TOD_Sky.Instance.IsDay)
			{
				SendReply(arg, $"Day is already active");
				return;
			}
			OnSunrise();
			TOD_Sky.Instance.Cycle.Hour = TOD_Sky.Instance.SunriseTime;
			SendReply(arg, $"Current nighttime skipped");
		}			

        [ChatCommand("tod")]
        private void TodCommand(BasePlayer player, string command, string[] args)
        {
			if (!Initialized)
				return;
			TimeSpan ts1= TimeSpan.FromHours(TOD_Sky.Instance.SunriseTime);
			TimeSpan ts2= TimeSpan.FromHours(TOD_Sky.Instance.SunsetTime);
			
            StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine(FormNeutralMessage("-------- Settings --------"));
			stringBuilder.AppendLine("Current Time".PadRight(15) + TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm:ss"));
			stringBuilder.AppendLine("Sunrise Hour".PadRight(15) + string.Format("{0}:{1}", System.Math.Truncate(ts1.TotalHours).ToString(), ts1.Minutes.ToString()));
			stringBuilder.AppendLine("Sunset Hour".PadRight(15) + string.Format("{0}:{1}", System.Math.Truncate(ts2.TotalHours).ToString(), ts2.Minutes.ToString()));
			stringBuilder.AppendLine("Daylength".PadRight(15) + dayLength.ToString() + " minutes");
			stringBuilder.Append("Nightlength".PadRight(15) + nightLength.ToString() + " minutes");
			PrintPluginMessageToChat(player, stringBuilder.ToString().TrimEnd());
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            if (!Initialized) return;
			StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.Append(FormNeutralMessage("-------------------- Available Commands --------------------\n"));
			stringBuilder.Append(FormNeutralMessage("/tod") + " - Shows current Time Of Day.\n");
            PrintPluginMessageToChat(player, stringBuilder.ToString());
        }

        private void PrintPluginMessageToChat(BasePlayer player, string message)
        {
            PrintToChat(player, "<b><size=16>[<color=#ffa500ff>" + this.Name + "</color>]</size></b>\n" + message);
        }

        private void PrintPluginMessageToChat(string message)
        {
            PrintToChat("<b><size=16>[<color=#ffa500ff>" + this.Name + "</color>]</size></b>\n" + message);
        }

        private string FormNeutralMessage(string message)
        {
            return "<color=#c0c0c0ff>" + message + "</color>";
        }

    }
}

// --- End of file: TimeOfDay.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/turret-config ---
// --- Original File Path: T/TurretConfig/TurretConfig.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Turret Config", "Calytic", "2.1.0")]
    [Description("Allows customizing and configuring the way turrets work")]
    class TurretConfig : RustPlugin
    {
        #region Variables

        [PluginReference]
        // ReSharper disable once InconsistentNaming
        private Plugin Vanish = null;

        private const string AutoTurretPrefab = "assets/prefabs/npc/autoturret/autoturret_deployed.prefab";
        private const string FlameTurretPrefab = "assets/prefabs/npc/flame turret/flameturret.deployed.prefab";

        #endregion

        private uint _autoTurretPrefabId;
        private uint _flameTurretPrefabId;

        #region Configuration

        // GLOBAL OVERRIDES
        private bool _adminOverride;
        private List<object> _animals;
        private bool _animalOverride;
        private bool _sleepOverride;
        private bool _infiniteAmmo;

        // MODIFIERS
        private bool _useGlobalDamageModifier;
        private float _globalDamageModifier;

        // AUTO TURRET DEFAULTS
        private float _defaultBulletModifier;
        private float _defaultBulletSpeed;
        private string _defaultAmmoType;
        private float _defaultSightRange;
        private float _defaultAutoHealth;
        private float _defaultAimCone;

        // AUTO TURRET PERMISSION-BASED SETTINGS
        private Dictionary<string, object> _bulletModifiers;
        private Dictionary<string, object> _bulletSpeeds;
        private Dictionary<string, object> _ammoTypes;
        private Dictionary<string, object> _sightRanges;
        private Dictionary<string, object> _autoHealths;
        private Dictionary<string, object> _aimCones;

        // FLAME TURRET DEFAULTS
        private float _defaultFlameModifier;
        private float _defaultArc;
        private float _defaultTriggerDuration;
        private float _defaultFlameRange;
        private float _defaultFlameRadius;
        private float _defaultFuelPerSec;
        private float _defaultFlameHealth;

        // FLAME TURRET PERMISSION-BASED SETTINGS
        private Dictionary<string, object> _flameModifiers;
        private Dictionary<string, object> _arcs;
        private Dictionary<string, object> _triggerDurations;
        private Dictionary<string, object> _flameRanges;
        private Dictionary<string, object> _flameRadiuses;
        private Dictionary<string, object> _fuelPerSecs;
        private Dictionary<string, object> _flameHealths;

        #endregion

        private void Init()
        {
            LoadData();

            _autoTurretPrefabId = StringPool.Get(AutoTurretPrefab);
            _flameTurretPrefabId = StringPool.Get(FlameTurretPrefab);

            permission.RegisterPermission("turretconfig.infiniteammo", this);

            _adminOverride = GetConfig("Settings", "adminOverride", true);
            _animalOverride = GetConfig("Settings", "animalOverride", false);
            _sleepOverride = GetConfig("Settings", "sleepOverride", false);
            _animals = GetConfig("Settings", "animals", GetPassiveAnimals());
            _infiniteAmmo = GetConfig("Settings", "infiniteAmmo", false);

            _useGlobalDamageModifier = GetConfig("Settings", "useGlobalDamageModifier", false);
            _globalDamageModifier = GetConfig("Settings", "globalDamageModifier", 1f);

            _defaultBulletModifier = GetConfig("Auto", "defaultBulletModifier", 1f);
            _defaultAutoHealth = GetConfig("Auto", "defaultAutoHealth", 1000f);
            _defaultAimCone = GetConfig("Auto", "defaultAimCone", 5f);
            _defaultSightRange = GetConfig("Auto", "defaultSightRange", 30f);
            _defaultBulletSpeed = GetConfig("Auto", "defaultBulletSpeed", 10f);
            _defaultAmmoType = GetConfig("Auto", "defaultAmmoType", "ammo.rifle");

            _bulletModifiers = GetConfig("Auto", "bulletModifiers", GetDefaultBulletModifiers());
            _bulletSpeeds = GetConfig("Auto", "bulletSpeeds", GetDefaultBulletSpeeds());
            _ammoTypes = GetConfig("Auto", "ammoTypes", GetDefaultAmmoTypes());
            _sightRanges = GetConfig("Auto", "sightRanges", GetDefaultSightRanges());
            _autoHealths = GetConfig("Auto", "autoHealths", GetDefaultAutoHealths());
            _aimCones = GetConfig("Auto", "aimCones", GetDefaultAimCones());

            _defaultFlameModifier = GetConfig("Flame", "defaultFlameModifier", 1f);
            _defaultArc = GetConfig("Flame", "defaultArc", 45f);
            _defaultTriggerDuration = GetConfig("Flame", "defaultTriggerDuration", 5f);
            _defaultFlameRange = GetConfig("Flame", "defaultFlameRange", 7f);
            _defaultFlameRadius = GetConfig("Flame", "defaultFlameRadius", 4f);
            _defaultFuelPerSec = GetConfig("Flame", "defaultFuelPerSec", 1f);
            _defaultFlameHealth = GetConfig("Flame", "defaultFlameHealth", 300f);

            _flameModifiers = GetConfig("Flame", "flameModifiers", GetDefaultFlameModifiers());
            _arcs = GetConfig("Flame", "arcs", GetDefaultArcs());
            _triggerDurations = GetConfig("Flame", "triggerDurations", GetDefaultTriggerDurations());
            _flameRanges = GetConfig("Flame", "flameRanges", GetDefaultFlameRanges());
            _flameRadiuses = GetConfig("Flame", "flameRadiuses", GetDefaultFlameRadiuses());
            _fuelPerSecs = GetConfig("Flame", "fuelPerSecs", GetDefaultFuelPerSecs());
            _flameHealths = GetConfig("Flame", "flameHealths", GetDefaultFlameHealths());

            LoadPermissions(_bulletModifiers);
            LoadPermissions(_bulletSpeeds);
            LoadPermissions(_ammoTypes);
            LoadPermissions(_sightRanges);
            LoadPermissions(_autoHealths);
            LoadPermissions(_aimCones);

            LoadPermissions(_arcs);
            LoadPermissions(_triggerDurations);
            LoadPermissions(_flameRanges);
            LoadPermissions(_flameRadiuses);
            LoadPermissions(_fuelPerSecs);
            LoadPermissions(_flameHealths);
        }

        private void OnServerInitialized()
        {
            LoadAutoTurrets();
            LoadFlameTurrets();

            if (_useGlobalDamageModifier)
            {
                Subscribe("OnPlayerAttack");
            }
            else
            {
                Unsubscribe("OnPlayerAttack");
            }

            if (_infiniteAmmo)
            {
                Subscribe("OnItemUse");
                Subscribe("OnLootEntity");
                Subscribe("OnTurretStartup");
                Subscribe("OnTurretShutdown");
                Subscribe("CanPickupEntity");
            }
            else
            {
                Unsubscribe("OnItemUse");
                Unsubscribe("OnLootEntity");
                Unsubscribe("OnTurretStartup");
                Unsubscribe("OnTurretShutdown");
                Unsubscribe("CanPickupEntity");
            }

            if (_animalOverride || _adminOverride || _sleepOverride)
            {
                Subscribe("CanBeTargeted");
            }
            else
            {
                Unsubscribe("CanBeTargeted");
            }
        }

        private void LoadPermissions(Dictionary<string, object> type)
        {
            foreach (var kvp in type)
            {
                if (!permission.PermissionExists(kvp.Key))
                {
                    if (!string.IsNullOrEmpty(kvp.Key))
                    {
                        permission.RegisterPermission(kvp.Key, this);
                    }
                }
            }
        }

        protected void LoadFlameTurrets()
        {
            var turrets = UnityEngine.Object.FindObjectsOfType<FlameTurret>();

            if (turrets.Length > 0)
            {
                var i = 0;
                for (var index = turrets.Length - 1; index >= 0; index--)
                {
                    UpdateFlameTurret(turrets[index], true);
                    i++;
                }

                PrintWarning("Configured {0} flame turrets", i);
            }
        }

        protected void LoadAutoTurrets()
        {
            var turrets = UnityEngine.Object.FindObjectsOfType<AutoTurret>();

            if (turrets.Length > 0)
            {
                var i = 0;
                for (var index = turrets.Length - 1; index >= 0; index--)
                {
                    UpdateAutoTurret(turrets[index]);
                    i++;
                }

                PrintWarning("Configured {0} turrets", i);
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating new configuration");
            Config.Clear();

            Config["Settings", "adminOverride"] = true;
            Config["Settings", "sleepOverride"] = false;
            Config["Settings", "animalOverride"] = true;
            Config["Settings", "useGlobalDamageModifier"] = false;
            Config["Settings", "globalDamageModifier"] = 1f;

            Config["Settings", "animals"] = GetPassiveAnimals();
            Config["Settings", "infiniteAmmo"] = false;

            Config["Auto", "defaultBulletModifier"] = 1f;
            Config["Auto", "defaultBulletSpeed"] = 200f;
            Config["Auto", "defaultAmmoType"] = "ammo.rifle";
            Config["Auto", "defaultSightRange"] = 30f;
            Config["Auto", "defaultAutoHealth"] = 1000;
            Config["Auto", "defaultAimCone"] = 5f;

            Config["Auto", "bulletModifiers"] = GetDefaultBulletModifiers();
            Config["Auto", "bulletSpeeds"] = GetDefaultBulletSpeeds();
            Config["Auto", "ammoTypes"] = GetDefaultAmmoTypes();
            Config["Auto", "sightRanges"] = GetDefaultSightRanges();
            Config["Auto", "autoHealths"] = GetDefaultAutoHealths();
            Config["Auto", "aimCones"] = GetDefaultAimCones();

            Config["Flame", "defaultFlameModifier"] = 1f;
            Config["Flame", "defaultArc"] = 45f;
            Config["Flame", "defaultTriggerDuration"] = 5f;
            Config["Flame", "defaultFlameRange"] = 7f;
            Config["Flame", "defaultFlameRadius"] = 4f;
            Config["Flame", "defaultFuelPerSec"] = 1f;
            Config["Flame", "defaultFlameHealth"] = 300f;

            Config["Flame", "flameModifiers"] = GetDefaultFlameModifiers();
            Config["Flame", "arcs"] = GetDefaultArcs();
            Config["Flame", "triggerDurations"] = GetDefaultTriggerDurations();
            Config["Flame", "flameRanges"] = GetDefaultFlameRanges();
            Config["Flame", "flameRadiuses"] = GetDefaultFlameRadiuses();
            Config["Flame", "fuelPerSecs"] = GetDefaultFuelPerSecs();
            Config["Flame", "flameHealths"] = GetDefaultFlameHealths();
        }

        protected void ReloadConfig()
        {
            Config["VERSION"] = Version.ToString();

            // NEW CONFIGURATION OPTIONS HERE
            // END NEW CONFIGURATION OPTIONS

            PrintWarning("Upgrading Configuration File");
            SaveConfig();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Denied: Permission", "You lack permission to do that"}
            }, this);
        }

        private List<object> GetPassiveAnimals()
        {
            return new List<object>
            {
                "stag",
                "boar",
                "chicken",
                "horse"
            };
        }

        private Dictionary<string, object> GetDefaultBulletModifiers()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", 2f}
            };
        }

        private Dictionary<string, object> GetDefaultFlameModifiers()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", 2f}
            };
        }

        private Dictionary<string, object> GetDefaultBulletSpeeds()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", 200f}
            };
        }

        private Dictionary<string, object> GetDefaultSightRanges()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", 30f}
            };
        }

        private Dictionary<string, object> GetDefaultAmmoTypes()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", "ammo.rifle"}
            };
        }

        private Dictionary<string, object> GetDefaultAutoHealths()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", 1000f}
            };
        }

        private Dictionary<string, object> GetDefaultAimCones()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", 5f}
            };
        }

        private Dictionary<string, object> GetDefaultArcs()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", 45f}
            };
        }

        private Dictionary<string, object> GetDefaultTriggerDurations()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", 5f}
            };
        }

        private Dictionary<string, object> GetDefaultFlameRanges()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", 7f}
            };
        }

        private Dictionary<string, object> GetDefaultFlameRadiuses()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", 4f}
            };
        }

        private Dictionary<string, object> GetDefaultFuelPerSecs()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", 1f}
            };
        }

        private Dictionary<string, object> GetDefaultFlameHealths()
        {
            return new Dictionary<string, object>
            {
                {"turretconfig.default", 300f}
            };
        }

        private void LoadData()
        {
            if (Config["VERSION"] == null)
            {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig();
            }
            else if (GetConfig("VERSION", Version.ToString()) != Version.ToString())
            {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig();
            }
        }

        [ConsoleCommand("turrets.reload")]
        private void CcTurretReload(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel < 1)
                {
                    SendReply(arg, GetMsg("Denied: Permission", arg.Connection.userid.ToString()));
                    return;
                }
            }

            LoadAutoTurrets();
            LoadFlameTurrets();
        }

        private void OnLootEntity(BasePlayer looter, BaseEntity target)
        {
            if (!_infiniteAmmo) return;
            if (!permission.UserHasPermission(target.OwnerID.ToString(), "turretconfig.infiniteammo")) return;

            if (target is AutoTurret)
            {
                var autoTurret = target as AutoTurret;

                while(autoTurret.GetTotalAmmo() > 0)
                {
                    autoTurret.GetAttachedWeapon().primaryMagazine.contents = 0;
                    autoTurret.Reload();

                    autoTurret.UpdateTotalAmmo();
                }
            }
            else if(target is FlameTurret)
            {
                timer.Once(0.01f, looter.EndLooting);
            }
        }

        private void OnItemUse(Item item, int amount)
        {
            if (!_infiniteAmmo) return;

            var entity = item.parent?.entityOwner;
            if (entity != null)
            {
                if (entity is AutoTurret)
                {
                    var autoTurret = entity as AutoTurret;
                    if (autoTurret != null && autoTurret.IsPowered() && autoTurret.IsOnline())
                    {
                        if (!permission.UserHasPermission(autoTurret.OwnerID.ToString(), "turretconfig.infiniteammo")) return;
                        RefillAutoTurretAmmo(autoTurret);
                    }
                }

                if(entity is FlameTurret)
                {
                    var flameTurret = entity as FlameTurret;
                    if(flameTurret != null && !flameTurret.HasFuel())
                    {
                        if (!permission.UserHasPermission(flameTurret.OwnerID.ToString(), "turretconfig.infiniteammo")) return;
                        RefillFlameTurretFuel(flameTurret);
                    }
                }

            }
        }

        void OnTurretStartup(AutoTurret autoTurret)
        {
            CheckAutoTurretAmmo(autoTurret);
        }

        void OnTurretShutdown(AutoTurret autoTurret)
        {
            if (!_infiniteAmmo) return;
            if (!permission.UserHasPermission(autoTurret.OwnerID.ToString(), "turretconfig.infiniteammo")) return;

            while(autoTurret.GetTotalAmmo() > 0)
            {
                autoTurret.GetAttachedWeapon().primaryMagazine.contents = 0;
                autoTurret.Reload();

                autoTurret.UpdateTotalAmmo();
            }
        }

        private void CheckAutoTurretAmmo(AutoTurret autoTurret)
        {
            if (!_infiniteAmmo) return;
            if (!permission.UserHasPermission(autoTurret.OwnerID.ToString(), "turretconfig.infiniteammo")) return;

            RefillAutoTurretAmmo(autoTurret);

            autoTurret.Invoke(() => CheckAutoTurretAmmo(autoTurret), 5.75f);
        }

        private void RefillAutoTurretAmmo(AutoTurret autoTurret)
        {
            if (autoTurret.GetTotalAmmo() <= 1 && autoTurret.IsPowered() && autoTurret.IsOnline() && autoTurret.GetAttachedWeapon() != null)
            {
                autoTurret.inventory.AddItem(autoTurret.GetAttachedWeapon().primaryMagazine.ammoType, autoTurret.GetAttachedWeapon().primaryMagazine.capacity);
                autoTurret.Reload();
                autoTurret.SendNetworkUpdateImmediate(false);
            }
        }

        private void CheckFlameTurretFuel(FlameTurret flameTurret)
        {
            if (!_infiniteAmmo) return;
            if (!permission.UserHasPermission(flameTurret.OwnerID.ToString(), "turretconfig.infiniteammo")) return;

            RefillFlameTurretFuel(flameTurret);

            flameTurret.Invoke(() => CheckFlameTurretFuel(flameTurret), 5.75f);
        }

        private void RefillFlameTurretFuel(FlameTurret flameTurret)
        {
            if (!flameTurret.HasFuel())
            {
                foreach (var item in flameTurret.inventory.onlyAllowedItems)
                {
                    flameTurret.inventory.AddItem(item, 50);
                }
                flameTurret.SendNetworkUpdateImmediate(false);
            }
        }

        void CanPickupEntity(BasePlayer player, BaseEntity entity)
        {
            if (!_infiniteAmmo) return;

            if(entity is FlameTurret)
            {
                if (!permission.UserHasPermission(entity.OwnerID.ToString(), "turretconfig.infiniteammo")) return;

                var flameTurret = entity as FlameTurret;
                if(flameTurret != null)
                {
                    flameTurret.inventory.Clear();
                }
            }
        }

        private object CanBeTargeted(BaseCombatEntity target, MonoBehaviour turret)
        {
            if (target is BasePlayer)
            {
                var isInvisible = Vanish?.Call("IsInvisible", target);
                if (isInvisible != null && (bool)isInvisible)
                {
                    return null;
                }
            }

            if (!(turret is AutoTurret) && !(turret is FlameTurret))
            {
                return null;
            }

            if (_animalOverride && target.GetComponent<BaseNpc>() != null)
            {
                if (_animals.Count > 0)
                {
                    if (_animals.Contains(target.ShortPrefabName.Replace(".prefab", "").ToLower()))
                    {
                        return false;
                    }

                    return null;
                }

                return false;
            }

            if (target.ToPlayer() == null)
            {
                return null;
            }

            var targetPlayer = target.ToPlayer();

            if (_adminOverride && targetPlayer.IsConnected && targetPlayer.net.connection.authLevel > 0)
            {
                return false;
            }
            if (_sleepOverride && targetPlayer.IsSleeping())
            {
                return false;
            }

            return null;
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null) return;

            if (entity.prefabID == _autoTurretPrefabId)
            {
                UpdateAutoTurret((AutoTurret)entity, true);
            }
            else if (entity.prefabID == _flameTurretPrefabId)
            {
                UpdateFlameTurret((FlameTurret)entity, true);
            }
        }

        private T FromPermission<T>(string userID, Dictionary<string, object> options, T defaultValue)
        {
            if (!string.IsNullOrEmpty(userID) && userID != "0")
            {
                foreach (var kvp in options)
                {
                    if (permission.UserHasPermission(userID, kvp.Key))
                    {
                        return (T)Convert.ChangeType(kvp.Value, typeof(T));
                    }
                }
            }

            return defaultValue;
        }

        private void InitializeTurret(BaseCombatEntity turret, float turretHealth, bool justCreated = false)
        {
            if (justCreated)
            {
                turret._health = turretHealth;
            }
            turret._maxHealth = turretHealth;

            if (justCreated)
            {
                turret.InitializeHealth(turretHealth, turretHealth);
            }
            else
            {
                turret.InitializeHealth(turret.health, turretHealth);
            }

            turret.startHealth = turretHealth;
        }

        private void UpdateFlameTurret(FlameTurret turret, bool justCreated = false)
        {
            CheckFlameTurretFuel(turret);

            var userID = turret.OwnerID.ToString();

            var turretHealth = FromPermission(userID, _flameHealths, _defaultFlameHealth);

            InitializeTurret(turret, turretHealth, justCreated);

            turret.arc = FromPermission(userID, _arcs, _defaultArc);
            turret.triggeredDuration = FromPermission(userID, _triggerDurations, _defaultTriggerDuration);
            turret.flameRange = FromPermission(userID, _flameRanges, _defaultFlameRange);
            turret.flameRadius = FromPermission(userID, _flameRadiuses, _defaultFlameRadius);
            turret.fuelPerSec = FromPermission(userID, _fuelPerSecs, _defaultFuelPerSec);

            turret.SendNetworkUpdateImmediate(justCreated);
        }

        private void UpdateAutoTurret(AutoTurret turret, bool justCreated = false)
        {
            CheckAutoTurretAmmo(turret);

            var userID = turret.OwnerID.ToString();

            var turretHealth = FromPermission(userID, _autoHealths, _defaultAutoHealth);
            var ammoType = FromPermission(userID, _ammoTypes, _defaultAmmoType);

            InitializeTurret(turret, turretHealth, justCreated);

            turret.bulletSpeed = FromPermission(userID, _bulletSpeeds, _defaultBulletSpeed);
            turret.sightRange = FromPermission(userID, _sightRanges, _defaultSightRange);
            turret.aimCone = FromPermission(userID, _aimCones, _defaultAimCone);

            var def = ItemManager.FindItemDefinition(ammoType);
            if (def != null)
            {
                var weapon = turret.GetAttachedWeapon();
                if (weapon?.primaryMagazine != null && weapon.IsValid())
                    weapon.primaryMagazine.ammoType = def;

                var projectile = def.GetComponent<ItemModProjectile>();
                if (projectile?.projectileObject != null && projectile.projectileObject.isValid)
                {
                    turret.gun_fire_effect.guid = projectile.projectileObject.guid;
                    turret.bulletEffect.guid = projectile.projectileObject.guid;
                }
            }
            else
            {
                PrintWarning("No ammo of type ({0})", ammoType);
            }


            if(turret.IsPowered() && turret.IsOnline())
            {
                turret.Reload();
            }

            turret.SendNetworkUpdateImmediate(justCreated);
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (hitInfo.Initiator != null)
            {
                var modifier = 1f;
                if (hitInfo.Initiator.prefabID == _autoTurretPrefabId)
                {
                    modifier = FromPermission(hitInfo.Initiator.OwnerID.ToString(), _bulletModifiers, _defaultBulletModifier);
                }
                else if (hitInfo.Initiator.prefabID == _flameTurretPrefabId)
                {
                    modifier = FromPermission(hitInfo.Initiator.OwnerID.ToString(), _flameModifiers, _defaultFlameModifier);
                }

                hitInfo.damageTypes.ScaleAll(modifier);
            }
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
        {
            if (attacker == null || hitInfo == null || hitInfo.HitEntity == null) return;

            if (_useGlobalDamageModifier && hitInfo.HitEntity.prefabID == _autoTurretPrefabId || hitInfo.HitEntity.prefabID == _flameTurretPrefabId)
            {
                hitInfo.damageTypes.ScaleAll(_globalDamageModifier);
            }
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        private T GetConfig<T>(string name, string name2, T defaultValue)
        {
            if (Config[name, name2] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name, name2], typeof(T));
        }

        private string GetMsg(string key, string userID = null)
        {
            return lang.GetMessage(key, this, userID);
        }
    }
}

// --- End of file: TurretConfig.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/turret-loadouts ---
// --- Original File Path: T/TurretLoadouts/TurretLoadouts.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Turret Loadouts", "WhiteThunder", "1.2.0")]
    [Description("Automatically fills turrets with weapons, attachments and ammo, using configurable loadouts.")]
    internal class TurretLoadouts : CovalencePlugin
    {
        #region Fields

        private const int LoadoutNameMaxLength = 20;

        private const string Permission_AutoToggle = "turretloadouts.autotoggle";
        private const string Permission_AutoToggleSamSite = "turretloadouts.autotoggle.samsite";
        private const string Permission_Manage = "turretloadouts.manage";
        private const string Permission_ManageCustom = "turretloadouts.manage.custom";

        private const string Permission_RulesetPrefix = "turretloadouts.ruleset";
        private const string Permission_DefaultLoadoutPrefix = "turretloadouts.default";
        private const string Permission_DefaultFlameTurretLoadoutPrefix = "turretloadouts.flameturret.default";
        private const string Permission_DefaultShotgunTrapLoadoutPrefix = "turretloadouts.shotguntrap.default";
        private const string Permission_DefaultSamSiteLoadoutPrefix = "turretloadouts.samsite.default";

        private readonly object False = false;

        private readonly Dictionary<string, PlayerData> _playerDataCache = new();

        private Configuration _config;

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(Permission_AutoToggle, this);
            permission.RegisterPermission(Permission_AutoToggleSamSite, this);
            permission.RegisterPermission(Permission_Manage, this);
            permission.RegisterPermission(Permission_ManageCustom, this);

            _config.Init(this);

            if (!_config.LockAutoFilledTurrets)
            {
                Unsubscribe(nameof(OnTurretToggle));
                Unsubscribe(nameof(CanMoveItem));
                Unsubscribe(nameof(OnDropContainerEntity));
            }
        }

        private void OnServerInitialized()
        {
            // Update locked turrets so they can be picked up and don't drop loot.
            // This is done even if the config option for locked turrets is off
            // because there could be locked turrets lingering from a previous configuration.
            // TBD if there are other plugins locking inventories which could conflict.
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                if (entity is AutoTurret or SamSite)
                {
                    var container = entity as ContainerIOEntity;
                    if (IsLocked(container))
                    {
                        SetupLockedContainer(container);
                    }
                }
                else if (entity is FlameTurret or GunTrap)
                {
                    var container = entity as StorageContainer;
                    if (IsLocked(container))
                    {
                        SetupLockedContainer(container);
                    }
                }
            }
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            var ownerPlayer = plan?.GetOwnerPlayer();
            if (ownerPlayer == null)
                return;

            var entity = go?.ToBaseEntity();
            if (entity == null)
                return;

            FillTurretLikeEntity(ownerPlayer, entity);
        }

        private void OnEntityPickedUp(StorageContainer container)
        {
            if (container is GunTrap or FlameTurret && IsLocked(container))
            {
                container.inventory.Clear();
            }
        }

        private void OnTurretToggle(AutoTurret turret)
        {
            // Remove items if powering down while locked and out of ammo
            // Otherwise, the turret would be unusable other than picking it up
            if (turret != null && turret.IsOnline() && IsLocked(turret) && GetTotalAmmo(turret) == 0)
            {
                turret.inventory.Clear();
                turret.inventory.SetLocked(false);
            }
        }

        private object CanMoveItem(Item item)
        {
            // Fix issue where right-clicking an item in a locked turret inventory allows moving it.
            var containerEntity = item.parent?.entityOwner;
            if (containerEntity is AutoTurret or SamSite && item.parent.IsLocked())
                return False;

            return null;
        }

        // Compatibility with plugin: Remover Tool (RemoverTool)
        private object OnDropContainerEntity(ContainerIOEntity container)
        {
            // Prevent Remover Tool from explicitly dropping the inventory
            if (container is AutoTurret or SamSite && IsLocked(container))
                return False;

            return null;
        }

        // Compatibility with plugin: Remover Tool (RemoverTool)
        private object OnDropContainerEntity(StorageContainer container)
        {
            // Prevent Remover Tool from explicitly dropping the inventory
            if (container is FlameTurret or GunTrap && IsLocked(container))
                return False;

            return null;
        }

        #endregion

        #region API

        [HookMethod(nameof(API_FillTurret))]
        public void API_FillTurret(BasePlayer player, BaseEntity turret)
        {
            FillTurretLikeEntity(player, turret);
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnTurretLoadoutFill(BasePlayer player, BaseEntity turret)
            {
                return Interface.CallHook("OnTurretLoadoutFill", player, turret);
            }
        }

        #endregion

        #region Commands

        [Command("tl")]
        private void MainCommand(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer)
                return;

            if (args.Length == 0)
            {
                SubCommandDefault(player);
                return;
            }

            switch (args[0].ToLower())
            {
                case "help":
                    SubCommandHelp(player);
                    return;

                case "list":
                    SubCommandList(player);
                    return;

                case "save":
                    SubCommandSave(player, args.Skip(1).ToArray());
                    return;

                case "update":
                    SubCommandUpdate(player, args.Skip(1).ToArray());
                    return;

                case "rename":
                    SubCommandRename(player, args.Skip(1).ToArray());
                    return;

                case "delete":
                    SubCommandDelete(player, args.Skip(1).ToArray());
                    return;

                default:
                    SubCommandActivate(player, args);
                    return;
            }
        }

        private void SubCommandDefault(IPlayer player)
        {
            if (!VerifyPermissionAny(player, Permission_Manage, Permission_ManageCustom))
                return;

            var sb = new StringBuilder();

            var loadout = GetPlayerActiveLoadout(player.Id);
            if (loadout == null)
            {
                sb.AppendLine(GetMessage(player, "Command.Default.NoActive"));
            }
            else
            {
                sb.AppendLine(GetMessage(player, "Command.Default.Active", GetLoadoutDisplayName(loadout, player.Id)));
                sb.Append(PrintLoadoutDetails(player, loadout));
                sb.AppendLine();
            }

            sb.AppendLine(GetMessage(player, "Command.Default.HelpHint"));
            player.Reply(sb.ToString());
        }

        private void SubCommandHelp(IPlayer player)
        {
            if (!VerifyPermissionAny(player, Permission_Manage, Permission_ManageCustom))
                return;

            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, "Generic.Header"));
            sb.AppendLine(GetMessage(player, "Command.Help.Details"));
            sb.AppendLine(GetMessage(player, "Command.Help.List"));
            sb.AppendLine(GetMessage(player, "Command.Help.Activate"));

            if (player.HasPermission(Permission_ManageCustom))
            {
                sb.AppendLine(GetMessage(player, "Command.Help.Save"));
                sb.AppendLine(GetMessage(player, "Command.Help.Update"));
                sb.AppendLine(GetMessage(player, "Command.Help.Rename"));
                sb.AppendLine(GetMessage(player, "Command.Help.Delete"));
            }

            player.Reply(sb.ToString());
        }

        private void SubCommandList(IPlayer player)
        {
            if (!VerifyPermissionAny(player, Permission_Manage, Permission_ManageCustom))
                return;

            var playerData = GetPlayerData(player);

            // Prune loadouts that are no longer valid
            // For example, if the player no longer has permission to the weapon type
            playerData.RestrictAndPruneLoadouts(GetPlayerLoadoutRuleset(player));

            var defaultLoadout = GetPlayerLastAllowedProfile(_config.DefaultLoadouts, player.Id);
            if (playerData.Loadouts.Count == 0 && defaultLoadout == null)
            {
                ReplyToPlayer(player, "Command.List.NoLoadouts");
                return;
            }

            var loadouts = playerData.Loadouts.ToArray();
            Array.Sort(loadouts, SortLoadoutNames);

            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, "Generic.Header"));

            if (defaultLoadout != null)
            {
                AddListItem(sb, player, defaultLoadout, playerData.ActiveLoadout);
            }

            foreach (var loadout in loadouts)
            {
                AddListItem(sb, player, loadout, playerData.ActiveLoadout);
            }

            sb.AppendLine();
            sb.AppendLine(GetMessage(player, "Command.List.ToggleHint"));

            player.Reply(sb.ToString());
        }

        private void AddListItem(StringBuilder sb, IPlayer player, TurretLoadout loadout, string activeLoadout)
        {
            var weaponDefinition = ItemManager.FindItemDefinition(loadout.Weapon);
            var activeString = loadout.IsDefault && activeLoadout == null || activeLoadout == loadout.Name ? GetMessage(player, "Command.List.Item.Active") : string.Empty;

            var attachmentAbbreviations = AbbreviateAttachments(player, loadout);
            var attachmentsString = attachmentAbbreviations == null
                ? string.Empty
                : $" ({string.Join(", ", attachmentAbbreviations)})";

            sb.AppendLine(GetMessage(player, "Command.List.Item", activeString, GetLoadoutDisplayName(loadout, player.Id), weaponDefinition.displayName.translated, attachmentsString));
        }

        private IEnumerable<string> AbbreviateAttachments(IPlayer player, TurretLoadout loadout)
        {
            if (loadout.Attachments == null || loadout.Attachments.Count == 0)
                return null;

            return loadout.Attachments.Select(attachmentName =>
            {
                var langKey = $"Abbreviation.{attachmentName}";
                var abbreviated = GetMessage(player, langKey);
                return abbreviated == langKey ? attachmentName : abbreviated;
            });
        }

        private void SubCommandSave(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, Permission_ManageCustom))
                return;

            if (args.Length == 0)
            {
                ReplyToPlayer(player, "Command.Save.Error.Syntax");
                return;
            }

            var loadoutName = args[0];
            if (!VerifyLoadoutNameLength(player, loadoutName))
                return;

            if (MatchesDefaultLoadoutName(player, loadoutName))
            {
                ReplyToPlayer(player, "Generic.Error.DefaultLoadout");
                return;
            }

            var playerData = GetPlayerData(player);
            var loadoutRuleset = GetPlayerLoadoutRuleset(player);
            playerData.RestrictAndPruneLoadouts(loadoutRuleset);

            if (playerData.HasLoadout(loadoutName))
            {
                ReplyToPlayer(player, "Command.Save.Error.LoadoutExists", loadoutName);
                return;
            }

            if (playerData.Loadouts.Count >= _config.MaxLoadoutsPerPlayer)
            {
                ReplyToPlayer(player, "Command.Save.Error.TooManyLoadouts", _config.MaxLoadoutsPerPlayer);
                return;
            }

            var basePlayer = player.Object as BasePlayer;

            if (!VerifyTurretFound(basePlayer, out var turret) ||
                !VerifyTurretLoadoutValid(player, turret, out var loadout))
                return;

            var disallowedItems = new Dictionary<string, int>();
            if (playerData.ValidateAndPossiblyReduceLoadout(loadout, loadoutRuleset, disallowedItems) == LoadoutManager.ValidationResult.DisallowedWeapon)
            {
                var itemDefinition = ItemManager.FindItemDefinition(loadout.Weapon);
                ReplyToPlayer(player, "Generic.Error.WeaponNotAllowed", itemDefinition.displayName.translated);
                return;
            }

            loadout.Name = loadoutName;
            playerData.SaveLoadout(loadout);

            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, "Command.Save.Success", loadoutName));
            sb.Append(PrintLoadoutDetails(player, loadout));

            if (!disallowedItems.IsEmpty())
            {
                sb.Append(PrintDisallowedItems(player, disallowedItems));
            }

            player.Reply(sb.ToString());
        }

        private void SubCommandUpdate(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, Permission_ManageCustom))
                return;

            if (args.Length < 1)
            {
                ReplyToPlayer(player, "Command.Update.Error.Syntax");
                return;
            }

            var loadoutName = args[0];
            if (MatchesDefaultLoadoutName(player, loadoutName))
            {
                ReplyToPlayer(player, "Generic.Error.DefaultLoadout");
                return;
            }

            var basePlayer = player.Object as BasePlayer;

            if (!VerifyTurretFound(basePlayer, out var turret) ||
                !VerifyTurretLoadoutValid(player, turret, out var newLoadout))
                return;

            var playerData = GetPlayerData(player);
            var loadoutPermission = GetPlayerLoadoutRuleset(player);
            playerData.RestrictAndPruneLoadouts(loadoutPermission);

            if (!VerifyHasLoadout(player, loadoutName, out _))
                return;

            var disallowedItems = new Dictionary<string, int>();
            if (playerData.ValidateAndPossiblyReduceLoadout(newLoadout, loadoutPermission, disallowedItems) == LoadoutManager.ValidationResult.DisallowedWeapon)
            {
                var itemDefinition = ItemManager.FindItemDefinition(newLoadout.Weapon);
                ReplyToPlayer(player, "Generic.Error.WeaponNotAllowed", itemDefinition.displayName.translated);
                return;
            }

            newLoadout.Name = loadoutName;
            GetPlayerData(player).TryUpdateLoadout(newLoadout);

            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, "Command.Update.Success", loadoutName));
            sb.Append(PrintLoadoutDetails(player, newLoadout));

            if (!disallowedItems.IsEmpty())
            {
                sb.Append(PrintDisallowedItems(player, disallowedItems));
            }

            player.Reply(sb.ToString());
        }

        private string PrintDisallowedItems(IPlayer player, Dictionary<string, int> disallowedItems)
        {
            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, "Generic.RestrictedItems"));
            foreach (var entry in disallowedItems)
            {
                sb.AppendLine($"  {entry.Value} {GetItemDisplayName(entry.Key)}");
            }

            return sb.ToString();
        }

        private string PrintLoadoutDetails(IPlayer player, TurretLoadout loadout)
        {
            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, loadout.Peacekeeper ? "Command.Default.Mode.Peacekeeper" : "Command.Default.Mode.AttackAll"));

            var ammoString = loadout.Ammo != null && loadout.Ammo.Amount > 0
                ? $" ({loadout.Ammo.Amount} {GetItemDisplayName(loadout.Ammo.Name)})"
                : string.Empty;

            sb.AppendLine(GetMessage(player, "Command.Default.Weapon", GetItemDisplayName(loadout.Weapon), ammoString));

            if (loadout.Attachments != null && loadout.Attachments.Count > 0)
            {
                sb.AppendLine(GetMessage(player, "Command.Default.Attachments"));
                foreach (var attachmentName in loadout.Attachments)
                {
                    sb.AppendLine($"  {GetItemDisplayName(attachmentName)}");
                }
            }

            if (loadout.ReserveAmmo != null && !loadout.ReserveAmmo.IsEmpty())
            {
                sb.AppendLine(GetMessage(player, "Command.Default.ReserveAmmo"));
                foreach (var ammo in loadout.ReserveAmmo)
                {
                    if (ammo.Amount > 0)
                    {
                        sb.AppendLine($"  {ammo.Amount} {GetItemDisplayName(ammo.Name)}");
                    }
                }
            }

            return sb.ToString();
        }

        private void SubCommandRename(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, Permission_ManageCustom))
                return;

            if (args.Length < 2)
            {
                ReplyToPlayer(player, "Command.Rename.Error.Syntax");
                return;
            }

            var oldName = args[0];
            var newName = args[1];

            if (MatchesDefaultLoadoutName(player, oldName) || MatchesDefaultLoadoutName(player, newName))
            {
                ReplyToPlayer(player, "Generic.Error.DefaultLoadout");
                return;
            }

            if (!VerifyHasLoadout(player, oldName, out var loadout) ||
                !VerifyLoadoutNameLength(player, newName))
                return;

            var playerData = GetPlayerData(player);
            var existingLoadoutWithNewName = playerData.FindByName(newName);

            // Allow renaming if just changing case
            if (existingLoadoutWithNewName != null && loadout != existingLoadoutWithNewName)
            {
                ReplyToPlayer(player, "Command.Rename.Error.LoadoutNameTaken", existingLoadoutWithNewName.Name);
                return;
            }

            var actualOldLoadoutName = loadout.Name;
            playerData.RenameLoadout(loadout, newName);

            if (playerData.ActiveLoadout == actualOldLoadoutName)
            {
                playerData.ActiveLoadout = newName;
            }

            ReplyToPlayer(player, "Command.Rename.Success", actualOldLoadoutName, newName);
        }

        private void SubCommandDelete(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, Permission_ManageCustom))
                return;

            if (args.Length < 1)
            {
                ReplyToPlayer(player, "Command.Delete.Error.Syntax");
                return;
            }

            var loadoutName = args[0];

            if (!VerifyHasLoadout(player, loadoutName, out var loadout))
                return;

            if (loadout.IsDefault)
            {
                ReplyToPlayer(player, "Generic.Error.DefaultLoadout");
                return;
            }

            GetPlayerData(player).DeleteLoadout(loadout);
            ReplyToPlayer(player, "Command.Delete.Success", loadout.Name);
        }

        private void SubCommandActivate(IPlayer player, string[] args)
        {
            if (!VerifyPermissionAny(player, Permission_Manage, Permission_ManageCustom))
                return;

            if (args.Length < 1)
            {
                ReplyToPlayer(player, "Command.Activate.Error.Syntax");
                return;
            }

            var loadoutName = args[0];

            if (!VerifyHasLoadout(player, loadoutName, out var loadout, matchPartial: true))
                return;

            var playerData = GetPlayerData(player);

            if (loadout.IsDefault)
            {
                playerData.ActiveLoadout = playerData.ActiveLoadout == null ? string.Empty : null;
            }
            else
            {
                playerData.ActiveLoadout = playerData.ActiveLoadout == loadout.Name ? string.Empty : loadout.Name;
            }

            playerData.SaveData();

            if (playerData.ActiveLoadout == string.Empty)
            {
                ReplyToPlayer(player, "Command.Activate.Success.Deactivated", GetLoadoutDisplayName(loadout, player.Id));
            }
            else
            {
                var sb = new StringBuilder();
                sb.AppendLine(GetMessage(player, "Command.Default.Active", GetLoadoutDisplayName(loadout, player.Id)));
                sb.Append(PrintLoadoutDetails(player, loadout));
                ReplyToPlayer(player, sb.ToString());
            }
        }

        #endregion

        #region Helper Methods - Command Checks

        private bool VerifyPermissionAny(IPlayer player, params string[] permissionNames)
        {
            if (HasPermissionAny(player, permissionNames))
                return true;

            ReplyToPlayer(player, "Generic.Error.NoPermission");
            return false;
        }

        private bool VerifyTurretFound(BasePlayer player, out AutoTurret turret)
        {
            turret = GetLookEntity(player, 3) as AutoTurret;
            if (turret != null)
                return true;

            ReplyToPlayer(player.IPlayer, "Command.Save.Error.NoTurretFound");
            return false;
        }

        private bool VerifyTurretLoadoutValid(IPlayer player, AutoTurret turret, out TurretLoadout loadout)
        {
            loadout = CreateLoadout(turret);
            if (loadout != null)
                return true;

            ReplyToPlayer(player, "Generic.Error.NoTurretWeapon");
            return false;
        }

        private bool VerifyHasLoadout(IPlayer player, string loadoutName, out TurretLoadout loadout, bool matchPartial = false)
        {
            loadout = MatchesDefaultLoadoutName(player, loadoutName, matchPartial)
                ? GetPlayerLastAllowedProfile(_config.DefaultLoadouts, player.Id)
                : GetPlayerData(player).FindByName(loadoutName, matchPartial);

            if (loadout != null)
                return true;

            ReplyToPlayer(player, "Generic.Error.LoadoutNotFound", loadoutName);
            return false;
        }

        private bool VerifyLoadoutNameLength(IPlayer player, string loadoutName)
        {
            if (loadoutName.Length <= LoadoutNameMaxLength)
                return true;

            ReplyToPlayer(player, "Generic.Error.LoadoutNameLength", LoadoutNameMaxLength);
            return false;
        }

        #endregion

        #region Helper Methods - Turrets

        private static void SetupLockedContainer(ContainerIOEntity container)
        {
            container.dropsLoot = false;
            container.pickup.requireEmptyInv = false;
        }

        private static void SetupLockedContainer(StorageContainer container)
        {
            container.dropsLoot = false;
            container.pickup.requireEmptyInv = false;
        }

        private static bool IsLocked(IItemContainerEntity containerEntity)
        {
            return containerEntity.inventory?.IsLocked() ?? false;
        }

        private static int GetTotalAmmo(AutoTurret turret)
        {
            if (turret == null || turret.inventory == null)
                return 0;

            var weapon = turret.GetAttachedWeapon();
            if (weapon == null)
                return 0;

            // AutoTurret.GetTotalAmmo() only includes the reserve ammo, not the loaded ammo
            return weapon.primaryMagazine.contents + turret.GetTotalAmmo();
        }

        private static TurretLoadout CreateLoadout(AutoTurret turret)
        {
            var heldEntity = turret.AttachedWeapon;
            if (heldEntity == null)
                return null;

            var weaponItem = turret.inventory.GetSlot(0);
            if (weaponItem == null)
                return null;

            var loadout = new TurretLoadout
            {
                Weapon = weaponItem.info.shortname,
                Skin = weaponItem.skin,
                Peacekeeper = turret.PeacekeeperMode()
            };

            if (weaponItem.contents != null)
            {
                var attachments = new List<string>();
                for (var slot = 0; slot < weaponItem.contents.capacity; slot++)
                {
                    var attachmentItem = weaponItem.contents.GetSlot(slot);
                    if (attachmentItem != null)
                    {
                        attachments.Add(attachmentItem.info.shortname);
                    }
                }

                if (attachments.Count > 0)
                {
                    loadout.Attachments = attachments;
                }
            }

            var weapon = heldEntity as BaseProjectile;
            if (weapon != null && weapon.primaryMagazine.contents > 0)
            {
                loadout.Ammo = new AmmoAmount
                {
                    Name = weapon.primaryMagazine.ammoType.shortname,
                    Amount = weapon.primaryMagazine.contents,
                };
            }

            var reserveAmmo = new List<AmmoAmount>();
            for (var slot = 1; slot <= 6; slot++)
            {
                var ammoItem = turret.inventory.GetSlot(slot);
                if (ammoItem is not { amount: > 0 })
                    continue;

                reserveAmmo.Add(new AmmoAmount
                {
                    Name = ammoItem.info.shortname,
                    Amount = ammoItem.amount
                });
            }

            if (reserveAmmo.Count > 0)
            {
                loadout.ReserveAmmo = reserveAmmo;
            }

            return loadout;
        }

        private string GetLoadoutDisplayName(TurretLoadout loadout, string userIdString)
        {
            return loadout.IsDefault ? GetDefaultLoadoutName(userIdString) : loadout.Name;
        }

        private Item AddHeldEntity(AutoTurret turret, BasePlayer ownerPlayer, TurretLoadout loadout)
        {
            var heldItem = ItemManager.CreateByName(loadout.Weapon, 1, loadout.Skin);
            if (heldItem == null)
            {
                LogError($"Weapon '{loadout.Weapon}' is not a valid item. Unable to add weapon to turret for player {ownerPlayer.userID}.");
                return null;
            }

            if (loadout.Attachments != null)
            {
                foreach (var attachmentName in loadout.Attachments)
                {
                    var attachmentItem = ItemManager.CreateByName(attachmentName);
                    if (attachmentItem == null)
                    {
                        LogError($"Attachment '{attachmentName}' is not a valid item. Unable to add to turret weapon for player {ownerPlayer.userID}.");
                    }
                    else if (!attachmentItem.MoveToContainer(heldItem.contents))
                    {
                        attachmentItem.Remove();
                    }
                }
            }

            if (!heldItem.MoveToContainer(turret.inventory, 0))
            {
                heldItem.Remove();
                return null;
            }

            var weapon = heldItem.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                if (loadout.Attachments != null)
                {
                    weapon.DelayedModsChanged();
                    weapon.CancelInvoke(weapon.DelayedModsChanged);
                }

                // Must unload the weapon first or the turret will unload it and the ammo will temporarily take up inventory space
                weapon.primaryMagazine.contents = 0;
                turret.UpdateAttachedWeapon();
                turret.CancelInvoke(turret.UpdateAttachedWeapon);

                if (loadout.Ammo != null)
                {
                    var loadedAmmoItemDefinition = ItemManager.FindItemDefinition(loadout.Ammo.Name);
                    if (loadedAmmoItemDefinition == null)
                    {
                        LogError($"Ammo type '{loadout.Ammo.Name}' is not a valid item. Unable to add ammo to turret for player {ownerPlayer.userID}.");
                        return heldItem;
                    }

                    weapon.primaryMagazine.ammoType = loadedAmmoItemDefinition;
                    weapon.primaryMagazine.contents = Math.Min(weapon.primaryMagazine.capacity, loadout.Ammo.Amount);
                }
            }

            return heldItem;
        }

        private void AddReserveAmmo(ItemContainer container, BaseLoadout loadout, BasePlayer ownerPlayer, int firstSlot = 0)
        {
            if (loadout.ReserveAmmo == null)
                return;

            var slot = firstSlot;
            var maxSlot = container.capacity - 1;

            foreach (var ammo in loadout.ReserveAmmo)
            {
                if (slot > maxSlot)
                    break;

                if (ammo.Amount <= 0)
                    continue;

                var itemDefinition = ItemManager.FindItemDefinition(ammo.Name);
                if (itemDefinition == null)
                {
                    LogError($"Ammo type '{ammo.Name}' is not a valid item. Unable to add ammo to turret for player {ownerPlayer.userID}.");
                    continue;
                }

                // Allow default loadouts to bypass max stack size
                var amountToAdd = loadout.IsDefault ? ammo.Amount : Math.Min(ammo.Amount, itemDefinition.stackable);
                var ammoItem = ItemManager.Create(itemDefinition, amountToAdd);
                if (!ammoItem.MoveToContainer(container, slot))
                {
                    ammoItem.Remove();
                }

                if (ammoItem.parent != container)
                {
                    // The item was split due to max stack size.
                    if (loadout.IsDefault)
                    {
                        var destinationItem = container.GetSlot(slot);
                        if (destinationItem != null)
                        {
                            destinationItem.amount = amountToAdd;
                            destinationItem.MarkDirty();
                        }
                    }

                    ammoItem.Remove();
                }

                slot++;
            }
        }

        private void FillAutoTurret(BasePlayer player, AutoTurret turret)
        {
            var loadout = GetPlayerActiveLoadout(player.UserIDString);
            if (loadout == null)
                return;

            if (loadout.Peacekeeper)
            {
                turret.SetPeacekeepermode(true);
            }

            var heldItem = AddHeldEntity(turret, player, loadout);
            if (heldItem == null)
                return;

            AddReserveAmmo(turret.inventory, loadout, player, firstSlot: 1);
            turret.UpdateTotalAmmo();
            turret.EnsureReloaded();

            var isInstrument = (heldItem.GetHeldEntity() as HeldEntity)?.IsInstrument() ?? false;
            if ((isInstrument || GetTotalAmmo(turret) > 0) && HasPermissionAny(player, Permission_AutoToggle))
            {
                turret.InitiateStartup();
                var turretSwitch = turret.GetComponentInChildren<ElectricSwitch>();
                if (turretSwitch != null)
                {
                    turretSwitch.SetSwitch(true);
                }
            }

            if (_config.LockAutoFilledTurrets)
            {
                heldItem.contents.SetLocked(true);
                turret.inventory.SetLocked(true);
                SetupLockedContainer(turret);
            }

            if (HasPermissionAny(player, Permission_Manage, Permission_ManageCustom))
            {
                ChatMessage(player, "Generic.FilledFromLoadout", GetLoadoutDisplayName(loadout, player.UserIDString));
            }

            turret.SendNetworkUpdate();
        }

        private void FillSamSite(BasePlayer player, SamSite samSite)
        {
            var loadout = GetPlayerLastAllowedProfile(_config.DefaultSamSiteLoadouts, player.UserIDString);
            if (loadout == null)
                return;

            AddReserveAmmo(samSite.inventory, loadout, player);

            if (HasPermissionAny(player, Permission_AutoToggleSamSite))
            {
                samSite.SetFlag(IOEntity.Flag_HasPower, true);
            }

            if (_config.LockAutoFilledTurrets)
            {
                samSite.inventory.SetLocked(true);
                SetupLockedContainer(samSite);
            }
        }

        private void FillFlameTurret(BasePlayer player, FlameTurret flameTurret)
        {
            var loadout = GetPlayerLastAllowedProfile(_config.DefaultFlameTurretLoadouts, player.UserIDString);
            if (loadout == null)
                return;

            AddReserveAmmo(flameTurret.inventory, loadout, player);
            if (_config.LockAutoFilledTurrets)
            {
                flameTurret.inventory.SetLocked(true);
                SetupLockedContainer(flameTurret);
            }
        }

        private void FillGunTrap(BasePlayer player, GunTrap gunTrap)
        {
            var loadout = GetPlayerLastAllowedProfile(_config.DefaultShotgunTrapLoadouts, player.UserIDString);
            if (loadout == null)
                return;

            AddReserveAmmo(gunTrap.inventory, loadout, player);
            if (_config.LockAutoFilledTurrets)
            {
                gunTrap.inventory.SetLocked(true);
                SetupLockedContainer(gunTrap);
            }
        }

        private void FillTurretLikeEntity(BasePlayer player, BaseEntity entity)
        {
            if (ExposedHooks.OnTurretLoadoutFill(player, entity) is false)
                return;

            switch (entity)
            {
                case AutoTurret turret:
                    FillAutoTurret(player, turret);
                    return;
                case SamSite samSite:
                    FillSamSite(player, samSite);
                    return;
                case FlameTurret flameTurret:
                    FillFlameTurret(player, flameTurret);
                    return;
                case GunTrap gunTrap:
                    FillGunTrap(player, gunTrap);
                    return;
            }
        }

        #endregion

        #region Helper Methods - Misc

        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Turret Loadouts] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Turret Loadouts] {message}");

        private bool HasPermissionAny(BasePlayer basePlayer, params string[] permissionNames)
        {
            return HasPermissionAny(basePlayer.UserIDString, permissionNames);
        }

        private bool HasPermissionAny(IPlayer player, params string[] permissionNames)
        {
            return HasPermissionAny(player.Id, permissionNames);
        }

        private bool HasPermissionAny(string userId, params string[] permissionNames)
        {
            foreach (var perm in permissionNames)
            {
                if (permission.UserHasPermission(userId, perm))
                    return true;
            }

            return false;
        }

        private bool MatchesDefaultLoadoutName(IPlayer player, string loadoutName, bool matchPartial = false)
        {
            var defaultLoadoutName = GetDefaultLoadoutName(player.Id);

            return matchPartial
                ? defaultLoadoutName.IndexOf(loadoutName, StringComparison.CurrentCultureIgnoreCase) >= 0
                : defaultLoadoutName.Equals(loadoutName, StringComparison.CurrentCultureIgnoreCase);
        }

        private string GetDefaultLoadoutName(string userIdString)
        {
            return GetMessage(userIdString, "Generic.DefaultLoadoutName");
        }

        private static int SortLoadoutNames(TurretLoadout a, TurretLoadout b)
        {
            return a.Name.ToLower().CompareTo(b.Name.ToLower());
        }

        private static string GetItemDisplayName(string shortname)
        {
            var itemDefinition = ItemManager.FindItemDefinition(shortname);
            return itemDefinition == null ? shortname : itemDefinition.displayName.translated;
        }

        private static BaseEntity GetLookEntity(BasePlayer basePlayer, int maxDistance)
        {
            return !Physics.Raycast(basePlayer.eyes.HeadRay(), out var hit, maxDistance) ? null : hit.GetEntity();
        }

        private static void AddToDictKey(Dictionary<string, int> dict, string key, int amount)
        {
            if (dict.ContainsKey(key))
            {
                dict[key] += amount;
            }
            else
            {
                dict[key] = amount;
            }
        }

        #endregion

        #region Data Management

        private PlayerData GetPlayerData(IPlayer player)
        {
            return GetPlayerData(player.Id);
        }

        private PlayerData GetPlayerData(string userIdString)
        {
            if (_playerDataCache.TryGetValue(userIdString, out var data))
                return data;

            data = PlayerData.Get(userIdString);
            _playerDataCache[userIdString] = data;
            return data;
        }

        private class PlayerData : LoadoutManager
        {
            public static PlayerData Get(string ownerId)
            {
                var filepath = GetFilepath(ownerId);

                var data = Interface.Oxide.DataFileSystem.ExistsDatafile(filepath) ?
                    Interface.Oxide.DataFileSystem.ReadObject<PlayerData>(filepath) :
                    new PlayerData(ownerId);

                return data;
            }

            private static string GetFilepath(string ownerId)
            {
                return $"{nameof(TurretLoadouts)}/{ownerId}";
            }

            [JsonProperty("OwnerId")]
            public string OwnerId { get; }

            [JsonProperty("ActiveLoadout", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string ActiveLoadout;

            public PlayerData(string ownerId)
            {
                OwnerId = ownerId;
            }

            public override void SaveData()
            {
                Interface.Oxide.DataFileSystem.WriteObject(GetFilepath(OwnerId), this);
            }

            // Remove loadouts where the player no longer has permission to the weapon type
            // Update other loadouts to remove disallowed items
            public void RestrictAndPruneLoadouts(LoadoutRuleset ruleset)
            {
                var changed = false;

                for (var i = 0; i < Loadouts.Count; i++)
                {
                    var loadout = Loadouts[i];
                    var validationResult = ValidateAndPossiblyReduceLoadout(loadout, ruleset);

                    if (validationResult == ValidationResult.InvalidWeapon)
                    {
                        LogWarning($"Removed turret loadout '{loadout.Name}' for player '{OwnerId}' because weapon '{loadout.Weapon}' is not a valid item.");
                    }
                    else if (validationResult == ValidationResult.DisallowedWeapon)
                    {
                        LogWarning($"Removed turret loadout '{loadout.Name}' for player '{OwnerId}' because they are no longer allowed to use loadouts with weapon '{loadout.Weapon}'.");
                    }

                    if (validationResult == ValidationResult.InvalidWeapon || validationResult == ValidationResult.DisallowedWeapon)
                    {
                        Loadouts.RemoveAt(i);
                        i--;
                    }

                    if (validationResult != ValidationResult.Valid)
                    {
                        changed = true;
                    }
                }

                if (changed)
                {
                    SaveData();
                }
            }
        }

        private abstract class LoadoutManager
        {
            public enum ValidationResult { Valid, Changed, InvalidWeapon, DisallowedWeapon }

            private static bool MatchesLoadout(TurretLoadout loadout, string name, bool matchPartial = false)
            {
                return matchPartial
                    ? loadout.Name.IndexOf(name, StringComparison.CurrentCultureIgnoreCase) >= 0
                    : loadout.Name.Equals(name, StringComparison.CurrentCultureIgnoreCase);
            }

            [JsonProperty("Loadouts")]
            public List<TurretLoadout> Loadouts = new();

            public TurretLoadout FindByName(string loadoutName, bool matchPartial = false)
            {
                if (Loadouts == null)
                    return null;

                foreach (var currentLoadout in Loadouts)
                {
                    if (MatchesLoadout(currentLoadout, loadoutName))
                        return currentLoadout;
                }

                if (matchPartial)
                {
                    // Perform partial matching in a second pass so the first pass can get a closer match
                    foreach (var currentLoadout in Loadouts)
                    {
                        if (MatchesLoadout(currentLoadout, loadoutName, matchPartial: true))
                            return currentLoadout;
                    }
                }

                return null;
            }

            public bool HasLoadout(string loadoutName)
            {
                return FindByName(loadoutName) != null;
            }

            public void SaveLoadout(TurretLoadout loadout)
            {
                Loadouts.Add(loadout);
                SaveData();
            }

            public bool TryUpdateLoadout(TurretLoadout newLoadout)
            {
                var existingLoadout = FindByName(newLoadout.Name);
                if (existingLoadout == null)
                    return false;

                Loadouts[Loadouts.IndexOf(existingLoadout)] = newLoadout;
                SaveData();
                return true;
            }

            public void RenameLoadout(TurretLoadout loadout, string newName)
            {
                loadout.Name = newName;
                SaveData();
            }

            public void DeleteLoadout(TurretLoadout loadout)
            {
                Loadouts.Remove(loadout);
                SaveData();
            }

            // Removes items from the loadout not currently allowed by the ruleset
            // The loadout may no longer be valid due to containing an invalid or disallowed weapon
            // This can be determined by checking the validation result
            public ValidationResult ValidateAndPossiblyReduceLoadout(TurretLoadout loadout, LoadoutRuleset loadoutRuleset, Dictionary<string, int> disallowedItems = null)
            {
                disallowedItems ??= new Dictionary<string, int>();

                var weaponDefinition = ItemManager.FindItemDefinition(loadout.Weapon);
                if (weaponDefinition == null)
                    return ValidationResult.InvalidWeapon;

                if (!loadoutRuleset.IsWeaponAllowed(loadout.Weapon))
                {
                    disallowedItems[loadout.Weapon] = 1;
                    return ValidationResult.DisallowedWeapon;
                }

                if (loadout.Attachments != null)
                {
                    for (var i = 0; i < loadout.Attachments.Count; i++)
                    {
                        var attachmentName = loadout.Attachments[i];
                        if (!loadoutRuleset.IsAttachmentAllowed(attachmentName))
                        {
                            disallowedItems[attachmentName] = 1;
                            loadout.Attachments.RemoveAt(i);
                            i--;
                        }
                    }
                }

                var allowedAmmo = loadoutRuleset.AllowedAmmo;
                var countedAmmo = new Dictionary<string, int>();

                // Don't impose ammo limits if allowed ammo is null
                if (loadout.Ammo != null && allowedAmmo != null)
                {
                    var ammo = loadout.Ammo;

                    // Make sure ammo name exists
                    if (ItemManager.FindItemDefinition(ammo.Name) == null)
                    {
                        LogWarning($"Ammo type '{ammo.Name}' is not a valid item. Removing from loadout.");
                        ammo.Amount = 0;
                    }
                    else if (allowedAmmo.ContainsKey(ammo.Name))
                    {
                        var allowedAmount = allowedAmmo[ammo.Name];

                        // Don't impose a limit if the allowed amount is negative
                        if (allowedAmount >= 0 && ammo.Amount > allowedAmount)
                        {
                            // Reduce ammo to the allowed amount
                            AddToDictKey(disallowedItems, ammo.Name, ammo.Amount - allowedAmount);
                            ammo.Amount = allowedAmount;
                        }
                    }
                    else
                    {
                        // Ammo not allowed
                        AddToDictKey(disallowedItems, ammo.Name, ammo.Amount);
                        ammo.Amount = 0;
                    }

                    if (ammo.Amount <= 0)
                    {
                        loadout.Ammo = null;
                    }
                    else
                    {
                        AddToDictKey(countedAmmo, ammo.Name, ammo.Amount);
                    }
                }

                // Don't impose ammo limits if allowed ammo is null
                if (loadout.ReserveAmmo != null && allowedAmmo != null)
                {
                    for (var i = 0; i < loadout.ReserveAmmo.Count; i++)
                    {
                        var ammo = loadout.ReserveAmmo[i];

                        // Make sure ammo name exists
                        if (ItemManager.FindItemDefinition(ammo.Name) == null)
                        {
                            LogWarning($"Ammo type '{ammo.Name}' is not a valid item. Removing from loadout.");
                            ammo.Amount = 0;
                        }
                        else if (allowedAmmo.ContainsKey(ammo.Name))
                        {
                            // Don't impose a limit if the allowed amount is negative
                            if (allowedAmmo[ammo.Name] >= 0)
                            {
                                var countedAmount = countedAmmo.ContainsKey(ammo.Name) ? countedAmmo[ammo.Name] : 0;
                                var remainingAllowedAmount = allowedAmmo[ammo.Name] - countedAmount;

                                if (ammo.Amount > remainingAllowedAmount)
                                {
                                    // Reduce ammo to the allowed amount
                                    AddToDictKey(disallowedItems, ammo.Name, ammo.Amount - remainingAllowedAmount);
                                    ammo.Amount = remainingAllowedAmount;
                                }
                            }
                        }
                        else
                        {
                            // Ammo not allowed
                            AddToDictKey(disallowedItems, ammo.Name, ammo.Amount);
                            ammo.Amount = 0;
                        }

                        if (ammo.Amount <= 0)
                        {
                            loadout.ReserveAmmo.RemoveAt(i);
                            i--;
                        }
                        else
                        {
                            AddToDictKey(countedAmmo, ammo.Name, ammo.Amount);
                        }
                    }
                }

                return disallowedItems.IsEmpty() ? ValidationResult.Valid : ValidationResult.Changed;
            }

            public abstract void SaveData();
        }

        #endregion

        #region Configuration

        private TurretLoadout GetPlayerActiveLoadout(string userIdString)
        {
            if (HasPermissionAny(userIdString, Permission_Manage, Permission_ManageCustom))
            {
                var playerData = GetPlayerData(userIdString);
                if (playerData.ActiveLoadout == string.Empty)
                {
                    // Player has explicitly set no active loadout.
                    return null;
                }

                if (playerData.ActiveLoadout != null)
                {
                    var loadout = playerData.FindByName(playerData.ActiveLoadout);
                    if (loadout == null)
                        return null;

                    var validationResult = playerData.ValidateAndPossiblyReduceLoadout(loadout, GetPlayerLoadoutRuleset(userIdString));
                    if (validationResult == LoadoutManager.ValidationResult.InvalidWeapon ||
                        validationResult == LoadoutManager.ValidationResult.DisallowedWeapon)
                        return null;

                    return loadout;
                }
            }

            // Player doesn't have permission to use custom loadouts, or they have not set an active one.
            return GetPlayerLastAllowedProfile(_config.DefaultLoadouts, userIdString);
        }

        private T GetPlayerLastAllowedProfile<T>(T[] profileList, string userIdString, T defaultProfile = null) where T : BaseProfile
        {
            if (profileList == null || profileList.Length == 0)
                return defaultProfile;

            for (var i = profileList.Length - 1; i >= 0; i--)
            {
                var profile = profileList[i];
                if (permission.UserHasPermission(userIdString, profile.Permission))
                    return profile;
            }

            return defaultProfile;
        }

        private LoadoutRuleset GetPlayerLoadoutRuleset(string userIdString)
        {
            return GetPlayerLastAllowedProfile(_config.LoadoutRulesets, userIdString, _config.EmptyLoadoutRuleset);
        }

        private LoadoutRuleset GetPlayerLoadoutRuleset(IPlayer player)
        {
            return GetPlayerLoadoutRuleset(player.Id);
        }

        private class Configuration : BaseConfiguration
        {
            [JsonIgnore]
            public readonly LoadoutRuleset EmptyLoadoutRuleset = new()
            {
                // Nothing allowed.
                AllowedWeapons = Array.Empty<string>(),
                AllowedAttachments = Array.Empty<string>(),
                AllowedAmmo = new Dictionary<string, int>(),
            };

            [JsonProperty("LockAutoFilledTurrets")]
            public bool LockAutoFilledTurrets = false;

            [JsonProperty("MaxLoadoutsPerPlayer")]
            public int MaxLoadoutsPerPlayer = 10;

            [JsonProperty("DefaultLoadouts")]
            public DefaultTurretLoadout[] DefaultLoadouts =
            {
                new()
                {
                    Name = "ak47",
                    Weapon = "rifle.ak",
                    Skin = 885146172,
                    Ammo = new AmmoAmount { Name = "ammo.rifle", Amount = 30 },
                    ReserveAmmo = new List<AmmoAmount>
                    {
                        new() { Name = "ammo.rifle", Amount = 128 },
                        new() { Name = "ammo.rifle", Amount = 128 },
                    },
                },
                new()
                {
                    Name = "m249",
                    Weapon = "lmg.m249",
                    Skin = 1831294069,
                    Attachments = new List<string>
                    {
                        "weapon.mod.lasersight",
                        "weapon.mod.silencer",
                    },
                    Ammo = new AmmoAmount { Name = "ammo.rifle.explosive", Amount = 100 },
                    ReserveAmmo = new List<AmmoAmount>
                    {
                        new() { Name = "ammo.rifle.incendiary", Amount = 128 },
                        new() { Name = "ammo.rifle.hv", Amount = 128 },
                    },
                },
            };

            [JsonProperty("LoadoutRulesets")]
            public LoadoutRuleset[] LoadoutRulesets =
            {
                new()
                {
                    Name = "onlypistols",
                    AllowedWeapons = new[]
                    {
                        "pistol.eoka",
                        "pistol.m92",
                        "pistol.nailgun",
                        "pistol.python",
                        "pistol.revolver",
                        "pistol.semiauto",
                        "pistol.water",
                    },
                    AllowedAmmo = new Dictionary<string, int>
                    {
                        ["ammo.pistol"] = 600,
                        ["ammo.pistol.hv"] = 400,
                        ["ammo.pistol.fire"] = 200,
                    },
                },
                new()
                {
                    Name = "norifles",
                    DisallowedWeapons = new[]
                    {
                        "rifle.ak",
                        "rifle.bolt",
                        "rifle.l96",
                        "rifle.lr300",
                        "rifle.m39",
                        "rifle.semiauto",
                        "lmg.m249",
                    },
                },
                new()
                {
                    Name = "unlimited",
                },
            };

            [JsonProperty("DefaultSamSiteLoadouts")]
            public DefaultBaseLoadout[] DefaultSamSiteLoadouts =
            {
                new()
                {
                    Name = "fullammo",
                    ReserveAmmo = new List<AmmoAmount>
                    {
                        new() { Name = "ammo.rocket.sam", Amount = 128 },
                        new() { Name = "ammo.rocket.sam", Amount = 128 },
                        new() { Name = "ammo.rocket.sam", Amount = 128 },
                        new() { Name = "ammo.rocket.sam", Amount = 128 },
                        new() { Name = "ammo.rocket.sam", Amount = 128 },
                        new() { Name = "ammo.rocket.sam", Amount = 128 },
                    },
                },
            };

            [JsonProperty("DefaultFlameTurretLoadouts")]
            public DefaultBaseLoadout[] DefaultFlameTurretLoadouts =
            {
                new()
                {
                    Name = "fullammo",
                    ReserveAmmo = new List<AmmoAmount>
                    {
                        new() { Name = "lowgradefuel", Amount = 500 }
                    },
                },
            };

            [JsonProperty("DefaultShotgunTrapLoadouts")]
            public DefaultBaseLoadout[] DefaultShotgunTrapLoadouts =
            {
                new()
                {
                    Name = "fullammo",
                    ReserveAmmo = new List<AmmoAmount>
                    {
                        new() { Name = "ammo.handmade.shell", Amount = 128 },
                        new() { Name = "ammo.handmade.shell", Amount = 128 },
                        new() { Name = "ammo.handmade.shell", Amount = 128 },
                        new() { Name = "ammo.handmade.shell", Amount = 128 },
                        new() { Name = "ammo.handmade.shell", Amount = 128 },
                        new() { Name = "ammo.handmade.shell", Amount = 128 },
                    },
                },
            };

            public void Init(TurretLoadouts pluginInstance)
            {
                foreach (var loadout in DefaultLoadouts)
                {
                    loadout.Init(pluginInstance, Permission_DefaultLoadoutPrefix);
                }

                foreach (var loadout in DefaultSamSiteLoadouts)
                {
                    loadout.Init(pluginInstance, Permission_DefaultSamSiteLoadoutPrefix);
                }

                foreach (var loadout in DefaultFlameTurretLoadouts)
                {
                    loadout.Init(pluginInstance, Permission_DefaultFlameTurretLoadoutPrefix);
                }

                foreach (var loadout in DefaultShotgunTrapLoadouts)
                {
                    loadout.Init(pluginInstance, Permission_DefaultShotgunTrapLoadoutPrefix);
                }

                foreach (var ruleset in LoadoutRulesets)
                {
                    ruleset.Init(pluginInstance, Permission_RulesetPrefix);
                }
            }
        }

        private abstract class BaseProfile
        {
            [JsonProperty("Name")]
            public string Name;

            [JsonIgnore]
            public string Permission;

            public void Init(TurretLoadouts pluginInstance, string permissionPrefix)
            {
                if (string.IsNullOrWhiteSpace(Name))
                    return;

                Permission = $"{permissionPrefix}.{Name}";
                pluginInstance.permission.RegisterPermission(Permission, pluginInstance);
            }
        }

        private class LoadoutRuleset : BaseProfile
        {
            [JsonProperty("AllowedWeapons", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string[] AllowedWeapons;

            [JsonProperty("DisallowedWeapons", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string[] DisallowedWeapons;

            [JsonProperty("AllowedAttachments", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string[] AllowedAttachments;

            [JsonProperty("DisallowedAttachments", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string[] DisallowedAttachments;

            [JsonProperty("AllowedAmmo", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Dictionary<string, int> AllowedAmmo;

            public bool IsWeaponAllowed(string weaponName)
            {
                if (AllowedWeapons != null)
                    return AllowedWeapons.Contains(weaponName);

                if (DisallowedWeapons != null)
                    return !DisallowedWeapons.Contains(weaponName);

                return true;
            }

            public bool IsAttachmentAllowed(string attachmentName)
            {
                if (AllowedAttachments != null)
                    return AllowedAttachments.Contains(attachmentName);

                if (DisallowedAttachments != null)
                    return !DisallowedAttachments.Contains(attachmentName);

                return true;
            }
        }

        private class BaseLoadout : BaseProfile
        {
            [JsonProperty("ReserveAmmo", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public List<AmmoAmount> ReserveAmmo;

            [JsonIgnore]
            public virtual bool IsDefault => false;
        }

        private class DefaultBaseLoadout : BaseLoadout
        {
            public override bool IsDefault => true;
        }

        private class TurretLoadout : BaseLoadout
        {
            [JsonProperty("Weapon")]
            public string Weapon;

            [JsonProperty("Skin", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong Skin;

            [JsonProperty("Peacekeeper", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool Peacekeeper;

            [JsonProperty("Attachments", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public List<string> Attachments;

            [JsonProperty("Ammo", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public AmmoAmount Ammo;
        }

        private class DefaultTurretLoadout : TurretLoadout
        {
            public override bool IsDefault => true;
        }

        private class AmmoAmount
        {
            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("Amount")]
            public int Amount;
        }

        private Configuration GetDefaultConfig() => new();

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private string GetMessage(string userIdString, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, userIdString);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetMessage(BasePlayer basePlayer, string messageName, params object[] args) =>
            GetMessage(basePlayer.UserIDString, messageName, args);

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer basePlayer, string messageName, params object[] args) =>
            basePlayer.ChatMessage(string.Format(GetMessage(basePlayer, messageName), args));

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Generic.RestrictedItems"] = "<color=#f44>Restricted items not saved:</color>",
                ["Generic.DefaultLoadoutName"] = "Default",
                ["Generic.Error.NoPermission"] = "You don't have permission to use this command.",
                ["Generic.Error.NoTurretWeapon"] = "Error: That auto turret has no weapon.",
                ["Generic.Error.WeaponNotAllowed"] = "Error: Weapon not allowed: <color=#f44>{0}</color>.",
                ["Generic.Error.LoadoutNotFound"] = "Error: Loadout <color=#fe4>{0}</color> not found.",
                ["Generic.Error.LoadoutNameLength"] = "Error: Loadout name may not be longer than <color=#fe4>{0}</color> characters.",
                ["Generic.Error.DefaultLoadout"] = "Error: You cannot edit the default loadout.",
                ["Generic.Header"] = "<size=16><color=#fa5>Turret Loadouts</color></size>",
                ["Generic.FilledFromLoadout"] = "Filled turret with loadout: <color=#fe4>{0}</color>. Type <color=#fe4>/tl help</color> for more options.",

                ["Command.Activate.Error.Syntax"] = "Syntax: <color=#fe4>tl <loadout name></color>",
                ["Command.Activate.Success.Deactivated"] = "Deactivated <color=#fe4>{0}</color> loadout.",

                ["Command.Default.HelpHint"] = "Use <color=#fe4>tl help</color> for more options.",
                ["Command.Default.NoActive"] = "No active turret loadout.",
                ["Command.Default.Active"] = "<size=16><color=#fa5>Active Turret Loadout</color>: {0}</size>",
                ["Command.Default.Mode.AttackAll"] = "<color=#fe4>Mode</color>: <color=#f44>Attack All</color>",
                ["Command.Default.Mode.Peacekeeper"] = "<color=#fe4>Mode</color>: <color=#6e6>Peacekeeper</color>",
                ["Command.Default.Weapon"] = "<color=#fe4>Weapon</color>: {0}{1}",
                ["Command.Default.Attachments"] = "<color=#fe4>Attachments</color>:",
                ["Command.Default.ReserveAmmo"] = "<color=#fe4>Reserve ammo</color>:",

                ["Command.List.NoLoadouts"] = "You don't have any turret loadouts.",
                ["Command.List.ToggleHint"] = "Use <color=#fe4>tl <loadout name></color> to activate or deactivate a loadout.",
                ["Command.List.Item"] = "<color=#fe4>{1}</color>{0} - {2}{3}",
                ["Command.List.Item.Active"] = " <color=#5bf>[ACTIVE]</color>",

                ["Command.Save.Error.Syntax"] = "Syntax: <color=#fe4>tl save <name></color>",
                ["Command.Save.Error.NoTurretFound"] = "Error: No auto turret found.",
                ["Command.Save.Error.LoadoutExists"] = "Error: Loadout <color=#fe4>{0}</color> already exists. Use <color=#fe4>tl update {0}</color> to update it.",
                ["Command.Save.Error.TooManyLoadouts"] = "Error: You may not have more than <color=#fe4>{0}</color> loadouts. You may delete another loadout and try again.",
                ["Command.Save.Success"] = "Turret loadout saved as <color=#fe4>{0}</color>. Activate it with <color=#fe4>tl {0}</color>.",

                ["Command.Update.Error.Syntax"] = "Syntax: <color=#fe4>tl update <name></color>",
                ["Command.Update.Success"] = "Updated <color=#fe4>{0}</color> loadout.",

                ["Command.Rename.Error.Syntax"] = "Syntax: <color=#fe4>tl rename <name> <new name></color>",
                ["Command.Rename.Error.LoadoutNameTaken"] = "Error: Loadout name <color=#fe4>{0}</color> is already taken.",
                ["Command.Rename.Success"] = "Renamed <color=#fe4>{0}</color> loadout to <color=#fe4>{1}</color>.",

                ["Command.Delete.Error.Syntax"] = "Syntax: <color=#fe4>tl delete <name></color>",
                ["Command.Delete.Success"] = "Deleted <color=#fe4>{0}</color> loadout.",

                ["Command.Help.Details"] = "<color=#fe4>tl</color> - Show your active loadout details",
                ["Command.Help.List"] = "<color=#fe4>tl list</color> - List turret loadouts",
                ["Command.Help.Activate"] = "<color=#fe4>tl <loadout name></color> - Toggle whether a loadout is active",
                ["Command.Help.Save"] = "<color=#fe4>tl save <name></color> - Save a loadout with the turret you are aiming at",
                ["Command.Help.Update"] = "<color=#fe4>tl update <name></color> - Overwrite an existing loadout with the turret you are aiming at",
                ["Command.Help.Rename"] = "<color=#fe4>tl rename <name> <new name></color> - Rename a loadout",
                ["Command.Help.Delete"] = "<color=#fe4>tl delete <name></color> - Delete a loadout",

                ["Abbreviation.weapon.mod.8x.scope"] = "16x",
                ["Abbreviation.weapon.mod.flashlight"] = "FL",
                ["Abbreviation.weapon.mod.holosight"] = "HS",
                ["Abbreviation.weapon.mod.lasersight"] = "LS",
                ["Abbreviation.weapon.mod.muzzleboost"] = "MBS",
                ["Abbreviation.weapon.mod.muzzlebrake"] = "MBR",
                ["Abbreviation.weapon.mod.silencer"] = "SL",
                ["Abbreviation.weapon.mod.simplesight"] = "SS",
                ["Abbreviation.weapon.mod.small.scope"] = "8x",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: TurretLoadouts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tank-commander ---
// --- Original File Path: T/TankCommander/TankCommander.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Globalization;
using Rust;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("Tank Commander", "k1lly0u", "0.2.3")]
    [Description("Drive tanks, shoot stuff")]
    class TankCommander : RustPlugin
    {
        #region Fields
        [PluginReference]
        private Plugin Friends, Clans, Godmode;
       
        private static TankCommander ins;

        private List<APCController> controllers = new List<APCController>();
        
        private Dictionary<CommandType, BUTTON> controlButtons;

        private int rocketId;
        private int mgId;

        private const string APC_PREFAB = "assets/prefabs/npc/m2bradley/bradleyapc.prefab";
        private const string CHAIR_PREFAB = "assets/prefabs/vehicle/seats/miniheliseat.prefab";
        private const string UI_HEALTH = "TCUI_Health";
        private const string UI_AMMO_MG = "TCUI_Ammo_MG";
        private const string UI_AMMO_ROCKET = "TCUI_Ammo_Rocket";

        private const int TARGET_LAYERS = ~(1 << 10 | 1 << 13 | 1 << 17 | 1 << 18 | 1 << 20 | 1 << 28 | 1 << 29);
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("tankcommander.admin", this);
            permission.RegisterPermission("tankcommander.use", this);
        }

        private void OnServerInitialized()
        {
            ins = this;

            ConvertControlButtons();

            rocketId = ItemManager.itemList.Find(x => x.shortname == configData.Weapons.Cannon.Type)?.itemid ?? 0;
            mgId = ItemManager.itemList.Find(x => x.shortname == configData.Weapons.MG.Type)?.itemid ?? 0;
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BradleyAPC)
            {
                APCController controller = entity.GetComponent<APCController>();
                if (controller != null)
                {
                    controller.ManageDamage(info);
                    return null;
                }
            }

            if (entity is BasePlayer)
            {
                if (IsOnboardAPC(entity as BasePlayer))
                    return true;

                if (info.Initiator is BradleyAPC)
                {
                    APCController controller = (info.Initiator as BradleyAPC).GetComponent<APCController>();
                    if (controller != null)
                    {
                        if (!controller.HasCommander)
                            return true;
                    }
                }
            }
            else if (entity is BaseMountable)
            {
                if (entity.GetComponentInParent<APCController>())
                    return true;
            }

            return null;
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (player == null || IsOnboardAPC(player) || !HasPermission(player, "tankcommander.use"))
                return;

            if (configData.Inventory.Enabled && input.WasJustPressed(controlButtons[CommandType.Inventory]))
            {
                RaycastHit hit;
                if (Physics.SphereCast(player.eyes.position, 0.5f, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward, out hit, 3f))
                {
                    APCController controller = hit.GetEntity()?.GetComponent<APCController>();
                    if (controller != null && !controller.HasCommander)
                        OpenTankInventory(player, controller);
                }
                return;
            }

            if (input.WasJustPressed(controlButtons[CommandType.EnterExit]))
            {
                RaycastHit hit;
                if (Physics.SphereCast(player.eyes.position, 0.5f, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward, out hit, 3f))
                {
                    APCController controller = hit.GetEntity()?.GetComponent<APCController>();
                    if (controller != null)
                    {                        
                        if (!controller.HasCommander)
                        {
                            controller.MountPlayer(player);
                        }
                        else
                        {
                            if (configData.Passengers.Enabled && controller.CanMountPlayer())
                            {
                                BasePlayer commander = controller.Commander;

                                if (!configData.Passengers.UseFriends && !configData.Passengers.UseClans)
                                {
                                    controller.MountPlayer(player);
                                    return;
                                }

                                if (configData.Passengers.UseFriends && AreFriends(commander.userID, player.userID))
                                {
                                    controller.MountPlayer(player);
                                    return;
                                }

                                if (configData.Passengers.UseClans && IsClanmate(commander.userID, player.userID))
                                {
                                    controller.MountPlayer(player);
                                    return;
                                }

                                player.ChatMessage(msg("not_friend", player.UserIDString));
                            }
                            else player.ChatMessage(msg("in_use", player.UserIDString));
                        }
                    }
                }
            }
        }

        private object CanDismountEntity(BasePlayer player, BaseMountable mountable)
        {
            APCController controller = mountable?.GetComponentInParent<APCController>();
            if (controller != null)
            {
                controller.DismountPlayer(player);
                return false;
            }

            return null;
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            APCController controller;
            if (IsOnboardAPC(player, out controller))
            {
                controller.DismountPlayer(player);
            }
        }

        private object OnRunPlayerMetabolism(PlayerMetabolism metabolism, BaseCombatEntity entity)
        {
            BasePlayer player = entity.ToPlayer();
            if (player == null || !IsOnboardAPC(player))
                return null;

            if (Godmode && (bool)Godmode.Call("IsGod", player.UserIDString))
                return null;

            return true;
        }

        private void Unload()
        {
            foreach (APCController controller in controllers)
                UnityEngine.Object.Destroy(controller);

            APCController[] objects = UnityEngine.Object.FindObjectsOfType<APCController>();
            if (objects != null)
            {
                foreach(APCController obj in objects)
                    UnityEngine.Object.Destroy(obj);
            }

            controllers.Clear();

            configData = null;
            ins = null;
        }
        #endregion

        #region Functions
        private bool IsOnboardAPC(BasePlayer player) => player?.GetMounted()?.GetComponentInParent<APCController>() != null;

        private bool IsOnboardAPC(BasePlayer player, out APCController controller)
        {
            controller = player?.GetMounted()?.GetComponentInParent<APCController>();
            return controller != null;
        }

        private T ParseType<T>(string type) => (T)Enum.Parse(typeof(T), type, true);

        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm) || permission.UserHasPermission(player.UserIDString, "tankcommander.admin");

        private void ConvertControlButtons()
        {
            controlButtons = new Dictionary<CommandType, BUTTON>
            {
                [CommandType.EnterExit] = ParseType<BUTTON>(configData.Buttons.Enter),
                [CommandType.Lights] = ParseType<BUTTON>(configData.Buttons.Lights),
                [CommandType.Inventory] = ParseType<BUTTON>(configData.Buttons.Inventory),
                [CommandType.Boost] = ParseType<BUTTON>(configData.Buttons.Boost),
                [CommandType.Cannon] = ParseType<BUTTON>(configData.Buttons.Cannon),
                [CommandType.Coax] = ParseType<BUTTON>(configData.Buttons.Coax),
                [CommandType.MG] = ParseType<BUTTON>(configData.Buttons.MG)
            };
        }

        private void OpenTankInventory(BasePlayer player, APCController controller)
        {
            player.inventory.loot.Clear();
            player.inventory.loot.entitySource = controller.entity;
            player.inventory.loot.itemSource = null;
            player.inventory.loot.AddContainer(controller.inventory);
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "generic");
            player.SendNetworkUpdate();
        }
        #endregion

        #region Component
        private enum CommandType { EnterExit, Lights, Inventory, Boost, Cannon, Coax, MG }
        
        private class APCController : MonoBehaviour
        {
            public BradleyAPC entity;
            private Rigidbody rigidBody;
            private BaseMountable[] mountables;

            private WheelCollider[] leftWheels;
            private WheelCollider[] rightWheels;

            public ItemContainer inventory;

            private float accelTimeTaken;
            private float accelTimeToTake = 3f;

            private float forwardTorque = 2000f;
            private float maxBrakeTorque = 50f;
            private float turnTorque = 2000f;

            private float lastFireCannon;
            private float lastFireMG;
            private float lastFireCoax;

            private bool isDying = false;
            private RaycastHit eyeRay;

            private Vector3 mouseInput = Vector3.zero;
            private Vector3 aimVector = Vector3.forward;
            private Vector3 aimVectorTop = Vector3.forward;

            private Dictionary<CommandType, BUTTON> controlButtons;
            private ConfigData.WeaponOptions.WeaponSystem cannon;
            private ConfigData.WeaponOptions.WeaponSystem mg;
            private ConfigData.WeaponOptions.WeaponSystem coax;
            private ConfigData.CrushableTypes crushables;

            public bool HasCommander
            {
                get
                {
                    return mountables[0].GetMounted() != null;
                }
            }

            public BasePlayer Commander { get; private set; }

            private void Awake()
            {
                entity = GetComponent<BradleyAPC>();

                entity.enabled = false;

                entity.CancelInvoke(entity.UpdateTargetList);
                entity.CancelInvoke(entity.UpdateTargetVisibilities);

                rigidBody = entity.myRigidBody;
                leftWheels = entity.leftWheels;
                rightWheels = entity.rightWheels;

                forwardTorque = configData.Movement.ForwardTorque;
                turnTorque = configData.Movement.TurnTorque;
                maxBrakeTorque = configData.Movement.BrakeTorque;
                accelTimeToTake = configData.Movement.Acceleration;

                controlButtons = ins.controlButtons;
                cannon = configData.Weapons.Cannon;
                mg = configData.Weapons.MG;
                coax = configData.Weapons.Coax;
                crushables = configData.Crushables;

                if (configData.Inventory.Enabled)
                {
                    inventory = new ItemContainer();
                    inventory.ServerInitialize(null, configData.Inventory.Size);
                    if (!inventory.uid.IsValid)
                        inventory.GiveUID();
                }
                
                CreateMountPoints();
                SetInitialAimDirection();
            }

            private void OnDestroy()
            {
                DismountAll();

                for (int i = 0; i < mountables.Length; i++)
                {
                    BaseMountable mountable = mountables[i];
                    if (mountable != null && !mountable.IsDestroyed)
                        mountable.Kill();
                }                

                if (entity != null && !entity.IsDestroyed)
                    entity.Kill();
            }

            private void Update()
            {
                if (Commander != null)
                {                   
                    DoMovementControls();
                    AdjustAiming();
                    DoWeaponControls();

                    entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                }
            }

            private void LateUpdate()
            {
                mouseInput = Commander?.serverInput?.current?.mouseDelta ?? Vector2.zero;
            }

            private void OnCollisionEnter(Collision collision)
            {
                if (!HasCommander) return;

                GameObject gObject = collision.gameObject;
                if (gObject == null)
                    return;

                if (crushables.Players)
                {
                    BasePlayer triggerPlayer = gObject.GetComponentInParent<BasePlayer>();
                    if (triggerPlayer != null && !IsPassenger(triggerPlayer))
                    {
                        triggerPlayer.Die(new HitInfo(Commander, triggerPlayer, DamageType.Blunt, 200f));
                        return;
                    }
                }

                if (crushables.Animals)
                {
                    BaseNpc npc = gObject.GetComponentInParent<BaseNpc>();
                    if (npc != null)
                    {
                        npc.Die(new HitInfo(Commander, npc, DamageType.Blunt, 200f));
                        return;
                    }
                }

                float impactForce = CalculateImpactForce(collision);

                if (crushables.Buildings)
                {
                    BuildingBlock buildingBlock = gObject.GetComponentInParent<BuildingBlock>();
                    if (buildingBlock != null && impactForce >= crushables.GradeForce[buildingBlock.grade.ToString()])
                    {
                        buildingBlock.Die(new HitInfo(Commander, buildingBlock, DamageType.Blunt, 1000f));
                        return;
                    }

                    SimpleBuildingBlock simpleBlock = gObject.GetComponentInParent<SimpleBuildingBlock>();
                    if (simpleBlock != null && impactForce >= crushables.WallForce)
                    {
                        simpleBlock.Die(new HitInfo(Commander, simpleBlock, DamageType.Blunt, 1500));
                        return;
                    }
                }

                if (crushables.Loot)
                {
                    LootContainer loot = gObject.GetComponentInParent<LootContainer>();
                    if (loot != null)
                    {
                        loot.Die(new HitInfo(Commander, loot, DamageType.Blunt, 200f));
                        return;
                    }
                }

                if (crushables.Resources)
                {
                    ResourceEntity resource = gObject.GetComponentInParent<ResourceEntity>();
                    if (resource != null && impactForce >= crushables.ResourceForce)
                    {
                        resource.Kill(BaseNetworkable.DestroyMode.None);
                        return;
                    }
                }
            }

            private float CalculateImpactForce(Collision col)
            {
                float impactVelocityX = rigidBody.velocity.x;
                impactVelocityX *= Mathf.Sign(impactVelocityX);

                float impactVelocityY = rigidBody.velocity.y;
                impactVelocityY *= Mathf.Sign(impactVelocityY);

                float impactVelocity = impactVelocityX + impactVelocityY;
                float impactForce = impactVelocity * rigidBody.mass;
                impactForce *= Mathf.Sign(impactForce);

                return impactForce;
            }

            private bool IsPassenger(BasePlayer player)
            {
                BaseMountable mountable = player.GetMounted();
                if (mountable == null)
                    return false;

                return mountables.Contains(mountable);
            }

            #region Mounting
            private List<KeyValuePair<Vector3, Vector3>> mountOffsets = new List<KeyValuePair<Vector3, Vector3>>()
            {
                new KeyValuePair<Vector3, Vector3>(new Vector3(0.6f, 1.9f, -0.6f), Vector3.zero),
                new KeyValuePair<Vector3, Vector3>(new Vector3(-0.6f, 0.4f, -1.3f), new Vector3(0f, 90f, 0f)),
                new KeyValuePair<Vector3, Vector3>(new Vector3(-0.6f, 0.4f, -2f), new Vector3(0f, 90f, 0f)),
                new KeyValuePair<Vector3, Vector3>(new Vector3(0.5f, 0.4f, -1.3f), new Vector3(0f, -90f, 0f)),
                new KeyValuePair<Vector3, Vector3>(new Vector3(0.5f, 0.4f, -2f), new Vector3(0f, -90f, 0f)),
            };

            private void CreateMountPoints()
            {
                int passengers = Mathf.Clamp(configData.Passengers.Max, 0, 4) + 1;
                mountables = new BaseMountable[passengers];

                for (int i = 0; i < passengers; i++)
                {
                    CreateMountPoint(i);
                }
            }

            private void CreateMountPoint(int index)
            {
                KeyValuePair<Vector3, Vector3> offset = mountOffsets[index];

                BaseMountable mountable = GameManager.server.CreateEntity(CHAIR_PREFAB, entity.transform.position) as BaseMountable;
                mountable.enableSaving = false;                
                mountable.Spawn();

                Destroy(mountable.GetComponent<DestroyOnGroundMissing>());
                Destroy(mountable.GetComponent<GroundWatch>());

                mountable.SetParent(entity, index == 0 ? (uint)4239370974 : (uint)0, false, true);
                mountable.transform.localPosition = offset.Key;
                mountable.transform.localRotation = Quaternion.Euler(offset.Value);
                
                GameObject tr = new GameObject("Seat Transform");
                tr.transform.SetParent(mountable.transform);
                tr.transform.localPosition = index > 0 ? new Vector3(0, 0, -3f) : new Vector3(3f, 0, 0);

                mountable.dismountPositions = new Transform[] { tr.transform };

                mountables[index] = mountable;
            }

            public bool CanMountPlayer()
            {
                for (int i = 0; i < mountables.Length; i++)
                {
                    BaseMountable mountable = mountables[i];
                    if (!mountable.IsMounted())
                        return true;
                }

                return false;
            }

            public void MountPlayer(BasePlayer player)
            {
                for (int i = 0; i < mountables.Length; i++)
                {                    
                    BaseMountable mountable = mountables[i];
                    if (mountable.IsMounted())
                        continue;

                    player.EnsureDismounted();
                    mountable._mounted = player;
                    player.MountObject(mountable, 0);
                    player.MovePosition(mountable.mountAnchor.transform.position);
                    player.transform.rotation = mountable.mountAnchor.transform.rotation;
                    player.ServerRotation = mountable.mountAnchor.transform.rotation;
                    player.OverrideViewAngles(mountable.mountAnchor.transform.rotation.eulerAngles);
                    player.eyes.NetworkUpdate(mountable.mountAnchor.transform.rotation);
                    player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
                    mountable.SetFlag(BaseEntity.Flags.Busy, true, false);

                    if (i > 0)
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, true);

                    OnEntityMounted(player, i == 0);
                    return;
                }
            }

            public void DismountPlayer(BasePlayer player)
            {
                if (player == null)
                    return;

                BaseMountable mountable = player.GetMounted();
                if (mountable == null)
                    return;

                player.PauseFlyHackDetection(1f);

                Vector3 dismountPosition = mountable.dismountPositions[0].position;
               
                if (TerrainMeta.HeightMap.GetHeight(dismountPosition) > dismountPosition.y)
                    dismountPosition.y = TerrainMeta.HeightMap.GetHeight(dismountPosition) + 0.5f;

                player.DismountObject();
                player.transform.rotation = Quaternion.identity;
                player.MovePosition(dismountPosition);
                player.eyes.NetworkUpdate(Quaternion.identity);

                player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);

                player.SendNetworkUpdateImmediate(false);
                player.ClientRPCPlayer(null, player, "ForcePositionTo", dismountPosition);
                mountable._mounted = null;

                if (player == Commander)
                {
                    entity.CancelInvoke(DrawTargeting);
                    Commander = null;
                }

                DestroyAllUI(player);
            }

            private void DismountAll()
            {
                for (int i = 0; i < mountables.Length; i++)
                {
                    BasePlayer player = mountables[i].GetMounted();
                    if (player != null)
                        DismountPlayer(player);
                }

                Commander = null;
            }

            private void OnEntityMounted(BasePlayer player, bool isOperator)
            {
                if (isOperator)
                {
                    string ctrlStr = msg("controls", player.UserIDString);
                    if (configData.Weapons.Cannon.Enabled)
                        ctrlStr += $"\n{string.Format(msg("fire_cannon", player.UserIDString), configData.Buttons.Cannon)}";
                    if (configData.Weapons.Coax.Enabled)
                        ctrlStr += $"\n{string.Format(msg("fire_coax", player.UserIDString), configData.Buttons.Coax)}";
                    if (configData.Weapons.MG.Enabled)
                        ctrlStr += $"\n{string.Format(msg("fire_mg", player.UserIDString), configData.Buttons.MG)}";
                    ctrlStr += $"\n{string.Format(msg("speed_boost", player.UserIDString), configData.Buttons.Boost)}";
                    ctrlStr += $"\n{string.Format(msg("enter_exit", player.UserIDString), configData.Buttons.Enter)}";
                    ctrlStr += $"\n{string.Format(msg("toggle_lights", player.UserIDString), configData.Buttons.Lights)}";
                    if (configData.Inventory.Enabled)
                        ctrlStr += $"\n{string.Format(msg("access_inventory", player.UserIDString), configData.Buttons.Inventory)}";
                    player.ChatMessage(ctrlStr);

                    CreateHealthUI(player, this);
                    CreateMGAmmoUI(player, this);
                    CreateRocketAmmoUI(player, this);

                    Commander = player;
                    entity.InvokeRepeating(DrawTargeting, DDRAW_UPDATE_TIME, DDRAW_UPDATE_TIME);
                }
                else
                {
                    player.ChatMessage(string.Format(msg("enter_exit", player.UserIDString), configData.Buttons.Enter));
                    if (configData.Inventory.Enabled)
                        player.ChatMessage(string.Format(msg("access_inventory", player.UserIDString), configData.Buttons.Inventory));
                    CreateHealthUI(player, this);
                }
            }
            #endregion

            #region Weapons
            private void SetInitialAimDirection()
            {
                aimVector = aimVectorTop = entity.transform.forward.normalized;

                entity.AimWeaponAt(entity.mainTurret, entity.coaxPitch, aimVector, -90f, 7f, 360f, null);
                entity.AimWeaponAt(entity.mainTurret, entity.CannonPitch, aimVector, -90f, 7f, 360f, null);
                entity.AimWeaponAt(entity.topTurretYaw, entity.topTurretPitch, aimVectorTop, -360f, 360f, 360f, entity.mainTurret);

                entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }

            private void DoWeaponControls()
            {                
                if (Commander.serverInput.WasJustPressed(controlButtons[CommandType.Lights]))
                    ToggleLights();

                if (Commander.serverInput.WasJustPressed(controlButtons[CommandType.Cannon]))
                    FireCannon();

                if (Commander.serverInput.IsDown(controlButtons[CommandType.MG]) || Commander.serverInput.WasJustPressed(controlButtons[CommandType.MG]))
                    FireMG();

                if (Commander.serverInput.IsDown(controlButtons[CommandType.Coax]) || Commander.serverInput.WasJustPressed(controlButtons[CommandType.Coax]))
                    FireCoax();
            }

            private void AdjustAiming()
            {                
                if (Mathf.Abs(mouseInput.x) < 0.5f)
                    mouseInput.x = 0;

                if (Mathf.Abs(mouseInput.y) < 0.5f)
                    mouseInput.y = 0;

                if (mouseInput == Vector3.zero)
                    return;

                Vector3 direction = Quaternion.Euler(entity.mainTurret.transform.eulerAngles + (new Vector3(-mouseInput.y, mouseInput.x, 0f) * 5f)) * Vector3.forward;
                
                Ray ray = new Ray(Commander.eyes.transform.position, direction);

                Vector3 hitPoint;

                if (Physics.Raycast(ray, out eyeRay, 5000f, TARGET_LAYERS))
                    hitPoint = eyeRay.point;                
                else hitPoint = ray.GetPoint(100);
                
                Vector3 desiredAim = (hitPoint - Commander.eyes.transform.position).normalized;
                Vector3 desiredAimTop = (hitPoint - entity.topTurretEyePos.transform.position).normalized;

                aimVector = entity.turretAimVector = Vector3.Lerp(aimVector, desiredAim, Time.deltaTime * 3f);
                aimVectorTop = entity.topTurretAimVector = Vector3.Lerp(aimVectorTop, desiredAimTop, Time.deltaTime * 3f);

                entity.AimWeaponAt(entity.mainTurret, entity.coaxPitch, aimVector, -90f, 7f, 360f, null);
                entity.AimWeaponAt(entity.mainTurret, entity.CannonPitch, aimVector, -90f, 7f, 360f, null);

                entity.AimWeaponAt(entity.topTurretYaw, entity.topTurretPitch, aimVectorTop, -360f, 360f, 360f, entity.mainTurret);
            }

            private const float DDRAW_UPDATE_TIME = 0.02f;

            private void DrawTargeting()
            {
                if (!configData.Weapons.EnableCrosshair || Commander == null)
                    return;

                Vector3 start = entity.CannonMuzzle.transform.position;
                Vector3 end = Vector3.zero;                  

                RaycastHit rayHit;
                if (Physics.Raycast(start, entity.CannonMuzzle.forward, out rayHit, 300, 1219701521, QueryTriggerInteraction.Ignore))                
                    end = rayHit.point;                
                else end = start + (entity.CannonMuzzle.forward * 300);
                
                if (Commander.IsAdmin)
                {
                    Commander.SendConsoleCommand("ddraw.text", DDRAW_UPDATE_TIME + 0.01f, configData.Weapons.CrosshairColor.Color, end, $"<size={configData.Weapons.CrosshairSize}>⊕</size>");
                }
                else
                {
                    Commander.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    Commander.SendNetworkUpdateImmediate();
                    Commander.SendConsoleCommand("ddraw.text", DDRAW_UPDATE_TIME + 0.01f, configData.Weapons.CrosshairColor.Color, end, $"<size={configData.Weapons.CrosshairSize}>⊕</size>");
                    Commander.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                }            
            }

            private void FireCannon()
            {
                if (cannon.RequireAmmo)
                {
                    if (inventory.itemList.Find(x => x.info.shortname == cannon.Type) == null)
                    {
                        if (ItemManager.itemDictionaryByName.ContainsKey(cannon.Type))
                            Commander.ChatMessage(string.Format(msg("no_ammo_cannon", Commander.UserIDString), ItemManager.itemDictionaryByName[cannon.Type].displayName.english));
                        else print($"Invalid ammo type for the cannon set in config: {cannon.Type}");
                        return;
                    }
                }
                if (Time.realtimeSinceStartup >= lastFireCannon)
                {
                    Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(cannon.Accuracy, entity.CannonMuzzle.rotation * Vector3.forward, true);
                    Vector3 cannonPitch = (entity.CannonPitch.transform.rotation * Vector3.back) + (entity.transform.up * -1f);

                    entity.myRigidBody.AddForceAtPosition(cannonPitch.normalized * entity.recoilScale, entity.CannonPitch.transform.position, ForceMode.Impulse);

                    Effect.server.Run(entity.mainCannonMuzzleFlash.resourcePath, entity, StringPool.Get(entity.CannonMuzzle.gameObject.name), Vector3.zero, Vector3.zero, null, false);

                    BaseEntity rocket = GameManager.server.CreateEntity(entity.mainCannonProjectile.resourcePath, entity.CannonMuzzle.transform.position, Quaternion.LookRotation(modifiedAimConeDirection), true);
                    ServerProjectile projectile = rocket.GetComponent<ServerProjectile>();
                    projectile.InitializeVelocity(modifiedAimConeDirection.normalized * projectile.speed);
                    rocket.Spawn();

                    TimedExplosive explosive = rocket.GetComponent<TimedExplosive>();
                    if (explosive != null)
                        explosive.damageTypes.Add(new DamageTypeEntry { amount = cannon.Damage, type = DamageType.Explosion });

                    lastFireCannon = Time.realtimeSinceStartup + cannon.Interval;

                    if (cannon.RequireAmmo)
                        inventory.itemList.Find(x => x.info.shortname == cannon.Type)?.UseItem(1);
                    CreateRocketAmmoUI(Commander, this);
                }
            }

            private void FireCoax()
            {
                if (coax.RequireAmmo)
                {
                    if (inventory.itemList.Find(x => x.info.shortname == coax.Type) == null)
                    {
                        if (ItemManager.itemDictionaryByName.ContainsKey(coax.Type))
                            Commander.ChatMessage(string.Format(msg("no_ammo_coax", Commander.UserIDString), ItemManager.itemDictionaryByName[coax.Type].displayName.english));
                        else print($"Invalid ammo type for the coaxial gun set in config: {coax.Type}");
                        return;
                    }
                }
                if (Time.realtimeSinceStartup >= lastFireCoax)
                {
                    Vector3 vector3 = entity.coaxMuzzle.transform.position - (entity.coaxMuzzle.forward * 0.25f);

                    Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(coax.Accuracy, entity.coaxMuzzle.transform.forward, true);
                    Vector3 targetPos = vector3 + (modifiedAimConeDirection * 300f);

                    List<RaycastHit> list = Pool.GetList<RaycastHit>();
                    GamePhysics.TraceAll(new Ray(vector3, modifiedAimConeDirection), 0f, list, 300f, 1219701521, QueryTriggerInteraction.UseGlobal);
                    for (int i = 0; i < list.Count; i++)
                    {
                        RaycastHit hit = list[i];
                        BaseEntity hitEntity = hit.GetEntity();
                        if (hitEntity != null && hitEntity != this.entity)
                        {
                            BaseCombatEntity baseCombatEntity = hitEntity as BaseCombatEntity;
                            if (baseCombatEntity != null)
                                ApplyDamage(baseCombatEntity, coax.Damage, hit.point, modifiedAimConeDirection);

                            if (hitEntity.ShouldBlockProjectiles())
                            {
                                targetPos = hit.point;
                                break;
                            }
                        }
                    }

                    entity.ClientRPC(null, "CLIENT_FireGun", true, targetPos);
                    Pool.FreeList<RaycastHit>(ref list);

                    lastFireCoax = Time.realtimeSinceStartup + coax.Interval;

                    if (coax.RequireAmmo)
                        inventory.itemList.Find(x => x.info.shortname == coax.Type)?.UseItem(1);
                    CreateMGAmmoUI(Commander, this);
                }
            }

            private void FireMG()
            {
                if (mg.RequireAmmo)
                {
                    if (inventory.itemList.Find(x => x.info.shortname == mg.Type) == null)
                    {
                        if (ItemManager.itemDictionaryByName.ContainsKey(mg.Type))
                            Commander.ChatMessage(string.Format(msg("no_ammo_mg", Commander.UserIDString), ItemManager.itemDictionaryByName[mg.Type].displayName.english));
                        else print($"Invalid ammo type for the machine gun set in config: {mg.Type}");
                        return;
                    }
                }
                if (Time.realtimeSinceStartup >= lastFireMG)
                {
                    Vector3 firePosition = entity.topTurretMuzzle.transform.position - (entity.topTurretMuzzle.forward * 0.25f);

                    Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(mg.Accuracy, entity.topTurretMuzzle.transform.forward, true);
                    Vector3 targetPos = firePosition + modifiedAimConeDirection;

                    List<RaycastHit> list = Pool.GetList<RaycastHit>();
                    GamePhysics.TraceAll(new Ray(firePosition, modifiedAimConeDirection), 0f, list, 300f, 1219701521, QueryTriggerInteraction.UseGlobal);
                    for (int i = 0; i < list.Count; i++)
                    {
                        RaycastHit hit = list[i];
                        BaseEntity hitEntity = hit.GetEntity();
                        if (hitEntity != null && !hitEntity == this.entity)
                        {
                            BaseCombatEntity baseCombatEntity = hitEntity as BaseCombatEntity;
                            if (baseCombatEntity != null)
                                ApplyDamage(baseCombatEntity, mg.Damage, hit.point, modifiedAimConeDirection);

                            if (hitEntity.ShouldBlockProjectiles())
                            {
                                targetPos = hit.point;
                                break;
                            }
                        }
                    }

                    entity.ClientRPC(null, "CLIENT_FireGun", false, targetPos);
                    Pool.FreeList<RaycastHit>(ref list);

                    lastFireMG = Time.realtimeSinceStartup + mg.Interval;

                    if (mg.RequireAmmo)
                        inventory.itemList.Find(x => x.info.shortname == mg.Type)?.UseItem(1);
                    CreateMGAmmoUI(Commander, this);
                }
            }

            private void FireSideGuns()
            {

            }

            private void ApplyDamage(BaseCombatEntity hitEntity, float damage, Vector3 point, Vector3 normal)
            {
                float single = damage * UnityEngine.Random.Range(0.9f, 1.1f);
                hitEntity.OnAttacked(new HitInfo(this.entity, hitEntity, DamageType.Bullet, single, point));
                if (hitEntity is BasePlayer || hitEntity is BaseNpc)
                {
                    HitInfo hitInfo = new HitInfo()
                    {
                        HitPositionWorld = point,
                        HitNormalWorld = -normal,
                        HitMaterial = StringPool.Get("Flesh")
                    };
                    Effect.server.ImpactEffect(hitInfo);
                }
            }
            #endregion

            #region Movement
            private void DoMovementControls()
            {
                float accelerate = Commander.serverInput.IsDown(BUTTON.FORWARD) ? 1f : Commander.serverInput.IsDown(BUTTON.BACKWARD) ? -1f : 0f;
                float steer = Commander.serverInput.IsDown(BUTTON.RIGHT) ? 1f : Commander.serverInput.IsDown(BUTTON.LEFT) ? -1f : 0f;

                bool boost = Commander.serverInput.IsDown(controlButtons[CommandType.Boost]);

                SetThrottleSpeed(accelerate, steer, boost);
            }

            private void SetThrottleSpeed(float acceleration, float steering, bool boost)
            {
                if (acceleration == 0 && steering == 0)
                {
                    ApplyBrakes(0.5f);

                    if (accelTimeTaken > 0)
                        accelTimeTaken = Mathf.Clamp(accelTimeTaken -= (Time.deltaTime * 2), 0, accelTimeToTake);
                }
                else
                {
                    ApplyBrakes(0f);

                    accelTimeTaken += Time.deltaTime;
                    float engineRpm = Mathf.InverseLerp(0f, accelTimeToTake, accelTimeTaken);

                    float throttle = Mathf.InverseLerp(0f, 1f, engineRpm);

                    float leftTrack = 0;
                    float rightTrack = 0;
                    float torque = 0;

                    if (acceleration > 0)
                    {
                        torque = forwardTorque;
                        leftTrack = 1f;
                        rightTrack = 1f;
                    }
                    else if (acceleration < 0)
                    {
                        torque = forwardTorque;
                        leftTrack = -1f;
                        rightTrack = -1f;
                    }
                    if (steering > 0)
                    {
                        if (acceleration == 0)
                        {
                            torque = turnTorque;
                            leftTrack = 1f;
                            rightTrack = -1f;
                        }
                        else
                        {
                            torque = (forwardTorque + turnTorque) * 0.75f;
                            rightTrack *= 0.5f;
                        }
                    }
                    else if (steering < 0)
                    {
                        if (acceleration == 0)
                        {
                            torque = turnTorque;
                            leftTrack = -1f;
                            rightTrack = 1f;
                        }
                        else
                        {
                            torque = (forwardTorque + turnTorque) * 0.75f;
                            leftTrack *= 0.5f;
                        }
                    }

                    if (boost)
                    {
                        if (torque > 0)
                            torque += configData.Movement.BoostTorque;
                        if (torque < 0)
                            torque -= configData.Movement.BoostTorque;
                    }

                    float sidewaysVelocity = Mathf.InverseLerp(5f, 1.5f, rigidBody.velocity.magnitude * Mathf.Abs(Vector3.Dot(rigidBody.velocity.normalized, entity.transform.forward)));
                    entity.ScaleSidewaysFriction(1f - sidewaysVelocity);

                    ApplyMotorTorque(Mathf.Clamp(leftTrack * throttle, -1f, 1f) * torque, false);
                    ApplyMotorTorque(Mathf.Clamp(rightTrack * throttle, -1f, 1f) * torque, true);
                }
            }

            private void ApplyBrakes(float amount)
            {
                amount = Mathf.Clamp(maxBrakeTorque * amount, 0, maxBrakeTorque);
                ApplyBrakeTorque(amount, true);
                ApplyBrakeTorque(amount, false);
            }

            private void ApplyBrakeTorque(float amount, bool rightSide)
            {
                WheelCollider[] wheelColliderArray = (!rightSide ? leftWheels : rightWheels);

                for (int i = 0; i < wheelColliderArray.Length; i++)
                    wheelColliderArray[i].brakeTorque = maxBrakeTorque * amount;
            }

            private void ApplyMotorTorque(float torque, bool rightSide)
            {
                WheelCollider[] wheelColliderArray = (!rightSide ? leftWheels : rightWheels);

                for (int i = 0; i < wheelColliderArray.Length; i++)
                    wheelColliderArray[i].motorTorque = torque;
            }
            #endregion
            
            private void ToggleLights() => entity.SetFlag(BaseEntity.Flags.Reserved5, !entity.HasFlag(BaseEntity.Flags.Reserved5), false);

            public void ManageDamage(HitInfo info)
            {
                if (isDying)
                    return;

                if (info.damageTypes.Total() >= entity.health)
                {
                    info.damageTypes = new DamageTypeList();
                    info.HitEntity = null;
                    info.HitMaterial = 0;
                    info.PointStart = Vector3.zero;

                    OnDeath();
                }
                else
                {
                    ins.NextTick(() =>
                    {
                        if (Commander != null)
                            CreateHealthUI(Commander, this);

                        for (int i = 1; i < mountables.Length; i++)
                        {
                            BasePlayer player = mountables[i]?.GetMounted();
                            if (player != null)
                                CreateHealthUI(player, this);
                        }
                    });
                }
            }

            private void OnDeath()
            {
                isDying = true;

                DismountAll();

                Effect.server.Run(entity.explosionEffect.resourcePath, entity.transform.position, Vector3.up, null, true);

                List<ServerGib> serverGibs = ServerGib.CreateGibs(entity.servergibs.resourcePath, entity.gameObject, entity.servergibs.Get().GetComponent<ServerGib>()._gibSource, Vector3.zero, 3f);
                for (int i = 0; i < 12 - entity.maxCratesToSpawn; i++)
                {
                    BaseEntity fireBall = GameManager.server.CreateEntity(entity.fireBall.resourcePath, entity.transform.position, entity.transform.rotation, true);
                    if (fireBall)
                    {
                        Vector3 onSphere = UnityEngine.Random.onUnitSphere;
                        fireBall.transform.position = (entity.transform.position + new Vector3(0f, 1.5f, 0f)) + (onSphere * UnityEngine.Random.Range(-4f, 4f));
                        Collider collider = fireBall.GetComponent<Collider>();
                        fireBall.Spawn();
                        fireBall.SetVelocity(Vector3.zero + (onSphere * UnityEngine.Random.Range(3, 10)));
                        foreach (ServerGib serverGib in serverGibs)
                            Physics.IgnoreCollision(collider, serverGib.GetCollider(), true);
                    }
                }

                if (configData.Inventory.DropInv)
                {
                    inventory.Drop("assets/prefabs/misc/item drop/item_drop.prefab", (entity.transform.position + new Vector3(0f, 1.5f, 0f)) + (UnityEngine.Random.onUnitSphere * UnityEngine.Random.Range(2f, 3f)), Quaternion.identity, 0f);
                }

                if (configData.Inventory.DropLoot)
                {
                    for (int j = 0; j < entity.maxCratesToSpawn; j++)
                    {
                        Vector3 onSphere = UnityEngine.Random.onUnitSphere;
                        BaseEntity lootCrate = GameManager.server.CreateEntity(entity.crateToDrop.resourcePath, (entity.transform.position + new Vector3(0f, 1.5f, 0f)) + (onSphere * UnityEngine.Random.Range(2f, 3f)), Quaternion.LookRotation(onSphere), true);
                        lootCrate.Spawn();

                        LootContainer lootContainer = lootCrate as LootContainer;
                        if (lootContainer)
                            lootContainer.Invoke(new Action(lootContainer.RemoveMe), 1800f);

                        Collider collider = lootCrate.GetComponent<Collider>();
                        Rigidbody rigidbody = lootCrate.gameObject.AddComponent<Rigidbody>();
                        rigidbody.useGravity = true;
                        rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
                        rigidbody.mass = 2f;
                        rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
                        rigidbody.velocity = Vector3.zero + (onSphere * UnityEngine.Random.Range(1f, 3f));
                        rigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
                        rigidbody.drag = 0.5f * (rigidbody.mass / 5f);
                        rigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);

                        FireBall fireBall = GameManager.server.CreateEntity(entity.fireBall.resourcePath, lootCrate.transform.position, new Quaternion(), true) as FireBall;
                        if (fireBall)
                        {
                            fireBall.transform.position = lootCrate.transform.position;
                            fireBall.Spawn();
                            fireBall.GetComponent<Rigidbody>().isKinematic = true;
                            fireBall.GetComponent<Collider>().enabled = false;
                            fireBall.transform.parent = lootCrate.transform;
                        }
                        lootCrate.SendMessage("SetLockingEnt", fireBall.gameObject, SendMessageOptions.DontRequireReceiver);

                        foreach (ServerGib serverGib1 in serverGibs)
                            Physics.IgnoreCollision(collider, serverGib1.GetCollider(), true);
                    }
                }
                if (entity != null && !entity.IsDestroyed)
                    entity.Kill(BaseNetworkable.DestroyMode.Gib);
            }
        }
        #endregion

        #region Commands
        [ChatCommand("spawntank")]
        void cmdTank(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "tankcommander.admin")) return;

            Vector3 position = player.eyes.position + (player.eyes.MovementForward() * 5f);

            BaseEntity entity = GameManager.server.CreateEntity(APC_PREFAB, position, Quaternion.Euler(0, player.eyes.rotation.eulerAngles.y - 90f, 0));
            entity.enableSaving = false;
            entity.Spawn();

            controllers.Add(entity.gameObject.AddComponent<APCController>());
        }

        [ConsoleCommand("spawntank")]
        void ccmdSpawnTank(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null || arg.Args == null)
                return;

            if (arg.Args.Length == 1)
            {
                BasePlayer player = covalence.Players.Connected.FirstOrDefault(x => x.Id == arg.GetString(0))?.Object as BasePlayer;
                if (player != null)
                {
                    Vector3 position = player.eyes.position + (player.eyes.MovementForward() * 5f);

                    BaseEntity entity = GameManager.server.CreateEntity(APC_PREFAB, position, Quaternion.Euler(0, player.eyes.rotation.eulerAngles.y - 90f, 0));
                    entity.enableSaving = false;
                    entity.Spawn();

                    controllers.Add(entity.gameObject.AddComponent<APCController>());
                }
                return;
            }
            if (arg.Args.Length == 3)
            {
                float x;
                float y;
                float z;

                if (float.TryParse(arg.GetString(0), out x))
                {
                    if (float.TryParse(arg.GetString(1), out y))
                    {
                        if (float.TryParse(arg.GetString(2), out z))
                        {
                            BaseEntity entity = GameManager.server.CreateEntity(APC_PREFAB, new Vector3(x, y, z));
                            entity.enableSaving = false;
                            entity.Spawn();

                            controllers.Add(entity.gameObject.AddComponent<APCController>());
                            return;
                        }
                    }
                }
                PrintError($"Invalid arguments supplied to spawn a tank at position : (x = {arg.GetString(0)}, y = {arg.GetString(1)}, z = {arg.GetString(2)})");
            }
        }
        #endregion

        #region Friends
        private bool AreFriends(ulong playerId, ulong friendId)
        {
            if (Friends && configData.Passengers.UseFriends)
                return (bool)Friends?.Call("AreFriendsS", playerId.ToString(), friendId.ToString());
            return true;
        }
        private bool IsClanmate(ulong playerId, ulong friendId)
        {
            if (Clans && configData.Passengers.UseClans)
            {
                object playerTag = Clans?.Call("GetClanOf", playerId);
                object friendTag = Clans?.Call("GetClanOf", friendId);
                if (playerTag is string && friendTag is string)
                {
                    if (!string.IsNullOrEmpty((string)playerTag) && !string.IsNullOrEmpty((string)friendTag) && (playerTag == friendTag))
                        return true;
                }
                return false;
            }
            return true;
        }
        #endregion

        #region UI
        #region UI Elements
        public static class UI
        {
            static public CuiElementContainer ElementContainer(string panelName, string color, UI4 dimensions, bool useCursor = false, string parent = "Overlay")
            {
                CuiElementContainer NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax()},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }
            static public void Panel(ref CuiElementContainer container, string panel, string color, UI4 dimensions, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void Label(ref CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text, Font = "droidsansmono.ttf" },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);

            }
            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.Substring(1);
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        public class UI4
        {
            public float xMin, yMin, xMax, yMax;
            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }
            public string GetMin() => $"{xMin} {yMin}";
            public string GetMax() => $"{xMax} {yMax}";
        }
        #endregion

        #region UI Creation
        private static void CreateHealthUI(BasePlayer player, APCController controller)
        {
            if (player == null)
                return;

            CuiElementContainer container = UI.ElementContainer(UI_HEALTH, "0.95 0.95 0.95 0.05", new UI4(0.69f, 0.1f, 0.83f, 0.135f));
            UI.Label(ref container, UI_HEALTH, $"HLTH: ", 12, new UI4(0.03f, 0, 1, 1), TextAnchor.MiddleLeft);
            double percentHealth = System.Convert.ToDouble((float)controller.entity.health / (float)controller.entity.MaxHealth());
            float yMaxHealth = 0.25f + (0.73f * (float)percentHealth);
            UI.Panel(ref container, UI_HEALTH, UI.Color("#ce422b", 0.6f), new UI4(0.25f, 0.1f, yMaxHealth, 0.9f));
            DestroyUI(player, UI_HEALTH);
            CuiHelper.AddUi(player, container);
        }

        private static void CreateMGAmmoUI(BasePlayer player, APCController controller)
        {
            if (player == null)
                return;

            if (configData.Weapons.MG.Enabled && configData.Weapons.MG.RequireAmmo)
            {
                CuiElementContainer container = UI.ElementContainer(UI_AMMO_MG, "0.95 0.95 0.95 0.05", new UI4(0.69f, 0.060f, 0.83f, 0.096f));
                UI.Label(ref container, UI_AMMO_MG, $"MGUN: <color=#ce422b>{controller.inventory.GetAmount(ins.mgId, false)}</color>", 12, new UI4(0.03f, 0, 1, 1), TextAnchor.MiddleLeft);
                DestroyUI(player, UI_AMMO_MG);
                CuiHelper.AddUi(player, container);
            }
        }

        private static void CreateRocketAmmoUI(BasePlayer player, APCController controller)
        {
            if (player == null)
                return;

            if (configData.Weapons.Cannon.Enabled && configData.Weapons.Cannon.RequireAmmo)
            {
                CuiElementContainer container = UI.ElementContainer(UI_AMMO_ROCKET, "0.95 0.95 0.95 0.05", new UI4(0.69f, 0.021f, 0.83f, 0.056f));
                UI.Label(ref container, UI_AMMO_ROCKET, $"CNON: <color=#ce422b>{controller.inventory.GetAmount(ins.rocketId, false)}</color>", 12, new UI4(0.03f, 0, 1, 1), TextAnchor.MiddleLeft);
                DestroyUI(player, UI_AMMO_ROCKET);
                CuiHelper.AddUi(player, container);
            }
        }

        private static void DestroyUI(BasePlayer player, string panel) => CuiHelper.DestroyUi(player, panel);

        private static void DestroyAllUI(BasePlayer player)
        {
            DestroyUI(player, UI_HEALTH);
            DestroyUI(player, UI_AMMO_MG);
            DestroyUI(player, UI_AMMO_ROCKET);
        }
        #endregion
        #endregion

        #region Config
        private static ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Movement Settings")]
            public MovementSettings Movement { get; set; }

            [JsonProperty(PropertyName = "Button Configuration")]
            public ButtonConfiguration Buttons { get; set; }

            [JsonProperty(PropertyName = "Crushable Types")]
            public CrushableTypes Crushables { get; set; }

            [JsonProperty(PropertyName = "Passenger Options")]
            public PassengerOptions Passengers { get; set; }

            [JsonProperty(PropertyName = "Inventory Options")]
            public InventoryOptions Inventory { get; set; }

            [JsonProperty(PropertyName = "Weapon Options")]
            public WeaponOptions Weapons { get; set; }

            public class CrushableTypes
            {
                [JsonProperty(PropertyName = "Can crush buildings")]
                public bool Buildings { get; set; }

                [JsonProperty(PropertyName = "Can crush resources")]
                public bool Resources { get; set; }

                [JsonProperty(PropertyName = "Can crush loot containers")]
                public bool Loot { get; set; }

                [JsonProperty(PropertyName = "Can crush animals")]
                public bool Animals { get; set; }

                [JsonProperty(PropertyName = "Can crush players")]
                public bool Players { get; set; }

                [JsonProperty(PropertyName = "Amount of force required to crush various building grades")]
                public Dictionary<string, float> GradeForce { get; set; }

                [JsonProperty(PropertyName = "Amount of force required to crush external walls")]
                public float WallForce { get; set; }

                [JsonProperty(PropertyName = "Amount of force required to crush resources")]
                public float ResourceForce { get; set; }
            }

            public class ButtonConfiguration
            {
                [JsonProperty(PropertyName = "Enter/Exit vehicle")]
                public string Enter { get; set; }

                [JsonProperty(PropertyName = "Toggle light")]
                public string Lights { get; set; }

                [JsonProperty(PropertyName = "Open inventory")]
                public string Inventory { get; set; }

                [JsonProperty(PropertyName = "Speed boost")]
                public string Boost { get; set; }

                [JsonProperty(PropertyName = "Fire Cannon")]
                public string Cannon { get; set; }

                [JsonProperty(PropertyName = "Fire Coaxial Gun")]
                public string Coax { get; set; }

                [JsonProperty(PropertyName = "Fire MG")]
                public string MG { get; set; }
            }

            public class MovementSettings
            {
                [JsonProperty(PropertyName = "Forward torque (nm)")]
                public float ForwardTorque { get; set; }

                [JsonProperty(PropertyName = "Rotation torque (nm)")]
                public float TurnTorque { get; set; }

                [JsonProperty(PropertyName = "Brake torque (nm)")]
                public float BrakeTorque { get; set; }

                [JsonProperty(PropertyName = "Time to reach maximum acceleration (seconds)")]
                public float Acceleration { get; set; }

                [JsonProperty(PropertyName = "Boost torque (nm)")]
                public float BoostTorque { get; set; }
            }
            public class PassengerOptions
            {
                [JsonProperty(PropertyName = "Allow passengers")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Number of allowed passengers (Max 4)")]
                public int Max { get; set; }

                [JsonProperty(PropertyName = "Require passenger to be a friend (FriendsAPI)")]
                public bool UseFriends { get; set; }

                [JsonProperty(PropertyName = "Require passenger to be a clan mate (Clans)")]
                public bool UseClans { get; set; }
            }

            public class InventoryOptions
            {
                [JsonProperty(PropertyName = "Enable inventory system")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Drop inventory on death")]
                public bool DropInv { get; set; }

                [JsonProperty(PropertyName = "Drop loot on death")]
                public bool DropLoot { get; set; }

                [JsonProperty(PropertyName = "Inventory size (max 36)")]
                public int Size { get; set; }
            }

            public class WeaponOptions
            {
                [JsonProperty(PropertyName = "Cannon")]
                public WeaponSystem Cannon { get; set; }

                [JsonProperty(PropertyName = "Coaxial")]
                public WeaponSystem Coax { get; set; }

                [JsonProperty(PropertyName = "Machine Gun")]
                public WeaponSystem MG { get; set; }

                [JsonProperty(PropertyName = "Enable Crosshair")]
                public bool EnableCrosshair { get; set; }

                [JsonProperty(PropertyName = "Crosshair Color")]
                public SerializedColor CrosshairColor { get; set; }

                [JsonProperty(PropertyName = "Crosshair Size")]
                public int CrosshairSize { get; set; }

                public class SerializedColor
                {
                    public float R { get; set; }
                    public float G { get; set; }
                    public float B { get; set; }
                    public float A { get; set; }

                    private Color _color;
                    private bool _isInit;

                    public SerializedColor(float r, float g, float b, float a)
                    {
                        R = r;
                        G = g;
                        B = b;
                        A = a;
                    }

                    [JsonIgnore]
                    public Color Color
                    {
                        get
                        {
                            if (!_isInit)
                            {
                                _color = new Color(R, G, B, A);
                                _isInit = true;
                            }
                            return _color;
                        }
                    }
                }

                public class WeaponSystem
                {
                    [JsonProperty(PropertyName = "Enable weapon system")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Require ammunition in inventory")]
                    public bool RequireAmmo { get; set; }

                    [JsonProperty(PropertyName = "Ammunition type (item shortname)")]
                    public string Type { get; set; }

                    [JsonProperty(PropertyName = "Fire rate (seconds)")]
                    public float Interval { get; set; }

                    [JsonProperty(PropertyName = "Aim cone (smaller number is more accurate)")]
                    public float Accuracy { get; set; }

                    [JsonProperty(PropertyName = "Damage")]
                    public float Damage { get; set; }
                }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Buttons = new ConfigData.ButtonConfiguration
                {
                    Enter = "USE",
                    Lights = "RELOAD",
                    Inventory = "RELOAD",
                    Boost = "SPRINT",
                    Cannon = "FIRE_PRIMARY",
                    Coax = "FIRE_SECONDARY",
                    MG = "FIRE_THIRD"
                },
                Crushables = new ConfigData.CrushableTypes
                {
                    Animals = true,
                    Buildings = true,
                    Loot = true,
                    Players = true,
                    Resources = true,
                    GradeForce = new Dictionary<string, float>
                    {
                        [BuildingGrade.Enum.Twigs.ToString()] = 1000f,
                        [BuildingGrade.Enum.Wood.ToString()] = 2000f,
                        [BuildingGrade.Enum.Stone.ToString()] = 3000f,
                        [BuildingGrade.Enum.Metal.ToString()] = 5000f,
                        [BuildingGrade.Enum.TopTier.ToString()] = 7000f,
                    },
                    ResourceForce = 1500f,
                    WallForce = 3000f
                },
                Movement = new ConfigData.MovementSettings
                {
                    Acceleration = 3f,
                    BrakeTorque = 50f,
                    ForwardTorque = 1500f,
                    TurnTorque = 1800f,
                    BoostTorque = 300f
                },
                Passengers = new ConfigData.PassengerOptions
                {
                    Enabled = true,
                    Max = 4,
                    UseClans = true,
                    UseFriends = true
                },
                Inventory = new ConfigData.InventoryOptions
                {
                    Enabled = true,
                    Size = 36,
                    DropInv = true,
                    DropLoot = false
                },
                Weapons = new ConfigData.WeaponOptions
                {
                    EnableCrosshair = true,
                    CrosshairColor = new ConfigData.WeaponOptions.SerializedColor(0.75f, 0.75f, 0.75f, 0.75f),
                    CrosshairSize = 40,
                    Cannon = new ConfigData.WeaponOptions.WeaponSystem
                    {
                        Accuracy = 0.025f,
                        Damage = 90f,
                        Enabled = true,
                        Interval = 1.75f,
                        RequireAmmo = false,
                        Type = "ammo.rocket.hv"
                    },
                    Coax = new ConfigData.WeaponOptions.WeaponSystem
                    {
                        Accuracy = 0.75f,
                        Damage = 10f,
                        Enabled = true,
                        Interval = 0.06667f,
                        RequireAmmo = false,
                        Type = "ammo.rifle.hv"
                    },
                    MG = new ConfigData.WeaponOptions.WeaponSystem
                    {
                        Accuracy = 1.25f,
                        Damage = 10f,
                        Enabled = true,
                        Interval = 0.1f,
                        RequireAmmo = false,
                        Type = "ammo.rifle.hv"
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(0, 2, 0))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(0, 2, 2))
            {
                configData.Weapons.EnableCrosshair = true;
                configData.Weapons.CrosshairColor = new ConfigData.WeaponOptions.SerializedColor(0.75f, 0.75f, 0.75f, 0.75f);
                configData.Weapons.CrosshairSize = 40;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Localization
        private static string msg(string key, string playerId = null) => ins.lang.GetMessage(key, ins, playerId);

        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["in_use"] = "<color=#D3D3D3>This tank is already in use</color>",
            ["not_friend"] = "<color=#D3D3D3>You must be a friend or clanmate with the operator</color>",
            ["passenger_enter"] = "<color=#D3D3D3>You have entered the tank as a passenger</color>",
            ["controls"] = "<color=#ce422b>Tank Controls:</color>",
            ["fire_cannon"] = "<color=#D3D3D3>Fire Cannon </color><color=#ce422b>{0}</color>",
            ["fire_coax"] = "<color=#D3D3D3>Fire Coaxial Gun </color><color=#ce422b>{0}</color>",
            ["fire_mg"] = "<color=#D3D3D3>Fire MG </color><color=#ce422b>{0}</color>",
            ["speed_boost"] = "<color=#D3D3D3>Speed Boost </color><color=#ce422b>{0}</color>",
            ["enter_exit"] = "<color=#D3D3D3>Enter/Exit Vehicle </color><color=#ce422b>{0}</color>",
            ["toggle_lights"] = "<color=#D3D3D3>Toggle Lights </color><color=#ce422b>{0}</color>",
            ["access_inventory"] = "<color=#D3D3D3>Access Inventory (from outside of the vehicle) </color><color=#ce422b>{0}</color>",
            ["no_ammo_cannon"] = "<color=#D3D3D3>You do not have ammunition to fire the cannon. It requires </color><color=#ce422b>{0}</color>",
            ["no_ammo_mg"] = "<color=#D3D3D3>You do not have ammunition to fire the machine gun. It requires </color><color=#ce422b>{0}</color>",
            ["no_ammo_coax"] = "<color=#D3D3D3>You do not have ammunition to fire the coaxial gun. It requires </color><color=#ce422b>{0}</color>",
        };
        #endregion
    }
}

// --- End of file: TankCommander.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/telegram-bot-api ---
// --- Original File Path: T/TelegramBotAPI/TelegramBotAPI.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Telegram Bot API", "NoxiousPluK", "0.1.2")]
    [Description("Send messages using the Telegram Bot API")]
    public class TelegramBotAPI : CovalencePlugin
    {
        #region Configuration
        private Configuration config;

        private class Configuration
        {
            [JsonProperty("Telegram Bot API Key")]
            public string TelegramBotAPIKey = "id:key";

            [JsonProperty("Default ID for messages")]
            public long DefaultID = -12345;

            [JsonProperty("ID for error messages")]
            public long ErrorID = -12345;

            [JsonProperty("Try sending error messages to Telegram")]
            public bool SendErrors = true;

            [JsonProperty("Announce plugin (re)load to Telegram")]
            public bool AnnounceLoad = false;

            public string ToJson() => JsonConvert.SerializeObject(this);
            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }
        #endregion Configuration

        void OnServerInitialized(bool initial)
        {
            if (config.AnnounceLoad)
            {
                if (initial)
                {
                    SendTelegramMessage($"ℹ Plugin loaded: *Telegram Bot API*");
                }
                else
                {
                    SendTelegramMessage($"ℹ Plugin reloaded: *Telegram Bot API*");
                }
            }
        }

        private void SendTelegramMessage(string message, long chatID = 0, bool escape = false, string parseMode = "Markdown")
        {
            if (config.TelegramBotAPIKey == "id:key")
            {
                LogWarning("Telegram Bot API plug-in not configured.");
                return;
            }

            if (escape)
                message = Escape(message);

            if (chatID == 0)
                chatID = config.DefaultID;

            string url = $"https://api.telegram.org/bot{config.TelegramBotAPIKey}/sendMessage?chat_id={chatID}&text={message}&parse_mode={parseMode}&disable_web_page_preview=true";
            webrequest.Enqueue(url, null, (code, response) =>
            {
                if (code != 200 || response == null)
                {
                    LogWarning($"Telegram bot error ({code}): {response} on request {url}");
                    if (config.SendErrors)
                        SendTelegramError($"Telegram error: {code}\r\n\r\nResponse: {Escape(response)}\r\n\r\nRequest: {Escape(url)}");
                    return;
                }
            }, this);
        }

        private string Escape(string Input)
        {
            StringBuilder input = new StringBuilder(Input);
            input.Replace("_", "\\_");
            input.Replace("*", "\\*");
            input.Replace("`", "\\`");
            input.Replace("[", "\\[");
            input.Replace("&", "%26");
            input.Replace("?", "%3F");
            input.Replace("#", "%23");
            return input.ToString();
        }

        private void SendTelegramError(string message)
        {
            string url = $"https://api.telegram.org/bot{config.TelegramBotAPIKey}/sendMessage?chat_id={config.ErrorID}&text={message}&parse_mode=Markdown&disable_web_page_preview=true";
            webrequest.Enqueue(url, null, (code, response) =>
            {
                if (code != 200 || response == null)
                {
                    LogWarning($"Telegram bot error ({code}): {response} on request {url}");
                    return;
                }
            }, this);
        }
    }
}


// --- End of file: TelegramBotAPI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/team-manager ---
// --- Original File Path: T/TeamManager/TeamManager.cs ---

﻿using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch.Extend;
using Oxide.Core;
using UnityEngine;
using UnityEngine.UI;

namespace Oxide.Plugins
{
    [Info("Team Manager", "Quantum", "1.0.6")]
    [Description("Manage teams from commands")]

    class TeamManager : RustPlugin
    {
        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SyntaxError"] = "Syntax Error!",
                ["PlayerNotFound"] = "Player not found!",
                ["MultiplePlayersFound"] = "Multiple players found",
                ["TeamsDisabled"] = "Teams are disabled on this server!",
                ["NotInTeam"] = "You are not in a team!",
                ["CannotPromoteYourself"] = "You cannot promote yourself!",
                ["CannotInviteYourself"] = "You cannot invite yourself!",
                ["NotTeamLeader"] = "You are not the team leader!",
                ["NotInYourTeam"] = "does not seem to be in your team!",
                ["Promoted"] = "Promoted",
                ["AlreadyInTeam"] = "You're already in a team!",
                ["Invited"] = "Invited"
            }, this);
        }
        #endregion Localization

        #region Commands
        [ChatCommand("team")]
        void Team(BasePlayer player, string command, string[] args)
        {
            string msgSyntaxError = lang.GetMessage("SyntaxError", this, player.UserIDString); // Used more than once

            if (args.Length < 1)
            {
                player.ChatMessage(msgSyntaxError);
                return;
            }

            if (RelationshipManager.maxTeamSize == 0)
            {
                player.ChatMessage(lang.GetMessage("TeamsDisabled", this, player.UserIDString));
            }
            else
            {
                switch (args[0].ToLower())
                {
                    case "invite":
                        {
                            if (args.Length <= 1)
                            {
                                player.ChatMessage(msgSyntaxError);
                                return;
                            }
                            Invite(player, args[1]);
                            break;
                        }
                    case "promote":
                        {
                            if (args.Length <= 1)
                            {
                                player.ChatMessage(msgSyntaxError);
                                return;
                            }

                            Promote(player, args[1]);
                            break;
                        }
                    case "create":
                        {
                            CreateTeam(player);
                            break;
                        }
                    case "remove":
                        {
                            Remove(player, args[1]);
                            break;
                        }
                    default:
                        {
                            player.ChatMessage(msgSyntaxError);
                            break;
                        }
                }
            }
        }
        #endregion Commands

        #region Promote
        void Promote(BasePlayer player, string targetPlayer)
        {
            string msgPlayerNotFound = lang.GetMessage("PlayerNotFound", this, player.UserIDString); // Used more than once

            // Check if player is in team
            if (player.currentTeam == 0UL)
            {
                player.ChatMessage(lang.GetMessage("NotInTeam", this, player.UserIDString));
                return;
            }

            RelationshipManager.PlayerTeam aTeam = RelationshipManager.ServerInstance.teams[player.currentTeam];

            var aTarget = FindPlayersOnline(targetPlayer);

            // Check if player exists
            if (aTarget.Count <= 0)
            {
                player.ChatMessage(msgPlayerNotFound);
                return;
            }
            // Found multiple players
            if (aTarget.Count > 1)
            {
                player.ChatMessage(string.Format("{0}: {1}",
                                   lang.GetMessage("MultiplePlayersFound", this, player.UserIDString),
                                   string.Join(", ", aTarget.ConvertAll(p => p.displayName).ToArray())));
                return;
            }

            var theTarget = aTarget[0];

            // Null Check
            if (theTarget == null)
            {
                player.ChatMessage(msgPlayerNotFound);
                return;
            }
            // Check if target is player
            if (theTarget == player)
            {
                player.ChatMessage(lang.GetMessage("CannotPromoteYourself", this, player.UserIDString));
                return;
            }
            // Check if team leader
            if (aTeam.teamLeader != player.userID)
            {
                player.ChatMessage(lang.GetMessage("NotTeamLeader", this, player.UserIDString));
                return;
            }
            // Check if target is in player's team
            if (aTeam.teamID != theTarget.currentTeam)
            {
                player.ChatMessage(string.Format("{0} {1}",
                                   aTarget[0].displayName,
                                   lang.GetMessage("NotInYourTeam", this, player.UserIDString)));
                return;
            }
            // Promote target if all checks pass
            aTeam.SetTeamLeader(theTarget.userID);
            player.ChatMessage(string.Format("{0}: {1}",
                                             lang.GetMessage("Promoted", this, player.UserIDString),
                                             theTarget.displayName));
        }
        #endregion Promote

        #region RemovePlayer
        void Remove(BasePlayer player, string targetPlayer)
        {
            string msgPlayerNotFound = lang.GetMessage("PlayerNotFound", this, player.UserIDString); // Used more than once

            // Check if player is in team
            if (player.currentTeam == 0UL)
            {
                player.ChatMessage(lang.GetMessage("NotInTeam", this, player.UserIDString));
                return;
            }

            RelationshipManager.PlayerTeam aTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
            var aTarget = FindPlayersOnline(targetPlayer);

            // Check if player exists
            if (aTarget.Count <= 0)
            {
                player.ChatMessage(msgPlayerNotFound);
                return;
            }
            // Found Multiple players
            if (aTarget.Count > 1)
            {
                player.ChatMessage(string.Format("{0}: {1}",
                                   lang.GetMessage("MultiplePlayersFound", this, player.UserIDString),
                                   string.Join(", ", aTarget.ConvertAll(p => p.displayName).ToArray())));
                return;
            }

            var theTarget = aTarget[0];

            // Null Check
            if (theTarget == null)
            {
                player.ChatMessage(msgPlayerNotFound);
                return;
            }
            // Check if team leader
            if (aTeam.teamLeader != player.userID)
            {
                player.ChatMessage(lang.GetMessage("NotTeamLeader", this, player.UserIDString));
                return;
            }

            // Remove if all checks pass
            aTeam.RemovePlayer(theTarget.userID);
            player.ChatMessage(string.Format("{0}: {1}",
                                             lang.GetMessage("Removed", this, player.UserIDString),
                                             theTarget.displayName));
        }
        #endregion RemovePlayer

        #region Invite
        void Invite(BasePlayer player, string targetPlayer)
        {
            string msgPlayerNotFound = lang.GetMessage("PlayerNotFound", this, player.UserIDString); // Used more than once

            // Check if player is in team
            if (player.currentTeam == 0UL)
            {
                player.ChatMessage(lang.GetMessage("NotInTeam", this, player.UserIDString));
                return;
            }

            RelationshipManager.PlayerTeam aTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
            var aTarget = FindPlayersOnline(targetPlayer);

            // Check if player exists
            if (aTarget.Count <= 0)
            {
                player.ChatMessage(msgPlayerNotFound);
                return;
            }
            // Found Multiple players
            if (aTarget.Count > 1)
            {
                player.ChatMessage(string.Format("{0}: {1}",
                                   lang.GetMessage("MultiplePlayersFound", this, player.UserIDString),
                                   string.Join(", ", aTarget.ConvertAll(p => p.displayName).ToArray())));
                return;
            }

            var theTarget = aTarget[0];

            // Null Check
            if (theTarget == null)
            {
                player.ChatMessage(msgPlayerNotFound);
                return;
            }
            // Check if team leader
            if (aTeam.teamLeader != player.userID)
            {
                player.ChatMessage(lang.GetMessage("NotTeamLeader", this, player.UserIDString));
                return;
            }
            // Check it target is player
            if (theTarget == player)
            {
                player.ChatMessage(lang.GetMessage("CannotInviteYourself", this, player.UserIDString));
                return;
            }

            // Invite if all checks pass
            aTeam.SendInvite(theTarget);
            player.ChatMessage(string.Format("{0}: {1}",
                                             lang.GetMessage("Invited", this, player.UserIDString),
                                             theTarget.displayName));
        }
        #endregion Invite

        #region CreateTeam
        void CreateTeam(BasePlayer player)
        {
            if (player.currentTeam != 0UL)
            {
                player.ChatMessage(lang.GetMessage("AlreadyInTeam", this, player.UserIDString));
                return;
            }

            RelationshipManager.PlayerTeam aTeam = RelationshipManager.ServerInstance.CreateTeam();
            aTeam.teamLeader = player.userID;
            aTeam.AddPlayer(player);
        }
        #endregion CreateTeam

        #region Misc
        private static List<BasePlayer> FindPlayersOnline(string nameOrIdOrIp)
        {
            var players = new List<BasePlayer>();
            if (string.IsNullOrEmpty(nameOrIdOrIp)) return players;
            foreach (var activePlayer in BasePlayer.activePlayerList.ToList())
            {
                if (activePlayer.UserIDString.Equals(nameOrIdOrIp))
                    players.Add(activePlayer);
                else if (!string.IsNullOrEmpty(activePlayer.displayName) && activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.IgnoreCase))
                    players.Add(activePlayer);
                else if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress.Equals(nameOrIdOrIp))
                    players.Add(activePlayer);
            }
            return players;
        }
        #endregion Misc
    }
}


// --- End of file: TeamManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/timed-workbench-unlock ---
// --- Original File Path: T/TimedWorkbenchUnlock/TimedWorkbenchUnlock.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace Oxide.Plugins
{
  [Info("Timed Workbench Unlock", "HunterZ", "2.3.0")]
  [Description("Provides timed/manual/disabled unlocking of workbenches")]
  class TimedWorkbenchUnlock : RustPlugin
  {
    #region Vars

    // ordered list of workbench IDs
    private static readonly int[] _WORKBENCH_ID = {
      1524187186, -41896755, -1607980696
    };

    // periodic global status broadcast timer
    private Timer _broadcastTimer;

    // data managed via config file
    private ConfigData _configData;

    // "can't craft" warning suppression timers by userID
    private readonly Dictionary<ulong, Timer> _craftWarned = new();

    // string builder for producing status messages
    private readonly StringBuilder _statusBuilder = new();

    // workbench unlock announcement broadcast timers
    private readonly Timer[] _unlockTimers = { null, null, null };

    #region Permission Strings

    private const string PERMISSION_ADMIN = "admin";
    private const string PERMISSION_BROADCAST = "broadcast";
    private const string PERMISSION_INFO = "info";
    private const string PERMISSION_MODIFY = "modify";
    private const string PERMISSION_RELOAD = "reload";
    private const string PERMISSION_RESET = "reset";
    private const string PERMISSION_SKIPLOCK = "skiplock";
    private const string PERMISSION_WIPE = "wipe";

    #endregion Permission Strings

    #endregion Vars

    #region Utilities

    // get time since wipe in seconds
    // if positive optional parameter is specified, it is used as a passthrough
    private double GetWipeElapsedSeconds(double wipeElapsedSeconds = -1.0)
    {
      if (null == _configData) return 0;
      return wipeElapsedSeconds > 0 ? wipeElapsedSeconds :
        (DateTime.UtcNow - _configData.LastWipeUTC).TotalSeconds;
    }

    // returns unlock status for given workbench index (0-2 => level 1-3)
    // -1 => locked forever (requires manual unlock)
    //  0 => unlocked
    // >0 => number of seconds until auto unlock
    //
    // wipe elapsed seconds can optionally be specified to avoid repeated
    //  lookups when calling from a loop
    private int GetUnlockStatus(int index, double wipeElapsedSeconds = -1.0)
    {
      if (null == _configData || index < 0 || index > 2) return 0;
      wipeElapsedSeconds = GetWipeElapsedSeconds(wipeElapsedSeconds);
      double unlockDelaySeconds = _configData.WBConfig[index];

      // check for permanent lock
      if (unlockDelaySeconds < 0.0) return -1;

      // determine auto unlock status
      if (unlockDelaySeconds > 0.0)
      {
        double unlockSecondsRemaining = unlockDelaySeconds - wipeElapsedSeconds;
        return unlockSecondsRemaining > 0 ?
          (int)Math.Ceiling(unlockSecondsRemaining) : 0;
      }

      // unlockDelaySeconds == 0.0 => always unlocked
      return 0;
    }

    // returns an array of unlock times for workbenches
    // see GetUnlockTime() for value meanings
    private int[] GetUnlockStatus()
    {
      double wipeElapsedSeconds = GetWipeElapsedSeconds();
      // unrolled loop for simplicity
      return new[]
      {
        GetUnlockStatus(0, wipeElapsedSeconds),
        GetUnlockStatus(1, wipeElapsedSeconds),
        GetUnlockStatus(2, wipeElapsedSeconds)
      };
    }

    // create a timer that will fire when the given workbench should unlock, or
    //  null if manually locked or already unlocked
    private Timer GetTimer(int index, double wipeElapsedSeconds = -1.0)
    {
      if (index < 0 || index > 2) { return null; }

      wipeElapsedSeconds = GetWipeElapsedSeconds(wipeElapsedSeconds);
      var status = GetUnlockStatus(index, wipeElapsedSeconds);

      if (status > 0) return timer.Once(status, () => { ReportUnlock(index); });

      return null;
    }

    // destroy existing broadcast timer (if any)
    private void DestroyBroadcastTimer()
    {
      if (null == _broadcastTimer) return;
      _broadcastTimer.Destroy();
      _broadcastTimer = null;
    }

    // (re)set broadcast timer to fire at configured interval
    private void SetBroadcastTimer()
    {
      DestroyBroadcastTimer();
      // only set new timer if config value is positive (i.e. broadcast period
      //  in seconds)
      var broadcastConfig = _configData?.BroadcastConfig ?? 0;
      if (broadcastConfig > 0)
      {
        _broadcastTimer =
          timer.Every(broadcastConfig, () => { ReportStatus(null); });
      }
    }

    // destroy all existing timers managed by unlockTimers
    private void DestroyUnlockTimers()
    {
      for (int i = 0; i < _unlockTimers.Length; ++i)
      {
        var unlockTimer = _unlockTimers[i];
        if (null == unlockTimer || unlockTimer.Destroyed) continue;
        unlockTimer.Destroy();
        _unlockTimers[i] = null;
      }
    }

    // (re)set all unlock announcement timers as appropriate
    // this should be called whenever unlock times might have changed
    private void SetUnlockTimers()
    {
      // timers don't auto-destruct, so wipe them to avoid double-firing
      DestroyUnlockTimers();
      var wipeElapsedSeconds = GetWipeElapsedSeconds();
      for (int i = 0; i < _unlockTimers.Length; ++i)
      {
        _unlockTimers[i] = GetTimer(i, wipeElapsedSeconds);
      }
    }

    private void DestroyWarnTimer(ulong userId)
    {
      if (_craftWarned.Remove(userId, out var wTimer) &&
          false == wTimer?.Destroyed)
      {
        wTimer.Destroy();
      }
    }

    // generate color locked/unlocked status text for twinfo command
    private string UnlockStatusString(int status, IPlayer player) =>
      status == 0 ?
        Colorize(lang.GetMessage("Unlocked", this, player.Id), "green") :
        Colorize(lang.GetMessage("Locked", this, player.Id), "red");

    // return true if player is null, server, or admin, or has permission, else
    //  reply with "no permission" message and return false
    private bool HasPermission(IPlayer player, string perm)
    {
      if (null == player) return false;

      var hasPermission =
        player.IsServer ||
        player.HasPermission(PrefixPermission(PERMISSION_ADMIN)) ||
        player.HasPermission(PrefixPermission(perm));

      if (!hasPermission) SendMessage(player, "NoPermission");

      return hasPermission;
    }

    // return a prefixed version of the given permission string
    // this is done to avoid hard-coding it, which would be a maintenance issue
    private string PrefixPermission(string perm) => Name.ToLower() + "." + perm;

    // report user-friendly detailed status
    private void ReportStatus(IPlayer player)
    {
      // don't report status if nobody is online
      if (null == player && BasePlayer.activePlayerList.IsNullOrEmpty()) return;

      var status = GetUnlockStatus();
      // don't report status if everything is unlocked
      if (0 == status[0] && 0 == status[1] && 0 == status[2]) return;

      _statusBuilder.Clear();
      _statusBuilder.AppendLine(FormatMessage(player, "StatusBanner"));
      for (int index = 0; index < 3; ++index)
      {
        string wbNumStr = (index + 1).ToString(CultureInfo.CurrentCulture);
        switch (status[index])
        {
          case < 0:
          {
            _statusBuilder.AppendLine(
              FormatMessage(player, "StatusManual", wbNumStr));
          }
          break;

          case 0:
          {
            _statusBuilder.AppendLine(
              FormatMessage(player, "StatusUnlocked", wbNumStr));
          }
          break;

          case > 0:
          {
            _statusBuilder.AppendLine(FormatMessage(
              player, "StatusTime", wbNumStr,
              TimeSpan.FromSeconds(status[index]).ToString(
                "g", CultureInfo.CurrentCulture)));
          }
          break;
        }
      }

      SendRawMessage(player, _statusBuilder.ToString());
    }

    // report that a workbench has unlocked
    private void ReportUnlock(int index)
    {
      if (index < 0 || index > 2) return;
      // don't report unlock if nobody is online
      if (BasePlayer.activePlayerList.IsNullOrEmpty()) return;
      SendMessage(
        null, "UnlockNotice", (index + 1).ToString(CultureInfo.CurrentCulture));
    }

    // return whether crafting of the given item ID should be allowed
    private bool AllowCraftAttempt(BasePlayer player, int itemid)
    {
      // do nothing if any of the following are true:
      // - player reference invalid
      // - player in Tutorial Island
      // - player crafting something other than a workbench
      // - player has skiplock permission (note: admins not exempt by default)
      if (null == player ||
          player.IsInTutorial ||
          !_WORKBENCH_ID.Contains(itemid) ||
          player.IPlayer.HasPermission(PrefixPermission(PERMISSION_SKIPLOCK)))
      {
        return true;
      }

      // get status
      var wbIndex = Array.IndexOf(_WORKBENCH_ID, itemid);
      var status = GetUnlockStatus(wbIndex);

      // do nothing if workbench is unlocked
      if (0 == status) return true;

      // warn player
      if (_configData.ReportAsSound) WarnSound(player);

      // abort here if text reports disabled, to avoid building time string
      if (status > 0 && !_configData.ReportAsChat && !_configData.ReportAsToast)
      {
        return false;
      }

      var timeString = status > 0 ?
        TimeSpan.FromSeconds(status).ToString("g", CultureInfo.CurrentCulture) :
        null;

      if (_configData.ReportAsChat)
      {
        WarnChat(player, timeString);
      }

      if (_configData.ReportAsToast)
      {
        WarnToast(player, timeString);
      }

      // block crafting
      return false;
    }

    private void WarnChat(BasePlayer player, string timeString = null)
    {
      // abort if chat spam suppression timer active for player
      var userId = player.userID.Get();
      if (_craftWarned.ContainsKey(userId)) return;

      SendMessage(
        player.IPlayer,
        null == timeString ? "CannotCraftManual" : "CannotCraft",
        timeString);

      // set chat spam suppression timer
      _craftWarned.Add(userId, timer.Once(5.0f, () =>
      {
        DestroyWarnTimer(userId);
      }));
    }

    private static void WarnSound(BasePlayer player)
    {
      Effect.server.Run(
        "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab",
        player.transform.position);
    }

    private void WarnToast(BasePlayer player, string timeString = null)
    {
      SendToast(
        player.IPlayer,
        null == timeString ? "CannotCraftManual" : "CannotCraft",
        timeString);
    }

    #endregion Utilities

    #region Messaging

    // load default message text dictionary
    protected override void LoadDefaultMessages()
    {
      lang.RegisterMessages(new Dictionary<string, string>
      {
        ["BroadcastDisabled"] = "Status broadcast disabled",
        ["BroadcastSet"] = "Status broadcast period set to {0} second(s)",
        ["CannotCraft"] = "Cannot craft this item (unlocks in {0})",
        ["CannotCraftManual"] = "Cannot craft this item (unlocks manually/never)",
        ["InfoBanner"] = "Now @{0} / T1 {1} (@{2}/{3}) / T2 {4} (@{5}/{6}) / T3 {7} (@{8}/{9})",
        ["InvalidWorkbench"] = "Invalid workbench number specified!",
        ["Locked"] = "locked",
        ["ModifiedManual"] = "WB {0} is now always locked",
        ["ModifiedTime"] = "WB {0} now unlocks in {1} second(s) after wipe",
        ["ModifiedUnlocked"] = "WB {0} is now always unlocked",
        ["NoPermission"] = "You don't have permission to use this command",
        ["PluginWipe"] = "Wipe time reset to {0}",
        ["ReloadConfig"] = "Config has been reloaded",
        ["ResetConfig"] = "Config has been reset",
        ["StatusBanner"] = "Workbenches are currently on a timed unlock system. Current status:",
        ["StatusManual"] = "- Workbench Level {0}: Unlocks manually/never",
        ["StatusTime"] = "- Workbench Level {0}: Unlocks in {1}",
        ["StatusUnlocked"] = "- Workbench Level {0}: Unlocked!",
        ["SyntaxError"] = "Syntax Error!",
        ["Unlocked"] = "unlocked",
        ["UnlockNotice"] = "Workbench Level {0} has unlocked, and can now be crafted!"
      }, this);
    }

    // format a message based on language dictionary, arguments, and destination
    private string FormatMessage(
      IPlayer player, string langCode, params string[] args)
    {
      var playerId = null == player || player.IsServer ? null : player.Id;
      var msg = string.Format(lang.GetMessage(langCode, this, playerId), args);
      // strip color markings out of console messages
      if (null == playerId)
        // note: cannot supply StringComparison enum value here, as it results
        //  in a "not implemented" exception in some cases
        msg = msg
          .Replace("<color=red>", string.Empty)
          .Replace("<color=green>", string.Empty)
          .Replace("</color>", string.Empty);
      return msg;
    }

    // send a message to player or server without additional formatting
    private void SendRawMessage(IPlayer player, string message)
    {
      if (null == player)
      {
        Server.Broadcast(message);
      }
      else
      {
        player.Reply(message);
      }
    }

    // send a message to player or server based on language dictionary and
    //  arguments
    // this is the primary method that should be used to communicate to users
    private void SendMessage(
      IPlayer player, string langCode, params string[] args)
    {
      SendRawMessage(player, FormatMessage(player, langCode, args));
    }

    private void SendToast(
      IPlayer player, string langCode, params string[] args)
    {
      var basePlayer = player.Object as BasePlayer;
      if (null == basePlayer) return;
      basePlayer.ShowToast(0, FormatMessage(player, langCode, args));
    }

    // decorate a string with color codes
    // note that only red or green should be used, as FormatMessage() only
    //  strips those
    private static string Colorize(string str, string color) =>
      "<color=" + color + ">" + str + "</color>";

    #endregion Messaging

    #region Hooks

    // called by Oxide after config load
    protected void Init()
    {
      SetBroadcastTimer();
      SetUnlockTimers();

      // Permissions
      permission.RegisterPermission(
        PrefixPermission(PERMISSION_ADMIN), this);
      permission.RegisterPermission(
        PrefixPermission(PERMISSION_BROADCAST), this);
      permission.RegisterPermission(
        PrefixPermission(PERMISSION_INFO), this);
      permission.RegisterPermission(
        PrefixPermission(PERMISSION_MODIFY), this);
      permission.RegisterPermission(
        PrefixPermission(PERMISSION_RELOAD), this);
      permission.RegisterPermission(
        PrefixPermission(PERMISSION_RESET), this);
      permission.RegisterPermission(
        PrefixPermission(PERMISSION_SKIPLOCK), this);
      permission.RegisterPermission(
        PrefixPermission(PERMISSION_WIPE), this);

      AddCovalenceCommand("twbroadcast", nameof(CommandBroadcast));
      AddCovalenceCommand("twinfo", nameof(CommandInfo));
      AddCovalenceCommand("twmodify", nameof(CommandModify));
      AddCovalenceCommand("twreload", nameof(CommandReload));
      AddCovalenceCommand("twreset", nameof(CommandReset));
      AddCovalenceCommand("twwipe", nameof(CommandWipe));
    }

    // called by Oxide on plugin unload
    protected void Unload()
    {
      // clean up any timers
      DestroyBroadcastTimer();
      DestroyUnlockTimers();
      foreach (var (_, warnTimer) in _craftWarned)
      {
        if (null == warnTimer || warnTimer.Destroyed) continue;
        warnTimer.Destroy();
      }
      _craftWarned.Clear();
    }

    private object CanCraft(
      PlayerBlueprints playerBlueprints, ItemDefinition itemDefinition) =>
      !_configData.BlockCraft || AllowCraftAttempt(
        playerBlueprints.baseEntity, itemDefinition.itemid) ? null : false;

    private object CanResearchItem(BasePlayer player, Item item) =>
      !_configData.BlockResearch || AllowCraftAttempt(
        player, item.info.itemid) ? null : false;

    private void OnPlayerConnected(BasePlayer player) =>
      ReportStatus(player.IPlayer);

    private void OnPlayerDisconnected(BasePlayer player, string reason)
    {
      DestroyWarnTimer(player.userID.Get());
    }

    #endregion Hooks

    #region Commands

    private void CommandBroadcast(IPlayer player, string command, string[] args)
    {
      if (null == _configData || !HasPermission(player, PERMISSION_BROADCAST))
      {
        return;
      }

      if (args.Length < 1)
      {
        player.Reply(string.Format(
          lang.GetMessage("SyntaxError", this, player.Id), command));
        return;
      }

      _configData.BroadcastConfig = Convert.ToInt32(args[0]);
      if (_configData.BroadcastConfig < 0) _configData.BroadcastConfig = 0;
      SaveConfig();
      SetBroadcastTimer();

      if (_configData.BroadcastConfig > 0)
      {
        SendMessage(
          player, "BroadcastSet", _configData.BroadcastConfig.ToString());
      }
      else
      {
        SendMessage(player, "BroadcastDisabled");
      }
    }

    private void CommandInfo(IPlayer player)
    {
      if (null == _configData || !HasPermission(player, PERMISSION_INFO))
      {
        return;
      }

      var status = GetUnlockStatus();

      SendMessage(player, "InfoBanner",
        GetWipeElapsedSeconds().ToString(CultureInfo.CurrentCulture),
        UnlockStatusString(status[0], player),
        status[0].ToString(CultureInfo.CurrentCulture),
        _configData.WBConfig[0].ToString(CultureInfo.CurrentCulture),
        UnlockStatusString(status[1], player),
        status[1].ToString(CultureInfo.CurrentCulture),
        _configData.WBConfig[1].ToString(CultureInfo.CurrentCulture),
        UnlockStatusString(status[2], player),
        status[2].ToString(CultureInfo.CurrentCulture),
        _configData.WBConfig[2].ToString(CultureInfo.CurrentCulture)
      );
    }

    private void CommandModify(IPlayer player, string command, string[] args)
    {
      if (null == _configData || !HasPermission(player, PERMISSION_MODIFY))
      {
        return;
      }

      if (args.Length < 2)
      {
        player.Reply(string.Format(
          lang.GetMessage("SyntaxError", this, player.Id), command));
        return;
      }

      var wbIndex = Convert.ToInt32(args[0]) - 1;
      if (wbIndex < 0 || wbIndex > 2)
      {
        player.Reply(string.Format(
          lang.GetMessage("InvalidWorkbench", this, player.Id), command));
        return;
      }

      var wbConfig = Convert.ToInt32(args[1]);
      if (wbConfig < -1) wbConfig = -1;
      _configData.WBConfig[wbIndex] = wbConfig;
      SaveConfig();
      SetUnlockTimers();

      if (wbConfig < 0)
      {
        SendMessage(player, "ModifiedManual", args[0]);
      }
      else if (wbConfig > 0)
      {
        SendMessage(player, "ModifiedTime", args[0], wbConfig.ToString(
          CultureInfo.CurrentCulture));
      }
      else
      {
        SendMessage(player, "ModifiedUnlocked", args[0]);
      }
    }

    private void CommandReload(IPlayer player)
    {
      if (!HasPermission(player, PERMISSION_RELOAD)) return;

      LoadConfig();
      SetBroadcastTimer();
      SetUnlockTimers();
      SendMessage(player, "ReloadConfig");
      CommandInfo(player);
    }

    private void CommandReset(IPlayer player)
    {
      if (!HasPermission(player, PERMISSION_RESET)) return;

      LoadDefaultConfig();
      SaveConfig();
      SetBroadcastTimer();
      SetUnlockTimers();
      SendMessage(player, "ResetConfig");
      CommandInfo(player);
    }

    private void CommandWipe(IPlayer player)
    {
      if (null == _configData || !HasPermission(player, PERMISSION_WIPE))
      {
        return;
      }

      DateTime currentTime = DateTime.UtcNow;
      _configData.LastWipeUTC = currentTime;
      SaveConfig();
      SetUnlockTimers();

      SendMessage(player, "PluginWipe", currentTime.ToString(
        "R", CultureInfo.CurrentCulture));
    }

    #endregion Commands

    #region Configuration

    // need to append logic to check for map wipe since last load
    protected override void LoadConfig()
    {
      base.LoadConfig();
      try
      {
        _configData = Config.ReadObject<ConfigData>();
        if (null == _configData)
        {
          throw new JsonException("ReadObject() returned null");
        }
      }
      catch (Exception ex)
      {
        PrintWarning($"LoadConfig(): Exception while loading configuration file:\n{ex}");
        LoadDefaultConfig();
      }

      if (null == _configData) return;

      if (_configData.WBConfig.Length != 3)
      {
        PrintWarning($"LoadConfig(): Got {_configData.WBConfig.Length} workbench unlock settings, but expected 3; resetting to default list");
        _configData.WBConfig = ConfigData._DEFAULT_WB_SECONDS;
      }

      var serverWipeTime = SaveRestore.SaveCreatedTime;
      if (_configData.LastWipeUTC < serverWipeTime)
      {
        _configData.LastWipeUTC = serverWipeTime;
        Puts("LoadConfig(): Wipe detected - reset wipe time to " + serverWipeTime.ToString("R", CultureInfo.CurrentCulture));
      }

      SaveConfig();
    }

    protected override void LoadDefaultConfig()
    {
      Puts("LoadDefaultConfig(): Creating a new configuration file");
      _configData = new ConfigData();
    }

    protected override void SaveConfig() => Config.WriteObject(_configData);

    // config file data class
    private sealed class ConfigData
    {
      // default workbench unlock times
      [JsonIgnore]
      public static readonly int[] _DEFAULT_WB_SECONDS = {
        86400, 172800, 259200
      };

      [JsonProperty(PropertyName = "Global status broadcast interval in seconds (0 to disable)")]
      public int BroadcastConfig { get; set; } = 300;

      [JsonProperty(PropertyName = "Time that current wipe started (UTC)")]
      public DateTime LastWipeUTC { get; set; } = SaveRestore.SaveCreatedTime;

      [JsonProperty(PropertyName = "Workbench unlock times (seconds from start of wipe, or 0 for unlocked, or -1 for permanently locked)")]
      public int[] WBConfig { get; set; } = _DEFAULT_WB_SECONDS;

      [JsonProperty(PropertyName = "Block crafting of locked workbench(es)")]
      public bool BlockCraft = true;

      [JsonProperty(PropertyName = "Block researching of locked workbench(es)")]
      public bool BlockResearch = true;

      [JsonProperty(PropertyName = "Report craft failure as chat message")]
      public bool ReportAsChat = false;

      [JsonProperty(PropertyName = "Report craft failure as sound effect")]
      public bool ReportAsSound = true;

      [JsonProperty(PropertyName = "Report craft failure as toast message")]
      public bool ReportAsToast = true;
    }

    #endregion Configuration
  }
}


// --- End of file: TimedWorkbenchUnlock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/toggle-noggin ---
// --- Original File Path: T/ToggleNoggin/ToggleNoggin.cs ---

﻿using System.Collections.Generic;
using System;
using UnityEngine;
using Oxide.Core.Plugins;


namespace Oxide.Plugins
{
    [Info("ToggleNoggin", "carny666", "1.0.4", ResourceId = 2725)]
    class ToggleNoggin : RustPlugin
    {
        const string adminPermission = "ToggleNoggin.admin";
        const string candlePermission = "ToggleNoggin.candle";
        const string minersPermission = "ToggleNoggin.miners";

        static string lastHat = "";

        void Init()
        {
            try
            {
                permission.RegisterPermission(adminPermission, this);
                permission.RegisterPermission(candlePermission, this);
                permission.RegisterPermission(minersPermission, this);

            }
            catch (Exception ex)
            {
                throw new Exception($"Error in Loaded {ex.Message}");
            }
        }

        [ConsoleCommand("togglenoggin")]
        void ccToggleNoggin(ConsoleSystem.Arg arg)
        {
            try
            {
                var player = arg.Player();
                if (player == null) return;

                if ((permission.UserHasPermission(player.UserIDString, minersPermission) || permission.UserHasPermission(player.UserIDString, adminPermission)) && arg?.Args != null)
                    ToggleHat(player, "hat.miner");
                else if (permission.UserHasPermission(player.UserIDString, candlePermission) && permission.UserHasPermission(player.UserIDString, adminPermission))
                    ToggleHat(player, "hat.candle");

            }
            catch (Exception ex)
            {
                throw new Exception($"Error in ccToggleNoggin {ex.Message}");
            }
        }

        [ChatCommand("togglenoggin")]
        void chcToggleNoggin(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (player == null) return;

                if ((permission.UserHasPermission(player.UserIDString, adminPermission) || permission.UserHasPermission(player.UserIDString, minersPermission)) && args.Length > 0)
                    ToggleHat(player, "hat.miner");
                else if (permission.UserHasPermission(player.UserIDString, adminPermission) || permission.UserHasPermission(player.UserIDString, candlePermission))
                    ToggleHat(player, "hat.candle");
            }
            catch (Exception ex)
            {
                throw new Exception($"Error in chcToggleNoggin {ex.Message}");

            }

        }

        void ToggleHat(BasePlayer player, string hatItemName)
        {
            try
            {

                /// test is hat already exists
                if (player.inventory.containerWear.FindItemsByItemName("hat.miner") == null && player.inventory.containerWear.FindItemsByItemName("hat.candle") == null)
                {
                    var hatDef = ItemManager.FindItemDefinition(hatItemName);

                    // save last hat for removeal next time..
                    lastHat = hatItemName;

                    if (hatDef != null)
                    {
                        Item hatItem = ItemManager.CreateByItemID(hatDef.itemid, 1);
                        if (hatItem != null)
                        {
                            player.inventory.GiveItem(hatItem, player.inventory.containerWear);
                            hatItem.SetFlag(global::Item.Flag.IsOn, true);
                        }
                    }
                }
                else
                {
                    var p = player.inventory.containerWear.FindItemsByItemName(lastHat);
                    if (p != null)
                        p.RemoveFromContainer();
                }
            }
            catch (Exception ex)
            {
                throw new Exception($"Error in ToggleHat {ex.Message}");
            }
        }

    }
}

// --- End of file: ToggleNoggin.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/thief-api ---
// --- Original File Path: T/ThiefAPI/ThiefAPI.cs ---

using System;                      //DateTime
using System.Reflection;           //Required for BindFlag
using System.Data;
using System.Linq;
using System.Collections.Generic;  //Required for Whilelist
using UnityEngine;
//using Rust;
using Oxide.Core;                  //Interface
//using Oxide.Core.Plugins;


namespace Oxide.Plugins
{
	[Info("Thief", "Alphawar", "0.5.0", ResourceId = 1503)]
	[Description("Mod for handling Thief class.")]
    class ThiefAPI : RustPlugin
	{
		///////////////////////////////////////
		///     Config, Values and Data     ///
		///////////////////////////////////////
		//Creates Blank Values to be loaded later
		private int Cooldown;
		private int Pass;
		private int LPchance;
		private int RandomNumber;
		private int DamageTicks;
		private int pickCostFM;
		private int pickCostSE;
		private float DamageAmount;
		private string NotAllowed;
		private string Allowed = "You start to pick the lock.";
		private string Failed;
		private string Success;
		private string MaxedAttempts = "My hands need a rest.";
		private string ChatPrefixColor = "008800";
        private string ChatPrefix = "Server";
		private string PickEnabledMessage = "Lock Pick Mode Enabled";
		private string PickDisabledMessage = "Lock Pick Mode Disabled";
		private string CooldownMessage;
		private bool PickEnabled;
		
		object GetConfig(string menu, string dataValue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
            }
            object value;
            if (!data.TryGetValue(dataValue, out value))
            {
                value = defaultValue;
                data[dataValue] = value;
            }
            return value;  
        }
		
		protected override void LoadDefaultConfig()
		{
			Puts("Creating a new configuration file!");
			Config.Clear();
			LoadVariables();
		}
		
		void LoadVariables() //Stores Default Values, calling GetConfig passing: menu, dataValue, defaultValue
		{
			//Booleans
			PickEnabled = Convert.ToBoolean(GetConfig("Settings", "PickEnabled", false));
			//Ints
			pickCostFM = Convert.ToInt32(GetConfig("Values", "MetalFragCost", 250));
			pickCostSE = Convert.ToInt32(GetConfig("Values", "StoneCost", 150));
			DamageTicks = Convert.ToInt32(GetConfig("Values", "DamageTicks", 50));
			LPchance = Convert.ToInt32(GetConfig("Values", "LPchance", 15));
			Cooldown = Convert.ToInt32(GetConfig("Values", "Cooldown", 25));
			//Floats
			DamageAmount = Convert.ToSingle(GetConfig("Values", "DamageAmount", 0.2f));
			//Strings
			NotAllowed = Convert.ToString(GetConfig("Messages", "NotAllowed", "You are not a thief."));
			Failed = Convert.ToString(GetConfig("Messages", "Failed", "You failed to pick the lock."));
			Success = Convert.ToString(GetConfig("Messages", "Success", "You have gained access to the door."));
			CooldownMessage = Convert.ToString(GetConfig("Messages", "ShortCooldown", "I cant do that right now"));
		}
		
		Hash<ulong, PlayerInfo> Thiefs = new Hash<ulong, PlayerInfo>();
		
        class PlayerInfo
        {
            public string UserId;
            public string Name;

            public PlayerInfo()
            {
            }

            public PlayerInfo(BasePlayer player)
            {
                UserId = player.userID.ToString();
                Name = player.displayName;
            }

            public ulong GetUserId()
            {
                ulong user_id;
                if (!ulong.TryParse(UserId, out user_id)) return 0;
                return user_id;
            }
        }
		
		class StoredData
		{
			public Dictionary<ulong, double> canpick = new Dictionary<ulong, double>();
			public HashSet<PlayerInfo> Thiefs = new HashSet<PlayerInfo>();
			
			public StoredData()
            {
            }
		}
		
		StoredData storedData;
		
		///////////////////////////////
		///   plugin initiation     ///
		///////////////////////////////
		System.Reflection.FieldInfo whitelistPlayers = typeof(CodeLock).GetField("whitelistPlayers", BindingFlags.NonPublic | BindingFlags.Instance);
		
        private void Loaded()
        {
			LoadVariables();
			if (!permission.PermissionExists("ThiefAPI.can"))
			{
				permission.RegisterPermission("ThiefAPI.can", this);
				Puts("ThiefAPI.can permission registered");
				Puts("only people with permission ThiefAPI.can can apply for the role");
			}
            storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("ThiefAPI"); 
        }
		
		[ChatCommand("lp")]
		void picklock(BasePlayer player, string cmd, string[] args)
		{
			if (!IsAllowed(player, "ThiefAPI.can", NotAllowed)) return;
			
			if (Thiefs[player.userID] != null)
			{
				DisableThiefMode(player);
				SendChatMessage(player, PickDisabledMessage);
			}
			else
			{
				EnableThiefMode(player);
				SendChatMessage(player, PickEnabledMessage);
			}
			
		}
		[ChatCommand("lpwipe")]
		void picklockwipe(BasePlayer player, string cmd, string[] args)
		{
			if (!IsAllowed(player, "ThiefAPI.can", NotAllowed)) return;
			storedData.canpick.Clear();
			Interface.GetMod().DataFileSystem.WriteObject("ThiefAPI", storedData);
		}
		
		object CanUseDoor(BasePlayer player, BaseLock codeLock)
		{
			ulong steamID = player.userID;
			double nextpicktime;
			//bool canBeThief;
			bool PassFail;
			if (!IsAllowed(player, "ThiefAPI.can","null")) return null;
            //SendChatMessage(player, NotAllowed);
			if (Thiefs[player.userID] != null){
				
				if (!storedData.canpick.TryGetValue(steamID, out nextpicktime))
				{
					SendChatMessage(player, "UserDataCreated");
					storedData.canpick.Add(steamID, GetTimeStamp() + Cooldown);
					Interface.GetMod().DataFileSystem.WriteObject("ThiefAPI", storedData);
				}
				
				if (codeLock is CodeLock)
				{
					List<ulong> whitelist = (List<ulong>)whitelistPlayers.GetValue(codeLock);
					if (whitelist.Contains(player.userID))
					{
						SendChatMessage(player, "You have the code");
						return null;
					}
				}
				
				if (GetTimeStamp() < nextpicktime)
				{
					int nexttele = Convert.ToInt32(GetTimeStamp() - nextpicktime);
					SendChatMessage(player, CooldownMessage);
					return null;
				}
				bool lockPickCostPass=lockPickCost(player);
				if (lockPickCostPass==true)
				{
					string debugmessage = Convert.ToString(lockPickCostPass);
					storedData.canpick[steamID] = GetTimeStamp() + Cooldown;
					Interface.GetMod().DataFileSystem.WriteObject("ThiefAPI", storedData);
					bool Pass=LPRoll();
					if (Pass==true)
					{
						SendChatMessage(player, Success);
						return true;
					}
					else
					{
						SendChatMessage(player, Failed);
						timer.Repeat(0.2f, DamageTicks, () =>
						{
							player.Hurt(DamageAmount);
						});
						return false;
					}
				}
			}
			return null;
		}

		
		///////////////////////////////
		///      plugin Logic       ///
		///////////////////////////////
		
		private bool lockPickCost(BasePlayer player)
        {
            int playerFM = player.inventory.GetAmount(688032252); // Frag metal
            int playerRk = player.inventory.GetAmount(3506021); // Spawn rock
            int playerSE = player.inventory.GetAmount(-892070738); // Stones
            {
                if ((playerFM >= pickCostFM) && (playerRk >= 1) && (playerSE >= pickCostSE)) // buyFlare/buyTarget is my config option for amount
                {
                    player.inventory.Take(null, 688032252, pickCostFM); // Take the specified amount of item
                    player.inventory.Take(null, -892070738, pickCostSE);
                    //callPaymentStrike(player); // Run function, not yet needed, may use to run code, as it only returns true or false atm.
                    return true;
                }
				else 
				{
					SendChatMessage(player, "You Dont have the inventory");
					return false;
				}
            }
		}

		bool LPRoll()
		{
			//create logic to roll LP pass/fail
			RandomNumber = UnityEngine.Random.Range(0, 101);
			if (RandomNumber < LPchance)
			{
				return true;
			}
			return false;
		}
		bool IsAllowed(BasePlayer player, string perm, string reason)
        {
            if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;
			if (reason != "null")
				SendChatMessage(player, reason);
            return false;
        }

		double GetTimeStamp()
		{
			return (DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds ;
		}
		
        void DisableThiefMode(BasePlayer player)
        {
            storedData.Thiefs.RemoveWhere(info => info.GetUserId() == player.userID);
            Thiefs.Remove(player.userID);
        }
		
        void EnableThiefMode(BasePlayer player)
        {
            var info = new PlayerInfo(player);
            storedData.Thiefs.Add(info);
            Thiefs[player.userID] = info;
        }
		
		//Function to send messages to player
		void SendChatMessage(BasePlayer player, string message, string args = null) => PrintToChat(player, $"<color={ChatPrefixColor}>{ChatPrefix}</color>: {message}", args);
	}
}

// --- End of file: ThiefAPI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ticket-fine ---
// --- Original File Path: T/TicketFines/TicketFines.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Ticket Fines", "McJackson164", "1.1.4")]
    [Description("A police-like system to issue tickets and impose fines.")]
    internal sealed class TicketFines : CovalencePlugin
    {
        #region Fields

        private const string PermissionTicketsIssue = "ticketfines.issue";
        private const string PermissionTicketsDemand = "ticketfines.demand";
        private const string PermissionTicketsClose = "ticketfines.close";
        private const string PermissionTicketsEdit = "ticketfines.edit";

        [PluginReference]
        private Plugin Economics;

        [PluginReference]
        private Plugin ServerRewards;

        private StoredData storedData;
        private Configuration config;

        private Dictionary<Ticket, string> demandedTickets = new Dictionary<Ticket, string>();

        private string currency = "";

        #endregion Fields

        #region Init

        private void Init()
        {
            permission.RegisterPermission(PermissionTicketsIssue, this);
            permission.RegisterPermission(PermissionTicketsDemand, this);
            permission.RegisterPermission(PermissionTicketsClose, this);
            permission.RegisterPermission(PermissionTicketsEdit, this);

            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

            var lastTicket = storedData.Tickets.Values.Select(l => l.Last()).OrderByDescending(t => t.TicketID).FirstOrDefault();
            Ticket.CurrentID = lastTicket != null ? lastTicket.TicketID : 0;
        }

        #endregion Init

        #region Hooks

        private void Loaded()
        {
            if (config.EnableFines)
            {
                if (new[] { config.UseEconomics, config.UseServerRewards, config.UseCustomCurrency }.Count(boolean => boolean) > 1)
                {
                    throw new ArgumentException("You can only use either Economics, Server Rewards or a custom currency to pay fines! Please adjust the configuration!");
                }
                else if (config.UseCustomCurrency)
                {
                    if (string.IsNullOrEmpty(config.CustomCurrencyItem))
                    {
                        throw new ArgumentException("You have to set a custom currency item in the configuration!");
                    }

                    var itemDefinition = ItemManager.FindItemDefinition(config.CustomCurrencyItem);
                    if (!itemDefinition)
                    {
                        throw new ArgumentException("The custom currency item does not exist! Please change the custom currency item in the configuration!");
                    }

                    currency = itemDefinition.displayName.translated;
                }
                else if (config.UseServerRewards)
                {
#if !RUST
                    throw new NotSupportedException("You can not use a Rust plugin in another game. Please set 'Use Server Rewards' to false in the configuration of this plugin.");
#endif
                    currency = "Point(s)";
                }
                else if (config.UseEconomics) currency = config.FineCurrency;
            }

            if (Economics == null)
            {
                Puts("Economics not found!");
            }
        }

        private void OnServerSave() => SaveData();

        private void Unload() => SaveData();

        #endregion Hooks

        #region Commands

        [Command("fine")]
        private void CommandTicket(IPlayer iplayer, string command, string[] args)
        {
            var hasPermissionIssue = iplayer.HasPermission(PermissionTicketsIssue);
            var hasPermissionDemand = iplayer.HasPermission(PermissionTicketsDemand);
            var hasPermissionClose = iplayer.HasPermission(PermissionTicketsClose);
            var hasPermissionEdit = iplayer.HasPermission(PermissionTicketsEdit);

            if (args.Length < 1)
            {
                var message = "Usage: /fine list|pay";
                if (hasPermissionIssue) message += "|issue";
                if (hasPermissionDemand) message += "|demand";
                if (hasPermissionClose) message += "|close";
                if (hasPermissionEdit) message += "|edit";

                iplayer.Message(message);
                return;
            };

            switch (args[0].ToLower())
            {
                case "list":
                    IPlayer listTarget = (hasPermissionDemand || hasPermissionClose || hasPermissionEdit) && args.Length >= 2 ? players.FindPlayer(args[1]) : iplayer;
                    if (listTarget == null)
                    {
                        iplayer.Message(lang.GetMessage("Exception_PlayerNotFound", this, iplayer.Id));
                        return;
                    }

                    var tickets = GetUnpaidTickets(listTarget, 10);
                    if (tickets == null) return;

                    iplayer.Message(lang.GetMessage("CmdTicket_List_Header", this, iplayer.Id));
                    foreach (var unpaidTicket in tickets)
                    {
                        iplayer.Message(GetMessageFormatted("CmdTicket_List_Entry", iplayer, unpaidTicket.TicketID, $"{unpaidTicket.IssueDate.Month}/{unpaidTicket.IssueDate.Day}", unpaidTicket.Fine, currency, unpaidTicket.Note));
                    }
                    iplayer.Message(lang.GetMessage("CmdTicket_List_UsagePay", this, iplayer.Id));

                    return;

                case "pay":
                    if (args.Length < 2)
                    {
                        iplayer.Message(lang.GetMessage("CmdTicket_Pay_Usage", this, iplayer.Id));
                        return;
                    }

                    var ticket = GetTicketByIDString(args[1]);
                    if (ticket == null) return;

                    var ticketPaid = PayTicket(iplayer, ticket);

                    if (ticketPaid)
                    {
                        iplayer.Message(GetMessageFormatted("CmdTicket_Pay_Success", iplayer, ticket.TicketID));
                    }
                    else
                    {
                        iplayer.Message(GetMessageFormatted("CmdTicket_Pay_Failed", iplayer, ticket.TicketID));
                    }

                    if (IsTicketDemanded(ticket))
                    {
                        var demanding = GetActivePlayerByUserID(demandedTickets[ticket]);
                        if (ticketPaid) demandedTickets.Remove(ticket);
                        if (demanding == null) return;
                        demanding.Message(GetMessageFormatted("CmdTicket_Pay_DemandResult", iplayer, ticket.TicketID, (ticketPaid ? "" : "not ")));
                    }
                    return;

                case "issue":
                    if (!hasPermissionIssue) return;
                    if (args.Length < 3)
                    {
                        iplayer.Message(lang.GetMessage("CmdTicket_Issue_Usage", this, iplayer.Id));
                        return;
                    }

                    double fine;
                    if (!double.TryParse(args[2], out fine) || fine < 0d)
                    {
                        iplayer.Message(lang.GetMessage("CmdTicket_Issue_InvalidFine", this, iplayer.Id));
                        return;
                    }

                    var target = players.FindPlayer(args[1]);
                    if (target == null)
                    {
                        iplayer.Message(lang.GetMessage("Exception_PlayerNotFound", this, iplayer.Id));
                        return;
                    }

                    var issuedTicket = IssueTicket(iplayer, target, fine, args.Length > 3 ? args[3] : null);
                    if (issuedTicket == null)
                    {
                        iplayer.Message(GetMessageFormatted("CmdTicket_Issue_Failed", iplayer, target.Name));
                        return;
                    }
                    iplayer.Message(GetMessageFormatted("CmdTicket_Issue_Success", iplayer, issuedTicket.TicketID, target.Name));
                    return;

                case "demand":
                    if (!hasPermissionDemand) return;
                    if (args.Length < 2)
                    {
                        iplayer.Message(lang.GetMessage("CmdTicket_Demand_Usage", this, iplayer.Id));
                        return;
                    }

                    var demandedTicket = GetTicketByIDString(args[1]);
                    if (demandedTicket == null)
                    {
                        iplayer.Message(GetMessageFormatted("Exception_TicketNotFound", iplayer, args[1]));
                        return;
                    }

                    var demandedPlayer = GetActivePlayerByUserID(demandedTicket.ReceiverID);
                    if (demandedPlayer == null)
                    {
                        iplayer.Message(lang.GetMessage("Exception_PlayerNotFound", this, iplayer.Id));
                        return;
                    }

                    if (demandedTickets.ContainsKey(demandedTicket))
                    {
                        iplayer.Message(lang.GetMessage("CmdTicket_Demand_TicketAlreadyDemanded", this, iplayer.Id));
                        return;
                    }

                    if (config.MaxDemandDistance > 0)
                    {
                        if (GenericDistance(iplayer.Position(), demandedPlayer.Position()) > config.MaxDemandDistance)
                        {
                            iplayer.Message(lang.GetMessage("CmdTicket_Demand_TargetOutOfRange", this, iplayer.Id));
                            return;
                        }
                    }

                    if (!DemandTicket(iplayer, demandedTicket))
                    {
                        iplayer.Message(GetMessageFormatted("CmdTicket_Demand_Failure", iplayer, demandedTicket.TicketID, demandedPlayer.Name));
                        return;
                    }

                    demandedPlayer.Message(GetMessageFormatted("CmdTicket_Demand_TargetNotification", iplayer, iplayer.Name, demandedTicket.TicketID, demandedTicket.Fine, currency));
                    demandedPlayer.Message(GetMessageFormatted("CmdTicket_Demand_TargetUsage", iplayer, demandedTicket.TicketID));
                    iplayer.Message(GetMessageFormatted("CmdTicket_Demand_Success", iplayer, demandedTicket.TicketID, demandedPlayer.Name));

                    return;

                case "close":
                    if (!hasPermissionClose) return;
                    if (args.Length < 2)
                    {
                        iplayer.Message(lang.GetMessage("CmdTicket_Close_Usage", this, iplayer.Id));
                        return;
                    }

                    var ticketToClose = GetTicketByIDString(args[1]);

                    if (ticketToClose == null)
                    {
                        iplayer.Message(GetMessageFormatted("Exception_TicketNotFound", iplayer, args[1]));
                        return;
                    }

                    if (!CloseTicket(ticketToClose, $"{iplayer.Name}:{iplayer.Id}"))
                    {
                        iplayer.Message(GetMessageFormatted("CmdTicket_Close_Failure", iplayer, ticketToClose.TicketID));
                        return;
                    }

                    iplayer.Message(GetMessageFormatted("CmdTicket_Close_Success", iplayer, ticketToClose.TicketID));
                    return;

                case "edit":
                    if (!hasPermissionEdit) return;
                    if (args.Length < 4)
                    {
                        iplayer.Message(lang.GetMessage("CmdTicket_Edit_Usage", this, iplayer.Id));
                        iplayer.Message(lang.GetMessage("CmdTicket_Edit_Fields", this, iplayer.Id));
                        return;
                    }

                    var ticketToEdit = GetTicketByIDString(args[1]);

                    if (ticketToEdit == null)
                    {
                        iplayer.Message(GetMessageFormatted("Exception_TicketNotFound", iplayer, args[1]));
                        return;
                    }

                    if (!EditTicket(ticketToEdit, (TicketEditField)Enum.Parse(typeof(TicketEditField), args[2]), args[3]))
                    {
                        iplayer.Message(GetMessageFormatted("CmdTicket_Edit_Failure", iplayer, ticketToEdit.TicketID));
                    }

                    iplayer.Message(GetMessageFormatted("CmdTicket_Edit_Success", iplayer, ticketToEdit.TicketID));
                    return;

                default:
                    return;
            }
        }

        #endregion Commands

        #region Methods

        private Ticket IssueTicket(string issuer, IPlayer target, double fine, string note = null)
        {
            if (config.EnableFines)
            {
                if (fine < 0d) return null;
                if (fine > config.MaxFine) fine = config.MaxFine;
            }
            else
            {
                fine = 0d;
            }

            if (config.EnableNotes)
            {
                var noteIsNull = string.IsNullOrEmpty(note);
                if (config.RequireNote && noteIsNull) return null;
                if (!noteIsNull && config.MaxNoteLength > 0 && note.Length > config.MaxNoteLength) note = note.Substring(0, config.MaxNoteLength);
            }
            else
            {
                note = null;
            }

            var ticket = new Ticket(issuer, target.Id, fine, note);

            if (storedData.Tickets.ContainsKey(target.Id))
            {
                storedData.Tickets[target.Id].Add(ticket);
            }
            else
            {
                storedData.Tickets.Add(target.Id, new List<Ticket>() { ticket });
            }

            var issuerPlayer = players.FindPlayer(ticket.IssuerID);
            var issuerName = issuerPlayer != null ? issuerPlayer.Name : ticket.IssuerID;

#if RUST
            var rustPlayer = target.Object as BasePlayer;
            if (config.EnableNotes && rustPlayer && rustPlayer.IsAlive())
            {
                var item = ItemManager.CreateByName("note");
                item.name = "Ticket";
                item.skin = 2640270407;
                item.text = $"TICKET\n----------------------------------\nID:\t\t\t\t{ticket.TicketID}\nIssued at:\t{ticket.IssueDate}\nIssued by:\t{issuerName}\nFine:\t\t\t{ticket.Fine} {currency}" + (string.IsNullOrEmpty(note) ? "" : $"\nNote:\t\t\t{ticket.Note}");
                rustPlayer?.inventory.GiveItem(item);
            }
#endif
            if (target.IsConnected)
            {
                if (!string.IsNullOrEmpty(note))
                {
                    target.Message(GetMessageFormatted("Method_IssueTicket_TargetNotificationWithNote", target, ticket.Fine, currency, issuerName, ticket.Note));
                }
                else
                {
                    target.Message(GetMessageFormatted("Method_IssueTicket_TargetNotification", target, ticket.Fine, currency, issuerName));
                }
            }

            Interface.CallHook("OnTicketIssued", ticket.TicketID, ticket.IssuerID, ticket.ReceiverID, ticket.Fine, ticket.Note);

            if (config.EnableFines && config.AutoWithdraw)
            {
                if (PayTicket(target, ticket))
                {
                    target.Message(lang.GetMessage("Method_IssueTicket_AutoWithdraw_Success", this, target.Id));
                }
                else
                {
                    target.Message(lang.GetMessage("Method_IssueTicket_AutoWithdraw_Failure", this, target.Id));
                }
            }

            return ticket;
        }

        private Ticket IssueTicket(IPlayer player, IPlayer target, double fine, string note = null) => IssueTicket(player.Id, target, fine, note);

        private bool DemandTicket(IPlayer player, Ticket ticket)
        {
            demandedTickets.Add(ticket, player.Id);
            Interface.CallHook("OnTicketDemanded", player.Id, ticket.ReceiverID, ticket.TicketID);
            return true;
        }

        private bool PayTicket(IPlayer player, Ticket ticket)
        {
            if (ticket == null) return false;
            if (ticket.IsClosed) return false;
            if (ticket.ReceiverID != player.Id) return false;

            var target = demandedTickets.ContainsKey(ticket) ? demandedTickets[ticket] : ticket.IssuerID;

            if (config.EnableFines && ticket.Fine > 0)
            {
                if (config.UseEconomics && Economics != null)
                {
                    if (config.DemandantReceiveFine)
                    {
                        if (!Economics.Call<bool>("Transfer", player.Id, target, ticket.Fine)) return false;
                    }
                    else
                    {
                        if (!Economics.Call<bool>("Withdraw", player.Id, ticket.Fine)) return false;
                    }
                }
                else if (config.UseServerRewards && ServerRewards != null)
                {
                    var serverRewardsResponse = ServerRewards.Call<object>("TakePoints", player.Id, Convert.ToInt32(ticket.Fine));
                    if (serverRewardsResponse == null) return false;
                    if (config.DemandantReceiveFine)
                    {
                        ServerRewards.Call<object>("AddPoints", target, Convert.ToInt32(ticket.Fine));
                    }
                }
                else
                {
#if RUST
                    var rustPlayer = player.Object as BasePlayer;
                    var itemDefinition = ItemManager.FindItemDefinition(config.CustomCurrencyItem);
                    if (!itemDefinition) return false;
                    if (rustPlayer.inventory.GetAmount(itemDefinition.itemid) < ticket.Fine) return false;
                    rustPlayer.inventory.Take(null, itemDefinition.itemid, Convert.ToInt32(ticket.Fine));
                    if (config.DemandantReceiveFine)
                    {
                        var rustTargetPlayer = BasePlayer.Find(target);
                        if (rustTargetPlayer)
                        {
                            rustTargetPlayer.inventory.GiveItem(ItemManager.Create(itemDefinition, Convert.ToInt32(ticket.Fine)));
                        }
                    }
#elif HURTWORLD
                    // TODO: implement
                    return false;
#else
                    return false;
#endif
                }
            }

            CloseTicket(ticket, "PAID");
            Interface.CallHook("OnTicketPaid", player.Id, ticket.TicketID, ticket.Fine);
            return true;
        }

        private bool CloseTicket(Ticket ticket, string closedBy = null)
        {
            if (ticket.IsClosed) return false;
            ticket.IsClosed = true;
            ticket.ClosedBy = closedBy;
            ticket.CloseDate = DateTime.Now;
            Interface.CallHook("OnTicketClosed", ticket.TicketID, ticket.ReceiverID, ticket.ClosedBy);
            return true;
        }

        private bool EditTicket(Ticket ticket, TicketEditField field, object value)
        {
            switch (field)
            {
                case TicketEditField.FINE:
                    double newFine;
                    if (!double.TryParse(value.ToString(), out newFine)) return false;
                    ticket.Fine = newFine;
                    return true;

                case TicketEditField.NOTE:
                    if (!(value is string)) return false;
                    ticket.Note = value.ToString();
                    return true;
            }
            return false;
        }

        private bool DeleteTicket(Ticket ticket)
        {
            return storedData.Tickets[ticket.ReceiverID].Remove(ticket);
        }

        private Ticket GetTicketByID(uint ticketID)
        {
            var query = from outer in storedData.Tickets
                        from inner in outer.Value
                        where inner.TicketID == ticketID
                        select inner;

            if (!query.Any()) return null;
            return query.First();
        }

        private Ticket GetTicketByIDString(string ticketIDString)
        {
            uint ticketID;
            if (!uint.TryParse(ticketIDString, out ticketID)) return null;
            return GetTicketByID(ticketID);
        }

        private List<Ticket> GetUnpaidTickets(IPlayer player, int limit = 100)
        {
            if (!HasTickets(player)) return null;
            return storedData.Tickets[player.Id].Where(ticket => !ticket.IsClosed).Take(limit).ToList();
        }

        private bool HasTickets(IPlayer player) => storedData.Tickets.ContainsKey(player.Id) && storedData.Tickets[player.Id].Count > 0;

        private bool IsTicketDemanded(Ticket ticket) => demandedTickets.ContainsKey(ticket);

        #endregion Methods

        #region API

        private List<Dictionary<string, object>> API_GetAllTicketsOfPlayer(IPlayer player)
        {
            if (!HasTickets(player)) return null;
            return TicketListToDictionary(storedData.Tickets[player.Id]);
        }

        private List<Dictionary<string, object>> API_GetUnpaidTicketsOfPlayer(IPlayer player)
        {
            if (!HasTickets(player)) return null;
            return TicketListToDictionary(GetUnpaidTickets(player));
        }

        private List<Dictionary<string, object>> API_GetPaidTicketsOfPlayer(IPlayer player)
        {
            if (!HasTickets(player)) return null;
            return TicketListToDictionary(storedData.Tickets[player.Id].Where(ticket => ticket.IsClosed));
        }

        private uint API_IssueTicket(string issuer, IPlayer target, double amount) => API_IssueTicket(issuer, target, amount, null);

        private uint API_IssueTicket(string issuer, IPlayer target, double amount, string note) => IssueTicket(issuer, target, amount, note)?.TicketID ?? 0;

        private bool API_PayTicketByID(IPlayer player, string ticketID, bool withdraw = true)
        {
            var ticket = GetTicketByIDString(ticketID);
            if (ticket == null) return false;

            return PayTicket(player, ticket);
        }

        private bool API_PayOldestTicketOfPlayer(IPlayer player)
        {
            if (!HasTickets(player)) return false;
            var ticket = storedData.Tickets[player.Id].First();
            return PayTicket(player, ticket);
        }

        private bool API_CloseTicketByID(string ticketID, string closedBy = null)
        {
            var ticket = GetTicketByIDString(ticketID);
            if (ticket == null) return false;
            return CloseTicket(ticket, closedBy);
        }

        private bool API_DeleteTicketByID(string ticketID)
        {
            var ticket = GetTicketByIDString(ticketID);
            if (ticket == null) return false;
            return DeleteTicket(ticket);
        }

        #endregion API

        #region Helper

        private List<Dictionary<string, object>> TicketListToDictionary(IEnumerable<Ticket> ticketList)
        {
            List<Dictionary<string, object>> ticketDictList = new List<Dictionary<string, object>>();
            foreach (var ticket in ticketList)
            {
                ticketDictList.Add(ticket.ToDictionary());
            }
            return ticketDictList;
        }

        private IPlayer GetActivePlayerByUserID(string userID)
        {
            foreach (var player in players.Connected)
                if (player.Id == userID) return player;
            return null;
        }

        private float GenericDistance(GenericPosition a, GenericPosition b)
        {
            float x = a.X - b.X;
            float y = a.Y - b.Y;
            float z = a.Z - b.Z;
            return (float)Math.Sqrt(x * x + y * y + z * z);
        }

        #endregion Helper

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Enable fines (requires Economics OR Server Rewards OR custom currency item)")]
            public bool EnableFines = true;

            [JsonProperty("Use 'Economics' plugin for payment (requires Economics)")]
            public bool UseEconomics = false;

            [JsonProperty("Use 'Server Rewards' plugin for payment (requires Server Rewards)")]
            public bool UseServerRewards = false;

            [JsonProperty("Use custom currency for payment")]
            public bool UseCustomCurrency = true;

            [JsonProperty("Custom Currency Item (requires 'Use custom currency' to be true. Use item shortname)")]
            public string CustomCurrencyItem = "scrap";

            [JsonProperty("Enable automatic withdraw of fines (requires 'Enable fines' to be true)")]
            public bool AutoWithdraw = false;

            [JsonProperty("The demandent will receive a paid fine. (if false, the fine amount will be deleted)")]
            public bool DemandantReceiveFine = true;

            [JsonProperty("Maximum fine per ticket (default 1000.0)")]
            public double MaxFine = 1000.0d;

            [JsonProperty("Currency (requires 'Use custom currency' to be true)")]
            public string FineCurrency = "Scrap";

            [JsonProperty("Enable notes (descriptive note attached to a ticket)")]
            public bool EnableNotes = true;

            [JsonProperty("Tickets require note (tickets won't be issued without a note)")]
            public bool RequireNote = false;

            [JsonProperty("Maximum note length (0 = unlimited)")]
            public int MaxNoteLength = 200;

            [JsonProperty("Maximum distance in which you are able to demand a ticket (0 = unlimited)")]
            public int MaxDemandDistance = 20;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    Puts("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                Puts($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Data

        private class StoredData
        {
            public Dictionary<string, List<Ticket>> Tickets = new Dictionary<string, List<Ticket>>();

            public StoredData()
            {
            }
        }

        private class Ticket
        {
            public static uint CurrentID = 0;

            public uint TicketID { get; }
            public string IssuerID { get; }
            public string ReceiverID { get; }
            public double Fine { get; set; }
            public string Note { get; set; }
            public bool IsClosed { get; set; }
            public string ClosedBy { get; set; }
            public DateTime IssueDate { get; set; }
            public DateTime CloseDate { get; set; }

            [JsonConstructor]
            public Ticket(uint ticketID, string issuerID, string receiverID, double fine, DateTime issueDate, string note = null, bool isClosed = false, string closedBy = null, DateTime? closeDate = null)
            {
                TicketID = ticketID;
                IssuerID = issuerID;
                ReceiverID = receiverID;
                Fine = fine;
                IssueDate = issueDate;
                Note = note;
                IsClosed = isClosed;
                ClosedBy = closedBy;
                if (closeDate != null) CloseDate = (DateTime) closeDate;
            }

            public Ticket(string issuerID, string receiverID, double fine, string note = null) : this(++CurrentID, issuerID, receiverID, fine, DateTime.Now, note)
            {
            }

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(JsonConvert.SerializeObject(this));
        }

        private enum TicketEditField
        {
            FINE,
            NOTE
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        #endregion Data

        #region Localization

        private string GetMessageFormatted(string key, IPlayer player, params object[] args) => string.Format(lang.GetMessage(key, this, player.Id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                // COMMANDS
                ["CmdTicket_List_Header"] = "ID\tDate\t\tFine\t\t\tNote\n--------------------------------------------------------------",
                ["CmdTicket_List_Entry"] = "{0}:\t{1}\t\t{2} {3}\t\t{4}",
                ["CmdTicket_List_UsagePay"] = "Use '/fine pay <ID>' to pay the fine of a ticket.",

                ["CmdTicket_Pay_Usage"] = "Usage: /fine pay <ticketID>",
                ["CmdTicket_Pay_Success"] = "Successfully paid ticket with id '{0}'!",
                ["CmdTicket_Pay_Failed"] = "Can not pay ticket with id '{0}'!",
                ["CmdTicket_Pay_DemandResult"] = "The demanded ticket with id '{0}' was {1}paid!",

                ["CmdTicket_Issue_Usage"] = "Usage: /fine issue <playerName> <fine> <note (optional)>",
                ["CmdTicket_Issue_InvalidFine"] = "Inavlid fine!",
                ["CmdTicket_Issue_Success"] = "Successfully issued ticket with id '{0}' to '{1}'!",
                ["CmdTicket_Issue_Failed"] = "Failed to issue ticket to '{0}'!",

                ["CmdTicket_Demand_Usage"] = "Usage: /fine demand <ticketID>",
                ["CmdTicket_Demand_TicketAlreadyDemanded"] = "Ticket already demanded!",
                ["CmdTicket_Demand_TargetOutOfRange"] = "Target is out of range!",
                ["CmdTicket_Demand_Success"] = "Successfully demanded the payment of the ticket with id '{0}' from '{1}'!",
                ["CmdTicket_Demand_Failure"] = "Failed to demand ticket with id '{0}' from '{1}'",
                ["CmdTicket_Demand_TargetNotification"] = "'{0}' demands you to pay ticket '{1}' with a fine of {2} {3}!",
                ["CmdTicket_Demand_TargetUsage"] = "Use '/fine pay {0}' to pay the demanded ticket.",

                ["CmdTicket_Close_Usage"] = "Usage: /fine close <ticketID>",
                ["CmdTicket_Close_Success"] = "Successfully closed ticket with id '{0}'!",
                ["CmdTicket_Close_Failure"] = "Failed to close ticket with id '{0}'!",

                ["CmdTicket_Edit_Usage"] = "Usage: /fine edit <ticketID> <field> <newValue>",
                ["CmdTicket_Edit_Fields"] = "Fields: FINE, NOTE",
                ["CmdTicket_Edit_Success"] = "Successfully edited ticket with id '{0}'!",
                ["CmdTicket_Edit_Failure"] = "Failed to edit ticket with id '{0}'!",

                // METHODS
                ["Method_IssueTicket_TargetNotificationWithNote"] = "You received a ticket with a fine of {0} {1}, issued by {2}! Note: {3}",
                ["Method_IssueTicket_TargetNotification"] = "You received a ticket with a fine of {0} {1}, issued by {2}!",
                ["Method_IssueTicket_AutoWithdraw_Success"] = "Automatic withdraw was successful!",
                ["Method_IssueTicket_AutoWithdraw_Failure"] = "Automatic withdraw was not successful! Please pay your ticket manually!",

                // GENERAL EXCEPTIONS
                ["Exception_PlayerNotFound"] = "Player not found!",
                ["Exception_TicketNotFound"] = "Ticket with id '{0}' not found!",
            }, this);
        }

        #endregion Localization
    }
}


// --- End of file: TicketFines.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/donation-webstore ---
// --- Original File Path: T/Tip4serv/Tip4serv.cs ---

﻿/***********************************************************************************************************************/
/*** DO NOT edit this file! Edit the files under `oxide/config` and/or `oxide/lang`, created once plugin has loaded. ***/
/***********************************************************************************************************************/

using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;
using Oxide.Core.Libraries;
using System;
using System.Text;
using System.Security.Cryptography;

namespace Oxide.Plugins
{
    [Info("Tip4serv", "Murgator & Duster", "1.4.8")]
    [Description("Allows Admin to monetize their 7 Days to die & Rust server from their Tip4serv store")]
    public class Tip4serv : CovalencePlugin
    {
        private class PluginConfig
        {
            public int request_interval_in_minutes;
            public string configkey;
            public string order_received_text;
        }
        [Serializable]
        public class ResponseData
        {
            public string date;
            public string action;
            public Dictionary<int, int> cmds;
            public int status;
            public string username;
        }
        [Serializable]
        public class Payments
        {
            public string player;
            public string action;
            public string id;
            public string steamid;
            public PaymentCmd[] cmds;
   
        }
        [Serializable]
        public class PaymentCmd
        {
            public string str;
            public int id;
            public int state;
        }
        private String key_msg = "Please set the config key to a valid key in your config/Tip4Serv.json file. Make sure you have copied the entire key on Tip4Serv.com (Ctrl+A then CTRL+C)";
        private bool Stopped = false;
        private Timer PaymentTimer;
        private PluginConfig config;
    
        protected override void LoadDefaultConfig()
        {
            LogWarning("Creating a new configuration file");
            Config.WriteObject(GetDefaultConfig(), true);
        }
        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                request_interval_in_minutes = 1,
                configkey = "YOUR_CONFIG_KEY",
                order_received_text = "[#cyan][Tip4serv][/#] You have received your order. Thank you !"
            };
        }
        private Dictionary<String,IPlayer> GetPlayers() {
            IEnumerable<IPlayer> players = covalence.Players.Connected;
             Dictionary<String,IPlayer> tip4customers = new Dictionary<string,IPlayer>();
            foreach (IPlayer player in players)
            {
                tip4customers[player.Id] = player;
            }
           return tip4customers;
        }
        private void Loaded()
        {            
            #if !SEVENDAYSTODIE && !RUST
               LogError("This plugin only works for the 7 Days to Die or Rust Game");
               Stopped = true;
            #else
               Tip4Print("Tip4serv plugin has started");
               config = Config.ReadObject<PluginConfig>();
            #endif
        }
        private void Unload()
        {
            key_msg = null;
            if(PaymentTimer != null && !PaymentTimer.Destroyed)
                PaymentTimer.Destroy();
        }
        void OnServerInitialized()
        {
            if (!Stopped)
            {
                //check Tip4serv connection on script start
                string[] key_part = config.configkey.Split('.');
                if (key_part.Length != 3)
                {
                    Tip4Print(key_msg);
                    return;
                }
                check_pending_commands(key_part, GetUnixTime(), "no");
                PaymentTimer = timer.In((float)config.request_interval_in_minutes * 60f,() => PaymentChecker());
            }
        }
        private void PaymentChecker()
        {
            string[] key_part = config.configkey.Split('.');
            if (key_part.Length != 3)
            {
                Tip4Print(key_msg);
                return;
            }
            check_pending_commands(key_part, GetUnixTime(), "yes");
            if(PaymentTimer!=null && !PaymentTimer.Destroyed)
                PaymentTimer.Destroy();
            PaymentTimer = timer.In((float)config.request_interval_in_minutes * 60f,() => PaymentChecker());
        }
        private string GetUnixTime()
        {
            long unixTime = ((DateTimeOffset)DateTime.Now).ToUnixTimeSeconds();
            return unixTime.ToString();
        }
        private void Tip4Print(string content)
        {
            LogWarning(content);
        }
        private void check_pending_commands(string[] key_parts, string timestamp, string get_cmd)
        {
            //HMAC calculation
            string HMAC = calculateHMAC(key_parts, timestamp);
            
            //get last infos from the json file
            Dictionary<string, ResponseData> response = LoadFile("tip4serv_response");
            string json_encoded = "";
            if (response.Count > 0)
            {
                json_encoded = Utility.ConvertToJson(response);
            }
            
            //Url parameters
            string ApiUrl = "https://api.tip4serv.com/payments_api_v2.php?id=" + key_parts[0] + "&time=" + timestamp;
            string EntireApiUrl = ApiUrl + "&get_cmd=" + get_cmd;
            
            //Header HMAC
            Dictionary<string, string> Headers = new Dictionary<string, string> { { "Authorization", HMAC }, { "Content-Type", "application/json" } };
            
            //Post Request
            webrequest.Enqueue(EntireApiUrl, json_encoded, (code, HTTPresponse) => {

                if (code != 200 || HTTPresponse == null)
                {
                    if (get_cmd == "no")
                    {
                        Tip4Print("Tip4serv API is temporarily unavailable, maybe you are making too many requests. Please try again later");
                    }
                    return;
                }
                //tip4serv connect
                if (get_cmd == "no")
                {
                    Tip4Print(HTTPresponse);
                    return;
                }
                response.Clear();
                //check for errors
                if (HTTPresponse.Contains("No pending payments found") || get_cmd == "update")
                {
                    Interface.Oxide.DataFileSystem.WriteObject("tip4serv_response", response);
                    return;
                }
                else if (HTTPresponse.StartsWith("\"[Tip4serv "))
                {
                    Tip4Print(HTTPresponse);
                    return;
                }                
                //clear old json infos
                Interface.Oxide.DataFileSystem.WriteObject("tip4serv_response", response);
                Dictionary<String,IPlayer> players = GetPlayers();
                var json_decoded = Utility.ConvertFromJson<List<Payments>>(HTTPresponse);
                var update_now = false;
                //loop customers
                for (int i = 0; i < json_decoded.Count; i++)
                {
                    ResponseData new_obj = new ResponseData();
                    Dictionary<int, int> new_cmds = new Dictionary<int, int>();
                    string payment_id = json_decoded[i].id;
                    new_obj.date = DateTime.Now.ToString();
                    new_obj.action = json_decoded[i].action;
                    new_obj.username = "";
                    //check if player is online
                    IPlayer player_infos = checkifPlayerIsLoaded(json_decoded[i].steamid,players);
                    if (player_infos != null)
                    {
                        new_obj.username = player_infos.Name;
                        player_infos.Message(config.order_received_text);
                    }
                    if (json_decoded[i].cmds.Length != 0)
                    {
                        for (int j = 0; j < json_decoded[i].cmds.Length; j++)
                        {
                            //do not run this command if the player must be online
                            if (player_infos == null && (json_decoded[i].cmds[j].str.Contains("{") || (json_decoded[i].cmds[j].state == 1)))
                            {
      
                                new_obj.status = 14;
                            }
                            else
                            {                                
                                #if SEVENDAYSTODIE
                                if (json_decoded[i].cmds[j].str.Contains("{7dtd_username}"))
                                #elif RUST
                                if (json_decoded[i].cmds[j].str.Contains("{rust_username}"))
                                #endif
                                {
                                    if (player_infos != null) {
                                        #if SEVENDAYSTODIE
                                        json_decoded[i].cmds[j].str = json_decoded[i].cmds[j].str.Replace("{7dtd_username}", player_infos.Name);
                                        #elif RUST 
                                        json_decoded[i].cmds[j].str = json_decoded[i].cmds[j].str.Replace("{rust_username}", player_infos.Name);
                                        #endif                                       
                                    }
                                }
                                string[] empty = { };
                                exe_command(json_decoded[i].cmds[j].str, empty);
                                new_cmds[json_decoded[i].cmds[j].id] = 3;
                                update_now = true;
                            }
                        }
                        new_obj.cmds = new_cmds;
                        if (new_obj.status == 0)
                        {
                            new_obj.status = 3;
                        }
                        response[payment_id] = new_obj;
                    }
                }
                //save the new json file
                Interface.Oxide.DataFileSystem.WriteObject("tip4serv_response", response);
                //update commands status on tip4serv if a command has been delivered
                if (update_now == true){
                    
                    //Json response data
                    json_encoded = Utility.ConvertToJson(response);
                    
                    //Url parameters
                    string EntireApiUrl = ApiUrl + "&get_cmd=update";
                    
                    //Header HMAC
                    Dictionary<string, string> Headers = new Dictionary<string, string> { { "Authorization", HMAC }, { "Content-Type", "application/json" } };
                    
                    webrequest.Enqueue(EntireApiUrl, json_encoded, (code, HTTPresponse) => {
                        if (code == 200 && HTTPresponse != null){
                            response.Clear();
                            Interface.Oxide.DataFileSystem.WriteObject("tip4serv_response", response);
                        }
                        return;
                    }, this, RequestMethod.POST, Headers, 10f);
                }

            }, this, RequestMethod.POST, Headers, 10f);
        }
        private Dictionary<string, ResponseData> LoadFile(string path)
        {
            Dictionary<string, ResponseData> response;
            try
            {
                response = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, ResponseData>>("tip4serv_response");
                if (response == null)
                {
                    response = new Dictionary<string, ResponseData>();
                }
            }
            catch (Exception)
            {
                response = new Dictionary<string, ResponseData>();
            }
            return response;
        }
        private string calculateHMAC(string[] key_parts, string timestamp)
        {
            HMACSHA256 Encryptor = new HMACSHA256(Encoding.ASCII.GetBytes(key_parts[1]));
            key_parts[1] = "";
            string Total_Key = string.Join("", key_parts);
            Total_Key += timestamp;
            var signature = Encryptor.ComputeHash(Encoding.ASCII.GetBytes(Total_Key));
            var HMACstr = BitConverter.ToString(signature).Replace("-", "").ToLower();
            HMACstr = Convert.ToBase64String(Encoding.ASCII.GetBytes(HMACstr));
            return HMACstr;
        }
        private IPlayer checkifPlayerIsLoaded(string steam_id, Dictionary<string,IPlayer> players)
        {
 
            IPlayer SteamPlayer = players.TryGetValue(steam_id, out SteamPlayer) ? SteamPlayer : null;     
            if (SteamPlayer == null)
            {
                return null;
            }
            #if RUST
            if (SteamPlayer.IsConnected)
            {
                return SteamPlayer;
            }
            else
            {
                return null;
            }
            #elif SEVENDAYSTODIE
            try {
                //here is the trick we get the position
                //if the position of the player is returned it mean the player is connected
                //on the other case if Position() throw an exception it means that the player ain't connected 
                GenericPosition JUNKPOS = SteamPlayer.Position(); 
                return SteamPlayer;
            } catch(KeyNotFoundException e) {
                return null;
            }
            #endif
            return null;
        }
        private void exe_command(string cmd, string[] CmdArgs)
        {
            Tip4Print("Tip4serv execute command: "+cmd);
            server.Command(cmd, CmdArgs);
        }
    }
}

// --- End of file: Tip4serv.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/troll-tax ---
// --- Original File Path: T/TrollTax/TrollTax.cs ---

﻿using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("Troll Tax", "Absolut", "1.1.1")]
    [Description("Places a tax on players killed. Once the Taxer dies his/her tax payer list is cleared")]
    public class TrollTax : RustPlugin
    {
        #region Fields

        [PluginReference]
        Plugin LustyMap;

        string TitleColor = "<color=orange>";
        string MsgColor = "<color=#A9A9A9>";

        TrollTaxData ttData;
        private DynamicConfigFile TTData;

        private Dictionary<string, Timer> timers = new Dictionary<string, Timer>();
        private Dictionary<ulong, Coords> BoxPrep = new Dictionary<ulong, Coords>();
        private List<ulong> VoidSelection = new List<ulong>();

        #endregion

        #region Server Hooks

        void Init()
        {
            TTData = Interface.Oxide.DataFileSystem.GetFile(Name + "_Data");
            
            LoadVariables();
            LoadData();
        }

        void InitializeTaxTimer(ulong taxer, ulong payer)
        {
            if (!ttData.VictimLimit.ContainsKey(payer))
                ttData.VictimLimit.Add(payer, new Dictionary<ulong, Timer>());
            if (ttData.VictimLimit[payer].ContainsKey(taxer))
                ttData.VictimLimit[payer].Remove(taxer);
            if (!ttData.TaxCollector.ContainsKey(taxer))
                ttData.TaxCollector.Add(taxer, new List<ulong>());
            ttData.TaxCollector[taxer].Add(payer);
            ttData.VictimLimit[payer].Add(taxer, timer.Once(configData.TaxTimeLimit * 3600, () => RemoveTax(payer, taxer)));
        }

        void RemoveTax(ulong payer, ulong taxer)
        {
            if (ttData.VictimLimit.ContainsKey(payer))
                if (ttData.VictimLimit[payer].ContainsKey(taxer))
                    ttData.VictimLimit[payer].Remove(taxer);
            if (ttData.TaxCollector.ContainsKey(taxer))
                if (ttData.TaxCollector[taxer].Contains(payer))
                {
                    ttData.TaxCollector[taxer].Remove(payer);
                    GetSendMSG(BasePlayer.FindByID(payer), "TaxRemoved");
                }
        }

        void Unload()
        {
            BoxPrep.Clear();
            VoidSelection.Clear();
            foreach (var entry in timers)
                entry.Value.Destroy();
            timers.Clear();
            SaveData();
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (VoidSelection.Contains(player.userID))
                VoidSelection.Remove(player.userID);
            if (BoxPrep.ContainsKey(player.userID))
                BoxPrep.Remove(player.userID);
        }

        void OnServerInitialized()
        {
            timers.Add("info", timer.Once(900, () => InfoLoop()));
            timers.Add("save", timer.Once(600, () => SaveLoop()));
            SaveData();
        }

        #endregion

        #region Player Hooks

        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            if (planner == null) return;

            if (gameobject.GetComponent<BaseEntity>() != null)
            {
                BaseEntity container = gameobject.GetComponent<BaseEntity>();
                var entityowner = gameobject.GetComponent<BaseEntity>().OwnerID;
                if (container.PrefabName == "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab" || container.PrefabName == "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab")
                {
                    if (BoxPrep.ContainsKey(entityowner)) BoxPrep.Remove(entityowner);
                    BoxPrep.Add(entityowner, new Coords { x = gameobject.transform.position.x, y = gameobject.transform.position.y, z = gameobject.transform.position.z });
                    BasePlayer player = BasePlayer.FindByID(entityowner);
                    TaxBoxConfirmation(player);
                }
            }
        }

        private void OnEntityDeath(BaseEntity entity, HitInfo hitInfo)
        {
            if (entity is StorageContainer)
            {
                Vector3 ContPosition = entity.transform.position;
                if (ttData.TaxBox.ContainsKey(entity.OwnerID))
                {
                    if (ContPosition == new Vector3(ttData.TaxBox[entity.OwnerID].x, ttData.TaxBox[entity.OwnerID].y, ttData.TaxBox[entity.OwnerID].z))
                    {
                        ttData.TaxBox.Remove(entity.OwnerID);
                        BasePlayer owner = BasePlayer.FindByID(entity.OwnerID);
                        if (BasePlayer.activePlayerList.Contains(owner))
                            GetSendMSG(owner, "TaxBoxDestroyed");
                    }
                    SaveData();
                }
                return;
            }

            if (entity is BasePlayer)
            {
                var victim = entity.ToPlayer();
                if (ttData.TaxCollector.ContainsKey(victim.userID))
                {
                    foreach (var entry in ttData.TaxCollector[victim.userID])
                        RemoveTax(entry, victim.userID);
                    SaveData();
                }
                if (entity is BasePlayer && hitInfo.Initiator is BasePlayer)
                {
                    var attacker = hitInfo.Initiator.ToPlayer() as BasePlayer;
                    if (entity as BasePlayer == null || hitInfo == null) return;

                    if (victim.userID != attacker.userID)
                    {
                        InitializeTaxTimer(attacker.userID, victim.userID);
                        SaveData();
                    }
                }
            }
        }

        void OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player)
        {
            if (!isPayor(player.userID)) return;

            var taxrate = configData.TaxRate;
            List<StorageContainer> TaxContainers = GetTaxContainer(player.userID);
            if (TaxContainers == null) return;

            int taxcollectors = 0;
            foreach (var entry in ttData.TaxCollector.Where(kvp => kvp.Value.Contains(player.userID)))
                taxcollectors++;
            var maxtaxors = Math.Floor(100 / taxrate);
            if (maxtaxors < taxcollectors)
                taxrate = 90 / taxcollectors;

            int Tax = Convert.ToInt32(Math.Ceiling((item.amount * taxrate) / 100));
            item.amount = item.amount - (Tax * taxcollectors);
            foreach (StorageContainer cont in TaxContainers)
            {
                if (!cont.inventory.IsFull())
                {
                    ItemDefinition ToAdd = ItemManager.FindItemDefinition(item.info.itemid);
                    if (ToAdd != null)
                    {
                        cont.inventory.AddItem(ToAdd, Tax);
                    }
                }
                else if (BasePlayer.activePlayerList.Contains(BasePlayer.FindByID(cont.OwnerID)))
                    if (timers.ContainsKey(cont.OwnerID.ToString()))
                    {
                        GetSendMSG(player, "TaxBoxFull");
                        SetBoxFullNotification(cont.OwnerID.ToString());
                        return;
                    }
            }
        }


        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (!isPayor(player.userID)) return;

            var taxrate = configData.TaxRate;
            List<StorageContainer> TaxContainers = GetTaxContainer(player.userID);
            if (TaxContainers == null) return;

            int taxcollectors = 0;
            foreach (var entry in ttData.TaxCollector.Where(kvp => kvp.Value.Contains(player.userID)))
                taxcollectors++;
            var maxtaxors = Math.Floor(100 / taxrate);
            if (maxtaxors < taxcollectors)
                taxrate = 90 / taxcollectors;

            int Tax = Convert.ToInt32(Math.Ceiling((item.amount * taxrate) / 100));
            item.amount = item.amount - (Tax * taxcollectors);
            foreach (StorageContainer cont in TaxContainers)
            {
                if (!cont.inventory.IsFull())
                {
                    ItemDefinition ToAdd = ItemManager.FindItemDefinition(item.info.itemid);
                    if (ToAdd != null)
                    {
                        cont.inventory.AddItem(ToAdd, Tax);
                    }
                }
                else if (BasePlayer.activePlayerList.Contains(BasePlayer.FindByID(cont.OwnerID)))
                    if (timers.ContainsKey(cont.OwnerID.ToString()))
                    {
                        GetSendMSG(player, "TaxBoxFull");
                        SetBoxFullNotification(cont.OwnerID.ToString());
                        return;
                    }
            }
        }

        void OnDispenserGather(ResourceDispenser Dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (!isPayor(entity.ToPlayer().userID)) return;

            var taxrate = configData.TaxRate;
            List<StorageContainer> TaxContainers = GetTaxContainer(player.userID);
            if (TaxContainers == null) return;

            int taxcollectors = 0;
            foreach (var entry in ttData.TaxCollector.Where(kvp => kvp.Value.Contains(player.userID)))
                taxcollectors++; 
            var maxtaxors = Math.Floor(100 / taxrate);
            if (maxtaxors < taxcollectors)
                taxrate = 90 / taxcollectors;
            int Tax = Convert.ToInt32(Math.Ceiling((item.amount * taxrate) / 100));
            item.amount = item.amount - (Tax * taxcollectors);
            foreach (StorageContainer cont in TaxContainers)
            {
                if (!cont.inventory.IsFull())
                {
                    ItemDefinition ToAdd = ItemManager.FindItemDefinition(item.info.itemid);
                    if (ToAdd != null)
                    {
                        cont.inventory.AddItem(ToAdd, Tax);
                    }
                }
                else if (BasePlayer.activePlayerList.Contains(BasePlayer.FindByID(cont.OwnerID)))
                {
                    if (timers.ContainsKey(cont.OwnerID.ToString()))
                    {
                        GetSendMSG(player, "TaxBoxFull");
                        SetBoxFullNotification(cont.OwnerID.ToString());
                        return;
                    }
                }
            }
        }

        #endregion

        #region Functions
        public bool isPayor(ulong ID)
        {
            foreach (var entry in ttData.TaxCollector)
            {
                if (entry.Value.Contains(ID))
                {
                    return true;
                }
                else continue;
            }
            return false;
        }

        private List<StorageContainer> GetTaxContainer(ulong Payor)
        {
            List<StorageContainer> Containers = new List<StorageContainer>();
            foreach (var entry in ttData.TaxCollector.Where(kvp => kvp.Value.Contains(Payor)))
            {
                if (ttData.TaxBox.ContainsKey(entry.Key))
                {
                    Vector3 containerPos = new Vector3 (ttData.TaxBox[entry.Key].x, ttData.TaxBox[entry.Key].y, ttData.TaxBox[entry.Key].z );
                    foreach (StorageContainer Cont in StorageContainer.FindObjectsOfType<StorageContainer>())
                    {
                        Vector3 ContPosition = Cont.transform.position;
                        if (ContPosition == containerPos)
                            Containers.Add(Cont);
                    }
                }
            }
            if (Containers.Count > 0)
                return Containers;
            else return null;
        }

        private void GetSendMSG(BasePlayer player, string message, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            if (!player.IsConnected) return;

            string msg = string.Format(lang.GetMessage(message, this, player.UserIDString), arg1, arg2, arg3);
            SendReply(player, TitleColor + lang.GetMessage("title", this, player.UserIDString) + "</color>" + MsgColor + msg + "</color>");
        }

        public void DestroyTaxPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelTax);
        }
        #endregion

        #region UI Creation

        private string PanelTax = "Tax";

        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 1.0f, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            static public void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
            static public void CreateTextOverlay(ref CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                //if (configdata.DisableUI_FadeIn)
                //    fadein = 0;
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"black", "0 0 0 1.0" },
            {"dark", "0.1 0.1 0.1 0.98" },
            {"header", "1 1 1 0.3" },
            {"light", ".564 .564 .564 1.0" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"brown", "0.3 0.16 0.0 1.0" },
            {"yellow", "0.9 0.9 0.0 1.0" },
            {"orange", "1.0 0.65 0.0 1.0" },
            {"blue", "0.2 0.6 1.0 1.0" },
            {"red", "1.0 0.1 0.1 1.0" },
            {"white", "1 1 1 1" },
            {"green", "0.28 0.82 0.28 1.0" },
            {"grey", "0.85 0.85 0.85 1.0" },
            {"lightblue", "0.6 0.86 1.0 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttongreen", "0.133 0.965 0.133 0.9" },
            {"buttonred", "0.964 0.133 0.133 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
            {"CSorange", "1.0 0.64 0.10 1.0" }
        };
        #endregion

        #region UI Panels

        private void TaxBoxConfirmation(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelTax);
            var element = UI.CreateElementContainer(PanelTax, UIColors["dark"], "0.425 0.45", "0.575 0.55", true);
            UI.CreatePanel(ref element, PanelTax, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelTax, MsgColor, lang.GetMessage("TaxBoxCreation", this, player.UserIDString), 14, "0.05 0.56", "0.95 0.9");
            UI.CreateButton(ref element, PanelTax, UIColors["buttongreen"], lang.GetMessage("Yes", this, player.UserIDString), 14, "0.05 0.25", "0.475 0.55", $"UI_SaveTaxBox");
            UI.CreateButton(ref element, PanelTax, UIColors["buttonred"], lang.GetMessage("No", this, player.UserIDString), 14, "0.525 0.25", "0.95 0.55", $"UI_DestroyTaxPanel");
            UI.CreateButton(ref element, PanelTax, UIColors["CSorange"], lang.GetMessage("VOID", this, player.UserIDString), 14, "0.25 0.05", "0.75 0.24", $"UI_DontAsk");
            CuiHelper.AddUi(player, element);
        }
        #endregion

        #region UI Commands

        [ConsoleCommand("UI_SaveTaxBox")]
        private void cmdUI_SaveTaxBox(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            DestroyTaxPanel(player);
            if (BoxPrep.ContainsKey(player.userID))
            {
                if (ttData.TaxBox.ContainsKey(player.userID)) ttData.TaxBox.Remove(player.userID);
                ttData.TaxBox.Add(player.userID, new Coords { x = BoxPrep[player.userID].x, y = BoxPrep[player.userID].y, z = BoxPrep[player.userID].z });
            }
            else GetSendMSG(player, "NoBoxPrepped");
            SaveData();
        }

        [ConsoleCommand("UI_DestroyTaxPanel")]
        private void cmdUI_DestroyTaxPanel(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            DestroyTaxPanel(player);
        }

        [ConsoleCommand("UI_DontAsk")]
        private void cmdUI_DontAsk(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            DestroyTaxPanel(player);
            if (VoidSelection.Contains(player.userID)) return;
            VoidSelection.Add(player.userID);
        }

        #endregion

        #region Timers

        private void SaveLoop()
        {
            if (timers.ContainsKey("save"))
            {
                timers["save"].Destroy();
                timers.Remove("save");
            }
            SaveData();
            timers.Add("save", timer.Once(600, () => SaveLoop()));
        }

        private void InfoLoop()
        {
            if (timers.ContainsKey("info"))
            {
                timers["info"].Destroy();
                timers.Remove("info");
            }
            if (configData.InfoInterval == 0) return;
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                GetSendMSG(p, "TrollTaxInfo");
            }
            timers.Add("info", timer.Once(configData.InfoInterval * 60, () => InfoLoop()));
        }

        private void SetBoxFullNotification(string ID)
        {
            timers.Add(ID, timer.Once(5 * 60, () => timers.Remove(ID)));
        }

        #endregion

        #region Classes
        class TrollTaxData
        {
            public Dictionary<ulong, List<ulong>> TaxCollector = new Dictionary<ulong, List<ulong>>();
            public Dictionary<ulong, Coords> TaxBox = new Dictionary<ulong, Coords>();
            public Dictionary<ulong, Dictionary<ulong, Timer>> VictimLimit = new Dictionary<ulong, Dictionary<ulong, Timer>>();
        }

        class Coords
        {
            public float x;
            public float y;
            public float z;
        }
        #endregion

        #region Data Management

        void SaveData()
        {
            TTData.WriteObject(ttData);
        }

        void LoadData()
        {
            try
            {
                ttData = TTData.ReadObject<TrollTaxData>();
            }
            catch
            {
                Puts("Couldn't load TrollTax data, creating new datafile");
                ttData = new TrollTaxData();
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;

        class ConfigData
        {
            public double TaxRate { get; set; }
            public int TaxTimeLimit { get; set; }
            public int InfoInterval { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                TaxRate = 5,
                TaxTimeLimit = 8,
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion


        #region Messages
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"title", "TrollTax: " },
                {"TrollTaxInfo", "This server is running TrollTax. You will become a tax collector for each player you kill until you die. To create a tax box simply place a box on the ground."},
                {"NoBoxPrepped", "Error finding target tax box!" },
                {"TaxBoxDestroyed", "Your tax box has been destroyed!" },
                {"TaxBoxFull", "Your tax box is full! Clear room to generate taxes." },
                {"TaxBoxCreation", "Would like to make this your tax box?" },
                {"Yes", "Yes?" },
                {"No", "No?" },
                {"TaxRemoved", "You are no longering being taxed by one of your taxers!" }
            }, this);
        }
        #endregion
    }
}

// --- End of file: TrollTax.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/tides ---
// --- Original File Path: T/Tides/Tides.cs ---

using System;
using ConVar;
using System.Collections.Generic;
using Random = System.Random;


namespace Oxide.Plugins
{
    [Info("Tides", "Regr3tti", "0.1.7")]
    [Description("Adds natural tides to rust")]
    public class Tides : RustPlugin
    {
        bool debug;
        bool storms;
        bool currentstorm;
        Timer stormTimer;
        string variance;
        double amt_variance;
        float variance_max;
        float variance_min;
        float tideheight_raw;
        float Tideheight_plus(float variance_low, float variance_high) => tideheight_raw + (((float)random.NextDouble() * (variance_high - variance_low)) + variance_low); // formula for the random variance that adds it to tide height specified in the config for your new actual tide height. If Variance is set to none in the config this will just return the tide height value from the config.  
        float period;
        float offset;
        float tideamplitude;
        float stormtideheight;
        float stormchance;
        private bool Changed;

        float refresh;
        Random random = new Random();
        float GetOceanLevel(float tideheight, float period, float offset) // Where the magic happens, this is what calculates the ocean height based on the time of day Env.time
        {
            return (float)Math.Round((tideheight / 2) * (float)Math.Sin((Math.PI / period) * Env.time - 1f * (Math.PI / offset)) + (tideheight / 2), 3); // Sine wave equation. By default Ocean Level = 1*sin((pi/6)x-(pi/2))+1, where x is Env.time. Simply this makes High Tide at 6:00 and 18:00, with low tide at 0:00 and 12:00. Ocean Levels stay between 0 and 2.
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        void LoadVariables()
        {
            tideheight_raw = Convert.ToInt32(GetConfig("1 - Tides", "1 - Height. How many meters (1m = 3ft) high do you want High Tide? 2 is natural and default, 5 is high, higher than 10 may have unintended consequences", 2));
            period = Convert.ToInt32(GetConfig("1 - Tides", "2 - Hours between high and low tide. 6 is natural and mimics real life, giving a high tide every 30 minutes (12 in-game hours)", 6));
            offset = Convert.ToInt32(GetConfig("1 - Tides", "4 - Offset. Don't change this unless you know what you're doing, 2 makes low tide start at midnight and -2 makes high tide start at midnight", 2));
            refresh = Convert.ToInt32(GetConfig("1 - Tides", "3 - Refresh rate, so 0.1 happens 10 times per second", 0.01));
            variance = Convert.ToString(GetConfig("2 - Variance", "Defines the amount of variance between high tides. Options are None, Low, Medium, High", "none"));
            debug = Convert.ToBoolean(GetConfig("4 - Debug", "This will output messages to your console to help diagnose problems", true));
            storms = Convert.ToBoolean(GetConfig("3 - Storms", "1 - If this is enabled you'll get a chance of storms", false));
            stormtideheight = Convert.ToInt32(GetConfig("3 - Storms", "2 - Set the maximum height of tides during a storm event. Default is 10 for a 10 meter high tide", 10));
            stormchance = Convert.ToInt32(GetConfig("3 - Storms", "3 - Set the chance of a storm occuring when storms are enabled. 0 means never 100 means always. Default is 10 for a 10% chance of storms", 10));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }
        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }
        void Init()
        {
            LoadVariables();
        }
        void OnServerInitialized()
        {
            CheckVariance();
            float occurance = (float)Math.Round((period * 2), 2);
            Timer oceanTimer = timer.Repeat(refresh, 0, () => //The code below runs an infinite number of times (or until it breaks!) at the specified refresh interval. This is what actually changes the ocean level. 
            {
                OceanLevelUpdater();
            });
            if (debug) { Puts($"Your next High Tide will reach **{Math.Round(tideamplitude, 2)}** meters."); }
            if (debug) { Puts($"The current time is **{TimeSpan.FromHours(Math.Round(Env.time, 2))}**"); }
            if (debug) { Puts($"The current ocean height is **{Math.Round(Env.oceanlevel, 2)}** meters"); }
            if (debug) { Puts($"Storms are set to {storms}"); }
            if (storms) { if (debug) { Puts($"Your chance of a storm occuring are {stormchance}%"); } }
            if (storms) { if (debug) { Puts($"During a storm event, your high tide will reach {stormtideheight} meters"); } }
            //if (Env.time < GetHighTide(period, tideamplitude, 0))
            //{
            //    if (debug) { Puts($"Your next High Tide will be at {TimeSpan.FromHours(GetHighTide(period, tideamplitude, 0)):h\\:mm}, with a new High Tide every {Math.Round(period * 2)} in-game hours"); }
            //}
            //else
            //{
            //    if (debug) { Puts($"Your next High Tide will be at {TimeSpan.FromHours(Math.Round(GetHighTide(period, tideamplitude, occurance), 2)):h\\:mm}, with a new High Tide every {Math.Round(period * 2)} in-game hours"); }
            //}
        }
        void OceanLevelUpdater()
        {
            ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"env.oceanlevel {GetOceanLevel(tideamplitude, period, offset)}"); //Executes the command, and blocks output to the console (or you'd get a flood of commands every 0.1 seconds)
            if (variance.Contains("low") || variance.Contains("medium") || variance.Contains("high") || storms)
            {
                CheckForLowTide();
                //Puts("Either Storms or Variance is enabled... checking for low tide");
            }
        }
        void CheckForLowTide()
        {
            bool itslowtide = (Math.Abs(Env.time % (period * 2)) < 0.0004 || Math.Abs(Env.time) < 0.001);
            if (itslowtide) // Checks that the oceanlevel is 0, which is the safest time to change the next tide height. There's an extra check for midnight so there's no divide by 0 error. This only does something if variance is enabled. 
            {
                DestroyTimer(stormTimer);
                currentstorm = false;
                ChanceOfStorm();
            } 
        }
        void DestroyTimer(Timer timer)
        {
            timer?.DestroyToPool();
            timer = null;
        }
        void ChanceOfStorm() //Rolling the dice on whether or not there's a storm event. 
        {
            if (random.NextDouble() < (stormchance / 100))
            {
                tideamplitude = stormtideheight;
                currentstorm = true;
                Puts("Chances of a storm coming are high...");
                stormTimer = timer.Repeat(1, 0, () => //The code below runs an infinite number of times (or until it breaks!) at the specified refresh interval. This is what actually changes the ocean level. 
                {
                    CreateStorms();
                });
            }    
            if (!currentstorm)
            {
                ChangeHighTide(); // This redoes the variance calculation to return a new maximum ocean height.
                if (debug) { Puts($"Your Variance setting is {variance},it's currently Low Tide and the time is {TimeSpan.FromHours(Env.time)} . Rolling the dice a few times for your next High Tide height... {Math.Round(tideamplitude, 2)} meters"); }
            }
        }
        void ChangeHighTide()
        {
            tideamplitude = Tideheight_plus(variance_min, variance_max);
        }
        float GetHighTide(float period, float tideamplitude, float occurance)
        {
            return (float)Math.Round((period / 2) + ((period / Math.PI)*(Math.Asin(tideamplitude - 1))) + (occurance));
        }
        void CheckVariance()
        {
            switch (variance.ToLower()) //checks for the config setting for variance, sets the value that tide height will be divided by to calculate the limits of the variance added to your defined tide height in the config. If 0 is selected, no variance is added.
            {
                case "none":
                    variance_max = 0;
                    variance_min = 0;
                    if (debug) { Puts($"Variance is set to **{variance.ToLower()}**, so your current tide height will never change. If you expected the opposite, change your Variance setting in the config file to **Low**, **Medium**, or **High**."); }
                    break;
                case "low":
                    amt_variance = 9.0;
                    SetVariance();
                    break;
                case "medium":
                    amt_variance = 5.0;
                    SetVariance();
                    break;
                case "high":
                    amt_variance = 1.2;
                    SetVariance();
                    break;
                default:
                    if (debug) { Puts($"The Variance setting in the Config file is wrong. You set it to **{variance.ToUpper()}**, and acceptable options are NONE, LOW, MEDIUM, HIGH. Capitalization doesn't matter."); }
                    break;
            }
           ChangeHighTide(); // Makes sure High Tide is set when the plugin loads. 
        }
        void SetVariance() //checks what value Variance is set to in the config and calculates the high and low boundaries for the variance calculation
            {
                variance_max = (float)(tideheight_raw / amt_variance); //The highest variance you might get in max tide height (e.g. you set a tide of 2, the tide might be as high as 2.22 in a given 15 minute period)
                variance_min = (float)(-1 * (tideheight_raw / amt_variance)); //The lowest variance you might get in max tide height (e.g. you set a tide of 2, the tide might be as low as 1.78 in a given 15 minute period)
                if (debug) { Puts($"Average High Tide height is set to **{Math.Round(tideheight_raw)}**, Variance is set to **{variance.ToUpper()}**. Due to your settings your next high tide will be between **{Math.Round(tideheight_raw - variance_min, 2)}** meters and **{Math.Round(tideheight_raw - variance_max, 2)}** meters.  If you expected less or no variance in your High Tide heights, please change your Variance settings in the config file"); }

            }
        void CreateStorms()
        {
                ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.fog {GetOceanLevel(1f, period, offset)}"); //Executes the command, and blocks output to the console (or you'd get a flood of commands every 0.1 seconds)
                ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.clouds {GetOceanLevel(1f, period, offset)}");
                ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.rain {GetOceanLevel(1f, period, offset)}");
                ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.wind {GetOceanLevel(1f, period, offset)}");

        }
    }
}

// --- End of file: Tides.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gather-manager ---
// --- Original File Path: G/GatherManager/GatherManager.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Gather Manager", "Mughisi", "2.2.78")]
    [Description("Increases the amount of items gained from gathering resources")]
    class GatherManager : RustPlugin
    {
        #region Configuration Data
        // Do not modify these values because this will not change anything, the values listed below are only used to create
        // the initial configuration file. If you wish changes to the configuration file you should edit 'GatherManager.json'
        // which is located in your server's config folder: <drive>:\...\server\<your_server_identity>\oxide\config\

        private bool configChanged;

        // Plugin settings
        private const string DefaultChatPrefix = "Gather Manager";
        private const string DefaultChatPrefixColor = "#008000ff";

        public string ChatPrefix { get; private set; }
        public string ChatPrefixColor { get; private set; }

        // Plugin options
        private static readonly Dictionary<string, object> DefaultGatherResourceModifiers = new Dictionary<string, object>();
        private static readonly Dictionary<string, object> DefaultGatherDispenserModifiers = new Dictionary<string, object>();
        private static readonly Dictionary<string, object> DefaultQuarryResourceModifiers = new Dictionary<string, object>();
        private static readonly Dictionary<string, object> DefaultPickupResourceModifiers = new Dictionary<string, object>();
        private static readonly Dictionary<string, object> DefaultSurveyResourceModifiers = new Dictionary<string, object>();

        // Defaults
        private const float DefaultMiningQuarryResourceTickRate = 5f;
        private const float DefaultExcavatorResourceTickRate = 3f;
        private const float DefaultExcavatorTimeForFullResources = 120f;
        private const float DefaultExcavatorBeltSpeedMax = 0.1f;

        public Dictionary<string, float> GatherResourceModifiers { get; private set; }
        public Dictionary<string, float> GatherDispenserModifiers { get; private set; }
        public Dictionary<string, float> QuarryResourceModifiers { get; private set; }
        public Dictionary<string, float> ExcavatorResourceModifiers { get; private set; }
        public Dictionary<string, float> PickupResourceModifiers { get; private set; }
        public Dictionary<string, float> SurveyResourceModifiers { get; private set; }
        public float MiningQuarryResourceTickRate { get; private set; }
        public float ExcavatorResourceTickRate { get; private set; }
        public float ExcavatorTimeForFullResources { get; private set; }
        public float ExcavatorBeltSpeedMax { get; private set; }

        // Plugin messages
        private const string DefaultNotAllowed = "You don't have permission to use this command.";
        private const string DefaultInvalidArgumentsGather =
            "Invalid arguments supplied! Use gather.rate <type:dispenser|pickup|quarry|excavator|survey> <resource> <multiplier>";
        private const string DefaultInvalidArgumentsDispenser =
            "Invalid arguments supplied! Use dispenser.scale <dispenser:tree|ore|corpse> <multiplier>";
        private const string DefaultInvalidArgumentsSpeed =
            "Invalid arguments supplied! Use quarry.rate <time between gathers in seconds>";
        private const string DefaultInvalidModifier =
            "Invalid modifier supplied! The new modifier always needs to be bigger than 0!";
        private const string DefaultInvalidSpeed = "You can't set the speed lower than 1 second!";
        private const string DefaultModifyResource = "You have set the gather rate for {0} to x{1} from {2}.";
        private const string DefaultModifyResourceRemove = "You have reset the gather rate for {0} from {1}.";
        private const string DefaultModifySpeed = "The Mining Quarry will now provide resources every {0} seconds.";
        private const string DefaultInvalidResource =
            "{0} is not a valid resource. Check gather.resources for a list of available options.";
        private const string DefaultModifyDispenser = "You have set the resource amount for {0} dispensers to x{1}";
        private const string DefaultInvalidDispenser =
            "{0} is not a valid dispenser. Check gather.dispensers for a list of available options.";

        private const string DefaultHelpText = "/gather - Shows you detailed gather information.";
        private const string DefaultHelpTextPlayer = "Resources gained from gathering have been scaled to the following:";
        private const string DefaultHelpTextAdmin = "To change the resources gained by gathering use the command:\r\ngather.rate <type:dispenser|pickup|quarry|survey> <resource> <multiplier>\r\nTo change the amount of resources in a dispenser type use the command:\r\ndispenser.scale <dispenser:tree|ore|corpse> <multiplier>\r\nTo change the time between Mining Quarry gathers:\r\nquarry.tickrate <seconds>";
        private const string DefaultHelpTextPlayerGains = "Resources gained from {0}:";
        private const string DefaultHelpTextPlayerMiningQuarrySpeed = "Time between Mining Quarry gathers: {0} second(s).";
        private const string DefaultHelpTextPlayerDefault = "Default values.";
        private const string DefaultDispensers = "Resource Dispensers";
        private const string DefaultCharges = "Survey Charges";
        private const string DefaultQuarries = "Mining Quarries";
        private const string DefaultExcavators = "Excavators";
        private const string DefaultPickups = "pickups";

        public string NotAllowed { get; private set; }
        public string InvalidArgumentsGather { get; private set; }
        public string InvalidArgumentsDispenser { get; private set; }
        public string InvalidArgumentsSpeed { get; private set; }
        public string InvalidModifier { get; private set; }
        public string InvalidSpeed { get; private set; }
        public string ModifyResource { get; private set; }
        public string ModifyResourceRemove { get; private set; }
        public string ModifySpeed { get; private set; }
        public string InvalidResource { get; private set; }
        public string ModifyDispenser { get; private set; }
        public string InvalidDispenser { get; private set; }
        public string HelpText { get; private set; }
        public string HelpTextPlayer { get; private set; }
        public string HelpTextAdmin { get; private set; }
        public string HelpTextPlayerGains { get; private set; }
        public string HelpTextPlayerDefault { get; private set; }
        public string HelpTextPlayerMiningQuarrySpeed { get; private set; }
        public string Dispensers { get; private set; }
        public string Charges { get; private set; }
        public string Quarries { get; private set; }
        public string Excavators { get; private set; }
        public string Pickups { get; private set; }

        #endregion

        private readonly List<string> subcommands = new List<string>() { "dispenser", "pickup", "quarry", "excavator", "survey" };

        private readonly Hash<string, ItemDefinition> validResources = new Hash<string, ItemDefinition>();

        private readonly Hash<string, ResourceDispenser.GatherType> validDispensers = new Hash<string, ResourceDispenser.GatherType>();

        private void Init() => LoadConfigValues();

        private void OnServerInitialized()
        {
            var resourceDefinitions = ItemManager.itemList;
            foreach (var def in resourceDefinitions.Where(def => def.category == ItemCategory.Food || def.category == ItemCategory.Resources))
                validResources.Add(def.displayName.english.ToLower(), def);

            validDispensers.Add("tree", ResourceDispenser.GatherType.Tree);
            validDispensers.Add("ore", ResourceDispenser.GatherType.Ore);
            validDispensers.Add("corpse", ResourceDispenser.GatherType.Flesh);
            validDispensers.Add("flesh", ResourceDispenser.GatherType.Flesh);

            foreach (var excavator in UnityEngine.Object.FindObjectsOfType<ExcavatorArm>())
            {
                if (ExcavatorResourceTickRate != DefaultMiningQuarryResourceTickRate)
                {
                    excavator.CancelInvoke("ProcessResources");
                    excavator.InvokeRepeating("ProcessResources", ExcavatorResourceTickRate, ExcavatorResourceTickRate);
                }

                if (ExcavatorBeltSpeedMax != DefaultExcavatorBeltSpeedMax)
                {
                    excavator.beltSpeedMax = ExcavatorBeltSpeedMax;
                }

                if (ExcavatorTimeForFullResources != DefaultExcavatorTimeForFullResources)
                {
                    excavator.timeForFullResources = ExcavatorTimeForFullResources;
                }
            }
        }

        private void Unload()
        {
            foreach (var excavator in UnityEngine.Object.FindObjectsOfType<ExcavatorArm>())
            {
                if (ExcavatorResourceTickRate != DefaultMiningQuarryResourceTickRate)
                {
                    excavator.CancelInvoke("ProcessResources");
                    excavator.InvokeRepeating("ProcessResources", DefaultMiningQuarryResourceTickRate, DefaultMiningQuarryResourceTickRate);
                }

                if (ExcavatorBeltSpeedMax != DefaultExcavatorBeltSpeedMax)
                {
                    excavator.beltSpeedMax = DefaultExcavatorBeltSpeedMax;
                }

                if (ExcavatorTimeForFullResources != DefaultExcavatorTimeForFullResources)
                {
                    excavator.timeForFullResources = DefaultExcavatorTimeForFullResources;
                }
            }
        }

        protected override void LoadDefaultConfig() => PrintWarning("New configuration file created.");

        [ChatCommand("gather")]
        private void Gather(BasePlayer player, string command, string[] args)
        {
            var help = HelpTextPlayer;
            if (GatherResourceModifiers.Count == 0 && SurveyResourceModifiers.Count == 0 && PickupResourceModifiers.Count == 0 && QuarryResourceModifiers.Count == 0)
                help += HelpTextPlayerDefault;
            else
            {
                if (GatherResourceModifiers.Count > 0)
                {
                    var dispensers = string.Format(HelpTextPlayerGains, Dispensers);
                    dispensers = GatherResourceModifiers.Aggregate(dispensers, (current, entry) => current + ("\r\n    " + entry.Key + ": x" + entry.Value));
                    help += "\r\n" + dispensers;
                }
                if (PickupResourceModifiers.Count > 0)
                {
                    var pickups = string.Format(HelpTextPlayerGains, Pickups);
                    pickups = PickupResourceModifiers.Aggregate(pickups, (current, entry) => current + ("\r\n    " + entry.Key + ": x" + entry.Value));
                    help += "\r\n" + pickups;
                }
                if (QuarryResourceModifiers.Count > 0)
                {
                    var quarries = string.Format(HelpTextPlayerGains, Quarries);
                    quarries = QuarryResourceModifiers.Aggregate(quarries, (current, entry) => current + ("\r\n    " + entry.Key + ": x" + entry.Value));
                    help += "\r\n" + quarries;
                }
                if (ExcavatorResourceModifiers.Count > 0)
                {
                    var excavators = string.Format(HelpTextPlayerGains, Excavators);
                    excavators = ExcavatorResourceModifiers.Aggregate(excavators, (current, entry) => current + ("\r\n    " + entry.Key + ": x" + entry.Value));
                    help += "\r\n" + excavators;
                }
                if (SurveyResourceModifiers.Count > 0)
                {
                    var charges = string.Format(HelpTextPlayerGains, Charges);
                    charges = SurveyResourceModifiers.Aggregate(charges, (current, entry) => current + ("\r\n    " + entry.Key + ": x" + entry.Value));
                    help += "\r\n" + charges;
                }
            }

            if (MiningQuarryResourceTickRate != DefaultMiningQuarryResourceTickRate)
                help += "\r\n" + string.Format(HelpTextPlayerMiningQuarrySpeed, MiningQuarryResourceTickRate);

            SendMessage(player, help);
            if (!player.IsAdmin) return;
            SendMessage(player, HelpTextAdmin);
        }

        private void SendHelpText(BasePlayer player) => SendMessage(player, HelpText);

        [ConsoleCommand("gather.rate")]
        private void GatherRate(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                arg.ReplyWith(NotAllowed);
                return;
            }

            var subcommand = arg.GetString(0).ToLower();
            if (!arg.HasArgs(3) || !subcommands.Contains(subcommand))
            {
                arg.ReplyWith(InvalidArgumentsGather);
                return;
            }

            if (!validResources[arg.GetString(1).ToLower()] && arg.GetString(1) != "*")
            {
                arg.ReplyWith(string.Format(InvalidResource, arg.GetString(1)));
                return;
            }

            var resource = validResources[arg.GetString(1).ToLower()]?.displayName.english ?? "*";
            var modifier = arg.GetFloat(2, -1);
            var remove = false;
            if (modifier < 0)
            {
                if (arg.GetString(2).ToLower() == "remove")
                    remove = true;
                else
                {
                    arg.ReplyWith(InvalidModifier);
                    return;
                }
            }

            switch (subcommand)
            {
                case "dispenser":
                    if (remove)
                    {
                        if (GatherResourceModifiers.ContainsKey(resource))
                            GatherResourceModifiers.Remove(resource);
                        arg.ReplyWith(string.Format(ModifyResourceRemove, resource, Dispensers));
                    }
                    else
                    {
                        if (GatherResourceModifiers.ContainsKey(resource))
                            GatherResourceModifiers[resource] = modifier;
                        else
                            GatherResourceModifiers.Add(resource, modifier);
                        arg.ReplyWith(string.Format(ModifyResource, resource, modifier, Dispensers));
                    }
                    SetConfigValue("Options", "GatherResourceModifiers", GatherResourceModifiers);
                    break;
                case "pickup":
                    if (remove)
                    {
                        if (PickupResourceModifiers.ContainsKey(resource))
                            PickupResourceModifiers.Remove(resource);
                        arg.ReplyWith(string.Format(ModifyResourceRemove, resource, Pickups));
                    }
                    else
                    {
                        if (PickupResourceModifiers.ContainsKey(resource))
                            PickupResourceModifiers[resource] = modifier;
                        else
                            PickupResourceModifiers.Add(resource, modifier);
                        arg.ReplyWith(string.Format(ModifyResource, resource, modifier, Pickups));
                    }
                    SetConfigValue("Options", "PickupResourceModifiers", PickupResourceModifiers);
                    break;
                case "quarry":
                    if (remove)
                    {
                        if (QuarryResourceModifiers.ContainsKey(resource))
                            QuarryResourceModifiers.Remove(resource);
                        arg.ReplyWith(string.Format(ModifyResourceRemove, resource, Quarries));
                    }
                    else
                    {
                        if (QuarryResourceModifiers.ContainsKey(resource))
                            QuarryResourceModifiers[resource] = modifier;
                        else
                            QuarryResourceModifiers.Add(resource, modifier);
                        arg.ReplyWith(string.Format(ModifyResource, resource, modifier, Quarries));
                    }
                    SetConfigValue("Options", "QuarryResourceModifiers", QuarryResourceModifiers);
                    break;
                case "excavator":
                    if (remove)
                    {
                        if (ExcavatorResourceModifiers.ContainsKey(resource))
                            ExcavatorResourceModifiers.Remove(resource);
                        arg.ReplyWith(string.Format(ModifyResourceRemove, resource, Excavators));
                    }
                    else
                    {
                        if (ExcavatorResourceModifiers.ContainsKey(resource))
                            ExcavatorResourceModifiers[resource] = modifier;
                        else
                            ExcavatorResourceModifiers.Add(resource, modifier);
                        arg.ReplyWith(string.Format(ModifyResource, resource, modifier, Excavators));
                    }
                    SetConfigValue("Options", "ExcavatorResourceModifiers", ExcavatorResourceModifiers);
                    break;
                case "survey":
                    if (remove)
                    {
                        if (SurveyResourceModifiers.ContainsKey(resource))
                            SurveyResourceModifiers.Remove(resource);
                        arg.ReplyWith(string.Format(ModifyResourceRemove, resource, Charges));
                    }
                    else
                    {
                        if (SurveyResourceModifiers.ContainsKey(resource))
                            SurveyResourceModifiers[resource] = modifier;
                        else
                            SurveyResourceModifiers.Add(resource, modifier);
                        arg.ReplyWith(string.Format(ModifyResource, resource, modifier, Charges));
                    }
                    SetConfigValue("Options", "SurveyResourceModifiers", SurveyResourceModifiers);
                    break;
            }
        }

        [ConsoleCommand("gather.resources")]
        private void GatherResources(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                arg.ReplyWith(NotAllowed);
                return;
            }

            arg.ReplyWith(validResources.Aggregate("Available resources:\r\n", (current, resource) => current + (resource.Value.displayName.english + "\r\n")) + "* (For all resources that are not setup separately)");
        }

        [ConsoleCommand("gather.dispensers")]
        private void GatherDispensers(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                arg.ReplyWith(NotAllowed);
                return;
            }

            arg.ReplyWith(validDispensers.Aggregate("Available dispensers:\r\n", (current, dispenser) => current + (dispenser.Value.ToString("G") + "\r\n")));
        }


        [ConsoleCommand("dispenser.scale")]
        private void DispenserRate(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                arg.ReplyWith(NotAllowed);
                return;
            }

            if (!arg.HasArgs(2))
            {
                arg.ReplyWith(InvalidArgumentsDispenser);
                return;
            }

            if (!validDispensers.ContainsKey(arg.GetString(0).ToLower()))
            {
                arg.ReplyWith(string.Format(InvalidDispenser, arg.GetString(0)));
                return;
            }

            var dispenser = validDispensers[arg.GetString(0).ToLower()].ToString("G");
            var modifier = arg.GetFloat(1, -1);
            if (modifier < 0)
            {
                arg.ReplyWith(InvalidModifier);
                return;
            }

            if (GatherDispenserModifiers.ContainsKey(dispenser))
                GatherDispenserModifiers[dispenser] = modifier;
            else
                GatherDispenserModifiers.Add(dispenser, modifier);
            SetConfigValue("Options", "GatherDispenserModifiers", GatherDispenserModifiers);
            arg.ReplyWith(string.Format(ModifyDispenser, dispenser, modifier));
        }

        [ConsoleCommand("quarry.tickrate")]
        private void MiningQuarryTickRate(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                arg.ReplyWith(NotAllowed);
                return;
            }

            if (!arg.HasArgs())
            {
                arg.ReplyWith(InvalidArgumentsSpeed);
                return;
            }

            var modifier = arg.GetFloat(0, -1);
            if (modifier < 1)
            {
                arg.ReplyWith(InvalidSpeed);
                return;
            }

            MiningQuarryResourceTickRate = modifier;
            SetConfigValue("Options", "MiningQuarryResourceTickRate", MiningQuarryResourceTickRate);
            arg.ReplyWith(string.Format(ModifySpeed, modifier));
            var quarries = UnityEngine.Object.FindObjectsOfType<MiningQuarry>();
            foreach (var quarry in quarries.Where(quarry => quarry.IsOn()))
            {
                quarry.CancelInvoke("ProcessResources");
                quarry.InvokeRepeating("ProcessResources", MiningQuarryResourceTickRate, MiningQuarryResourceTickRate);
            }
        }

        [ConsoleCommand("excavator.tickrate")]
        private void ExcavatorTickRate(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                arg.ReplyWith(NotAllowed);
                return;
            }

            if (!arg.HasArgs())
            {
                arg.ReplyWith(InvalidArgumentsSpeed);
                return;
            }

            var modifier = arg.GetFloat(0, -1);
            if (modifier < 1)
            {
                arg.ReplyWith(InvalidSpeed);
                return;
            }

            ExcavatorResourceTickRate = modifier;
            SetConfigValue("Options", "ExcavatorResourceTickRate", ExcavatorResourceTickRate);
            arg.ReplyWith(string.Format(ModifySpeed, modifier));
            var excavators = UnityEngine.Object.FindObjectsOfType<MiningQuarry>();
            foreach (var excavator in excavators.Where(excavator => excavator.IsOn()))
            {
                excavator.CancelInvoke("ProcessResources");
                excavator.InvokeRepeating("ProcessResources", ExcavatorResourceTickRate, ExcavatorResourceTickRate);
            }
        }

        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (!entity.ToPlayer())
            {
                return;
            }

            var gatherType = dispenser.gatherType.ToString("G");
            var amount = item.amount;

            float modifier;
            if (GatherResourceModifiers.TryGetValue(item.info.displayName.english, out modifier))
            {
                item.amount = (int)(item.amount * modifier);
            }
            else if (GatherResourceModifiers.TryGetValue("*", out modifier))
            {
                item.amount = (int)(item.amount * modifier);
            }

            if (!GatherResourceModifiers.ContainsKey(gatherType))
            {
                return;
            }

            var dispenserModifier = GatherDispenserModifiers[gatherType];

            try
            {
                dispenser.containedItems.Single(x => x.itemid == item.info.itemid).amount += amount - item.amount / dispenserModifier;

                if (dispenser.containedItems.Single(x => x.itemid == item.info.itemid).amount < 0)
                {
                    item.amount += (int)dispenser.containedItems.Single(x => x.itemid == item.info.itemid).amount;
                }
            }
            catch { }
        }

        private void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            OnDispenserGather(dispenser, entity, item);
        }

        private void OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player)
        {
            float modifier;
            if (GatherResourceModifiers.TryGetValue(item.info.displayName.english, out modifier))
            {
                item.amount = (int)(item.amount * modifier);
            }
            else if (GatherResourceModifiers.TryGetValue("*", out modifier))
            {
                item.amount = (int)(item.amount * modifier);
            }
        }

        private void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            float modifier;
            if (QuarryResourceModifiers.TryGetValue(item.info.displayName.english, out modifier))
            {
                item.amount = (int)(item.amount * modifier);
            }
            else if (QuarryResourceModifiers.TryGetValue("*", out modifier))
            {
                item.amount = (int)(item.amount * modifier);
            }
        }

        private void OnExcavatorGather(ExcavatorArm excavator, Item item)
        {
            float modifier;
            if (ExcavatorResourceModifiers.TryGetValue(item.info.displayName.english, out modifier))
            {
                item.amount = (int)(item.amount * modifier);
            }
            else if (ExcavatorResourceModifiers.TryGetValue("*", out modifier))
            {
                item.amount = (int)(item.amount * modifier);
            }
        }

        private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
        {
            foreach (ItemAmount item in collectible.itemList)
            {
                float modifier;
                if (PickupResourceModifiers.TryGetValue(item.itemDef.displayName.english, out modifier))
                {
                    item.amount = (int)(item.amount * modifier);
                }
                else if (PickupResourceModifiers.TryGetValue("*", out modifier))
                {
                    item.amount = (int)(item.amount * modifier);
                }
            }
        }

        private void OnSurveyGather(SurveyCharge surveyCharge, Item item)
        {
            float modifier;
            if (SurveyResourceModifiers.TryGetValue(item.info.displayName.english, out modifier))
            {
                item.amount = (int)(item.amount * modifier);
            }
            else if (SurveyResourceModifiers.TryGetValue("*", out modifier))
            {
                item.amount = (int)(item.amount * modifier);
            }
        }

        private void OnMiningQuarryEnabled(MiningQuarry quarry)
        {
            if (MiningQuarryResourceTickRate == DefaultMiningQuarryResourceTickRate) return;
            quarry.CancelInvoke("ProcessResources");
            quarry.InvokeRepeating("ProcessResources", MiningQuarryResourceTickRate, MiningQuarryResourceTickRate);
        }

        private void LoadConfigValues()
        {
            // Plugin settings
            ChatPrefix = GetConfigValue("Settings", "ChatPrefix", DefaultChatPrefix);
            ChatPrefixColor = GetConfigValue("Settings", "ChatPrefixColor", DefaultChatPrefixColor);

            // Plugin options
            var gatherResourceModifiers = GetConfigValue("Options", "GatherResourceModifiers", DefaultGatherResourceModifiers);
            var gatherDispenserModifiers = GetConfigValue("Options", "GatherDispenserModifiers", DefaultGatherDispenserModifiers);
            var quarryResourceModifiers = GetConfigValue("Options", "QuarryResourceModifiers", DefaultQuarryResourceModifiers);
            var excavatorResourceModifiers = GetConfigValue("Options", "ExcavatorResourceModifiers", quarryResourceModifiers);
            var pickupResourceModifiers = GetConfigValue("Options", "PickupResourceModifiers", DefaultPickupResourceModifiers);
            var surveyResourceModifiers = GetConfigValue("Options", "SurveyResourceModifiers", DefaultSurveyResourceModifiers);

            MiningQuarryResourceTickRate = GetConfigValue("Options", "MiningQuarryResourceTickRate", DefaultMiningQuarryResourceTickRate);

            ExcavatorResourceTickRate = GetConfigValue("Options", "ExcavatorResourceTickRate", DefaultExcavatorResourceTickRate);
            ExcavatorBeltSpeedMax = GetConfigValue("Options", "ExcavatorBeltSpeedMax", DefaultExcavatorBeltSpeedMax);
            ExcavatorTimeForFullResources = GetConfigValue("Options", "ExcavatorTimeForFullResources", DefaultExcavatorTimeForFullResources);

            GatherResourceModifiers = new Dictionary<string, float>();
            foreach (var entry in gatherResourceModifiers)
            {
                float rate;
                if (!float.TryParse(entry.Value.ToString(), out rate)) continue;
                GatherResourceModifiers.Add(entry.Key, rate);
            }

            GatherDispenserModifiers = new Dictionary<string, float>();
            foreach (var entry in gatherDispenserModifiers)
            {
                float rate;
                if (!float.TryParse(entry.Value.ToString(), out rate)) continue;
                GatherDispenserModifiers.Add(entry.Key, rate);
            }

            QuarryResourceModifiers = new Dictionary<string, float>();
            foreach (var entry in quarryResourceModifiers)
            {
                float rate;
                if (!float.TryParse(entry.Value.ToString(), out rate)) continue;
                QuarryResourceModifiers.Add(entry.Key, rate);
            }

            ExcavatorResourceModifiers = new Dictionary<string, float>();
            foreach (var entry in excavatorResourceModifiers)
            {
                float rate;
                if (!float.TryParse(entry.Value.ToString(), out rate)) continue;
                ExcavatorResourceModifiers.Add(entry.Key, rate);
            }

            PickupResourceModifiers = new Dictionary<string, float>();
            foreach (var entry in pickupResourceModifiers)
            {
                float rate;
                if (!float.TryParse(entry.Value.ToString(), out rate)) continue;
                PickupResourceModifiers.Add(entry.Key, rate);
            }

            SurveyResourceModifiers = new Dictionary<string, float>();
            foreach (var entry in surveyResourceModifiers)
            {
                float rate;
                if (!float.TryParse(entry.Value.ToString(), out rate)) continue;
                SurveyResourceModifiers.Add(entry.Key, rate);
            }

            // Plugin messages
            NotAllowed = GetConfigValue("Messages", "NotAllowed", DefaultNotAllowed);
            InvalidArgumentsGather = GetConfigValue("Messages", "InvalidArgumentsGather", DefaultInvalidArgumentsGather);
            InvalidArgumentsDispenser = GetConfigValue("Messages", "InvalidArgumentsDispenserType", DefaultInvalidArgumentsDispenser);
            InvalidArgumentsSpeed = GetConfigValue("Messages", "InvalidArgumentsMiningQuarrySpeed", DefaultInvalidArgumentsSpeed);
            InvalidModifier = GetConfigValue("Messages", "InvalidModifier", DefaultInvalidModifier);
            InvalidSpeed = GetConfigValue("Messages", "InvalidMiningQuarrySpeed", DefaultInvalidSpeed);
            ModifyResource = GetConfigValue("Messages", "ModifyResource", DefaultModifyResource);
            ModifyResourceRemove = GetConfigValue("Messages", "ModifyResourceRemove", DefaultModifyResourceRemove);
            ModifySpeed = GetConfigValue("Messages", "ModifyMiningQuarrySpeed", DefaultModifySpeed);
            InvalidResource = GetConfigValue("Messages", "InvalidResource", DefaultInvalidResource);
            ModifyDispenser = GetConfigValue("Messages", "ModifyDispenser", DefaultModifyDispenser);
            InvalidDispenser = GetConfigValue("Messages", "InvalidDispenser", DefaultInvalidDispenser);
            HelpText = GetConfigValue("Messages", "HelpText", DefaultHelpText);
            HelpTextAdmin = GetConfigValue("Messages", "HelpTextAdmin", DefaultHelpTextAdmin);
            HelpTextPlayer = GetConfigValue("Messages", "HelpTextPlayer", DefaultHelpTextPlayer);
            HelpTextPlayerGains = GetConfigValue("Messages", "HelpTextPlayerGains", DefaultHelpTextPlayerGains);
            HelpTextPlayerDefault = GetConfigValue("Messages", "HelpTextPlayerDefault", DefaultHelpTextPlayerDefault);
            HelpTextPlayerMiningQuarrySpeed = GetConfigValue("Messages", "HelpTextMiningQuarrySpeed", DefaultHelpTextPlayerMiningQuarrySpeed);
            Dispensers = GetConfigValue("Messages", "Dispensers", DefaultDispensers);
            Quarries = GetConfigValue("Messages", "MiningQuarries", DefaultQuarries);
            Excavators = GetConfigValue("Messages", "Excavators", DefaultExcavators);
            Charges = GetConfigValue("Messages", "SurveyCharges", DefaultCharges);
            Pickups = GetConfigValue("Messages", "Pickups", DefaultPickups);

            if (!configChanged) return;
            PrintWarning("Configuration file updated.");
            SaveConfig();
        }

        private T GetConfigValue<T>(string category, string setting, T defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }
            if (data.TryGetValue(setting, out value)) return (T)Convert.ChangeType(value, typeof(T));
            value = defaultValue;
            data[setting] = value;
            configChanged = true;
            return (T)Convert.ChangeType(value, typeof(T));
        }

        private void SetConfigValue<T>(string category, string setting, T newValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data != null && data.TryGetValue(setting, out value))
            {
                value = newValue;
                data[setting] = value;
                configChanged = true;
            }
            SaveConfig();
        }

        private void SendMessage(BasePlayer player, string message, params object[] args) => player?.SendConsoleCommand("chat.add", 0, -1, string.Format($"<color={ChatPrefixColor}>{ChatPrefix}</color>: {message}", args), 1.0);
    }
}

// --- End of file: GatherManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gather-bonuses ---
// --- Original File Path: G/GatherBonuses/GatherBonuses.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{

    [Info("Gather bonuses", "wazzzup", "0.0.1")]
    class GatherBonuses : RustPlugin
    {

        #region config

        private DynamicConfigFile config;
        Dictionary<string,int> rates = new Dictionary<string,int>();
        private bool Changed;

        void LoadVariables()
        {
            rates["High Quality Metal Ore"] = Convert.ToInt32(GetConfig("Rates", "High Quality Metal Ore", 1));
            rates["Sulfur Ore"] = Convert.ToInt32(GetConfig("Rates", "Sulfur Ore", 1));
            rates["Metal Ore"] = Convert.ToInt32(GetConfig("Rates", "Metal Ore", 1));
            rates["Stones"] = Convert.ToInt32(GetConfig("Rates", "Stones", 1));

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
            LoadVariables();
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion

        #region hooks

        void Loaded()
        {
            permission.RegisterPermission("gatherbonuses.magic", this);
            LoadVariables();
            config = Interface.Oxide.DataFileSystem.GetFile(Name);
        }

        private object OnDispenserBonus(ResourceDispenser resource, BasePlayer player, Item obj1)
        {
            obj1.amount = obj1.amount * rates[obj1.info.displayName.english];
            if (Interface.CallHook("IsMagicTool", player.GetActiveItem()) != null || permission.UserHasPermission(player.UserIDString, "gatherbonuses.magic"))
            {
                switch (obj1.info.shortname)
                {
                    case "sulfur.ore":
                        obj1.info = ItemManager.FindItemDefinition(-891243783);
                        break;
                    case "hq.metal.ore":
                        obj1.info = ItemManager.FindItemDefinition(374890416);
                        break;
                    case "metal.ore":
                        obj1.info = ItemManager.FindItemDefinition(688032252);
                        break;
                }
            }
            return obj1;
        }

        #endregion

    }
}

// --- End of file: GatherBonuses.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gun-stats ---
// --- Original File Path: G/GunStats/GunStats.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;

/*
 * Originally created by Orange, up to version 1.0.5
 * Rewritten from scratch and maintained to present by VisEntities
 */

namespace Oxide.Plugins
{
    [Info("Gun Stats", "VisEntities", "2.2.0")]
    [Description("Tracks your weapon use history, including kills and hits, and displays it on the weapon name.")]

    public class GunStats : RustPlugin
    {
        #region Fields

        private static GunStats _plugin;
        private static Configuration _config;
        private Dictionary<ulong, WeaponStats> _weaponStats = new Dictionary<ulong, WeaponStats>();

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Weapon Name Format")]
            public string WeaponNameFormat { get; set; }

            [JsonProperty("Include NPC In Stats")]
            public bool IncludeNPCInStats { get; set; }

            [JsonProperty("Excluded Item Short Names")] 
            public List<string> ExcludedItemShortNames { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            if (string.Compare(_config.Version, "2.1.0") < 0)
            {
                _config.IncludeNPCInStats = defaultConfig.IncludeNPCInStats;
            }

            if (string.Compare(_config.Version, "2.2.0") < 0)
            {
                _config.ExcludedItemShortNames = defaultConfig.ExcludedItemShortNames;
            }

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                WeaponNameFormat = "{weaponName}\nKills: {kills}, Hits: {shotsHit}, Shots: {shotsFired}",
                IncludeNPCInStats = false,
                ExcludedItemShortNames = new List<string>()
                {
                    "explosive.timed",
                    "explosive.satchel",
                    "grenade.f1",
                    "grenade.beancan"
                }
            };
        }

        #endregion Configuration

        #region Data

        private class WeaponStats
        {
            public int Kills { get; set; }
            public int ShotsFired { get; set; }
            public int ShotsHit { get; set; }
        }

        #endregion Data

        #region Oxide Hooks

        private void Init()
        {
            _plugin = this;
            PermissionUtil.RegisterPermissions();
        }

        private void Unload()
        {
            _config = null;
            _plugin = null;
        }

        private void OnPlayerDeath(BasePlayer victim, HitInfo hitInfo)
        {
            if (hitInfo == null || victim == null)
                return;

            BasePlayer killer = hitInfo.InitiatorPlayer;
            if (killer == null || killer.IsNpc)
                return;

            if (!PermissionUtil.VerifyHasPermission(killer))
                return;

            if (killer == victim)
                return;

            Item item = killer.GetActiveItem();
            if (item == null || _config.ExcludedItemShortNames.Contains(item.info.shortname))
                return;

            if (!_config.IncludeNPCInStats && victim.IsNpc)
                return;

            UpdateWeaponStats(item, addKills: 1);
        }

        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player)
        {
            if (projectile == null || player == null)
                return;

            if (!PermissionUtil.VerifyHasPermission(player))
                return;

            Item item = projectile.GetItem();
            if (item == null || _config.ExcludedItemShortNames.Contains(item.info.shortname))
                return;

            UpdateWeaponStats(item, addShotsFired: 1);
        }

        private void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (hitInfo == null || player == null)
                return;

            BasePlayer killer = hitInfo.InitiatorPlayer;
            if (killer == null || killer.IsNpc)
                return;

            if (!PermissionUtil.VerifyHasPermission(killer))
                return;

            if (killer == player)
                return;

            Item item = killer.GetActiveItem();
            if (item == null || _config.ExcludedItemShortNames.Contains(item.info.shortname))
                return;

            if (!_config.IncludeNPCInStats && player.IsNpc)
                return;

            UpdateWeaponStats(item, addShotsHit: 1);
        }

        #endregion Oxide Hooks

        #region Functions

        private void UpdateWeaponStats(Item weapon, int addKills = 0, int addShotsHit = 0, int addShotsFired = 0)
        {
            WeaponStats stats;
            if (!_weaponStats.TryGetValue(weapon.uid.Value, out stats))
            {
                stats = new WeaponStats();
                _weaponStats[weapon.uid.Value] = stats;
            }

            stats.Kills += addKills;
            stats.ShotsHit += addShotsHit;
            stats.ShotsFired += addShotsFired;

            UpdateWeaponName(weapon, stats);
        }

        private void UpdateWeaponName(Item weapon, WeaponStats stats)
        {
            string formattedName = _config.WeaponNameFormat
                .Replace("{weaponName}", weapon.info.displayName.english)
                .Replace("{kills}", stats.Kills.ToString())
                .Replace("{shotsFired}", stats.ShotsFired.ToString())
                .Replace("{shotsHit}", stats.ShotsHit.ToString());

            weapon.name = formattedName;
            weapon.MarkDirty();
        }

        #endregion Functions

        #region Utility Classes

        private static class PermissionUtil
        {
            public const string USE = "gunstats.use";

            public static void RegisterPermissions()
            {
                _plugin.permission.RegisterPermission(USE, _plugin);
            }

            public static bool VerifyHasPermission(BasePlayer player, string permissionName = USE)
            {
                return _plugin.permission.UserHasPermission(player.UserIDString, permissionName);
            }
        }

        #endregion Utility Classes
    }
}


// --- End of file: GunStats.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/gui-shop ---
// --- Original File Path: G/GUIShop/GUIShop.cs ---

﻿using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using Rust;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Steamworks;
using WebSocketSharp;
using Physics = UnityEngine.Physics;

/********************************************************
 *  Follow the status on https://trello.com/b/BCm6PUwK/guishop   __φ(．．)

 *  Credits to Nogrod and Reneb for the original plugin. <Versions up to 1.4.6
 *  Thanks! to Default for maintaining and adding in feature updates over the years.  <versions 1.4.65 to 1.5.9

 *  Current Maintainer: 8/14/2020 Khan#8615 discord ID.  1.6.0  to Present.
 *  Imported Auto Config Updater by WhiteThunder! ◝(⁰▿⁰)◜
 *  Thanks to Baz/Hockeygel/Whispers/Mr.Blue
 * -----------------------------------------------------------

 *  TODO:
 * Add Theme Switcher
 * Add BLuePrint Generation option
 * Add TC or Backpack option to store custom currency (seeking alternative)..
 * Update all Language Translations
 * Add support for Prerequisite item
 * Add Vending Machine Support
 *******************************************************/

/*****
* This release Update 2.1.0
 * Added NPC Checks
 * Updated to latest kits support but hook reversed back to default so was pointless
 * Added missing message response
 * Added Discord Embed Logging for Buy & Sell + Error logging
 *
 * This Update 2.2.0
 * Added SkinID support to custom currency
 * Added Custom Name support to custom currency
 * Added Shop Permissions
 * Slight Load Balance tweak to fix possible reload issues
 * Added Per shop currency options/else uses global defaults.
 * Updated German Lang file (Delete only the old Germ Lang file optional)
 * Added GetCurrency Hook
 * Updated OpenShop Hook
 *
 * This Update 2.2.1
 * Added Per Shop color options for both Display Name and Shop Descriptions
 * Added GUIShop Display Button on Left side. (Feature Request)
 * Added Button Permission
 * Right side config setting option
 * "Offsets Min": "185 18",
 * "Offsets Max": "245 78",
 *
 * This Update 2.2.2
 * Converted GUIShop Button to RGBA format Hex is glitched..
 *
 * This Update 2.2.3
 * Fixed Custom Items with Skin ID issues not being able to be sold.
 *
 * This Update 2.2.31
 * Fixed Custom Commands Issues
 * Added Null checks for custom shop currency id's being blank or null to prevent item/money loss!
 *
 * This update 2.2.40
 * Fully repaired ImageLibrary bugs
 * SkinId support is working properly now for Imagelibrary
 * Added Blueprint support for buy only! Cannot sell.
 * Added manual update command to update the Image URL links accordingly.
 * Update Command Requires Admin permission. is in game command only. 
 * Updated All Lang files to fix the Coal item name typo..
 *
 * This update 2.2.41
 * Added null check for items that cannot be made a blueprint.
 *
 * This update 2.2.42
 * This update fixes ImageLibrary Error on server reboot.
 *
 * This update 2.2.43
 * Patches multi command 
 * Slightly changed discord embed messages to fix multi command issues
 * Added discord Logging feature update to show the spawn cords
 * Added Old config option back {1, 10, 100, 1000} now is a global default setting if none of the others are set.
 * Now supports decimal numbers for economics. 0.33 etc
 * Added Command and Custom Item Buy support as the same item with a true/false toggle.
 * Added Toggle for creating the custom items as there DisplayNames
 *
 * This update 2.2.44 beta update
 * Added a cooldown setting to prevent players from being able to shop right away until x time has passed after each server wipe occurs.
 * Separated buy/sell all buttons into individual config toggle options.
 *
 * This update 2.2.45 beta update
 * Added Limiter Feature for Buy/Sell
 * Both will be enabled by default so set to false if you don't want them on!
 * If you set a cooldown on the item and a limit the cooldown will run each time -
 - they buy an item same for the sell-side they are both separate
 
 * This update 2.2.47 released.
 * Added a cooldown setting to prevent players from being able to shop right away until x time has passed after each server wipe occurs.
 * Separated buy/sell all buttons into individual config toggle options.
 * Added Limiter Feature for Buy/Sell
 * Both will be enabled by default so set to false if you don't want them on!
 * If you set a cooldown on the item and a limit the cooldown will run each time -
 - they buy an item same for the sell-side they are both separate
 * Added Buy/Sell Limit Reset CoolDown options
 * Fixed BUY All button problem caused from update 2.0.10 ( 7 months ago ).
 * Added limits.clear Console Command Requires Admin permission ( for guishop ).
 * clears entire data file for limits ( includes coodlown timers )
 * Added transactions.clear Console Command Requires Admin permission ( for guishop ).
 * clears entire data file for buy/sell cooldowns
 
 * This update 2.2.48
 * Fixed Sell All button issues relating to custom items with skinid's
 * Added Support for multiple npc's to be assigned to shops.
 *
 * This update 2.3.0 / Major HotFix Update!
 * Fixed item leak when taking items from players
 * Fixed Reloading issues where ram usage would keep being taken up from Image Library calls.
 * No longer uses //requires ( due to issues with it )
 * Updated Currency Systems
 * Created Whole new Item Creation methods
 * Created Whole new Item Give methods
 * Updated/re-wrote Get and Take Methods to include new feature support + fix old feature support checks
 * Fixed issues with buying commands when inventory was full
 * Fixed issues with buying items when command strings were not null but empty
 * Fixed Custom Item names not being applied to items bought correctly
 * Updated permission name error response to catch other plugins that improperly code..
 * Preparations for the new HumanNPC plugin in development finished
 * Preparations for the Nomad Shop Plugin NPC done
 * Added Requested Hooks
 * Added Condition Level Support - Condition levels that default to 0 are not supported.
 * Added Allow Or Not Allow selling of used Items
 * All items that are broken are no longer counted for selling in guishop! 
 * All items are preset to max default condition values. ( changing these to 0 will result in items being bought as broken items )
 * Updated Updater Command please run it in-game and make sure you have the guishop.admin perm! /update
 * ( Updater command now only checks for any item condition set to 0 and will auto add the correct value for it if it supports conditions )
 * Added a /resetconditions command for those that need to reset only item config conditions back to defaults.
 * Added Missing Sunglasses to item generation list
 * Adding pooling for UI creation for better performance and faster page switching
 * Added LangAPI translation support for all 30 langs!
 * Added Russian support
 * Updated/fixed all 10 language translations
 * Fixed All Button Error Response issues / limit triggers
 * Added Full genetics support fer buyin' plants & seeds.
 * Added missing lang responses
 * Fixed GUIShop permission issues
 *
 * Update 2.3.1
 * Fixed Player Message Response not showing relating to npcs and shop permissions.
 * Fixed Transparency changer buttons when using NPC shops
 *
 * Update 2.3.2
 * Added New config option and increased Library check count to 15.
 * Fixed players currency money not showing correctly specific to custom currencies per shop.
 * performance update on get method /
 * Fixed message response for custom currencies
 *

 * From version 2.3.2 to 2.3.15, The following issues have been fixed.

Note: If you have not yet updated to 2.3.1 or higher you need to run the /update
* command in-game so that your configs get updated with the latest feature additions/requests.
* Fixed Button Feature update. ( Was missing a page sometimes )
* Substantially reduced Image Library load order times.
* Added a new page switching feature the forward/back buttons will only show 
if there is more than 1 page and if you are not on the last page.

* Fixed Economics bug when trying to use 0.01 as a currency amount for selling.
* Fixed an issue when buying if a player's inventory is full 
it would send the message response saying your inventory is full, not enough space.
But it would still take the money and not give them anything.
* Resolves Custom Stack Size issues
* when using Stack Size Controller ( would end up with more )
* when using stack modifier ( would end up with less sometimes ) etc
* Fixed Another Possible Item Leak problem / ( if an item was not null but failed )
* Fixed shops set to use "custom" and a player attempts to buy something 
with 0 scrap outputting wrong msg response.

* Updated /shop-specific command checks, in regards to permission-based shops.
* Code Cleanup.
* Fixed an issue that occurs specifically with odd server stack sizes.
* Relating to buying items in bulk, players would end up with 1 or two extra sometimes.
( IDK how this didn't get reported months ago as an issue )
* Fixed selling for items with 100% condition and only = 1
Complete list from 2.2.48 to latest release of changes/repairs can be found here
https://umod.org/community/gui-shop/40000-2248-to-2315-update-notes

 * This Update 2.3.16
 * Updated to ignore 3rd party plugin npcs trying to access the shops.
 *
 * Update 2.3.17
 * Added auto wipe for data files on new map saves. ( default is true )
 * Added Experimental Economics support for beta update pending.
 *
 * Update 2.3.18
 * Updated TryGiveChecks work around for fixing snowmobiles not spawning via commands
 *
 * update 2.3.191
 * Fixed limit count starting wrong
 * Fixed A Currency Bug
 * Fixed msg
 *
 * update 2.3.192
 * Fixed selling items that had condition values below 80% not being able to be sold when enabled true.
 *
 * Update 2.3.193
 * Fixed items with custom skin ids not updating / showing correctly inside the UI!
 *
 * Update 2.4.0
 * Now Using Native Facepunch logic for fetching default images + skins for shop items
 * Only using ImageLibrary for very limited things
 * Massive performance boost!
 * Fixed Shop Color Changing / Transparency Changing Bugs not remembering your last Shop TAB
 * Fixed Some Images Not updating in very special use cases
 * Fixed Image Library not loading the order properly after a server restarts
 * Improved Message response outputs in console when / if image library is being waited on/for.
 * Huge performance improvements for when you first load onto a server && when reloading the plugin
 * No longer causes performance/lag spikes on high pop servers when re-loading
 *
 * Update 2.4.2
 * Added /updateold ( in game chat command requires guishop.admin)
for really old configs that did not follow the old update notes from like 11months back??

 * Fixed Default shop to open not being displayed correctly, and just opening the first shop in the list to show player.
 *
 * Update 2.4.3
 * Updated UI Display for Limit Counts so players can see the counter values change now
 * Updated Config support scenarios to expand deeper scenario settings
 * Updated Limits code to support new features
 * Updated UI Systems for showing players by caching as much as possible
 * UI System no longer constantly free's up the pooling resulting in the pool having to be re-created each time increasing garbage collections etc.
 * Higher Pop server should notice some more performance gains the most.
 *
 * Update 2.4.4
 * Added New Experimental Config Options SwapLimitToQuantityBuyLimit & SwapLimitToQuantitySoldLimit
 * Toggling True results in buy quantities subtracting from the total Limit Count instead of subtracting 1
 * Updated all cooldown logic & limits again
 * Added Emergency Hotfix for F1 Commands exploit!
 *
 * Update 2.4.41
 * Now Double Checks Data file systems on Load & Unload
 * Now Properly Checks NPC Ranges for F1 commands on shops with only NPCs setup on them
 * Now Properly Handles F1 Commands and respects shop categories settings + shop item settings
 * F1 Buy / Sell All Functions are now blocked
 * F1 transaction amount support can be specified by the player & respects the currency values
 * F1 Transactions should properly reset cooldowns on items as well without having to open the UI
 * If all global shops are disabled & players have GUIShop.Button perm it will no longer show
 *
 * update 2.4.42
 * fixed /shop command erroring in console if all shop categories have been disabled.
 * Added New config toggle [JsonProperty("Shop - GUIShop Enable Background Image")]
public bool BackgroundImage = true;
 * Added up to 16 shop tabs in a single row now & supports 2 rows now totalling 32 shops
 *
 * Update 2.4.43
 * Fixed an issue with 2 config toggle settings relating to SR & E
 * Updated UI System to support 2 more shop fields & cleaned up generation code a bit
 * Added up to 17 shop tabs in a single row now & supports 2 rows now totalling 34! shops
 * Couple minor bug fixes where for the shop was null in a weird use case.
 * Fixed a msg response saying bought 0 even though you got the items & it took the money properly.
 *
 * Update 2.4.44
 * Fixed GUIShop button & updated some text.
 *
 * Update 2.4.45
 * Performance Update
 * Fixed /shop NRE
 * Other Tweaks / Fixes in regards to giving out currency specifically
 * Updated for Staging changes
 *
 * Update 2.4.46
 * permission guishop.blockbypass is now only for global /shop's ( to shop while at monuments etc )
 * Fixed NPC shops from not being excluded in CanBuild Checks.
 * Removed redundant checks in console commands.
 * Lets noescape handle blocking if installed.
 *
 * Update 2.4.47
 * Updated method name facepunch changed from FindItemsByItemName to FindItemByItemName.
*/

namespace Oxide.Plugins
{
    [Info("GUIShop", "Khan", "2.4.48")]
    [Description("GUI Shop Supports all known Currency, with NPC support - Re-Write Edition 2")]
    public class GUIShop : RustPlugin
    {
        #region References

        [PluginReference] Plugin Economics, Kits, ImageLibrary, ServerRewards, LangAPI;

        #endregion

        #region Fields

        private bool _isRestart = true;
        private bool _isShopReady;
        private bool _isLangAPIReady;
        private bool _isEconomicsLimits;
        private bool _isEconomicsDebt;
        private KeyValuePair<int, int> _balanceLimits;
        private Dictionary<string, string> _imageListGUIShop;
        private List<KeyValuePair<string, ulong>> _guishopItemIcons;

        private const string GUIShopOverlayName = "GUIShopOverlay";
        private const string GUIShopContentName = "GUIShopContent";
        private const string GUIShopDescOverlay = "GUIShopDescOverlay";
        private const string GUIShopColorPicker = "GUIShopColorPicker";
        private const string BlockAllow = "guishop.blockbypass";
        private const string Use = "guishop.use";
        private const string Admin = "guishop.admin";
        //private const string Vip = "guishop.vip";
        private const string Color = "guishop.color";
        private const string Button = "guishop.button";

        private int _imageLibraryCheck = 0;
        private Hash<ulong, int> _shopPage = new Hash<ulong, int>();
        private Dictionary<ulong, Dictionary<string, double>> _sellCoolDownData;
        private Dictionary<ulong, Dictionary<string, double>> _buyCooldownData;
        private Dictionary<ulong, Dictionary<string, double>> _buyLimitResetCoolDownData;
        private Dictionary<ulong, Dictionary<string, double>> _sellLimitResetCoolDownData;
        private Dictionary<string, ulong> _boughtData;
        private Dictionary<string, ulong> _soldData;
        private Dictionary<ulong, ItemLimit> _limitsData;
        readonly Dictionary<string, string> _headers = new Dictionary<string, string> {{"Content-Type", "application/json"}};
        private List<MonumentInfo> _monuments => TerrainMeta.Path.Monuments;
        private bool _configChanged;
        private int playersMask = LayerMask.GetMask("Player (Server)");

        //Caching Shop Images.
        private const string GUIShopWelcomeImage = "GUIShopWelcome";
        private const string GUIShopBackgroundImage = "GUIShopBackground";
        private const string GUIShopAmount1Image = "GUIShopAmount1";
        private const string GUIShopAmount2Image = "GUIShopAmount2";
        private const string GUIShopBuyImage = "GUIShopBuy";
        private const string GUIShopSellImage = "GUIShopSell";
        private const string GUIShopBackArrowImage = "GUIShopBackArrow";
        private const string GUIShopForwardArrowImage = "GUIShopForwardArrow";
        private const string GUIShopCloseImage = "GUIShopClose";
        private const string GUIShopShopButton = "GUIShopButton";

        //Auto Close
        private HashSet<string> playerGUIShopUIOpen = new HashSet<string>();

        private Dictionary<string, PlayerUISetting> _playerUIData;
        private string _uiSettingChange = "Text";
        private bool _imageChanger;
        private double Transparency = 0.95;
        private PluginConfig _config;
        private static GUIShop _instance;

        //Shop Button
        private HashSet<string> _playerDisabledButtonData;

        private readonly Dictionary<string, string> _corrections = new Dictionary<string, string>
        {
            {"sunglasses02black", "Sunglasses Style 2"},
            {"sunglasses02camo", "Sunglasses Camo"},
            {"sunglasses02red", "Sunglasses Red"},
            {"sunglasses03black", "Sunglasses Style 3"},
            {"sunglasses03chrome", "Sunglasses Chrome"},
            {"sunglasses03gold", "Sunglasses Gold"},
            {"twitchsunglasses", "Sunglasses Purple"},
            {"innertube", "Inner Tube"},
            {"innertube.horse", "Inner Tube Horse"},
            {"innertube.unicorn", "Inner Tube Unicorn"},
        };

        #endregion

        #region Config

        private readonly HashSet<string> _exclude = new HashSet<string>
        {
            "vehicle.chassis",
            "vehicle.module"
        };

        internal class PluginConfig : SerializableConfiguration
        {
            [JsonProperty("Carefully Edit This")]
            public CarefullyEdit Time = new CarefullyEdit();
            
            [JsonProperty("Wipe GUIShop Data files on Map Changes / Server Wipes & if server save file is deleted")]
            public bool AutoWipe = true;

            [JsonProperty("Sets the ImageLibrary Counter Check ( Set higher if needed for server restarts )")]
            public int ImageLibraryCounter = 15;

            [JsonProperty("Enable Discord Buy Transaction Logging")]
            public bool EnableDiscordLogging;

            [JsonProperty("Enable Discord Sell Transaction Logging")]
            public bool EnableDiscordSellLogging;

            [JsonProperty("Discord Webhook URL")]
            public string DiscordWebHookURL = "";

            [JsonProperty("Discord Embed Color")]
            public string DiscordColor = "#483D8B";

            [JsonProperty("Discord Author Image")]
            public string DiscordAuthorImage = "https://assets.umod.org/images/icons/plugin/5f80fe12851f5.png";

            [JsonProperty("Discord Embed Icon")] 
            public string DiscordAuthorName = "GUIShop";

            [JsonProperty("Set Default Global Shop to open")]
            public string DefaultShop = "Commands";

            [JsonProperty("Sets shop command")] 
            public string shopcommand = "shop";

            [JsonProperty("Sets Vehicle Spawn Distance")]
            public float SpawnDistance = 15f;

            [JsonProperty("Switches to Economics as default curency")]
            public bool Economics = true;

            [JsonProperty("Switches to ServerRewards as default curency")]
            public bool ServerRewards = false;

            [JsonProperty("Switches to Custom as default curency")]
            public bool CustomCurrency = false;

            [JsonProperty("Allow Custom Currency Sell Of Used Items")]
            public bool CustomCurrencyAllowSellOfUsedItems;

            [JsonProperty("Custom Currency Item ID")]
            public int CustomCurrencyID = -932201673;

            [JsonProperty("Custom Currency Skin ID")]
            public ulong CustomCurrencySkinID = 0;

            [JsonProperty("Custom Currency Name")]
            public string CustomCurrencyName = "";

            [JsonProperty("Allows you to specify which containers you can sell items from")]
            public InventoryTypes AllowedSellContainers = InventoryTypes.ContainerAll;

            [JsonProperty("Enable Shop Buy All Button")]
            public bool BuyAllButton = true;

            [JsonProperty("Enable Shop Sell All Button")]
            public bool SellAllButton = true;

             [JsonProperty("Sets the buy/Sell button amounts + how many buttons")]
             public int[] steps = { 1, 10, 100, 1000 };

            [JsonProperty("Player UI display")] 
            public bool PersonalUI = false;

            [JsonProperty("Block Monuments")] 
            public bool BlockMonuments = false;

            [JsonProperty("If true = Images, If False = Text Labels")]
            public bool UIImageOption = false;

            [JsonProperty("NPC Distance Check")] 
            public float NPCDistanceCheck = 2.5f;

            [JsonProperty("Enable NPC Auto Open")] 
            public bool NPCAutoOpen = false;

            [JsonProperty("Enable GUIShop NPC Msg's")]
            public bool NPCLeaveResponse = false;

            [JsonProperty("GUI Shop - Welcome MSG")]
            public string WelcomeMsg = "WELCOME TO GUISHOP ◝(⁰▿⁰)◜";

            [JsonProperty("Shop - Buy Price Label")]
            public string BuyLabel = "Buy Price";

            [JsonProperty("Shop - Amount1 Label1")]
            public string AmountLabel = "Amount";

            [JsonProperty("Shop - Sell $ Label")] 
            public string SellLabel = "Sell $";

            [JsonProperty("Shop - Amount2 Label2")]
            public string AmountLabel2 = "Amount";

            [JsonProperty("Shop - Back Button Text")]
            public string BackButtonText = "<<";

            [JsonProperty("Shop - Forward Button Text")]
            public string ForwardButtonText = ">>";

            [JsonProperty("Shop - Close Label")] 
            public string CloseButtonlabel = "CLOSE";

            [JsonProperty("Shop - GUIShop Welcome Url")]
            public string GuiShopWelcomeUrl = "https://i.imgur.com/RcLdEly.png";
            
            [JsonProperty("Shop - GUIShop Enable Background Image")]
            public bool BackgroundImage = true;

            [JsonProperty("Shop - GUIShop Background Image Url")]
            public string BackgroundUrl = "https://i.imgur.com/Jej3cwR.png";

            [JsonProperty("Shop - Sets any shop items to this image if image link does not exist.")]
            public string IconUrl = "https://imgur.com/BPM9UR4.png";

            [JsonProperty("Shop - Shop Buy Icon Url")]
            public string BuyIconUrl = "https://imgur.com/oeVUwCy.png";

            [JsonProperty("Shop - Shop Amount Left Url")]
            public string AmountUrl = "https://imgur.com/EKtvylU.png";

            [JsonProperty("Shop - Shop Amount Right Url")]
            public string AmountUrl2 = "https://imgur.com/EKtvylU.png";

            [JsonProperty("Shop - Shop Sell Icon Url")]
            public string SellIconUrl = "https://imgur.com/jV3hEHy.png";

            [JsonProperty("Shop - Shop Back Arrow Url")]
            public string BackButtonUrl = "https://imgur.com/zNKprM1.png";

            [JsonProperty("Shop - Shop Forward Arrow Url")]
            public string ForwardButtonUrl = "https://imgur.com/qx9syT5.png";

            [JsonProperty("Shop - Close Image Url")]
            public string CloseButton = "https://imgur.com/IK5yVrW.png";

            [JsonProperty("Shop GUI Button")]
            public GUIButton GUI = new GUIButton();

            [JsonProperty("GUIShop Configurable UI colors (First 8 Colors!)")]
            public HashSet<string> ColorsUI = new HashSet<string>();

            [JsonProperty("Set Default Shop Buy Color")]
            public string BuyColor = "#FFFFFF";

            [JsonProperty("Set Default Shop Sell Color")]
            public string SellColor = "#FFFFFF";

            [JsonProperty("Set Default Shop Text Color")]
            public string TextColor = "#FFFFFF";

            [JsonProperty("Was Saved Don't Touch!")]
            public bool WasSaved;

            [JsonProperty("Shop - Shop Categories")]
            public Dictionary<string, ShopCategory> ShopCategories = new Dictionary<string, ShopCategory>();

            [JsonProperty("Shop - Shop List")] 
            public Dictionary<string, ShopItem> ShopItems = new Dictionary<string, ShopItem>();

            public string ToJson() => JsonConvert.SerializeObject(this);
            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        public class ShopItem
        {
            public string DisplayName;
            public bool CraftAsDisplayName = false;
            public string Shortname;
            public int ItemId;
            public bool MakeBlueprint = false;
            public bool AllowSellOfUsedItems = false;
            public float Condition;
            public bool EnableBuy = true;
            public bool EnableSell = true;
            public string Image = "";
            public double SellPrice;
            public double BuyPrice;
            public int BuyCooldown;
            public int SellCooldown;
            public int[] BuyQuantity = {};
            public int[] SellQuantity = {};

            //public string Prerequisite;
            public int BuyLimit = 0;
            public int BuyLimitResetCoolDown = 0;
            public bool SwapLimitToQuantityBuyLimit;
            public int SellLimit = 0;
            public int SellLimitResetCoolDown = 0;
            public bool SwapLimitToQuantitySoldLimit;
            public string KitName = "";
            public List<string> Command = new List<string>();
            public bool RunCommandAndCustomShopItem = false;
            public List<char> GeneTypes = new List<char>();
            public ulong SkinId;

            public double GetSellPrice(string playerId="")
            {
                var hook = Interface.CallHook("GUIShopSellPrice", JObject.FromObject(this), (string)playerId);
                return hook != null ? (double)hook : SellPrice;
            }

            public double GetBuyPrice(string playerId="")
            {
                var hook = Interface.CallHook("GUIShopBuyPrice", JObject.FromObject(this), (string)playerId);
                return hook != null ? (double)hook : BuyPrice;
            }
        }

        public class ShopCategory
        {
            public string DisplayName;
            public string DisplayNameColor = null;
            public string Description;
            public string DescriptionColor = null;
            public string Permission = "";
            [JsonIgnore]
            public string PrefixPermission => "guishop." + Permission;
            public string Currency = "";
            public bool CustomCurrencyAllowSellOfUsedItems;
            public string CustomCurrencyNames = "";
            public int CustomCurrencyIDs = -0;
            public ulong CustomCurrencySkinIDs = 0;
            public bool EnabledCategory;

            //public bool BluePrints;
            public bool EnableNPC;
            public string NPCId = "";
            public List<string> NpcIds = new List<string>();
            public HashSet<string> Items = new HashSet<string>();
            [JsonIgnore] public HashSet<ShopItem> ShopItems;
        }

        public class ItemLimit
        {
            public Dictionary<string, int> BLimit = new Dictionary<string, int>();
            public Dictionary<string, int> SLimit = new Dictionary<string, int>();
            public bool CheckSellLimit(string item, int amount)
            {
                if (!SLimit.ContainsKey(item))
                {
                    SLimit[item] = 0;
                }

                return SLimit[item] >= amount;
            }
            public void IncrementSell(string item, int amount, bool toggle)
            {
                if (!toggle)
                    SLimit[item]++;
                else
                    SLimit[item] += amount;
            }

            public bool CheckBuyLimit(string item, int amount)
            {
                if (!BLimit.ContainsKey(item))
                {
                    BLimit[item] = 0;
                }

                return BLimit[item] >= amount;
            }
            public void IncrementBuy(string item, int amount, bool toggle)
            {
                if (!toggle)
                    BLimit[item]++;
                else
                    BLimit[item] += amount;
            }
        }

        private class PlayerUISetting
        {
            public double Transparency;
            public string SellBoxColors;
            public string BuyBoxColors;
            public string UITextColor;
            public double RangeValue;
            public bool ImageOrText;
            public string ShopKey;
        }

        public class GUIButton
        {
            [JsonProperty(PropertyName = "Image")]
            public string Image = "https://i.imgur.com/hc0qPet.png";

            [JsonProperty(PropertyName = "Background color (RGBA format)")]
            public string Color = "1 0.96 0.88 0.15";

            [JsonProperty(PropertyName = "GUI Button Position")]
            public Position GUIButtonPosition = new Position();
            public class Position
            {
                [JsonProperty(PropertyName = "Anchors Min")]
                public string AnchorsMin = "0.5 0.0";

                [JsonProperty(PropertyName = "Anchors Max")]
                public string AnchorsMax = "0.5 0.0";

                [JsonProperty(PropertyName = "Offsets Min")]
                public string OffsetsMin = "-265 18";

                [JsonProperty(PropertyName = "Offsets Max")]
                public string OffsetsMax = "-205 78";
            }
        }

        public class CarefullyEdit
        {
            public string WipeTime = DateTime.Now.ToString("u");
            public string LastWipe = DateTime.Now.ToString("u");
            [JsonProperty("Sets time before shops can be used after the server wipes")]
            public float CanShopIn = 300f;
        }

        private void CheckConfig()
        {
            if (!_config.ShopCategories.ContainsKey("Commands"))
            {
                _config.ShopCategories.Add("Commands", new ShopCategory
                {
                    DisplayName = "Commands",
                    DisplayNameColor = null,
                    Description = "You currently have {0} coins to spend in the commands shop",
                    DescriptionColor = null,
                    Permission = "",
                    Currency = "",
                    CustomCurrencyNames = "",
                    CustomCurrencyIDs = -0,
                    CustomCurrencySkinIDs = 0,
                    EnabledCategory = true,
                    //BluePrints = false
                });
                //_configChanged = true;
            }

            if (_config.ShopCategories.ContainsKey("Commands") && !_config.ShopItems.ContainsKey("Minicopter") &&
                !_config.ShopItems.ContainsKey("Sedan") && !_config.ShopItems.ContainsKey("Airdrop Call"))
            {
                _config.ShopItems.Add("Minicopter", new ShopItem
                {
                    DisplayName = "Minicopter",
                    Shortname = "minicopter",
                    CraftAsDisplayName = false,
                    MakeBlueprint = false,
                    EnableBuy = true,
                    EnableSell = false,
                    Image = "https://i.imgur.com/vI6LwCZ.png",
                    Condition = 0,
                    BuyPrice = 1.0,
                    SellPrice = 1.0,
                    BuyCooldown = 0,
                    SellCooldown = 0,
                    BuyQuantity = {},
                    SellQuantity = {},
                    BuyLimit = 0,
                    BuyLimitResetCoolDown = 0,
                    SellLimit = 0,
                    SellLimitResetCoolDown = 0,
                    KitName = "",
                    Command = new List<string> {"spawn minicopter \"$player.x $player.y $player.z\""},
                    RunCommandAndCustomShopItem = false,
                    SkinId = 0,
                });

                _config.ShopItems.Add("Sedan", new ShopItem
                {
                    DisplayName = "Sedan",
                    Shortname = "sedan",
                    CraftAsDisplayName = false,
                    MakeBlueprint = false,
                    EnableBuy = true,
                    EnableSell = false,
                    Image = "",
                    Condition = 0,
                    BuyPrice = 1.0,
                    SellPrice = 1.0,
                    BuyCooldown = 0,
                    SellCooldown = 0,
                    BuyQuantity = {},
                    SellQuantity = {},
                    BuyLimit = 0,
                    BuyLimitResetCoolDown = 0,
                    SellLimit = 0,
                    SellLimitResetCoolDown = 0,
                    KitName = "",
                    Command = new List<string> {"spawn sedan \"$player.x $player.y $player.z\""},
                    RunCommandAndCustomShopItem = false,
                    SkinId = 0,
                });

                _config.ShopItems.Add("Airdrop Call", new ShopItem
                {
                    DisplayName = "Airdrop Call",
                    Shortname = "airdrop.call",
                    ItemId = 1397052267,
                    CraftAsDisplayName = false,
                    MakeBlueprint = false,
                    EnableBuy = true,
                    EnableSell = false,
                    Image = "",
                    Condition = 0,
                    BuyPrice = 1.0,
                    SellPrice = 1.0,
                    BuyCooldown = 0,
                    SellCooldown = 0,
                    BuyQuantity = {},
                    SellQuantity = {},
                    BuyLimit = 0,
                    BuyLimitResetCoolDown = 0,
                    SellLimit = 0,
                    SellLimitResetCoolDown = 0,
                    KitName = "",
                    Command = new List<string> {"inventory.giveto $player.id supply.signal"},
                    RunCommandAndCustomShopItem = false,
                    SkinId = 0,
                });

                _config.ShopCategories["Commands"].Items.Add("Minicopter");
                _config.ShopCategories["Commands"].Items.Add("Sedan");
                _config.ShopCategories["Commands"].Items.Add("Airdrop Call");
            }

            foreach (var item in _config.ShopItems.Values)
            {
                if (item.ItemId == 0 && !string.IsNullOrEmpty(item.Shortname) && ItemManager.FindItemDefinition(item.Shortname) != null)
                {
                    item.ItemId = ItemManager.FindItemDefinition(item.Shortname).itemid;
                    _configChanged = true;
                }
            }

            foreach (ItemDefinition item in ItemManager.itemList)
            {
                string categoryName = item.category.ToString();

                ShopCategory shopCategory;

                if (!_config.ShopCategories.TryGetValue(categoryName, out shopCategory))
                {
                    _config.ShopCategories[categoryName] = shopCategory = new ShopCategory
                    {
                        DisplayName = item.category.ToString(),
                        DisplayNameColor = null,
                        Description = "You currently have {0} coins to spend in the " + item.category + " shop",
                        DescriptionColor = null,
                        Permission = "",
                        Currency = "",
                        CustomCurrencyAllowSellOfUsedItems = false,
                        CustomCurrencyNames = "",
                        CustomCurrencyIDs = -0,
                        CustomCurrencySkinIDs = 0,
                        EnabledCategory = true,
                        //BluePrints = false
                    };

                    //_configChanged = true;
                }

                string displayname = _corrections.ContainsKey(item.shortname) ? _corrections[item.shortname] : item.displayName.english;

                if (_exclude.Contains(item.shortname)) continue;

                if (!shopCategory.Items.Contains(displayname) && !_config.WasSaved)
                {
                    shopCategory.Items.Add(displayname);

                    _configChanged = true;
                }

                if (_config.ShopItems.ContainsKey(displayname) && _config.ShopItems[displayname].ItemId == 0)
                {
                    _config.ShopItems[displayname].ItemId = item.itemid;
                    _configChanged = true;
                }

                if (!_config.ShopItems.ContainsKey(displayname))
                {
                    _config.ShopItems.Add(displayname, new ShopItem
                    {
                        DisplayName = displayname,
                        CraftAsDisplayName = false,
                        Shortname = item.shortname,
                        MakeBlueprint = false,
                        AllowSellOfUsedItems = false,
                        Condition = item.condition.max,
                        EnableBuy = true,
                        EnableSell = true,
                        Image = "",
                        BuyPrice = 1.0,
                        SellPrice = 1.0,
                        BuyCooldown = 0,
                        SellCooldown = 0,
                        BuyQuantity = {},
                        SellQuantity = {},
                        BuyLimit = 0,
                        BuyLimitResetCoolDown = 0,
                        SellLimit = 0,
                        SellLimitResetCoolDown = 0,
                        KitName = "",
                        Command = new List<string>(),
                        RunCommandAndCustomShopItem = false,
                        SkinId = 0,
                        // Image = "https://rustlabs.com/img/items180/" + item.shortname + ".png"
                    });
                    _configChanged = true;
                }
            }

            if (_config.ColorsUI.Count <= 0)
            {
                _config.ColorsUI = new HashSet<string> {"#A569BD", "#2ECC71", "#E67E22", "#3498DB", "#E74C3C", "#F1C40F", "#F4F6F7", "#00FFFF"};
            }

            foreach (var key in _config.ShopCategories.Values)
            {
                if (!string.IsNullOrEmpty(key.NPCId))
                {
                    if (!key.NpcIds.Contains(key.NPCId))
                        key.NpcIds.Add(key.NPCId);

                    PrintWarning($"Auto Moved, Warning! This config option is being removed soon do not use! NPCId");
                    key.NPCId = String.Empty;
                    _configChanged = true;
                }
            }

            if (_configChanged)
            {
                _config.WasSaved = true;
                SaveConfig();
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    PrintToConsole($"Generating Config File for GUIShop");
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception ex)
            {
                PrintWarning("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
            }
        }

        protected override void LoadDefaultConfig() => _config = new PluginConfig();

        protected override void SaveConfig()
        {
            PrintToConsole($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #region Updater

        internal class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>().ToDictionary(prop => prop.Name, prop => ToObject(prop.Value));
                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue) token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        #endregion

        #endregion

        #region Storage

        private void LoadData()
        {
            try
            {
                _buyCooldownData = _buyCoolDowns.ReadObject<Dictionary<ulong, Dictionary<string, double>>>();
            }
            catch
            {
                _buyCooldownData = new Dictionary<ulong, Dictionary<string, double>>();
            }

            try
            {
                _sellCoolDownData = _sellCoolDowns.ReadObject<Dictionary<ulong, Dictionary<string, double>>>();
            }
            catch
            {
                _sellCoolDownData = new Dictionary<ulong, Dictionary<string, double>>();
            }
            
            try
            {
                _buyLimitResetCoolDownData = _buyLimitResetCoolDowns.ReadObject<Dictionary<ulong, Dictionary<string, double>>>();
            }
            catch
            {
                _buyLimitResetCoolDownData = new Dictionary<ulong, Dictionary<string, double>>();
            }
            
            try
            {
                _sellLimitResetCoolDownData = _sellLimitResetCoolDowns.ReadObject<Dictionary<ulong, Dictionary<string, double>>>();
            }
            catch
            {
                _sellLimitResetCoolDownData = new Dictionary<ulong, Dictionary<string, double>>();
            }

            try
            {
                _boughtData = _bought.ReadObject<Dictionary<string, ulong>>();
            }
            catch
            {
                _boughtData = new Dictionary<string, ulong>();
            }

            try
            {
                _soldData = _sold.ReadObject<Dictionary<string, ulong>>();
            }
            catch
            {
                _soldData = new Dictionary<string, ulong>();
            }

            try
            {
                _limitsData = _limits.ReadObject<Dictionary<ulong, ItemLimit>>();
            }
            catch
            {
                _limitsData = new Dictionary<ulong, ItemLimit>();
            }

            try
            {
                _playerUIData = _playerData.ReadObject<Dictionary<string, PlayerUISetting>>();
            }
            catch
            {
                _playerUIData = new Dictionary<string, PlayerUISetting>();
            }

            try
            {
                _playerDisabledButtonData = _buttonData.ReadObject<HashSet<string>>();
            }
            catch
            {
                _playerDisabledButtonData = new HashSet<string>();
            }
        }

        private void SaveData()
        {
            _buyCoolDowns.WriteObject(_buyCooldownData);
            _sellCoolDowns.WriteObject(_sellCoolDownData); 
            _buyLimitResetCoolDowns.WriteObject(_buyLimitResetCoolDownData);
            _sellLimitResetCoolDowns.WriteObject(_sellLimitResetCoolDownData);
            _bought.WriteObject(_boughtData);
            _sold.WriteObject(_soldData);
            _limits.WriteObject(_limitsData);
            _playerData.WriteObject(_playerUIData);
            _buttonData.WriteObject(_playerDisabledButtonData);
        }

        #endregion

        #region Lang File Messages

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"ShopInvalid", "This is not a shop <color=#32CD32>{0}</color> update default shop setting!\nAvailable Shops are:\n{1}"},
                {"Economics", "GUIShop did not recieve a response from the Economics plugin. Please ensure the Economics plugin is installed correctly."},
                {"EconomicsMaxDebt", "Transaction declined you are already at max economics debt"},
                {"EconomicsExceedsDebt", "Transaction declined this would exceed max economics debt limit of {0}"},
                {"CustomInvalidID", "Custom currency ID is not valid please update config for this shop {0}"},
                {"MaxEconomicsBalance", "Transaction declined your already at max economics limit"},
                {"EconomicsExceedsLimit", "Transaction declined this would exceed max earnable economics limit of {0}"},
                {"ServerRewards", "GUIShop did not recieve a response from the ServerRewards plugin. Please ensure the ServerRewards plugin is installed correctly."},
                {"TakeCurrency", "GUIShop has failed to take this currency upon purchase {0}"},
                {"Bought", "You've successfully bought {0} {1}."},
                {"Sold", "You've successfully sold {0} {1}."},
                {"Cooldown", "You can only purchase this item every {0} seconds."},
                {"InventoryFull", "Your inventory is full."},
                {"InventorySlots", "You need at least {0} free inventory slots."},
                {"ErrorShop", "There is something wrong with this shop. Please contact an admin."},
                {"GlobalShopsDisabled", "Global Shops are disabled. This server uses NPC vendors!"},
                {"DeniedActionInShop", "You are not allowed to {0} in this shop"},
                {"ShopItemItemInvalid", "WARNING: It seems like this sell item you have is not a valid item! Please contact an Admin!"},
                {"ItemNotValidbuy", "WARNING: It seems like it's not a valid item to buy, Please contact an Admin!"},
                {"ItemNotValidsell", "WARNING: It seems like it's not a valid item to sell, Please contact an Admin!"},
                {"RedeemKitFail", "WARNING: There was an error while giving you this kit, Please contact an Admin!"},
                {"NotKit", "This is not a valid kit name assigned to this shop item: {0}"},
                {"BuyCmd", "Can't buy multiple of this item!"},
                {"SellCmd", "Can't sell multiple of this item!"},
                {"BuyPriceFail", "WARNING: No buy price was given by the admin, you can't buy this item"},
                {"SellPriceFail", "WARNING: No sell price was given by the admin, you can't sell this item"},
                {"NotEnoughMoney", "You need {0} coins to buy {1}x {2}"},
                {"NotEnoughMoneyCustom", "You need {0} currency to buy {1}x {2}"},
                {"CustomCurrencyFail", "WANRING Admin has this shop called {0} set as custom currency but has not set a valid currency ID {1}"},
                {"NotEnoughSell", "You don't have enough of this item."},
                {"NotNothingShopFail", "You cannot buy Zero of this item."},
                {"ItemNoExist", "WARNING: The item you are trying to buy doesn't seem to exist! Please contact an Admin!"},
                {"ItemNoExistTake", "The item you are trying to sell is not sellable at this time."},
                {"ItemIsNotBlueprintable", "This shop item {0} cannot be set as a Blueprint!"},
                {"BuildingBlocked", "You cannot shop while in a building blocked area. "},
                {"BlockedMonuments", "You may not use the shop while near a Monument!"},
                {"ItemNotEnabled", "The shop keeper has disabled this item."},
                {"ItemNotFound", "Item was not found"},
                {"CantSellCommands", "You can not sell Commands back to the shop."},
                {"CantSellKits", "You can not sell Kits back to the shop."},
                //{"CannotSellWhileEquiped", "You can not sell the item if you have it Equipt."},
                {"GUIShopResponse", "GUIShop is waiting for ImageLibrary & LangAPI downloads to finish please wait."},
                {"NPCResponseClose", "Thanks for shopping at {0} come again soon!"},
                {"NPCResponseOpen", "Welcome to the {0} what would you like to purchase? Press E to start shopping!"},
                {"NoPerm", "You do not have permission to shop at {0}"},
                {"WipeReady", "Dear {0}, all shops are closed for \n {1} minutes"},
                {"ImageLibraryFailure", "ImageLibrary appears to be missing or occupied by other plugins load orders. GUIShop is unusable. \n Reload GUIShop and increase the config counter check limit to higher than {0}."},
                {"NoPermUse", "You do not have permission {0}"},
                {"Commands", "Commands"},
                {"Attire", "Attire"},
                {"Misc", "Misc"},
                {"Items", "Items"},
                {"Ammunition", "Ammunition"},
                {"Construction", "Construction"},
                {"Component", "Component"},
                {"Traps", "Traps"},
                {"Electrical", "Electrical"},
                {"Fun", "Fun"},
                {"Food", "Food"},
                {"Resources", "Resources"},
                {"Tool", "Tool"},
                {"Weapon", "Weapon"},
                {"Medical", "Medical"},
                {"Minicopter", "Minicopter"},
                {"Sedan", "Sedan"},
                {"Airdrop Call", "Airdrop Call"},
            }, this); //en

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Economics", "GUIShop n'a pas reçu de réponse du plugin Economics. Veuillez vous assurer que le plugin Economics est correctement installé."},
                {"EconomicsMaxDebt", "Transaction refusée, vous avez déjà une dette économique maximale"},
                {"EconomicsExceedsDebt", "Transaction refusée, cela dépasserait la limite d'endettement économique maximale de {0}"},
                {"CustomInvalidID", "L'ID de devise personnalisé n'est pas valide, la configuration nécessite une mise à jour pour cette boutique {0}"},
                {"MaxEconomicsBalance", "Transaction refusée, vous avez déjà atteint la limite économique maximale"},
                {"EconomicsExceedsLimit", "Transaction refusée, cela dépasserait la limite économique maximale de {0}"},
                {"ServerRewards", "GUIShop n'a pas reçu de réponse du plugin ServerRewards. Veuillez vous assurer que le plugin ServerRewards est correctement installé."},
                {"TakeCurrency", "GUIShop n'a pas réussi à prendre cette devise lors de l'achat {0}"},
                {"Bought", "Vous avez acheté {0} x {1} avec succès."},
                {"Sold", "Vous avez vendu {0} x {1} avec succès."},
                {"Cooldown", "Vous ne pouvez acheter cet article que toutes les {0} secondes."},
                {"InventoryFull", "Votre inventaire est plein."},
                {"InventorySlots", "Vous avez besoin d'au moins {0} emplacements d'inventaire gratuits."},
                {"ErrorShop", "Il y a un problème avec cette boutique. Veuillez contacter un administrateur."},
                {"GlobalShopsDisabled", "Les boutiques globales sont désactivées. Ce serveur utilise des vendeurs de PNJ!"},
                {"DeniedActionInShop", "Vous n'êtes pas autorisé à {0} dans cette boutique"},
                {"ShopItemItemInvalid", "AVERTISSEMENT: il semble que cet article que vous possédez n'est pas un article valide! Veuillez contacter un administrateur!"},
                {"ItemNotValidbuy", "AVERTISSEMENT: Il semble que ce ne soit pas un article valide à acheter, veuillez contacter un administrateur!"},
                {"ItemNotValidsell", "AVERTISSEMENT: Il semble que ce ne soit pas un article valide à vendre, veuillez contacter un administrateur!"},
                {"RedeemKitFail", "AVERTISSEMENT: Une erreur s'est produite lors de la remise de ce kit, veuillez contacter un administrateur!"},
                {"NotKit", "Ce n'est pas un nom de kit valide attribué à cet article de la boutique {0}"},
                {"BuyCmd", "Impossible d'acheter plusieurs exemplaires de cet article!"},
                {"BuyPriceFail", "AVERTISSEMENT: aucun prix d'achat n'a été donné par l'administrateur, vous ne pouvez pas acheter cet article"},
                {"SellPriceFail", "AVERTISSEMENT: aucun prix de vente n'a été donné par l'administrateur, vous ne pouvez pas vendre cet article"},
                {"NotEnoughMoney", "Vous avez besoin de {0} pièces pour acheter {1} sur {2}"},
                {"NotEnoughMoneyCustom", "Vous avez besoin de {0} devise pour acheter {1} x {2}"},
                {"CustomCurrencyFail", "L'administrateur WANRING a défini cette boutique appelée {0} comme devise personnalisée mais n'a pas défini d'ID de devise valide {1}"},
                {"NotEnoughSell", "Vous n'avez pas assez de cet article."},
                {"NotNothingShopFail", "Vous ne pouvez pas acheter Zero de cet article."},
                {"ItemNoExist", "AVERTISSEMENT: l'article que vous essayez d'acheter ne semble pas exister! Veuillez contacter un administrateur!"},
                {"ItemNoExistTake", "L'article que vous essayez de vendre n'est pas vendable pour le moment."},
                {"ItemIsNotBlueprintable", "Cet article de la boutique {0} ne peut pas être défini comme plan !"},
                {"BuildingBlocked", "Vous ne pouvez pas faire vos achats dans une zone de bâtiment bloquée."},
                {"BlockedMonuments", "Vous ne pouvez pas utiliser la boutique à proximité d'un monument!"},
                {"ItemNotEnabled", "Le commerçant a désactivé cet article."},
                {"ItemNotFound", "L'élément n'a pas été trouvé"},
                {"CantSellCommands", "Vous ne pouvez pas revendre les commandes à la boutique."},
                {"CantSellKits", "Vous ne pouvez pas revendre les kits à la boutique."},
                //{"CannotSellWhileEquiped", "Vous ne pouvez pas vendre l'objet si vous l'avez équipé."},
                {"GUIShopResponse", "GUIShop attend la fin des téléchargements d'ImageLibrary & LangAPI, veuillez patienter."},
                {"NPCResponseClose", "Merci pour vos achats chez {0} revenez bientôt!"},
                {"NPCResponseOpen", "Bienvenue dans le {0} que souhaitez-vous acheter? Appuyez sur E pour commencer vos achats!"},
                {"NoPerm", "Vous n'êtes pas autorisé à faire des achats chez {0}"},
                {"WipeReady", "Chère {0}, tous les magasins sont fermés pour \n {1} minutes"},
                {"ImageLibraryFailure", "ImageLibrary semble être manquant ou occupé par d'autres ordres de chargement de plugins. GUIShop est inutilisable. \n Rechargez GUIShop et augmentez la limite de vérification du compteur de configuration à plus de {0}"},
                {"NoPermUse", "Tu n'as pas la permission {0}"},
                {"Commands", "Commandes"},
                {"Attire", "Tenue"},
                {"Misc", "Divers"},
                {"Items", "Articles"},
                {"Ammunition", "Munition"},
                {"Construction", "Construction"},
                {"Component", "Composant"},
                {"Traps", "Pièges"},
                {"Electrical", "Électrique"},
                {"Fun", "Amusement"},
                {"Food", "Nourriture"},
                {"Resources", "Ressources"},
                {"Tool", "Outil"},
                {"Weapon", "Arme"},
                {"Medical", "Médical"},
                {"Minicopter", "Minicopter"},
                {"Sedan", "Sedan"},
                {"Airdrop Call", "Fumigène de dètresse"},
            }, this, "fr"); //French

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Economics", "GUIShop fick inte svar från pluginet Economics. Se till att plugin för ekonomi är korrekt installerad." },
                {"EconomicsMaxDebt", "Transaktionen avvisad du är redan på max ekonomiskuld"},
                {"EconomicsExceedsDebt", "Transaktionen avvisades detta skulle överskrida den högsta ekonomiska skuldgränsen på {0}"},
                {"CustomInvalidID", "Anpassat valuta-ID är inte giltigt konfiguration kräver uppdatering för denna butik {0}"},
                {"MaxEconomicsBalance", "Transaktionen avvisad, du har redan nått den högsta ekonomiska gränsen"},
                {"EconomicsExceedsLimit", "Transaktionen avvisades detta skulle överskrida den högsta möjliga ekonomigränsen på {0}"},
                {"ServerRewards", "GUIShop fick inte svar från ServerRewards-plugin. Se till att ServerRewards-tillägget är korrekt installerat." },
                {"TakeCurrency", "GUIshop har misslyckats med att ta denna valuta vid köp {0}"},
                {"Bought", "Du har köpt {0} x {1}."},
                {"Sold", "Du har sålt {0} x {1}."},
                {"Cooldown", "Du kan bara köpa den här varan var {0} sekund."},
                {"InventoryFull", "Ditt lager är fullt."},
                {"InventorySlots", "Du behöver minst {0} lediga lagerplatser."},
                {"ErrorShop", "Det är något fel med denna butik. Kontakta en administratör."},
                {"GlobalShopsDisabled", "Globala butiker är inaktiverade. Denna server använder NPC-leverantörer!"},
                {"DeniedActionInShop", "Du får inte {0} i den här butiken"},
                {"ShopItemItemInvalid", "VARNING: Det verkar som att detta säljföremål du har inte är ett giltigt objekt! Vänligen kontakta en administratör!" },
                {"ItemNotValidbuy", "VARNING: Det verkar som om det inte är ett giltigt objekt att köpa. Kontakta en administratör!" },
                {"ItemNotValidsell", "VARNING: Det verkar som om det inte är ett giltigt objekt att sälja. Kontakta en administratör!" },
                {"RedeemKitFail", "VARNING: Det uppstod ett fel när du gav dig detta kit. Kontakta en administratör!"},
                {"NotKit", "Detta är inte ett giltigt kitnamn som har tilldelats denna butiksvara {0}"},
                {"BuyCmd", "Kan inte köpa flera av denna artikel!"},
                {"BuyPriceFail", "VARNING: Inget köppris gavs av administratören, du kan inte köpa denna artikel"},
                {"SellPriceFail", "VARNING: Inget försäljningspris gavs av administratören, du kan inte sälja denna artikel"},
                {"NotEnoughMoney", "Du behöver {0} mynt för att köpa {1} av {2}"},
                {"NotEnoughMoneyCustom", "Du behöver {0} valuta för att köpa {1} x {2}"},
                {"CustomCurrencyFail", "WANRING Admin har angett denna butik som heter {0} som anpassad valuta men har inte angett ett giltigt valuta-ID {1}"},
                {"NotEnoughSell", "Du har inte tillräckligt med det här objektet."},
                {"NotNothingShopFail", "Du kan inte köpa noll av denna artikel."},
                {"ItemNoExist", "VARNING: Varan du försöker köpa verkar inte existera! Vänligen kontakta en administratör!"},
                {"ItemNoExistTake", "Föremålet du försöker sälja kan inte säljas just nu."},
                {"ItemIsNotBlueprintable", "Denna butiksartikel {0} kan inte ställas in som en Blueprint! Kontakta Admin"},
                {"BuildingBlocked", "Du kan inte handla när du är i ett byggnadsspärrat område."},
                {"BlockedMonuments", "Du får inte använda butiken i närheten av ett monument!"},
                {"ItemNotEnabled", "Butiksinnehavaren har inaktiverat detta föremål."},
                {"ItemNotFound", "Objektet hittades inte"},
                {"CantSellCommands", "Du kan inte sälja kommandon tillbaka till butiken."},
                {"CantSellKits", "Du kan inte sälja kit tillbaka till butiken."},
                //{"CannotSellWhileEquiped", "Du kan inte sälja föremålet om du har det."},
                {"GUIShopResponse", "GUIShop väntar på att ImageLibrary & LangAPI-nedladdningar ska slutföras. Vänta."},
                {"NPCResponseClose", "Tack för att du handlar på {0} kom igen snart!"},
                {"NPCResponseOpen", "Välkommen till {0} vad vill du köpa? Tryck på E för att börja handla!"},
                {"NoPerm", "Du har inte behörighet att handla på {0}"},
                {"WipeReady", "{0}, alla butiker är stängda för \n {1} minuter"},
                {"ImageLibraryFailure", "ImageLibrary verkar saknas eller upptas av andra insticksladdningsorder. GUIshop är oanvändbart. \n Ladda om GUIshop och öka kontrollgränsen för konfigurationsräknaren till högre än {0}"},
                {"NoPermUse", "Du har inte tillåtelse {0}"},
                {"Commands", "Kommandon"},
                {"Attire", "Klädsel"},
                {"Misc", "Övrigt"},
                {"Items", "Objekt"},
                {"Ammunition", "Ammunition"},
                {"Construction", "Konstruktion"},
                {"Component", "Komponent"},
                {"Traps", "Fällor"},
                {"Electrical", "Elektrisk"},
                {"Fun", "Roligt"},
                {"Food", "Mat"},
                {"Resources", "Resurser"},
                {"Tool", "Verktyg"},
                {"Weapon", "Vapen"},
                {"Medical", "Medicinsk"},
                {"Minicopter", "Minikopter"},
                {"Sedan", "Sedan"},
                {"Airdrop Call", "Airdrop Call"},
            }, this, "sv-SE"); //Swedish

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Economics", "GUIShop heeft geen reactie ontvangen van de Economics-plug-in. Zorg ervoor dat de Economics-plug-in correct is geïnstalleerd."},
                {"EconomicsMaxDebt", "Transactie geweigerd, u heeft al een maximale economische schuld"},
                {"EconomicsExceedsDebt", "Transactie geweigerd, dit zou de maximale economische schuldlimiet van {0} overschrijden"},
                {"CustomInvalidID", "Aangepaste valuta-ID is niet geldig configuratie vereist update voor deze winkel {0}"},
                {"MaxEconomicsBalance", "Transactie geweigerd, u zit al op de maximale economische limiet"},
                {"EconomicsExceedsLimit", "Transactie geweigerd, dit zou de max. verdienbare economische limiet van {0} overschrijden"},
                {"ServerRewards", "GUIShop heeft geen antwoord ontvangen van de ServerRewards-plug-in. Zorg ervoor dat de ServerRewards-plug-in correct is geïnstalleerd."},
                {"TakeCurrency", "GUIShop heeft deze valuta niet ontvangen bij aankoop {0}"},
                {"Bought", "U heeft met succes {0} x {1} gekocht."},
                {"Sold", "U heeft met succes {0} x {1} verkocht."},
                {"Cooldown", "U kunt dit item slechts elke {0} seconden kopen."},
                {"InventoryFull", "Uw inventaris is vol."},
                {"InventorySlots", "U heeft minimaal {0} gratis voorraadvakken nodig."},
                {"ErrorShop", "Er is iets mis met deze winkel. Neem contact op met een admin."},
                {"GlobalShopsDisabled", "Global Shops zijn uitgeschakeld. Deze server gebruikt NPC-leveranciers!"},
                {"DeniedActionInShop", "Je mag niet {0} in deze winkel komen"},
                {"ShopItemItemInvalid", "WAARSCHUWING: het lijkt erop dat dit verkoopartikel dat u heeft geen geldig item is! Neem contact op met een beheerder!"},
                {"ItemNotValidbuy", "WAARSCHUWING: Het lijkt erop dat het geen geldig item is om te kopen. Neem contact op met een beheerder!"},
                {"ItemNotValidsell", "WAARSCHUWING: Het lijkt erop dat het geen geldig item is om te verkopen. Neem contact op met een beheerder!"},
                {"RedeemKitFail", "WAARSCHUWING: Er is een fout opgetreden bij het overhandigen van deze kit. Neem contact op met een beheerder!"},
                {"NotKit", "Dit is geen geldige kitnaam die is toegewezen aan dit winkelitem {0}"},
                {"BuyCmd", "Kan niet meerdere van dit item kopen!"},
                {"BuyPriceFail", "WAARSCHUWING: Er is geen koopprijs gegeven door de admin, u kunt dit item niet kopen"},
                {"SellPriceFail", "WAARSCHUWING: Er is geen verkoopprijs opgegeven door de beheerder, u kunt dit item niet verkopen"},
                {"NotEnoughMoney", "U heeft {0} munten nodig om {1} van {2} te kopen"},
                {"NotEnoughMoneyCustom", "U heeft {0} valuta nodig om {1} x {2} te kopen"},
                {"CustomCurrencyFail", "WANRING Beheerder heeft deze winkel met de naam {0} ingesteld als aangepaste valuta, maar heeft geen geldige valuta-ID ingesteld {1}"},
                {"NotEnoughSell", "Je hebt niet genoeg van dit item."},
                {"NotNothingShopFail", "U kunt geen nul van dit artikel kopen."},
                {"ItemNoExist", "WAARSCHUWING: Het artikel dat u probeert te kopen, lijkt niet te bestaan! Neem contact op met een beheerder!"},
                {"ItemNoExistTake", "Het item dat u probeert te verkopen, is op dit moment niet verkoopbaar."},
                {"ItemIsNotBlueprintable", "Dit winkelitem {0} kan niet worden ingesteld als blauwdruk! Neem contact op met beheerder"},
                {"BuildingBlocked", "U kunt niet winkelen in een gebied dat geblokkeerd is door gebouwen."},
                {"BlockedMonuments", "Je mag de winkel niet gebruiken in de buurt van een monument!"},
                {"ItemNotEnabled", "De winkelier heeft dit item uitgeschakeld."},
                {"ItemNotFound", "Item is niet gevonden"},
                {"CantSellCommands", "Je kunt geen commando's terug verkopen aan de winkel."},
                {"CantSellKits", "U kunt kits niet terug verkopen aan de winkel."},
                //{"CannotSellWhileEquiped", "Je kunt het item niet verkopen als je het hebt Equipt."},
                {"GUIShopResponse", "GUIShop wacht tot het downloaden van ImageLibrary & LangAPI is voltooid, even geduld."},
                {"NPCResponseClose", "Bedankt voor het winkelen bij {0}, kom snel weer!"},
                {"NPCResponseOpen", "Welkom bij de {0} wat wilt u kopen? Druk op E om te beginnen met winkelen!"},
                {"NoPerm", "U heeft geen toestemming om te winkelen bij {0}"},
                {"WipeReady", "{0}, alle winkels zijn gesloten voor \n {1} minuten"},
                {"ImageLibraryFailure", "ImageLibrary lijkt te ontbreken of wordt bezet door andere laadopdrachten voor plug-ins. GUIShop is onbruikbaar. \n Herlaad GUIShop en verhoog de controlelimiet van de configuratieteller naar hoger dan {0}"},
                {"NoPermUse", "Je hebt geen toestemming {0}"},
                {"Commands", "Commando's"},
                {"Attire", "Kleding"},
                {"Misc", "Diversen"},
                {"Items", "Artikelen"},
                {"Ammunition", "Munitie"},
                {"Construction", "Bouw"},
                {"Component", "Component"},
                {"Traps", "Vallen"},
                {"Electrical", "Elektrisch"},
                {"Fun", "Pret"},
                {"Food", "Voedsel"},
                {"Resources", "Middelen"},
                {"Tool", "Tool"},
                {"Weapon", "Wapen"},
                {"Medical", "Medisch"},
                {"Minicopter", "Minikopter"},
                {"Sedan", "Sinds"},
                {"Airdrop Call", "Airdrop-oproep"},
            }, this, "nl"); //Dutch

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Economics", "GUIShop이 Economics 플러그인에서 응답을받지 못했습니다. Economics 플러그인이 올바르게 설치되었는지 확인하십시오."},
                {"EconomicsMaxDebt", "거래가 거부되었습니다. 이미 최대 경제 부채에 도달했습니다."},
                {"EconomicsExceedsDebt", "거래가 거부되면 최대 경제 부채 한도인 {0}을(를) 초과합니다."},
                {"CustomInvalidID", "사용자 정의 통화 ID가 올바르지 않습니다. 이 상점 {0}에 대한 업데이트가 필요합니다."},
                {"MaxEconomicsBalance", "거래가 거부되었습니다. 이미 최대 경제 한도에 도달했습니다."},
                {"EconomicsExceedsLimit", "거래가 거부되면 최대 수익 가능 한도인 {0}을(를) 초과합니다."},
                {"ServerRewards", "GUIShop이 ServerRewards 플러그인에서 응답을받지 못했습니다. ServerRewards 플러그인이 올바르게 설치되었는지 확인하십시오."},
                {"TakeCurrency", "GUIShop은 구매 시 이 통화 {0}을(를) 사용하지 못했습니다."},
                {"Bought", "{0} x {1}을 (를) 성공적으로 구입했습니다."},
                {"Sold", "{0} x {1}을 (를) 성공적으로 판매했습니다."},
                {"Cooldown", "이 아이템은 {0} 초마다 구매할 수 있습니다."},
                {"InventoryFull", "재고가 가득 찼습니다."},
                {"InventorySlots", "최소 {0} 개의 인벤토리 자리가 필요합니다."},
                {"ErrorShop", "이 가게에 문제가 있습니다. 관리자에게 문의하십시오."},
                {"GlobalShopsDisabled", "글로벌 상점이 비활성화되었습니다. 이 서버는 NPC 상인을 사용합니다!"},
                {"DeniedActionInShop", "이 상점에서 {0} 할 수 없습니다."},
                {"ShopItemItemInvalid", "경고: 보유한 판매 항목이 유효한 항목이 아닌 것 같습니다! 관리자에게 문의하십시오!"},
                {"ItemNotValidbuy", "경고 : 구매할 수있는 유효한 항목이 아닌 것 같습니다. 관리자에게 문의하십시오!"},
                {"ItemNotValidsell", "경고 : 판매 할 수있는 유효한 항목이 아닌 것 같습니다. 관리자에게 문의하십시오!"},
                {"RedeemKitFail", "경고: 이 키트를 제공하는 동안 오류가 발생했습니다. 관리자에게 문의하십시오!"},
                {"NotKit", "이 상점 항목 {0}에 할당된 유효한 키트 이름이 아닙니다."},
                {"BuyCmd", "이 항목을 여러 개 구매할 수 없습니다!"},
                {"BuyPriceFail", "경고: 관리자가 제공 한 구매 가격이 없으므로이 항목을 구매할 수 없습니다."},
                {"SellPriceFail", "경고: 관리자가 제공 한 판매 가격이 없으므로이 항목을 판매 할 수 없습니다."},
                {"NotEnoughMoney", "{2} 개 중 {1} 개를 구매하려면 {0} 코인이 필요합니다."},
                {"NotEnoughMoneyCustom", "{1} x {2}을 (를) 구매하려면 {0} 통화가 필요합니다."},
                {"CustomCurrencyFail", "WANRING 관리자는 {0}이라는 상점을 맞춤 통화로 설정했지만 유효한 통화 ID {1}를 설정하지 않았습니다."},
                {"NotEnoughSell", "이 항목이 충분하지 않습니다."},
                {"NotNothingShopFail", "이 항목의 0을 구매할 수 없습니다."},
                {"ItemNoExist", "WARNING : 구매하려는 항목이 존재하지 않는 것 같습니다! 관리자에게 문의하십시오!"},
                {"ItemNoExistTake", "판매하려는 아이템은 현재 판매 할 수 없습니다."},
                {"ItemIsNotBlueprintable", "이 상점 항목 {0}은(는) 청사진으로 설정할 수 없습니다! 관리자에게 문의"},
                {"BuildingBlocked", "건물이 차단 된 구역에서는 쇼핑을 할 수 없습니다."},
                {"BlockedMonuments", "기념비 근처에서는 상점을 사용할 수 없습니다!"},
                {"ItemNotEnabled", "상점 주인이 항목을 비활성화했습니다."},
                {"ItemNotFound", "항목을 찾을 수 없습니다."},
                {"CantSellCommands", "명령어는 상점에 다시 판매 할 수 없습니다."},
                {"CantSellKits", "킷은 상점에 반납 할 수 없습니다."},
                {"GUIShopResponse", "GUIShop은 ImageLibrary & LangAPI 다운로드가 완료되기를 기다리고 있습니다. 잠시 기다려주세요."},
                {"NPCResponseClose", "{0}에서 쇼핑 해 주셔서 감사합니다. 곧 다시 오세요!"},
                {"NPCResponseOpen", "무엇을 구매 하시겠습니까? {0}에 오신 것을 환영합니다. 쇼핑을 시작하려면 E를 누르세요!"},
                {"NoPerm", "에서 쇼핑할 권한이 없습니다. {0}"},
                {"WipeReady", "{0} 모든 매장이 {1}분 동안 문을 닫습니다."},
                {"ImageLibraryFailure", "ImageLibrary가 누락되었거나 다른 플러그인 로드 순서에 의해 점유된 것 같습니다. GUIShop을 사용할 수 없습니다. \n 을 다시 GUIShop 로드하고 구성 카운터 확인 제한을 보다 높게 늘립니다 {0}"},
                {"NoPermUse", "당신은 권한이 없습니다 {0}"},
                {"Commands", "명령"},
                {"Attire", "복장"},
                {"Misc", "기타"},
                {"Items", "아이템"},
                {"Ammunition", "탄약"},
                {"Construction", "구성"},
                {"Component", "구성 요소"},
                {"Traps", "트랩"},
                {"Electrical", "전기 같은"},
                {"Fun", "장난"},
                {"Food", "음식"},
                {"Resources", "자원"},
                {"Tool", "수단"},
                {"Weapon", "무기"},
                {"Medical", "의료"},
                {"Minicopter", "미니 콥터"},
                {"Sedan", "이후"},
                {"Airdrop Call", "에어 드랍 콜"},
            }, this, "ko"); //Korean

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Economics", "GUIShop no va rebre cap resposta del connector Economics. Assegureu-vos que el connector d'Economia està instal·lat correctament." },
                {"EconomicsMaxDebt", "S'ha rebutjat la transacció, ja teniu el deute econòmic màxim"},
                {"EconomicsExceedsDebt", "La transacció ha rebutjat, això superaria el límit màxim de deute econòmic de {0}"},
                {"CustomInvalidID", "L'identificador de moneda personalitzat no és vàlid. La configuració requereix actualització per a aquesta botiga {0}"},
                {"MaxEconomicsBalance", "La transacció s'ha rebutjat, ja esteu al límit econòmic màxim"},
                {"EconomicsExceedsLimit", "La transacció ha rebutjat, això supera el límit econòmic màxim que es pot guanyar de {0}"},
                {"ServerRewards", "GUIShop no ha rebut cap resposta del connector ServerRewards. Assegureu-vos que el connector ServerRewards està instal·lat correctament." },
                {"TakeCurrency", "GUIShop no ha pogut acceptar aquesta moneda {0} en comprar-la"},
                {"Bought", "Heu comprat {0} x {1} correctament."},
                {"Sold", "Heu venut correctament {0} x {1}."},
                {"Cooldown", "Només podeu comprar aquest article cada {0} segons."},
                {"InventoryFull", "El vostre inventari està ple."},
                {"InventorySlots", "Necessiteu almenys {0} ranures d'inventari gratuïtes."},
                {"ErrorShop", "Hi ha algun problema amb aquesta botiga. Poseu-vos en contacte amb un administrador."},
                {"GlobalShopsDisabled", "Les botigues globals estan desactivades. Aquest servidor utilitza proveïdors de NPC."},
                {"DeniedActionInShop", "No podeu {0} en aquesta botiga"},
                {"ShopItemItemInvalid", "ADVERTÈNCIA: Sembla que aquest article de venda que teniu no és un article vàlid. Poseu-vos en contacte amb un administrador." },
                {"ItemNotValidbuy", "ADVERTÈNCIA: Sembla que no és un article vàlid per comprar, poseu-vos en contacte amb un administrador." },
                {"ItemNotValidsell", "ADVERTÈNCIA: Sembla que no és un article vàlid per vendre, poseu-vos en contacte amb un administrador." },
                {"RedeemKitFail", "ADVERTÈNCIA: S'ha produït un error en donar-vos aquest kit. Poseu-vos en contacte amb un administrador." },
                {"NotKit", "Aquest no és un nom de kit vàlid assignat a aquest article de botiga {0}"},
                {"BuyCmd", "No es poden comprar diversos elements."},
                {"BuyPriceFail", "AVÍS: l'administrador no va donar cap preu de compra, no podeu comprar aquest article"},
                {"SellPriceFail", "ADVERTÈNCIA: l'administrador no ha donat cap preu de venda, no es pot vendre aquest article"},
                {"NotEnoughMoney", "Necessiteu {0} monedes per comprar {1} de {2}"},
                {"NotEnoughMoneyCustom", "Necessiteu {0} moneda per comprar {1} x {2}"},
                {"CustomCurrencyFail", "WANRING L'administrador té aquesta botiga anomenada {0} establerta com a moneda personalitzada, però no ha establert un identificador de moneda vàlid {1}"},
                {"NotEnoughSell", "No en teniu prou amb aquest element."},
                {"NotNothingShopFail", "No podeu comprar zero d'aquest article."},
                {"ItemNoExist", "ADVERTÈNCIA: sembla que no existeix l'article que intenteu comprar. Poseu-vos en contacte amb un administrador." },
                {"ItemNoExistTake", "L'element que intenteu vendre no es pot vendre en aquest moment."},
                {"ItemIsNotBlueprintable", "Aquest article de la botiga {0} no es pot definir com a pla. Contacta amb l'administrador"},
                {"BuildingBlocked", "No es pot comprar mentre es troba en una zona bloquejada."},
                {"BlockedMonuments", "No podeu fer servir la botiga a prop d'un monument."},
                {"ItemNotEnabled", "El botiguer ha desactivat aquest article."},
                {"ItemNotFound", "No s'ha trobat l'element"},
                {"CantSellCommands", "No podeu vendre comandes a la botiga."},
                {"CantSellKits", "No es poden vendre els kits a la botiga."},
                //{"CannotSellWhileEquiped", "No podeu vendre l'article si el teniu equipat."},
                {"GUIShopResponse", "GUIShop espera que finalitzin les baixades de ImageLibrary & LangAPI, espereu."},
                {"NPCResponseClose", "Gràcies per comprar a {0} torna aviat."},
                {"NPCResponseOpen", "Us donem la benvinguda a {0} què voleu comprar? Premeu E per començar a comprar."},
                {"NoPerm", "No tens permís per comprar a {0}"},
                {"WipeReady", "Benvolgut {0}, totes les botigues estan tancades durant \n {1} minuts"},
                {"ImageLibraryFailure", "Sembla que la ImageLibrary falta o està ocupada per altres ordres de càrrega de connectors. GUIShop no es pot utilitzar. \n Torneu a carregar GUIShop i augmenteu el límit de comprovació del comptador de configuració a més de {0}"},
                {"NoPermUse", "No tens permís {0}"},
                {"Commands", "Ordres"},
                {"Attire", "Vestimenta"},
                {"Misc", "Misc"},
                {"Items", "Articles"},
                {"Ammunition", "Munició"},
                {"Construction", "Construcció"},
                {"Component", "Component"},
                {"Traps", "Paranys"},
                {"Electrical", "Elèctric"},
                {"Fun", "Diversió"},
                {"Food", "Menjar"},
                {"Resources", "Recursos"},
                {"Tool", "Eina"},
                {"Weapon", "Arma"},
                {"Medical", "Mèdic"},
                {"Minicopter", "Minicòpter"},
                {"Sedan", "Des de"},
                {"Airdrop Call", "Trucada Airdrop"},
            }, this, "ca"); // Catalan

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Economics", "GUIShop没有收到来自Economics插件的响应。请确保经济学插件已正确安装。"},
                {"EconomicsMaxDebt", "交易被拒绝 您已经处于最大经济债务状态"},
                {"EconomicsExceedsDebt", "交易被拒绝，这将超过经济债务上限 {0}"},
                {"CustomInvalidID", "自定义货币 ID 无效配置需要为此商店更新 {0}"},
                {"MaxEconomicsBalance", "交易被拒绝 您已经达到最大经济限制"},
                {"EconomicsExceedsLimit", "交易被拒绝，这将超过 {0} 的最大可赚取经济限制"},
                {"ServerRewards", "GUIShop没有收到ServerRewards插件的响应。请确保ServerRewards插件已正确安装。"},
                {"TakeCurrency", "GUIShop 在购买时未能使用此货币 {0}"},
                {"Bought", "您已成功购买{0} x {1}。"},
                {"Sold", "您已成功售出{0} x {1}。"},
                {"Cooldown", "您只能每{0}秒购买此商品。"},
                {"InventoryFull", "您的库存已满。"},
                {"InventorySlots", "您至少需要{0}个可用的广告位。"},
                {"ErrorShop", "这家商店有问题。请联系管理员。"},
                {"GlobalShopsDisabled", "禁用全球商店。该服务器使用NPC供应商！"},
                {"DeniedActionInShop", "此商店不允许您{0}"},
                {"ShopItemItemInvalid", "警告：看来您拥有的这个销售商品不是有效商品！请联系管理员！"},
                {"ItemNotValidbuy", "警告：看来这不是有效的商品，请与管理员联系！"},
                {"ItemNotValidsell", "警告：看来这不是有效的商品，请与管理员联系！"},
                {"RedeemKitFail", "警告：为您提供此工具包时出错，请与管理员联系！"},
                {"NotKit", "这不是分配给此商店商品的有效套件名称 {0}"},
                {"BuyCmd", "无法购买此商品的多个！"},
                {"BuyPriceFail", "警告：管理员未给出购买价格，您不能购买此商品"},
                {"SellPriceFail", "警告：管理员未给出出售价格，您不能出售该物品"},
                {"NotEnoughMoney", "您需要{0}硬币才能购买{2}中的{1}"},
                {"NotEnoughMoneyCustom", "您需要{0}货币才能购买{1} x {2}"},
                {"CustomCurrencyFail", "万灵 管理员已将此名为 {0} 的商店设置为自定义货币，但尚未设置有效的货币 ID {1}"},
                {"NotEnoughSell", "您没有足够的此项。"},
                {"NotNothingShopFail", "您不能购买此商品的零。"},
                {"ItemNoExist", "警告：您尝试购买的商品似乎不存在！请联系管理员！"},
                {"ItemNoExistTake", "您要出售的商品目前无法出售。"},
                {"ItemIsNotBlueprintable", "此商店商品 {0} 不能设置为蓝图！联系管理员"},
                {"BuildingBlocked", "您不能在建筑物受阻区域购物。"},
                {"BlockedMonuments", "您在纪念碑附近不能使用商店！"},
                {"ItemNotEnabled", "店主已禁用此项目。"},
                {"ItemNotFound", "找不到项目"},
                {"CantSellCommands", "您不能将Commands卖回商店。"},
                {"CantSellKits", "您不能将套件卖回商店。"},
                //{"CannotSellWhileEquiped", "如果拥有此设备，则无法出售。"},
                {"GUIShopResponse", "GUIShop正在等待ImageLibrary & LangAPI下载完成，请等待。"},
                {"NPCResponseClose", "感谢您在{0}购物，很快再来！"},
                {"NPCResponseOpen", "欢迎来到{0}，您想购买什么？按E键开始购物！"},
                {"NoPerm", "您无权在 购物 {0}"},
                {"WipeReady", "亲爱的{0}，所有商店都关门 \n {1} 分钟"},
                {"ImageLibraryFailure", "ImageLibrary 似乎丢失或被其他插件加载顺序占用。GUIShop 无法使用。 \n 重新加载 GUIShop 并将配置计数器检查限制增加到高于 {0}"},
                {"NoPermUse", "你没有许可 {0}"},
                {"Commands", "指令"},
                {"Attire", "服装"},
                {"Misc", "杂项"},
                {"Items", "物品"},
                {"Ammunition", "弹药"},
                {"Construction", "施工"},
                {"Component", "零件"},
                {"Traps", "陷阱"},
                {"Electrical", "电的"},
                {"Fun", "好玩"},
                {"Food", "餐饮"},
                {"Resources", "资源资源"},
                {"Tool", "工具"},
                {"Weapon", "武器"},
                {"Medical", "医疗类"},
                {"Minicopter", "微型直升机"},
                {"Sedan", "以来"},
                {"Airdrop Call", "空投电话"},
            }, this, "zh-CN"); //Simplified Chinese

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Economics", "O GUIShop não recebeu resposta do plugin Economics. Certifique-se de que o plugin Economics está instalado corretamente. " },
                {"EconomicsMaxDebt", "Transação recusada, você já está com dívida econômica máxima"},
                {"EconomicsExceedsDebt", "A transação foi recusada. Isso excederia o limite máximo de dívida econômica de {0}"},
                {"CustomInvalidID", "O ID de moeda personalizado não é válido A configuração requer atualização para esta loja {0}"},
                {"MaxEconomicsBalance", "Transação recusada, você já está no limite máximo de economia"},
                {"EconomicsExceedsLimit", "A transação foi recusada. Isso excederia o limite máximo de economia de ganhos de {0}"},
                {"ServerRewards", "GUIShop não recebeu uma resposta do plugin ServerRewards. Certifique-se de que o plugin ServerRewards esteja instalado corretamente. " },
                {"TakeCurrency", "GUIShop não conseguiu usar esta moeda {0} na compra"},
                {"Bought", "Você comprou com sucesso {0} {1}."},
                {"Sold", "Você vendeu com sucesso {0} {1}. "},
                {"Cooldown", "Você só pode comprar este item a cada {0} segundos."},
                {"InventoryFull", "Seu inventário está cheio."},
                {"InventorySlots", "Você precisa de pelo menos {0} slots de inventário gratuitos."},
                {"ErrorShop", "Há algo errado com esta loja. Entre em contato com um administrador."},
                {"GlobalShopsDisabled", "Lojas globais estão desativadas. Este servidor usa fornecedores NPC!"},
                {"DeniedActionInShop", "Você não tem permissão para {0} nesta loja"},
                {"ShopItemItemInvalid", "AVISO: Parece que este item de venda que você tem não é um item válido! Entre em contato com um administrador!" },
                {"ItemNotValidbuy", "AVISO: parece que não é um item válido para comprar, entre em contato com um administrador!"},
                {"ItemNotValidsell", "AVISO: parece que não é um item válido para vender, entre em contato com um administrador!"},
                {"RedeemKitFail", "AVISO: Ocorreu um erro ao fornecer este kit a você, entre em contato com um administrador!"},
                {"NotKit", "Este não é um nome de kit válido atribuído a este item da loja {0}"},
                {"BuyCmd", "Não é possível comprar vários deste item!"},
                {"BuyPriceFail", "AVISO: Nenhum preço de compra foi fornecido pelo administrador, você não pode comprar este item"},
                {"SellPriceFail", "AVISO: Nenhum preço de venda foi fornecido pelo administrador, você não pode vender este item"},
                {"NotEnoughMoney", "Você precisa de {0} moedas para comprar {1}x {2}"},
                {"NotEnoughMoneyCustom", "Você precisa de {0} moeda para comprar {1}x {2}"},
                {"CustomCurrencyFail", "O administrador do WANRING tem esta loja chamada {0} definida como moeda personalizada, mas não definiu um ID de moeda válido {1}"},
                {"NotEnoughSell", "Você não tem o suficiente deste item."},
                {"NotNothingShopFail", "Você não pode comprar Zero deste item."},
                {"ItemNoExist", "AVISO: o item que você está tentando comprar parece não existir! Entre em contato com um administrador!" },
                {"ItemNoExistTake", "O item que você está tentando vender não pode ser vendido no momento."},
                {"ItemIsNotBlueprintable", "Este item da loja {0} não pode ser definido como um projeto! Administrador de contato"},
                {"BuildingBlocked", "Você não pode fazer compras enquanto estiver em uma área de construção bloqueada. "},
                {"BlockedMonuments", "Você não pode usar a loja perto de um Monumento!"},
                {"ItemNotEnabled", "O lojista desativou este item."},
                {"ItemNotFound", "Item não encontrado"},
                {"CantSellCommands", "Você não pode vender comandos de volta para a loja."},
                {"CantSellKits", "Você não pode vender Kits de volta para a loja."},
                //{"CannotSellWhileEquiped", "Você não pode vender o item se o tiver equipado."},
                {"GUIShopResponse", "GUIShop está esperando o download da ImageLibrary & LangAPI terminar, por favor aguarde."},
                {"NPCResponseClose", "Obrigado por comprar em {0} volte em breve!"},
                {"NPCResponseOpen", "Bem-vindo ao {0} o que você gostaria de comprar? Pressione E para começar a comprar!"},
                {"NoPerm", "Você não tem permissão para comprar em {0}"},
                {"WipeReady", "Caro {0}, todas as lojas estão fechadas por \n {1} minutos"},
                {"ImageLibraryFailure", "ImageLibrary parece estar ausente ou ocupado por outros pedidos de carregamento de plug-ins. GUIShop está inutilizável. \n Recarregue o GUIShop e aumente o limite de verificação do contador de configuração para mais de {0}"},
                {"NoPermUse", "Você não tem permissão {0}"},
                {"Commands", "Comandos"},
                {"Attire", "Vestuário"},
                {"Misc", "Misc"},
                {"Items", "Items"},
                {"Ammunition", "Munição"},
                {"Construction", "Construção"},
                {"Component", "Componente"},
                {"Traps", "Traps"},
                {"Electrical", "Elétrico"},
                {"Fun", "Diversão"},
                {"Food", "Comida"},
                {"Resources", "Resources"},
                {"Tool", "Ferramenta"},
                {"Weapon", "Arma"},
                {"Medical", "Médico"},
                {"Minicopter", "Minicóptero"},
                {"Sedan", "Desde a"},
                {"Airdrop Call", "Airdrop Call"},
            }, this, "pt-BR"); //Portuguese Brazil

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Economics", "GUIShop hat keine Antwort vom Economics-Plugin erhalten. Bitte stellen Sie sicher, dass das Economics-Plugin korrekt installiert ist."},
                {"EconomicsMaxDebt", "Transaktion abgelehnt, Sie haben bereits die maximale wirtschaftliche Verschuldung erreicht"},
                {"EconomicsExceedsDebt", "Transaktion abgelehnt, dies würde das maximale Wirtschaftsschuldenlimit von {0} überschreiten"},
                {"CustomInvalidID", "Benutzerdefinierte Währungs-ID ist ungültig Konfiguration muss für diesen Shop aktualisiert werden {0}"},
                {"MaxEconomicsBalance", "Transaktion abgelehnt, Sie haben bereits das maximale Wirtschaftslimit erreicht"},
                {"EconomicsExceedsLimit", "Transaktion abgelehnt, dies würde das maximal erzielbare Wirtschaftslimit von {0} überschreiten"},
                {"ServerRewards", "GUIShop hat keine Antwort vom ServerRewards-Plugin erhalten. Bitte stellen Sie sicher, dass das ServerRewards-Plugin korrekt installiert ist."},
                {"TakeCurrency", "GUIShop hat es versäumt zu nehmen Währung beim Kauf {0}"},
                {"Bought", "Sie haben {0} x {1} erfolgreich gekauft."},
                {"Sold", "Sie haben {0} x {1} erfolgreich verkauft."},
                {"Cooldown", "Sie können diesen Artikel nur alle {0} Sekunden kaufen."},
                {"InventoryFull", "Ihr Inventar ist voll."},
                {"InventorySlots", "Sie benötigen mindestens {0} freie Inventarplätze."},
                {"ErrorShop", "Mit diesem Shop stimmt etwas nicht. Bitte wenden Sie sich an einen Administrator."},
                {"GlobalShopsDisabled", "Globale Shops sind deaktiviert. Dieser Server verwendet NPC-Anbieter!"},
                {"DeniedActionInShop", "Sie dürfen in diesem Shop nicht {0}"},
                {"ShopItemItemInvalid", "WARNUNG: Es scheint, dass dieser Verkaufsartikel, den Sie haben, kein gültiger Artikel ist! Bitte wenden Sie sich an einen Administrator!"},
                {"ItemNotValidbuy", "WARNUNG: Es scheint, als wäre es kein gültiger Artikel zum Kaufen. Bitte wenden Sie sich an einen Administrator!"},
                {"ItemNotValidsell", "WARNUNG: Es scheint, dass es sich nicht um einen gültigen Artikel handelt. Bitte wenden Sie sich an einen Administrator."},
                {"RedeemKitFail", "WARNUNG: Bei der Bereitstellung dieses Kits ist ein Fehler aufgetreten. Bitte wenden Sie sich an einen Administrator."},
                {"NotKit", "Dies ist kein gültiger Kit-Name, der diesem Shop-Artikel {0} zugewiesen ist."},
                {"BuyCmd", "Mehrere Artikel können nicht gekauft werden!"},
                {"BuyPriceFail", "WARNUNG: Der Administrator hat keinen Kaufpreis angegeben. Sie können diesen Artikel nicht kaufen"},
                {"SellPriceFail", "WARNUNG: Der Administrator hat keinen Verkaufspreis angegeben. Sie können diesen Artikel nicht verkaufen"},
                {"NotEnoughMoney", "Sie benötigen {0} Münzen, um {1} von {2} zu kaufen."},
                {"NotEnoughMoneyCustom", "Sie benötigen {0} Währung, um {1} x {2} zu kaufen."},
                {"CustomCurrencyFail", "WARNUNG Administrator; dieser Shop {0} ist auf eine benutzerdefinierte Währung eingestellt, hat aber keine gültige Währungs-ID {1}"},
                {"NotEnoughSell", "Sie haben nicht genug von diesem Artikel."},
                {"NotNothingShopFail", "Sie können Zero von diesem Artikel nicht kaufen."},
                {"ItemNoExist", "WARNUNG: Der Artikel, den Sie kaufen möchten, scheint nicht zu existieren! Bitte wenden Sie sich an einen Administrator!"},
                {"ItemNoExistTake", "Der Artikel, den Sie verkaufen möchten, ist derzeit nicht verfügbar."},
                {"ItemIsNotBlueprintable", "Dieser Shop-Artikel {0} kann nicht als Blaupause festgelegt werden!"},
                {"BuildingBlocked", "Sie können nicht in einem blockierten Bereich einkaufen."},
                {"BlockedMonuments", "Sie dürfen den Shop nicht in der Nähe eines Denkmals benutzen!"},
                {"ItemNotEnabled", "Der Ladenbesitzer hat diesen Artikel deaktiviert."},
                {"ItemNotFound", "Element wurde nicht gefunden"},
                {"CantSellCommands", "Sie können keine Befehle an den Shop zurückverkaufen."},
                {"CantSellKits", "Sie können Kits nicht an den Shop zurückverkaufen."},
                //{"CannotSellWhileEquiped", "Sie können den Artikel nicht verkaufen, wenn Sie über Equipt verfügen."},
                {"GUIShopResponse", "GUIShop wartet auf den Abschluss der ImageLibrary & LangAPI-Downloads. Bitte warten Sie."},
                {"NPCResponseClose", "Vielen Dank für Ihren Einkauf bei {0}. Kommen Sie bald wieder!"},
                {"NPCResponseOpen", "Willkommen bei der {0}, was möchten Sie kaufen? Drücken Sie E, um mit dem Einkaufen zu beginnen!"},
                {"NoPerm", "Sie sind nicht berechtigt, bei  einzukaufen {0}"},
                {"WipeReady", "Liebling {0}, alle Geschäfte sind geschlossen für \n {1} Minuten"},
                {"ImageLibraryFailure", "ImageLibrary scheint zu fehlen oder von anderen Plugin-Ladeaufträgen belegt zu sein. GUIShop ist unbrauchbar. \n Laden Sie GUIShop neu und erhöhen Sie das Prüflimit für den Konfigurationszähler auf mehr als {0}"},
                {"NoPermUse", "Sie haben keine Berechtigung {0}"},
                {"Commands", "Befehle"},
                {"Attire", "Kleidung"},
                {"Misc", "Sonstiges"},
                {"Items", "Artikel"},
                {"Ammunition", "Munition"},
                {"Construction", "Konstruktion"},
                {"Component", "Komponenten"},
                {"Traps", "Fallen"},
                {"Electrical", "Elektrik"},
                {"Fun", "Spaß"},
                {"Food", "Essen"},
                {"Resources", "Ressourcen"},
                {"Tool", "Werkzeuge"},
                {"Weapon", "Waffen"},
                {"Medical", "Medizin"},
                {"Minicopter", "Minikopter"},
                {"Sedan", "Limousine"},
                {"Airdrop Call", "Airdrop rufen"},
            }, this, "de"); // German

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Economics", "GUIShop не получает ответа от плагина Экономика. Пожалуйста убедитесь что плагин экономика установлен правильно." },
                {"EconomicsMaxDebt", "Транзакция отклонена, вы уже достигли максимального экономического долга"},
                {"EconomicsExceedsDebt", "Транзакция отклонена, это приведет к превышению максимального экономического долга {0}"},
                {"CustomInvalidID", "Идентификатор пользовательской валюты недействителен, требуется обновление конфигурации для этого магазина {0}"},
                {"MaxEconomicsBalance", "Транзакция отклонена, вы уже достигли максимального экономического предела"},
                {"EconomicsExceedsLimit", "Транзакция отклонена, это приведет к превышению максимального экономического предела заработка, равного {0}"},
                {"ServerRewards", "GUIShop не получает ответа от плагина ServerRewards плагин. Пожалуйста, убедитесь, что ServerRewards плагин установлен правильно." },
                {"TakeCurrency", "GUIShop не смог забрать эту валюту при покупке {0}"},
                {"Bought", "Вы успешно купили {0} {1}."},
                {"Sold", "Вы успешно продали {0} {1}."},
                {"Cooldown", "Вы можете купить этот товар один раз в {0} секунд."},
                {"InventoryFull", "Ваш инвентарь полностью заполнен."},
                {"InventorySlots", "У вас должно быть {0} свободных слота в инвентаре."},
                {"ErrorShop", "Что то произошло с магазином. Пожалуйста сообщите об этом администратору."},
                {"GlobalShopsDisabled", "Глобальные магазины отключены. На данном сервере используются торговцы НПС!"},
                {"DeniedActionInShop", "Вам не разрешено использовать {0} в этом магазине"},
                {"ShopItemItemInvalid", "ВНИМАНИЕ: Данный предмет недействителен! Пожалуйста сообщите об этом администратору!"},
                {"ItemNotValidbuy", "ВНИМАНИЕ: Этот предмет невозможно купить. Пожалуйста сообщите об этом администратору!"},
                {"ItemNotValidsell", "ВНИМАНИЕ: Этот предмет невозможно продать. Пожалуйста сообщите об этом администратору!"},
                {"RedeemKitFail", "ВНИМАНИЕ: При получении комплекта произошла ошибка. Пожалуйста сообщите об этом администратору!"},
                {"NotKit", "Ошибка в название комплекта {0}"},
                {"BuyCmd", "Нельзя купить сразу несколько единиц данного товара!"},
                {"BuyPriceFail", "ВНИМАНИЕ: Цена товара не указана администратором, покупка невозможна"},
                {"SellPriceFail", "ВНИМАНИЕ: Цена товара не указана администратором, продажа невозможна"},
                {"NotEnoughMoney", "Вам нужно {0} монет для покупки {1}x {2}"},
                {"NotEnoughMoneyCustom", "Вам нужно {0} валюты для покупки {1}x {2}"},
                {"CustomCurrencyFail", "ВНИМАНИЕ: Администратор установил магазин {0} для торговли специальной валютой, но не установил действительный идентификатор валюты {1}"},
                {"NotEnoughSell", "У вас недостаточно этого продукта для продажи"},
                {"NotNothingShopFail", "Ошибка, вы не можете купить 0 {0}. Связаться с разработчиком"},
                {"ItemNoExist", "ВНИМАНИЕ: Товар который вы приобретаете - не существует! Пожалуйста сообщите об этом администратору!"},
                {"ItemNoExistTake", "Товар, указанный в магазине, который вы пытаетесь продать, недействителен, свяжитесь с администратором"},
                {"ItemIsNotBlueprintable", "Ошибка Этот предмет {0} в магазине нельзя купить в качестве чертежа! Связаться с администратором"},
                {"BuildingBlocked", "Вы не можете делать покупки, находясь в зоне, заблокированной зданием."},
                {"BlockedMonuments", "Вы не можете искользовать магазин рядом с памятником!"},
                {"ItemNotEnabled", "Продавец отключил продажу этого предмета."},
                {"ItemNotFound", "Товар не найден"},
                {"CantSellCommands", "Вы не можете продать команду обратно в магазин."},
                {"CantSellKits", "Вы не можете продать комплект обратно в магазин."},
                //{"CannotSellWhileEquiped", "Вы не можете продать это оборудование."},
                {"GUIShopResponse", "GUIShop ожидает загрузки ImageLibrary и LangAPI, пожалуйста подождите."},
                {"NPCResponseClose", "Спасибо за покупку {0}. Приходите к нам ещё!"},
                {"NPCResponseOpen", "Добро пожаловать в {0} что хотите приобрести? Нажмите Е для начала торговли!"},
                {"NoPerm", "У вас нет разрешения делать покупки в {0}"},
                {"WipeReady", "Уважаемый {0}, все магазины закрыты на \n {1} минут"},
                {"ImageLibraryFailure", "ImageLibrary отсутствует или занята другими порядками загрузки плагинов. GUIShop непригоден для использования. \n Перезагрузите GUIShop и увеличьте лимит поверки счетчика конфигурации до значения, превышающего {0}"},
                {"NoPermUse", "У вас нет разрешения {0}"},
                {"Commands", "Команды"},
                {"Attire", "Одежда"},
                {"Misc", "Разное"},
                {"Items", "Предметы"},
                {"Ammunition", "Боеприпасы"},
                {"Construction", "Строительство"},
                {"Component", "Компоненты"},
                {"Traps", "Ловушки"},
                {"Electrical", "Электричество"},
                {"Fun", "Веселье"},
                {"Food", "Еда"},
                {"Resources", "Ресурсы"},
                {"Tool", "Инструмент"},
                {"Weapon", "Оружие"},
                {"Medical", "Медицина"},
                {"Minicopter", "Миникоптер"},
                {"Sedan", "Седан"},
                {"Airdrop Call", "Вызов Аирдропа"},
            }, this, "ru"); // Russian
        }
        private string Lang(string key, string id = null) => lang.GetMessage(key, this, id);
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion

        #region Queue

        RequestQueue _requestQueue;

        private void Enqueue(Action action) => _requestQueue.Enqueue(action);

        private class RequestQueue
        {
            readonly Queue<Action> _actions;
            readonly Timer _timer;

            public RequestQueue(float interval = 2f)
            {
                _actions = new Queue<Action>();

                _timer = _instance.timer.Every(interval, Check);
            }

            public void Enqueue(Action action)
            {
                if (action != null)
                {
                    _actions.Enqueue(action);
                }
            }

            public void Destroy()
            {
                _timer?.Destroy();
                _actions.Clear();
            }

            public void Check()
            {
                if (_actions.Count <= 0)
                {
                    return;
                }

                _actions.Dequeue()?.Invoke();
            }
        }

        #endregion

        #region Request

        private class Request
        {
            public Dictionary<string, string> Headers;
            public Message Message;
            public Plugin Plugin;
            public string Webhook;
            public int Retries;

            public Request()
            {
                //
            }

            public Request(string webhook, Message message, Plugin plugin, Dictionary<string, string> headers = null)
            {
                Webhook = webhook;
                Message = message;
                Plugin = plugin;
                Headers = headers;
            }

            public void SendRequest()
            {
                if (_instance._config.DiscordWebHookURL.IsNullOrEmpty()) return;
                _instance.webrequest.Enqueue(Webhook, Message.ToJson(), RequestCallback, Plugin, RequestMethod.POST,
                    Headers);
            }

            public void RequestCallback(int code, string message)
            {
                Response response = new Response
                {
                    Code = code,
                    Message = message,
                };

                if (Retries >= 3)
                {
                    return;
                }

                if (!response.IsLimited && response.IsOk)
                {
                    return;
                }

                Retries++;

                _instance.Enqueue(SendRequest);

                _instance.Puts($"Error sending message, {code}");
            }
        }

        private class Response
        {
            public int Code;
            public string Message;
            public bool IsLimited => Code == 429;
            public bool IsOk => Code == 200 || Code == 204;
        }

        #endregion

        #region Discord

        private class Message
        {
            [JsonProperty("content")] public string Content;

            [JsonProperty("embeds")] public List<Embed> Embeds;

            public Message()
            {
                Embeds = new List<Embed>();
            }

            public Message(string content)
            {
                Embeds = new List<Embed>();
                Content = content;
            }

            public Message AddContent(string content)
            {
                Content = content;

                return this;
            }

            public Message AddEmbed(Embed embed)
            {
                Embeds.Add(embed);

                return this;
            }

            public string ToJson() => JsonConvert.SerializeObject(this);
        }

        private class Author
        {
            [JsonProperty("icon_url")] public string IconUrl;

            [JsonProperty("name")] public string Name;

            [JsonProperty("url")] public string Url;
        }

        private class Embed
        {
            [JsonProperty("author")] public Author Author;

            [JsonProperty("title")] public string Title;

            [JsonProperty("description")] public string Description;

            [JsonProperty("color")] public int Color;

            [JsonProperty("fields")] public List<Field> Fields = new List<Field>();

            public Embed AddTitle(string title)
            {
                Title = title;

                return this;
            }

            public Embed AddDescription(string description)
            {
                Description = description;

                return this;
            }

            public Embed AddColor(string color)
            {
                Color = int.Parse(color.TrimStart('#'), NumberStyles.AllowHexSpecifier);

                return this;
            }

            public Embed AddField(string name, string value, bool inline = false)
            {
                Fields.Add(new Field(name, value, inline));

                return this;
            }

            public Embed AddAuthor(string name, string url, string iconUrl)
            {
                Author = new Author
                {
                    Name = name,
                    Url = url,
                    IconUrl = iconUrl
                };

                return this;
            }
        }

        private class Field
        {
            public Field(string name, string value, bool inline)
            {
                Name = name;
                Value = value;
                Inline = inline;
            }

            [JsonProperty("name")] public string Name;

            [JsonProperty("value")] public string Value;

            [JsonProperty("inline")] public bool Inline;
        }

        private void SendToDiscord(List<Embed> embeds)
        {
            if (_config.EnableDiscordLogging)
            {
                Message message = new Message();
                message.Embeds = embeds;
                _requestQueue.Enqueue(new Request(_config.DiscordWebHookURL, message, this, _headers).SendRequest);
            }
        }

        private Embed BuildMessage(BasePlayer player)
        {
            Embed embed = new Embed();
            embed.AddAuthor(nameof(GUIShop), "https://umod.org/plugins/gui-shop", _config.DiscordAuthorImage);
            embed.AddColor(_config.DiscordColor);
            embed.AddField("Steam ID", player.UserIDString, true);
            embed.AddField("Display Name", player.displayName.EscapeRichText(), true);
            return embed;
        }

        #endregion

        #region Oxide

        private bool _wipeReady = true;
        private void OnNewSave(string filename)
        {
            _wipeReady = false;
            if (_config.AutoWipe)
            {
                _sellCoolDowns.Clear();
                _sellCoolDownData.Clear();
                _sellLimitResetCoolDowns.Clear();
                _sellLimitResetCoolDownData.Clear();
                _buyCoolDowns.Clear();
                _buyCooldownData.Clear();
                _buyLimitResetCoolDowns.Clear();
                _buyLimitResetCoolDownData.Clear();

                _bought.Clear();
                _boughtData.Clear();
                _sold.Clear();
                _soldData.Clear();
                _limits.Clear();
                _limitsData.Clear();
            }

            _config.Time.LastWipe = _config.Time.WipeTime;
            _config.Time.WipeTime = DateTime.Now.ToString("u");
            SaveConfig();
            timer.Once(_config.Time.CanShopIn, () =>
            {
                PrintToChat("All Shops are open for business!");
                _wipeReady = true;
            });
        }

        readonly Dictionary<ulong, string> _customSpawnables = new Dictionary<ulong, string>
        {
            {
                2255658925, "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab"
            }
        };

        private void OnUserConnected(IPlayer player) => GetPlayerData(player.Object as BasePlayer);

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            BaseEntity entity = go.ToBaseEntity();
            if (entity == null || entity.skinID == 0UL)  //Fixed typo 
            {
                return;
            }

            if (_customSpawnables.ContainsKey(entity.skinID))
            {
                SpawnReplacementItem(entity, _customSpawnables[entity.skinID]);

                NextTick(() => entity.Kill());
            }
        }
        private void SpawnReplacementItem(BaseEntity entity, string prefabPath)
        {
            BaseEntity newEntity = GameManager.server.CreateEntity(prefabPath, entity.ServerPosition, entity.ServerRotation);
            if (newEntity == null) return;
            newEntity.Spawn();
        }

        private void OnEntityTakeDamage(BasePlayer player, HitInfo info) //Auto close feature
        {
            if (info == null)
                return;

            if (playerGUIShopUIOpen.Contains(player.UserIDString) && (info.IsProjectile() || 
                                                                      info.damageTypes.Has(DamageType.Bite) ||
                                                                      info.damageTypes.Has(DamageType.Blunt) ||
                                                                      info.damageTypes.Has(DamageType.Drowned) ||
                                                                      info.damageTypes.Has(DamageType.Explosion) ||
                                                                      info.damageTypes.Has(DamageType.Stab) ||
                                                                      info.damageTypes.Has(DamageType.Slash) ||
                                                                      info.damageTypes.Has(DamageType.Fun_Water)))
            {
                DestroyUi(player, true);
            }
        }

        private string Currency = String.Empty;
        private Dictionary<int, string[]> _categoryRects = new Dictionary<int, string[]>();
        private Dictionary<int, float[]> _itemRects = new Dictionary<int, float[]>();

        // button width is 0.05 , 0.525 0.05 0.525
        // 16 buttons max
        // gap ratio 0.006
        //_categoryRects[i] = new string[] { $"{(0.052 + (i * 0.056))} 0.78", $"{(0.1 + (i * 0.056))} 0.82" };
        private void CacheRects()
        {
            for (int i = 0; i < 7; i++)
            {
                float pos = 0.85f - 0.125f * i;

                _itemRects[i] = new float[] {pos + 0.125f, pos};
            }

            int count = 0;

            for (int i = 0; i < _config.ShopCategories.Count; i++)
            {
                if (i <= 16)
                    _categoryRects[i] = new string[] { $"{(0.024 + (i * 0.056))} 0.82", $"{(0.074 + (i * 0.056))} 0.86" };
                else
                {
                    _categoryRects[i] = new string[] { $"{(0.024 + (count * 0.056))} 0.765", $"{(0.074 + (count * 0.056))} 0.805" };
                    count++;
                }
            }
        }

        private void OnServerInitialized()
        {
            CheckConfig();

            /*if (_config.ShopCategories.ContainsKey(_config.DefaultShop) && _config.ShopCategories[_config.DefaultShop].EnabledCategory == false)
            {
                PrintError($"The Default Set Shop to open <{_config.DefaultShop}> has been manually set to false on the EnabledCategory Field.\nThis will result in an error, plugin is self unloading, correct config manually.\n If you want to disable all shops, set the default shop to open to be a blank string as stated in the docs!");
                Server.Command("o.unload GUIShop");
                return;
            }*/

            CacheRects();
            permission.RegisterPermission(BlockAllow, this);
            permission.RegisterPermission(Use, this);
            permission.RegisterPermission(Admin, this);
            //permission.RegisterPermission(Vip, this);
            permission.RegisterPermission(Color, this);
            permission.RegisterPermission(Button, this);

            if (_config.Economics)
                Currency = "Economics";
            else if (_config.ServerRewards)
                Currency = "ServerRewards";
            else if (_config.CustomCurrency)
                Currency = "Custom";

            if (Economics != null && Economics.IsLoaded && Economics.Call("BalanceLimits") != null)
            {
                _balanceLimits = Economics.Call<KeyValuePair<int, int>>("BalanceLimits");

                if (_balanceLimits.Value != 0)
                    _isEconomicsLimits = true;

                if (_balanceLimits.Key != -1)
                    _isEconomicsDebt = true;
            }

            LibraryCheck();
            
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player == null || player.IsNpc || !player.userID.IsSteamId()) continue;
                GetPlayerLimit(player);
                GetPlayerData(player).ShopKey = String.Empty;
            }

            SaveData();

            if (LangAPI != null && LangAPI.IsLoaded)
                _isLangAPIReady = LangAPI.Call<bool>("IsReady");
        }

        private DynamicConfigFile _buyCoolDowns;
        private DynamicConfigFile _sellCoolDowns;
        private DynamicConfigFile _buyLimitResetCoolDowns;
        private DynamicConfigFile _sellLimitResetCoolDowns;
        private DynamicConfigFile _bought;
        private DynamicConfigFile _sold;
        private DynamicConfigFile _limits;
        private DynamicConfigFile _playerData;
        private DynamicConfigFile _buttonData;

        private void Loaded()
        {
            _instance = this;
            _requestQueue = new RequestQueue();

            cmd.AddChatCommand(_config.shopcommand, this, CmdGUIShop);
            _buyCoolDowns = Interface.Oxide.DataFileSystem.GetFile(nameof(GUIShop) + "/BuyCooldowns");
            _sellCoolDowns = Interface.Oxide.DataFileSystem.GetFile(nameof(GUIShop) + "/SellCooldowns");
            _buyLimitResetCoolDowns = Interface.Oxide.DataFileSystem.GetFile(nameof(GUIShop) + "/BuyLimitResetCoolDowns");
            _sellLimitResetCoolDowns = Interface.Oxide.DataFileSystem.GetFile(nameof(GUIShop) + "/SellLimitResetCoolDowns");
            _bought = Interface.Oxide.DataFileSystem.GetFile(nameof(GUIShop) + "/Purchases");
            _sold = Interface.Oxide.DataFileSystem.GetFile(nameof(GUIShop) + "/Sales");
            _limits = Interface.Oxide.DataFileSystem.GetFile(nameof(GUIShop) + "/Limits");
            _playerData = Interface.Oxide.DataFileSystem.GetFile(nameof(GUIShop) + "/GUIShopPlayerConfigs");
            _buttonData = Interface.Oxide.DataFileSystem.GetFile(nameof(GUIShop) + "/GUIShopButtonSettings");
            LoadData();

            foreach (var category in _config.ShopCategories.Values)
            {
                if (category.Permission.IsNullOrEmpty() || permission.PermissionExists(category.PrefixPermission, this)) continue;

                permission.RegisterPermission(category.PrefixPermission, this);
            }
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                DestroyUi(player, true);
                DestroyGUIShopButton(player);
                GetPlayerData(player).ShopKey = String.Empty;
            }
            SaveData();
            _itemRects = null;
            _guishopItemIcons = null;
            _imageListGUIShop = null;
            _instance = null;
        }

        private void OnGroupPermissionGranted(string group, string perm)
        {
            if (perm.Equals(Button))
            {
                foreach (IPlayer player in covalence.Players.Connected.Where(p => permission.UserHasGroup(p.Id, group)))
                {
                    CreateGUIShopButton(player.Object as BasePlayer);
                }
            }
        }

        private void OnGroupPermissionRevoked(string group, string perm)
        {
            if (perm.Equals(Button))
            {
                foreach (IPlayer player in covalence.Players.Connected.Where(p => permission.UserHasGroup(p.Id, group)))
                {
                    DestroyGUIShopButton(player.Object as BasePlayer);
                }
            }
        }

        private void OnUserPermissionGranted(string id, string permName)
        {
            UserData userData = permission.GetUserData(id);
            if (userData != null && permission.GroupsHavePermission(userData.Groups, permName))
            {
                Puts($"This user {id} is already in a group that has {permName} please remove duplication");
            }
            if (permName.Equals(Button))
                CreateGUIShopButton(BasePlayer.Find(id));
        }

        private void OnUserPermissionRevoked(string userId, string perm)
        {
            if (perm.Equals(Button))
                DestroyGUIShopButton(BasePlayer.Find(userId));
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!player.userID.IsSteamId()) return;
            CreateGUIShopButton(player);
            GetPlayerLimit(player);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            GetPlayerLimit(player);
        }

        private void OnPluginLoaded(Plugin name)
        {
            if (ImageLibrary != null && name.Name == ImageLibrary.Name && !_isRestart && ImageLibrary.Call<bool>("IsReady"))
            {
                PrintWarning("ImageLibrary has been detected and GUIShop Images are now being Processed");
                _imageLibraryCheck = 0;
                LibraryCheck();
            }

            if (Economics != null && name.Name == Economics.Name && Economics.Call("BalanceLimits") != null)
            {
                _balanceLimits = Economics.Call<KeyValuePair<int, int>>("BalanceLimits");
                if (_balanceLimits.Value != 0)
                    _isEconomicsLimits = true;

                if (_balanceLimits.Key != 0)
                    _isEconomicsDebt = true;
            }
        }

        private void OnServerSave()
        {
            SaveData();
        }

        #endregion

        #region ImageLibrary

        private void LibraryCheck()
        {
            if (ImageLibrary == null || !ImageLibrary.IsLoaded)
            {
                _imageLibraryCheck++;

                if (_imageLibraryCheck >= _config.ImageLibraryCounter)
                {
                    _isRestart = false;
                    PrintWarning(Lang("ImageLibraryFailure", null, _config.ImageLibraryCounter));
                    return;
                }

                timer.In(60, LibraryCheck);
                if (ImageLibrary == null)
                {
                    PrintWarning("ImageLibrary is not LOADED! please install");
                }
                else
                    PrintWarning("ImageLibrary appears to be occupied will check again in 1 minute");
                return;
            }

            LoadImages();
        }

        private void LoadImages()
        {
            _isRestart = false;
            _guishopItemIcons = new List<KeyValuePair<string, ulong>>();
            _imageListGUIShop = new Dictionary<string, string>();
            _imageListGUIShop.Add(GUIShopBackgroundImage, _config.BackgroundUrl);
            _imageListGUIShop.Add(GUIShopWelcomeImage, _config.GuiShopWelcomeUrl);
            _imageListGUIShop.Add(GUIShopAmount1Image, _config.AmountUrl);
            _imageListGUIShop.Add(GUIShopAmount2Image, _config.AmountUrl2);
            _imageListGUIShop.Add(GUIShopBuyImage, _config.BuyIconUrl);
            _imageListGUIShop.Add(GUIShopSellImage, _config.SellIconUrl);
            _imageListGUIShop.Add(GUIShopBackArrowImage, _config.BackButtonUrl);
            _imageListGUIShop.Add(GUIShopForwardArrowImage, _config.ForwardButtonUrl);
            _imageListGUIShop.Add(GUIShopCloseImage, _config.CloseButton);
            _imageListGUIShop.Add(GUIShopShopButton, _config.GUI.Image);
            _imageListGUIShop.Add(_config.IconUrl, _config.IconUrl);
   
            foreach (ShopItem shopItem in _config.ShopItems.Values)
            {
                if (!shopItem.Image.IsNullOrEmpty() && !_imageListGUIShop.ContainsKey(shopItem.Image))
                {
                    _imageListGUIShop.Add(shopItem.Image, shopItem.Image);
                }
            }

            ImageLibrary?.Call("ImportImageList", Name, _imageListGUIShop, 0UL, true, new Action(ShopReady));
        }
        private void ShopReady()
        {
            _isShopReady = true;
            _guishopItemIcons.Clear();
            _imageListGUIShop.Clear();
            _imageLibraryCheck = 0;

            int AnyShops = 0;
            foreach (var enabled in _config.ShopCategories.Values.Select(x => x.EnabledCategory))
                if (enabled)
                    AnyShops++;

            if (AnyShops > 0)
                foreach (var player in BasePlayer.activePlayerList) CreateGUIShopButton(player);
        }

        private void OnLangAPIFinished()
        {
            _isLangAPIReady = true;
        }

        #endregion

        #region Main GUIShop UI

        private CuiElementContainer CreateGUIShopOverlay(BasePlayer player, bool toggle)
        {
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiElement
            {
                DestroyUi = "ButtonBack",
            });

            string material = _config.BackgroundImage ? "" : "RobotoCondensed-Bold.ttf";

            container.Add(new CuiPanel //This is the background transparency slider!
                {
                    Image =
                    {
                        Color = $"0 0 0 {GetUITransparency(player)}",
                        Material = material
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0", 
                        AnchorMax = "1 1"
                    },
                    CursorEnabled = true
                },
                "Overlay", GUIShopOverlayName);

            if (_config.BackgroundImage)
                container.Add(new CuiElement //Background image fix
                {
                    Parent = GUIShopOverlayName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", GUIShopBackgroundImage) //updated 2.0.7
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        }
                    }
                });

            if (toggle)
            {
                container.Add(new CuiElement // GUIShop Welcome MSG
                {
                    Parent = GUIShopOverlayName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", GUIShopWelcomeImage)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.3 0.85",
                            AnchorMax = "0.7 0.95"
                        }
                    }
                });

                /*
                container.Add(new CuiElement // Limit Icon
                {
                    Parent = ShopOverlayName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Url = GetText("", "image", player) // // Adjust position/size
                            // Png = ImageLibrary?.Call<string>("GetImage", LimitUrl)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.28 0.6",
                            AnchorMax = "0.33 0.65"
                        }
                    }
                });
                */

                container.Add(new CuiElement // Amount Icon
                {
                    Parent = GUIShopOverlayName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", GUIShopAmount1Image) //2.0.7
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.53 0.6", 
                            AnchorMax = "0.58 0.65"
                        }
                    }
                });

                container.Add(new CuiElement // Buy Icon
                {
                    Parent = GUIShopOverlayName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", GUIShopBuyImage) //2.0.7
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.435 0.6", 
                            AnchorMax = "0.465 0.65"
                        }
                    }
                });

                container.Add(new CuiElement // Sell Icon
                {
                    Parent = GUIShopOverlayName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", GUIShopSellImage) //2.0.7
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.685 0.6", //Second digit = Hight Done. First Digit = Position on screen from left to right.
                            AnchorMax = "0.745 0.65" //Left to right size for msg
                        }
                    }
                });

                container.Add(new CuiElement // Amount Icon
                {
                    Parent = GUIShopOverlayName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", GUIShopAmount2Image) //2.0.7
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.8 0.6", 
                            AnchorMax = "0.85 0.65"
                        }
                    }
                });

                container.Add(new CuiElement //close button image
                {
                    Parent = GUIShopOverlayName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", GUIShopCloseImage) //2.0.7
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.45 0.14", 
                            AnchorMax = "0.55 0.19"
                        }
                    }
                });
            }

            container.Add(new CuiLabel //Welcome Msg
                {
                    Text =
                    {
                        Text = GetText(_config.WelcomeMsg, "label", player), //Updated to config output. https://i.imgur.com/Y9n5KgO.png
                        FontSize = 30,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.3 0.85", 
                        AnchorMax = "0.7 0.95"
                    }
                },
                GUIShopOverlayName);

            container.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = GetText("", "label", player), //added Config output
                        FontSize = 20,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.2 0.6",
                        AnchorMax = "0.5 0.65" //"0.23 0.65" rebranded to Limit
                    }
                },
                GUIShopOverlayName);

            /*container.Add(new CuiLabel  //Adding missing Lable for limit function TODO
                {
                    Text = {
                        Text = "Limits",
                        FontSize = 20,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter,
                    },
                    RectTransform = {
                        AnchorMin = "0.18 0.6", //"0.2 0.6", Buy
                        AnchorMax = "0.5 0.65" //"0.7 0.65"  Buy
                    }
                },
                ShopOverlayName);  */

            container.Add(new CuiLabel // Amount Label
                {
                    Text =
                    {
                        Text = GetText(_config.AmountLabel, "label", player),
                        FontSize = 20,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleLeft
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.535 0.6", 
                        AnchorMax = "0.7 0.65"
                    }
                },
                GUIShopOverlayName);

            container.Add(new CuiLabel // Buy Price Label,
                {
                    Text =
                    {
                        Text = GetText(_config.BuyLabel, "label", player), //Updated
                        FontSize = 20,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.4 0.6", 
                        AnchorMax = "0.5 0.65"
                    }
                },
                GUIShopOverlayName);

            container.Add(new CuiLabel // Sell label
                {
                    Text =
                    {
                        Text = GetText(_config.SellLabel, "label", player), //Sell $
                        FontSize = 20,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.54 0.6", //Second digit = Hight Done.
                        AnchorMax = "0.89 0.65" //Left to right size for msg
                    }
                },
                GUIShopOverlayName);

            container.Add(new CuiLabel //Amount Label
                {
                    Text =
                    {
                        Text = GetText(_config.AmountLabel2, "label", player),
                        FontSize = 20,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.75 0.6", 
                        AnchorMax = "0.9 0.65"
                    }
                },
                GUIShopOverlayName);

            container.Add(new CuiButton //close button Label
                {
                    Button =
                    {
                        Close = GUIShopOverlayName,
                        Color = "0 0 0 0.40" //"1.4 1.4 1.4 0.14"  new
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.45 0.14", 
                        AnchorMax = "0.55 0.19"
                    },
                    Text =
                    {
                        Text = GetText(_config.CloseButtonlabel, "label", player),
                        FontSize = 20,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter
                    }
                },
                GUIShopOverlayName);

            return container;
        }

        private readonly CuiLabel _guishopDescription = new CuiLabel
        {
            Text =
            {
                Text = "{shopdescription}",
                FontSize = 15,
                Align = TextAnchor.MiddleCenter
            },
            RectTransform =
            {
                AnchorMin = "0.2 0.7", 
                AnchorMax = "0.8 0.75"
            }
        };

        private CuiElementContainer CreateGUIShopItemEntry(ShopItem shopItem, float ymax, float ymin, string shopKey, string color, bool pricebuttons, bool cooldown, BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = $"{(pricebuttons ? shopItem.GetSellPrice(player.UserIDString) : shopItem.GetBuyPrice(player.UserIDString))}",
                        FontSize = 15,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = $"{(pricebuttons ? 0.675 : 0.4)} {ymin}",
                        AnchorMax = $"{(pricebuttons ? 0.755 : 0.5)} {ymax}"
                    }
                },
                GUIShopContentName);

            bool isKitOrCommand = !shopItem.Command.IsNullOrEmpty() || !string.IsNullOrEmpty(shopItem.KitName);

            // TODO finish feature integrations
            //bool isPrerequisite = !shopItem.Prerequisite.IsNullOrEmpty();
            // itemCount % 7 == 0 ? itemCount / 7 - 1: itemCount / 7;
           // finish autofix function > for experimental feature int[] autoFix = pricebuttons ? shopItem.SwapLimitToQuantitySoldLimit && shopItem.SellQuantity.Length == 1 && shopItem.SellLimit > 0 && shopItem.SellLimit % shopItem.SellQuantity.FirstOrDefault() == 0 ? shopItem.SellQuantity :  : shopItem.SwapLimitToQuantityBuyLimit && shopItem.BuyQuantity.Length > 0 ? : ;
            int[] maxSteps = pricebuttons ? shopItem.SellLimit == 0 && shopItem.SellQuantity.Length == 0 ? _config.steps : shopItem.SellLimit == 0 ? shopItem.SellQuantity :  shopItem.SellQuantity.Length == 0 ? new[] {1} : shopItem.SellQuantity : shopItem.BuyLimit == 0 && shopItem.BuyQuantity.Length == 0 ? _config.steps : shopItem.BuyLimit == 0 ? shopItem.BuyQuantity :  shopItem.BuyQuantity.Length == 0 ? new[] {1} : shopItem.BuyQuantity;

            if (isKitOrCommand)
            {
                maxSteps = new[] {1};
            }

            if (cooldown)
            {
                return container;
            }

            for (var i = 0; i < maxSteps.Length; i++)
            {
                container.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"shop.{(pricebuttons ? "Sell" : "buy")} {shopKey.Replace(" ", "_")} {shopItem.DisplayName.Replace(" ", "_")} {maxSteps[i]}",
                        Color = color
                    },
                    RectTransform =
                    {
                        AnchorMin = $"{(pricebuttons ? 0.775 : 0.5) + i * 0.03 + 0.001} {ymin}",
                        AnchorMax = $"{(pricebuttons ? 0.805 : 0.53) + i * 0.03 - 0.001} {ymax}"
                    },
                    Text =
                    {
                        Text = maxSteps[i].ToString(),
                        FontSize = 15,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter
                    }
                }, GUIShopContentName);
            }

            if (!isKitOrCommand && !(!pricebuttons && shopItem.BuyCooldown > 0 || pricebuttons && shopItem.SellCooldown > 0) && !(!pricebuttons && shopItem.BuyLimitResetCoolDown > 0 || pricebuttons && shopItem.SellLimitResetCoolDown > 0))
            {
                container.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"shop.{(pricebuttons ? "Sell" : "buy")} {shopKey.Replace(" ", "_")} {shopItem.DisplayName.Replace(" ", "_")} all",
                        Color = color
                    },
                    RectTransform =
                    {
                        AnchorMin = $"{(pricebuttons ? _config.SellAllButton ? 0.775 : 0 : _config.BuyAllButton ? 0.5 : 0) + maxSteps.Length * 0.03 + 0.001} {ymin}",
                        AnchorMax = $"{(pricebuttons ? _config.SellAllButton ? 0.805 : 0 : _config.BuyAllButton ? 0.53 : 0) + maxSteps.Length * 0.03 - 0.001} {ymax}"
                    },
                    Text =
                    {
                        Text = "All",
                        FontSize = 15,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter
                    }
                }, GUIShopContentName);
            }

            return container;
        }

        private void CreateGUIShopItemIcon(ref CuiElementContainer container, string item, float ymax, float ymin, ShopItem data, BasePlayer player)
        {
            var label = new CuiLabel
            {
                Text =
                {
                    Text = item,
                    FontSize = 15,
                    Color = GetUITextColor(player, _config.TextColor),
                    Align = TextAnchor.MiddleLeft
                },
                RectTransform =
                {
                    AnchorMin = $"0.05 {ymin}", 
                    AnchorMax = $"0.34 {ymax}"
                } // 0.1 0.3
            };

            container.Add(label, GUIShopContentName);

            if (!string.IsNullOrEmpty(data.Image))
            {
                string image = null;

                if ((bool)(ImageLibrary?.Call("HasImage", data.Image, 0UL) ?? false))
                    image = (string)ImageLibrary?.Call("GetImage", data.Image, 0UL, false);
                else
                    image = (string) ImageLibrary?.Call("GetImage", _config.IconUrl);

                container.Add(new CuiElement
                {
                    Parent = GUIShopContentName,
                    Components =
                    {
                        new CuiRawImageComponent { Png = image },
                        new CuiRectTransformComponent { AnchorMin = $"0.01 {ymin}", AnchorMax = $"0.04 {ymax}" } // 0.05 0.08
                    }
                });
            }
            else
            {
               // Puts($"{data.DisplayName} ,{data.SkinId}");
                container.Add(new CuiElement
                {
                    Parent = GUIShopContentName,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            ItemId = data.ItemId,
                            SkinId = data.SkinId,
                        },
                        new CuiRectTransformComponent { AnchorMin = $"0.01 {ymin}", AnchorMax = $"0.04 {ymax}" } // 0.05 0.08
                    }
                });
            }

        }

        private void CreateGUIShopColorChanger(ref CuiElementContainer container, string shopKey, BasePlayer player, bool toggle)
        {
            container.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = "Personal UI Settings",
                        FontSize = 15,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.18 0.11", 
                        AnchorMax = "0.33 0.15"
                    }
                },
                GUIShopOverlayName, "DisplayTag");

            container.Add(new CuiButton //set button 1 + color
                {
                    Button =
                    {
                        Command = $"shop.colorsetting Text {shopKey.Replace(" ", "_")}",
                        Close = GUIShopOverlayName,
                        Color = GetSettingTypeToChange("Text")
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.10 0.09", 
                        AnchorMax = "0.17 0.12"
                    },
                    Text =
                    {
                        Text = "Set Text Color",
                        FontSize = 15,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf"
                    }
                },
                GUIShopOverlayName,
                "SetTextColor");

            container.Add(new CuiButton //Toggle Botton (Has enable/disable config option)
                {
                    Button =
                    {
                        Command = $"shop.imageortext {shopKey.Replace(" ", "_")}",
                        Close = GUIShopOverlayName,
                        Color = "0 0 0 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.06 0.09", 
                        AnchorMax = "0.10 0.12"
                    },
                    Text =
                    {
                        Text = "Toggle",
                        FontSize = 15,
                        Color = GetUITextColor(player, _config.TextColor),
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf"
                    }
                },
                GUIShopOverlayName,
                "Toggle");

            container.Add(new CuiButton //set button 3
                {
                    Button =
                    {
                        Command = $"shop.colorsetting Sell {shopKey.Replace(" ", "_")}",
                        Close = GUIShopOverlayName,
                        Color = GetSettingTypeToChange("Sell")
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.10 0.05", 
                        AnchorMax = "0.17 0.08"
                    },
                    Text =
                    {
                        Text = "Sell Color",
                        FontSize = 15,
                        Align = TextAnchor.MiddleCenter,
                        Color = GetUITextColor(player, _config.TextColor),
                        Font = "robotocondensed-regular.ttf"
                    }
                },
                GUIShopOverlayName,
                "SellChanger");

            container.Add(new CuiButton //set button 2
                {
                    Button =
                    {
                        Command = $"shop.colorsetting Buy {shopKey.Replace(" ", "_")}",
                        Close = GUIShopOverlayName,
                        Color = GetSettingTypeToChange("Buy")
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.10 0.02", 
                        AnchorMax = "0.17 0.05"
                    },
                    Text =
                    {
                        Text = "Buy Color",
                        FontSize = 15,
                        Align = TextAnchor.MiddleCenter,
                        Color = GetUITextColor(player, _config.TextColor),
                        Font = "robotocondensed-regular.ttf"
                    }
                },
                GUIShopOverlayName,
                "BuyChanger");

            container.Add(new CuiLabel //Display Bar
                {
                    Text =
                    {
                        Text = "ⅢⅢⅢⅢⅢⅢⅢⅢ",
                        Color = GetUITextColor(player, _config.TextColor),
                        FontSize = 20,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.80 0.19", 
                        AnchorMax = $"{0.80 + AnchorBarMath(player)} 0.24"
                    }
                },
                GUIShopOverlayName, "ProgressBar");

            if (toggle)
            {
                container.Add(new CuiElement
                {
                    Parent = GUIShopOverlayName, Name = "toggled",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", GUIShopForwardArrowImage)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.85 0.14",
                            AnchorMax = "0.90 0.19"
                        }
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = GUIShopOverlayName, Name = "toggled2",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", GUIShopBackArrowImage)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.80 0.14",
                            AnchorMax = "0.85 0.19"
                        }
                    }
                });
            }

            container.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"shop.transparency increase {shopKey.Replace(" ", "_")}",
                        Close = GUIShopOverlayName,
                        Color = "0 0 0 0.40"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.85 0.14", 
                        AnchorMax = "0.90 0.19"
                    },
                    Text =
                    {
                        Text = GetText(_config.ForwardButtonText, "label", player), //_config.ForwardButtonText
                        Color = GetUITextColor(player, _config.TextColor),
                        FontSize = 30, Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf"
                    }
                },
                GUIShopOverlayName, "MoreTP");

            container.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"shop.transparency decrease {shopKey.Replace(" ", "_")}",
                        Close = GUIShopOverlayName,
                        Color = "0 0 0 0.40"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.80 0.14", 
                        AnchorMax = "0.85 0.19"
                    },
                    Text =
                    {
                        Text = GetText(_config.BackButtonText, "label", player),
                        Color = GetUITextColor(player, _config.TextColor),
                        FontSize = 30, Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf"
                    }
                },
                GUIShopOverlayName, "LessTP");

            container.Add(new CuiPanel
            {
                Image =
                {
                    Color = $"0 0 0 0"
                },
                RectTransform =
                {
                    AnchorMin = "0.18 0.01", 
                    AnchorMax = "0.33 0.12"
                }
            }, GUIShopOverlayName, GUIShopColorPicker);

            int itemPos = 0;

            foreach (string color in _config.ColorsUI)
            {
                int numberPerRow = 4;

                float padding = 0.03f; // Space between each 
                float margin = (0.01f + padding); //left to right alignment adjuster

                //Puts("{0}", padding * (numberPerRow + 1) / numberPerRow);
                float width = ((0.975f - (padding * (numberPerRow + 1))) / numberPerRow);
                //Puts("{0}", width * 1.75f);
                float height = (width * 1.975f);

                int row = (int) Math.Floor((float) itemPos / numberPerRow);
                int col = (itemPos - (row * numberPerRow));
                container.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"shop.uicolor {HexToColor(color)} {shopKey.Replace(" ", "_")}",
                        Close = GUIShopOverlayName,
                        Color = $"{HexToColor(color)} 0.9"
                    },
                    RectTransform =
                    {
                        AnchorMin = $"{margin + (width * col) + (padding * col)} {(0.975f - padding) - ((row + 1) * height) - (padding * row)}",
                        AnchorMax = $"{margin + (width * (col + 1)) + (padding * col)} {(0.93f - padding) - (row * height) - (padding * row)}"
                    },
                    Text =
                    {
                        Text = "",
                    }
                }, GUIShopColorPicker, $"ColorPicker_{color}");
                itemPos++;
            }
        }

        private void CreateGUIShopChangePage(ref CuiElementContainer container, string shopKey, int minus, int plus, BasePlayer player, bool toggle)
        {
            if (toggle)
            {
                container.Add(new CuiElement
                {
                    Parent = GUIShopOverlayName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", GUIShopBackArrowImage)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.345 0.14",
                            AnchorMax = "0.445 0.19"
                        }
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = GUIShopOverlayName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ImageLibrary?.Call<string>("GetImage", GUIShopForwardArrowImage)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.555 0.14",
                            AnchorMax = "0.655 0.19"
                        }
                    }
                });
            }

            if (_shopPage[player.userID] != minus)
            {
                container.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = $"shop.show {shopKey.Replace(" ", "_")} {minus}",
                            Color = "0 0 0 0.40"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.345 0.14", 
                            AnchorMax = "0.445 0.19"
                        },
                        Text =
                        {
                            Text = GetText(_config.BackButtonText, "label", player),
                            Color = GetUITextColor(player, _config.TextColor),
                            FontSize = 30,
                            Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf"
                        }
                    },
                    GUIShopOverlayName,
                    "ButtonBack");
            }

            if (_shopPage[player.userID] != plus)
            {
                container.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = $"shop.show {shopKey.Replace(" ", "_")} {plus}",
                            Color = "0 0 0 0.40"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.555 0.14",
                            AnchorMax = "0.655 0.19"
                        },
                        Text =
                        {
                            Text = GetText(_config.ForwardButtonText, "label", player),
                            Color = GetUITextColor(player, _config.TextColor),
                            FontSize = 30,
                            Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf"
                        }
                    },
                    GUIShopOverlayName,
                    "ButtonForward");
            }
        }

        private void CreateShopButton(ref CuiElementContainer container, ShopCategory shopCategory, int minus, int rowPos, BasePlayer player) 
        {
            container.Add(new CuiButton
            {
                Button =
                {
                    Command = $"shop.show {shopCategory.DisplayName.Replace(" ", "_")} {minus}",
                    Color = "0.5 0.5 0.5 0.5" //"1.2 1.2 1.2 0.24" new
                },
                RectTransform =
                {
                    AnchorMin = _categoryRects[rowPos][0], // $"{(0.09 + (rowPos * 0.056))} 0.78", // * 0.056 = Margin for more buttons... less is better
                    AnchorMax = _categoryRects[rowPos][1] //$"{(0.14 + (rowPos * 0.056))} 0.82"
                },
                Text =
                {
                    Text = Lang(shopCategory.DisplayName, player.UserIDString),
                    Align = TextAnchor.MiddleCenter,
                    Color = GetUITextColor(player, shopCategory.DisplayNameColor ?? _config.TextColor),
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12
                }
            }, GUIShopOverlayName, shopCategory.DisplayName);
        }

        private void DestroyUi(BasePlayer player, bool full = false)
        {
            CuiHelper.DestroyUi(player, GUIShopContentName);
            CuiHelper.DestroyUi(player, "ButtonForward");
            CuiHelper.DestroyUi(player, "ButtonBack");
            if (!full) return;
            CuiHelper.DestroyUi(player, GUIShopDescOverlay);
            CuiHelper.DestroyUi(player, GUIShopOverlayName);
        }

        #endregion

        #region GUIShop Overlay Button

        private void CreateGUIShopButton(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId() || !player.IsAlive()) return;

            if (!permission.UserHasPermission(player.UserIDString, Button)) return;

            if (_playerDisabledButtonData.Contains(player.UserIDString))
            {
                DestroyGUIShopButton(player); 
                return;
            }

            CuiHelper.DestroyUi(player, Button);
            var elements = new CuiElementContainer();
            var shopButton = elements.Add(new CuiPanel
            {
                Image = { Color = _instance._config.GUI.Color }, //$"{HexToColor(_instance._config.GUI.Color)} 0.15" },
                RectTransform = {
                    AnchorMin = _config.GUI.GUIButtonPosition.AnchorsMin,
                    AnchorMax = _config.GUI.GUIButtonPosition.AnchorsMax,
                    OffsetMin = _config.GUI.GUIButtonPosition.OffsetsMin,
                    OffsetMax = _config.GUI.GUIButtonPosition.OffsetsMax
                },
                CursorEnabled = false
            }, "Overlay", Button);

            elements.Add(new CuiElement
            {
                Parent = Button,
                Components = {
                    new CuiRawImageComponent { Png = ImageLibrary?.Call<string>("GetImage", GUIShopShopButton) },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            elements.Add(new CuiButton
            {
                Button =
                {
                    Command = "shop.button", 
                    Color = "0 0 0 0"
                },
                RectTransform =
                {
                    AnchorMin = "0 0", 
                    AnchorMax = "1 1"
                },
                Text =
                {
                    Text = ""
                }
            }, shopButton);

            CuiHelper.AddUi(player, elements);
        }

        private void DestroyGUIShopButton(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Button);
        }

        #endregion

        #region Currency

        [Flags]
        public enum InventoryTypes
        {
            ContainerMain,
            ContainerBelt,
            ContainerWear,
            ContainerAll = ContainerMain | ContainerBelt | ContainerWear
        }

        private int GetAmount(PlayerInventory inventory, InventoryTypes type, int itemid, string display, bool used, ulong skinId = 0UL)
        {
            if (itemid == 0)
                return 0;
            int num = 0;
            if (inventory.containerMain != null && type.HasFlag(InventoryTypes.ContainerMain))
                num += GetAmount(inventory.containerMain, itemid, display, used, skinId);
            if (inventory.containerBelt != null && type.HasFlag(InventoryTypes.ContainerBelt))
                num += GetAmount(inventory.containerBelt, itemid, display, used, skinId);
            if (inventory.containerWear != null && type.HasFlag(InventoryTypes.ContainerWear))
                num += GetAmount(inventory.containerWear, itemid, display, used, skinId);
            return num;
        }

        private int GetAmount(ItemContainer container, int itemid, string display, bool used, ulong skinId)
        {
            int num = 0;
            foreach (Item obj in container.itemList)
            {
                if (obj.isBroken || obj.hasCondition && !used && obj.amount == 1 && obj.condition < obj.info.condition.max) continue;

                if (!string.IsNullOrEmpty(display) ? 
                        obj.name == display && obj.info.itemid == itemid && obj.skin == skinId && (!obj.hasCondition || used && obj.hasCondition || obj.hasCondition && obj.condition == obj.info.condition.max || obj.hasCondition && !used && obj.amount != 1 && obj.condition < obj.info.condition.max) : 
                        string.IsNullOrEmpty(display) && obj.info.itemid == itemid && obj.skin == skinId && (!obj.hasCondition || used && obj.hasCondition || obj.hasCondition && obj.condition == obj.info.condition.max || obj.hasCondition && !used && obj.amount != 1 && obj.condition < obj.info.condition.max))
                {
                    if (!obj.hasCondition || used && obj.hasCondition || obj.hasCondition && obj.condition == obj.info.condition.max)
                        num += obj.amount;
                    else
                        num += obj.amount - 1;
                }
            }
            return num;
        }

        private double GetCurrency(ShopCategory shop, BasePlayer player)
        {
            if (shop?.Currency.Contains("custom") == true)
            {
                return GetAmount(player.inventory, _config.AllowedSellContainers, shop.CustomCurrencyIDs, shop.CustomCurrencyNames, shop.CustomCurrencyAllowSellOfUsedItems, shop.CustomCurrencySkinIDs);
            }

            if (Economics != null && (_config.Economics || shop?.Currency.Contains("economics") == true))
            {
                return (double) Economics.Call("Balance", player.UserIDString);
            }

            if (ServerRewards != null && (_config.ServerRewards || shop?.Currency.Contains("serverrewards") == true))
            {
                return (int)ServerRewards.Call("CheckPoints", player.UserIDString);
            }

            if (_config.CustomCurrency)
            {
                return GetAmount(player.inventory, _config.AllowedSellContainers, _config.CustomCurrencyID, _config.CustomCurrencyName, _config.CustomCurrencyAllowSellOfUsedItems, _config.CustomCurrencySkinID);
            }

            return 0;
        }

        private int Take(PlayerInventory inventory, InventoryTypes type, List<Item> collect, int itemid, int amount, bool used, string display, ulong skinId = 0UL)
        {
            int num1 = 0;
            if (inventory.containerMain != null && type.HasFlag(InventoryTypes.ContainerMain))
            {
                int num2 = Take(inventory.containerMain, collect, itemid, amount, used, display, skinId);
                num1 += num2;
                amount -= num2;
            }

            if (amount <= 0)
                return num1;
            if (inventory.containerBelt != null && type.HasFlag(InventoryTypes.ContainerBelt))
            {
                int num2 = Take(inventory.containerBelt, collect, itemid, amount, used, display, skinId);
                num1 += num2;
                amount -= num2;
            }

            if (amount <= 0 || inventory.containerWear == null && type.HasFlag(InventoryTypes.ContainerWear))
                return num1;
            int num3 = Take(inventory.containerWear, collect, itemid, amount, used, display, skinId);
            num1 += num3;
            amount -= num3;
            return num1;
        }

        private int Take(ItemContainer container, List<Item> collect, int itemid, int iAmount, bool used, string display, ulong skinId)
        {
            int num1 = 0;
            if (iAmount == 0) return num1;
            List<Item> list = Facepunch.Pool.GetList<Item>();
            foreach (Item obj in container.itemList)
            {
                if (obj.isBroken || obj.hasCondition && used == false && obj.amount == 1 && obj.condition < obj.info.condition.max) continue;
                if (obj.info.itemid == itemid && obj.skin == skinId && (display.IsNullOrEmpty() ? used ? !obj.hasCondition || obj.hasCondition : !obj.hasCondition || obj.hasCondition && obj.condition == obj.maxCondition :
                        obj.name.IsNullOrEmpty() || !obj.name.IsNullOrEmpty() && obj.name == display && used ? !obj.hasCondition || obj.hasCondition : !obj.hasCondition || obj.hasCondition && obj.condition == obj.maxCondition))
                {
                    int num2 = iAmount - num1;
                    if (num2 > 0)
                    {
                        if (obj.amount > num2)
                        {
                            obj.MarkDirty();
                            obj.amount -= num2;
                            num1 += num2;
                            obj.name = display;
                            Item byItemId = ItemManager.CreateByItemID(itemid);
                            byItemId.amount = num2;
                            byItemId.CollectedForCrafting(container.playerOwner);
                            if (collect != null)
                            {
                                collect.Add(byItemId);
                                break;
                            }

                            break;
                        }

                        if (obj.amount <= num2)
                        {
                            num1 += obj.amount;
                            list.Add(obj);
                            collect?.Add(obj);
                        }

                        if (num1 == iAmount)
                            break;
                    }
                }
            }

            foreach (Item obj in list)
            {
                obj.RemoveFromContainer();
                obj.Remove();
            }
            Facepunch.Pool.FreeList<Item>(ref list);
            return num1;
        }

        private int GetAmountPrice(double amount)
        {
            if (amount <= 0.5)
            {
                return (int)Math.Ceiling(amount);
            }
        
            return (int)Math.Round(amount);
        }

        private bool TakeCurrency(ShopCategory shop, BasePlayer player, double amount)
        {
            if (shop?.Currency.Contains("custom") == true && GetAmount(player.inventory, _config.AllowedSellContainers, shop.CustomCurrencyIDs, shop.CustomCurrencyNames, shop.CustomCurrencyAllowSellOfUsedItems, shop.CustomCurrencySkinIDs) >= GetAmountPrice(amount))
            {
                if (string.IsNullOrEmpty(shop.CustomCurrencyNames) == false)
                {
                    Take(player.inventory, _config.AllowedSellContainers, null, shop.CustomCurrencyIDs, GetAmountPrice(amount), shop.CustomCurrencyAllowSellOfUsedItems, shop.CustomCurrencyNames, shop.CustomCurrencySkinIDs);
                    return true;
                }
                Take(player.inventory, _config.AllowedSellContainers, null, shop.CustomCurrencyIDs, GetAmountPrice(amount), shop.CustomCurrencyAllowSellOfUsedItems, null, shop.CustomCurrencySkinIDs);
                return true;
            }

            if (_config.Economics && Economics != null || Economics != null && shop?.Currency.Contains("economics") == true)
            {
                return Economics.Call<bool>("Withdraw", player.UserIDString, amount);
            }

            if (_config.ServerRewards && ServerRewards != null || ServerRewards != null && shop?.Currency.Contains("serverrewards") == true)
            {
                return ServerRewards.Call<object>("TakePoints", player.userID, GetAmountPrice(amount)) != null;
            }

            if (_config.CustomCurrency && GetAmount(player.inventory, _config.AllowedSellContainers, _config.CustomCurrencyID, _config.CustomCurrencyName, _config.CustomCurrencyAllowSellOfUsedItems, _config.CustomCurrencySkinID) >= GetAmountPrice(amount))
            {
                if (_config.CustomCurrencyName.IsNullOrEmpty() == false)
                {
                    Take(player.inventory, _config.AllowedSellContainers, null, _config.CustomCurrencyID, GetAmountPrice(amount), _config.CustomCurrencyAllowSellOfUsedItems, _config.CustomCurrencyName, _config.CustomCurrencySkinID);
                    return true;
                }
                Take(player.inventory, _config.AllowedSellContainers, null, _config.CustomCurrencyID, GetAmountPrice(amount), _config.CustomCurrencyAllowSellOfUsedItems, null, _config.CustomCurrencySkinID);
                return true;
            }

            return false;
        }

        private void AddCurrency(ShopCategory shop, BasePlayer player, double amount, string item) // Updated 2.2.49 Fixed Currency item not including names?
        {
            if (shop?.Currency.Contains("custom") == true)
            {
                Item currency = ItemManager.CreateByItemID(shop.CustomCurrencyIDs, GetAmountPrice(amount), shop.CustomCurrencySkinIDs);
                if (!shop.CustomCurrencyNames.IsNullOrEmpty())
                {
                    currency.name = shop.CustomCurrencyNames;
                    //currency.MarkDirty();
                }
                player.GiveItem(currency);
                return;
            }

            if (_config.Economics && Economics != null || Economics != null && shop?.Currency.Contains("economics") == true || Economics != null && item.Contains("economics") && _isEconomicsDebt)
            {
                Economics?.Call("Deposit", player.UserIDString, amount);
                return;
            }

            if (_config.ServerRewards && ServerRewards != null || ServerRewards != null && shop?.Currency.Contains("serverrewards") == true)
            {
                ServerRewards?.Call("AddPoints", player.UserIDString, GetAmountPrice(amount));
                return;
            }

            if (_config.CustomCurrency)
            {
                Item currency = ItemManager.CreateByItemID(_config.CustomCurrencyID, GetAmountPrice(amount), _config.CustomCurrencySkinID);
                if (!_config.CustomCurrencyName.IsNullOrEmpty())
                {
                    currency.name = _config.CustomCurrencyName;
                    //currency.MarkDirty();
                }

                player.GiveItem(currency);
            }
        }

        #endregion

        #region Shop

        private void ShowGUIShops(BasePlayer player, string shopKey, int from = 0, bool fullPaint = true, bool refreshFunds = false)
        {
            bool toggle = GetPlayerData(player).ImageOrText;
            _shopPage[player.userID] = from;

            ShopCategory shop;
            if (!_config.ShopCategories.TryGetValue(shopKey, out shop))
            {
                SendReply(player, Lang("ErrorShop", player.UserIDString));
                return;
            }

            if (_config.BlockMonuments && !shop.EnableNPC && IsNearMonument(player))
            {
                SendReply(player, Lang("BlockedMonuments", player.UserIDString));
                return;
            }

            ItemLimit itemLimit = GetPlayerLimit(player);
            double playerCoins = GetCurrency(shop, player);

            CuiElementContainer container;

            _guishopDescription.Text.Text = string.Format(shop.Description, playerCoins);
            _guishopDescription.Text.Color = GetUITextColor(player, shop.DescriptionColor ?? _config.TextColor);

            if (fullPaint)
            {
                CuiHelper.DestroyUi(player, GUIShopOverlayName);

                container = CreateGUIShopOverlay(player, toggle);

                container.Add(_guishopDescription, GUIShopOverlayName, GUIShopDescOverlay);

                if (permission.UserHasPermission(player.UserIDString, Color) || _config.PersonalUI)
                {
                    CreateGUIShopColorChanger(ref container, shopKey, player, toggle); //2.0.7 updating UI
                }

                int rowPos = 0;

                string vendor = String.Empty;
                foreach (string id in shop.NpcIds)
                {
                    if (NearNpc(id ,player))
                    {
                        vendor = id;
                    }
                }

                if (shop.EnableNPC && !string.IsNullOrEmpty(vendor))
                {
                    foreach (ShopCategory cat in _config.ShopCategories.Values.Where(i => i.EnableNPC && i.NpcIds.Contains(vendor)))
                    {
                        if (!string.IsNullOrEmpty(cat.Permission) && !permission.UserHasPermission(player.UserIDString, cat.PrefixPermission)) continue;
                        CreateShopButton(ref container, cat, from, rowPos, player);
                        rowPos++;
                    }
                }
                else
                {
                    foreach (ShopCategory cat in _config.ShopCategories.Values.Where(i => i.EnabledCategory))
                    {
                        if (!string.IsNullOrEmpty(cat.Permission) && !permission.UserHasPermission(player.UserIDString, cat.PrefixPermission)) continue;
                        CreateShopButton(ref container, cat, from, rowPos, player);
                        rowPos++;
                    }
                }
            }
            else
            {
                container = new CuiElementContainer();
            }

            CuiHelper.DestroyUi(player, GUIShopContentName);
            CuiHelper.DestroyUi(player, "ButtonBack");
            CuiHelper.DestroyUi(player, "ButtonForward");

            container.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0"  //was 0 0 0 1
                },
                RectTransform =
                {
                    AnchorMin = "0 0.2", 
                    AnchorMax = "1 0.6"
                }
            }, GUIShopOverlayName, GUIShopContentName);

            if (refreshFunds)
            {
                CuiHelper.DestroyUi(player, GUIShopDescOverlay);
                container.Add(_guishopDescription, GUIShopOverlayName, GUIShopDescOverlay);
            }

            int itemIndex = 0;

            GetCategoryItems(shop);

            foreach (ShopItem data in shop.ShopItems.Skip(from * 7).Take(7))
            {
                float cachedRect = _itemRects[itemIndex][0];
                float cachedRect2 = _itemRects[itemIndex][1];
                string name = data.DisplayName; // TODO: Updated 12/12 2020

                itemLimit.CheckBuyLimit(data.Shortname, data.BuyLimit);
                itemLimit.CheckSellLimit(data.Shortname, data.SellLimit);

                int B = 0;
                int S = 0;

                if (data.BuyLimit > 0)
                {
                    B = itemLimit.BLimit[data.Shortname] == 0 ? data.BuyLimit : data.BuyLimit - itemLimit.BLimit[data.Shortname];
                }

                if (data.SellLimit > 0)
                {
                    S = itemLimit.SLimit[data.Shortname] == 0 ? data.SellLimit : data.SellLimit - itemLimit.SLimit[data.Shortname];
                }

                string cooldowndescription = string.Empty;
                string limitdescription = string.Empty;

                double sellCooldown;
                double buyCooldown;
                double buylimitcooldown;
                double selllimitcooldown;

                bool hasSellCooldown =
                    data.SellLimitResetCoolDown > 0 && HasSellLimitCoolDown(player.userID, data.DisplayName, out selllimitcooldown) ||
                    data.SellCooldown > 0 && HasSellCooldown(player.userID, data.DisplayName, out sellCooldown);

                bool hasBuyCooldown =
                    data.BuyLimitResetCoolDown > 0 && HasBuyLimitCoolDown(player.userID, data.DisplayName, out buylimitcooldown) ||
                    data.BuyCooldown > 0 && HasBuyCooldown(player.userID, data.DisplayName, out buyCooldown);

                bool cooldown = data.BuyCooldown > 0 || data.SellCooldown > 0 || data.BuyLimit > 0 || data.SellLimit > 0;

                if (data.BuyCooldown > 0)
                {
                    cooldowndescription += $" (Buy CoolDown  {FormatTime(data.BuyCooldown)})";
                }

                if (data.SellCooldown > 0)
                {
                    cooldowndescription += $" (Sell CoolDown  {FormatTime(data.SellCooldown)})"; //TODO: Add into lang file/multi support
                }

                if (data.BuyLimit > 0)
                {
                    if (data.BuyLimitResetCoolDown > 0 && HasBuyLimitCoolDown(player.userID, data.DisplayName, out buylimitcooldown))
                    {
                        limitdescription += $" (Out of Stock)";
                    }
                    else
                    {
                        limitdescription += $" (Buy Limit {B})";
                    }
                }

                if (data.SellLimit > 0)
                {
                    if (data.SellLimitResetCoolDown > 0 && HasSellLimitCoolDown(player.userID, data.DisplayName, out selllimitcooldown))
                    {
                        limitdescription += $" (Out of Stock)";
                    }
                    else
                    {
                        limitdescription += $" (Sell Limit {S})";
                    }
                }

                /*Lang(name, player.UserIDString)*/
                name = $"{GetItemDisplayName(data.Shortname, data.DisplayName, player.UserIDString)}<size=11>{(cooldown ? "\n" + cooldowndescription + limitdescription : "")}</size>"; //added Updated,  Creates new line for cooldowns under the Displayed Item Names.

                CreateGUIShopItemIcon(ref container, name, cachedRect, cachedRect2, data, player);

                if (data.EnableBuy)
                    container.AddRange(CreateGUIShopItemEntry(data, cachedRect, cachedRect2, shopKey, GetUIBuyBoxColor(player), false, hasBuyCooldown, player));

                if (data.EnableSell)
                    container.AddRange(CreateGUIShopItemEntry(data, cachedRect, cachedRect2, shopKey, GetUISellBoxColor(player), true,
                        hasSellCooldown, player));

                itemIndex++;
            }

            int itemCount = shop.ShopItems.Count;
            int totalPages = itemCount == 7 ? 0 : itemCount % 7 == 0 ? itemCount / 7 - 1: itemCount / 7;

            int minfrom = from <= 0 ? 0 : from - 1;
            int maxfrom = itemIndex != 7 || totalPages == 0 || totalPages == from ? from : from + 1;

            CreateGUIShopChangePage(ref container, shopKey, minfrom, maxfrom, player, toggle);

            CuiHelper.AddUi(player, container);
        }

        private void GetCategoryItems(ShopCategory category)
        {
            if (category.ShopItems != null) return;

            category.ShopItems = new HashSet<ShopItem>();
            foreach (var shortname in category.Items)
            {
                if (!_config.ShopItems.ContainsKey(shortname)) continue;

                category.ShopItems.Add(_config.ShopItems[shortname]);
            }
        }

        private string CheckAction(BasePlayer player, string shopKey, string item, string ttype)
        {
            if (!_config.ShopCategories.ContainsKey(shopKey) || !_config.ShopCategories[shopKey].EnabledCategory && !_config.ShopCategories[shopKey].EnableNPC || !string.IsNullOrEmpty(_config.ShopCategories[shopKey].Permission) && !permission.UserHasPermission(player.UserIDString, _config.ShopCategories[shopKey].PrefixPermission))
            {
                return Lang("DeniedActionInShop", player.UserIDString, ttype);
            }

            if (!_config.ShopItems.ContainsKey(item) || !_config.ShopCategories[shopKey].Items.Contains(item))
            {
                return Lang("ItemNotFound", player.UserIDString);
            }

            if (!_config.ShopCategories[shopKey].EnabledCategory && _config.ShopCategories[shopKey].EnableNPC && _config.ShopCategories[shopKey].NpcIds.Count > 0)
            {
                string vendor = String.Empty;
                foreach (string id in _config.ShopCategories[shopKey].NpcIds)
                {
                    if (NearNpc(id ,player))
                    {
                        vendor = id;
                        break;
                    }
                }
                if (string.IsNullOrEmpty(vendor))
                    return Lang("NoPerm", player.UserIDString, shopKey);
            }

            if (!_config.ShopItems[item].EnableBuy && ttype == "buy")
            {
                return Lang("ItemNotEnabled", player.UserIDString, ttype);
            }

            if (!_config.ShopItems[item].EnableSell && ttype == "Sell")
            {
                return Lang("ItemNotEnabled", player.UserIDString, ttype);
            }

            return null;
        }

        private string IsShop(BasePlayer player, string shopKey)
        {
            if (!_config.ShopCategories.ContainsKey(shopKey))
                return Lang("ErrorShop", player.UserIDString);

            return null;
        }

        #endregion

        #region Buy

        // Updated to support LangAPI + Fixes message responses to be more accurate when failing to take currencies.

        private int newamounts = 0;
        private string TryShopBuy(BasePlayer player, string shopKey, string item, int amount, bool isAll)
        {
            var slots = FreeSlots(player);
            if (isAll && _isEconomicsDebt)
            {
                ShopCategory shopCategory = _config.ShopCategories[shopKey];
                if (shopCategory != null && (shopCategory.Currency.Equals("economics") || string.IsNullOrEmpty(shopCategory.Currency) && _config.Economics))
                {
                    double balance = Economics.Call<double>("Balance", player.UserIDString);
                    int max = _balanceLimits.Key;
                    ShopItem datas = _config.ShopItems[item];
                    double price = datas.GetBuyPrice(player.UserIDString);
                    int newamount = 0;

                    if (balance.Equals(max))
                    {
                        return Lang("EconomicsMaxDebt", player.UserIDString);
                    }

                    //Puts($"{balance > max} {max < balance}");
                    while (balance > max)
                    {
                        balance -= price;
                        newamount++;
                    }

                    //Puts($"current {balance}, max {max}, new amount {newamount}, new balance{balance}");
                    amount = newamount;
                    newamounts = newamount;
                }
            }
            else if (amount <= 0)
            {
                return null;
            }

            string success = IsShop(player, shopKey);
            if (success != null)
            {
                return success;
            }

            success = CheckAction(player, shopKey, item, "buy");
            if (success != null)
            {
                return success;
            }

            success = CanBuy(player, _config.ShopCategories[shopKey], item, amount, isAll);
            if (success != null)
            {
                return success;
            }

            if (slots == 0)
            {
                //Puts("called here");
                return Lang("InventoryFull", player.UserIDString);
            }

            ShopItem data = _config.ShopItems[item];

            var purchase = data.GetBuyPrice(player.UserIDString) * amount;

            if (!TakeCurrency(_config.ShopCategories[shopKey], player, purchase))
            {
                ItemDefinition itemDef = ItemManager.FindItemDefinition(_config.ShopCategories[shopKey].CustomCurrencyIDs);
                string type = _config.ShopCategories[shopKey].Currency.Equals("custom") ? _isLangAPIReady ? GetItemDisplayName(itemDef.shortname, itemDef.displayName.english, player.UserIDString) : itemDef.displayName.english
                    : string.IsNullOrEmpty(_config.ShopCategories[shopKey].Currency) ? Currency : _config.ShopCategories[shopKey].Currency;
                return Lang("TakeCurrency", player.UserIDString, type);
            }

            success = TryGive(player, _config.ShopCategories[shopKey], item, amount, purchase);
            if (success != null)
            {
                return success;
            }

            /*if (success is bool && (bool)success == false)
            {
                AddCurrency(_config.ShopCategories[shopKey], player, purchase, "economics");
                return Lang("TryGiveFailed Contact Developer", player.UserIDString);
            }*/

            //Puts($"{shop == null} {amount * data.BuyPrice}");

            Interface.Call("OnGUIShopBuy", player.UserIDString, data.GetBuyPrice(player.UserIDString), amount, data.Shortname);

            if (data.BuyCooldown > 0)
            {
                Dictionary<string, double> itemCooldowns;

                if (!_buyCooldownData.TryGetValue(player.userID, out itemCooldowns))
                    _buyCooldownData[player.userID] = itemCooldowns = new Dictionary<string, double>();
                
                itemCooldowns[item] = CurrentTime() + data.BuyCooldown /* *amount */;
            }

            if (!string.IsNullOrEmpty(data.Shortname))
            {
                ulong count;

                _boughtData.TryGetValue(data.Shortname, out count);

                _boughtData[data.Shortname] = count + (ulong) amount;
            }
            return null;
        }

        private string CanBuy(BasePlayer player, ShopCategory shopCategory, string item, int amount, bool isAll)
        {
            if (ServerRewards == null && (_config.ServerRewards && string.IsNullOrEmpty(shopCategory?.Currency) || shopCategory?.Currency.Contains("serverrewards") == true))
            {
                return Lang("ServerRewards", player.UserIDString);
            }

            if (Economics == null && (_config.Economics && string.IsNullOrEmpty(shopCategory?.Currency) || shopCategory?.Currency.Contains("economics") == true))
            {
                return Lang("Economics", player.UserIDString);
            }

            if (!_config.ShopItems.ContainsKey(item))
            {
                return Lang("ItemNotValidbuy", player.UserIDString);
            }

            var data = _config.ShopItems[item];
            if (data.GetBuyPrice(player.UserIDString) < 0)
            {
                return Lang("BuyPriceFail", player.UserIDString);
            }

            if (!data.Command.IsNullOrEmpty() && amount > 1)
            {
                return Lang("BuyCmd", player.UserIDString);
            }

            if ((_config.CustomCurrency && string.IsNullOrEmpty(shopCategory.Currency) && ItemManager.FindItemDefinition(_config.CustomCurrencyID) == null || shopCategory.Currency.Equals("custom")) && ItemManager.FindItemDefinition(shopCategory.CustomCurrencyIDs) == null)
            {
                return Lang("CustomInvalidID", player.UserIDString, shopCategory.DisplayName);
                //$"\n CustomCurrencyIDs was null or not a correct rust item ID for {shopKey} shop, config requires updating"
            }

            double buyprice = data.GetBuyPrice(player.UserIDString);

            //Puts($"buyprice {buyprice}, getcurrency {GetCurrency(shopCategory, player)}, less than {GetCurrency(shopCategory, player) < buyprice * amount}");

            if (_isEconomicsDebt)
            {
                if (shopCategory.Currency.Equals("economics") || string.IsNullOrEmpty(shopCategory.Currency) && _config.Economics)
                {
                    double balance = Economics.Call<double>("Balance", player.UserIDString);
                    int max = _balanceLimits.Key;
                    
                    if (balance.Equals(max))
                    {
                        return Lang("EconomicsMaxDebt", player.UserIDString);
                    }

                    if (!isAll)
                    {
                        if (balance - (buyprice * amount) > -max)
                        {
                            return Lang("EconomicsExceedsDebt", player.UserIDString, max);
                        }
                    }
                }
            }

            if (GetCurrency(shopCategory, player) < buyprice * amount) // Fixed Custom Currency Issues in regards to message responses
            {
                if (shopCategory?.Currency.Contains("custom") == true)
                {
                    ItemDefinition currency = ItemManager.FindItemDefinition(shopCategory.CustomCurrencyIDs);
                    if (currency == null)
                    {
                        return Lang("CustomCurrencyFail", player.UserIDString, shopCategory.DisplayName, shopCategory.CustomCurrencyIDs);
                    }
                    
                    if (GetCurrency(shopCategory, player) == 0)
                        return Lang("NotEnoughMoneyCustom", player.UserIDString, buyprice * amount, amount, item);
                }
                else if (_config.CustomCurrency)
                {
                    return Lang("NotEnoughMoneyCustom", player.UserIDString, buyprice * amount, amount, item);
                }

                if (_isEconomicsDebt)
                {
                    if (shopCategory.Currency.Equals("economics") || string.IsNullOrEmpty(shopCategory.Currency) && _config.Economics)
                    {
                        double balance = Economics.Call<double>("Balance", player.UserIDString);
                        int max = _balanceLimits.Key;
                    
                        if (balance.Equals(max))
                        {
                            return Lang("EconomicsMaxDebt", player.UserIDString);
                        }

                        if (!isAll)
                        {
                            if (balance - (buyprice * amount) > -max)
                            {
                                return Lang("EconomicsExceedsDebt", player.UserIDString, max);
                            }
                        }
                    }
                }
                else
                    return Lang("NotEnoughMoney", player.UserIDString, buyprice * amount, amount, item);
            }

            if (data.BuyCooldown > 0)
            {
                Dictionary<string, double> itemCooldowns;
                double itemCooldown;

                if (_buyCooldownData.TryGetValue(player.userID, out itemCooldowns) && itemCooldowns.TryGetValue(item, out itemCooldown) && itemCooldown > CurrentTime())
                {
                    return Lang("Cooldown", player.UserIDString, FormatTime((long) (itemCooldown - CurrentTime())));
                }
            }

            ItemLimit itemLimit = GetPlayerLimit(player);
            if (data.BuyLimit > 0 && itemLimit.BLimit[data.Shortname] >= data.BuyLimit)
            {
               // Puts($"{data.DisplayName}, {player.displayName}, {itemLimit.CheckBuyLimit(data.Shortname, amount)}");
               if (data.BuyLimitResetCoolDown > 0)
               {
                   Dictionary<string, double> itemCooldowns;
                   double itemCooldown;
                   if (_buyLimitResetCoolDownData.TryGetValue(player.userID, out itemCooldowns) && itemCooldowns.TryGetValue(item, out itemCooldown) && itemCooldown > CurrentTime())
                   {
                       return Lang( $"Buy Limit of {data.BuyLimit} was Reached for {data.DisplayName} \n This limit resets in {FormatTime((long) (itemCooldown - CurrentTime()))} seconds", player.UserIDString);
                   }
               }
               else
                return Lang($"Buy Limit of {data.BuyLimit} Reached for {data.DisplayName}", player.UserIDString);
            }

            return null;
        }

        private int GetAmountBuy(BasePlayer player, ShopCategory shopCategory, string item)
        {
            ShopItem data = _config.ShopItems[item];
            ItemDefinition definition = ItemManager.FindItemDefinition(data.Shortname);
            if (definition == null) return 0;
            var freeSlots = FreeSlots(player);

            double amountcanbuy = GetCurrency(shopCategory, player) / data.GetBuyPrice(player.UserIDString);

            if (amountcanbuy >= freeSlots)
            {
                return freeSlots * definition.stackable;
            }
            return (int)amountcanbuy * definition.stackable;
        }

        private string TryGive(BasePlayer player, ShopCategory shopCategory, string item, int amount, double purchase)
        {
            ShopItem data = _config.ShopItems[item];
            //var slots = FreeSlots(player);
            //Puts($"{data.RunCommandAndCustomShopItem == false} / { (!(data.Command?.Any() ?? false))}");

            bool passed = false;

            if (data.RunCommandAndCustomShopItem && !data.Command.IsNullOrEmpty())
            {
                /*if (slots == 0)
                {
                    return Lang("InventoryFull", player.UserIDString);
                }*/

                List<Embed> embeds = new List<Embed>();

                Vector3 pos = GetLookPoint(player);

                Embed embed = BuildMessage(player);

                embed.AddTitle("Command & Item Bought 1 of 2");

                foreach (var command in data.Command)
                {
                    var c = command
                            .Replace("$player.id", player.UserIDString)
                            .Replace("$player.name", player.displayName)
                            .Replace("$player.x", pos.x.ToString())
                            .Replace("$player.y", pos.y.ToString())
                            .Replace("$player.z", pos.z.ToString());
                        
                        if (c.StartsWith("shop.show close", StringComparison.OrdinalIgnoreCase))
                            NextTick(() => ConsoleSystem.Run(ConsoleSystem.Option.Server, c));
                        else
                            ConsoleSystem.Run(ConsoleSystem.Option.Server, c);
                }

                var d = string.Join("\n", data.Command);
                embed.AddField("Command Name", d);
                embed.AddField("Cost", $"{amount * data.GetBuyPrice(player.UserIDString)}", true)
                    .AddField("Remaining Balance", $"{GetCurrency(shopCategory, player) - amount * data.GetBuyPrice(player.UserIDString)}", true);
                embeds.Add(embed);

                Embed embed2 = BuildMessage(player);

                if (!string.IsNullOrEmpty(data.Shortname))
                {
                    //bool space = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity - player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count < 1 && targetItem.stackable <= Amount;
                    if (player.inventory.containerMain.IsFull() && player.inventory.containerBelt.IsFull())
                    {
                        //Puts($"called here");
                        return Lang("InventoryFull", player.UserIDString);
                    }

                    string success = GiveItem(player, data, amount, shopCategory);

                    if (success != null)
                    {
                        return success;
                    }
                }

                embed2.AddTitle("Item Given 2 of 2").AddField("Item Name", data.Shortname).AddField("amount", $"{amount}", true);
                    //.AddField("Cost", $"{amount * data.BuyPrice}", true)
                    //.AddField("Balance", $"{GetCurrency(shopCategory, player) - amount * data.BuyPrice}", true);

                    embeds.Add(embed2);
                    SendToDiscord(embeds);

                    passed = true;
            }

            if (!data.RunCommandAndCustomShopItem && !data.Command.IsNullOrEmpty()) //updated/patched sorta 5/13/2021
            {
                /*if (slots == 0)
                {
                    return Lang("InventoryFull", player.UserIDString);
                }*/

                Vector3 pos = GetLookPoint(player);

                Embed embed = BuildMessage(player);

                embed.AddTitle("Command Bought");
                
                foreach (var command in data.Command)
                {
                    //embed.AddTitle("Command Bought");
                    var c = command
                        .Replace("$player.id", player.UserIDString)
                        .Replace("$player.name", player.displayName)
                        .Replace("$player.x", pos.x.ToString())
                        .Replace("$player.y", pos.y.ToString())
                        .Replace("$player.z", pos.z.ToString());

                    if (c.StartsWith("shop.show close", StringComparison.OrdinalIgnoreCase))
                        NextTick(() => ConsoleSystem.Run(ConsoleSystem.Option.Server, c));
                    else
                        ConsoleSystem.Run(ConsoleSystem.Option.Server, c);
                }

                var d = string.Join("\n", data.Command);
                embed.AddField("Command Name", d);
                embed.AddField("Cost", $"{amount * data.GetBuyPrice(player.UserIDString)}", true)
                    .AddField("Remaining Balance", $"{GetCurrency(shopCategory, player) - amount * data.GetBuyPrice(player.UserIDString)}", true);
                SendToDiscord(new List<Embed>{embed});

                passed = true;
            }

            if (!string.IsNullOrEmpty(data.KitName))
            {
                object isKit = Kits?.Call<bool>("isKit", data.KitName);

                Embed embed = BuildMessage(player);

                if (!(isKit is bool) || !(bool) isKit)
                {

                    embed.AddTitle("Kit Purchase Failed").AddField("Kit Name", data.KitName)
                        .AddDescription($"WARNING: This is not a valid kit name assigned to this shop item: {data.Shortname}");
                    SendToDiscord(new List<Embed> {embed});
                    return Lang("NotKit", player.UserIDString, data.DisplayName);
                }

                object successkit = Kits.Call<object>("GiveKit", player, data.KitName);

                if (!(successkit is bool && (bool) successkit || successkit == null))
                {
                    embed.AddTitle("Kit Purchase Failed").AddField("Kit Name", data.KitName)
                        .AddDescription($"WARNING: There was an error while giving this player this kit {data.Shortname}");
                    SendToDiscord(new List<Embed> {embed});
                    return Lang("RedeemKitFail", player.UserIDString);
                }

                embed.AddTitle("Kit Bought").AddField("Kit Name", data.KitName)
                    .AddField("Cost", $"{amount * data.GetBuyPrice(player.UserIDString)}", true)
                    .AddField("Balance", $"{GetCurrency(shopCategory, player) - amount * data.GetBuyPrice(player.UserIDString)}", true);
                SendToDiscord(new List<Embed> {embed});

                passed = true;
            }

            if (!string.IsNullOrEmpty(data.Shortname) && data.Command.IsNullOrEmpty())
            {
                Embed embed = BuildMessage(player);
                /*if (slots == 0)
                {
                    return Lang("InventoryFull", player.UserIDString);
                }*/
                
                string success = GiveItem(player, data, amount, shopCategory);

                if (success != null)
                {
                    return success;
                }

                embed.AddTitle("Item Bought").AddField("Item Name", data.Shortname).AddField("amount", $"{amount}", true)
                    .AddField("Cost", $"{amount * data.GetBuyPrice(player.UserIDString)}", true)
                    .AddField("Balance", $"{GetCurrency(shopCategory, player) - amount * data.GetBuyPrice(player.UserIDString)}", true);
                SendToDiscord(new List<Embed> {embed});

                passed = true;
            }

            if (!passed)
            {
                AddCurrency(_config.ShopCategories[shopCategory.DisplayName], player, purchase, "economics");
                return Lang("TryGiveFailed Contact Developer", player.UserIDString);
            }

            return null;
        }

        private string GiveItem(BasePlayer player, ShopItem data, int amount, ShopCategory shopCategory)
        {
            if (amount <= 0)
            {
                return Lang("NotNothingShopFail", player.UserIDString);
            }

            ItemDefinition definition = ItemManager.FindItemDefinition(data.Shortname);
            if (definition == null)
            {
                return Lang("ItemNoExist", player.UserIDString);
            }

            var stack = GetStacks(definition, amount);
            var stacks = stack.Count;

            if (!data.MakeBlueprint && data.Condition != 0 && definition.condition.enabled && data.Condition < definition.condition.max)
            {
                //Puts("true");
                stacks = amount;
            }

            var slots = FreeSlots(player);
            if (slots < stacks)
            {
                AddCurrency(shopCategory, player, (data.GetSellPrice(player.UserIDString) * amount), "economics");
                return Lang("InventorySlots", player.UserIDString, stacks);
            }

            string name = string.Empty;
            if (data.CraftAsDisplayName)
            {
                name = data.DisplayName;
            }

            var results = Enumerable.Repeat(definition.stackable, amount / definition.stackable)
                .Concat(Enumerable.Repeat(amount % definition.stackable, 1))
                .Where(x => x > 0);

            foreach (var value in results)
            {
                var item = CreateByName(data.MakeBlueprint ? "blueprintbase" : data.Shortname, value, name, data.Condition, data.SkinId);
                if (data.GeneTypes.Count == 6 && item.GetHeldEntity() is Planner)
                {
                    for (int slot = 0; slot < 6; slot++)
                    {
                        Genes.Genes[slot].Set(CharToGeneType(data.GeneTypes[slot]), true);
                    }
                    EncodeGenesToItem(Genes, item);
                }

                item.MarkDirty();

                if (data.MakeBlueprint)
                {
                    if (ItemManager.FindBlueprint(definition) == null) return Lang("ItemIsNotBlueprintable", player.UserIDString, data.DisplayName);

                    if (item.instanceData == null)
                    {
                        item.instanceData = new ProtoBuf.Item.InstanceData();
                    }

                    item.instanceData.ShouldPool = false;
                    item.instanceData.blueprintAmount = 1;
                    item.instanceData.blueprintTarget = definition.itemid;
                    item.MarkDirty();
                }

                if (!GiveItem(player, item))
                {
                    item.Remove();
                    item.DoRemove();
                    AddCurrency(shopCategory, player, (data.GetSellPrice(player.UserIDString) * value), "economics");
                }
            }

            return null;
        }

        #region Creation_Checks

        public GrowableGenes Genes = new GrowableGenes();
        
        GrowableGenetics.GeneType CharToGeneType(char h)
        {
            switch (h)
            {
                case 'g': return GrowableGenetics.GeneType.GrowthSpeed;
                case 'y': return GrowableGenetics.GeneType.Yield;
                case 'h': return GrowableGenetics.GeneType.Hardiness;
                case 'x': return GrowableGenetics.GeneType.Empty;
                case 'w': return GrowableGenetics.GeneType.WaterRequirement;
                default: return GrowableGenetics.GeneType.Empty;
            }
        }

        public void EncodeGenesToItem(GrowableGenes sourceGrowable, Item targetItem)
        {
            GrowableGeneEncoding.EncodeGenesToItem(GrowableGeneEncoding.EncodeGenesToInt(sourceGrowable), targetItem);
        }

        private static Item CreateByName(string strName, int iAmount, string name, float con, ulong skin = 0)
        {
            ItemDefinition itemDefinition = ItemManager.itemList.Find(x => x.shortname == strName);
            return itemDefinition == null ? (Item) null : CreateByItemID(itemDefinition.itemid, iAmount, name, con, skin);
        }

        private static Item CreateByItemID(int itemID, int iAmount, string name, float con, ulong skin = 0)
        {
            ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemID);
            return itemDefinition == null ? (Item) null : Create(itemDefinition, iAmount, name, con, skin);
        }

        private static Item Create(ItemDefinition template, int iAmount, string name, float con, ulong skin = 0)
        {
            TrySkinChangeItem(ref template, ref skin);
            if (template == null)
            {
                Debug.LogWarning( "Creating invalid/missing item!");
                return null;
            }
            Item obj = new Item();
            obj.isServer = true;
            if (iAmount <= 0)
            {
                Debug.LogError( "Creating item with less than 1 amount! (" + template.displayName.english + ")");
                return null;
            }
            obj.info = template;
            obj.amount = iAmount;
            obj.skin = skin;
            if (!name.IsNullOrEmpty())
            {
                obj.name = name;
            }
            obj.uid = new ItemId(Network.Net.sv.TakeUID());
            if (obj.hasCondition)
            {
                obj.maxCondition = obj.info.condition.max;
                obj.condition = con;
            }
            obj.OnItemCreated();
            return obj;
        }

        private static void TrySkinChangeItem(ref ItemDefinition template, ref ulong skinId)
        {
            if (skinId == 0UL) return;
            ItemSkinDirectory.Skin inventoryDefinitionId = ItemSkinDirectory.FindByInventoryDefinitionId((int) skinId);
            if (inventoryDefinitionId.id == 0) return;
            ItemSkin invItem = inventoryDefinitionId.invItem as ItemSkin;
            if (invItem == null || invItem.Redirect == null) return;
            template = invItem.Redirect;
            skinId = 0UL;
        }

        #endregion

        #region Give_Checks

        private static bool GiveItem(BasePlayer player, Item item, ItemContainer container = null)
        {
            if (item == null)
                return false;
            int position = -1;
            GetIdealPickupContainer(player, item, ref container, ref position);
            return container != null && item.MoveToContainer(container, position) ||
                   item.MoveToContainer(player.inventory.containerMain) ||
                   item.MoveToContainer(player.inventory.containerBelt) ||
                   item.DropAndTossUpwards(player.inventory.containerMain.dropPosition);
        }

        protected static void GetIdealPickupContainer(BasePlayer player, Item item, ref ItemContainer container, ref int position)
        {
            if (item.info.stackable > 1)
            {
                if (player.inventory.containerBelt != null && player.inventory.containerBelt.FindItemByItemID(item.info.itemid) != null)
                {
                    container = player.inventory.containerBelt;
                    return;
                }
                if (player.inventory.containerMain != null && player.inventory.containerMain.FindItemByItemID(item.info.itemid) != null)
                {
                    container = player.inventory.containerMain;
                    return;
                }
            }
            if (!item.info.isUsable || item.info.HasFlag(ItemDefinition.Flag.NotStraightToBelt)) return;
            container = player.inventory.containerBelt;
        }
        
        private int FreeSlots(BasePlayer player)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            var taken = player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count;
            return slots - taken;
        }

        private List<int> GetStacks(ItemDefinition items, int amount)
        {
            var list = new List<int>();
            var maxStack = items.stackable;

            while (amount > maxStack)
            {
                amount -= maxStack;
                list.Add(maxStack);
            }

            list.Add(amount);

            return list;
        }

        #endregion

        #endregion

        #region Sell

        private string TryShopSell(BasePlayer player, string shopKey, string item, int amount)
        {
            string success = IsShop(player, shopKey);
            if (success != null)
            {
                return success;
            }

            success = CheckAction(player, shopKey, item, "Sell");
            if (success != null)
            {
                return success;
            }

            success = CanSell(player, item, amount);
            if (success != null)
            {
                return success;
            }

            // Puts($"tryshopsell amount is {amount}");
            success = TrySell(player, shopKey, item, amount);
            if (success != null)
            {
                return success;
            }

            ShopItem data = _config.ShopItems[item];
            double cooldown = Convert.ToDouble(data.SellCooldown);

            if (cooldown > 0)
            {
                Dictionary<string, double> itemCooldowns;

                if (!_sellCoolDownData.TryGetValue(player.userID, out itemCooldowns))
                {
                    _sellCoolDownData[player.userID] = itemCooldowns = new Dictionary<string, double>();
                }

                itemCooldowns[item] = CurrentTime() + cooldown;
            }

            AddCurrency(_config.ShopCategories[shopKey], player, (data.GetSellPrice(player.UserIDString) * amount), item);

            Interface.Call("OnGUIShopSell", player.UserIDString, data.GetSellPrice(player.UserIDString), amount, data.Shortname);

            if (!string.IsNullOrEmpty(data.Shortname))
            {
                ulong count;

                _soldData.TryGetValue(data.Shortname, out count);

                _soldData[data.Shortname] = count + (ulong)amount;
            }

            return null;
        }

        private string TrySell(BasePlayer player, string shopKey, string item, int amount)
        {
            Embed embed = BuildMessage(player);
            ShopItem data = _config.ShopItems[item];

            if (_isEconomicsLimits)
            {
                if (_config.Economics && string.IsNullOrEmpty(_config.ShopCategories[shopKey]?.Currency) || _config.ShopCategories[shopKey]?.Currency.Contains("economics") == true)
                {
                    double balance = Economics.Call<double>("Balance", player.UserIDString);
                    int max = _balanceLimits.Value;

                    if (balance.Equals(max))
                    {
                        return Lang("MaxEconomicsBalance", player.UserIDString);
                    }

                    if (balance + (data.GetSellPrice(player.UserIDString) * amount) > max)
                    {
                        return Lang("EconomicsExceedsLimit", player.UserIDString, max);
                    }
                }
            }

            if (string.IsNullOrEmpty(data.Shortname))
            {
                return Lang("ShopItemItemInvalid", player.UserIDString);
            }

            if (!data.Command.IsNullOrEmpty())
            {
                return Lang("CantSellCommands", player.UserIDString);
            }

            object iskit = Kits?.CallHook("isKit", data.Shortname);

            if (iskit is bool && (bool) iskit)
            {
                return Lang("CantSellKits", player.UserIDString);
            }

            // Puts($"trysell amount is {amount}");
            string success = TakeItem(player, _config.ShopItems[item], _config.ShopCategories[shopKey], amount);
            if (success != null)
            {
                return success;
            }

            if (_config.EnableDiscordSellLogging)
            {
                embed.AddTitle("Item Sold").AddField("Item Name", data.Shortname).AddField("amount", $"{amount}", true)
                    .AddField("Receive", $"{amount * data.GetSellPrice(player.UserIDString)}", true)
                    .AddField("Balance", $"{GetCurrency(_config.ShopCategories[shopKey], player) + amount * data.GetSellPrice(player.UserIDString)}", true);
                SendToDiscord(new List<Embed>{embed});
            }

            return null;
        }

        private int GetAmountSell(BasePlayer player, string item)
        {
            ShopItem data = _config.ShopItems[item];
            ItemDefinition definition = ItemManager.FindItemDefinition(data.Shortname);

            if (definition == null)
            {
                return 0;
            }
            
            string name = String.Empty;
            if (data.CraftAsDisplayName)
            {
                name = data.DisplayName;
            }

            return GetAmount(player.inventory, _config.AllowedSellContainers, definition.itemid, name, data.AllowSellOfUsedItems, data.SkinId);
        }

        private string TakeItem(BasePlayer player, ShopItem data, ShopCategory shopCategory, int amount)
        {
            if (amount <= 0)
            {
                return Lang("NotEnoughSell", player.UserIDString);
            }

            ItemDefinition definition = ItemManager.FindItemDefinition(data.Shortname);

            if (definition == null)
            {
                return Lang("ItemNoExistTake", player.UserIDString);
            }

            string name = String.Empty;
            if (data.CraftAsDisplayName)
            {
                //Puts($"{data.DisplayName}");
                name = data.DisplayName;
            }
            int pamount = GetAmount(player.inventory, _config.AllowedSellContainers, definition.itemid, name, data.AllowSellOfUsedItems, data.SkinId);

            if (pamount < amount)
            {
                //Puts($"TakeItem pamount < amount true ? {pamount}, {amount}");
                return Lang("NotEnoughSell", player.UserIDString);
            }

            if (shopCategory?.Currency.Contains("custom") == true)
            {
                Item currency = ItemManager.CreateByItemID(shopCategory.CustomCurrencyIDs, amount, shopCategory.CustomCurrencySkinIDs);
                if (currency == null)
                {
                    return Lang("CustomCurrencyFail", player.UserIDString, shopCategory.DisplayName, shopCategory.CustomCurrencyIDs);
                }
                currency.Remove();
                currency.DoRemove();
            }

            //Puts($"{data.CraftAsDisplayName} {data.DisplayName.IsNullOrEmpty()} hmm?");
            if (data.CraftAsDisplayName && !string.IsNullOrEmpty(data.DisplayName))
            {
                Take(player.inventory, _config.AllowedSellContainers, null, definition.itemid, amount, data.AllowSellOfUsedItems, data.DisplayName, data.SkinId);
                return null;
            }

            Take(player.inventory, _config.AllowedSellContainers, null, definition.itemid, amount, data.AllowSellOfUsedItems, null, data.SkinId);
            return null;
        }

        private string CanSell(BasePlayer player, string item, int amount)
        {
            if (!_config.ShopItems.ContainsKey(item))
            {
                return Lang("ItemNotValidsell", player.UserIDString);
            }

            ShopItem itemdata = _config.ShopItems[item];

            if (itemdata.Command.IsNullOrEmpty() && player.inventory.containerMain.FindItemByItemName(itemdata.Shortname) == null && player.inventory.containerBelt.FindItemByItemName(itemdata.Shortname) == null) //fixed..
            {
                //Puts($"Is inside CanSell dunno why.. {itemdata.Shortname}, {amount}"); //Fixed
                return Lang("NotEnoughSell", player.UserIDString);
            }

            if (itemdata.GetSellPrice(player.UserIDString) < 0)
            {
                return Lang("SellPriceFail", player.UserIDString);
            }

            if (itemdata.SellCooldown > 0)
            {
                Dictionary<string, double> itemCooldowns;

                double itemCooldown;

                if (_sellCoolDownData.TryGetValue(player.userID, out itemCooldowns) && itemCooldowns.TryGetValue(item, out itemCooldown) && itemCooldown > CurrentTime())
                {
                    return Lang("Cooldown", player.UserIDString, FormatTime((long) (itemCooldown - CurrentTime())));
                }
            }

            ItemLimit itemLimit = GetPlayerLimit(player);
            if (itemdata.SellLimit > 0 && itemLimit.SLimit[itemdata.Shortname] >= itemdata.SellLimit)
            {
                //Puts($"{itemdata.DisplayName}, {player.displayName}, {itemLimit.CheckSellLimit(itemdata.Shortname, amount)}");
                if (itemdata.SellLimitResetCoolDown > 0)
                {
                    Dictionary<string, double> itemCooldowns;
                    double itemCooldown;
                    if (_sellLimitResetCoolDownData.TryGetValue(player.userID, out itemCooldowns) && itemCooldowns.TryGetValue(item, out itemCooldown) && itemCooldown > CurrentTime())
                    {
                        return Lang( $"Sell Limit of {itemdata.SellLimit} was Reached for {itemdata.DisplayName} \n This limit resets in {FormatTime((long) (itemCooldown - CurrentTime()))}", player.UserIDString);
                    }
                }
                else
                    return Lang($"Sell Limit of {itemdata.SellLimit} Reached for {itemdata.DisplayName}", player.UserIDString);
            }

            return null;
        }

        #endregion

        #region Chat

        public string StripTags(string input) => Regex.Replace(input, "<.*?>", String.Empty);
        private void CmdGUIShop(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, Use))
            {
                SendReply(player, Lang("NoPermUse", player.UserIDString, Use));
                return;
            }

            if (_imageLibraryCheck >= _config.ImageLibraryCounter)
            {
                SendReply(player, Lang("ImageLibraryFailure", player.UserIDString, _config.ImageLibraryCounter));
                return;
            }

            if (!_isShopReady || LangAPI != null && !_isLangAPIReady)
            {
                SendReply(player, Lang("GUIShopResponse", player.UserIDString));
                return;
            }

            if (_wipeReady == false)
            {
                float timeresult = _config.Time.CanShopIn / 60;
                SendReply(player, Lang("WipeReady", player.UserIDString, player.displayName, Math.Round(timeresult)));
                return;
            }

            if (!_config.ShopCategories.ContainsKey(_config.DefaultShop) && !string.IsNullOrWhiteSpace(_config.DefaultShop))
            {
                StringBuilder sb = new StringBuilder();
                foreach (var name in _config.ShopCategories)
                {
                    if (name.Key == name.Value.DisplayName)
                        sb.Append($"<color=#32CD32>{name.Key}</color>\n");
                }
                PrintError($"This is not a shop {_config.DefaultShop} update default shop setting!\nAvailable Shops are:\n{StripTags(sb.ToString())}");
                player.ChatMessage(Lang("ShopInvalid", player.UserIDString, _config.DefaultShop, sb));
               return;
            }

            ShopCategory shop = null;
            _config.ShopCategories.TryGetValue(_config.DefaultShop, out shop);

            string shopKey = shop?.DisplayName;
            ShopCategory category;
            bool isNpc = false;
            if (GetNearestVendor(player, out category))
            {
                isNpc = true;
                shopKey = category.DisplayName;
            }
            if (category == null && String.IsNullOrEmpty(_config.DefaultShop))
            {
                SendReply(player, Lang("GlobalShopsDisabled", player.UserIDString));
                return;
            }

            if (category == null && shop.EnabledCategory == false || !string.IsNullOrEmpty(shop.Permission) && !permission.UserHasPermission(player.UserIDString, shop.PrefixPermission))
            {
                shopKey = _config.ShopCategories.Select(x => x.Value).FirstOrDefault(i => i.EnabledCategory && (string.IsNullOrEmpty(i.Permission) || !string.IsNullOrEmpty(i.Permission) && permission.UserHasPermission(player.UserIDString, i.PrefixPermission)))?.DisplayName;
            }

            if (shopKey != null && !string.IsNullOrEmpty(_config.ShopCategories[shopKey].Permission) && !permission.UserHasPermission(player.UserIDString, _config.ShopCategories[shopKey].PrefixPermission))
            {
                SendReply(player, Lang("NoPerm", player.UserIDString, shopKey));
                return;
            }

            if (category == null && (string.IsNullOrEmpty(shopKey) || !_config.ShopCategories[shopKey].EnabledCategory))
            {
                SendReply(player, Lang("GlobalShopsDisabled", player.UserIDString));
                return;
            }

            if (!player.CanBuild() && !isNpc)
            {
                if (permission.UserHasPermission(player.UserIDString, BlockAllow)) //Overrides being blocked.
                    ShowGUIShops(player, shopKey);
                else
                    SendReply(player, Lang("BuildingBlocked", player.UserIDString));

                return;
            }

            GetPlayerData(player).ShopKey = shopKey;

            _imageChanger = _config.UIImageOption;
            playerGUIShopUIOpen.Add(player.UserIDString);
            ShowGUIShops(player, shopKey);
        }

        [ChatCommand("cleardata")]
        private void CmdGUIShopClearData(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, Admin))
            {
                _playerUIData.Clear();
                Puts($"{player.userID} has cleared the data in the GUI Shop file");
            }
        }

        [ChatCommand("shopgui")]
        private void CmdGUIShopToggleBackpackGUI(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, Button))
                return;

            if (!_playerDisabledButtonData.Remove(player.UserIDString))
            {
                _playerDisabledButtonData.Add(player.UserIDString);
            }
            CreateGUIShopButton(player);

            SendReply(player, "{0} GUIShop Button", _playerDisabledButtonData.Contains(player.UserIDString) ? "Disabled" : "Enabled", this, player.UserIDString);
            SaveData();
        }

        [ChatCommand("update")]
        private void CmdGUIShopUpdate(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, Admin))
            {
                return;
            }
            
            if (_imageLibraryCheck >= _config.ImageLibraryCounter)
            {
                SendReply(player, Lang("ImageLibraryFailure", player.UserIDString, _config.ImageLibraryCounter));
                return;
            }

            if (!_isShopReady || LangAPI != null && !_isLangAPIReady)
            {
                SendReply(player, Lang("GUIShopResponse", player.UserIDString));
                return;
            }

            foreach (var item in _config.ShopItems.Values)
            {
                if (item.Condition == 0 && item.Shortname != null)
                {
                    ItemDefinition update = ItemManager.FindItemDefinition(item.Shortname);
                    if (update != null && update.condition.enabled) 
                        item.Condition = update.condition.max;
                }
            }

            SaveConfig();
            SendReply(player, $"{player.displayName} has manually updated the GUIShop config.");
            Server.Command("o.reload GUIShop");
            Puts($"Command update was manually ran by {player.UserIDString}, {player.displayName}");
        }

        [ChatCommand("updateold")]
        private void Update(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, Admin))
            {
                return;
            }

            foreach (var item in _config.ShopItems.Values)
            {
                if (!item.Image.IsNullOrEmpty() && item.Image.Equals("https://rustlabs.com/img/items180/" + item.Shortname + ".png"))
                {
                    item.Image = String.Empty;
                }
            }

            SaveConfig();
            SendReply(player, $"{player.displayName} has manually updated the GUIShop config.");
            Server.Command("o.reload GUIShop");
            Puts($"Command update was manually ran by {player.UserIDString}");
        }

        [ChatCommand("resetconditions")]
        private void CmdGUIShopResetConditions(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, Admin))
            {
                return;
            }
            
            if (_imageLibraryCheck >= _config.ImageLibraryCounter)
            {
                SendReply(player, Lang("ImageLibraryFailure", player.UserIDString, _config.ImageLibraryCounter));
                return;
            }
            
            if (!_isShopReady || LangAPI != null && !_isLangAPIReady)
            {
                SendReply(player, Lang("GUIShopResponse", player.UserIDString));
                return;
            }

            foreach (var item in _config.ShopItems.Values)
            {
                ItemDefinition update = ItemManager.FindItemDefinition(item.Shortname);
                if (update != null && update.condition.enabled) 
                    item.Condition = update.condition.max;
            }

            SaveConfig();
            SendReply(player, $"{player.displayName} has manually reset item conditions for the GUIShop config.");
            Server.Command("o.reload GUIShop");
            Puts($"Command resetconditions was manually ran by {player.UserIDString}, {player.displayName}");
        }

        #endregion

        #region Console

        [ConsoleCommand("limits.clear")]
        private void ConsoleGUIShopClearLimit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null || !permission.UserHasPermission(player.UserIDString, Admin)) return;
            _limitsData.Clear();
            _buyLimitResetCoolDownData.Clear();
            _sellLimitResetCoolDownData.Clear();
        }

        [ConsoleCommand("transactions.clear")]
        private void ConsoleGUIShopClearTransactions(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null || !permission.UserHasPermission(player.UserIDString, Admin)) return;
            _buyCooldownData.Clear();
            _sellCoolDownData.Clear();
        }

        [ConsoleCommand("shop.button")]
        private void ConsoleGUIShopButton(ConsoleSystem.Arg arg)
        {
            BasePlayer user = arg.Player();
            /*if (_wipeReady == false)
            {
                float timeresult = _config.Time.CanShopIn / 60;
                SendReply(user, Lang("WipeReady", user.UserIDString, user.displayName, Math.Round(timeresult)));
                return;
            }*/
            CmdGUIShop(user, null, null);
        }

        [ConsoleCommand("shop.show")] //updated to fix spacing issues in name again.
        private void ConsoleGUIShopShow(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs(2))
            {
                return;
            }

            BasePlayer player = arg.Player();

            string shopid = arg.GetString(0).Replace("_", " ");

            if (shopid.Equals("close", StringComparison.OrdinalIgnoreCase))
            {
                BasePlayer targetPlayer = arg.GetPlayerOrSleeper(1);

                DestroyUi(targetPlayer, true);

                GetPlayerData(targetPlayer).ShopKey = String.Empty;

                _shopPage.Remove(targetPlayer.userID);
            }
            else
            {
                if (player == null || !permission.UserHasPermission(player.UserIDString, Use))
                {
                    return;
                }

                GetPlayerData(player).ShopKey = shopid;

                ShowGUIShops(player, shopid, arg.GetInt(1), false, true);   
            }
        }

        [ConsoleCommand("shop.buy")]
        private void ConsoleGUIShopBuy(ConsoleSystem.Arg arg, ShopCategory shopCategory)
        {
            BasePlayer user = arg.Player();
            if (_wipeReady == false && user != null)
            {
                float timeresult = _config.Time.CanShopIn / 60;
                SendReply(user, Lang("WipeReady", user.UserIDString, user.displayName, Math.Round(timeresult)));
                return;
            }
            /*if (!user.CanBuild() && )
            {
                if (!permission.UserHasPermission(user.UserIDString, BlockAllow)) //Override.
                {
                    SendReply(user, Lang("BuildingBlocked", user.UserIDString));
                    return;
                }
            }*/

            if (!arg.HasArgs(3))
            {
                return;
            }

            BasePlayer player = arg.Player();

            if (player == null || !permission.UserHasPermission(player.UserIDString, Use))
            {
                return;
            }

            object UmodNoEscape = Interface.Oxide.CallHook("canShop", player);

            // TODO: re-code
            if (UmodNoEscape != null)
            {
                string message = "You are not allowed to shop at the moment";
                if (UmodNoEscape is string)
                {
                    message = (string) UmodNoEscape;
                }

                SendReply(player, message);
                return;
            }

            string shopName = arg.GetString(0).Replace("_", " ");
            string item = arg.GetString(1).Replace("_", " ");
            bool isAll = arg.GetString(2).Equals("all") && !string.IsNullOrEmpty(GetPlayerData(player).ShopKey);
            int amount = arg.GetString(2).Equals("all") ? !string.IsNullOrEmpty(GetPlayerData(player).ShopKey) ? GetAmountBuy(player, _config.ShopCategories[shopName], item) : 0 : arg.GetInt(2);
            if (amount == 0)
            {
                if (!string.IsNullOrEmpty(GetPlayerData(player).ShopKey))
                    SendReply(player, Lang("InventoryFull", player.UserIDString));
                else
                    SendReply(player, Lang("BuyCmd", player.UserIDString));
                return;
            }
            //int amount = arg.Args[2].Equals("all") ? GetAmountBuy(player, item) : Convert.ToInt32(arg.Args[2]);

            ShopItem shopitem = _config.ShopItems.Values.FirstOrDefault(x => x.DisplayName == item);
            if (shopitem == null) return;

            ItemLimit itemLimit = GetPlayerLimit(player);
            itemLimit.CheckBuyLimit(shopitem.Shortname, shopitem.BuyLimit);

            double limitcooldown = Convert.ToDouble(shopitem.BuyLimitResetCoolDown);
            if (shopitem.BuyLimitResetCoolDown > 0 && itemLimit.BLimit[shopitem.Shortname] >= shopitem.BuyLimit)
            {
                Dictionary<string, double> itemCooldowns;
                if (!_buyLimitResetCoolDownData.TryGetValue(player.userID, out itemCooldowns))
                    _buyLimitResetCoolDownData[player.userID] = itemCooldowns = new Dictionary<string, double>();
                itemCooldowns[shopitem.DisplayName] = CurrentTime() + limitcooldown;
                itemLimit.BLimit[shopitem.Shortname] = 0;
            }

            string success = TryShopBuy(player, shopName, item, amount, isAll);

            //Puts($"inside buy command {TryShopBuy(player, shopName, item, amount)}");

            //Puts($"{success}");
            /*
            if (success is bool && (bool)success == false)
            {
                SendReply(player, Lang("InventoryFull", player.UserIDString));
                return;
            }
            */

            if (success != null)
            {
                SendReply(player, (string) success);
                return;
            }

            if (isAll && newamounts != 0)
            {
                amount = newamounts;
            }

            if (shopitem.BuyLimit > 0)
            {
                itemLimit.IncrementBuy(shopitem.Shortname, amount, shopitem.SwapLimitToQuantityBuyLimit);
            }

            SendReply(player, Lang("Bought", player.UserIDString), amount, GetItemDisplayName(shopitem.Shortname, shopitem.DisplayName, player.UserIDString));

            if (!string.IsNullOrEmpty(GetPlayerData(player).ShopKey))
                ShowGUIShops(player, shopName, _shopPage[player.userID], false, true);

            newamounts = 0;
        }

        private string GetItemDisplayName(string shorname, string displayName, string userID)
        {
            if (LangAPI != null && LangAPI.Call<bool>("IsDefaultDisplayName", displayName))
            {
                return LangAPI.Call<string>("GetItemDisplayName", shorname, displayName, userID) ?? displayName;
            }
            return displayName;
        }

        [ConsoleCommand("shop.sell")]
        private void ConsoleGUIShopSell(ConsoleSystem.Arg arg)
        {
            BasePlayer user = arg.Player();
            if (_wipeReady == false && user != null)
            {
                float timeresult = _config.Time.CanShopIn / 60;
                SendReply(user, Lang("WipeReady", user.UserIDString, user.displayName, Math.Round(timeresult)));
                return;
            }
            /*if (!user.CanBuild())
            {
                if (!permission.UserHasPermission(user.UserIDString, BlockAllow)) //Override.
                {
                    SendReply(user, Lang("BuildingBlocked", user.UserIDString));
                    return;
                }
            }*/

            if (!arg.HasArgs(3))
            {
                return;
            }

            BasePlayer player = arg.Player();

            if (player == null || !permission.UserHasPermission(player.UserIDString, Use))
            {
                return;
            }

            object UmodNoEscape = Interface.Oxide.CallHook("canShop", player);

            if (UmodNoEscape != null)
            {
                string message = "You are not allowed to shop at the moment";
                if (UmodNoEscape is string)
                {
                    message = (string) UmodNoEscape;
                }

                SendReply(player, message);
                return;
            }

            string shopName = arg.GetString(0).Replace("_", " ");
            string item = arg.GetString(1).Replace("_", " ");
            int amount = arg.GetString(2).Equals("all") ? !string.IsNullOrEmpty(GetPlayerData(player).ShopKey) ? GetAmountSell(player, item) : -1 : arg.GetInt(2);

            if (amount == -1)
            {
                SendReply(player, Lang("SellCmd", player.UserIDString));
                return;
            }

            ShopItem shopitem = _config.ShopItems.Values.FirstOrDefault(x => x.DisplayName == item);
            if (shopitem == null) return;

            ItemLimit itemLimit = GetPlayerLimit(player);
            itemLimit.CheckSellLimit(shopitem.Shortname, shopitem.SellLimit);
            double limitcooldown2 = Convert.ToDouble(shopitem.SellLimitResetCoolDown);
            if (shopitem.SellLimitResetCoolDown > 0 && itemLimit.SLimit[shopitem.Shortname] >= shopitem.SellLimit)
            {
                Dictionary<string, double> itemCooldowns2;
                if (!_sellLimitResetCoolDownData.TryGetValue(player.userID, out itemCooldowns2))
                    _sellLimitResetCoolDownData[player.userID] = itemCooldowns2 = new Dictionary<string, double>();
                itemCooldowns2[shopitem.DisplayName] = CurrentTime() + limitcooldown2;
                itemLimit.SLimit[shopitem.Shortname] = 0;
            }

            string success = TryShopSell(player, shopName, item, amount);

            if (success != null)
            {
                SendReply(player, (string) success);
                return;
            }

            if (shopitem.SellLimit > 0)
            {
                itemLimit.IncrementSell(shopitem.Shortname, amount, shopitem.SwapLimitToQuantitySoldLimit);
            }
            //string broadcast = $"<size=10><color=orange>{player.displayName}</color> sold {amount}x {shopitem.DisplayName} for {(int)(shopitem.SellPrice * amount)} RP!</size>";
            //Server.Broadcast(broadcast);
            SendReply(player, Lang("Sold", player.UserIDString), amount, GetItemDisplayName(shopitem.Shortname, shopitem.DisplayName, player.UserIDString));

            if (!string.IsNullOrEmpty(GetPlayerData(player).ShopKey))
                ShowGUIShops(player, shopName, _shopPage[player.userID], false, true);
        }

        // Fixed ShopID issues when using inside NPC shops ( current bug with global shops ) requires re-implementation Fixed Since 2.4.4x
        [ConsoleCommand("shop.transparency")]
        private void ConsoleGUIShopTransparency(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (!permission.UserHasPermission(player.UserIDString, Use))
            {
                return;
            }

            PlayerTransparencyChange(player, arg.Args[0]);

            string cat = GetPlayerData(player).ShopKey;

            /*if (!player.CanBuild())
            {
                if (permission.UserHasPermission(player.UserIDString, BlockAllow)) //Override.
                    ShowGUIShops(player, cat);
                else
                    SendReply(player, Lang("BuildingBlocked", player.UserIDString));
                return;
            }*/

            ShowGUIShops(player, cat);
        }

        [ConsoleCommand("shop.uicolor")]
        private void ConsoleGUIShopUIColor(ConsoleSystem.Arg arg)
        {
            if (arg.Args[0] == null || arg.Args[1] == null)
            {
                return;
            }

            PlayerColorTextChange(arg.Player(), arg.Args[0], arg.Args[1], arg.Args[2], _uiSettingChange);
            if (!permission.UserHasPermission(arg.Player().UserIDString, Use)) //added vip option.
            {
                return;
            }

            string cat = GetPlayerData(arg.Player()).ShopKey; // arg.Args[3].Replace("_", " ")

            /*if (!arg.Player().CanBuild())
            {
                if (permission.UserHasPermission(arg.Player().UserIDString, BlockAllow)) //Overrides being blocked.
                    ShowGUIShops(arg.Player(),cat);
                else
                    SendReply(arg.Player(), Lang("BuildingBlocked", arg.Player().UserIDString));
                return;
            }*/

            ShowGUIShops(arg.Player(), cat);
        }

        [ConsoleCommand("shop.colorsetting")]
        private void ConsoleGUIShopUIColorSetting(ConsoleSystem.Arg arg)
        {
            //Puts("{0}", arg.GetString(1));
            if (!arg.HasArgs(2))
                return;

            _uiSettingChange = arg.Args[0];
            if (!permission.UserHasPermission(arg.Player().UserIDString, Use)) //added vip
                return;

            string cat = GetPlayerData(arg.Player()).ShopKey; //arg.Args[1].Replace("_", " ")

            /*if (!arg.Player().CanBuild())
            {
                if (permission.UserHasPermission(arg.Player().UserIDString, BlockAllow)) //Overrides being blocked.
                    ShowGUIShops(arg.Player(), cat);
                else
                    SendReply(arg.Player(), Lang("BuildingBlocked", arg.Player().UserIDString));
                return;
            }*/

            GetSettingTypeToChange(_uiSettingChange);
            
            ShowGUIShops(arg.Player(), cat);
        }

        [ConsoleCommand("shop.imageortext")]
        private void ConsoleGUIShopUIImageOrText(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs())
            {
                return;
            }
            
            string cat = GetPlayerData(arg.Player()).ShopKey; //arg.Args[0].Replace("_", " ")

            if (_config.PersonalUI && !permission.UserHasPermission(arg.Player().UserIDString, Color))
            {
                ShowGUIShops(arg.Player(), cat);
                return;
            }

            SetImageOrText(arg.Player());

            /*if (!arg.Player().CanBuild())
            {
                if (permission.UserHasPermission(arg.Player().UserIDString, BlockAllow)) //Overrides being blocked.
                    ShowGUIShops(arg.Player(), _config.DefaultShop);
                else
                    SendReply(arg.Player(), Lang("BuildingBlocked", arg.Player().UserIDString));
                return;
            }*/

            ShowGUIShops(arg.Player(), cat);
        }

        [ConsoleCommand(("guishop.reset"))] /* Added to permanently assure zero config resets! */
        private void ConsoleGUIShopReset(ConsoleSystem.Arg arg)
        {
            if (!(arg.IsRcon || arg.IsAdmin)) return;
            PrintWarning("Loading GUIShop Defaults");
            LoadDefaultConfig();
            CheckConfig();
            SaveConfig();
            LibraryCheck();
        }

        #endregion

        #region CoolDowns

        private int CurrentTime() => Facepunch.Math.Epoch.Current;

        private bool HasBuyCooldown(ulong userID, string item, out double itemCooldown)
        {
            Dictionary<string, double> itemCooldowns;

            itemCooldown = 0.0;

            return _buyCooldownData.TryGetValue(userID, out itemCooldowns) && itemCooldowns.TryGetValue(item, out itemCooldown) && itemCooldown > CurrentTime();
        }

        private bool HasSellCooldown(ulong userID, string item, out double itemCooldown)
        {
            Dictionary<string, double> itemCooldowns;

            itemCooldown = 0.0;

            return _sellCoolDownData.TryGetValue(userID, out itemCooldowns) && itemCooldowns.TryGetValue(item, out itemCooldown) && itemCooldown > CurrentTime();
        }

        private bool HasBuyLimitCoolDown(ulong userID, string item, out double itemCooldown)
        {
            Dictionary<string, double> itemCooldowns;

            itemCooldown = 0.0;

            return _buyLimitResetCoolDownData.TryGetValue(userID, out itemCooldowns) && itemCooldowns.TryGetValue(item, out itemCooldown) && itemCooldown > CurrentTime();
        }
        
        private bool HasSellLimitCoolDown(ulong userID, string item, out double itemCooldown)
        {
            Dictionary<string, double> itemCooldowns;

            itemCooldown = 0.0;

            return _sellLimitResetCoolDownData.TryGetValue(userID, out itemCooldowns) && itemCooldowns.TryGetValue(item, out itemCooldown) && itemCooldown > CurrentTime();
        }

        private string FormatTime(long seconds)
        {
            TimeSpan timespan = TimeSpan.FromSeconds(seconds);

            return string.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds,
                Math.Floor(timespan.TotalHours));
        }

        #endregion

        #region UI Colors

        private string GetSettingTypeToChange(string type)
        {
            return type == _uiSettingChange ? $"{HexToColor("#FFFFFF")} 0.2" : $"{HexToColor("#CCD1D1")} 0";
        }

        private void SetImageOrText(BasePlayer player)
        {
            PlayerUISetting playerUISetting = GetPlayerData(player);

            if (permission.UserHasPermission(player.UserIDString, Color))
            {
                playerUISetting.ImageOrText = !playerUISetting.ImageOrText;
                return;
            }

            if (_config.PersonalUI)
            {
                playerUISetting.ImageOrText = !playerUISetting.ImageOrText;
            }
        }

        private bool GetImageOrText(BasePlayer player)
        {
            PlayerUISetting playerUISetting = GetPlayerData(player);
            if (!_config.PersonalUI && !permission.UserHasPermission(player.UserIDString, Color))
            {
                playerUISetting.ImageOrText = false;
            }

            if (_config.UIImageOption && !permission.UserHasPermission(player.UserIDString, Color))
            {
                //Puts("UI Image option + no Color perm");
                playerUISetting.ImageOrText = true;
            }

            if (_config.PersonalUI && _config.UIImageOption && !permission.UserHasPermission(player.UserIDString, Color))
            {
                //Puts("personal UI + UI Image Option + Color permission");
                playerUISetting.ImageOrText = true;
            }

            _imageChanger = playerUISetting.ImageOrText;
            return _imageChanger;
        }

        private string GetText(string text, string type, BasePlayer player)
        {
            if (GetImageOrText(player))
            {
                switch (type)
                {
                    case "label":
                        return "";
                    case "image":
                        return text;
                }
            }
            else
            {
                switch (type)
                {
                    case "label":
                        return text;
                    case "image":
                        return "https://i.imgur.com/fL7N8Zf.png";
                }
            }

            return "";
        }

        private double AnchorBarMath(BasePlayer uiPlayer) => (GetUITransparency(uiPlayer) / 10 - (GetUITransparency(uiPlayer) / 10 - GetPlayerData(uiPlayer).RangeValue / 1000)) * 10;

        private PlayerUISetting GetPlayerData(BasePlayer player)
        {
            PlayerUISetting playerUISetting;

            if (!_playerUIData.TryGetValue(player.UserIDString, out playerUISetting))
            {
                _playerUIData[player.UserIDString] = playerUISetting = new PlayerUISetting
                {
                    Transparency = Transparency,
                    
                    SellBoxColors = $"{HexToColor(_config.SellColor)} 0.15",
                    BuyBoxColors = $"{HexToColor(_config.BuyColor)} 0.15",
                    RangeValue = (Transparency - 0.9) * 100,
                    ImageOrText = _config.UIImageOption,
                };
            }

            return playerUISetting;
        }

        private void PlayerTransparencyChange(BasePlayer uiPlayer, string action)
        {
            PlayerUISetting playerUISetting = GetPlayerData(uiPlayer);

            switch (action)
            {
                case "increase":
                    if (Math.Abs(playerUISetting.Transparency - 1) >= 1)
                    {
                        break;
                    }

                    playerUISetting.Transparency = playerUISetting.Transparency + 0.01;
                    playerUISetting.RangeValue = playerUISetting.RangeValue + 1;
                    break;
                case "decrease":
                    if (Math.Abs(playerUISetting.Transparency - 0.01) <= 0.9)
                    {
                        break;
                    }

                    playerUISetting.Transparency = playerUISetting.Transparency - 0.01;
                    playerUISetting.RangeValue = playerUISetting.RangeValue - 1;
                    break;
            }
        }

        private double GetUITransparency(BasePlayer uiPlayer) => GetPlayerData(uiPlayer).Transparency;

        private void PlayerColorTextChange(BasePlayer uiPlayer, string textColorRed, string textColorGreen, string textColorBlue, string uiSettingToChange)
        {
            PlayerUISetting playerUISetting = GetPlayerData(uiPlayer);

            switch (uiSettingToChange)
            {
                case "Text":
                    playerUISetting.UITextColor = $"{textColorRed} {textColorGreen} {textColorBlue} 1";
                    break;
                case "Buy":
                    playerUISetting.BuyBoxColors = $"{textColorRed} {textColorGreen} {textColorBlue} {GetUITransparency(uiPlayer) - 0.75}";
                    break;
                case "Sell":
                    playerUISetting.SellBoxColors = $"{textColorRed} {textColorGreen} {textColorBlue} {GetUITransparency(uiPlayer) - 0.75}";
                    break;
            }
        }

        private string GetUITextColor(BasePlayer uiPlayer, string defaultHex) => GetPlayerData(uiPlayer).UITextColor ?? $"{HexToColor(defaultHex)} 1";

        private string GetUISellBoxColor(BasePlayer uiPlayer) => GetPlayerData(uiPlayer).SellBoxColors;

        private string GetUIBuyBoxColor(BasePlayer uiPlayer) => GetPlayerData(uiPlayer).BuyBoxColors;

        private string HexToColor(string hexString)
        {
            if (hexString.IndexOf('#') != -1) hexString = hexString.Replace("#", "");

            int b = 0;
            int r = 0;
            int g = 0;

            if (hexString.Length == 6)
            {
                r = int.Parse(hexString.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                g = int.Parse(hexString.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                b = int.Parse(hexString.Substring(4, 2), NumberStyles.AllowHexSpecifier);
            }

            return $"{(double) r / 255} {(double) g / 255} {(double) b / 255}";
        }

        #endregion

        #region Limits

        private ItemLimit GetPlayerLimit(BasePlayer player)
        {
            if (!player.userID.IsSteamId()) 
                return null;
            
            ItemLimit itemdata;

            if (!_limitsData.TryGetValue(player.userID, out itemdata))
                _limitsData[player.userID] = itemdata = new ItemLimit();

            return itemdata;
        }

        #endregion

        #region NPC

        private bool NearNpc(string npcId, BasePlayer player)
        {
            BasePlayer npc = GetNPC(npcId);

            if (npc == null)
            {
                return false;
            }
            object success = Interface.Call("isInTriggerHumanNpc", npc, player);
            if (success is bool) return (bool) success;
            
            return Vector3Ex.Distance2D(npc.ServerPosition, player.transform.position) <= _config.NPCDistanceCheck;
        }
        private BasePlayer GetNPC(string npcId)
        {
            foreach (BasePlayer npcPlayer in BaseNetworkable.serverEntities.OfType<BasePlayer>())
            {
                if (npcPlayer.UserIDString == npcId)
                {
                    return npcPlayer;
                }
            }

            return null;
        }

        bool GetNearestVendor(BasePlayer player, out ShopCategory shopCategory) //NPC helper reverted.
        {
            shopCategory = null;

            Collider[] colliders = Physics.OverlapSphere(player.ServerPosition, _config.NPCDistanceCheck, playersMask);

            if (!colliders.Any()) return false;

            //Puts($"collider count ? {colliders.Length} | collider get baseplayer is null ? {colliders.Select(col => col.GetComponent<BasePlayer>()) == null} | first or default is null ? {colliders.Select(col => col.GetComponent<BasePlayer>())?.FirstOrDefault(x => x != null && x != player && !IsPlayer(x.userID)) ?? null}");

            BasePlayer npc = colliders.Select(col => col.GetComponent<BasePlayer>()).FirstOrDefault(x => x != null && x != player && !IsPlayer(x.userID)) ?? null;

            if (npc == null) return false;

            shopCategory = _config.ShopCategories.Select(x => x.Value).FirstOrDefault(i => i.EnableNPC && i.NpcIds.Contains(npc.UserIDString) && (!string.IsNullOrEmpty(i.Permission) && permission.UserHasPermission(player.UserIDString, i.PrefixPermission) || string.IsNullOrEmpty(i.Permission)));

            if (shopCategory == null) return false;

            return true;
        }

        bool IsPlayer(ulong userID) => userID.IsSteamId();

        private void OnUseNPC(BasePlayer npc, BasePlayer player) //added 1.8.7 //updated 2.2.48
        {
            if (player == null) return;

            if (!permission.UserHasPermission(player.UserIDString, Use))
            {
                SendReply(player, Lang("NoPermUse", player.UserIDString, Use));
                return;
            }

            if (_imageLibraryCheck >= _config.ImageLibraryCounter)
            {
                SendReply(player, Lang("ImageLibraryFailure", player.UserIDString, _config.ImageLibraryCounter));
                return;
            }

            if (!_isShopReady || LangAPI != null && !_isLangAPIReady)
            {
                SendReply(player, Lang("GUIShopResponse", player.UserIDString));
                return;
            }

            if (_wipeReady == false)
            {
                float timeresult = _config.Time.CanShopIn / 60;
                SendReply(player, Lang("WipeReady", player.UserIDString, player.displayName, Math.Round(timeresult)));
                return;
            }

            float distance = Vector3.Distance(npc.ServerPosition, player.ServerPosition);
            if (distance > _config.NPCDistanceCheck) return;

            ShopCategory category = _config.ShopCategories.Select(x => x.Value).FirstOrDefault(i => i.EnableNPC && i.NpcIds.Contains(npc.UserIDString) && (!string.IsNullOrEmpty(i.Permission) && permission.UserHasPermission(player.UserIDString, i.PrefixPermission) || string.IsNullOrEmpty(i.