              }
            }

            var attackerPlayer = _pluginConfig.AttributeDamageToBombTruckOwner ? BasePlayer.FindByID(car.OwnerID) : null;
            var attackerId = _pluginConfig.AttributeDamageToBombTruckOwner ? car.OwnerID : 0;

            var carPosition = car.CenterPoint();
            car.Kill();
            DetonateExplosion(attackerPlayer, attackerId, truckConfig.ExplosionSpec, carPosition);
        }

        private void DetonateExplosion(BasePlayer attackerPlayer, ulong attackerId, ExplosionSpec spec, Vector3 origin)
        {
            ServerMgr.Instance.StartCoroutine(ExplosionCoroutine(attackerPlayer, attackerId, spec, origin));
        }

        private IEnumerator ExplosionCoroutine(BasePlayer attackerPlayer, ulong attackerId, ExplosionSpec spec, Vector3 origin)
        {
            float rocketTravelTime = 0.3f;
            double totalTime = spec.Radius / spec.Speed;
            int numExplosions = (int)Math.Ceiling(spec.DensityCoefficient * Math.Pow(spec.Radius, spec.DensityExponent));

            float timeElapsed = 0;
            double prevDistance = 0;

            FireRocket(attackerPlayer, attackerId, PrefabExplosiveRocket, origin, Vector3.forward, 0, spec.BlastRadiusMult, spec.DamageMult);

            for (var i = 1; i <= numExplosions; i++)
            {
                if (_pluginUnloaded)
                    yield break;

                double timeFraction = timeElapsed / totalTime;
                double stepDistance = spec.Radius * timeFraction;

                double stepStartDistance = prevDistance;
                double stepEndDistance = stepDistance;

                double rocketDistance = Core.Random.Range(stepStartDistance, stepEndDistance);
                double rocketSpeed = rocketDistance / rocketTravelTime;

                Vector3 rocketVector = MakeRandomDomeVector();

                // Skip over some space to reduce the frequency of rockets colliding with each other.
                Vector3 skipDistance = rocketVector;

                rocketVector *= Convert.ToSingle(rocketSpeed);
                FireRocket(attackerPlayer, attackerId, PrefabExplosiveRocket, origin + skipDistance, rocketVector + skipDistance, rocketTravelTime, spec.BlastRadiusMult, spec.DamageMult);

                float timeToNext = Convert.ToSingle(Math.Pow(i / spec.DensityCoefficient, 1.0 / spec.DensityExponent) / spec.Speed - timeElapsed);

                yield return CoroutineEx.waitForSeconds(timeToNext);
                prevDistance = stepDistance;
                timeElapsed += timeToNext;
            }
        }

        private Vector3 MakeRandomDomeVector() =>
            new Vector3(Core.Random.Range(-1f, 1f), Core.Random.Range(0, 1f), Core.Random.Range(-1f, 1f)).normalized;

        #endregion

        #region Data Management

        private PlayerData GetPlayerData(string userID)
        {
            if (!_pluginData.PlayerData.ContainsKey(userID))
                _pluginData.PlayerData.Add(userID, new PlayerData());

            return _pluginData.PlayerData[userID];
        }

        private void CleanStaleTruckData()
        {
            var cleanedCount = 0;

            // Clean up any stale truck IDs in case of a data file desync.
            foreach (var playerData in _pluginData.PlayerData.Values)
            {
                cleanedCount += playerData.BombTrucks.RemoveAll(truckData =>
                    (BaseNetworkable.serverEntities.Find(new NetworkableId(truckData.ID)) as ModularCar) == null);
            }

            if (cleanedCount > 0)
            {
                SaveData();
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _pluginData);

        private void ClearData() => Interface.Oxide.DataFileSystem.WriteObject(Name, new StoredData());

        private class StoredData
        {
            [JsonProperty("PlayerData")]
            public Dictionary<string, PlayerData> PlayerData = new Dictionary<string, PlayerData>();
        }

        private class PlayerData
        {
            [JsonProperty("BombTrucks")]
            public List<PlayerTruckData> BombTrucks = new List<PlayerTruckData>();

            [JsonProperty("Cooldowns")]
            public Dictionary<string, long> Cooldowns = new Dictionary<string, long>();

            public void UpdateCooldown(string truckName, long time)
            {
                if (Cooldowns.ContainsKey(truckName))
                {
                    Cooldowns[truckName] = time;
                }
                else
                {
                    Cooldowns.Add(truckName, time);
                }
            }

            public int GetTruckCount(string truckName) =>
                BombTrucks.Count(truckData => truckData.Tracked && truckData.Name == truckName);

            public PlayerTruckData FindTruck(ulong netID) =>
                BombTrucks.FirstOrDefault(truckData => truckData.ID == netID);

            public void RemoveTruck(ulong netID)
            {
                BombTrucks.RemoveAll(truckData => truckData.ID == netID);
            }
        }

        private class PlayerTruckData
        {
            [JsonProperty("ID")]
            public ulong ID;

            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("Tracked")]
            public bool Tracked = true;
        }

        #endregion

        #region Configuration

        private TruckConfig GetTruckConfig(string truckName) =>
            _pluginConfig.BombTrucks.FirstOrDefault(truckConfig => truckConfig.Name.ToLower() == truckName.ToLower());

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("BombTrucks")]
            public TruckConfig[] BombTrucks = new TruckConfig[0];

            [JsonProperty("AttributeDamageToBombTruckOwner")]
            public bool AttributeDamageToBombTruckOwner;

            [JsonProperty("NoEscapeSettings")]
            public NoEscapeSettings NoEscapeSettings = new NoEscapeSettings();
        }

        private class TruckConfig
        {
            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("CooldownSeconds")]
            public long CooldownSeconds;

            [JsonProperty("SpawnLimitPerPlayer")]
            public int SpawnLimit = 1;

            [JsonProperty("AttachRFReceiver")]
            public bool AttachRFReceiver = true;

            private int _enginePartsTier = 1;

            [JsonProperty("EnginePartsTier")]
            public int EnginePartsTier
            {
                get { return _enginePartsTier; }
                set { _enginePartsTier = Math.Min(Math.Max(value, 1), 3); }
            }

            [JsonProperty("Modules")]
            public object[] Modules =
            {
                "vehicle.1mod.cockpit.with.engine",
                "vehicle.2mod.fuel.tank"
            };

            [JsonProperty("ExplosionSettings")]
            public ExplosionSpec ExplosionSpec = new ExplosionSpec();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                BombTrucks = new[]
                {
                    new TruckConfig
                    {
                        Name = DefaultTruckConfigName,
                        EnginePartsTier = 3,
                        CooldownSeconds = 3600,
                        SpawnLimit = 3,
                        ExplosionSpec = new ExplosionSpec
                        {
                            BlastRadiusMult = 1,
                            DamageMult = 4.0f,
                            DensityCoefficient = 1,
                            DensityExponent = Math.Round(1.8f * 100) / 100,
                            Radius = 5,
                            Speed = 10,
                        }
                    },
                    new TruckConfig
                    {
                        Name = "Nuke",
                        EnginePartsTier = 1,
                        CooldownSeconds = 10800,
                        SpawnLimit = 1,
                        Modules = new object[]
                        {
                            "vehicle.1mod.engine",
                            "vehicle.1mod.cockpit.armored",
                            "vehicle.2mod.fuel.tank"
                        },
                        ExplosionSpec = new ExplosionSpec
                        {
                            BlastRadiusMult = 1,
                            DamageMult = 6.0f,
                            DensityCoefficient = 1,
                            DensityExponent = Math.Round(1.6f * 100) / 100,
                            Radius = 15,
                            Speed = 10,
                        }
                    }
                }
            };
        }

        private class ExplosionSpec
        {
            private double _speed = 10;
            private double _densityCoefficient = 1;
            private double _densityExponent = 2;

            [JsonProperty("Radius")]
            public double Radius = 10;

            [JsonProperty("DensityCoefficient")]
            public double DensityCoefficient
            {
                get { return _densityCoefficient; }
                set { _densityCoefficient = Math.Max(value, 0.01); }
            }

            [JsonProperty("DensityExponent")]
            public double DensityExponent
            {
                get { return _densityExponent; }
                set { _densityExponent = Math.Min(Math.Max(value, 1), 3); }
            }

            [JsonProperty("Speed")]
            public double Speed
            {
                get { return _speed; }
                set { _speed = Math.Max(value, 0.1); }
            }

            [JsonProperty("BlastRadiusMult")]
            public float BlastRadiusMult = 1;

            [JsonProperty("DamageMult")]
            public float DamageMult = 1;
        }

        private class NoEscapeSettings
        {
            [JsonProperty("CanSpawnWhileRaidBlocked")]
            public bool CanSpawnWhileRaidBlocked = true;

            [JsonProperty("CanSpawnWhileCombatBlocked")]
            public bool CanSpawnWhileCombatBlocked = true;
        }

        #endregion

        #region Configuration Boilerplate

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion

        #region Localization

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));

        private string GetMessage(IPlayer player, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, player.Id);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Generic.Error.NoPermission"] = "You don't have permission to use this command.",
                ["Generic.Error.BuildingBlocked"] = "Error: Cannot do that while building blocked.",
                ["Generic.Error.Cooldown"] = "Please wait <color=red>{0}</color> and try again.",
                ["Command.Spawn.Error.NotFound"] = "Truck <color=red>{0}</color> does not exist.",
                ["Command.Spawn.Error.TooManyOfType"] = "Error: You may not have more than <color=red>{0}</color> of that truck.",
                ["Command.Spawn.Error.Mounted"] = "You cannot do that while mounted.",
                ["Command.Spawn.Error.NotOnGround"] = "You must be on the ground to do that.",
                ["Command.Spawn.Error.Generic"] = "You cannot do that right now.",
                ["Command.Spawn.Success"] = "Here is your bomb truck.",
                ["Command.Spawn.Success.Frequency"] = "Detonate it with frequency: {0}",
                ["Command.Help"] = "<color=orange>BombTruck Command Usages</color>",
                ["Command.Help.Spawn.Default"] = "<color=yellow>bt</color> - Spawn a bomb truck",
                ["Command.Help.Spawn.Named"] = "<color=yellow>bt {0}</color> - Spawn a {0} truck",
                ["Command.Help.LimitUsage"] = "<color=yellow>{0}/{1}</color>",
                ["Command.Help.RemainingCooldown"] = "<color=red>{0}</color>",
                ["Command.Spawn.Error.RaidBlocked"] = "Error: Cannot do that while raid blocked.",
                ["Command.Spawn.Error.CombatBlocked"] = "Error: Cannot do that while combat blocked.",
                ["Command.Give.Error.Syntax"] = "Syntax: <color=yellow>givebombtruck <player> <truck name></color>",
                ["Command.Give.Error.PlayerNotFound"] = "Error: Player <color=red>{0}</color> not found.",
                ["Lift.Edit.Error"] = "Error: That vehicle may not be edited.",
                ["Lock.Deploy.Error"] = "Error: Bomb trucks may not have locks.",
                ["Unclaim.Error"] = "Error: You cannot unclaim bomb trucks.",
                ["AutoTurret.Deploy.Error"] = "Error: You cannot deploy auto turrets to bomb trucks.",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: BombTrucks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-chat-ignore ---
// --- Original File Path: B/BetterChatIgnore/BetterChatIgnore.cs ---

﻿using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("BetterChatIgnore", "MisterPixie", "1.0.3")]
    [Description("Players can ignore chat messages from other players")]
    public class BetterChatIgnore : CovalencePlugin
    {
        [PluginReference]
        private Plugin BetterChat, Ignore;

        void OnServerInitialized()
        {
            if (!BetterChat)
            {
                PrintWarning("BetterChat not detected");
            }

            if (!Ignore)
            {
                PrintWarning("Ignore API not detected");
            }
        }

        object OnBetterChat(Dictionary<string, object> messageData)
        {
            if (!Ignore)
            {
                PrintWarning("Ignore API not detected");
                return messageData;
            }

            IPlayer playerSendingMessage = (IPlayer)messageData["Player"];

            List<string> blockedReceivers = (List<string>)messageData["BlockedReceivers"];

            foreach (var player in covalence.Players.Connected)
            {
                var hasIgnored = Ignore?.CallHook("HasIgnored", player.Id, playerSendingMessage.Id);
                if (hasIgnored != null && (bool)hasIgnored)
                {
                    blockedReceivers.Add(player.Id);
                }
            }

            messageData["BlockedReceivers"] = blockedReceivers;

            return messageData;
        }
    }
}

// --- End of file: BetterChatIgnore.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bounty ---
// --- Original File Path: B/Bounty/Bounty.cs ---

using System.Collections.Generic;
using System;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Linq;
using Oxide.Core.Configuration;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Network;

namespace Oxide.Plugins
{
    [Info("Bounty", "k1lly0u", "0.2.7")]
    [Description("Place bounties on other players using in-game items, RP or Economics")]
    class Bounty : RustPlugin
    {
        [PluginReference] Plugin Clans, Friends, PopupNotifications, Economics, ServerRewards;

        private StoredData storedData;
        private DynamicConfigFile data;

        private Dictionary<ulong, ulong> bountyCreator = new Dictionary<ulong, ulong>();
        private Dictionary<StorageContainer, ulong> openContainers = new Dictionary<StorageContainer, ulong>();
        private Dictionary<int, string> idToDisplayName = new Dictionary<int, string>();

        private string boxPrefab = "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab";

        #region Oxide Hooks     
        private void Loaded()
        {
            permission.RegisterPermission("bounty.use", this);
            permission.RegisterPermission("bounty.admin", this);

            lang.RegisterMessages(messages, this);

            data = Interface.Oxide.DataFileSystem.GetFile("Bounty/bounty_data");
        }

        private void OnServerInitialized()
        {
            idToDisplayName = ItemManager.itemList.ToDictionary(x => x.itemid, y => y.displayName.english);
            LoadData();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }
        
        private void OnPlayerConnected(BasePlayer player)
        {
            PlayerData playerData;
            if (storedData.players.TryGetValue(player.userID, out playerData))
            {
                if (playerData.activeBounties.Count > 0)                
                    BroadcastToPlayer(player, string.Format(msg("bounties_outstanding", player.userID), playerData.activeBounties.Count));
                
                playerData.displayName = player.displayName;
            }            
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            PlayerData playerData;
            if (storedData.players.TryGetValue(player.userID, out playerData))
                playerData.UpdateWantedTime();
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null)
                return null;

            if (entity is StorageContainer && openContainers.ContainsKey(entity as StorageContainer))
                return false;

            return null;
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null)
                return;

            BasePlayer victim = entity.ToPlayer();
            BasePlayer attacker = info.InitiatorPlayer;

            if (victim == null || attacker == null || attacker.GetComponent<NPCPlayer>())
                return;
            
            PlayerData victimData;
            if (!storedData.players.TryGetValue(victim.userID, out victimData))
                return;

            if (victimData.activeBounties.Count == 0)
                return;

            if (IsFriendlyPlayer(victim.userID, attacker.userID))
            {
                BroadcastToPlayer(attacker, msg("is_friend", attacker.userID));
                return;
            }
           
            victimData.UpdateWantedTime();

            List<int> rewards = victimData.activeBounties.Select(x => x.rewardId).ToList();
            victimData.activeBounties.Clear();

            PlayerData attackerData;
            if (!storedData.players.TryGetValue(attacker.userID, out attackerData))
            {
                attackerData = new PlayerData(attacker.displayName);
                storedData.players.Add(attacker.userID, attackerData);
            }

            attackerData.ClaimRewards(rewards);
            BroadcastToPlayer(attacker, string.Format(msg("rewards_pending"), victim.displayName, rewards.Count));            
        }

        private object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (player == null || container == null || !openContainers.ContainsKey(container))
                return null;

            if (openContainers[container] != player.userID)
                return false;
            
            return null;
        }

        private void OnPlayerLootEnd(PlayerLoot inventory)
        {
            BasePlayer player = inventory.GetComponent<BasePlayer>();

            if (bountyCreator.ContainsKey(player.userID))
            {
                StorageContainer container = inventory.entitySource.GetComponent<StorageContainer>();
                if (container != null)
                {
                    if (container.inventory.itemList.Count == 0)
                        SendReply(player, msg("no_items_deposited", player.userID));
                    else CreateNewBounty(player, bountyCreator[player.userID], 0, 0, container.inventory);

                    openContainers.Remove(container);
                    ClearContainer(container.inventory);
                    container.DieInstantly();
                }
                bountyCreator.Remove(player.userID);
            }
        }

        private void OnServerSave() => SaveData();
       
        private void Unload() => SaveData(); 
        #endregion

        #region Functions  
        private void BroadcastToPlayer(BasePlayer player, string message)
        {
            if (configData.Notifications.UsePopupNotifications && PopupNotifications)
                PopupNotifications?.Call("CreatePopupOnPlayer", message, player, configData.Notifications.PopupDuration);
            else SendReply(player, message);
        }

        private void CreateNewBounty(BasePlayer initiator, ulong targetId, int rpAmount, int ecoAmount, ItemContainer container)
        {
            IPlayer target = covalence.Players.FindPlayerById(targetId.ToString());
            
            PlayerData playerData;
            if (!storedData.players.TryGetValue(targetId, out playerData))
            {
                playerData = new PlayerData(target?.Name ?? "No Name");
                storedData.players.Add(targetId, playerData);
            }

            playerData.totalBounties++;

            int rewardId = GetUniqueId();
            storedData.rewards.Add(rewardId, new RewardInfo(rpAmount, ecoAmount, container));
            playerData.activeBounties.Add(new PlayerData.BountyInfo(initiator.userID, initiator.displayName, rewardId));

            BasePlayer targetPlayer = target?.Object as BasePlayer;

            if (configData.Notifications.BroadcastNewBounties && targetPlayer != null)
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                    SendReply(player, string.Format(msg("bounty_placed_global", player.userID), initiator.displayName, targetPlayer.displayName));
            }
            else
            {
                if (targetPlayer != null)
                    BroadcastToPlayer(targetPlayer, string.Format(msg("bounty_placed_target", targetPlayer.userID), initiator.displayName));

                BroadcastToPlayer(initiator, string.Format(msg("bounty_placed_initiator", initiator.userID), target?.Name ?? "No Name"));
            }  
        }

        private void CancelBounty(BasePlayer player, IPlayer target)
        {
            PlayerData playerData;
            if (!storedData.players.TryGetValue(ulong.Parse(target.Id), out playerData))
            {
                SendReply(player, string.Format(msg("no_bounty_placed", player.userID), target.Name));
                return;
            }

            PlayerData.BountyInfo bountyInfo = playerData.activeBounties.Find(x => x.initiatorId == player.userID) ?? null;
            if (bountyInfo == null)
            {
                SendReply(player, string.Format(msg("no_bounty_placed", player.userID), target.Name));
                return;
            }

            RewardInfo rewardInfo = storedData.rewards[bountyInfo.rewardId];
            GivePlayerRewards(player, rewardInfo);
            storedData.rewards.Remove(bountyInfo.rewardId);
            playerData.activeBounties.Remove(bountyInfo);

            BasePlayer targetPlayer = target.Object as BasePlayer;
            if (targetPlayer != null)            
                BroadcastToPlayer(targetPlayer, string.Format(msg("bounty_cancelled_target", targetPlayer.userID), player.displayName));

            BroadcastToPlayer(player, string.Format(msg("bounty_cancelled_initiator", player.userID), target.Name));
        }

        private void GivePlayerRewards(BasePlayer player, RewardInfo rewardInfo)
        {
            if (rewardInfo.econAmount > 0 && Economics)            
                Economics?.Call("Deposit", player.UserIDString, (double)rewardInfo.econAmount);
            
            if (rewardInfo.rpAmount > 0 && ServerRewards)
                ServerRewards?.Call("AddPoints", player.userID, rewardInfo.rpAmount);

            if (rewardInfo.rewardItems.Count > 0)
            {
                foreach (RewardInfo.ItemData itemData in rewardInfo.rewardItems)
                {
                    Item item = CreateItem(itemData);
                    player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                }
            }

            SendReply(player, msg("reward_claimed", player.userID));
        }

        private Item CreateItem(RewardInfo.ItemData itemData)
        {
            Item item = ItemManager.CreateByItemID(itemData.itemid, itemData.amount, itemData.skin);
            item.condition = itemData.condition;

            if (itemData.instanceData != null)
                itemData.instanceData.Restore(item);

            BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                if (!string.IsNullOrEmpty(itemData.ammotype))
                    weapon.primaryMagazine.ammoType = ItemManager.FindItemDefinition(itemData.ammotype);
                weapon.primaryMagazine.contents = itemData.ammo;
            }
            if (itemData.contents != null)
            {
                foreach (var contentData in itemData.contents)
                {
                    var newContent = ItemManager.CreateByItemID(contentData.itemid, contentData.amount);
                    if (newContent != null)
                    {
                        newContent.condition = contentData.condition;
                        newContent.MoveToContainer(item.contents);
                    }
                }
            }
            return item;
        }

        private void SpawnItemContainer(BasePlayer player)
        {
            StorageContainer container = (StorageContainer)GameManager.server.CreateEntity(boxPrefab, player.transform.position + player.eyes.BodyForward(), new Quaternion(), true);
            container.enableSaving = false;
            container.Spawn();
            
            openContainers.Add(container, player.userID);
            timer.In(0.15f, ()=> OpenInventory(player, container));            
        }
        
        private void OpenInventory(BasePlayer player, StorageContainer container)
        {
            player.inventory.loot.Clear();
            player.inventory.loot.entitySource = container;
            player.inventory.loot.itemSource = null;
            player.inventory.loot.AddContainer(container.inventory);
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "generic");
            player.SendNetworkUpdate();
        }

        private void ClearContainer(ItemContainer itemContainer)
        {
            if (itemContainer == null || itemContainer.itemList == null) return;
            while (itemContainer.itemList.Count > 0)
            {
                var item = itemContainer.itemList[0];
                item.RemoveFromContainer();
                item.Remove(0f);
            }
        }

        private int GetUniqueId()
        {
            int uid = UnityEngine.Random.Range(0, 10000);
            if (storedData.rewards.ContainsKey(uid))
                return GetUniqueId();
            return uid;
        }
        
        private double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private List<BasePlayer> FindPlayer(string partialNameOrId)
        {
            List<BasePlayer> players = new List<BasePlayer>();
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                if (partialNameOrId == player.UserIDString)
                    return new List<BasePlayer>() { player };

                if (player.displayName.ToLower().Contains(partialNameOrId.ToLower()))
                    players.Add(player);
            }
            return players;
        }

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            var days = dateDifference.Days;
            var hours = dateDifference.Hours;
            hours += (days * 24);
            var mins = dateDifference.Minutes;
            var secs = dateDifference.Seconds;
            if (hours > 0)
                return string.Format("{0:00}h {1:00}m {2:00}s", hours, mins, secs);
            else return string.Format("{0:00}m {1:00}s", mins, secs);
        }
        #endregion

        #region Friends
        public bool IsFriendlyPlayer(ulong playerId, ulong friendId)
        {
            if (playerId == friendId || IsFriend(playerId, friendId) || IsClanmate(playerId, friendId))
                return true;
            return false;
        }

        private bool IsClanmate(ulong playerId, ulong friendId)
        {
            if (!Clans || !configData.IgnoreClans) return false;
            object playerTag = Clans?.Call("GetClanOf", playerId);
            object friendTag = Clans?.Call("GetClanOf", friendId);
            if ((playerTag is string && !string.IsNullOrEmpty((string)playerTag)) && (friendTag is string && !string.IsNullOrEmpty((string)friendTag)))
                if (playerTag == friendTag) return true;
            return false;
        }

        private bool IsFriend(ulong playerID, ulong friendID)
        {
            if (!Friends || !configData.IgnoreFriends) return false;
            return (bool)Friends?.Call("AreFriends", playerID, friendID);
        }
        #endregion

        #region Commands       
        [ChatCommand("bounty")]
        private void cmdBounty(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "bounty.use"))
            {
                SendReply(player, msg("no_permission", player.userID));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, string.Format(msg("title", player.userID), Title, Version));
                if (configData.Rewards.AllowItems)
                    SendReply(player, msg("help1", player.userID));
                if (configData.Rewards.AllowServerRewards && ServerRewards)
                    SendReply(player, msg("help2", player.userID));
                if (configData.Rewards.AllowEconomics && Economics)
                    SendReply(player, msg("help3.1", player.userID));
                SendReply(player, msg("help4", player.userID));
                SendReply(player, msg("help5", player.userID));
                SendReply(player, msg("help6", player.userID));
                SendReply(player, msg("help7", player.userID));
                SendReply(player, msg("help8", player.userID));
                SendReply(player, msg("help11", player.userID));

                if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, "bounty.admin"))                
                    SendReply(player, msg("help9", player.userID));

                return;
            }

            switch (args[0].ToLower())
            {
                case "add":
                    {                        
                        if (args.Length < 3)
                        {
                            SendReply(player, msg("invalid_syntax", player.userID));
                            return;
                        }

                        List<BasePlayer> players = FindPlayer(args[2]);
                        if (players.Count == 0)
                        {
                            SendReply(player, msg("no_player_found", player.userID));
                            return;
                        }
                        if (players.Count > 1)
                        {
                            SendReply(player, msg("multiple_players_found", player.userID));
                            return;
                        }

                        BasePlayer targetPlayer = players[0];
                        if (targetPlayer == null)
                        {
                            SendReply(player, msg("no_player_found", player.userID));
                            return;
                        }

                        if (targetPlayer == player)
                        {
                            SendReply(player, msg("cant_bounty_self", player.userID));
                            return;
                        }

                        PlayerData playerData;
                        if (!storedData.players.TryGetValue(targetPlayer.userID, out playerData))
                        {
                            playerData = new PlayerData(targetPlayer.displayName);

                            storedData.players.Add(targetPlayer.userID, playerData);
                        }

                        if (playerData.activeBounties.Find(x => x.initiatorId == player.userID) != null)
                        {
                            SendReply(player, msg("has_active_bounty", player.userID));
                            return;
                        }

                        switch (args[1].ToLower())
                        {
                            case "items":
                                SpawnItemContainer(player);

                                if (bountyCreator.ContainsKey(player.userID))
                                    bountyCreator[player.userID] = targetPlayer.userID;
                                else bountyCreator.Add(player.userID, targetPlayer.userID);
                                return;
                            case "rp":
                                if (!configData.Rewards.AllowServerRewards || !ServerRewards || args.Length != 4)
                                {
                                    SendReply(player, msg("invalid_syntax", player.userID));
                                    return;
                                }

                                int rpAmount;
                                if (!int.TryParse(args[3], out rpAmount))
                                {
                                    SendReply(player, msg("no_value_entered", player.userID));
                                    return;
                                }

                                int availableRp = (int)ServerRewards?.Call("CheckPoints", player.userID);

                                if (availableRp < rpAmount || !(bool)ServerRewards?.Call("TakePoints", player.userID, rpAmount))
                                {
                                    SendReply(player, msg("not_enough_rp", player.userID));
                                    return;
                                }

                                CreateNewBounty(player, targetPlayer.userID, rpAmount, 0, null);
                                return;
                            case "eco":
                                if (!configData.Rewards.AllowEconomics || !Economics || args.Length != 4)
                                {
                                    SendReply(player, msg("invalid_syntax", player.userID));
                                    return;
                                }

                                int ecoAmount;
                                if (!int.TryParse(args[3], out ecoAmount))
                                {
                                    SendReply(player, msg("no_value_entered", player.userID));
                                    return;
                                }

                                double availableEco = (double)Economics?.Call("Balance", player.UserIDString);

                                if (availableEco < ecoAmount || !(bool)Economics?.Call("Withdraw", player.UserIDString, (double)ecoAmount))
                                {
                                    SendReply(player, msg("not_enough_eco", player.userID));
                                    return;
                                }

                                CreateNewBounty(player, targetPlayer.userID, 0, ecoAmount, null);
                                return;

                            default:
                                SendReply(player, msg("invalid_syntax", player.userID));
                                return;
                        }
                    }
                case "cancel":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, msg("invalid_syntax", player.userID));
                            return;
                        }

                        IPlayer targetPlayer = covalence.Players.FindPlayer(args[1]);
                        if (targetPlayer == null)
                        {
                            SendReply(player, msg("no_player_found", player.userID));
                            return;
                        }

                        CancelBounty(player, targetPlayer);
                    }
                    return;
                case "claim":
                    {
                        PlayerData playerData;
                        if (!storedData.players.TryGetValue(player.userID, out playerData) || playerData.unclaimedRewards.Count == 0)
                        {
                            SendReply(player, msg("no_rewards_pending", player.userID));
                            return;
                        }

                        if (args.Length < 2)
                        {
                            SendReply(player, msg("help10", player.userID));
                            foreach(int rewardId in playerData.unclaimedRewards)
                            {
                                RewardInfo rewardInfo = storedData.rewards[rewardId];
                                string reward = string.Empty;
                                if (rewardInfo.rewardItems.Count > 1)
                                {
                                    for (int i = 0; i < rewardInfo.rewardItems.Count; i++)
                                    {
                                        RewardInfo.ItemData itemData = rewardInfo.rewardItems.ElementAt(i);
                                        reward += (string.Format(msg("reward_item", player.userID), itemData.amount, idToDisplayName[itemData.itemid]) + (i < rewardInfo.rewardItems.Count - 1 ? ", " : ""));
                                    }
                                }
                                else reward = rewardInfo.econAmount > 0 ? string.Format(msg("reward_econ", player.userID), rewardInfo.econAmount) : string.Format(msg("reward_rp", player.userID), rewardInfo.rpAmount);

                                SendReply(player, string.Format(msg("reward_info", player.userID), rewardId, reward));
                            }
                        }
                        else
                        {
                            int rewardId;
                            if (!int.TryParse(args[1], out rewardId) || !playerData.unclaimedRewards.Contains(rewardId))
                            {
                                SendReply(player, msg("invalid_reward_id", player.userID));
                                return;
                            }

                            RewardInfo rewardInfo = storedData.rewards[rewardId];
                            GivePlayerRewards(player, rewardInfo);
                            storedData.rewards.Remove(rewardId);
                            playerData.unclaimedRewards.Remove(rewardId);
                        }
                    }
                    return;
                case "view":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, msg("invalid_syntax", player.userID));
                            return;
                        }

                        IPlayer targetPlayer = covalence.Players.FindPlayer(args[1]);
                        if (targetPlayer == null)
                        {
                            SendReply(player, msg("no_player_found", player.userID));
                            return;
                        }

                        PlayerData playerData;
                        if (!storedData.players.TryGetValue(ulong.Parse(targetPlayer.Id), out playerData) || playerData.activeBounties.Count == 0)
                        {
                            SendReply(player, msg("no_active_bounties", player.userID));
                            return;
                        }

                        SendReply(player, string.Format(msg("player_has_bounties", player.userID), targetPlayer.Name, playerData.activeBounties.Count));
                        foreach(var bounty in playerData.activeBounties)
                        {
                            RewardInfo rewardInfo = storedData.rewards[bounty.rewardId];
                            string reward = string.Empty;
                            if (rewardInfo.rewardItems.Count > 0)
                            {
                                for (int i = 0; i < rewardInfo.rewardItems.Count; i++)
                                {
                                    RewardInfo.ItemData itemData = rewardInfo.rewardItems.ElementAt(i);
                                    reward += (string.Format(msg("reward_item", player.userID), itemData.amount, idToDisplayName[itemData.itemid]) + (i < rewardInfo.rewardItems.Count - 1 ? ", " : ""));
                                }
                            }
                            else reward = rewardInfo.econAmount > 0 ? string.Format(msg("reward_econ", player.userID), rewardInfo.econAmount) : string.Format(msg("reward_rp", player.userID), rewardInfo.rpAmount);

                            SendReply(player, string.Format(msg("bounty_info", player.userID), bounty.initiatorName, FormatTime(CurrentTime() - bounty.initiatedTime), reward));
                        }
                    }
                    return;
                case "top":
                    IEnumerable<PlayerData> top10Hunters = storedData.players.Values.OrderByDescending(x => x.bountiesClaimed).Take(10);
                    string hunterMessage = msg("top_hunters", player.userID);

                    for (int i = 0; i < top10Hunters.Count(); i++)
                    {
                        PlayerData playerData = top10Hunters.ElementAt(i);
                        hunterMessage += string.Format(msg("top_hunter_entry", player.userID), playerData.displayName, playerData.bountiesClaimed);

                        if (i == 4)
                        {
                            SendReply(player, hunterMessage);
                            hunterMessage = string.Empty;
                        }
                    }
                    //foreach (PlayerData playerData in top10Hunters)
                       // hunterMessage += string.Format(msg("top_hunter_entry", player.userID), playerData.displayName, playerData.bountiesClaimed);

                    SendReply(player, hunterMessage);
                    return;
                case "wanted":
                    IEnumerable<PlayerData> top10Hunted = storedData.players.Values.OrderByDescending(x => x.totalWantedTime + x.GetCurrentWantedTime()).Take(10);
                    string wantedMessage = msg("top_wanted", player.userID);

                    for (int i = 0; i < top10Hunted.Count(); i++)
                    {
                        PlayerData playerData = top10Hunted.ElementAt(i);
                        wantedMessage += string.Format(msg("top_wanted_entry", player.userID), playerData.displayName, FormatTime(playerData.totalWantedTime + playerData.GetCurrentWantedTime()), playerData.totalBounties);

                        if (i == 3)
                        {
                            SendReply(player, wantedMessage);
                            wantedMessage = string.Empty;
                        }
                    }
                    //foreach (PlayerData playerData in top10Hunted)
                        //wantedMessage += string.Format(msg("top_wanted_entry", player.userID), playerData.displayName, FormatTime(playerData.totalWantedTime + playerData.GetCurrentWantedTime()), playerData.totalBounties);

                    SendReply(player, wantedMessage);
                    return;
                case "list":
                    List<string> items = new List<string>();
                    foreach (PlayerData playerData in storedData.players.Values.OrderByDescending(x => x.totalWantedTime + x.GetCurrentWantedTime()))
                    {
                        string str = $"<color=red>-- {playerData.displayName}</color>";
                        str += $"\n- Active Bounties: {playerData.activeBounties.Count} - Total Wanted Time {FormatTime(playerData.totalWantedTime + playerData.GetCurrentWantedTime())}";
                        int count = 1;
                        foreach(PlayerData.BountyInfo bountyInfo in playerData.activeBounties)
                        {
                            RewardInfo rewardInfo = storedData.rewards[bountyInfo.rewardId];
                            items = new List<string>(rewardInfo.rewardItems.Select(x => ItemManager.FindItemDefinition(x.itemid).displayName.english));
                            str += $"\n- {count} - RP: {rewardInfo.rpAmount} - Eco: {rewardInfo.econAmount} - Items: {items.ToSentence()}";
                            items.Clear();
                            count++;
                        }
                        SendEchoConsole(player.net.connection, str);
                    }
                    SendReply(player, msg("checkConsole", player.userID));
                    return;
                case "clear":
                    {
                        if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, "bounty.admin"))
                            return;

                        if (args.Length < 2)
                        {
                            SendReply(player, msg("invalid_syntax", player.userID));
                            return;
                        }

                        IPlayer targetPlayer = covalence.Players.FindPlayer(args[1]);
                        if (targetPlayer == null)
                        {
                            SendReply(player, msg("no_player_found", player.userID));
                            return;
                        }

                        PlayerData playerData;
                        if (!storedData.players.TryGetValue(ulong.Parse(targetPlayer.Id), out playerData) || playerData.activeBounties.Count == 0)
                        {
                            SendReply(player, msg("no_active_bounties", player.userID));
                            return;
                        }

                        foreach(PlayerData.BountyInfo bounty in playerData.activeBounties)                        
                            storedData.rewards.Remove(bounty.rewardId);
                        playerData.activeBounties.Clear();
                        
                        SendReply(player, string.Format(msg("bounties_cleared", player.userID), targetPlayer.Name));
                    }
                    return;
                default:
                    SendReply(player, msg("invalid_syntax", player.userID));
                    break;
            }            
        }   
        
        [ConsoleCommand("bounty")]
        private void ccmdBounty(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
                return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "bounty view <target name or ID> - View active bounties on the specified player");
                SendReply(arg, "bounty top - View the top 20 bounty hunters");
                SendReply(arg, "bounty wanted - View the top 20 most wanted players");
                SendReply(arg, "bounty clear <target name or ID> - Clear all active bounties on the specified player");
                SendReply(arg, "bounty list - List all active bounties to console");
                SendReply(arg, "bounty wipe - Wipe all bounty data");
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "view":
                    {
                        if (arg.Args.Length < 2)
                        {
                            SendReply(arg, "Invalid command syntax! Type 'bounty' to see available commands");
                            return;
                        }                        

                        IPlayer targetPlayer = covalence.Players.FindPlayer(arg.Args[1]);
                        if (targetPlayer == null)
                        {
                            SendReply(arg, "Unable to find a player with that name or ID");
                            return;
                        }

                        PlayerData playerData;
                        if (!storedData.players.TryGetValue(ulong.Parse(targetPlayer.Id), out playerData) || playerData.activeBounties.Count == 0)
                        {
                            SendReply(arg, "That player does not have any active bounties");
                            return;
                        }

                        SendReply(arg, string.Format("{0} has {1} active bounties", targetPlayer.Name, playerData.activeBounties.Count));
                        foreach (var bounty in playerData.activeBounties)
                        {
                            RewardInfo rewardInfo = storedData.rewards[bounty.rewardId];
                            string reward = string.Empty;
                            if (rewardInfo.rewardItems.Count > 1)
                            {
                                for (int i = 0; i < rewardInfo.rewardItems.Count; i++)
                                {
                                    RewardInfo.ItemData itemData = rewardInfo.rewardItems.ElementAt(i);
                                    reward += (string.Format("{0}x {1}", itemData.amount, idToDisplayName[itemData.itemid]) + (i < rewardInfo.rewardItems.Count - 1 ? ", " : ""));
                                }
                            }
                            else reward = rewardInfo.econAmount > 0 ? string.Format("{0} economics", rewardInfo.econAmount) : string.Format("{0} rp", rewardInfo.rpAmount);

                            SendReply(arg, string.Format("Placed by {0} {1} ago. Reward: {2}", bounty.initiatorName, FormatTime(CurrentTime() - bounty.initiatedTime), reward));
                        }
                    }
                    return;
                case "top":
                    IEnumerable<PlayerData> top20Hunters = storedData.players.Values.OrderByDescending(x => x.bountiesClaimed).Take(20);
                    string hunterMessage = "Top 20 Hunters:";

                    foreach (PlayerData playerData in top20Hunters)
                        hunterMessage += string.Format("\n{0} - {1} bounties collected", playerData.displayName, playerData.bountiesClaimed);

                    SendReply(arg, hunterMessage);
                    return;
                case "wanted":
                    IEnumerable<PlayerData> top20Hunted = storedData.players.Values.OrderByDescending(x => x.totalWantedTime + x.GetCurrentWantedTime()).Take(20);
                    string wantedMessage = "Top 20 Most Wanted:";

                    foreach (PlayerData playerData in top20Hunted)
                        wantedMessage += string.Format("\n{0} has all together been on the run for {1} with a total of {2} bounties", playerData.displayName, FormatTime(playerData.totalWantedTime + playerData.GetCurrentWantedTime()), playerData.totalBounties);

                    SendReply(arg, wantedMessage);
                    return;
                case "list":
                    List<string> items = new List<string>();
                    foreach (PlayerData playerData in storedData.players.Values.OrderByDescending(x => x.totalWantedTime + x.GetCurrentWantedTime()))
                    {
                        string str = $"-- {playerData.displayName}";
                        str += $"\n- Active Bounties: {playerData.activeBounties.Count} - Total Wanted Time {FormatTime(playerData.totalWantedTime + playerData.GetCurrentWantedTime())}";
                        int count = 1;
                        foreach (PlayerData.BountyInfo bountyInfo in playerData.activeBounties)
                        {
                            RewardInfo rewardInfo = storedData.rewards[bountyInfo.rewardId];
                            items = new List<string>(rewardInfo.rewardItems.Select(x => ItemManager.FindItemDefinition(x.itemid).displayName.english));
                            str += $"\n- {count} - RP: {rewardInfo.rpAmount} - Eco: {rewardInfo.econAmount} - Items: {items.ToSentence()}";
                            items.Clear();
                            count++;
                        }
                        Puts(str);
                    }
                    return;
                case "clear":
                    {
                        if (arg.Args.Length < 2)
                        {
                            SendReply(arg, "Invalid command syntax! Type 'bounty' to see available commands");
                            return;
                        }

                        IPlayer targetPlayer = covalence.Players.FindPlayer(arg.Args[1]);
                        if (targetPlayer == null)
                        {
                            SendReply(arg, "Unable to find a player with that name or ID");
                            return;
                        }

                        PlayerData playerData;
                        if (!storedData.players.TryGetValue(ulong.Parse(targetPlayer.Id), out playerData) || playerData.activeBounties.Count == 0)
                        {
                            SendReply(arg, "That player does not have any active bounties");
                            return;
                        }

                        foreach (var bounty in playerData.activeBounties)
                            storedData.rewards.Remove(bounty.rewardId);
                        playerData.activeBounties.Clear();

                        SendReply(arg, $"You have cleared all pending bounties from {targetPlayer.Name}");
                    }
                    return;
                case "wipe":
                    storedData.players.Clear();
                    storedData.rewards.Clear();
                    SaveData();
                    SendReply(arg, "All data has been wiped!");
                    return;
                default:
                    SendReply(arg, "Invalid command syntax! Type 'bounty' to see available commands");
                    break;
            }
        }

        private void SendEchoConsole(Network.Connection cn, string msg)
        {
            if (Net.sv.IsConnected())
            {
                NetWrite netWrite = Net.sv.StartWrite();
                netWrite.PacketID(Message.Type.ConsoleMessage);
                netWrite.String(msg);
                netWrite.Send(new SendInfo(cn));
            }
        }
        #endregion        

        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Ignore kills by clan members")]
            public bool IgnoreClans { get; set; }
            [JsonProperty(PropertyName = "Ignore kills by friends")]
            public bool IgnoreFriends { get; set; }
            [JsonProperty(PropertyName = "Notification Options")]
            public NotificationOptions Notifications { get; set; }
            [JsonProperty(PropertyName = "Reward Options")]
            public RewardOptions Rewards { get; set; }

            public class NotificationOptions
            {
                [JsonProperty(PropertyName = "PopupNotifications - Broadcast using PopupNotifications")]
                public bool UsePopupNotifications { get; set; }
                [JsonProperty(PropertyName = "PopupNotifications - Duration of notification")]
                public float PopupDuration { get; set; }
                [JsonProperty(PropertyName = "Broadcast new bounties globally")]
                public bool BroadcastNewBounties { get; set; }
                [JsonProperty(PropertyName = "Reminders - Remind targets they have a bounty on them")]
                public bool ShowReminders { get; set; }
                [JsonProperty(PropertyName = "Reminders - Amount of time between reminders (in minutes)")]
                public int ReminderTime { get; set; }
            }

            public class RewardOptions
            {
                [JsonProperty(PropertyName = "Allow bounties to be placed using Economics")]
                public bool AllowEconomics { get; set; }
                [JsonProperty(PropertyName = "Allow bounties to be placed using RP")]
                public bool AllowServerRewards { get; set; }
                [JsonProperty(PropertyName = "Allow bounties to be placed using items")]
                public bool AllowItems { get; set; }
            }
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                IgnoreClans = true,
                IgnoreFriends = true,
                Notifications = new ConfigData.NotificationOptions
                {
                    BroadcastNewBounties = true,
                    PopupDuration = 8f,
                    ReminderTime = 30,
                    ShowReminders = true,
                    UsePopupNotifications = false
                },
                Rewards = new ConfigData.RewardOptions
                {
                    AllowEconomics = true,
                    AllowItems = true,
                    AllowServerRewards = true
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();
            if (configData.Version < new Core.VersionNumber(0, 2, 0))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management        
        private void SaveData() => data.WriteObject(storedData);        
        
        private void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }

            if (storedData.players == null)
                storedData.players = new Dictionary<ulong, PlayerData>();

            if (storedData.rewards == null)
                storedData.rewards = new Dictionary<int, RewardInfo>();
        }
       
        private class StoredData
        {
            public Dictionary<ulong, PlayerData> players = new Dictionary<ulong, PlayerData>();
            public Dictionary<int, RewardInfo> rewards = new Dictionary<int, RewardInfo>();
        }

        private class PlayerData
        {
            public string displayName;
            public int totalBounties;
            public int bountiesClaimed;
            public double totalWantedTime;
            public List<BountyInfo> activeBounties = new List<BountyInfo>();
            public List<int> unclaimedRewards = new List<int>();

            public PlayerData() { }

            public PlayerData(string displayName)
            {
                this.displayName = displayName;
            }
            
            public void ClaimRewards(List<int> rewards)
            {
                foreach(int reward in rewards)
                {
                    unclaimedRewards.Add(reward);
                    bountiesClaimed++;
                }
            }

            public void UpdateWantedTime()
            {                
                totalWantedTime += GetCurrentWantedTime();
            }

            public double GetCurrentWantedTime()
            {
                double largestTime = 0;
                foreach (BountyInfo bountyInfo in activeBounties)
                {
                    double time = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds - bountyInfo.initiatedTime;
                    if (time > largestTime)
                        largestTime = time;
                }
                return largestTime;
            }

            public class BountyInfo
            {
                public ulong initiatorId;
                public string initiatorName;
                public double initiatedTime;
                public int rewardId;

                public BountyInfo() { }
                public BountyInfo(ulong initiatorId, string initiatorName, int rewardId)
                {
                    this.initiatorId = initiatorId;
                    this.initiatorName = initiatorName;
                    this.rewardId = rewardId;
                    this.initiatedTime = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
                }                
            }
        }

        private class RewardInfo
        {
            public int rpAmount;
            public int econAmount;
            public List<ItemData> rewardItems = new List<ItemData>();

            public RewardInfo() { }
            public RewardInfo(int rpAmount, int econAmount, ItemContainer container)
            {
                this.rpAmount = rpAmount;
                this.econAmount = econAmount;
                if (container != null)                
                    rewardItems = GetItems(container).ToList();                
            }

            private IEnumerable<ItemData> GetItems(ItemContainer container)
            {
                return container.itemList.Select(item => new ItemData
                {
                    itemid = item.info.itemid,
                    amount = item.amount,
                    ammo = (item.GetHeldEntity() as BaseProjectile)?.primaryMagazine.contents ?? 0,
                    ammotype = (item.GetHeldEntity() as BaseProjectile)?.primaryMagazine.ammoType.shortname ?? null,
                    skin = item.skin,
                    condition = item.condition,
                    instanceData = new ItemData.InstanceData(item),
                    contents = item.contents?.itemList.Select(item1 => new ItemData
                    {
                        itemid = item1.info.itemid,
                        amount = item1.amount,
                        condition = item1.condition
                    }).ToArray()
                });
            }

            public class ItemData
            {
                public int itemid;
                public ulong skin;
                public int amount;
                public float condition;
                public int ammo;
                public string ammotype;
                public InstanceData instanceData;
                public ItemData[] contents;

                public class InstanceData
                {
                    public int dataInt;
                    public int blueprintTarget;
                    public int blueprintAmount;

                    public InstanceData() { }
                    public InstanceData(Item item)
                    {
                        if (item.instanceData == null)
                            return;

                        dataInt = item.instanceData.dataInt;
                        blueprintAmount = item.instanceData.blueprintAmount;
                        blueprintTarget = item.instanceData.blueprintTarget;
                    }

                    public void Restore(Item item)
                    {
                        item.instanceData = new ProtoBuf.Item.InstanceData();
                        item.instanceData.blueprintAmount = blueprintAmount;
                        item.instanceData.blueprintTarget = blueprintTarget;
                        item.instanceData.dataInt = dataInt;
                    }
                }
            }
        }         
        #endregion

        #region Localization
        private string msg(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId == 0U ? null : playerId.ToString());

        Dictionary<string, string> messages = new Dictionary<string, string>
        {
            ["rewards_pending"] = "<color=#D3D3D3><color=#ce422b>{0}</color> had <color=#ce422b>{1}</color> outstanding bounties on them. You can claim your rewards by typing</color> <color=#ce422b>/bounty</color>",
            ["is_friend"] = "<color=#D3D3D3>You cannot claim a bounty on a friend or clan mate</color>",
            ["bounty_placed_target"] = "<color=#ce422b>{0} </color><color=#D3D3D3>has placed a bounty on you</color>",
            ["bounty_placed_initiator"] = "<color=#D3D3D3>You have successfully placed a bounty on</color> <color=#ce422b>{0}</color>",
            ["bounty_placed_global"] = "<color=#ce422b>{0}</color> <color=#D3D3D3>has placed a bounty on</color> <color=#ce422b>{1}</color>",
            ["no_bounty_placed"] = "<color=#D3D3D3>You do not have a bounty placed on </color> <color=#ce422b>{0}</color>",
            ["bounty_cancelled_target"] = "<color=#ce422b>{0} </color><color=#D3D3D3>has cancelled their bounty on you</color>",
            ["bounty_cancelled_initiator"] = "<color=#D3D3D3>You have cancelled the bounty on</color> <color=#ce422b>{0}</color>",
            ["no_permission"] = "<color=#D3D3D3>You do not have permission to use that command</color>",
            ["no_items_deposited"] = "<color=#D3D3D3>You did not place any items in the box</color>",
            ["invalid_syntax"] = "<color=#D3D3D3>Invalid command syntax! Type <color=#ce422b>/bounty</color> to see available commands</color>",
            ["help1"] = "<color=#ce422b>/bounty add items <target name or ID></color><color=#D3D3D3> - Create a new bounty using items as the reward</color>",
            ["help2"] = "<color=#ce422b>/bounty add rp <target name or ID> <amount></color><color=#D3D3D3> - Create a new bounty using RP as the reward</color>",
            ["help3.1"] = "<color=#ce422b>/bounty add eco <target name or ID> <amount></color><color=#D3D3D3> - Create a new bounty using Economics as the reward</color>",
            ["help4"] = "<color=#ce422b>/bounty cancel <target name or ID></color><color=#D3D3D3> - Cancel a bounty you placed on a player</color>",
            ["help5"] = "<color=#ce422b>/bounty claim</color><color=#D3D3D3> - Claim a outstanding reward</color>",
            ["help6"] = "<color=#ce422b>/bounty view <target name or ID></color><color=#D3D3D3> - View active bounties on on the target player</color>",
            ["help7"] = "<color=#ce422b>/bounty top</color><color=#D3D3D3> - List the top 10 bounty hunters</color>",
            ["help8"] = "<color=#ce422b>/bounty wanted</color><color=#D3D3D3> - List the top 10 most wanted players</color>",
            ["help11"] = "<color=#ce422b>/bounty list</color><color=#D3D3D3> - List all active bounties to console</color>",
            ["help9"] = "<color=#ce422b>/bounty clear <target name or ID></color><color=#D3D3D3> - Clear all bounties on the target player</color>",
            ["no_player_found"] = "<color=#D3D3D3>Unable to find a player with that name or ID</color>",
            ["multiple_players_found"] = "<color=#D3D3D3>Multiple players found with that name</color>",
            ["has_active_bounty"] = "<color=#D3D3D3>You already have a active bounty on that player</color>",
            ["no_value_entered"] = "<color=#D3D3D3>You must enter an amount</color>",
            ["not_enough_rp"] = "<color=#D3D3D3>You do not have enough RP to place this bounty</color>",
            ["not_enough_eco"] = "<color=#D3D3D3>You do not have enough money to place this bounty</color>",
            ["no_active_bounties"] = "<color=#D3D3D3>That player does not have any active bounties</color>",
            ["player_has_bounties"] = "<color=#D3D3D3><color=#ce422b>{0}</color> has <color=#ce422b>{1}</color> active bounties</color>",
            ["bounty_info"] = "<color=#D3D3D3>Placed by <color=#ce422b>{0} {1}</color> ago. Reward: </color><color=#ce422b>{2}</color>",
            ["reward_econ"] = "<color=#ce422b>{0}</color> <color=#D3D3D3>economics</color>",
            ["reward_rp"] = "<color=#ce422b>{0}</color> <color=#D3D3D3>rp</color>",
            ["reward_item"] = "<color=#D3D3D3>{0} x</color> <color=#ce422b>{1}</color>",
            ["help10"] = "<color=#ce422b>/bounty claim <ID></color><color=#D3D3D3> - Claim the reward for the bounty with the specified ID number</color>",
            ["no_rewards_pending"] = "<color=#D3D3D3>You do not have any outstanding rewards to be claimed</color>",
            ["reward_info"] = "<color=#D3D3D3>ID: <color=#ce422b>{0}</color> - Reward: </color><color=#ce422b>{1}</color>",
            ["top_hunters"] = "<color=#ce422b>Top 10 Hunters:</color>",
            ["top_hunter_entry"] = "<color=#D3D3D3>\n<color=#ce422b>{0}</color> - <color=#ce422b>{1}</color> bounties collected</color>",
            ["top_wanted"] = "<color=#ce422b>Top 10 Most Wanted:</color>",
            ["top_wanted_entry"] = "<color=#D3D3D3>\n<color=#ce422b>{0}</color> has all together been on the run for <color=#ce422b>{1}</color> with a total of <color=#ce422b>{2}</color> bounties</color>",
            ["cant_bounty_self"] = "<color=#D3D3D3>You can not place a bounty on yourself</color>",
            ["title"] = "<color=#ce422b>{0}  <color=#D3D3D3>v</color>{1}</color>",
            ["bounties_outstanding"] = "<color=#D3D3D3>You have <color=#ce422b>{0}</color> active bounties on you!</color>",
            ["bounties_cleared"] = "<color=#D3D3D3>You have cleared all pending bounties from </color><color=#ce422b>{0}</color>",
            ["reward_claimed"] = "<color=#D3D3D3>You have claimed your reward!</color>",
            ["checkConsole"] = "Check your F1 console for the current bounty list"
        };        
        #endregion

    }
}

// --- End of file: Bounty.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-grenades ---
// --- Original File Path: B/BetterGrenades/BetterGrenades.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Better Grenades", "redBDGR", "1.0.3")]
    [Description("Adds enhanced grenades features")]
    class BetterGrenades : RustPlugin
    {
        private bool Changed;
        private static BetterGrenades plugin;

        private Dictionary<string, float> throwerList = new Dictionary<string, float>();

        private float f1FuseTime = 10f;
        private float beancanFuseTime = 5f;

        #region Configuration

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            f1FuseTime = Convert.ToSingle(GetConfig("Settings", "F1 Grenade Fuse Time", 10f));
            beancanFuseTime = Convert.ToSingle(GetConfig("Settings", "Beancan Grenade Fuse Time", 5f));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            plugin = this;
            LoadVariables();

            foreach(BasePlayer player in BasePlayer.activePlayerList)
                if (player.IsConnected)
                    if (player.GetActiveItem()?.info.shortname == "grenade.f1" || player.GetActiveItem()?.info.shortname == "grenade.beancan")
                    {
                        GrenadeTimer grenadeTimer = player.GetComponent<GrenadeTimer>();
                        if (grenadeTimer)
                            grenadeTimer.DestroyThis();
                        player.gameObject.AddComponent<GrenadeTimer>();
                    }
        }

        private void Unload()
        {
            foreach(BasePlayer player in BasePlayer.activePlayerList)
                player.GetComponent<GrenadeTimer>()?.DestroyThis();
        }

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (!throwerList.ContainsKey(player.UserIDString))
                return;
            if (entity.ShortPrefabName != "grenade.f1.deployed" && entity.ShortPrefabName != "grenade.beancan.deployed")
                return;
            TimedExplosive expl = entity.GetComponent<TimedExplosive>();
            if (!expl) return;
            expl.CancelInvoke("Explode");
            expl.SetFuse(throwerList[player.UserIDString]);
        }

        private void OnExplosiveDropped(BasePlayer player, BaseEntity entity)
        {
            if (!throwerList.ContainsKey(player.UserIDString))
                return;
            if (entity.ShortPrefabName != "grenade.f1.deployed" && entity.ShortPrefabName != "grenade.beancan.deployed")
                return;
            TimedExplosive expl = entity.GetComponent<TimedExplosive>();
            if (!expl) return;
            expl.CancelInvoke("Explode");
            expl.SetFuse(throwerList[player.UserIDString]);
        }

        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (newItem != null)
                if (newItem.info.shortname == "grenade.f1" || newItem.info.shortname == "grenade.beancan")
                    player.gameObject.AddComponent<GrenadeTimer>();
            else if (oldItem != null)
                if (oldItem.info.shortname == "grenade.f1" || oldItem.info.shortname == "grenade.beancan")
                    player.GetComponent<GrenadeTimer>()?.DestroyThis();
        }

        #endregion

        #region MonoBehaviour Classes

        private class GrenadeTimer : MonoBehaviour
        {
            private BasePlayer player;
            private Item activeItem;

            private bool cookingGrenade;
            private float startTime;
            private float timeUntilGrenadeFire;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                activeItem = player.GetActiveItem();
            }

            private void Update()
            {
                if (!player)
                {
                    DestroyThis();
                    return;
                }
                Item latestItem = player.GetActiveItem();
                if (latestItem == null)
                {
                    DestroyThis();
                    return;
                }
                if (latestItem.info.shortname != "grenade.f1" || latestItem.info.shortname != "grenade.beancan")
                {
                    DestroyThis();
                    return;
                }
                if (player.serverInput.IsDown(BUTTON.FIRE_PRIMARY))
                {
                    if (!cookingGrenade)
                    {
                        cookingGrenade = true;
                        startTime = UnityEngine.Time.time;
                        timeUntilGrenadeFire = startTime + GetExplosionLength(activeItem);
                    }
                    if (UnityEngine.Time.time >= timeUntilGrenadeFire)
                        HandleSuicideExplosion(activeItem);
                }
                else
                {
                    if (!cookingGrenade)
                        return;
                    if (plugin.throwerList.ContainsKey(player.UserIDString))
                        plugin.throwerList.Remove(player.UserIDString);
                    plugin.throwerList.Add(player.UserIDString, timeUntilGrenadeFire - UnityEngine.Time.time);
                    cookingGrenade = false;
                }
            }

            private static float GetExplosionLength(Item item)
            {
                switch (item.info.shortname)
                {
                    case "grenade.f1":
                        return plugin.f1FuseTime;
                    case "grenade.beancan":
                        return plugin.beancanFuseTime;
                }
                return 10f;
            }

            private void HandleSuicideExplosion(Item item) // الله أكبر
            {
                player.inventory.containerBelt.Take(new List<Item>{ item }, item.info.itemid, 1);
                BaseEntity grenade = null;
                switch (item.info.shortname)
                {
                    case "grenade.f1":
                        grenade = GameManager.server.CreateEntity("assets/prefabs/weapons/f1 grenade/grenade.f1.deployed.prefab", player.transform.position + new Vector3(0, 1, 0));
                        break;
                    case "grenade.beancan":
                        grenade = GameManager.server.CreateEntity("assets/prefabs/weapons/beancan grenade/grenade.beancan.deployed.prefab", player.transform.position + new Vector3(0, 1, 0));
                        break;
                }
                if (grenade == null)
                    return;
                grenade.Spawn();
                TimedExplosive expl = grenade.GetComponent<TimedExplosive>();
                expl.Explode();
                cookingGrenade = false;
                if (!player.IsDead())
                    RemoveActiveItem(player);
                DestroyThis();
            }

            // Active item removal code courtesy of Fujikura
            private static void RemoveActiveItem(BasePlayer player)
            {
                foreach (var item in player.inventory.containerBelt.itemList.Where(x => x.IsValid() && x.GetHeldEntity()).ToList())
                {
                    var slot = item.position;
                    item.RemoveFromContainer();
                    item.MarkDirty();
                    plugin.timer.Once(0.15f, () =>
                    {
                        if (item == null)
                            return;
                        item.MoveToContainer(player.inventory.containerBelt, slot);
                        item.MarkDirty();
                    });
                }
            }

            public void DestroyThis() => Destroy(this);
        }

        #endregion

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (data.TryGetValue(datavalue, out value)) return value;
            value = defaultValue;
            data[datavalue] = value;
            Changed = true;
            return value;
        }
    }
}


// --- End of file: BetterGrenades.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/building-skins ---
// --- Original File Path: B/BuildingSkins/BuildingSkins.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Building Skins", "Marat", "2.0.10")]
    [Description("Automatic application of DLC skins for building blocks")]
    class BuildingSkins : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;

        #region Field

        private const string InitialLayer = "UI_BuildingLayer";
        private const string CupboardLayer = "UI_CupboardLayer";

        private const string permissionUse = "buildingskins.use";
        private const string permissionAll = "buildingskins.all";
        private const string permissionBuild = "buildingskins.build";
        private const string permissionTc = "buildingskins.tc";
        private const string permissionAdmin = "buildingskins.admin";

        private readonly Dictionary<ulong, Coroutine> runningCoroutines = new();
        private readonly Dictionary<BuildingGrade.Enum, List<ulong>> gradesSkin = new();

        private readonly Dictionary<uint, string> colors = new()
        {
            [1] = "0.38 0.56 0.74 1.0",
            [2] = "0.45 0.71 0.34 1.0",
            [3] = "0.57 0.29 0.83 1.0",
            [4] = "0.42 0.17 0.11 1.0",
            [5] = "0.82 0.46 0.13 1.0",
            [6] = "0.87 0.87 0.87 1.0",
            [7] = "0.20 0.20 0.18 1.0",
            [8] = "0.40 0.33 0.27 1.0",
            [9] = "0.20 0.22 0.34 1.0",
            [10] = "0.24 0.35 0.20 1.0",
            [11] = "0.73 0.30 0.18 1.0",
            [12] = "0.78 0.53 0.39 1.0",
            [13] = "0.84 0.66 0.22 1.0",
            [14] = "0.34 0.33 0.31 1.0",
            [15] = "0.21 0.34 0.37 1.0",
            [16] = "0.66 0.61 0.56 1.0"
        };

        #endregion

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            if (ImageLibrary == null)
            {
                PrintError("[ImageLibrary] not found! Plugin is disabled!");
                Interface.Oxide.UnloadPlugin(Title);
                return;
            }

            LoadData();
            AddCovalenceCommand(config.Commands, nameof(CmdChangeSkin));
            permission.RegisterPermission(permissionUse, this);
            permission.RegisterPermission(permissionAll, this);
            permission.RegisterPermission(permissionBuild, this);
            permission.RegisterPermission(permissionTc, this);
            permission.RegisterPermission(permissionAdmin, this);

            foreach (var list in config.BuildingImages)
            {
                var skinId = list.Value.Select(x => x.SkinId).ToList();
                gradesSkin.Add((BuildingGrade.Enum)(list.Key + 1), skinId);

                foreach (var info in list.Value.Where(x => !string.IsNullOrEmpty(x.Url)))
                {
                    ImageLibrary.Call("AddImage", info.Url, info.Title);
                    if (config.SeparatePermissions && info.SkinId != 0 && !string.IsNullOrEmpty(info.Title))
                    {
                        if (!permission.PermissionExists(info.Title))
                        {
                            permission.RegisterPermission($"buildingskins.{info.Title}".ToLower(), this);
                        }
                    }
                }
            }

            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }
        }

        private void Unload()
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                var player = BasePlayer.activePlayerList[i];
                CuiHelper.DestroyUi(player, InitialLayer);
                CuiHelper.DestroyUi(player, CupboardLayer);
                StopCoroutine(player);
            }
            SaveData();
            runningCoroutines.Clear();
            config = null;
        }

        private void OnServerSave() => SaveData();

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.IsConnected) return;
            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }
            StartCoroutine(player, PreloadImages(player));
            if (!storedData.PlayerData.TryGetValue(player.userID.Get(), out var data))
            {
                data = new Data
                {
                    ChangeHammer = true,
                    NeedsRepair = true,
                    EnableAnimation = true,
                    RandomColor = false,
                    Color = 9
                };
                storedData.PlayerData[player.userID] = data;
            }
            player.SetInfo("client.SelectedShippingContainerBlockColour", data.RandomColor ? data.Color.ToString() : player.GetInfoString("client.SelectedShippingContainerBlockColour", "0"));
        }

        private void OnPlayerDisconnected(BasePlayer player) => StopCoroutine(player);

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (player == null || !player.IsConnected) return;
            var data = storedData.PlayerData.TryGetValue(player.userID, out var playerData) ? playerData : null;
            if(data == null)
                player.SetInfo("client.SelectedShippingContainerBlockColour", player.GetInfoString("client.SelectedShippingContainerBlockColour", "0"));
            else
                player.SetInfo("client.SelectedShippingContainerBlockColour", data.RandomColor ? data.Color.ToString() : player.GetInfoString("client.SelectedShippingContainerBlockColour", "0"));
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null || info.HitEntity == null) return;
            if (!permission.UserHasPermission(player.UserIDString, permissionUse)) return;
            var block = info.HitEntity as BuildingBlock;
            if (block == null || !gradesSkin.TryGetValue(block.grade, out var skinId) || skinId == null) return;
            var skinID = GetPlayerSkinID(player, block.grade);
            var playerData = storedData.PlayerData[player.userID];
            if (block.SecondsSinceAttacked <= 30f) return;
            if (block.skinID != 0 && block.grade.ToString() == "Metal" && !playerData.RandomColor) block.SetCustomColour((uint)player.GetInfoInt("client.SelectedShippingContainerBlockColour", 0));
            if (block.skinID == skinID) return;
            if ((config.BuildingBlocked && !player.CanBuild() || block.OwnerID != player.userID) && !permission.UserHasPermission(player.UserIDString, permissionAdmin)) return;
            if (!playerData.ChangeHammer || block.health != block.MaxHealth() && !playerData.NeedsRepair) return;
            block.skinID = skinID;
            block.ChangeGradeAndSkin(block.grade, skinID, true, true);
            if (playerData.EnableAnimation) block.ClientRPC(null, "DoUpgradeEffect", (int)block.grade, skinID);
        }

        private object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade, ulong skin)
        {
            if (player == null || block == null) return null;
            if (!permission.UserHasPermission(player.UserIDString, permissionUse)) return null;
            if (skin != 0 && player.blueprints.steamInventory.HasItem((int)skin)) return null;
            if (!gradesSkin.TryGetValue(grade, out var skinId) || skinId == null) return null;
            var skinID = GetPlayerSkinID(player, grade);
            var playerData = storedData.PlayerData[player.userID];
            if (block.SecondsSinceAttacked <= 30f)
            {
                block.OnRepairFailed(player, string.Format("Unable to repair: Recently damaged. Repairable in: {0:N0}s.", 30f - block.SecondsSinceAttacked));
                return false;
            }
            if (block.skinID != 0 && grade.ToString() == "Metal" && !playerData.RandomColor) block.SetCustomColour((uint)player.GetInfoInt("client.SelectedShippingContainerBlockColour", 0));
            if (block.skinID == skinID && block.grade == grade) return false;
            NextTick(() =>
            {
                if (block == null || block.IsDestroyed) return;
                block.skinID = skinID;
                block.ChangeGradeAndSkin(block.grade, skinID, true, true);
                if (playerData.EnableAnimation) block.ClientRPC(null, "DoUpgradeEffect", (int)block.grade, skinID);
                ///for plugin BuildingGrades
                if (block.skinID != 0 && grade.ToString() == "Metal" && !playerData.RandomColor) block.SetCustomColour((uint)player.GetInfoInt("client.SelectedShippingContainerBlockColour", 0));
            });
            return null;
        }

        ///for plugin BuildingGrades
        private void OnStructureGradeUpdated(BuildingBlock block, BasePlayer player, BuildingGrade.Enum oldGrade, BuildingGrade.Enum newGrade)
        {
            OnStructureUpgrade(block, player, newGrade, block.skinID);
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity == null) return;
            var cupboard = entity.gameObject.GetComponent<BuildingPrivlidge>();
            if (cupboard == null || !permission.UserHasPermission(player.UserIDString, permissionTc)) return;
            if (config.ChangeSkinTC && cupboard.OwnerID != player.userID) return;
            TCupboardLayer(player);
        }

        private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (player == null || entity == null) return;
            if (entity is BuildingPrivlidge)
            {
                CuiHelper.DestroyUi(player, CupboardLayer);
            }
        }

        #endregion

        #region Configuration

        private static PluginConfig config;

        private class PluginConfig
        {
            [JsonProperty("Building skin change commands")] public string[] Commands;
            [JsonProperty("Block building skin in building blocked")] public bool BuildingBlocked;
            [JsonProperty("Changing skin from tool cupboard only by owner")] public bool ChangeSkinTC;
            [JsonProperty("Number of blocks updated per tick")] public int UpdatesPerTick;
            [JsonProperty("Use separate permissions for skins")] public bool SeparatePermissions;
            [JsonProperty("Image and description settings")] public Dictionary<int, List<BlockInfo>> BuildingImages;
            public Oxide.Core.VersionNumber Version;
        }

        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig
            {
                Commands = new string[] { "bskin", "building.skin" },
                BuildingBlocked = true,
                ChangeSkinTC = true,
                UpdatesPerTick = 5,
                SeparatePermissions = false,
                BuildingImages = new Dictionary<int, List<BlockInfo>>
                {
                    [0] = new List<BlockInfo>
                    {
                        new("Wood", "https://i.ibb.co/yqsWpbp/wood.png", 0),
                        new("Frontier", "https://i.ibb.co/b2bZFXj/frontier.png", 10232),
                        new("Gingerbread", "https://i.ibb.co/Tw67yBM/gingerbread.png", 2)
                    },
                    [1] = new List<BlockInfo>
                    {
                        new("Stone", "https://i.ibb.co/jw9FJFP/stone.png", 0),
                        new("Adobe", "https://i.ibb.co/Ky1MBJ7/adobe.png", 10220),
                        new("Brick", "https://i.ibb.co/vjqh3Hj/brick.png", 10223),
                        new("Brutalist", "https://i.ibb.co/86bpvS2/brutalist.png", 10225)
                    },
                    [2] = new List<BlockInfo>
                    {
                        new("Metal", "https://i.ibb.co/M9RPSZ2/metal.png", 0),
                        new("Container", "https://i.ibb.co/YWzfwS4/container.png", 10221)
                    },
                    [3] = new List<BlockInfo>
                    {
                        new("TopTier", "https://i.ibb.co/T0Nwfvp/toptire.png", 0)
                    }
                },
                Version = Version
            };
        }

        private class BlockInfo
        {
            public string Title;
            public string Url;
            public ulong SkinId;

            public BlockInfo(string title, string url, ulong skinId)
            {
                Title = title;
                Url = url;
                SkinId = skinId;
            }
        }

        protected override void SaveConfig() => Config.WriteObject(config);
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<PluginConfig>();
                if (config == null) LoadDefaultConfig();
                if (config.Version < Version)
                {
                    PrintWarning("Config update detected! Updating config values...");
                    if (config.Version < new Core.VersionNumber(2, 0, 0))
                    {
                        LoadDefaultConfig();
                    }
                    if (config.Version < new Core.VersionNumber(2, 0, 3))
                    {
                        if (config.BuildingImages[0][3].SkinId == 10225)
                        {
                            config.BuildingImages[0][3].SkinId = 3;
                        }
                    }
                    if (config.Version < new Core.VersionNumber(2, 0, 4))
                    {
                        config.ChangeSkinTC = true;
                    }
                    config.Version = Version;
                    PrintWarning("Config update completed!");
                }
            }
            catch
            {
                PrintWarning("The config file contains an error and has been replaced with the default config.");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        #endregion

        #region Commands

        [ConsoleCommand("UI_BuildingController")]
        private void CmdConsoleHandler(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || !arg.HasArgs(1)) return;
            var playerData = storedData.PlayerData[player.userID];
            SoundEffect(player, "assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab");

            int index, skinIndex;
            switch (arg.Args[0].ToLower())
            {
                case "open":
                    {
                        InitializeLayers(player, true);
                        break;
                    }
                case "build":
                    {
                        var blocks = player.GetBuildingPrivilege().GetBuilding()?.buildingBlocks.ToArray();
                        if (blocks == null) return;
                        PrintToChat(player, GetMessage("Lang_UpdateBuilding", player));
                        StartCoroutine(player, UpgradeSkin(player, blocks));
                        TCupboardLayer(player);
                        SoundEffect(player, "assets/prefabs/deployable/repair bench/effects/skinchange_spraypaint.prefab");
                        break;
                    }
                case "change":
                    {
                        if (!int.TryParse(arg.Args[1], out index) || !int.TryParse(arg.Args[2], out skinIndex)) return;
                        ImageLayers(player, index, skinIndex);
                        break;
                    }
                case "choose":
                    {
                        if (!int.TryParse(arg.Args[1], out index) || !int.TryParse(arg.Args[2], out skinIndex)) return;
                        var grades = gradesSkin.ElementAt(index);
                        playerData.GetType().GetField(grades.Key.ToString())?.SetValue(playerData, grades.Value[skinIndex]);
                        ImageLayers(player, index, skinIndex);
                        SoundEffect(player, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
                        break;
                    }
                case "settings":
                    {
                        SettingsLayer(player);
                        break;
                    }
                case "colors":
                    {
                        if (!int.TryParse(arg.Args[1], out index)) return;
                        ColorLayer(player, index);
                        break;
                    }
                case "setcolor":
                    {
                        if (!int.TryParse(arg.Args[1], out index) || !uint.TryParse(arg.Args[2], out uint colorId)) return;
                        player.SetInfo("client.SelectedShippingContainerBlockColour", colorId.ToString());
                        playerData.Color = colorId;
                        ColorLayer(player, index);
                        SoundEffect(player, "assets/prefabs/deployable/repair bench/effects/skinchange_spraypaint.prefab");
                        break;
                    }
                case "randomcolor":
                    {
                        if (!int.TryParse(arg.Args[1], out index)) return;
                        var randomColor = !playerData.RandomColor;
                        playerData.RandomColor = randomColor;
                        player.SetInfo("client.SelectedShippingContainerBlockColour", randomColor ? "0" : playerData.Color.ToString());
                        ColorLayer(player, index);
                        break;
                    }
                case "hammer":
                    {
                        var changeHammer = !playerData.ChangeHammer;
                        playerData.ChangeHammer = changeHammer;
                        SettingsLayer(player);
                        break;
                    }
                case "repair":
                    {
                        var needsRepair = !playerData.NeedsRepair;
                        playerData.NeedsRepair = needsRepair;
                        SettingsLayer(player);
                        break;
                    }
                case "animation":
                    {
                        var enableAnimation = !playerData.EnableAnimation;
                        playerData.EnableAnimation = enableAnimation;
                        SettingsLayer(player);
                        break;
                    }
            }
        }

        private void CmdChangeSkin(IPlayer ipPlayer, string command, string[] arg)
        {
            var player = ipPlayer?.Object as BasePlayer;
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, permissionUse))
            {
                PrintToChat(player, GetMessage("Lang_NoPermissions", player));
                return;
            }
            if (arg.Length == 0)
            {
                InitializeLayers(player, true);
                return;
            }
            if (runningCoroutines.ContainsKey(player.userID))
            {
                PrintToChat(player, GetMessage("Lang_UpdateProgress", player));
                return;
            }
            if (arg.Length > 0 && config.BuildingBlocked && !player.CanBuild() && !permission.UserHasPermission(player.UserIDString, permissionAdmin))
            {
                PrintToChat(player, GetMessage("Lang_BuildingBlocked", player));
                return;
            }
            switch (arg[0].ToLower())
            {
                case "build":
                    {
                        if (!permission.UserHasPermission(player.UserIDString, permissionBuild))
                        {
                            PrintToChat(player, GetMessage("Lang_NoPermissions", player));
                            return;
                        }
                        var entity = GetLookEntity(player);
                        if (entity == null)
                        {
                            PrintToChat(player, GetMessage("Lang_NotFoundBuilding", player));
                            return;
                        }
                        if (entity.OwnerID != player.userID && !permission.UserHasPermission(player.UserIDString, permissionAdmin))
                        {
                            PrintToChat(player, GetMessage("Lang_NotOwnerBuilding", player));
                            return;
                        }
                        var blocks = entity.GetBuilding()?.buildingBlocks.ToArray();
                        if (blocks == null) return;
                        PrintToChat(player, GetMessage("Lang_UpdateBuilding", player));
                        StartCoroutine(player, UpgradeSkin(player, blocks));
                        break;
                    }
                case "all":
                    {
                        if (!permission.UserHasPermission(player.UserIDString, permissionAll))
                        {
                            PrintToChat(player, GetMessage("Lang_NoPermissions", player));
                            return;
                        }
                        if (arg.Length > 1 && !ulong.TryParse(arg[1], out var owner))
                        {
                            PrintToChat(player, GetMessage("Lang_NotFoundPlayer", player));
                            return;
                        }
                        var targetOwner = arg.Length > 1 ? ulong.Parse(arg[1]) : player.userID.Get();
                        if (!permission.UserHasPermission(player.UserIDString, permissionAdmin) && targetOwner != player.userID)
                        {
                            PrintToChat(player, GetMessage("Lang_NoPermissions", player));
                            return;
                        }
                        var blockOwner = BaseNetworkable.serverEntities.OfType<BuildingBlock>().Where(x => x.OwnerID == targetOwner).ToArray();
                        if (blockOwner.Length == 0)
                        {
                            PrintToChat(player, GetMessage("Lang_NotFoundBlocks", player));
                            return;
                        }
                        PrintToChat(player, GetMessage(targetOwner != player.userID.Get() ? "Lang_UpdateAllTarget" : "Lang_UpdateAll", player));
                        StartCoroutine(player, UpgradeSkin(player, blockOwner));
                        break;
                    }
            }
        }

        #endregion

        #region Methods

        private void StartCoroutine(BasePlayer player, IEnumerator routine)
        {
            if (runningCoroutines.ContainsKey(player.userID.Get())) return;
            var coroutine = ServerMgr.Instance?.StartCoroutine(routine);
            if (coroutine != null) runningCoroutines[player.userID.Get()] = coroutine;
        }

        private void StopCoroutine(BasePlayer player)
        {
            if (!runningCoroutines.ContainsKey(player.userID.Get())) return;
            var coroutine = runningCoroutines[player.userID.Get()];
            if (coroutine != null) ServerMgr.Instance?.StopCoroutine(coroutine);
            runningCoroutines.Remove(player.userID.Get());
            var entity = player?.inventory?.loot?.entitySource;
            if (entity == null || !permission.UserHasPermission(player.UserIDString, permissionTc)) return;
            if (entity is BuildingPrivlidge)
            {
                if (config.ChangeSkinTC && entity.OwnerID != player.userID.Get()) return;
                TCupboardLayer(player);
            }
        }

        private IEnumerator UpgradeSkin(BasePlayer player, BuildingBlock[] blocks)
        {
            var count = 0;
            for (int i = 0; i < blocks.Length; i++)
            {
                var block = blocks[i];
                if (block == null || block.IsDestroyed) continue;
                if (!gradesSkin.TryGetValue(block.grade, out var skinId) || skinId == null) continue;
                var skinID = GetPlayerSkinID(player, block.grade);
                var playerData = storedData.PlayerData[player.userID.Get()];
                if (skinID != 0 && player.blueprints.steamInventory.HasItem((int)skinID)) continue;
                if (block.SecondsSinceAttacked < 30f) continue;
                if (block.skinID != 0 && block.grade.ToString() == "Metal" && !playerData.RandomColor) block.SetCustomColour((uint)player.GetInfoInt("client.SelectedShippingContainerBlockColour", 0));
                if (block.skinID == skinID) continue;
                block.skinID = skinID;
                block.ChangeGradeAndSkin(block.grade, skinID, true, true);
                count++;
                if (i % config.UpdatesPerTick == 0)
                    yield return CoroutineEx.waitForFixedUpdate;
            }
            if (count == 0) PrintToChat(player, GetMessage("Lang_UpdateNotRequired", player));
            else PrintToChat(player, GetMessage("Lang_UpdateCompleted", player), count, blocks.Length);
            StopCoroutine(player);
        }

        private bool HasPermission(BasePlayer player, string name)
        {
            foreach (var blockInfoList in config.BuildingImages.Values)
            {
                foreach (var blockInfo in blockInfoList)
                {
                    if (blockInfo.Title == name && permission.UserHasPermission(player.UserIDString, $"buildingskins.{blockInfo.Title}".ToLower()))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        private ulong GetPlayerSkinID(BasePlayer player, BuildingGrade.Enum grade)
        {
            var playerData = storedData.PlayerData.TryGetValue(player.userID.Get(), out var data) ? data : null;
            return (ulong)(playerData?.GetType().GetField(grade.ToString()).GetValue(playerData) ?? 0);
        }

        private BuildingBlock GetLookEntity(BasePlayer player)
        {
            return Physics.Raycast(player.eyes.HeadRay(), out RaycastHit raycastHit, 4f, Rust.Layers.Mask.Construction) ? raycastHit.GetEntity() as BuildingBlock : null;
        }

        private static void SoundEffect(BasePlayer player, string effect = null)
        {
            EffectNetwork.Send(new Effect(effect, player, 0, new Vector3(), new Vector3()), player.Connection);
        }

        private string GetMessage(string key, BasePlayer player)
        {
            return lang.GetMessage(key, this, player.UserIDString);
        }

        #endregion

        #region Interfaces

        private void InitializeLayers(BasePlayer player, bool update)
        {
            float fade = !update ? 0f : 0.25f;
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiElement()
            {
                Parent = "Overlay",
                Name = InitialLayer,
                DestroyUi = InitialLayer,
                Components =
                {
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                    new CuiImageComponent { Color = "0.235 0.227 0.2 0.9" },
                    new CuiNeedsCursorComponent()
                }
            });

            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                Button = { Close = InitialLayer, Color = "0.141 0.137 0.096 0.98", Sprite = "assets/content/ui/ui.background.transparent.radial.psd" }
            }, InitialLayer);

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-250 -320", OffsetMax = $"250 300" },
                Image = { Color = "0.117 0.121 0.109 0.8", Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = fade }
            }, InitialLayer, InitialLayer + ".Main");

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "30 -60", OffsetMax = "-30 -2" },
                Text = { Text = GetMessage("Lang_InterfaceTitle", player).ToUpper(), Color = "0.78 0.74 0.70 1.0", FontSize = 20, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = fade }
            }, InitialLayer + ".Main");

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 5", OffsetMax = "0 25" },
                Text = { Text = $"• {GetMessage("Lang_InterfaceDescr", player)}".ToUpper(), Color = "0.78 0.74 0.70 0.6", FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = fade }
            }, InitialLayer + ".Main");

            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-25 -25", OffsetMax = "-5 -5" },
                Button = { Close = InitialLayer, Color = "0.71 0.22 0.15 1.0", Sprite = "assets/icons/close.png" }
            }, InitialLayer + ".Main");

            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "5 -25", OffsetMax = "25 -5" },
                Button = { Command = $"UI_BuildingController settings", Color = "0.31 0.64 0.89 0.5", Sprite = "assets/icons/gear.png" }
            }, InitialLayer + ".Main", InitialLayer + ".Settings");

            CuiHelper.AddUi(player, container);

            for (var i = 0; i < config.BuildingImages.Count; i++)
            {
                var grades = gradesSkin.ElementAt(i);
                var skinID = GetPlayerSkinID(player, grades.Key);
                var skinIndex = grades.Value.IndexOf(skinID);
                ImageLayers(player, i, skinIndex);
            }
        }

        private void ImageLayers(BasePlayer player, int index, int skinIndex)
        {
            var playerData = storedData.PlayerData[player.userID.Get()];
            var listIndex = config.BuildingImages[index];
            var nextIndex = (skinIndex + 1) % listIndex.Count;
            var grades = gradesSkin.ElementAt(index);
            var skinID = GetPlayerSkinID(player, grades.Key);
            var selected = listIndex[skinIndex].SkinId == skinID;
            var hasSkin = listIndex.Any(x => !string.IsNullOrEmpty(x.Url) && x.SkinId != 0);
            var hasPermission = HasPermission(player, listIndex[skinIndex].Title);
            var isBlocked = config.SeparatePermissions && !hasPermission && skinIndex != 0;

            if (isBlocked && selected)
            {
                playerData.GetType().GetField(grades.Key.ToString())?.SetValue(playerData, grades.Value[0]);
                ImageLayers(player, index, 0);
                return;
            }

            const int marginTop = 10, margin = 6, width = 200, height = 250;
            var offsetX = (index % 2 == 0 ? -1 : 1) * ((width + margin) / 2 + margin);
            var offsetY = (index < 2 ? 1 : -1) * ((height + margin) / 2 + margin) - marginTop;

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{offsetX - width / 2} {offsetY - height / 2}", OffsetMax = $"{offsetX + width / 2} {offsetY + height / 2}" },
                Button = { Command = hasSkin ? $"UI_BuildingController change {index} {nextIndex}" : "", Color = "0.22 0.25 0.16 0.9", Material = "assets/content/ui/uibackgroundblur.mat" },
            }, InitialLayer + ".Main", InitialLayer + $".Button.{index}");

            container.Add(new CuiElement()
            {
                Parent = InitialLayer + $".Button.{index}",
                Name = InitialLayer + $".Image.{index}",
                DestroyUi = InitialLayer + $".Image.{index}",
                Components =
                {
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-85 -72", OffsetMax = "85 98" },
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", listIndex[skinIndex].Title), Color = hasSkin && !isBlocked ? "1 1 1 1" : "0.8 0.8 0.8 0.5" }
                }
            });

            if (hasSkin)
            {
                container.Add(new CuiPanel()
                {
                    RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-28 -28", OffsetMax = "-5 -5" },
                    Image = { Color = "0.81 0.77 0.74 0.8", Sprite = "assets/icons/refresh.png" }
                }, InitialLayer + $".Button.{index}");
            }
            if (!hasSkin || isBlocked)
            {
                container.Add(new CuiPanel()
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-22 -30", OffsetMax = "22 30" },
                    Image = { Color = "0.81 0.77 0.74 0.8", Sprite = "assets/content/ui/lock@4x.png" }
                }, InitialLayer + $".Image.{index}");
            }

            if (grades.Key.ToString() == "Metal" && !isBlocked)
            {
                if (skinIndex != 0)
                {
                    var colorIcon = colors.TryGetValue((uint)player.GetInfoInt("client.SelectedShippingContainerBlockColour", 0), out var value) ? value : "0.20 0.30 0.40 1.0";

                    container.Add(new CuiButton()
                    {
                        RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "5 -28", OffsetMax = "28 -5" },
                        Button = { Command = $"UI_BuildingController colors {index}", Color = colorIcon, Sprite = "assets/icons/circle_closed.png" }
                    }, InitialLayer + $".Button.{index}", InitialLayer + ".Color");

                    container.Add(new CuiPanel()
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-2 -2", OffsetMax = "2 2" },
                        Image = { Color = "0.81 0.77 0.74 1.0", Sprite = "assets/icons/workshop.png" }
                    }, InitialLayer + ".Color");
                }
                else CuiHelper.DestroyUi(player, InitialLayer + ".Color");
            }

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 26" },
                Image = { Color = "0 0 0 0.5" }
            }, InitialLayer + $".Button.{index}", InitialLayer + $".Title.{index}");

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "10 0", OffsetMax = "125 26" },
                Text = { Text = GetMessage(listIndex[skinIndex].Title, player).ToUpper(), Color = "0.81 0.77 0.74 1.0", FontSize = 11, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, InitialLayer + $".Title.{index}");

            var textTitle = GetMessage(selected ? "Lang_SkinInstalled" : (isBlocked ? "Lang_Unavailable" : "Lang_InterfaceApply"), player);
            var colorTitle = selected ? "0.59 0.84 0.18 1.0" : isBlocked ? "0.81 0.77 0.74 1.0" : "0.30 0.65 0.90 1.0";
            var colorButton = selected ? "0.30 0.36 0.16 1.0" : isBlocked ? "0.34 0.33 0.31 1.0" : "0.20 0.30 0.40 1.0";

            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-75 0", OffsetMax = "0 26" },
                Button = { Command = hasSkin && !isBlocked && !selected ? $"UI_BuildingController choose {index} {skinIndex}" : "", Color = colorButton, Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { Text = textTitle.ToUpper(), Color = colorTitle, FontSize = 11, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, InitialLayer + $".Title.{index}");

            CuiHelper.AddUi(player, container);
        }

        private void SettingsLayer(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiElement()
            {
                Parent = InitialLayer + ".Settings",
                Name = InitialLayer + ".SettingsMenu",
                DestroyUi = InitialLayer + ".SettingsMenu",
                Components =
                {
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-350 -5", OffsetMax = "5 5" },
                    new CuiImageComponent { Color = "0.20 0.30 0.40 1.0", Material = "assets/content/ui/uibackgroundblur.mat" }
                }
            });

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 0", OffsetMax = "0 0" },
                Text = { Text = GetMessage("Lang_MenuSettings", player).ToUpper(), Color = "0.78 0.74 0.70 1.0", FontSize = 20, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, InitialLayer + ".SettingsMenu");

            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-25 -25", OffsetMax = "-5 -5" },
                Button = { Close = InitialLayer + ".SettingsMenu", Color = "0.71 0.22 0.15 1.0", Sprite = "assets/icons/close.png" }
            }, InitialLayer + ".SettingsMenu");

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "2 -150", OffsetMax = "-35 0" },
                Image = { Color = "0.117 0.121 0.109 0.8", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, InitialLayer + ".SettingsMenu", InitialLayer + ".SettingsButton");

            string[] langKeys = { "Lang_ChangeHammer", "Lang_NeedsRepair", "Lang_EnableAnimation" };
            string[] commands = { "UI_BuildingController hammer", "UI_BuildingController repair", "UI_BuildingController animation" };
            var playerData = storedData.PlayerData[player.userID.Get()];
            var margin = 0;

            for (var i = 0; i < 3; i++)
            {
                var active = new[] { playerData.ChangeHammer, playerData.ChangeHammer && playerData.NeedsRepair, playerData.EnableAnimation }[i];
                var text = GetMessage($"Lang_Setting{(active ? "Enable" : "Disable")}", player);
                var textlang = GetMessage(langKeys[i], player);

                container.Add(new CuiButton()
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"10 {-50 - margin}", OffsetMax = $"-10 {-15 - margin}" },
                    Button = { Command = commands[i], Color = "0.34 0.33 0.31 1.0", Material = "assets/content/ui/uibackgroundblur.mat" },
                }, InitialLayer + ".SettingsButton", InitialLayer + $".SettingsButton.{i}");

                container.Add(new CuiPanel()
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMin = "0 0", OffsetMax = "50 0" },
                    Image = { Color = active ? "0.36 0.44 0.22 1.0" : "0.71 0.22 0.15 1.0", Material = "assets/content/ui/uibackgroundblur.mat" },
                }, InitialLayer + $".SettingsButton.{i}", InitialLayer + $".TextButton");

                container.Add(new CuiLabel()
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                    Text = { Text = text.ToUpper(), Color = active ? "0.78 0.74 0.70 1.0" : "0.78 0.74 0.70 0.6", FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, InitialLayer + $".TextButton");

                container.Add(new CuiLabel()
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "60 0", OffsetMax = "-5 0" },
                    Text = { Text = textlang.ToUpper(), Color = "0.78 0.74 0.70 1.0", FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                }, InitialLayer + $".SettingsButton.{i}");

                margin += 45;
            }

            CuiHelper.AddUi(player, container);
        }

        private void ColorLayer(BasePlayer player, int index)
        {
            var playerData = storedData.PlayerData[player.userID.Get()];
            var playerColor = (uint)player.GetInfoInt("client.SelectedShippingContainerBlockColour", 0);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiElement()
            {
                Parent = InitialLayer + ".Color",
                Name = InitialLayer + ".SetColor",
                DestroyUi = InitialLayer + ".SetColor",
                Components =
                {
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-250 -5", OffsetMax = "5 5" },
                    new CuiImageComponent { Color = colors.TryGetValue(playerColor, out var value) ? value : "0.20 0.30 0.40 1.0", Material = "assets/content/ui/uibackgroundblur.mat" }
                }
            });

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 0", OffsetMax = "0 0" },
                Text = { Text = GetMessage("Lang_ColorSettings", player).ToUpper(), Color = "0.78 0.74 0.70 1.0", FontSize = 20, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, InitialLayer + ".SetColor");

            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-25 -25", OffsetMax = "-5 -5" },
                Button = { Close = InitialLayer + ".SetColor", Color = "0.71 0.22 0.15 1.0", Sprite = "assets/icons/close.png" }
            }, InitialLayer + ".SetColor");

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = $"2 {(playerData.RandomColor ? -42 : -228)}", OffsetMax = "-80 0" },
                Image = { Color = "0.117 0.121 0.109 0.8", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, InitialLayer + ".SetColor", InitialLayer + ".ColorButton");

            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-89 -35", OffsetMax = "89 -6" },
                Button = { Command = $"UI_BuildingController randomcolor {index}", Color = "0.34 0.33 0.31 1.0", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, InitialLayer + ".ColorButton", InitialLayer + ".RandomButton");

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0.25 0", AnchorMax = "0.9 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                Text = { Text = GetMessage("Lang_Randomcolor", player).ToUpper(), Color = "0.78 0.74 0.70 1.0", FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, InitialLayer + ".RandomButton");

            var sprite = playerData.RandomColor ? "assets/icons/circle_closed.png" : "assets/icons/circle_open.png";

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMin = "23 5", OffsetMax = "42 -5" },
                Image = { Color = "0.85 0.85 0.85 0.8", Sprite = sprite }
            }, InitialLayer + ".RandomButton", InitialLayer + ".Panel");

            if (playerData.RandomColor)
            {
                container.Add(new CuiPanel()
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "3 3", OffsetMax = "-3 -3" },
                    Image = { Color = "0 0 0 1", Sprite = "assets/icons/check.png" }
                }, InitialLayer + ".Panel");
            }
            else
            {
                const int marginTop = 2, margin = 6, width = 40, height = 40;

                for (var i = 0; i < colors.Count; i++)
                {
                    var colorIndex = colors.ElementAt(i).Key;
                    var colorValue = colors.ElementAt(i).Value;
                    var offsetX = i % 4 * (width + margin) - (2 * width + 1.5 * margin);
                    var offsetY = -i / 4 * (height + margin) + 35 - marginTop;

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{offsetX} {offsetY}", OffsetMax = $"{offsetX + width} {offsetY + height}" },
                        Button = { Command = colorIndex != playerColor ? $"UI_BuildingController setcolor {index} {colorIndex}" : "", Color = colorValue, Material = "assets/content/ui/uibackgroundblur.mat" }
                    }, InitialLayer + ".ColorButton", InitialLayer + ".PanelButton");

                    if (colorIndex == playerColor)
                    {
                        container.Add(new CuiPanel()
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                            Image = { Color = "0.59 0.84 0.18 1.0", Sprite = "assets/icons/vote_up.png" }
                        }, InitialLayer + ".PanelButton");
                    }
                }
            }

            CuiHelper.AddUi(player, container);
        }

        private void TCupboardLayer(BasePlayer player)
        {
            var isRunning = runningCoroutines.ContainsKey(player.userID.Get());
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiElement()
            {
                Parent = "Overlay",
                Name = CupboardLayer,
                DestroyUi = CupboardLayer,
                Components =
                {
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.0", AnchorMax = "0.5 0.0", OffsetMin = "400 595", OffsetMax = "572 616" },
                    new CuiImageComponent { Color = isRunning ? "0.90 0.53 0.05 1.0" : "0.40 0.50 0.20 1.0", Material = "assets/content/ui/uibackgroundblur.mat" }
                }
            });

            var text = GetMessage(isRunning ? "Lang_TcWait" : "Lang_TcChangeSkin", player);
            var color = isRunning ? "1 1 1 1" : "0.70 0.90 0.45 1.0";
            var sprite = isRunning ? "assets/icons/refresh.png" : "assets/icons/brush.png";

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "22 0", OffsetMax = "0 0" },
                Button = { Command = !isRunning ? "UI_BuildingController build" : "", Color = "0 0 0 0" },
                Text = { Text = text.ToUpper(), Color = color, FontSize = 11, Align = TextAnchor.MiddleCenter }
            }, CupboardLayer, CupboardLayer + ".Button");

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMin = "4 2", OffsetMax = "22 -2" },
                Image = { Color = "1 1 1 1", Sprite = sprite }
            }, CupboardLayer);

            if (!isRunning)
            {
                container.Add(new CuiButton()
                {
                    RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "5 -20", OffsetMax = "25 0" },
                    Button = { Command = $"UI_BuildingController open", Color = "0.31 0.64 0.89 0.5", Sprite = "assets/icons/gear.png" }
                }, CupboardLayer);
            }

            CuiHelper.AddUi(player, container);
        }

        private IEnumerator PreloadImages(BasePlayer player)
        {
            if (player == null || !player.IsConnected) yield break;
            for (var i = 0; i < config.BuildingImages.Count; i++)
            {
                CuiElementContainer temp = new CuiElementContainer();

                foreach (var blockInfo in config.BuildingImages[i])
                {
                    if (string.IsNullOrEmpty(blockInfo.Url)) continue;
                    temp.Add(new CuiElement()
                    {
                        Parent = "Hud",
                        Name = $".{i}",
                        DestroyUi = $".{i}",
                        Components =
                        {
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0 0" },
                            new CuiRawImageComponent { Png = (string) ImageLibrary?.Call("GetImage", blockInfo.Title) }
                        }
                    });
                    CuiHelper.AddUi(player, temp);
                    yield return new WaitForSeconds(1.0f);
                    CuiHelper.DestroyUi(player, $".{i}");
                }
            }
            StopCoroutine(player);
        }

        #endregion

        #region Language

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Lang_UpdateAll"] = "Skin update for all your buildings has started...",
                ["Lang_UpdateBuilding"] = "Skin update for selected building has started...",
                ["Lang_UpdateAllTarget"] = "Skin update for all players buildings has started...",
                ["Lang_UpdateProgress"] = "Please wait for the building skin update to finish.",
                ["Lang_UpdateCompleted"] = "Building skin update completed.\nUpdated {0} of {1} building blocks.",
                ["Lang_UpdateNotRequired"] = "All building blocks already have your chosen skin.",
                ["Lang_NotFoundBlocks"] = "No available buildings found for the selected player.",
                ["Lang_NotFoundPlayer"] = "Player not found. Use only the Steam Id of the player.",
                ["Lang_NotFoundBuilding"] = "Building not found. Get closer to the building and repeat again.",
                ["Lang_NotOwnerBuilding"] = "You are not the owner of this building.",
                ["Lang_BuildingBlocked"] = "You can't use this command if the building is blocked.",
                ["Lang_NoPermissions"] = "You don't have permission to use this command.",
                ["Lang_InterfaceTitle"] = "Choose a default skin for the building block",
                ["Lang_InterfaceDescr"] = "The skin will be automatically applied to building blocks.",
                ["Lang_ChangeHammer"] = "Change the skin of a building block with a hammer",
                ["Lang_NeedsRepair"] = "Allow skin changing with a hammer if a building needs repair",
                ["Lang_EnableAnimation"] = "Allow building block skin update animation",
                ["Lang_InterfaceApply"] = "Apply",
                ["Lang_SkinInstalled"] = "Installed",
                ["Lang_Unavailable"] = "Unavailable",
                ["Lang_MenuSettings"] = "Settings",
                ["Lang_ColorSettings"] = "Set color",
                ["Lang_Randomcolor"] = "Use random color",
                ["Lang_SettingEnable"] = "On",
                ["Lang_SettingDisable"] = "Off",
                ["Lang_TcChangeSkin"] = "Change building skin",
                ["Lang_TcWait"] = "Wait...",
                ["Wood"] = "Wood skin",
                ["Stone"] = "Stone skin",
                ["Metal"] = "Metal skin",
                ["TopTier"] = "TopTier skin",
                ["Adobe"] = "Adobe skin",
                ["Brick"] = "Brick skin",
                ["Brutalist"] = "Brutalist skin",
                ["Container"] = "Container skin",
                ["Frontier"] = "Frontier skin",
                ["Gingerbread"] = "Gingerbread skin"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Lang_UpdateAll"] = "Обновление скина для всех ваших построек началось...",
                ["Lang_UpdateBuilding"] = "Обновление скина для выбранной постройки началось...",
                ["Lang_UpdateAllTarget"] = "Обновление скина для всех построек игрока началось...",
                ["Lang_UpdateProgress"] = "Пожалуйста, дождитесь завершения обновления скина построек.",
                ["Lang_UpdateCompleted"] = "Обновление скина построек завершено.\nОбновлено {0} из {1} строительных блоков.",
                ["Lang_UpdateNotRequired"] = "Все строительные блоки уже имеют выбранный вами скин.",
                ["Lang_NotFoundBlocks"] = "Не найдено доступных построек для выбранного игрока.",
                ["Lang_NotFoundPlayer"] = "Игрок не найден. Используйте только Steam Id игрока.",
                ["Lang_NotFoundBuilding"] = "Постройка не найдена. Подойдите ближе к постройке и повторите снова.",
                ["Lang_NotOwnerBuilding"] = "Вы не являетесь владельцем этой постройки.",
                ["Lang_BuildingBlocked"] = "Вы не можете использовать эту команду в зоне блокировки строительства.",
                ["Lang_NoPermissions"] = "У вас нет разрешения на использование этой команды.",
                ["Lang_InterfaceTitle"] = "Выберите скин по умолчанию для строительного блока",
                ["Lang_InterfaceDescr"] = "Скин будет автоматически применяться к постройке.",
                ["Lang_ChangeHammer"] = "Изменять скин постройки при помощи киянки",
                ["Lang_NeedsRepair"] = "Разрешить смену скина киянкой, если требуется ремонт постройки",
                ["Lang_EnableAnimation"] = "Разрешить анимацию обновления скина постройки",
                ["Lang_InterfaceApply"] = "Применить",
                ["Lang_SkinInstalled"] = "Установлен",
                ["Lang_Unavailable"] = "Недоступен",
                ["Lang_MenuSettings"] = "Настройки",
                ["Lang_ColorSettings"] = "Выбор цвета",
                ["Lang_Randomcolor"] = "Случайный цвет",
                ["Lang_SettingEnable"] = "Вкл",
                ["Lang_SettingDisable"] = "Выкл",
                ["Lang_TcChangeSkin"] = "Изменить скин постройки",
                ["Lang_TcWait"] = "Ожидайте...",
                ["Wood"] = "Деревянный скин",
                ["Stone"] = "Каменный скин",
                ["Metal"] = "Металлический скин",
                ["TopTier"] = "МВК скин",
                ["Adobe"] = "Саманный скин",
                ["Brick"] = "Кирпичный скин",
                ["Brutalist"] = "Брутализм скин",
                ["Container"] = "Контейнерный скин",
                ["Frontier"] = "Фронтир скин",
                ["Gingerbread"] = "Пряничный скин"
            }, this, "ru");
        }

        #endregion

        #region Data

        private StoredData storedData;

        private class StoredData
        {
            public Dictionary<ulong, Data> PlayerData = new Dictionary<ulong, Data>();
        }

        private class Data
        {
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public bool ChangeHammer;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public bool NeedsRepair;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public bool EnableAnimation;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public bool RandomColor;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public uint Color;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public ulong Wood;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public ulong Stone;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public ulong Metal;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public ulong TopTier;
        }

        private void SaveData()
        {
            if (storedData != null)
            {
                Interface.Oxide.DataFileSystem.WriteObject($"{Name}_Data", storedData, true);
            }
        }

        private void LoadData()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>($"{Name}_Data");
            if (storedData == null)
            {
                storedData = new StoredData();
                SaveData();
            }

            foreach (var playerData in storedData.PlayerData.Values)
            {
                playerData.Wood = config.BuildingImages[0].Any(b => b.SkinId == playerData.Wood) ? playerData.Wood : 0;
                playerData.Stone = config.BuildingImages[1].Any(b => b.SkinId == playerData.Stone) ? playerData.Stone : 0;
                playerData.Metal = config.BuildingImages[2].Any(b => b.SkinId == playerData.Metal) ? playerData.Metal : 0;
                playerData.TopTier = config.BuildingImages[3].Any(b => b.SkinId == playerData.TopTier) ? playerData.TopTier : 0;
            }
        }

        #endregion
    }
}

// --- End of file: BuildingSkins.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-attachments ---
// --- Original File Path: B/BetterAttachments/BetterAttachments.cs ---

using Newtonsoft.Json;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("BetterAttachments", "ignignokt84", "0.0.3", ResourceId = 2326)]
	[Description("Plugin allowing for better control of weapon attachment attributes")]
	class BetterAttachments : RustPlugin
	{
		// configuration container
		AttachmentData data = new AttachmentData();
		// defaults cache - original attachment values are saved here so that
		// attachments can be reverted when this plugin is unloaded (otherwise
		// attachment modifications would be permanent)
		Dictionary<string,AttachmentModifier> defaults = new Dictionary<string,AttachmentModifier>();
		
		// load config
		void LoadConfig()
		{
			Config.Settings.NullValueHandling = NullValueHandling.Ignore;
			
			bool dirty = false;
			try {
				data = Config.ReadObject<AttachmentData>();
			} catch (Exception e) {
				data = new AttachmentData();
			}
			
			if(data == null || data.data == null || data.data.Count == 0)
				dirty |= LoadDefaultConfig();
			
			if(dirty)
				SaveData();
		}

		// save data
		void SaveData() => Config.WriteObject(data);

		// loads default configuration entries
		bool LoadDefaultConfig()
		{
			data.data.Clear();
			
			// flashlight defaults:
			// none
			AttachmentModifier flashlight = new AttachmentModifier();
			flashlight.name = "flashlight.entity";
			flashlight.sightAimCone = new Modifier(true);
			flashlight.sightAimCone.scalar = 0.95f;
			flashlight.recoil = new Modifier(true);
			flashlight.recoil.offset = -0.5f;
			flashlight.aimswaySpeed = new Modifier(true);
			flashlight.aimswaySpeed.scalar = 0.95f;
			flashlight.conditionLoss = 0f;
			data.data[flashlight.name] = flashlight;
			
			// holosight defaults:
			// none
			AttachmentModifier holosight = new AttachmentModifier();
			holosight.name = "holosight.entity";
			holosight.sightAimCone = new Modifier(true);
			holosight.sightAimCone.scalar = 0.9f;
			holosight.conditionLoss = 0f;
			data.data[holosight.name] = holosight;
			
			// lasersight defaults:
			// aimsway scalar 0.8
			// recoil scalar 0.85
			// sightAimCone scalar 0.25
			// hipAimCone scalar 0.25
			AttachmentModifier lasersight = new AttachmentModifier();
			lasersight.name = "lasersight.entity";
			lasersight.aimsway = new Modifier(true);
			lasersight.aimsway.scalar = 0.9f;
			lasersight.recoil = new Modifier(true);
			lasersight.recoil.scalar = 1f;
			lasersight.recoil.offset = -0.5f;
			lasersight.sightAimCone = new Modifier(true);
			lasersight.sightAimCone.scalar = 0.75f;
			lasersight.hipAimCone = new Modifier(true);
			lasersight.hipAimCone.scalar = 0.75f;
			lasersight.conditionLoss = 0f;
			data.data[lasersight.name] = lasersight;
			
			// muzzleBoost defaults:
			// repeatDelay scalar 0.9
			// projectileVelocity scalar 0.9
			// projectileDamage scalar 0.9
			// recoil scalar 0.98
			AttachmentModifier muzzleBoost = new AttachmentModifier();
			muzzleBoost.name = "muzzleboost.entity";
			muzzleBoost.repeatDelay = new Modifier(true);
			muzzleBoost.repeatDelay.scalar = 0.8f;
			muzzleBoost.projectileVelocity = new Modifier(true);
			muzzleBoost.projectileVelocity.scalar = 0.95f;
			muzzleBoost.projectileDamage = new Modifier(true);
			muzzleBoost.projectileDamage.scalar = 1f;
			muzzleBoost.recoil = new Modifier(true);
			muzzleBoost.recoil.scalar = 0.95f;
			muzzleBoost.conditionLoss = 0.1f;
			data.data[muzzleBoost.name] = muzzleBoost;
			
			// add catastrophic failure condition for muzzle boost
			CatastrophicFailure muzzleBoostFailure = new CatastrophicFailure();
			muzzleBoostFailure.enabled = true;
			muzzleBoostFailure.start = 0.15f; // start failure chances at 15%
			muzzleBoostFailure.target = 0.02f; // guaranteed failure at 2%
			muzzleBoostFailure.weaponDamage = 0.2f; // 20% of max weapon condition damaged on failure
			muzzleBoostFailure.playerDamage = 0.2f; // 20% of max player HP lost on failure
			data.failures[muzzleBoost.name] = muzzleBoostFailure;
			
			// muzzleBrake defaults:
			// recoil scalar 0.5
			// sightAimCone scalar 1.0 offset 1.0
			// hipAimCone scalar 1.0 offset 1.0
			AttachmentModifier muzzleBrake = new AttachmentModifier();
			muzzleBrake.name = "muzzlebrake.entity";
			muzzleBrake.aimsway = new Modifier(true);
			muzzleBrake.aimsway.scalar = 1.05f;
			muzzleBrake.aimswaySpeed = new Modifier(true);
			muzzleBrake.aimswaySpeed.scalar = 0.95f;
			muzzleBrake.recoil = new Modifier(true);
			muzzleBrake.recoil.scalar = 0.4f;
			muzzleBrake.sightAimCone = new Modifier(true);
			muzzleBrake.sightAimCone.scalar = 0.95f;
			muzzleBrake.sightAimCone.offset = 0f;
			muzzleBrake.hipAimCone = new Modifier(true);
			muzzleBrake.hipAimCone.scalar = 1f;
			muzzleBrake.hipAimCone.offset = 0f;
			data.data[muzzleBrake.name] = muzzleBrake;
			
			// add catastrophic failure condition for muzzle brake
			CatastrophicFailure muzzleBrakeFailure = new CatastrophicFailure();
			muzzleBrakeFailure.enabled = true;
			muzzleBrakeFailure.start = 0.10f; // start failure chances at 10%
			muzzleBrakeFailure.target = 0.01f; // guaranteed failure at 1%
			muzzleBrakeFailure.weaponDamage = 0.05f; // 5% of max weapon condition damaged on failure
			muzzleBrakeFailure.playerDamage = 0.1f; // 10% of max player HP lost on failure
			data.failures[muzzleBrake.name] = muzzleBrakeFailure;
			
			// silencer defaults:
			// projectileVelocity scalar 0.75
			// projectileDamage scalar 0.75
			// aimsway scalar 0.8
			// recoil scalar 0.8
			// sightAimCone scalar 0.7
			// hipAimCone scalar 0.6
			AttachmentModifier silencer = new AttachmentModifier();
			silencer.name = "silencer.entity";
			silencer.projectileVelocity = new Modifier(true);
			silencer.projectileVelocity.scalar = 1.05f;
			silencer.projectileDamage = new Modifier(true);
			silencer.projectileDamage.scalar = 1f;
			silencer.aimsway = new Modifier(true); 
			silencer.aimsway.scalar = 0.95f;
			silencer.recoil = new Modifier(true);
			silencer.recoil.scalar = 0.75f;
			silencer.sightAimCone = new Modifier(true);
			silencer.sightAimCone.scalar = 0.95f;
			silencer.hipAimCone = new Modifier(true);
			silencer.hipAimCone.scalar = 0.95f;
			silencer.conditionLoss = 0f;
			data.data[silencer.name] = silencer;
			
			// add catastrophic failure condition for muzzle brake
			CatastrophicFailure silencerFailure = new CatastrophicFailure();
			silencerFailure.enabled = true;
			silencerFailure.start = 0.10f; // start failure chances at 10%
			silencerFailure.target = 0.01f; // guaranteed failure at 1%
			silencerFailure.weaponDamage = 0.1f; // 10% of max weapon condition damaged on failure
			silencerFailure.playerDamage = 0.15f; // 15% of max player HP lost on failure
			data.failures[silencer.name] = silencerFailure;
			
			// scope defaults:
			// recoil scalar 0.8
			// sightAimCone scalar 0.7
			AttachmentModifier scope = new AttachmentModifier();
			scope.name = "smallscope.entity";
			scope.aimswaySpeed = new Modifier(true);
			scope.aimswaySpeed.scalar = 0.95f;
			scope.recoil = new Modifier(true);
			scope.recoil.scalar = 0.95f;
			scope.sightAimCone = new Modifier(true);
			scope.sightAimCone.scalar = 0.5f;
			data.data[scope.name] = scope;
			
			return true;
		}
		
		// plugin loaded
		void Loaded() {
			LoadConfig();
			checkAllAttachments();
		}
		
		// plugin unloaded
		void Unload()
		{
			restoreAllAttachments();
		}
		
		// check if spawned entity is an attachment and update it accordingly
		void OnEntitySpawned(BaseNetworkable entity)
		{
			if(entity is ProjectileWeaponMod)
			{
				ProjectileWeaponMod attachment = entity as ProjectileWeaponMod;
				if(attachment != null)
					modifyAttachment(attachment);
			}
		}
		
		// check if the default settings are saved
		bool checkDefaults(string prefabName)
		{
			return defaults.ContainsKey(prefabName);
		}
		
		// save default setting
		void saveDefaults(ProjectileWeaponMod mod)
		{
			if(defaults.ContainsKey(mod.ShortPrefabName))
				return;
			defaults[mod.ShortPrefabName] = new AttachmentModifier(mod);
			// print default settings
			//Puts("Default created:");
			//Puts(defaults[mod.ShortPrefabName].ToString());
		}
		
		// check all attachments and update where required
		void checkAllAttachments()
		{
			ProjectileWeaponMod[] attachments = (ProjectileWeaponMod[]) GameObject.FindObjectsOfType(typeof(ProjectileWeaponMod));
			if(attachments != null)
				foreach(ProjectileWeaponMod attachment in attachments)
					modifyAttachment(attachment);
		}
		
		// restore all attachments to their default values
		void restoreAllAttachments()
		{
			ProjectileWeaponMod[] attachments = (ProjectileWeaponMod[]) GameObject.FindObjectsOfType(typeof(ProjectileWeaponMod));
			if(attachments != null)
				foreach(ProjectileWeaponMod attachment in attachments)
					restoreDefaults(attachment);
		}
		
		// modify the attachment
		void modifyAttachment(ProjectileWeaponMod attachment)
		{
			AttachmentModifier m;
			if(data.data.TryGetValue(attachment.ShortPrefabName, out m))
			{
				if(m != null && m.enabled)
				{
					if(!checkDefaults(attachment.ShortPrefabName))
						saveDefaults(attachment);
					if(m.repeatDelay != null)
						updateModifier(ref attachment.repeatDelay, m.repeatDelay);
					if(m.projectileVelocity != null)
						updateModifier(ref attachment.projectileVelocity, m.projectileVelocity);
					if(m.projectileDamage != null)
						updateModifier(ref attachment.projectileDamage, m.projectileDamage);
					if(m.projectileDistance != null)
						updateModifier(ref attachment.projectileDistance, m.projectileDistance);
					if(m.aimsway != null)
						updateModifier(ref attachment.aimsway, m.aimsway);
					if(m.aimswaySpeed != null)
						updateModifier(ref attachment.aimswaySpeed, m.aimswaySpeed);
					if(m.recoil != null)
						updateModifier(ref attachment.recoil, m.recoil);
					if(m.sightAimCone != null)
						updateModifier(ref attachment.sightAimCone, m.sightAimCone);
					if(m.hipAimCone != null)
						updateModifier(ref attachment.hipAimCone, m.hipAimCone);
				}
			}
		}
		
		// restore the attachment to its default values
		void restoreDefaults(ProjectileWeaponMod attachment)
		{
			AttachmentModifier m;
			if(defaults.TryGetValue(attachment.ShortPrefabName, out m))
			{
				if(m != null)
				{
					if(m.repeatDelay != null)
						updateModifier(ref attachment.repeatDelay, m.repeatDelay);
					if(m.projectileVelocity != null)
						updateModifier(ref attachment.projectileVelocity, m.projectileVelocity);
					if(m.projectileDamage != null)
						updateModifier(ref attachment.projectileDamage, m.projectileDamage);
					if(m.projectileDistance != null)
						updateModifier(ref attachment.projectileDistance, m.projectileDistance);
					if(m.aimsway != null)
						updateModifier(ref attachment.aimsway, m.aimsway);
					if(m.aimswaySpeed != null)
						updateModifier(ref attachment.aimswaySpeed, m.aimswaySpeed);
					if(m.recoil != null)
						updateModifier(ref attachment.recoil, m.recoil);
					if(m.sightAimCone != null)
						updateModifier(ref attachment.sightAimCone, m.sightAimCone);
					if(m.hipAimCone != null)
						updateModifier(ref attachment.hipAimCone, m.hipAimCone);
				}
			}
		}
		
		// update a modifier
		void updateModifier(ref ProjectileWeaponMod.Modifier originalMod, Modifier newMod)
		{
			if(newMod == null) return;
			if(newMod.enabled != null)
				originalMod.enabled = newMod.enabled;
			if(newMod.scalar != null)
				originalMod.scalar = newMod.scalar;
			if(newMod.offset != null)
				originalMod.offset = newMod.offset;
		}
		
		// on lost condition, add condition back based on scaled amount
		void OnLoseCondition(Item item, ref float amount)
		{
			if(item == null || !item.hasCondition) return;
			BaseEntity entity = item.GetHeldEntity();
			if(entity == null) return;
			
			if(data.data.ContainsKey(entity.ShortPrefabName) && data.data[entity.ShortPrefabName].conditionLoss != null)
			{
				amount = amount * (1-data.data[entity.ShortPrefabName].conditionLoss);
				item.condition += amount;
			}
			if(shouldFail(entity.ShortPrefabName, item.conditionNormalized))
			{
				Item weaponItem = item.parent.parent;
				if(weaponItem == null) return;
				BasePlayer player = weaponItem.GetOwnerPlayer();
				if(player == null) return;
				BaseEntity weapon = player.GetHeldEntity();
				if(weapon != null && weapon is BaseProjectile)
				{
					float lostCondition = weaponItem.maxCondition * data.failures[entity.ShortPrefabName].weaponDamage;
					weaponItem.LoseCondition(lostCondition);
					
					float lostHP = player.MaxHealth() * data.failures[entity.ShortPrefabName].playerDamage;
					player.Hurt(lostHP, DamageType.Bullet);
					
					Effect.server.Run("assets/bundled/prefabs/fx/impacts/slash/metal/metal1.prefab", weapon, StringPool.closest, Vector3.zero, Vector3.zero);
					Effect.server.Run("assets/bundled/prefabs/fx/impacts/bullet/metal/metal1.prefab", weapon, StringPool.closest, Vector3.zero, Vector3.zero);
					Effect.server.Run("assets/prefabs/weapons/doubleshotgun/effects/pfx_bolt_shut_sparks.prefab", weapon, StringPool.closest, Vector3.zero, Vector3.zero);
				}
			}
		}
		
		// check whether the passed entity should fail
		// uses a logarithmic scale from start to target
		bool shouldFail(string name, float amount)
		{
			if(data.failures.ContainsKey(name) && data.failures[name].enabled)
			{
				if(amount == 0f) return true;
				if(amount == 1f) return false;
				if(data.failures[name].start <= amount) return false;
				if(data.failures[name].target == 0) return false;
				float target = amount/data.failures[name].target;
				float factor = 1f / data.failures[name].target * data.failures[name].start;
				float log = factor == 0f ? 0.0f : 1f - Mathf.Log(target, factor);
				if(log <= 0f) return false;
				return log >= UnityEngine.Random.value;
			}
			return false;
		}
		
		// wrapper class to hold configuration data all in one object
		private class AttachmentData
		{
			public Dictionary<string,AttachmentModifier> data = new Dictionary<string,AttachmentModifier>();
			public Dictionary<string,CatastrophicFailure> failures = new Dictionary<string,CatastrophicFailure>();
		}
		
		// container for modifier configuration for a single attachment type
		private class AttachmentModifier
		{
			public string name;
			public bool enabled = true;
			public Modifier repeatDelay;
			public Modifier projectileVelocity;
			public Modifier projectileDamage;
			public Modifier projectileDistance;
			public Modifier aimsway;
			public Modifier aimswaySpeed;
			public Modifier recoil;
			public Modifier sightAimCone;
			public Modifier hipAimCone;
			public float conditionLoss;
			
			public AttachmentModifier() {}
			
			public AttachmentModifier(ProjectileWeaponMod mod)
			{
				cloneAsDefaults(mod);
			}
			
			void cloneAsDefaults(ProjectileWeaponMod mod)
			{
				name = mod.ShortPrefabName;
				setModifier(ref repeatDelay, mod.repeatDelay);
				setModifier(ref projectileVelocity, mod.projectileVelocity);
				setModifier(ref projectileDamage, mod.projectileDamage);
				setModifier(ref projectileDistance, mod.projectileDistance);
				setModifier(ref aimsway, mod.aimsway);
				setModifier(ref aimswaySpeed, mod.aimswaySpeed);
				setModifier(ref recoil, mod.recoil);
				setModifier(ref sightAimCone, mod.sightAimCone);
				setModifier(ref hipAimCone, mod.hipAimCone);
			}
			
			void setModifier(ref Modifier internalMod, ProjectileWeaponMod.Modifier mod)
			{
				internalMod = new Modifier();
				internalMod.enabled = mod.enabled;
				internalMod.scalar = mod.scalar;
				internalMod.offset = mod.offset;
			}
			
			public string ToString() {
				string str = "name: " + name + Environment.NewLine +
							 "repeatDelay: " + repeatDelay.ToString() + Environment.NewLine +
							 "projectileVelocity: " + projectileVelocity.ToString() + Environment.NewLine +
							 "projectileDamage: " + projectileDamage.ToString() + Environment.NewLine +
							 "projectileDistance: " + projectileDistance.ToString() + Environment.NewLine +
							 "aimsway: " + aimsway.ToString() + Environment.NewLine +
							 "aimswaySpeed: " + aimswaySpeed.ToString() + Environment.NewLine +
							 "recoil: " + recoil.ToString() + Environment.NewLine +
							 "sightAimCone: " + sightAimCone.ToString() + Environment.NewLine +
							 "hipAimCone: " + hipAimCone.ToString();
				return str;
			}
		}
		
		// replication of ProjectileWeaponMod.Modifier as class instead of struct to allow nulls
		private class Modifier
		{
			public bool enabled;
			public float scalar;
			public float offset;
			
			public Modifier() {}
			public Modifier(bool enabled) {
				this.enabled = enabled;
			}
			public string ToString() {
				return "Modifier [" + enabled + ", " + scalar + ", " + offset + "]";
			}
		}
		
		private struct CatastrophicFailure {
			public bool enabled;
			public float start;
			public float target;
			public float weaponDamage;
			public float playerDamage;
		}
	}
}

// --- End of file: BetterAttachments.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bradley-guards ---
// --- Original File Path: B/BradleyGuards/BradleyGuards.cs ---

﻿/*
 * Copyright (c) 2023 Bazz3l
 * 
 * Bradley Guards cannot be copied, edited and/or (re)distributed without the express permission of Bazz3l.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */

using System.Collections.Generic;
using System.Collections;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System;
using Oxide.Plugins.BradleyGuardsExtensionMethods;
using Oxide.Core.Plugins;
using Oxide.Core;
using Rust;
using UnityEngine;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using Facepunch;
using HarmonyLib;
using Network;
using Action = System.Action;

namespace Oxide.Plugins
{
    [Info("Bradley Guards", "Bazz3l", "1.6.6")]
    [Description("Spawn reinforcements for bradley when destroyed at configured monuments.")]
    internal class BradleyGuards : RustPlugin
    {
        [PluginReference] private Plugin NpcSpawn, GUIAnnouncements;
        
        #region Fields
        
        private const string PERM_USE = "bradleyguards.use";
        
        private const float INITIALIZE_DELAY = 10f;
        
        private StoredData _storedData;
        private ConfigData _configData;
        private Coroutine _setupRoutine;
        
        private static BradleyGuards Instance;

        #endregion
        
        #region Local
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { MessageKeys.NoPermission, "Sorry you don't have permission to do that." },
                { MessageKeys.Prefix, "<color=#8a916f>Bradley Guards</color>:\n" },
                
                { MessageKeys.EventStart, "Armed reinforcements en route to <color=#e7cf85>{0}</color> eliminate the guards to gain access to high-value loot." },
                { MessageKeys.EventEnded, "Armed reinforcements have been eliminated at <color=#e7cf85>{0}</color>." },
                { MessageKeys.EventUpdated, "Event updated, please reload the plugin to take effect." },
                { MessageKeys.EventNotFound, "Event not found, please make sure you have typed the correct name." },
                { MessageKeys.DisplayNameEmpty, "Invalid event name provided." },
                { MessageKeys.InvalidGuardAmount, "Invalid guard amount must be between <color=#e7cf85>{0}</color> - <color=#e7cf85>{1}</color>." },
                { MessageKeys.InvalidBooleanValue, "Invalid boolean value provided, must be true or false." },
                
                { MessageKeys.HelpEventEnable, "<color=#e7cf85>/{0}</color> \"<color=#e7cf85><monument-path></color>\" enable <color=#e7cf85><true|false></color>\n" },
                { MessageKeys.HelpEventName, "<color=#e7cf85>/{0}</color> \"<color=#e7cf85><monument-path></color>\" display \"<color=#e7cf85><name-here></color>\"\n" },
                { MessageKeys.HelpGuardAmount, "<color=#e7cf85>/{0}</color> \"<color=#e7cf85><monument-path></color>\" amount <color=#e7cf85><number></color>\n" },
                { MessageKeys.HelpGuardLoadout, "<color=#e7cf85>/{0}</color> \"<color=#e7cf85><monument-path></color>\" loadout" },
            }, this);
        }

        private class MessageKeys
        {
            public static readonly string Prefix = "Prefix";
            public static readonly string NoPermission = "NoPermission";
            
            public static readonly string EventStart = "EventStart";
            public static readonly string EventEnded = "EventEnded";
            public static readonly string EventNotFound = "EventNotFound";
            public static readonly string EventUpdated = "EventUpdated";
            public static readonly string DisplayNameEmpty = "InvalidDisplayName";
            public static readonly string InvalidGuardAmount = "InvalidGuardAmount";
            public static readonly string InvalidBooleanValue = "InvalidBooleanValue";
            
            public static readonly string HelpEventEnable = "HelpEventEnable";
            public static readonly string HelpEventName = "HelpEventName";
            public static readonly string HelpGuardAmount = "HelpGuardAmount";
            public static readonly string HelpGuardLoadout = "HelpGuardLoadout";
        }

        private void MessagePlayer(BasePlayer player, string langKey, params object[] args)
        {
            if (player == null || !player.IsConnected) return;
            string message = lang.GetMessage(langKey, this);
            player.ChatMessage(args?.Length > 0 ? string.Format(message, args) : message);
        }
        
        private void MessagePlayers(string langKey, params object[] args)
        {
            string message =  lang.GetMessage(langKey, this);
            message = args?.Length > 0 ? string.Format(message, args) : message;
            
            if (_configData.MessageSettings.EnableChat)
                ConsoleNetwork.BroadcastToAllClients("chat.add", 2, _configData.MessageSettings.ChatIcon, _configData.MessageSettings.EnableChatPrefix ? (lang.GetMessage(MessageKeys.Prefix, this) + message) : message);
            
            if (_configData.MessageSettings.EnableToast)
                ConsoleNetwork.BroadcastToAllClients("gametip.showtoast_translated", 2, null, message);
            
            if (_configData.MessageSettings.EnableGuiAnnouncements && GUIAnnouncements.IsReady())
                GUIAnnouncements?.Call("CreateAnnouncement", message, _configData.MessageSettings.GuiAnnouncementsBgColor, _configData.MessageSettings.GuiAnnouncementsTextColor, null, 0.03f);
        }
        
        #endregion
        
        #region Config

        protected override void LoadDefaultConfig()
        {
            _configData = ConfigData.DefaultConfig();
            PrintWarning("Loaded default config.");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null) throw new JsonException();

                if (_configData.CommandName == null || _configData.MessageSettings == null)
                {
                    PrintWarning("Updated config.");
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch(Exception e)
            {
                PrintWarning(e.Message);
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_configData, true);
        
        private class ConfigData
        {
            [JsonProperty("command name")]
            public string CommandName = "bguard";
            
            [JsonProperty("enable auto unlock crates when guards are eliminated")]
            public bool EnableAutoUnlock;
            
            [JsonProperty("enable auto extinguish crates when guards are eliminated")]
            public bool EnableAutoExtinguish;

            [JsonProperty("bradley starting health")]
            public float BradleyHealth;

            [JsonProperty("crate spawn amount")]
            public int CrateSpawnAmount;
            
            [JsonProperty("message notification settings")]
            public MessageSettings MessageSettings;

            public static ConfigData DefaultConfig()
            {
                return new ConfigData
                {
                    CommandName = "bguard",
                    EnableAutoUnlock = true,
                    EnableAutoExtinguish = true,
                    BradleyHealth = 1000f,
                    CrateSpawnAmount = 4,
                    MessageSettings = new MessageSettings()
                    {
                        EnableToast = false,
                        EnableChat = true, 
                        EnableChatPrefix = true,
                        ChatIcon = 76561199542550973,
                        EnableGuiAnnouncements = false,
                        GuiAnnouncementsBgColor = "Purple",
                        GuiAnnouncementsTextColor = "White"
                    }
                };
            }
        }
        
        private class MessageSettings
        {
            [JsonProperty("enable toast message")]
            public bool EnableToast;
            
            [JsonProperty("enable chat message")]
            public bool EnableChat;

            [JsonProperty("enable chat prefix")]
            public bool EnableChatPrefix;
            
            [JsonProperty("custom chat message icon (steam64)")]
            public ulong ChatIcon;
            
            [JsonProperty("enable gui announcements plugin from umod.org")]
            public bool EnableGuiAnnouncements;
            
            [JsonProperty("gui announcements text color")]
            public string GuiAnnouncementsTextColor;
            
            [JsonProperty("gui announcements background color")]
            public string GuiAnnouncementsBgColor;
        }

        #endregion

        #region Storage

        private void LoadDefaultData()
        {
            _storedData = new StoredData
            {
                BradleyEventEntries = new Dictionary<string, EventEntry>
                {
                    ["assets/bundled/prefabs/autospawn/monument/xlarge/launch_site_1.prefab"] = new EventEntry
                    {
                        DisplayName = "Launch Site",
                        EnabledEvent = true,
                        BoundsPosition = new Vector3(0f, 0f, 0f),
                        BoundsSize = new Vector3(580f, 280f, 300f),
                        LandingPosition = new Vector3(152.3f, 3f, 0f),
                        LandingRotation = new Vector3(0f, 90f, 0f),
                        ChinookPosition = new Vector3(-195f, 150f, 25f),
                        GuardAmount = 10,
                        GuardConfig = new GuardConfig
                        {
                            Name = "Launch Site Guard",
                            WearItems = new List<GuardConfig.WearEntry>
                            {
                                new GuardConfig.WearEntry
                                {
                                    ShortName = "hazmatsuit_scientist_peacekeeper",
                                    SkinID = 0UL
                                }
                            },
                            BeltItems = new List<GuardConfig.BeltEntry>
                            {
                                new GuardConfig.BeltEntry
                                {
                                    ShortName = "smg.mp5",
                                    Amount = 1,
                                    SkinID = 0UL,
                                    Mods = new List<string>()
                                },
                                new GuardConfig.BeltEntry
                                {
                                    ShortName = "syringe.medical",
                                    Amount = 10,
                                    SkinID = 0UL,
                                    Mods = new List<string>()
                                },
                            },
                            Kit = "",
                            Health = 250f,
                            RoamRange = 25f,
                            ChaseRange = 40f,
                            SenseRange = 150f,
                            AttackRangeMultiplier = 8f,
                            CheckVisionCone = false,
                            VisionCone = 180f,
                            DamageScale = 1f,
                            TurretDamageScale = 0.25f,
                            AimConeScale = 0.35f,
                            DisableRadio = false,
                            CanRunAwayWater = true,
                            CanSleep = false,
                            Speed = 8.5f,
                            AreaMask = 1,
                            AgentTypeID = -1372625422,
                            MemoryDuration = 30f
                        }
                    },
                    ["assets/bundled/prefabs/autospawn/monument/large/airfield_1.prefab"] = new EventEntry
                    {
                        DisplayName = "Airfield Guard",
                        EnabledEvent = false,
                        BoundsPosition = new Vector3(0f, 0f, 0f),
                        BoundsSize = new Vector3(340f, 260f, 300f),
                        LandingPosition = new Vector3(0f, 0f, -28f),
                        LandingRotation = new Vector3(0f, 0f, 0f),
                        ChinookPosition = new Vector3(-195f, 150f, 25f),
                        GuardAmount = 10,
                        GuardConfig = new GuardConfig
                        {
                            Name = "Guarded Crate",
                            WearItems = new List<GuardConfig.WearEntry>
                            {
                                new GuardConfig.WearEntry
                                {
                                    ShortName = "hazmatsuit_scientist_peacekeeper",
                                    SkinID = 0UL
                                }
                            },
                            BeltItems = new List<GuardConfig.BeltEntry>
                            {
                                new GuardConfig.BeltEntry
                                {
                                    ShortName = "smg.mp5",
                                    Amount = 1,
                                    SkinID = 0UL,
                                    Mods = new List<string>()
                                },
                                new GuardConfig.BeltEntry
                                {
                                    ShortName = "syringe.medical",
                                    Amount = 10,
                                    SkinID = 0UL,
                                    Mods = new List<string>()
                                },
                            },
                            Kit = "",
                            Health = 250f,
                            RoamRange = 25f,
                            ChaseRange = 40f,
                            SenseRange = 150f,
                            AttackRangeMultiplier = 8f,
                            CheckVisionCone = false,
                            VisionCone = 180f,
                            DamageScale = 1f,
                            TurretDamageScale = 0.25f,
                            AimConeScale = 0.35f,
                            DisableRadio = false,
                            CanRunAwayWater = true,
                            CanSleep = false,
                            Speed = 8.5f,
                            AreaMask = 1,
                            AgentTypeID = -1372625422,
                            MemoryDuration = 30f
                        }
                    }
                }
            };

            SaveData();
        }

        private void LoadData()
        {
            try
            {
                _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
                if (_storedData == null || !_storedData.IsValid) throw new Exception();
            }
            catch
            {
                PrintWarning("Loaded default data.");
                LoadDefaultData();
            }
        }

        private void SaveData()
        {
            if (_storedData == null || !_storedData.IsValid) 
                return;
            
            Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);
        }

        private class StoredData
        {
            public Dictionary<string, EventEntry> BradleyEventEntries = new(StringComparer.OrdinalIgnoreCase);

            [JsonIgnore] 
            public bool IsValid => BradleyEventEntries != null && BradleyEventEntries.Count > 0;
            
            public EventEntry FindEntryByName(string monumentName)
            {
                return BradleyEventEntries.TryGetValue(monumentName, out EventEntry eventEntry) ? eventEntry : null;
            }
        }

        private class EventEntry
        {
            [JsonProperty("display name")]
            public string DisplayName;
            
            [JsonProperty("enabled")]
            public bool EnabledEvent;
            
            [JsonProperty("bounds center")]
            public Vector3 BoundsPosition;
            [JsonProperty("bounds size")]
            public Vector3 BoundsSize;
            
            [JsonProperty("landing position")]
            public Vector3 LandingPosition;
            [JsonProperty("landing rotation")]
            public Vector3 LandingRotation;
            
            [JsonProperty("chinook position")]
            public Vector3 ChinookPosition;
            
            [JsonProperty("guard spawn amount")]
            public int GuardAmount;
            
            [JsonProperty("guard spawn profile")]
            public GuardConfig GuardConfig;

            public IEnumerator Create(Transform transform, bool enableAutoExtinguish, bool enableAutoUnlock)
            {
                Vector3 landingRotation = transform.TransformDirection(transform.rotation.eulerAngles - LandingRotation);
                Vector3 landingPosition = transform.TransformPoint(LandingPosition);
                Vector3 chinookPosition = transform.TransformPoint(ChinookPosition);
                
                if (GuardConfig.Parsed == null)
                    GuardConfig.CacheConfig();
                
                BradleyGuardsEvent component = Utils.CreateObjectWithComponent<BradleyGuardsEvent>(landingPosition, Quaternion.Euler(landingRotation), "Bradley_Guards_Event");
                component.bounds = new OBB(transform.position, transform.rotation, new Bounds(BoundsPosition, BoundsSize));
                component.chinookPosition = chinookPosition;
                component.guardConfig = GuardConfig;
                
                component.guardAmount = GuardAmount;
                component.displayName = DisplayName;
                component.enableAutoExtinguish = enableAutoExtinguish;
                component.enableAutoUnlock = enableAutoUnlock;
                component.CreateLandingZone();
                component.DisplayInfo();
                
                yield return CoroutineEx.waitForEndOfFrame;
            }
        }
        
        private class GuardConfig
        {
            public string Name;
            public string Kit;
            public float Health;
            public float RoamRange;
            public float ChaseRange;
            public float SenseRange;
            public float AttackRangeMultiplier;
            public bool CheckVisionCone;
            public float VisionCone;
            public float DamageScale;
            public float TurretDamageScale;
            public float AimConeScale;
            public bool DisableRadio;
            public bool CanRunAwayWater;
            public bool CanSleep;
            public float Speed;
            public int AreaMask;
            public int AgentTypeID;
            public float MemoryDuration;
            public List<WearEntry> WearItems;
            public List<BeltEntry> BeltItems; 

            [JsonIgnore]
            public JObject Parsed;

            public class BeltEntry
            {
                public string ShortName;
                public ulong SkinID;
                public int Amount;
                public string Ammo;
                public List<string> Mods;

                public static List<BeltEntry> SaveItems(ItemContainer container)
                {
                    List<BeltEntry> items = new List<BeltEntry>();
                    
                    foreach (Item item in container.itemList)
                    {
                        BeltEntry beltEntry = new BeltEntry
                        {
                            ShortName = item.info.shortname,
                            SkinID = item.skin,
                            Amount = item.amount,
                            Mods = new List<string>()
                        };

                        if (item.GetHeldEntity() is BaseProjectile projectile && projectile?.primaryMagazine != null && projectile.primaryMagazine.ammoType != null)
                            beltEntry.Ammo = projectile.primaryMagazine.ammoType.shortname;

                        if (item?.contents?.itemList != null)
                        {
                            foreach (Item itemContent in item.contents.itemList)
                                beltEntry.Mods.Add(itemContent.info.shortname);
                        }
                        
                        items.Add(beltEntry);
                    }

                    return items;
                }
            }

            public class WearEntry
            {
                public string ShortName; 
                public ulong SkinID;

                public static List<WearEntry> SaveItems(ItemContainer container)
                {
                    List<WearEntry> items = new List<WearEntry>();
                    
                    foreach (Item item in container.itemList)
                    {
                        WearEntry wearEntry = new WearEntry
                        {
                            ShortName = item.info.shortname,
                            SkinID = item.skin
                        };
                        
                        items.Add(wearEntry);
                    }

                    return items;
                }
            }

            public void CacheConfig()
            {
                Parsed = new JObject
                {
                    ["Name"] = Name,
                    ["WearItems"] = new JArray { WearItems.Select(x => new JObject { ["ShortName"] = x.ShortName, ["SkinID"] = x.SkinID }) },
                    ["BeltItems"] = new JArray { BeltItems.Select(x => new JObject { ["ShortName"] = x.ShortName, ["SkinID"] = x.SkinID, ["Amount"] = x.Amount, ["Ammo"] = x.Ammo, ["Mods"] = new JArray(x.Mods) }) },
                    ["Kit"] = Kit,
                    ["Health"] = Health,
                    ["RoamRange"] = RoamRange,
                    ["ChaseRange"] = ChaseRange,
                    ["SenseRange"] = SenseRange,
                    ["ListenRange"] = SenseRange / 2,
                    ["AttackRangeMultiplier"] = AttackRangeMultiplier,
                    ["CheckVisionCone"] = CheckVisionCone,
                    ["VisionCone"] = VisionCone,
                    ["DamageScale"] = DamageScale,
                    ["TurretDamageScale"] = TurretDamageScale,
                    ["AimConeScale"] = AimConeScale,
                    ["DisableRadio"] = DisableRadio,
                    ["CanRunAwayWater"] = CanRunAwayWater,
                    ["CanSleep"] = CanSleep,
                    ["Speed"] = Speed,
                    ["AreaMask"] = AreaMask,
                    ["AgentTypeID"] = AgentTypeID,
                    ["MemoryDuration"] = MemoryDuration,
                    ["States"] = new JArray
                    {
                        new HashSet<string> { "RoamState", "ChaseState", "CombatState", "RaidState" }
                    }
                };
            }
        }

        #endregion
        
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            CustomProtection.Initialize();
            EntitiesLookup.Initialize();
            
            PerformSetupRoutine();
            
            if (string.IsNullOrEmpty(_configData.CommandName))
                return;
            
            cmd.AddChatCommand(_configData.CommandName, this, nameof(EventCommands));
        }

        private void Init()
        {
            permission.RegisterPermission(PERM_USE, this);
            
            Instance = this;
            
            LoadData();
        }

        private void Unload()
        {
            try
            {
                DestroySetupRoutine();
                BradleyGuardsEvent.OnUnload();
            }
            finally
            {
                CustomProtection.OnUnload();
                EntitiesLookup.OnUnload();
                Instance = null;
            }
        }
        
        private void OnEntityKill(ScientistNPC npc)
        {
            EntitiesLookup.FindEventByEntity(npc)
                ?.OnGuardDeath(npc, null);
        }

        private void OnEntitySpawned(BradleyAPC bradley)
        {
            if (bradley == null || bradley.IsDestroyed)
                return;
            
            Vector3 position = bradley.transform.position;
            if (position == Vector3.zero)
                return;
            
            BradleyGuardsEvent component = BradleyGuardsEvent.GetClosest(position);
            if (component == null)
                return;
            
            component.ResetEvent();
            
            bradley.maxCratesToSpawn = _configData.CrateSpawnAmount;
            bradley._maxHealth = _configData.BradleyHealth;
            bradley.InitializeHealth(_configData.BradleyHealth, _configData.BradleyHealth); 
        }

        private void OnEntityDeath(BradleyAPC bradley, HitInfo info)
        {
            if (bradley == null || bradley.IsDestroyed || info?.InitiatorPlayer == null)
                return;
            
            Vector3 position = bradley.transform.position;
            if (position == Vector3.zero)
                return;
            
            BradleyGuardsEvent component = BradleyGuardsEvent.GetClosest(position);
            if (component == null || component.IsStarted()) 
                return;
            
            if (!NpcSpawn.IsReady())
            {
                PrintWarning("Missing dependency [NpcSpawn v2.4.8] this can be found over at codefling.com thanks to KpucTaJl");
                return;
            }

            component.StartEvent(position);
        }
        
        private void OnEntityDeath(ScientistNPC npc, HitInfo hitInfo)
        {
            EntitiesLookup.FindEventByEntity(npc)
                ?.OnGuardDeath(npc, hitInfo?.InitiatorPlayer);
        }
        
        private void OnEntityDismounted(BaseMountable mountable, ScientistNPC scientist)
        {
            CH47HelicopterAIController chinook = mountable.GetParentEntity() as CH47HelicopterAIController;
            if (chinook == null || chinook.OwnerID != 111999 || chinook.IsDestroyed)
                return;
            
            scientist.Brain.Navigator.ForceToGround();
            scientist.Brain.Navigator.SetDestination(scientist.finalDestination);
            
            if (chinook.AnyMounted())
                return;
            
            ForceChinookLeave(chinook);
        }

        #endregion

        #region Event

        private void PerformSetupRoutine()
        {
            DestroySetupRoutine();
            
            _setupRoutine = ServerMgr.Instance.StartCoroutine(SetupEventsRoutine());
        }

        private void DestroySetupRoutine()
        {
            if (_setupRoutine != null)
                ServerMgr.Instance.StopCoroutine(_setupRoutine);
            
            _setupRoutine = null;
        }
        
        private IEnumerator SetupEventsRoutine()
        {
            yield return null;
            Interface.Oxide.LogDebug("Initializing (Bradley Guard Events) in ({0})s.", INITIALIZE_DELAY);
            yield return CoroutineEx.waitForSeconds(INITIALIZE_DELAY);
            
            using (new DebugStopwatch("Finished initializing (Bradley Guard Events) in ({0})ms."))
            {
                foreach (MonumentInfo monumentInfo in TerrainMeta.Path.Monuments)
                {
                    if (monumentInfo.name.IsNullOrEmpty())
                        continue;
                    
                    EventEntry monumentEntry = _storedData.FindEntryByName(monumentInfo.name);
                    if (monumentEntry == null || !monumentEntry.EnabledEvent)
                        continue;
                    
                    yield return monumentEntry.Create(monumentInfo.transform, _configData.EnableAutoExtinguish, _configData.EnableAutoUnlock);
                }
            }
            
            _setupRoutine = null;
            
            yield break;
        }
        
        private class BradleyGuardsEvent : FacepunchBehaviour
        {
            public static readonly List<BradleyGuardsEvent> EventComponents = new();
            
            private List<BaseEntity> _spawnInstances = new();
            private CH47LandingZone _eventLandingZone;
            private CurrentState _eventState;
            private Vector3 _eventPosition;
            private GameObject _go;
            
            public GuardConfig guardConfig;
            public Vector3 chinookPosition;
            public string displayName;
            public int guardAmount;
            public bool enableAutoExtinguish;
            public bool enableAutoUnlock;
            public OBB bounds;
            public BasePlayer winningPlayer;
            
            public static BradleyGuardsEvent GetClosest(Vector3 position)
            {
                for (int i = 0; i < EventComponents.Count; i++)
                {
                    BradleyGuardsEvent component = EventComponents[i];
                    if (component.bounds.Contains(position)) 
                        return component;
                }

                return (BradleyGuardsEvent)null;
            }
            
            public static void OnUnload()
            {
                if (Rust.Application.isQuitting)
                    return;
                
                for (int i = EventComponents.Count - 1; i >= 0; i--)
                    EventComponents[i]?.DestroyMe();
                
                EventComponents.Clear();
            }
            
            #region Unity
            
            public void Awake()
            {
                _go = gameObject;
                
                BradleyGuardsEvent.EventComponents.Add(this);
            }

            public void OnDestroy()
            {
                BradleyGuardsEvent.EventComponents.Remove(this);   
            }

            public void DestroyMe()
            {
                ClearGuards();
                UnityEngine.GameObject.Destroy(_go);
            }

            #endregion
            
            #region Event Management
            
            public bool IsStarted() => _eventState == CurrentState.Started;

            public void StartEvent(Vector3 deathPosition)
            {
                if (IsStarted())
                    return;
                
                winningPlayer = null;
                
                _eventPosition = deathPosition;
                _eventState = CurrentState.Started;
                
                SpawnChinook();
                RemoveDamage();
                
                Instance?.HookResubscribe();
                Instance?.MessagePlayers(MessageKeys.EventStart, displayName);
            }

            private void StopEvent()
            {
                _eventState = CurrentState.Waiting;
                
                Instance?.HookUnsubscribe();
                Instance?.MessagePlayers(MessageKeys.EventEnded, displayName);
            }

            public void ResetEvent()
            {
                ClearGuards();

                _eventState = CurrentState.Waiting;
            }

            public void CheckEvent()
            {
                if (enableAutoExtinguish)
                    RemoveFlames();
                
                if (enableAutoUnlock)
                    UnlockCrates();

                if (winningPlayer != null)
                    Interface.CallHook("OnBradleyGuardsEventEnded", winningPlayer);
                
                StopEvent();
            }

            private bool HasGuards() => _spawnInstances.Count > 0;

            private void UnlockCrates()
            {
                List<LockedByEntCrate> entities = Facepunch.Pool.Get<List<LockedByEntCrate>>();

                try
                {
                    Vis.Entities(_eventPosition, 25f, entities);

                    foreach (LockedByEntCrate entCrate in entities)
                    {
                        if (!entCrate.IsValid() || entCrate.IsDestroyed) 
                            continue;
                    
                        entCrate.SetLocked(false);
                        
                        if (entCrate.lockingEnt == null) 
                            continue;
                        
                        BaseEntity entity = entCrate.lockingEnt.GetComponent<BaseEntity>();
                        if (entity != null && !entity.IsDestroyed)
                            entity.Kill();
                    }
                }
                catch (Exception e)
                {
                    //
                }

                Facepunch.Pool.FreeUnmanaged<LockedByEntCrate>(ref entities);
            }

            private void RemoveFlames()
            {
                List<FireBall> entities = Facepunch.Pool.Get<List<FireBall>>();

                try
                {
                    Vis.Entities<FireBall>(_eventPosition, 25f, entities);
                    
                    foreach (FireBall fireball in entities)
                    {
                        if (fireball.IsValid() && !fireball.IsDestroyed)
                            fireball.Extinguish();
                    }
                }
                catch (Exception e)
                {
                    //
                }

                Facepunch.Pool.FreeUnmanaged<FireBall>(ref entities);
            }
            
            private void RemoveDamage()
            {
                List<FireBall> entities = Facepunch.Pool.Get<List<FireBall>>();

                try
                {
                    Vis.Entities<FireBall>(_eventPosition, 25f, entities);

                    foreach (FireBall fireball in entities)
                    {
                        if (fireball.IsValid() && !fireball.IsDestroyed)
                            fireball.ignoreNPC = true;
                    }
                }
                catch (Exception e)
                {
                    //
                }

                Facepunch.Pool.FreeUnmanaged<FireBall>(ref entities);
            }

            #endregion

            #region Chinook

            private void SpawnChinook()
            {
                CH47HelicopterAIController component = GameManager.server.CreateEntity("assets/prefabs/npc/ch47/ch47scientists.entity.prefab")?.GetComponent<CH47HelicopterAIController>();
                component.transform.position = chinookPosition;
                component.SetLandingTarget(_eventLandingZone.transform.position);
                component.OwnerID = 111999;
                component.Spawn();
                component.SetMinHoverHeight(0.0f);
                component.Invoke(new Action(() => SpawnGuards(component, guardAmount)), 0.25f);
                component.Invoke(new Action(() => DropSmokeGrenade(_eventLandingZone.transform.position)), 1f);
                
                CustomProtection.ModifyProtection(component);
            }
            
            private void DropSmokeGrenade(Vector3 position)
            {
                SmokeGrenade component = GameManager.server.CreateEntity("assets/prefabs/tools/smoke grenade/grenade.smoke.deployed.prefab", position, Quaternion.identity).GetComponent<SmokeGrenade>();
                component.smokeDuration = 45f;
                component.Spawn();
            }

            #endregion

            #region Landing

            public void CreateLandingZone()
            {
                _eventLandingZone = gameObject.AddComponent<CH47LandingZone>();
                _eventLandingZone.enabled = true;
            }

            #endregion

            #region Guard
            
            private void SpawnGuards(CH47HelicopterAIController chinook, int numToSpawn)
            {
                int num = Mathf.Clamp(numToSpawn, 1, chinook.mountPoints.Count);
                
                for (int i = 0; i < 2; i++)
                    SpawnGuard(chinook, chinook.transform.position + chinook.transform.forward * 10f);

                num -= 2;
                
                if (num <= 0)
                    return;
                
                for (int i = 0; i < num; i++)
                    SpawnGuard(chinook, chinook.transform.position - chinook.transform.forward * 15f);
            }

            private void SpawnGuard(CH47HelicopterAIController chinook, Vector3 position)
            {
                Vector3 destination = _eventPosition.GetPointAround(2f);
                guardConfig.Parsed["HomePosition"] = destination.ToString();
                
                ScientistNPC scientist = (ScientistNPC)Instance?.NpcSpawn.Call("SpawnNpc", position, guardConfig.Parsed);
                if (scientist == null || scientist.IsDestroyed)
                    return;
                
                scientist.finalDestination = destination;
                CachedGuardAdd(scientist);
                chinook.AttemptMount((BasePlayer) scientist, false);
            }
            
            public void ClearGuards()
            {
                for (int i = _spawnInstances.Count - 1; i >= 0; i--)
                {
                    BaseEntity entity = _spawnInstances[i];
                    if (entity != null && !entity.IsDestroyed)
                        entity.Kill();
                }
                
                _spawnInstances.Clear();
            }
            
            #endregion
            
            #region Oxide Hooks
            
            public void OnGuardDeath(ScientistNPC npc, BasePlayer player)
            {
                CachedGuardRemove(npc);
                
                if (HasGuards())
                    return;
                
                winningPlayer = player;
                CheckEvent();
            }
            
            #endregion
            
            #region Cache Guard Entity

            private void CachedGuardAdd(BaseEntity entity)
            {
                _spawnInstances.Add(entity);
                
                EntitiesLookup.CreateEntity(entity, this);
            }

            private void CachedGuardRemove(BaseEntity entity)
            {
                _spawnInstances.Remove(entity);
                
                EntitiesLookup.RemoveEntity(entity);
            }

            #endregion
            
            #region Debug Info

            public void DisplayInfo()
            {
                List<Connection> connections = Facepunch.Pool.Get<List<Connection>>();
                
                try
                {
                    connections.AddRange(Net.sv.connections.Where(x => x.connected && x.authLevel == 2));
                    
                    Utils.DText(connections, transform.position, "Landing Position", Color.magenta, 30f);
                    Utils.DText(connections, chinookPosition, "Chinook Position", Color.green, 30f);
                    Utils.DLine(connections, chinookPosition, _eventLandingZone.transform.position, Color.yellow, 30f);
                    Utils.DText(connections, bounds.position, "Bounds Position", Color.cyan, 30f);
                    Utils.DCube(connections, bounds.position, bounds.rotation, bounds.extents, Color.blue, 30f);
                }
                catch (Exception e)
                {
                    //
                }
                
                Facepunch.Pool.FreeUnmanaged<Connection>(ref connections);
            }

            #endregion
        }

        private void ForceChinookLeave(CH47HelicopterAIController chinook)
        {
            chinook.ClearLandingTarget();
            chinook.Invoke(() =>
            {
                chinook.EnableFacingOverride(true);
                chinook.SetMinHoverHeight(60f);
                chinook.SetMoveTarget(Vector3.right * 6000f);
                chinook.Invoke(new Action(chinook.KillMessage), 60f);

                if (chinook.TryGetComponent<CH47AIBrain>(out CH47AIBrain aiBrain)) 
                    aiBrain.SwitchToState(AIState.Egress, aiBrain.currentStateContainerID);
            }, 5f);
        }

        private enum CurrentState
        {
            Waiting, 
            Started
        }
        
        #endregion
        
        #region Rust Edit

        private object OnNpcRustEdit(ScientistNPC npc)
        {
            return EntitiesLookup.FindEventByEntity(npc) != null ? (object)true : null;
        }

        #endregion
        
        #region Hook Subscribe
        
        private void HookUnsubscribe() => Unsubscribe(nameof(OnEntityDismounted));
        
        private void HookResubscribe() => Subscribe(nameof(OnEntityDismounted));

        #endregion
        
        #region Custom Protection

        private static class CustomProtection
        {
            private static ProtectionProperties ProtectionInstance;
            
            public static void Initialize()
            {
                ProtectionInstance = ScriptableObject.CreateInstance<ProtectionProperties>();
                ProtectionInstance.name = "Bradley_Guards_Protection";
                ProtectionInstance.Add(1);
            }

            public static void OnUnload()
            {
                if (ProtectionInstance != null) 
                    UnityEngine.ScriptableObject.Destroy(ProtectionInstance);
                
                ProtectionInstance = null;
            }

            public static void ModifyProtection(BaseCombatEntity combatEntity)
            {
                if (combatEntity != null && !combatEntity.IsDestroyed) 
                    combatEntity.baseProtection = ProtectionInstance;
            }
        }

        #endregion
        
        #region Entities Lookup

        private static class EntitiesLookup
        {
            public static Dictionary<BaseEntity, BradleyGuardsEvent> Entities;

            public static BradleyGuardsEvent FindEventByEntity(BaseEntity entity)
            {
                return entity != null && Entities.TryGetValue(entity, out BradleyGuardsEvent component) ? component : null;
            }

            public static void Initialize()
            {
                Entities = new Dictionary<BaseEntity, BradleyGuardsEvent>();
            }
            
            public static void OnUnload()
            {
                Entities.Clear();
                Entities = null;
            }

            public static void CreateEntity(BaseEntity entity, BradleyGuardsEvent component)
            {
                if (Entities != null)
                    Entities.Add(entity, component);
            }

            public static void RemoveEntity(BaseEntity entity)
            {
                if (Entities != null)
                    Entities.Remove(entity);
            }
        }

        #endregion
        
        #region Chat Command
        
        private void EventCommands(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERM_USE))
            {
                MessagePlayer(player, MessageKeys.NoPermission);
                return;
            }
            
            if (args.Length < 2)
            {
                EventHelpText(player);
                return;
            }
            
            if (!_storedData.BradleyEventEntries.TryGetValue(args[0], out EventEntry eventEntry))
            {
                MessagePlayer(player, MessageKeys.EventNotFound);
                return;
            }

            string option = args[1];
            if (option.Equals("enable"))
            {
                if (args.Length != 3)
                {
                    EventHelpText(player);
                    return;
                }
                
                bool enabled;
                if (bool.TryParse(args[2], out enabled))
                {
                    MessagePlayer(player, MessageKeys.InvalidBooleanValue);
                    return;
                }
                
                eventEntry.EnabledEvent = enabled;
                
                SaveData();
                MessagePlayer(player, MessageKeys.EventUpdated);
                return;
            }
            
            if (option.Equals("display"))
            {
                if (args.Length != 3)
                {
                    EventHelpText(player);
                    return;
                }
                
                string displayName = string.Join(" ", args.Skip(2));
                if (displayName.IsNullOrEmpty())
                {
                    MessagePlayer(player, MessageKeys.DisplayNameEmpty);
                    return;
                }
                
                eventEntry.DisplayName = displayName;
                
                SaveData();
                MessagePlayer(player, MessageKeys.EventUpdated);
                return;
            }
            
            if (option.Equals("amount"))
            {
                if (args.Length != 3)
                {
                    EventHelpText(player);
                    return;
                }

                int amount;
                if (!int.TryParse(args[2], out amount) || (amount < 2 || amount > 10))
                {
                    MessagePlayer(player, MessageKeys.InvalidGuardAmount);
                    return;
                }

                eventEntry.GuardAmount = amount;
                
                SaveData();
                MessagePlayer(player, MessageKeys.EventUpdated);
                return;
            }
            
            if (option.Equals("loadout"))
            {
                if (player.inventory == null)
                    return;
                
                eventEntry.GuardConfig.BeltItems = GuardConfig.BeltEntry.SaveItems(player.inventory.containerBelt);
                eventEntry.GuardConfig.WearItems = GuardConfig.WearEntry.SaveItems(player.inventory.containerWear);
                eventEntry.GuardConfig.CacheConfig();
                SaveData();
                MessagePlayer(player, MessageKeys.EventUpdated);
                return;
            }
            
            EventHelpText(player);
        }

        private void EventHelpText(BasePlayer player)
        {
            StringBuilder sb = Facepunch.Pool.Get<StringBuilder>();
            
            try
            {
                sb.Clear();
                sb.AppendFormat(lang.GetMessage(MessageKeys.Prefix, this, player.UserIDString))
                    .AppendFormat(lang.GetMessage(MessageKeys.HelpEventEnable, this, player.UserIDString), _configData.CommandName)
                    .AppendFormat(lang.GetMessage(MessageKeys.HelpEventName, this, player.UserIDString), _configData.CommandName)
                    .AppendFormat(lang.GetMessage(MessageKeys.HelpGuardAmount, this, player.UserIDString), _configData.CommandName)
                    .AppendFormat(lang.GetMessage(MessageKeys.HelpGuardLoadout, this, player.UserIDString), _configData.CommandName);
            
                player.ChatMessage(sb.ToString());
            }
            finally
            {
                sb.Clear();
                Facepunch.Pool.FreeUnmanaged(ref sb);
            }
        }

        #endregion

        #region Debug Stopwatch

        private class DebugStopwatch : IDisposable
        {
            private Stopwatch _stopwatch;
            private string _format;

            public DebugStopwatch(string format)
            {
                _format = format;

                _stopwatch = new Stopwatch();
                _stopwatch.Start();
            }

            public void Dispose()
            {
                _stopwatch.Stop();

                Interface.Oxide.LogDebug(_format, _stopwatch.ElapsedMilliseconds);
                
                _stopwatch = null;
            }
        }

        #endregion

        #region Harmony Patches

        [AutoPatch]
        [HarmonyPatch(typeof(CH47HelicopterAIController), "CheckSpawnScientists")]
        public static class Prevent_CH47_Scientists_Spawning_Patch
        {
            public static bool Prefix(CH47HelicopterAIController __instance)
            {
                return !(__instance != null && __instance.OwnerID == 111999);
            }
        }

        #endregion
    }
}

namespace Oxide.Plugins.BradleyGuardsExtensionMethods
{
    public static class Utils
    {
        public static T CreateObjectWithComponent<T>(Vector3 position, Quaternion rotation, string name) where T : MonoBehaviour
        {
            return new GameObject(name)
            {
                layer = (int)Layer.Reserved1,
                transform =
                {
                    position = position,
                    rotation = rotation
                }
            }.AddComponent<T>();
        }
        
        public static void Segments(List<Connection> connections, Vector3 origin, Vector3 target, Color color, float duration)
        {
            Vector3 delta = target - origin;
            float distance = delta.magnitude;
            Vector3 direction = delta.normalized;

            float segmentLength = 10f;
            int numSegments = Mathf.CeilToInt(distance / segmentLength);

            for (int i = 0; i < numSegments; i++)
            {
                float length = segmentLength;
                if (i == numSegments - 1 && distance % segmentLength != 0)
                    length = distance % segmentLength;

                Vector3 start = origin + i * segmentLength * direction;
                Vector3 end = start + length * direction;
                
                Utils.DLine(connections, start, end, color, duration);
            }
        }
        
        public static void DLine(List<Connection> connections, Vector3 start, Vector3 end, Color color, float duration)
        {
            if (connections?.Count > 0)     
                ConsoleNetwork.SendClientCommand(connections, "ddraw.line", duration, color, start, end);
        }
        
        public static void DText(List<Connection> connections, Vector3 origin, string text, Color color, float duration)
        {
            if (connections?.Count > 0)
                ConsoleNetwork.SendClientCommand(connections, "ddraw.text", duration, color, origin, text);
        }
        
        public static void DCube(List<Connection> connections, Vector3 center, Quaternion rotation, Vector3 extents, Color color, float duration)
        {
            Vector3 forwardUpperLeft = center + rotation * extents.WithX(-extents.x);
            Vector3 forwardUpperRight = center + rotation * extents;
            Vector3 forwardLowerLeft = center + rotation * extents.WithX(-extents.x).WithY(-extents.y);
            Vector3 forwardLowerRight = center + rotation * extents.WithY(-extents.y);
            Vector3 backLowerRight = center + rotation * -extents.WithX(-extents.x);
            Vector3 backLowerLeft = center + rotation * -extents;
            Vector3 backUpperRight = center + rotation * -extents.WithX(-extents.x).WithY(-extents.y);
            Vector3 backUpperLeft = center + rotation * -extents.WithY(-extents.y);
                
            Utils.Segments(connections, forwardUpperLeft, forwardUpperRight, color, duration);
            Utils.Segments(connections, forwardLowerLeft, forwardLowerRight, color, duration);
            Utils.Segments(connections, forwardUpperLeft, forwardLowerLeft, color, duration);
            Utils.Segments(connections, forwardUpperRight, forwardLowerRight, color, duration);

            Utils.Segments(connections, backUpperLeft, backUpperRight, color, duration);
            Utils.Segments(connections, backLowerLeft, backLowerRight, color, duration);
            Utils.Segments(connections, backUpperLeft, backLowerLeft, color, duration);
            Utils.Segments(connections, backUpperRight, backLowerRight, color, duration);

            Utils.Segments(connections, forwardUpperLeft, backUpperLeft, color, duration);
            Utils.Segments(connections, forwardLowerLeft, backLowerLeft, color, duration);
            Utils.Segments(connections, forwardUpperRight, backUpperRight, color, duration);
            Utils.Segments(connections, forwardLowerRight, backLowerRight, color, duration);
        }
    }
    
    public static class ExtensionMethods
    {
        public static bool IsNullOrEmpty(this string value) => string.IsNullOrEmpty(value);
        
        public static bool IsReady(this Plugin plugin) => plugin != null && plugin.IsLoaded;
        
        public static Vector3 GetPointAround(this Vector3 position, float radius)
        {
            float angle = UnityEngine.Random.value * 360f;
            
            Vector3 pointAround = position;
            pointAround.x = position.x + radius * Mathf.Sin(angle * Mathf.Deg2Rad);
            pointAround.z = position.z + radius * Mathf.Cos(angle * Mathf.Deg2Rad);
            pointAround.y = position.y;
            pointAround.y = TerrainMeta.HeightMap.GetHeight(pointAround);
            return pointAround;
        }
    }
}


// --- End of file: BradleyGuards.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bed-rename-blocker ---
// --- Original File Path: B/BedRenameBlocker/BedRenameBlocker.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;

namespace Oxide.Plugins
{
    [Info("Bed Rename Blocker", "MON@H", "2.0.1")]
    [Description("Blocks people of renaming a bed/sleeping bag")]
    class BedRenameBlocker : RustPlugin
    {
        #region Variables

        [PluginReference] private Plugin Clans, Friends;

        private const string PermissionImmunity = "bedrenameblocker.immunity";

        #endregion Variables

        #region Initialization

        private void Init()
        {
            Unsubscribe(nameof(CanRenameBed));

            permission.RegisterPermission(PermissionImmunity, this);
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(CanRenameBed));
        }

        #endregion Initialization

        #region Configuration

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Block only bags owned by the players (false = block all)")]
            public bool PlayerOwnedOnly = true;

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans = true;

            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends = true;

            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams = true;

            [JsonProperty(PropertyName = "Chat steamID icon")]
            public ulong SteamIDIcon = 0;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration

        #region Localization

        private string Lang(string key, string userIDString = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, userIDString), args);
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception:\n{ex}");
                throw;
            }
        }

        private static class LangKeys
        {
            public static class Error
            {
                private const string Base = nameof(Error) + ".";
                public const string NoPermission = Base + nameof(NoPermission);
            }

            public static class Format
            {
                private const string Base = nameof(Format) + ".";
                public const string Prefix = Base + nameof(Prefix);
            }
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Error.NoPermission] = "You do not have permission to use this command",
                [LangKeys.Format.Prefix] = "<color=#00FF00>[Bed Rename Blocker]</color>: ",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Error.NoPermission] = "У вас нет разрешения на использование этой команды",
                [LangKeys.Format.Prefix] = "<color=#00FF00>[Блокировка переименнования]</color>: ",
            }, this, "ru");
        }

        #endregion Localization

        #region Oxide Hooks

        private object CanRenameBed(BasePlayer player, SleepingBag bed, string bedName)
        {
            if (player != null && bed != null && !permission.UserHasPermission(player.UserIDString, PermissionImmunity))
            {
                if (!bed.OwnerID.IsSteamId() && !_configData.PlayerOwnedOnly)
                {
                    PlayerSendMessage(player, Lang(LangKeys.Error.NoPermission, player.UserIDString));
                    return true;
                }

                if (bed.OwnerID.IsSteamId() && !IsAlly(player.userID, bed.OwnerID))
                {
                    PlayerSendMessage(player, Lang(LangKeys.Error.NoPermission, player.UserIDString));
                    return true;
                }
            }

            return null;
        }

        #endregion Oxide Hooks

        #region Helpers

        private bool IsPluginLoaded(Plugin plugin) => plugin != null && plugin.IsLoaded;

        public bool IsAlly(ulong playerId, ulong targetId)
        {
            return playerId == targetId || IsOnSameTeam(playerId, targetId) || IsClanMemberOrAlly(playerId.ToString(), targetId.ToString()) || IsFriend(playerId, targetId);
        }

        public bool IsClanMemberOrAlly(string playerId, string targetId)
        {
            if (_configData.UseClans)
            {
                if (IsPluginLoaded(Clans))
                {
                    return Clans.Call<bool>("IsMemberOrAlly", playerId, targetId);
                }
                else
                {
                    PrintError("UseClans is set to true, but Clans plugin is not loaded!");
                }
            }

            return false;
        }

        public bool IsFriend(ulong playerId, ulong targetId)
        {
            if (_configData.UseFriends)
            {
                if (IsPluginLoaded(Friends))
                {
                    return Friends.Call<bool>("HasFriend", targetId, playerId);
                }
                else
                {
                    PrintError("UseFriends is set to true, but Friends plugin is not loaded!");
                }
            }

            return false;
        }

        public bool IsOnSameTeam(ulong playerId, ulong targetId)
        {
            if (!_configData.UseTeams)
            {
                return false;
            }

            RelationshipManager.PlayerTeam playerTeam;
            if (!RelationshipManager.ServerInstance.playerToTeam.TryGetValue(playerId, out playerTeam))
            {
                return false;
            }

            RelationshipManager.PlayerTeam targetTeam;
            if (!RelationshipManager.ServerInstance.playerToTeam.TryGetValue(targetId, out targetTeam))
            {
                return false;
            }

            return playerTeam.teamID == targetTeam.teamID;
        }

        private void PlayerSendMessage(BasePlayer player, string message)
        {
            player.SendConsoleCommand("chat.add", 2, _configData.SteamIDIcon, string.IsNullOrEmpty(Lang(LangKeys.Format.Prefix, player.UserIDString)) ? message : Lang(LangKeys.Format.Prefix, player.UserIDString) + message);
        }

        #endregion Helpers
    }
}

// --- End of file: BedRenameBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/base-repair ---
// --- Original File Path: B/BaseRepair/BaseRepair.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using ProtoBuf;
using UnityEngine;

namespace Oxide.Plugins;

[Info("Base Repair", "MJSU", "1.0.27")]
[Description("Allows player to repair their entire base")]
internal class BaseRepair : RustPlugin
{
    #region Class Fields

    [PluginReference] private Plugin NoEscape, RaidBlock;

    private StoredData _storedData; //Plugin Data
    private PluginConfig _pluginConfig; //Plugin Config

    private const string UsePermission = "baserepair.use";
    private const string NoCostPermission = "baserepair.nocost";
    private const string NoAuthPermission = "baserepair.noauth";
    private const string AccentColor = "#de8732";

    private readonly List<ulong> _repairingPlayers = new();
    private readonly ItemAmountPool _itemAmountPool = new();
    private readonly StringBuilder _sb = new();

    private GameObject _go;
    private RepairBehavior _rb;

    private readonly object _true = true;
    #endregion

    #region Setup & Loading
    private void Init()
    {
        _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
        permission.RegisterPermission(UsePermission, this);
        permission.RegisterPermission(NoCostPermission, this);
        permission.RegisterPermission(NoAuthPermission, this);
        foreach (string command in _pluginConfig.ChatCommands)
        {
            cmd.AddChatCommand(command, this, BaseRepairChatCommand);
        }

        UnsubscribeAll();
    }

    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            [LangKeys.Chat] = $"<color=#bebebe>[<color={AccentColor}>{Title}</color>] {{0}}</color>",
            [LangKeys.NoPermission] = "You do not have permission to use this command",
            [LangKeys.RepairInProcess] = "You have a current repair in progress. Please wait for that to finish before repairing again",
            [LangKeys.RecentlyDamaged] = "We failed to repair {0} because they were recently damaged",
            [LangKeys.AmountRepaired] = "We have repaired {0} damaged items in this base. ",
            [LangKeys.Enabled] = "You enabled enabled building repair. Hit the building you wish to repair with the hammer and we will do the rest for you.",
            [LangKeys.Disabled] = "You have disabled building repair.",
            [LangKeys.RaidBlockPluginBlocked] = "You are currently raid blocked and cannot base repair this building"
        }, this);
    }

    protected override void LoadDefaultConfig()
    {
        PrintWarning("Loading Default Config");
    }

    protected override void LoadConfig()
    {
        base.LoadConfig();
        Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
        _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
        Config.WriteObject(_pluginConfig);
    }

    private PluginConfig AdditionalConfig(PluginConfig config)
    {
        config.ChatCommands ??= new List<string>
        {
            "br"
        };
        return config;
    }

    private void OnServerInitialized()
    {
        _go = new GameObject(Name);
        _rb = _go.AddComponent<RepairBehavior>();
            
        SubscribeAll();
    }

    private void Unload()
    {
        if (_rb)
        {
            _rb.StopAllCoroutines();
            _rb.DoDestroy();
        }
           
        GameObject.Destroy(_go);
    }
    #endregion

    #region Chat Command
    private void BaseRepairChatCommand(BasePlayer player, string cmd, string[] args)
    {
        if (!player.IsAdmin && !HasPermission(player, UsePermission))
        {
            Chat(player, Lang(LangKeys.NoPermission, player));
            return;
        }

        bool enabled = !_storedData.RepairEnabled[player.userID];
        _storedData.RepairEnabled[player.userID] = enabled;

        Chat(player, enabled ? Lang(LangKeys.Enabled, player) : Lang(LangKeys.Disabled, player));
        SaveData();
    }
    #endregion

    #region Oxide Hooks
    private object OnHammerHit(BasePlayer player, HitInfo info)
    {
        BaseCombatEntity entity = info?.HitEntity as BaseCombatEntity;
        if (entity == null || entity.IsDestroyed)
        {
            return null;
        }
            
        if (entity is BaseVehicle or ConstructableEntity)
        {
            return null;
        }

        if (!CanRepair(player))
        {
            return null;
        }

        if (IsRepairBlocked(player))
        {
            return null;
        }

        if (_repairingPlayers.Contains(player.userID))
        {
            Chat(player, Lang(LangKeys.RepairInProcess, player));
            return _true;
        }

        bool hasNoAuth = HasPermission(player, NoAuthPermission);
            
        BuildingPrivlidge priv = player.GetBuildingPrivilege();
        if (priv && !hasNoAuth && !priv.IsAuthed(player))
        {
            return null;
        }
            
        BuildingManager.Building building = null;
        if (entity is DecayEntity decayEntity)
        {
            building = decayEntity.GetBuilding();
        }
            
        if (building == null)
        {
            if (!priv)
            {
                return null;
            }
                
            building = priv.GetBuilding();
            if (building == null)
            {
                return null;
            }
        }
            
        priv = building.GetDominatingBuildingPrivilege();
        if (!priv && !_pluginConfig.AllowNoTcRepair)
        {
            return null;
        }
            
        if (priv && !hasNoAuth && !priv.IsAuthed(player))
        {
            return null;
        }

        PlayerRepairStats stats = new();

        if (Interface.CallHook("OnBaseRepair", building, player) != null)
        {
            return null;
        }
            
        _rb.StartCoroutine(DoBuildingRepair(player, building, stats));
        return _true;
    }
    
    public bool CanRepair(BasePlayer player)
    {
        if (!HasPermission(player, UsePermission))
        {
            return false;
        }

        if (_pluginConfig.EnableHammerSkin && player.GetActiveItem()?.skin == _pluginConfig.HammerSkinId)
        {
            return true;
        }

        if (_storedData.RepairEnabled.TryGetValue(player.userID, out bool enabled))
        {
            return enabled;
        }

        return _pluginConfig.DefaultEnabled;
    }
    
    public bool IsRepairBlocked(BasePlayer player)
    {
        if (Interface.Call("CanBaseRepair", player) is bool canRepair)
        {
            return canRepair;
        }
        
        if (IsPluginLoaded(NoEscape) && NoEscape.Call("CanDo", "repair", player) is string result && !string.IsNullOrEmpty(result))
        {
            Chat(player, result);
            return true;
        }

        if (IsPluginLoaded(RaidBlock) && RaidBlock.Call("IsBlocked", player) is true)
        {
            Chat(player, Lang(LangKeys.RaidBlockPluginBlocked));
            return true;
        }

        return false;
    }

    #endregion

    #region Repair Handler

    private IEnumerator DoBuildingRepair(BasePlayer player, BuildingManager.Building building, PlayerRepairStats stats)
    {
        _repairingPlayers.Add(player.userID);
        bool noCostPerm = HasPermission(player, NoCostPermission);
            
        for (int index = 0; index < building.decayEntities.Count; index++)
        {
            DecayEntity entity = building.decayEntities[index];
            DoRepair(player, entity, stats, noCostPerm);

            for (int i = 0; i < entity.children.Count; i++)
            {
                BaseEntity childEntity = entity.children[i];
                if (childEntity is BaseLadder ladder)
                {
                    DoRepair(player, ladder, stats, noCostPerm);
                }
            }

            if (index % _pluginConfig.RepairsPerFrame == 0)
            {
                yield return null;
            }
        }

        _sb.Clear();
        _sb.AppendLine(Lang(LangKeys.AmountRepaired, player, stats.TotalSuccess));

        if (stats.RecentlyDamaged > 0)
        {
            _sb.AppendLine(Lang(LangKeys.RecentlyDamaged, player, stats.RecentlyDamaged));
        }

        Chat(player, _sb.ToString());

        if (stats.TotalCantAfford > 0)
        {
            List<ItemAmount> missingAmounts = Pool.Get<List<ItemAmount>>();
            foreach (KeyValuePair<int, ItemAmount> missing in stats.MissingAmounts)
            {
                float amountMissing = missing.Value.amount - player.inventory.GetAmount(missing.Key);
                if (amountMissing <= 0)
                {
                    ItemAmount amount = missing.Value;
                    _itemAmountPool.Free(ref amount);
                    continue;
                }

                missingAmounts.Add(missing.Value);
            }
                
            SendMissingItemAmounts(player, missingAmounts);
            FreeItemAmounts(missingAmounts);
        }

        foreach (KeyValuePair<int, int> taken in stats.AmountTaken)
        {
            player.Command("note.inv", taken.Key, -taken.Value);
        }

        _repairingPlayers.Remove(player.userID);
    }

    private void DoRepair(BasePlayer player, BaseCombatEntity entity, PlayerRepairStats stats, bool noCost)
    {
        if (!entity.IsValid() || entity.IsDestroyed)
        {
            return;
        }

        if (!entity.repair.enabled || entity.health == entity.MaxHealth())
        {
            return;
        }

        if (Interface.CallHook("OnStructureRepair", entity, player) != null)
        {
            return;
        }

        if (entity.SecondsSinceAttacked <= _pluginConfig.EntityRepairDelay)
        {
            entity.OnRepairFailed(null, string.Empty);
            stats.RecentlyDamaged++;
            return;
        }

        float missingHealth = entity.MaxHealth() - entity.health;
        float healthPercentage = missingHealth / entity.MaxHealth();
        if (missingHealth <= 0f || healthPercentage <= 0f)
        {
            entity.OnRepairFailed(null, string.Empty);
            return;
        }

        if (!noCost)
        {
            List<ItemAmount> itemAmounts = Pool.Get<List<ItemAmount>>();
            GetEntityRepairCost(entity, itemAmounts, healthPercentage);
            if (!HasRepairCost(itemAmounts))
            {
                entity.health += missingHealth;
                entity.SendNetworkUpdate();
                entity.OnRepairFinished();
                FreeItemAmounts(itemAmounts);
                return;
            }

            if (Math.Abs(_pluginConfig.RepairCostMultiplier - 1f) > 0.001f)
            {
                foreach (ItemAmount amount in itemAmounts)
                {
                    amount.amount *= _pluginConfig.RepairCostMultiplier;
                }
            }

            if (!CanAffordRepair(player, itemAmounts))
            {
                entity.OnRepairFailed(null, string.Empty);
                    
                foreach (ItemAmount amount in itemAmounts)
                {
                    ItemAmount missing = stats.MissingAmounts[amount.itemid];
                    if (missing == null)
                    {
                        missing = _itemAmountPool.Get();
                        missing.itemDef = amount.itemDef;
                        missing.amount = amount.amount;
                        stats.MissingAmounts[amount.itemid] = missing;
                        continue;
                    }

                    missing.amount += amount.amount;
                }

                stats.TotalCantAfford++;
                FreeItemAmounts(itemAmounts);
                return;
            }

            List<Item> items = Pool.Get<List<Item>>();
            foreach (ItemAmount amount in itemAmounts)
            {
                player.inventory.Take(items, amount.itemid, (int) amount.amount);
                stats.AmountTaken[amount.itemid] += (int) amount.amount;
            }

            for (int index = 0; index < items.Count; index++)
            {
                Item item = items[index];
                item.Remove();
            }

            Pool.FreeUnmanaged(ref items);
            FreeItemAmounts(itemAmounts);
        }

        entity.health += missingHealth;
        entity.SendNetworkUpdate();

        if (entity.health < entity.MaxHealth())
        {
            entity.OnRepair();
        }
        else
        {
            entity.OnRepairFinished();
        }

        stats.TotalSuccess++;
    }

    public bool CanAffordRepair(BasePlayer player, List<ItemAmount> amounts)
    {
        for (int index = 0; index < amounts.Count; index++)
        {
            ItemAmount amount = amounts[index];
            if (player.inventory.GetAmount(amount.itemid) < amount.amount)
            {
                return false;
            }
        }

        return true;
    }

    public void GetEntityRepairCost(BaseCombatEntity entity, List<ItemAmount> repairAmounts, float missingHealthFraction)
    {
        List<ItemAmount> entityAmount = entity.BuildCost();
        if (entityAmount == null)
        {
            return;
        }
            
        float repairCostFraction = entity.RepairCostFraction();
        for (int index = 0; index < entityAmount.Count; index++)
        {
            ItemAmount itemAmount = entityAmount[index];
                
            if (entity.repair.ignoreForRepair && itemAmount.itemDef.itemid == entity.repair.ignoreForRepair.itemid)
            {
                continue;
            }
                
            int amount = Mathf.RoundToInt(itemAmount.amount * repairCostFraction * missingHealthFraction);
            if (amount > 0)
            {
                ItemAmount repairAmount = _itemAmountPool.Get();
                repairAmount.itemDef = itemAmount.itemDef;
                repairAmount.amount = amount;
                repairAmounts.Add(repairAmount);
            }
        }
    }

    public bool HasRepairCost(List<ItemAmount> amounts)
    {
        for (int index = 0; index < amounts.Count; index++)
        {
            ItemAmount amount = amounts[index];
            if (amount.amount >= 1)
            {
                return true;
            }
        }

        return false;
    }

    public void FreeItemAmounts(List<ItemAmount> amounts)
    {
        for (int index = 0; index < amounts.Count; index++)
        {
            ItemAmount amount = amounts[index];
            _itemAmountPool.Free(ref amount);
        }
            
        Pool.FreeUnmanaged(ref amounts);
    }
    #endregion

    #region Helper Methods
    public void SendMissingItemAmounts(BasePlayer player, List<ItemAmount> itemAmounts)
    {
        using ItemAmountList itemAmountList = ItemAmount.SerialiseList(itemAmounts);
        player.ClientRPC(RpcTarget.Player("Client_OnRepairFailedResources", player), itemAmountList);
    }
        
    public void SubscribeAll()
    {
        Subscribe(nameof(OnHammerHit));
    }
        
    public void UnsubscribeAll()
    {
        Unsubscribe(nameof(OnHammerHit));
    }
    
    public bool IsPluginLoaded(Plugin plugin) => plugin is { IsLoaded: true };

    private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);

    private void Chat(BasePlayer player, string format) => PrintToChat(player, Lang(LangKeys.Chat, player, format));

    private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

    private string Lang(string key, BasePlayer player = null)
    {
        return lang.GetMessage(key, this, player?.UserIDString);
    }
        
    private string Lang(string key, BasePlayer player = null, params object[] args)
    {
        try
        {
            return string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
        }
        catch (Exception ex)
        {
            PrintError($"Lang Key '{key}' threw exception\n:{ex}");
            throw;
        }
    }

    #endregion

    #region Behavior
    private class RepairBehavior : FacepunchBehaviour
    {
        private void Awake()
        {
            enabled = false;
        }

        public void DoDestroy()
        {
            Destroy(this);
        }
    }
    #endregion
        
    #region Classes

    private class PluginConfig
    {
        [DefaultValue(10)]
        [JsonProperty(PropertyName = "Number of entities to repair per server frame")]
        public int RepairsPerFrame { get; set; }

        [DefaultValue(false)]
        [JsonProperty(PropertyName = "Default Enabled")]
        public bool DefaultEnabled { get; set; }
            
        [DefaultValue(false)]
        [JsonProperty(PropertyName = "Allow Repairing Bases Without A Tool Cupboard")]
        public bool AllowNoTcRepair { get; set; }

        [DefaultValue(1f)]
        [JsonProperty(PropertyName = "Repair Cost Multiplier")]
        public float RepairCostMultiplier { get; set; }
            
        [DefaultValue(30f)]
        [JsonProperty(PropertyName = "How long after an entity is damaged before it can be repaired (Seconds)")]
        public float EntityRepairDelay { get; set; }

        [JsonProperty(PropertyName = "Chat Commands")]
        public List<string> ChatCommands { get; set; }
            
        [JsonProperty(PropertyName = "Enable Repairs Using A Skinned Hammer")]
        public bool EnableHammerSkin { get; set; }
            
        [DefaultValue(2902701361)]
        [JsonProperty(PropertyName = "Repair Hammer Skin ID")]
        public ulong HammerSkinId { get; set; }
    }

    private class StoredData
    {
        public Hash<ulong, bool> RepairEnabled = new();
    }

    private class PlayerRepairStats
    {
        public int TotalSuccess { get; set; }
        public int TotalCantAfford { get; set; }
        public int RecentlyDamaged { get; set; }
        public Hash<int, ItemAmount> MissingAmounts { get; } = new();
        public Hash<int, int> AmountTaken { get; } = new();
    }

    private class LangKeys
    {
        public const string Chat = "Chat";
        public const string NoPermission = "NoPermission";
        public const string RepairInProcess = "RepairInProcess";
        public const string RecentlyDamaged = "RecentlyDamaged";
        public const string AmountRepaired = "AmountRepaired";
        public const string Enabled = "Enabled";
        public const string Disabled = "Disabled";
        public const string RaidBlockPluginBlocked = "RaidBlockPlugin.Blocked";
    }

    #endregion

    #region Pool
    private class BasePool<T> where T : class
    {
        protected readonly List<T> Pool = new();
        protected readonly Func<T> Init;

        public BasePool(Func<T> init)
        {
            Init = init;
        }
            
        public virtual T Get()
        {
            if (Pool.Count == 0)
            {
                return Init.Invoke();
            }

            int index = Pool.Count - 1; //Removing the last element prevents an array copy.
            T entity = Pool[index];
            Pool.RemoveAt(index);
                
            return entity;
        }

        public virtual void Free(ref T entity)
        {
            Pool.Add(entity);
            entity = null;
        }
    }
        
    private class ItemAmountPool : BasePool<ItemAmount>
    {
        public ItemAmountPool() : base(() => new ItemAmount())
        {
        }
            
        public override void Free(ref ItemAmount ia)
        {
            ia.itemDef = null;
            ia.amount = 0;
            ia.startAmount = 0;
            base.Free(ref ia);
        }
    }
    #endregion
}

// --- End of file: BaseRepair.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-chat-mute-voice ---
// --- Original File Path: B/BetterChatMuteVoice/BetterChatMuteVoice.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Better Chat Mute Voice", "collect_vood", "1.0.4")]
    [Description("Adds voice mute to better chat muted players")]
    public class BetterChatMuteVoice : CovalencePlugin
    {
        [PluginReference]
        private Plugin BetterChatMute;

        #region Variables

        public HashSet<string> MuteCache = new HashSet<string>();

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            if (BetterChatMute == null || !BetterChatMute.IsLoaded)
            {
                PrintWarning("BetterChatMute is required for this plugin to work.");
            }
            else
            {
                var muteList = BetterChatMute.Call("API_GetMuteList") as List<string>;
                MuteCache = new HashSet<string>(muteList);
            }


            if (MuteCache.Count < 1) Unsubscribe(nameof(OnPlayerVoice));
        }

        private object OnPlayerVoice(BasePlayer player)
        {
            if (MuteCache.Contains(player.UserIDString)) return true;

            return null;
        }

        #region BetterChatMute Hooks

        private void OnBetterChatMuted(IPlayer target, IPlayer initiator, string reason) => HandleAddMute(target.Id);

        private void OnBetterChatTimeMuted(IPlayer target, IPlayer initiator, TimeSpan timeSpan, string reason) => HandleAddMute(target.Id);

        private void OnBetterChatUnmuted(IPlayer target, IPlayer initiator) => HandleRemoveMute(target.Id);

        private void OnBetterChatMuteExpired(IPlayer player) => HandleRemoveMute(player.Id);

        #endregion

        #endregion

        #region Methods

        private void HandleRemoveMute(string playerId)
        {
            MuteCache.Remove(playerId);

            if (MuteCache.Count < 1) Unsubscribe(nameof(OnPlayerVoice));
        }        
        
        private void HandleAddMute(string playerId)
        {
            MuteCache.Add(playerId);

            if (MuteCache.Count == 1) Subscribe(nameof(OnPlayerVoice));
        }

        #endregion
    }
}


// --- End of file: BetterChatMuteVoice.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/backpacks ---
// --- Original File Path: B/Backpacks/Backpacks.cs ---

﻿// #define DEBUG_DROP_ON_DEATH
// #define DEBUG_POOLING
// #define DEBUG_BACKPACK_LIFECYCLE

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using Facepunch;
using Network;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Rust;
using UnityEngine;
using UnityEngine.UI;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("Backpacks", "WhiteThunder", "3.15.0")]
    [Description("Allows players to have a Backpack which provides them extra inventory space.")]
    internal class Backpacks : CovalencePlugin
    {
        #region Fields

        private static int _maxCapacityPerPage = 48;

        private const int MinRows = 1;
        private const int MaxRows = 8;
        private const int MinContainerCapacity = 1;
        private const int MaxContainerCapacity = 48;
        private const int SlotsPerRow = 6;
        private const int ReclaimEntryMaxSize = 40;
        private const float StandardLootDelay = 0.1f;
        private const Item.Flag SearchableItemFlag = (Item.Flag)(1 << 24);
        private const Item.Flag UnsearchableItemFlag = (Item.Flag)(1 << 25);
        private const ItemDefinition.Flag SearchableItemDefinitionFlag = (ItemDefinition.Flag)(1 << 24);

        private const string UsagePermission = "backpacks.use";
        private const string SizePermission = "backpacks.size";
        private const string GUIPermission = "backpacks.gui";
        private const string FetchPermission = "backpacks.fetch";
        private const string GatherPermission = "backpacks.gather";
        private const string RetrievePermission = "backpacks.retrieve";
        private const string AdminPermission = "backpacks.admin";
        private const string AdminProtectedPermission = "backpacks.admin.protected";
        private const string CapacityProfilePermission = "backpacks.size.profile";
        private const string KeepOnDeathPermission = "backpacks.keepondeath";
        private const string LegacyKeepOnWipePermission = "backpacks.keeponwipe";
        private const string LegacyNoBlacklistPermission = "backpacks.noblacklist";

        private const string CoffinPrefab = "assets/prefabs/misc/halloween/coffin/coffinstorage.prefab";
        private const string DroppedBackpackPrefab = "assets/prefabs/misc/item drop/item_drop_backpack.prefab";
        private const string ResizableLootPanelName = "generic_resizable";

        private const int SaddleBagItemId = 1400460850;

        private readonly CapacityManager _capacityManager;
        private readonly BackpackManager _backpackManager;
        private readonly SubscriberManager _subscriberManager = new();

        private ProtectionProperties _immortalProtection;
        private Effect _reusableEffect = new();
        private string _cachedButtonUi;

        private readonly ApiInstance _api;
        private Configuration _config;
        private PreferencesData _preferencesData;
        private CapacityData _capacityData;
        private readonly HashSet<ulong> _uiViewers = new();
        private Coroutine _saveRoutine;

        [PluginReference]
        private readonly Plugin Arena, BackpackButton, EventManager, ItemRetriever;

        public Backpacks()
        {
            _backpackManager = new BackpackManager(this);
            _capacityManager = new CapacityManager(this, _backpackManager);
            _api = new ApiInstance(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(UsagePermission, this);
            permission.RegisterPermission(GUIPermission, this);
            permission.RegisterPermission(FetchPermission, this);
            permission.RegisterPermission(GatherPermission, this);
            permission.RegisterPermission(RetrievePermission, this);
            permission.RegisterPermission(AdminPermission, this);
            permission.RegisterPermission(AdminProtectedPermission, this);
            permission.RegisterPermission(KeepOnDeathPermission, this);

            _config.Init(this);

            _maxCapacityPerPage = Mathf.Clamp(_config.BackpackSize.MaxCapacityPerPage, MinContainerCapacity, MaxContainerCapacity);

            PoolUtils.ResizePools();

            _preferencesData = PreferencesData.Load();
            _capacityData = CapacityData.Exists() ? CapacityData.Load() : new CapacityData();
            _capacityManager.Init(_config, _capacityData);

            Unsubscribe(nameof(OnPlayerSleep));
            Unsubscribe(nameof(OnPlayerSleepEnded));

            if (_config.GUI.Enabled)
            {
                AddCovalenceCommand("backpackgui", nameof(ToggleBackpackGUICommand));
            }
            else
            {
                Unsubscribe(nameof(OnPlayerConnected));
                Unsubscribe(nameof(OnNpcConversationStart));
                Unsubscribe(nameof(OnNpcConversationEnded));
            }
        }

        private void OnServerInitialized()
        {
            _immortalProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
            _immortalProtection.name = "BackpacksProtection";
            _immortalProtection.Add(1);

            CheckBackpackButtonPlugin();
            RegisterAsItemSupplier();

            if (_config.GUI.Enabled)
            {
                Subscribe(nameof(OnPlayerSleep));
                Subscribe(nameof(OnPlayerSleepEnded));
                Subscribe(nameof(OnPlayerConnected));
                Subscribe(nameof(OnNpcConversationStart));
                Subscribe(nameof(OnNpcConversationEnded));

                foreach (var player in BasePlayer.activePlayerList)
                {
                    MaybeCreateButtonUi(player);
                }
            }
        }

        private void Unload()
        {
            UnityEngine.Object.Destroy(_immortalProtection);

            RestartSaveRoutine(async: false, keepInUseBackpacks: false);

            BackpackNetworkController.ResetNetworkGroupId();

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyButtonUi(player);
            }

            PoolUtils.ResizePools(empty: true);
        }

        private void OnNewSave(string filename)
        {
            if (_config.BackpackSize.DynamicSize is { Enabled: true, CapacityResetOptions.Enabled: true })
            {
                _capacityData.Clear();
                if (_capacityData.SaveIfChanged())
                {
                    LogWarning("Dynamic size data has been reset.");
                }
            }

            if (_config.ClearOnWipe.Enabled)
            {
                _backpackManager.ClearCache();

                IEnumerable<string> backpackFileNameList;
                try
                {
                    backpackFileNameList = Interface.Oxide.DataFileSystem.GetFiles(Name)
                        .Select(fn => fn.Split(Path.DirectorySeparatorChar).Last()
                            .Replace(".json", string.Empty));
                }
                catch (DirectoryNotFoundException)
                {
                    // No backpacks to clear.
                    return;
                }

                var retainedDueToContents = 0;
                var retainedDueToPreferences = 0;
                var deletedBackpackFiles = 0;

                foreach (var backpackFileName in backpackFileNameList)
                {
                    if (!ulong.TryParse(backpackFileName, out var userId))
                        continue;

                    var backpack = _backpackManager.GetBackpackIfExists(userId);
                    if (backpack == null)
                        continue;

                    backpack.EraseContents(_config.ClearOnWipe.GetForPlayer(backpackFileName));

                    // Only delete the backpack data file if it's empty and has no saved preferences.
                    if (backpack.HasItems || backpack.HasPreferences)
                    {
                        backpack.SaveIfChanged();

                        if (backpack.HasItems)
                        {
                            retainedDueToContents++;
                        }
                        else if (backpack.HasPreferences)
                        {
                            retainedDueToPreferences++;
                        }
                    }
                    else
                    {
                        _backpackManager.DeleteBackpackFile(userId);
                        deletedBackpackFiles++;
                    }
                }

                _backpackManager.ClearCache();

                var logMessage =
                    "New save created. Backpacks were wiped according to the config and player permissions.";
                if (deletedBackpackFiles > 0)
                {
                    logMessage +=
                        $"\n- {deletedBackpackFiles} file(s) were deleted because those backpacks are now empty.";
                }

                if (retainedDueToContents > 0)
                {
                    logMessage +=
                        $"\n- {retainedDueToContents} file(s) were retained because those backpacks were not empty after applying the player's wipe ruleset.";
                }

                if (retainedDueToPreferences > 0)
                {
                    logMessage +=
                        $"\n- {retainedDueToPreferences} file(s) were retained even though those backpacks are empty because they contain player gather/retrieve preferences.";
                }

                LogWarning(logMessage);
            }
        }

        private void OnServerSave()
        {
            RestartSaveRoutine(async: true, keepInUseBackpacks: true);
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            switch (plugin.Name)
            {
                case nameof(BackpackButton):
                    CheckBackpackButtonPlugin();
                    break;
                case nameof(ItemRetriever):
                    RegisterAsItemSupplier();
                    break;
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            _subscriberManager.RemoveSubscriber(plugin);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            _capacityManager.ForgetCachedCapacity(player.userID);
            _backpackManager.GetBackpackIfCached(player.userID)?.NetworkController?.Unsubscribe(player);
        }

        // Handle player death by normal means.
        private void OnEntityDeath(BasePlayer player, HitInfo info) =>
            OnEntityKill(player);

        // Handle player death while sleeping in a safe zone.
        private void OnEntityKill(BasePlayer player)
        {
            if (player.IsNpc)
                return;

            DestroyButtonUi(player);

            if (!_backpackManager.HasBackpack(player.userID))
                return;

            if (permission.UserHasPermission(player.UserIDString, KeepOnDeathPermission))
            {
                #if DEBUG_DROP_ON_DEATH
                LogWarning($"[DEBUG_DROP_ON_DEATH] [Player {player.UserIDString}] Backpack not dropped because the player has the {KeepOnDeathPermission} permission.");
                #endif
                return;
            }

            if (_config.EraseOnDeath)
            {
                _backpackManager.TryEraseForPlayer(player.userID);
            }
            else if (_config.DropOnDeath)
            {
                _backpackManager.Drop(player.userID, player.transform.position);
            }
            else
            {
                #if DEBUG_DROP_ON_DEATH
                LogWarning($"[DEBUG_DROP_ON_DEATH] [Player {player.UserIDString}] Backpack not dropped because \"Drop on Death (true/false)\" is set to false in the config.");
                #endif
            }
        }

        private void OnGroupPermissionGranted(string groupName, string perm)
        {
            if (!perm.StartsWith("backpacks"))
                return;

            if (perm.StartsWith(SizePermission) || perm.StartsWith(UsagePermission) || perm.StartsWith(CapacityProfilePermission))
            {
                _backpackManager.HandleCapacityPermissionChangedForGroup(groupName);
            }
            else if (perm.StartsWith(RestrictionRuleset.FullPermissionPrefix) || perm.Equals(LegacyNoBlacklistPermission))
            {
                _backpackManager.HandleRestrictionPermissionChangedForGroup(groupName);
            }
            else if (perm.Equals(GatherPermission))
            {
                _backpackManager.HandleGatherPermissionChangedForGroup(groupName);
            }
            else if (perm.Equals(RetrievePermission))
            {
                _backpackManager.HandleRetrievePermissionChangedForGroup(groupName);
            }
            else if (_config.GUI.Enabled && perm.Equals(GUIPermission))
            {
                var groupName2 = groupName;
                foreach (var player in BasePlayer.activePlayerList.Where(p => permission.UserHasGroup(p.UserIDString, groupName2)))
                {
                    CreateOrDestroyButtonUi(player);
                }
            }
        }

        private void OnGroupPermissionRevoked(string groupName, string perm)
        {
            OnGroupPermissionGranted(groupName, perm);
        }

        private void OnUserPermissionGranted(string userId, string perm)
        {
            if (!perm.StartsWith("backpacks"))
                return;

            if (perm.StartsWith(SizePermission) || perm.StartsWith(UsagePermission) || perm.StartsWith(CapacityProfilePermission))
            {
                _backpackManager.HandleCapacityPermissionChangedForUser(userId);
            }
            else if (perm.StartsWith(RestrictionRuleset.FullPermissionPrefix) || perm.Equals(LegacyNoBlacklistPermission))
            {
                _backpackManager.HandleRestrictionPermissionChangedForUser(userId);
            }
            else if (perm.Equals(GatherPermission))
            {
                _backpackManager.HandleGatherPermissionChangedForUser(userId);
            }
            else if (perm.Equals(RetrievePermission))
            {
                _backpackManager.HandleRetrievePermissionChangedForUser(userId);
            }
            else if (_config.GUI.Enabled && perm.Equals(GUIPermission))
            {
                var player = BasePlayer.Find(userId);
                if (player != null)
                {
                    CreateOrDestroyButtonUi(player);
                }
            }
        }

        private void OnUserPermissionRevoked(string userId, string perm)
        {
            OnUserPermissionGranted(userId, perm);
        }

        private void OnUserGroupAdded(string userId, string groupName)
        {
            _backpackManager.HandleGroupChangeForUser(userId);
        }

        private void OnUserGroupRemoved(string userId, string groupName)
        {
            _backpackManager.HandleGroupChangeForUser(userId);
        }

        // Only subscribed while the GUI button is enabled.
        private void OnPlayerConnected(BasePlayer player) => MaybeCreateButtonUi(player);

        private void OnPlayerRespawned(BasePlayer player)
        {
            // People reported NRE on Carbon framework, meaning the player is somehow null, unknown root cause.
            if (player == null)
                return;

            MaybeCreateButtonUi(player);
            _backpackManager.GetBackpackIfCached(player.userID)?.PauseGatherMode(1f);
        }

        // Only subscribed while the GUI button is enabled.
        private void OnPlayerSleepEnded(BasePlayer player) => OnPlayerRespawned(player);

        // Only subscribed while the GUI button is enabled.
        private void OnPlayerSleep(BasePlayer player) => DestroyButtonUi(player);

        // Only subscribed while the GUI button is enabled.
        private void OnNpcConversationStart(NPCTalking npcTalking, BasePlayer player, ConversationData conversationData)
        {
            // This delay can be removed in the future if an OnNpcConversationStarted hook is created.
            NextTick(() =>
            {
                // Verify the conversation started, since another plugin may have blocked it.
                if (!npcTalking.conversingPlayers.Contains(player))
                    return;

                DestroyButtonUi(player);
            });
        }

        // Only subscribed while the GUI button is enabled.
        private void OnNpcConversationEnded(NPCTalking npcTalking, BasePlayer player) => MaybeCreateButtonUi(player);

        private void OnNetworkSubscriptionsUpdate(Networkable networkable, List<Network.Visibility.Group> groupsToAdd, List<Network.Visibility.Group> groupsToRemove)
        {
            if (groupsToRemove == null)
                return;

            for (var i = groupsToRemove.Count - 1; i >= 0; i--)
            {
                var group = groupsToRemove[i];
                if (BackpackNetworkController.IsBackpackNetworkGroup(group))
                {
                    // Prevent automatically unsubscribing from backpack network groups.
                    // This allows the subscriptions to persist while players move around.
                    groupsToRemove.Remove(group);
                }
            }
        }

        #endregion

        #region API

        private class ApiInstance
        {
            public readonly Dictionary<string, object> ApiWrapper;

            private readonly Backpacks _plugin;
            private BackpackManager _backpackManager => _plugin._backpackManager;

            public ApiInstance(Backpacks plugin)
            {
                _plugin = plugin;

                ApiWrapper = new Dictionary<string, object>
                {
                    [nameof(AddSubscriber)] = new Action<Plugin, Dictionary<string, object>>(AddSubscriber),
                    [nameof(RemoveSubscriber)] = new Action<Plugin>(RemoveSubscriber),
                    [nameof(GetExistingBackpacks)] = new Func<Dictionary<ulong, ItemContainer>>(GetExistingBackpacks),
                    [nameof(EraseBackpack)] = new Action<ulong>(EraseBackpack),
                    [nameof(DropBackpack)] = new Func<BasePlayer, List<DroppedItemContainer>, DroppedItemContainer>(DropBackpack),
                    [nameof(GetBackpackOwnerId)] = new Func<ItemContainer, ulong>(GetBackpackOwnerId),
                    [nameof(IsBackpackLoaded)] = new Func<BasePlayer, bool>(IsBackpackLoaded),
                    [nameof(IsDynamicCapacityEnabled)] = new Func<bool>(IsDynamicCapacityEnabled),
                    [nameof(GetBackpackCapacity)] = new Func<BasePlayer, int>(GetBackpackCapacity),
                    [nameof(GetBackpackCapacityById)] = new Func<ulong, string, int>(GetBackpackCapacityById),
                    [nameof(GetBackpackInitialCapacity)] = new Func<BasePlayer, int>(GetBackpackInitialCapacity),
                    [nameof(GetBackpackMaxCapacity)] = new Func<BasePlayer, int>(GetBackpackMaxCapacity),
                    [nameof(AddBackpackCapacity)] = new Func<BasePlayer, int, int>(AddBackpackCapacity),
                    [nameof(SetBackpackCapacity)] = new Func<BasePlayer, int, int>(SetBackpackCapacity),
                    [nameof(IsBackpackGathering)] = new Func<BasePlayer, bool>(IsBackpackGathering),
                    [nameof(IsBackpackRetrieving)] = new Func<BasePlayer, bool>(IsBackpackRetrieving),
                    [nameof(GetBackpackContainer)] = new Func<ulong, ItemContainer>(GetBackpackContainer),
                    [nameof(GetBackpackItemAmount)] = new Func<ulong, int, ulong, int>(GetBackpackItemAmount),
                    [nameof(TryOpenBackpack)] = new Func<BasePlayer, ulong, bool>(TryOpenBackpack),
                    [nameof(TryOpenBackpackContainer)] = new Func<BasePlayer, ulong, ItemContainer, bool>(TryOpenBackpackContainer),
                    [nameof(TryOpenBackpackPage)] = new Func<BasePlayer, ulong, int, bool>(TryOpenBackpackPage),
                    [nameof(SumBackpackItems)] = new Func<ulong, Dictionary<string, object>, int>(SumBackpackItems),
                    [nameof(CountBackpackItems)] = new Func<ulong, Dictionary<string, object>, int>(CountBackpackItems),
                    [nameof(TakeBackpackItems)] = new Func<ulong, Dictionary<string, object>, int, List<Item>, int>(TakeBackpackItems),
                    [nameof(MutateBackpackItems)] = new Func<ulong, Dictionary<string, object>, Dictionary<string, object>, int>(MutateBackpackItems),
                    [nameof(TryDepositBackpackItem)] = new Func<ulong, Item, bool>(TryDepositBackpackItem),
                    [nameof(WriteBackpackContentsFromJson)] = new Action<ulong, string>(WriteBackpackContentsFromJson),
                    [nameof(ReadBackpackContentsAsJson)] = new Func<ulong, string>(ReadBackpackContentsAsJson),
                };
            }

            public void AddSubscriber(Plugin plugin, Dictionary<string, object> spec)
            {
                if (plugin == null)
                    throw new ArgumentNullException(nameof(plugin));

                if (spec == null)
                    throw new ArgumentNullException(nameof(spec));

                _plugin._subscriberManager.AddSubscriber(plugin, spec);
            }

            public void RemoveSubscriber(Plugin plugin)
            {
                if (plugin == null)
                    throw new ArgumentNullException(nameof(plugin));

                _plugin._subscriberManager.RemoveSubscriber(plugin);
            }

            public Dictionary<ulong, ItemContainer> GetExistingBackpacks()
            {
                return _backpackManager.GetAllCachedContainers();
            }

            public void EraseBackpack(ulong userId)
            {
                _backpackManager.TryEraseForPlayer(userId);
            }

            public DroppedItemContainer DropBackpack(BasePlayer player, List<DroppedItemContainer> collect)
            {
                var backpack = _backpackManager.GetBackpackIfExists(player.userID);
                if (backpack == null)
                    return null;

                return _backpackManager.Drop(player.userID, player.transform.position, collect);
            }

            public ulong GetBackpackOwnerId(ItemContainer container)
            {
                return _backpackManager.GetCachedBackpackForContainer(container)?.OwnerId ?? 0;
            }

            public bool IsBackpackLoaded(BasePlayer player)
            {
                return _backpackManager.GetBackpackIfCached(player.userID) != null;
            }

            public bool IsDynamicCapacityEnabled()
            {
                return _plugin._config.BackpackSize.DynamicSize.Enabled;
            }

            public int GetBackpackCapacity(BasePlayer player)
            {
                return _plugin._capacityManager.GetCapacity(player.userID, player.UserIDString);
            }
            
            public int GetBackpackCapacityById(ulong playerID, string playerIDString)
            {
                return _plugin._capacityManager.GetCapacity(playerID, playerIDString);
            }

            public int GetBackpackInitialCapacity(BasePlayer player)
            {
                return _plugin._capacityManager.GetInitialCapacity(player.userID, player.UserIDString);
            }

            public int GetBackpackMaxCapacity(BasePlayer player)
            {
                return _plugin._capacityManager.GetMaxCapacity(player.userID, player.UserIDString);
            }

            public int AddBackpackCapacity(BasePlayer player, int amount)
            {
                return _plugin._capacityManager.AddCapacity(player, amount);
            }

            public int SetBackpackCapacity(BasePlayer player, int capacity)
            {
                return _plugin._capacityManager.SetCapacity(player, capacity);
            }

            public bool IsBackpackGathering(BasePlayer player)
            {
                return _backpackManager.GetBackpackIfCached(player.userID)?.IsGathering ?? false;
            }

            public bool IsBackpackRetrieving(BasePlayer player)
            {
                return _backpackManager.GetBackpackIfCached(player.userID)?.IsRetrieving ?? false;
            }

            public ItemContainer GetBackpackContainer(ulong ownerId)
            {
                return _backpackManager.GetBackpackIfExists(ownerId)?.GetContainer(ensureContainer: true);
            }

            public int GetBackpackItemAmount(ulong ownerId, int itemId, ulong skinId)
            {
                var itemQuery = new ItemQuery { ItemId = itemId, SkinId = skinId };
                return _backpackManager.GetBackpackIfExists(ownerId)?.SumItems(ref itemQuery) ?? 0;
            }

            public bool TryOpenBackpack(BasePlayer player, ulong ownerId)
            {
                return _backpackManager.TryOpenBackpack(player, ownerId);
            }

            public bool TryOpenBackpackContainer(BasePlayer player, ulong ownerId, ItemContainer container)
            {
                return _backpackManager.TryOpenBackpackContainer(player, ownerId, container);
            }

            public bool TryOpenBackpackPage(BasePlayer player, ulong ownerId, int page)
            {
                return _backpackManager.TryOpenBackpackPage(player, ownerId, page);
            }

            public int SumBackpackItems(ulong ownerId, Dictionary<string, object> dict)
            {
                var itemQuery = ItemQuery.Parse(dict);
                return _backpackManager.GetBackpackIfExists(ownerId)?.SumItems(ref itemQuery) ?? 0;
            }

            public int CountBackpackItems(ulong ownerId, Dictionary<string, object> dict)
            {
                var backpack = _backpackManager.GetBackpackIfExists(ownerId);
                if (backpack == null)
                    return 0;

                if (dict == null)
                    return backpack.ItemCount;

                var itemQuery = ItemQuery.Parse(dict);
                return backpack.CountItems(ref itemQuery);
            }

            public int TakeBackpackItems(ulong ownerId, Dictionary<string, object> dict, int amount, List<Item> collect)
            {
                var itemQuery = ItemQuery.Parse(dict);
                return _backpackManager.GetBackpackIfExists(ownerId)?.TakeItems(ref itemQuery, amount, collect) ?? 0;
            }

            public int MutateBackpackItems(ulong ownerId, Dictionary<string, object> itemQueryDict, Dictionary<string, object> mutationRequestDict)
            {
                var itemQuery = ItemQuery.Parse(itemQueryDict);
                var mutationRequest = MutationRequest.Parse(mutationRequestDict);
                return _backpackManager.GetBackpackIfExists(ownerId)?.MutateItems(ref itemQuery, ref mutationRequest) ?? 0;
            }

            public bool TryDepositBackpackItem(ulong ownerId, Item item)
            {
                return _backpackManager.GetBackpack(ownerId).TryDepositItem(item);
            }

            public void WriteBackpackContentsFromJson(ulong ownerId, string json)
            {
                _backpackManager.GetBackpack(ownerId).WriteContentsFromJson(json);
            }

            public string ReadBackpackContentsAsJson(ulong ownerId)
            {
                return _backpackManager.GetBackpackIfExists(ownerId)?.SerializeContentsAsJson();
            }
        }

        [HookMethod(nameof(API_GetApi))]
        public Dictionary<string, object> API_GetApi()
        {
            return _api.ApiWrapper;
        }

        [HookMethod(nameof(API_AddSubscriber))]
        public void API_AddSubscriber(Plugin plugin, Dictionary<string, object> spec)
        {
            _api.AddSubscriber(plugin, spec);
        }

        [HookMethod(nameof(API_RemoveSubscriber))]
        public void API_RemoveSubscriber(Plugin plugin)
        {
            _api.RemoveSubscriber(plugin);
        }

        // Deprecated, only returns container for first page. Use higher level APIs instead.
        [HookMethod(nameof(API_GetExistingBackpacks))]
        public Dictionary<ulong, ItemContainer> API_GetExistingBackpacks()
        {
            return _api.GetExistingBackpacks();
        }

        [HookMethod(nameof(API_EraseBackpack))]
        public void API_EraseBackpack(ulong userId)
        {
            _api.EraseBackpack(userId);
        }
        [HookMethod(nameof(API_EraseBackpack))]
        public void API_EraseBackpack(EncryptedValue<ulong> userId)
        {
            _api.EraseBackpack(userId);
        }

        [HookMethod(nameof(API_DropBackpack))]
        public DroppedItemContainer API_DropBackpack(BasePlayer player, List<DroppedItemContainer> collect = null)
        {
            return _api.DropBackpack(player, collect);
        }

        [HookMethod(nameof(API_GetBackpackOwnerId))]
        public object API_GetBackpackOwnerId(ItemContainer container)
        {
            return ObjectCache.Get(_api.GetBackpackOwnerId(container));
        }

        [HookMethod(nameof(API_IsBackpackLoaded))]
        public object API_IsBackpackLoaded(BasePlayer player)
        {
            return ObjectCache.Get(_api.IsBackpackLoaded(player));
        }

        [HookMethod(nameof(API_IsDynamicCapacityEnabled))]
        public object API_IsDynamicCapacityEnabled(BasePlayer player)
        {
            return ObjectCache.Get(_api.IsDynamicCapacityEnabled());
        }

        [HookMethod(nameof(API_GetBackpackCapacity))]
        public object API_GetBackpackCapacity(BasePlayer player)
        {
            return ObjectCache.Get(_api.GetBackpackCapacity(player));
        }
        
        [HookMethod(nameof(API_GetBackpackCapacityById))]
        public object API_GetBackpackCapacityById(ulong playerID, string playerIDString)
        {
            return ObjectCache.Get(_api.GetBackpackCapacityById(playerID, playerIDString));
        }
        [HookMethod(nameof(API_GetBackpackCapacityById))]
        public object API_GetBackpackCapacityById(EncryptedValue<ulong> playerID, string playerIDString)
        {
            return ObjectCache.Get(_api.GetBackpackCapacityById(playerID, playerIDString));
        }

        [HookMethod(nameof(API_GetBackpackInitialCapacity))]
        public object API_GetBackpackInitialCapacity(BasePlayer player)
        {
            return ObjectCache.Get(_api.GetBackpackInitialCapacity(player));
        }

        [HookMethod(nameof(API_GetBackpackMaxCapacity))]
        public object API_GetBackpackMaxCapacity(BasePlayer player)
        {
            return ObjectCache.Get(_api.GetBackpackMaxCapacity(player));
        }

        [HookMethod(nameof(API_AddBackpackCapacity))]
        public object API_AddBackpackCapacity(BasePlayer player, int amount)
        {
            return ObjectCache.Get(_api.AddBackpackCapacity(player, amount));
        }

        [HookMethod(nameof(API_SetBackpackCapacity))]
        public object API_SetBackpackCapacity(BasePlayer player, int capacity)
        {
            return ObjectCache.Get(_api.SetBackpackCapacity(player, capacity));
        }

        [HookMethod(nameof(API_IsBackpackGathering))]
        public object API_IsBackpackGathering(BasePlayer player)
        {
            return ObjectCache.Get(_api.IsBackpackGathering(player));
        }

        [HookMethod(nameof(API_IsBackpackRetrieving))]
        public object API_IsBackpackRetrieving(BasePlayer player)
        {
            return ObjectCache.Get(_api.IsBackpackRetrieving(player));
        }

        // Deprecated, only returns container for first page. Use higher level APIs instead.
        [HookMethod(nameof(API_GetBackpackContainer))]
        public ItemContainer API_GetBackpackContainer(ulong ownerId)
        {
            return _api.GetBackpackContainer(ownerId);
        }
        [HookMethod(nameof(API_GetBackpackContainer))]
        public ItemContainer API_GetBackpackContainer(EncryptedValue<ulong> ownerId)
        {
            return _api.GetBackpackContainer(ownerId);
        }

        [HookMethod(nameof(API_GetBackpackItemAmount))]
        public int API_GetBackpackItemAmount(ulong ownerId, int itemId, ulong skinId = 0)
        {
            return _api.GetBackpackItemAmount(ownerId, itemId, skinId);
        }
        [HookMethod(nameof(API_GetBackpackItemAmount))]
        public int API_GetBackpackItemAmount(EncryptedValue<ulong> ownerId, int itemId, ulong skinId = 0)
        {
            return _api.GetBackpackItemAmount(ownerId, itemId, skinId);
        }

        [HookMethod(nameof(API_TryOpenBackpack))]
        public object API_TryOpenBackpack(BasePlayer player, ulong ownerId = 0)
        {
            return ObjectCache.Get(_api.TryOpenBackpack(player, ownerId));
        }
        [HookMethod(nameof(API_TryOpenBackpack))]
        public object API_TryOpenBackpack(BasePlayer player, EncryptedValue<ulong> ownerId = default)
        {
            return ObjectCache.Get(_api.TryOpenBackpack(player, ownerId));
        }

        [HookMethod(nameof(API_TryOpenBackpackContainer))]
        public object API_TryOpenBackpackContainer(BasePlayer player, ulong ownerId, ItemContainer container)
        {
            return ObjectCache.Get(_api.TryOpenBackpackContainer(player, ownerId, container));
        }
        [HookMethod(nameof(API_TryOpenBackpackContainer))]
        public object API_TryOpenBackpackContainer(BasePlayer player, EncryptedValue<ulong> ownerId, ItemContainer container)
        {
            return ObjectCache.Get(_api.TryOpenBackpackContainer(player, ownerId, container));
        }

        [HookMethod(nameof(API_TryOpenBackpackPage))]
        public object API_TryOpenBackpackPage(BasePlayer player, ulong ownerId = 0, int page = 0)
        {
            return ObjectCache.Get(_api.TryOpenBackpackPage(player, ownerId, page));
        }
        [HookMethod(nameof(API_TryOpenBackpackPage))]
        public object API_TryOpenBackpackPage(BasePlayer player, EncryptedValue<ulong> ownerId = default, int page = 0)
        {
            return ObjectCache.Get(_api.TryOpenBackpackPage(player, ownerId, page));
        }

        [HookMethod(nameof(API_SumBackpackItems))]
        public object API_SumBackpackItems(ulong ownerId, Dictionary<string, object> dict)
        {
            return ObjectCache.Get(_api.SumBackpackItems(ownerId, dict));
        }
        [HookMethod(nameof(API_SumBackpackItems))]
        public object API_SumBackpackItems(EncryptedValue<ulong> ownerId, Dictionary<string, object> dict)
        {
            return ObjectCache.Get(_api.SumBackpackItems(ownerId, dict));
        }

        [HookMethod(nameof(API_CountBackpackItems))]
        public object API_CountBackpackItems(ulong ownerId, Dictionary<string, object> dict)
        {
            return ObjectCache.Get(_api.CountBackpackItems(ownerId, dict));
        }
        [HookMethod(nameof(API_CountBackpackItems))]
        public object API_CountBackpackItems(EncryptedValue<ulong> ownerId, Dictionary<string, object> dict)
        {
            return ObjectCache.Get(_api.CountBackpackItems(ownerId, dict));
        }

        [HookMethod(nameof(API_TakeBackpackItems))]
        public object API_TakeBackpackItems(ulong ownerId, Dictionary<string, object> dict, int amount, List<Item> collect)
        {
            return ObjectCache.Get(_api.TakeBackpackItems(ownerId, dict, amount, collect));
        }
        [HookMethod(nameof(API_TakeBackpackItems))]
        public object API_TakeBackpackItems(EncryptedValue<ulong> ownerId, Dictionary<string, object> dict, int amount, List<Item> collect)
        {
            return ObjectCache.Get(_api.TakeBackpackItems(ownerId, dict, amount, collect));
        }

        [HookMethod(nameof(API_MutateBackpackItems))]
        public object API_MutateBackpackItems(ulong ownerId, Dictionary<string, object> itemQueryDict, Dictionary<string, object> mutationRequestDict)
        {
            return ObjectCache.Get(_api.MutateBackpackItems(ownerId, itemQueryDict, mutationRequestDict));
        }
        [HookMethod(nameof(API_MutateBackpackItems))]
        public object API_MutateBackpackItems(EncryptedValue<ulong> ownerId, Dictionary<string, object> itemQueryDict, Dictionary<string, object> mutationRequestDict)
        {
            return ObjectCache.Get(_api.MutateBackpackItems(ownerId, itemQueryDict, mutationRequestDict));
        }

        [HookMethod(nameof(API_TryDepositBackpackItem))]
        public object API_TryDepositBackpackItem(ulong ownerId, Item item)
        {
            return ObjectCache.Get(_api.TryDepositBackpackItem(ownerId, item));
        }
        [HookMethod(nameof(API_TryDepositBackpackItem))]
        public object API_TryDepositBackpackItem(EncryptedValue<ulong> ownerId, Item item)
        {
            return ObjectCache.Get(_api.TryDepositBackpackItem(ownerId, item));
        }

        [HookMethod(nameof(API_WriteBackpackContentsFromJson))]
        public void API_WriteBackpackContentsFromJson(ulong ownerId, string json)
        {
            _api.WriteBackpackContentsFromJson(ownerId, json);
        }
        [HookMethod(nameof(API_WriteBackpackContentsFromJson))]
        public void API_WriteBackpackContentsFromJson(EncryptedValue<ulong> ownerId, string json)
        {
            _api.WriteBackpackContentsFromJson(ownerId, json);
        }

        [HookMethod(nameof(API_ReadBackpackContentsAsJson))]
        public object API_ReadBackpackContentsAsJson(ulong ownerId)
        {
            return _api.ReadBackpackContentsAsJson(ownerId);
        }
        [HookMethod(nameof(API_ReadBackpackContentsAsJson))]
        public object API_ReadBackpackContentsAsJson(EncryptedValue<ulong> ownerId)
        {
            return _api.ReadBackpackContentsAsJson(ownerId);
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object CanOpenBackpack(BasePlayer looter, ulong ownerId)
            {
                return Interface.CallHook("CanOpenBackpack", looter, ObjectCache.Get(ownerId));
            }

            public static void OnBackpackClosed(BasePlayer looter, ulong ownerId, ItemContainer container)
            {
                Interface.CallHook("OnBackpackClosed", looter, ObjectCache.Get(ownerId), container);
            }

            public static void OnBackpackOpened(BasePlayer looter, ulong ownerId, ItemContainer container)
            {
                Interface.CallHook("OnBackpackOpened", looter, ObjectCache.Get(ownerId), container);
            }

            public static object CanDropBackpack(ulong ownerId, Vector3 position)
            {
                return Interface.CallHook("CanDropBackpack", ObjectCache.Get(ownerId), position);
            }

            public static void OnBackpackDropped(ulong ownerId, List<DroppedItemContainer> droppedBackpackList)
            {
                Interface.CallHook("OnBackpackDropped", ownerId, droppedBackpackList);
            }

            public static object CanEraseBackpack(ulong ownerId)
            {
                return Interface.CallHook("CanEraseBackpack", ObjectCache.Get(ownerId));
            }

            public static object CanBackpackAcceptItem(ulong ownerId, ItemContainer container, Item item)
            {
                return Interface.CallHook("CanBackpackAcceptItem", ObjectCache.Get(ownerId), container, item);
            }
        }

        #endregion

        #region Commands

        [Command("backpack", "backpack.open")]
        private void BackpackOpenCommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanInteract(player, out var basePlayer)
                || !VerifyHasPermission(player, UsagePermission))
                return;

            OpenBackpack(
                basePlayer,
                IsKeyBindArg(args.LastOrDefault()),
                ParsePageArg(args.FirstOrDefault()),
                wrapAround: false
            );
        }

        [Command("backpack.next")]
        private void BackpackNextCommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanInteract(player, out var basePlayer)
                || !VerifyHasPermission(player, UsagePermission))
                return;

            OpenBackpack(
                basePlayer,
                IsKeyBindArg(args.LastOrDefault())
            );
        }

        [Command("backpack.previous", "backpack.prev")]
        private void BackpackPreviousCommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanInteract(player, out var basePlayer)
                || !VerifyHasPermission(player, UsagePermission))
                return;

            OpenBackpack(
                basePlayer,
                IsKeyBindArg(args.LastOrDefault()),
                forward: false
            );
        }

        [Command("backpack.fetch")]
        private void BackpackFetchCommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanInteract(player, out var basePlayer)
                || !VerifyHasPermission(player, FetchPermission))
                return;

            if (args.Length < 2)
            {
                ReplyToPlayer(player, LangEntry.BackpackFetchSyntax);
                return;
            }

            if (!VerifyCanOpenBackpack(basePlayer, basePlayer.userID))
                return;

            if (!VerifyValidItem(player, args[0], out var itemDefinition))
                return;

            if (!int.TryParse(args[1], out var desiredAmount) || desiredAmount < 1)
            {
                ReplyToPlayer(player, LangEntry.InvalidItemAmount);
                return;
            }

            var itemLocalizedName = itemDefinition.displayName.translated;
            var backpack = _backpackManager.GetBackpack(basePlayer.userID);

            var itemQuery = new ItemQuery { ItemDefinition = itemDefinition };

            var quantityInBackpack = backpack.SumItems(ref itemQuery);
            if (quantityInBackpack == 0)
            {
                ReplyToPlayer(player, LangEntry.ItemNotInBackpack, itemLocalizedName);
                return;
            }

            if (desiredAmount > quantityInBackpack)
            {
                desiredAmount = quantityInBackpack;
            }

            var amountTransferred = backpack.FetchItems(basePlayer, ref itemQuery, desiredAmount);
            if (amountTransferred <= 0)
            {
                ReplyToPlayer(player, LangEntry.FetchFailed, itemLocalizedName);
                return;
            }

            ReplyToPlayer(player, LangEntry.ItemsFetched, amountTransferred, itemLocalizedName);
        }

        [Command("backpack.erase")]
        private void EraseBackpackCommand(IPlayer player, string cmd, string[] args)
        {
            if (!player.IsServer)
                return;

            if (args.Length < 1 || !ulong.TryParse(args[0], out var userId))
            {
                player.Reply($"Syntax: {cmd} <id>");
                return;
            }

            if (!_backpackManager.TryEraseForPlayer(userId))
            {
                LogWarning($"Player {userId.ToString()} has no backpack to erase.");
                return;
            }

            LogWarning($"Erased backpack for player {userId.ToString()}.");
        }

        [Command("viewbackpack")]
        private void ViewBackpackCommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanInteract(player, out var basePlayer)
                || !VerifyHasPermission(player, AdminPermission))
                return;

            if (args.Length < 1)
            {
                ReplyToPlayer(player, LangEntry.ViewBackpackSyntax);
                return;
            }

            if (!VerifyTargetPlayer(player, args[0], out var targetPlayerId, out var targetPlayerIdString))
                return;

            if (permission.UserHasPermission(targetPlayerIdString, AdminProtectedPermission))
            {
                ReplyToPlayer(player, LangEntry.ViewBackpackProtected);
                return;
            }

            OpenBackpack(
                basePlayer,
                IsKeyBindArg(args.LastOrDefault()),
                ParsePageArg(args.ElementAtOrDefault(1)),
                desiredOwnerId: targetPlayerId
            );
        }

        // Alias for older versions of Player Administration (which should ideally not be calling this method directly).
        private void ViewBackpack(BasePlayer player, string cmd, string[] args) =>
            ViewBackpackCommand(player.IPlayer, cmd, args);

        [Command("backpack.addsize")]
        private void AddBackpackCapacityCommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyHasPermission(player, AdminPermission))
                return;

            if (args.Length < 2 || !int.TryParse(args[1], out var amount))
            {
                ReplyToPlayer(player, LangEntry.BackpackCapacitySyntax, cmd);
                return;
            }

            if (!VerifyTargetPlayer(player, args[0], out var targetPlayerId, out var targetPlayerIdString)
                || !VerifyDynamicCapacityEnabled(player))
                return;

            var newCapacity = _capacityManager.AddCapacity(targetPlayerId, targetPlayerIdString, amount);
            ReplyToPlayer(player, LangEntry.ChangeCapacitySuccess, targetPlayerId, newCapacity);
        }

        [Command("backpack.setsize")]
        private void SetBackpackCapacityCommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyHasPermission(player, AdminPermission))
                return;

            if (args.Length < 2 || !int.TryParse(args[1], out var amount))
            {
                ReplyToPlayer(player, LangEntry.BackpackCapacitySyntax, cmd);
                return;
            }

            if (!VerifyTargetPlayer(player, args[0], out var targetPlayerId, out var targetPlayerIdString)
                || !VerifyDynamicCapacityEnabled(player))
                return;

            var newCapacity = _capacityManager.SetCapacity(targetPlayerId, targetPlayerIdString, amount);
            ReplyToPlayer(player, LangEntry.ChangeCapacitySuccess, targetPlayerId, newCapacity);
        }

        private void ToggleBackpackGUICommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyHasPermission(player, GUIPermission))
                return;

            var enabledNow = _preferencesData.ToggleGuiButtonPreference(basePlayer.userID, _config.GUI.EnabledByDefault);
            if (enabledNow)
            {
                MaybeCreateButtonUi(basePlayer);
            }
            else
            {
                DestroyButtonUi(basePlayer);
            }

            ReplyToPlayer(player, LangEntry.ToggledBackpackGUI);
        }

        [Command("backpack.setgathermode")]
        private void SetGatherCommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanInteract(player, out var basePlayer)
                || !VerifyHasPermission(player, UsagePermission)
                || !VerifyHasPermission(player, GatherPermission))
                return;

            var backpack = _backpackManager.GetBackpack(basePlayer.userID);
            if (!backpack.CanGather)
                return;

            if (args.Length < 1 || !TryParseGatherMode(basePlayer, args[0], out var gatherMode))
            {
                ReplyToPlayer(player, LangEntry.SetGatherSyntax, cmd, GetGatherModeDisplayOptions(basePlayer));
                return;
            }

            var oneBasedPageIndex = 1;
            if (args.Length >= 2 && !IsKeyBindArg(args[1]) && !int.TryParse(args[1], out oneBasedPageIndex))
            {
                ReplyToPlayer(player, LangEntry.SetGatherSyntax, cmd, GetGatherModeDisplayOptions(basePlayer));
                return;
            }

            if (oneBasedPageIndex < 1 || oneBasedPageIndex > backpack.PageCount)
            {
                ReplyToPlayer(player, LangEntry.PageOutOfRange, backpack.PageCount);
                return;
            }

            var pageIndex = oneBasedPageIndex - 1;
            if (backpack.GetGatherModeForPage(pageIndex) == gatherMode)
                return;

            backpack.SetGatherModeForPage(basePlayer, pageIndex, gatherMode);
            ReplyToPlayer(player, LangEntry.SetGatherModeSuccess, oneBasedPageIndex, GetGatherModeDisplayString(basePlayer, gatherMode));
        }

        [Command("backpack.ui.togglegather")]
        private void ToggleGatherUICommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer))
                return;

            var lootingContainer = basePlayer.inventory.loot.containers.FirstOrDefault();
            if (lootingContainer == null)
                return;

            if (!_backpackManager.IsBackpack(lootingContainer, out var backpack, out var pageIndex)
                || backpack.OwnerId != basePlayer.userID
                || !backpack.CanGather)
                return;

            backpack.ToggleGatherMode(basePlayer, pageIndex);
        }

        [Command("backpack.ui.toggleretrieve")]
        private void ToggleRetrieveUICommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer))
                return;

            var lootingContainer = basePlayer.inventory.loot.containers.FirstOrDefault();
            if (lootingContainer == null)
                return;

            if (!_backpackManager.IsBackpack(lootingContainer, out var backpack, out var pageIndex)
                || pageIndex > 31
                || backpack.OwnerId != basePlayer.userID
                || !backpack.CanRetrieve)
                return;

            backpack.ToggleRetrieve(basePlayer, pageIndex);
        }

        #endregion

        #region Helper Methods

        public static void LogDebug(string message) => Interface.Oxide.LogDebug($"[Backpacks] {message}");
        public static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Backpacks] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Backpacks] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Backpacks] {message}");

        private static T[] ParseEnumList<T>(string[] list, string errorFormat) where T : struct
        {
            var valueList = new List<T>(list?.Length ?? 0);

            if (list != null)
            {
                foreach (var itemName in list)
                {
                    if (Enum.TryParse(itemName, ignoreCase: true, result: out T result))
                    {
                        valueList.Add(result);
                    }
                    else
                    {
                        LogError(string.Format(errorFormat, itemName));
                    }
                }
            }

            return valueList.ToArray();
        }

        private static bool IsKeyBindArg(string arg)
        {
            return arg == "True";
        }

        private static int ParsePageArg(string arg)
        {
            if (arg == null)
                return -1;

            return int.TryParse(arg, out var pageIndex)
                ? Math.Max(0, pageIndex - 1)
                : -1;
        }

        private static bool HasItemMod<T>(ItemDefinition itemDefinition, out T itemModOfType) where T : ItemMod
        {
            foreach (var itemMod in itemDefinition.itemMods)
            {
                itemModOfType = itemMod as T;
                if (itemModOfType is not null)
                    return true;
            }

            itemModOfType = null;
            return false;
        }

        private static string DetermineLootPanelName(ItemContainer container)
        {
            return (container.entityOwner as StorageContainer)?.panelName
                   ?? (container.entityOwner as ContainerIOEntity)?.lootPanelName
                   ?? (container.entityOwner as LootableCorpse)?.lootPanelName
                   ?? (container.entityOwner as DroppedItemContainer)?.lootPanelName
                   ?? (container.entityOwner as BaseRidableAnimal)?.lootPanelName
                   ?? ResizableLootPanelName;
        }

        private static void ClosePlayerInventory(BasePlayer player)
        {
            player.ClientRPCPlayer(null, player, "OnRespawnInformation");
        }

        private static float CalculateOpenDelay(ItemContainer currentContainer, int nextContainerCapacity, bool isKeyBind = false)
        {
            if (currentContainer != null)
            {
                // Can instantly switch to a smaller container.
                if (nextContainerCapacity <= currentContainer.capacity)
                    return 0;

                // Can instantly switch to a generic resizable loot panel from a different loot panel.
                if (DetermineLootPanelName(currentContainer) != ResizableLootPanelName)
                    return 0;

                // Need a short delay so the generic_resizable loot panel can be redrawn properly.
                return StandardLootDelay;
            }

            // Can open instantly since not looting and chat is assumed to be closed.
            if (isKeyBind)
                return 0;

            // Not opening via key bind, so the chat window may be open.
            // Must delay in case the chat is still closing or else the loot panel may close instantly.
            return StandardLootDelay;
        }

        private static void StartLooting(BasePlayer player, ItemContainer container, StorageContainer entitySource)
        {
            if (player.CanInteract()
                && Interface.CallHook("CanLootEntity", player, entitySource) == null
                && player.inventory.loot.StartLootingEntity(entitySource, doPositionChecks: false))
            {
                player.inventory.loot.AddContainer(container);
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", entitySource.panelName);
            }
        }

        private static ItemContainer GetRootContainer(Item item)
        {
            var container = item.parent;
            if (container == null)
                return null;

            while (container.parent?.parent != null && container.parent != item)
            {
                container = container.parent.parent;
            }

            return container;
        }

        private bool TryParseGatherMode(BasePlayer player, string arg, out GatherMode gatherMode)
        {
            foreach (var enumValue in typeof(GatherMode).GetEnumValues())
            {
                var name = Enum.GetName(typeof(GatherMode), enumValue);
                var gatherModeValue = (GatherMode)enumValue;

                if (StringUtils.EqualsCaseInsensitive(arg, name))
                {
                    gatherMode = gatherModeValue;
                    return true;
                }

                var localizedName = GetGatherModeDisplayString(player, gatherModeValue);
                if (StringUtils.EqualsCaseInsensitive(arg, localizedName, StringComparison.InvariantCultureIgnoreCase))
                {
                    gatherMode = gatherModeValue;
                    return true;
                }
            }

            gatherMode = GatherMode.None;
            return false;
        }

        private string GetGatherModeDisplayOptions(BasePlayer player)
        {
            return string.Join("|", new List<string>
            {
                GetGatherModeDisplayString(player, GatherMode.All),
                GetGatherModeDisplayString(player, GatherMode.Existing),
                GetGatherModeDisplayString(player, GatherMode.None),
            });
        }

        private void SendEffect(BasePlayer player, string effectPrefab)
        {
            if (string.IsNullOrWhiteSpace(effectPrefab))
                return;

            _reusableEffect.Init(Effect.Type.Generic, player, 0, Vector3.zero, Vector3.forward);
            _reusableEffect.pooledString = effectPrefab;
            EffectNetwork.Send(_reusableEffect, player.net.connection);
        }

        private void CheckBackpackButtonPlugin()
        {
            if (BackpackButton == null
                || _config.UsingDefaults
                || !_config.GUI.Enabled)
                return;

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyButtonUi(player);
            }

            _config.GUI.Enabled = false;
            SaveConfig();
            LogWarning($"Disabled GUI button in the config because the {nameof(BackpackButton)} plugin was detected.");
        }

        private void RegisterAsItemSupplier()
        {
            ItemRetriever?.Call("API_AddSupplier", this, new Dictionary<string, object>
            {
                ["FindPlayerItems"] = new Action<BasePlayer, Dictionary<string, object>, List<Item>>((player, rawItemQuery, collect) =>
                {
                    var backpack = _backpackManager.GetBackpackIfCached(player.userID);
                    if (backpack is not { CanRetrieve: true } || !backpack.CanAccess)
                        return;

                    var itemQuery = ItemQuery.Parse(rawItemQuery);
                    backpack.FindItems(ref itemQuery, collect, forItemRetriever: true);
                }),

                ["FindPlayerAmmo"] = new Action<BasePlayer, AmmoTypes, List<Item>>((player, ammoType, collect) =>
                {
                    var backpack = _backpackManager.GetBackpackIfCached(player.userID);
                    if (backpack is not { CanRetrieve: true } || !backpack.CanAccess)
                        return;

                    backpack.FindAmmo(ammoType, collect, forItemRetriever: true);
                }),

                ["SumPlayerItems"] = new Func<BasePlayer, Dictionary<string, object>, int>((player, rawItemQuery) =>
                {
                    var backpack = _backpackManager.GetBackpackIfCached(player.userID);
                    if (backpack is not { CanRetrieve: true } || !backpack.CanAccess)
                        return 0;

                    var itemQuery = ItemQuery.Parse(rawItemQuery);
                    return backpack.SumItems(ref itemQuery, forItemRetriever: true);
                }),

                ["TakePlayerItems"] = new Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int>((player, rawItemQuery, amount, collect) =>
                {
                    var backpack = _backpackManager.GetBackpackIfCached(player.userID);
                    if (backpack is not { CanRetrieve: true } || !backpack.CanAccess)
                        return 0;

                    var itemQuery = ItemQuery.Parse(rawItemQuery);
                    return backpack.TakeItems(ref itemQuery, amount, collect, forItemRetriever: true);
                }),

                ["SerializeForNetwork"] = new Action<BasePlayer, List<ProtoBuf.Item>>((player, saveList) =>
                {
                    var backpack = _backpackManager.GetBackpackIfCached(player.userID);
                    // Don't check CanAccess here to save on performance. This may result in minor issues like the
                    // player attempting an action they can't perform.
                    if (backpack is not { CanRetrieve: true })
                        return;

                    backpack.SerializeForNetwork(saveList, forItemRetriever: true);
                }),
            });
        }

        private IEnumerator SaveRoutine(bool async, bool keepInUseBackpacks)
        {
            if (_preferencesData.SaveIfChanged() && async)
                yield return null;

            if (_capacityData.SaveIfChanged() && async)
                yield return null;

            yield return _backpackManager.SaveAllAndKill(async, keepInUseBackpacks);
        }

        private void RestartSaveRoutine(bool async, bool keepInUseBackpacks)
        {
            if (_saveRoutine != null)
            {
                ServerMgr.Instance.StopCoroutine(_saveRoutine);
            }

            ServerMgr.Instance?.StartCoroutine(SaveRoutine(async, keepInUseBackpacks));
        }

        private bool IsLootingBackpack(BasePlayer player, out Backpack backpack, out int pageIndex)
        {
            backpack = null;
            pageIndex = 0;

            var lootingContainer = player.inventory.loot.containers.FirstOrDefault();
            return lootingContainer != null
                   && _backpackManager.IsBackpack(lootingContainer, out backpack, out pageIndex);
        }

        private void OpenBackpackMaybeDelayed(BasePlayer looter, ItemContainer currentContainer, Backpack backpack, int pageIndex, bool isKeyBind)
        {
            var pageCapacity = backpack.GetAllowedPageCapacityForLooter(looter.userID, pageIndex);

            var delaySeconds = CalculateOpenDelay(currentContainer, pageCapacity, isKeyBind);
            if (delaySeconds > 0)
            {
                if (currentContainer != null)
                {
                    looter.EndLooting();
                    looter.inventory.loot.SendImmediate();
                }

                var ownerId2 = backpack.OwnerId;
                var looter2 = looter;
                var pageIndex2 = pageIndex;

                timer.Once(delaySeconds, () => _backpackManager.TryOpenBackpackPage(looter2, ownerId2, pageIndex2));
                return;
            }

            _backpackManager.TryOpenBackpackPage(looter, backpack.OwnerId, pageIndex);
        }

        private void OpenBackpack(BasePlayer looter, bool isKeyBind, int desiredPageIndex = -1, bool forward = true, bool wrapAround = true, ulong desiredOwnerId = 0)
        {
            var playerLoot = looter.inventory.loot;
            var lootingContainer = playerLoot.containers.FirstOrDefault();

            if (lootingContainer != null)
            {
                if (_backpackManager.IsBackpack(lootingContainer, out var currentBackpack, out var currentPageIndex)
                    && (currentBackpack.OwnerId == desiredOwnerId || desiredOwnerId == 0))
                {
                    var nextPageIndex = currentBackpack.DetermineNextPageIndexForLooter(looter.userID, currentPageIndex, desiredPageIndex, forward, wrapAround, requireContents: false);
                    if (nextPageIndex == currentPageIndex)
                    {
                        if (!wrapAround)
                        {
                            // Close the backpack.
                            looter.EndLooting();
                            ClosePlayerInventory(looter);
                        }
                        return;
                    }

                    var nextPageCapacity = currentBackpack.GetAllowedPageCapacityForLooter(looter.userID, nextPageIndex);
                    if (nextPageCapacity > lootingContainer.capacity)
                    {
                        playerLoot.Clear();
                        playerLoot.SendImmediate();

                        var backpack2 = currentBackpack;
                        var looter2 = looter;
                        var nextPageIndex2 = nextPageIndex;
                        timer.Once(StandardLootDelay, () => backpack2.TryOpen(looter2, nextPageIndex2));
                        return;
                    }

                    currentBackpack.SwitchToPage(looter, nextPageIndex);
                    return;
                }

                var parent = lootingContainer.parent?.parent;
                if (parent != null && _backpackManager.IsBackpack(parent, out currentBackpack, out currentPageIndex)
                    && (currentBackpack.OwnerId == desiredOwnerId || desiredOwnerId == 0))
                {
                    // Player is looting a child container of the target backpack, so open the current page.
                    OpenBackpackMaybeDelayed(looter, lootingContainer, currentBackpack, currentPageIndex, isKeyBind);
                    return;
                }
            }

            // At this point, player is not looting, looting a different backpack, or looting a different container.
            if (desiredOwnerId == 0)
            {
                desiredOwnerId = looter.userID;
            }

            var backpack = _backpackManager.GetBackpack(desiredOwnerId);
            desiredPageIndex = backpack.DetermineInitialPageForLooter(looter.userID, desiredPageIndex, forward);

            OpenBackpackMaybeDelayed(looter, lootingContainer, backpack, desiredPageIndex, isKeyBind);
        }

        private bool ShouldDisplayGuiButton(BasePlayer player)
        {
            return _preferencesData.GetGuiButtonPreference(player.userID)
                ?? _config.GUI.EnabledByDefault;
        }

        private IPlayer FindPlayer(IPlayer requester, string nameOrID, out string failureMessage)
        {
            failureMessage = string.Empty;

            if (nameOrID.StartsWith("7656119") && nameOrID.Length == 17 && ulong.TryParse(nameOrID, out _))
            {
                var player = covalence.Players.All.FirstOrDefault(p => p.Id == nameOrID);
                if (player == null)
                {
                    failureMessage = GetMessage(requester.Id, LangEntry.UserIDNotFound, nameOrID);
                }

                return player;
            }

            var foundPlayers = new List<IPlayer>();

            foreach (var player in covalence.Players.All)
            {
                if (player.Name.Equals(nameOrID, StringComparison.InvariantCultureIgnoreCase))
                    return player;

                if (player.Name.ToLower().Contains(nameOrID.ToLower()))
                {
                    foundPlayers.Add(player);
                }
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    failureMessage = GetMessage(requester.Id, LangEntry.UserNameNotFound, nameOrID);
                    return null;

                case 1:
                    return foundPlayers[0];

                default:
                    var names = string.Join(", ", foundPlayers.Select(p => p.Name).ToArray());
                    failureMessage = GetMessage(requester.Id, LangEntry.MultiplePlayersFound, names);
                    return null;
            }
        }

        private bool VerifyPlayer(IPlayer player, out BasePlayer basePlayer)
        {
            if (player.IsServer)
            {
                basePlayer = null;
                return false;
            }

            basePlayer = player.Object as BasePlayer;
            return true;
        }

        private bool VerifyTargetPlayer(IPlayer requester, string playerArg, out ulong userId, out string userIdString)
        {
            var targetPlayer = FindPlayer(requester, playerArg, out var failureMessage);

            if (targetPlayer == null)
            {
                requester.Reply(failureMessage);
                userId = 0;
                userIdString = null;
                return false;
            }

            userId = (targetPlayer.Object as BasePlayer)?.userID ?? ulong.Parse(targetPlayer.Id);
            userIdString = targetPlayer.Id;
            return true;
        }

        private bool VerifyHasPermission(IPlayer player, string perm)
        {
            if (player.HasPermission(perm))
                return true;

            ReplyToPlayer(player, LangEntry.NoPermission);
            return false;
        }

        private bool VerifyValidItem(IPlayer player, string itemArg, out ItemDefinition itemDefinition)
        {
            itemDefinition = ItemManager.FindItemDefinition(itemArg);
            if (itemDefinition != null)
                return true;

            // User may have provided an itemID instead of item short name
            if (!int.TryParse(itemArg, out var itemID))
            {
                ReplyToPlayer(player, LangEntry.InvalidItem);
                return false;
            }

            itemDefinition = ItemManager.FindItemDefinition(itemID);
            if (itemDefinition != null)
                return true;

            ReplyToPlayer(player, LangEntry.InvalidItem);
            return false;
        }

        private bool VerifyCanInteract(IPlayer player, out BasePlayer basePlayer)
        {
            return VerifyPlayer(player, out basePlayer)
                   && basePlayer.CanInteract();
        }

        private bool VerifyCanOpenBackpack(BasePlayer looter, ulong ownerId, bool provideFeedback = true)
        {
            if (IsPlayingEvent(looter))
            {
                if (provideFeedback)
                {
                    looter.ChatMessage(GetMessage(looter.UserIDString, LangEntry.MayNotOpenBackpackInEvent));
                }

                return false;
            }

            var hookResult = ExposedHooks.CanOpenBackpack(looter, ownerId);
            if (hookResult != null)
            {
                if (hookResult is string feedbackMessage)
                {
                    if (provideFeedback)
                    {
                        looter.ChatMessage(feedbackMessage);
                    }

                    return false;
                }

                if (hookResult is false)
                    return false;
            }

            return true;
        }

        private bool IsPlayingEvent(BasePlayer player)
        {
            // Multiple event/arena plugins define the isEventPlayer method as a standard.
            if (Interface.CallHook("isEventPlayer", player) is true)
                return true;

            // EventManager 3.x
            if (EventManager?.Call("isPlaying", player) is true)
                return true;

            if (Arena?.Call("IsEventPlayer", player) is true)
                return true;

            return false;
        }

        private bool VerifyDynamicCapacityEnabled(IPlayer player)
        {
            if (_config.BackpackSize.DynamicSize.Enabled)
                return true;

            ReplyToPlayer(player, LangEntry.DynamicCapacityNotEnabled);
            return false;
        }

        private void MaybeCreateButtonUi(BasePlayer player)
        {
            if (!_config.GUI.Enabled)
                return;

            if (player == null || player.IsNpc || !player.IsAlive() || player.IsSleeping())
                return;

            if (!permission.UserHasPermission(player.UserIDString, GUIPermission))
                return;

            if (!ShouldDisplayGuiButton(player))
                return;

            _uiViewers.Add(player.userID);
            _cachedButtonUi ??= ButtonUi.CreateButtonUi(_config);
            CuiHelper.AddUi(player, _cachedButtonUi);
        }

        private void DestroyButtonUi(BasePlayer player)
        {
            if (!_uiViewers.Remove(player.userID))
                return;

            ButtonUi.DestroyUi(player);
        }

        private void CreateOrDestroyButtonUi(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, GUIPermission))
            {
                MaybeCreateButtonUi(player);
            }
            else
            {
                DestroyButtonUi(player);
            }
        }

        #endregion

        #region Helper Classes

        private static class StringUtils
        {
            public static bool EqualsCaseInsensitive(string a, string b, StringComparison stringComparison = StringComparison.Ordinal)
            {
                return string.Compare(a, b, stringComparison) == 0;
            }

            public static bool Contains(string haystack, string needle)
            {
                return haystack.Contains(needle, CompareOptions.IgnoreCase);
            }
        }

        private static class ObjectCache
        {
            private static readonly object True = true;
            private static readonly object False = false;

            private static class StaticObjectCache<T>
            {
                private static readonly Dictionary<T, object> _cacheByValue = new();

                public static object Get(T value)
                {
                    if (!_cacheByValue.TryGetValue(value, out var cachedObject))
                    {
                        cachedObject = value;
                        _cacheByValue[value] = cachedObject;
                    }

                    return cachedObject;
                }
            }

            public static object Get<T>(T value)
            {
                return StaticObjectCache<T>.Get(value);
            }

            public static object Get(bool value)
            {
                return value ? True : False;
            }
        }

        private class PoolConverter<T> : CustomCreationConverter<T> where T : class, new()
        {
            public override T Create(Type objectType)
            {
                #if DEBUG_POOLING
                LogDebug($"{typeof(PoolConverter<T>).Name}<{objectType.Name}>::Create");
                #endif

                return CustomPool.Get<T>();
            }
        }

        private class PoolListConverter<T> : CustomCreationConverter<List<T>> where T : class, new()
        {
            public override List<T> Create(Type objectType)
            {
                #if DEBUG_POOLING
                LogDebug($"{typeof(PoolListConverter<T>).Name}<{objectType.Name}>::Create");
                #endif

                return CustomPool.GetList<T>();
            }
        }

        private static class ItemUtils
        {
            public static int PositionOf(List<Item> itemList, ref ItemQuery itemQuery)
            {
                // Assumes the list is sorted.
                foreach (var item in itemList)
                {
                    var usableAmount = itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                        return item.position;
                }

                return -1;
            }

            public static int PositionOf(List<ItemData> itemDataList, ref ItemQuery itemQuery)
            {
                // Assumes the list is sorted.
                foreach (var itemData in itemDataList)
                {
                    var usableAmount = itemQuery.GetUsableAmount(itemData);
                    if (usableAmount > 0)
                        return itemData.Position;
                }

                return -1;
            }

            public static void FindItems(List<Item> itemList, ref ItemQuery itemQuery, List<Item> collect)
            {
                foreach (var item in itemList)
                {
                    var usableAmount = itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                    {
                        collect.Add(item);
                    }

                    if (HasSearchableContainer(item, out var childItemList))
                    {
                        FindItems(childItemList, ref itemQuery, collect);
                    }
                }
            }

            public static int CountItems(List<Item> itemList, ref ItemQuery itemQuery)
            {
                var count = 0;

                foreach (var item in itemList)
                {
                    var usableAmount = itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                    {
                        count++;
                    }

                    if (HasSearchableContainer(item, out var childItems))
                    {
                        count += CountItems(childItems, ref itemQuery);
                    }
                }

                return count;
            }

            public static int CountItems(List<ItemData> itemDataList, ref ItemQuery itemQuery)
            {
                var count = 0;

                foreach (var itemData in itemDataList)
                {
                    var usableAmount = itemQuery.GetUsableAmount(itemData);
                    if (usableAmount > 0)
                    {
                        count++;
                    }

                    if (HasSearchableContainer(itemData, out var childItems))
                    {
                        count += CountItems(childItems, ref itemQuery);
                    }
                }

                return count;
            }

            public static int SumItems(List<Item> itemList, ref ItemQuery itemQuery)
            {
                var sum = 0;

                foreach (var item in itemList)
                {
                    sum += itemQuery.GetUsableAmount(item);

                    if (HasSearchableContainer(item, out var childItems))
                    {
                        sum += SumItems(childItems, ref itemQuery);
                    }
                }

                return sum;
            }

            public static int SumItems(List<ItemData> itemDataList, ref ItemQuery itemQuery)
            {
                var sum = 0;

                foreach (var itemData in itemDataList)
                {
                    sum += itemQuery.GetUsableAmount(itemData);

                    if (HasSearchableContainer(itemData, out var childItemList))
                    {
                        sum += SumItems(childItemList, ref itemQuery);
                    }
                }

                return sum;
            }

            public static int TakeItems(List<Item> itemList, ref ItemQuery itemQuery, int amount, List<Item> collect)
            {
                var totalAmountTaken = 0;

                for (var i = itemList.Count - 1; i >= 0; i--)
                {
                    var item = itemList[i];
                    var amountToTake = amount - totalAmountTaken;
                    if (amountToTake <= 0)
                        break;

                    var usableAmount = itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                    {
                        amountToTake = Math.Min(usableAmount, amountToTake);

                        TakeItemAmount(item, amountToTake, collect);
                        totalAmountTaken += amountToTake;
                    }

                    amountToTake = amount - totalAmountTaken;
                    if (amountToTake > 0 && HasSearchableContainer(item, out var childItemList))
                    {
                        totalAmountTaken += TakeItems(childItemList, ref itemQuery, amountToTake, collect);
                    }
                }

                return totalAmountTaken;
            }

            public static int TakeItems(List<ItemData> itemDataList, ref ItemQuery itemQuery, int amount, List<Item> collect)
            {
                var totalAmountTaken = 0;

                for (var i = itemDataList.Count - 1; i >= 0; i--)
                {
                    var itemData = itemDataList[i];
                    var amountToTake = amount - totalAmountTaken;
                    if (amountToTake <= 0)
                        break;

                    var usableAmount = itemQuery.GetUsableAmount(itemData);
                    if (usableAmount > 0)
                    {
                        amountToTake = Math.Min(usableAmount, amountToTake);

                        collect?.Add(itemData.ToItem(amountToTake));
                        itemData.Reduce(amountToTake);

                        totalAmountTaken += amountToTake;

                        if (itemData.Amount <= 0)
                        {
                            itemDataList.RemoveAt(i);
                            CustomPool.Free(ref itemData);
                            continue;
                        }
                    }

                    amountToTake = amount - totalAmountTaken;
                    if (amountToTake > 0 && HasSearchableContainer(itemData, out var childItemList))
                    {
                        totalAmountTaken += TakeItems(childItemList, ref itemQuery, amountToTake, collect);
                    }
                }

                return totalAmountTaken;
            }

            public static int MutateItems(List<Item> itemList, ref ItemQuery itemQuery, ref MutationRequest mutationRequest)
            {
                var count = 0;

                foreach (var item in itemList)
                {
                    if (itemQuery.GetUsableAmount(item) > 0 && mutationRequest.ApplyTo(item))
                    {
                        item.MarkDirty();
                        count++;
                    }

                    if (HasSearchableContainer(item, out var childItemList))
                    {
                        count += MutateItems(childItemList, ref itemQuery, ref mutationRequest);
                    }
                }

                return count;
            }

            public static int MutateItems(List<ItemData> itemDataList, ref ItemQuery itemQuery, ref MutationRequest mutationRequest)
            {
                var count = 0;

                foreach (var itemData in itemDataList)
                {
                    if (itemQuery.GetUsableAmount(itemData) > 0 && mutationRequest.ApplyTo(itemData))
                    {
                        count++;
                    }

                    if (HasSearchableContainer(itemData, out var childItemList))
                    {
                        count += MutateItems(childItemList, ref itemQuery, ref mutationRequest);
                    }
                }

                return count;
            }

            public static void SerializeForNetwork(List<Item> itemList, List<ProtoBuf.Item> collect)
            {
                foreach (var item in itemList)
                {
                    collect.Add(item.Save());

                    if (HasSearchableContainer(item, out var childItems))
                    {
                        SerializeForNetwork(childItems, collect);
                    }
                }
            }

            public static void SerializeForNetwork(List<ItemData> itemDataList, List<ProtoBuf.Item> collect)
            {
                foreach (var itemData in itemDataList)
                {
                    var serializedItemData = Pool.Get<ProtoBuf.Item>();
                    serializedItemData.itemid = itemData.ID;
                    serializedItemData.amount = itemData.Amount;

                    if (itemData.DataInt != 0 || itemData.BlueprintTarget != 0)
                    {
                        serializedItemData.instanceData ??= Pool.Get<ProtoBuf.Item.InstanceData>();
                        serializedItemData.instanceData.dataInt = itemData.DataInt;
                        serializedItemData.instanceData.blueprintTarget = itemData.BlueprintTarget;
                    }

                    collect.Add(serializedItemData);

                    if (HasSearchableContainer(itemData, out var childItemList))
                    {
                        SerializeForNetwork(childItemList, collect);
                    }
                }
            }

            private static bool IsSearchableItemDefinition(ItemDefinition itemDefinition)
            {
                return (itemDefinition.flags & (ItemDefinition.Flag.Backpack | SearchableItemDefinitionFlag)) != 0;
            }

            private static bool IsSearchableItemDefinition(int itemId)
            {
                var itemDefinition = ItemManager.FindItemDefinition(itemId);
                return itemDefinition is not null && IsSearchableItemDefinition(itemDefinition);
            }

            private static bool HasSearchableContainer(Item item, out List<Item> itemList)
            {
                itemList = item.contents?.itemList;
                if (itemList is not { Count: > 0 })
                    return false;

                if (item.HasFlag(SearchableItemFlag))
                    return true;

                if (item.HasFlag(UnsearchableItemFlag))
                    return false;

                return IsSearchableItemDefinition(item.info);
            }

            private static bool HasSearchableContainer(ItemData itemData, out List<ItemData> itemDataList)
            {
                itemDataList = itemData.Contents;
                if (itemDataList is not { Count: > 0 })
                    return false;

                if (itemData.Flags.HasFlag(SearchableItemFlag))
                    return true;

                if (itemData.Flags.HasFlag(UnsearchableItemFlag))
                    return false;

                return IsSearchableItemDefinition(itemData.ID);
            }

            private static void TakeItemAmount(Item item, int amount, List<Item> collect)
            {
                if (amount >= item.amount)
                {
                    item.RemoveFromContainer();
                    if (collect != null)
                    {
                        collect.Add(item);
                    }
                    else
                    {
                        item.Remove();
                    }
                }
                else
                {
                    if (collect != null)
                    {
                        collect.Add(item.SplitItem(amount));
                    }
                    else
                    {
                        item.amount -= amount;
                        item.MarkDirty();
                    }
                }
            }
        }

        #endregion

        #region Pooling

        private static class CustomPool
        {
            public interface IPooled
            {
                void EnterPool();
                void LeavePool();
            }

            private static class StaticPool<T> where T : class, new()
            {
                public static readonly PoolCollection<T> Collection = new();
            }

            private class PoolCollection<T> where T : class, new()
            {
                public const int DefaultPoolSize = 512;

                private T[] _buffer;
                public int ItemsCreated { get; private set; }
                public int ItemsInStack { get; private set; }
                public int ItemsInUse { get; private set; }
                public int ItemsSpilled { get; private set; }
                public int ItemsTaken { get; private set; }

                public PoolCollection()
                {
                    Reset(DefaultPoolSize);
                }

                public void Reset(int size = 0)
                {
                    _buffer = size == 0 ? Array.Empty<T>() : new T[size];

                    ItemsCreated = 0;
                    ItemsInStack = 0;
                    ItemsInUse = 0;
                    ItemsSpilled = 0;
                    ItemsTaken = 0;
                }

                public void Add(T obj)
                {
                    (obj as IPooled)?.EnterPool();

                    ItemsInUse--;

                    if (ItemsInStack >= _buffer.Length)
                    {
                        ItemsSpilled++;
                        return;
                    }

                    _buffer[ItemsInStack] = obj;
                    ItemsInStack++;
                }

                public T Take()
                {
                    if (ItemsInStack > 0)
                    {
                        ItemsInStack--;
                        ItemsInUse++;
                        var obj = _buffer[ItemsInStack];
                        _buffer[ItemsInStack] = null;
                        (obj as IPooled)?.LeavePool();
                        ItemsTaken++;
                        return obj;
                    }

                    ItemsCreated++;
                    ItemsInUse++;
                    return new T();
                }
            }

            public static void Reset<T>(int size) where T : class, new()
            {
                StaticPool<T>.Collection.Reset(size);
            }

            public static string GetStats<T>() where T : class, new()
            {
                var pool = StaticPool<T>.Collection;
                return $"{typeof(T).Name} | {pool.ItemsInUse.ToString()} used of {pool.ItemsCreated.ToString()} created | {pool.ItemsTaken.ToString()} taken";
            }

            public static T Get<T>() where T : class, new()
            {
                return StaticPool<T>.Collection.Take();
            }

            public static List<T> GetList<T>()
            {
                return Get<List<T>>();
            }

            public static void Free<T>(ref T obj) where T : class, new()
            {
                FreeInternal(ref obj);
            }

            public static void FreeList<T>(ref List<T> list) where T : class
            {
                list.Clear();
                FreeInternal(ref list);
            }

            private static void FreeInternal<T>(ref T obj) where T : class, new()
            {
                StaticPool<T>.Collection.Add(obj);
                obj = null;
            }
        }

        private static class PoolUtils
        {
            public const int BackpackPoolSize = 500;

            public static void ResetItemsAndClear<T>(IList<T> list) where T : class, CustomPool.IPooled, new()
            {
                for (var i = list.Count - 1; i >= 0; i--)
                {
                    var item = list[i];
                    if (item == null)
                        continue;

                    CustomPool.Free(ref item);
                }

                if (list.IsReadOnly)
                {
                    for (var i = 0; i < list.Count; i++)
                    {
                        list[i] = null;
                    }
                }
                else
                {
                    list.Clear();
                }
            }

            public static void ResizePools(bool empty = false)
            {
                CustomPool.Reset<ItemData>(empty ? 0 : 2 * BackpackPoolSize);
                CustomPool.Reset<List<ItemData>>(empty ? 0 : BackpackPoolSize);
                CustomPool.Reset<OwnershipData>(empty ? 0 : 2 * BackpackPoolSize);
                CustomPool.Reset<List<OwnershipData>>(empty ? 0 : BackpackPoolSize);
                CustomPool.Reset<EntityData>(empty ? 0 : BackpackPoolSize / 4);
                CustomPool.Reset<EntityData.BasicItemData>(empty ? 0 : BackpackPoolSize / 4);
                CustomPool.Reset<Backpack>(empty ? 0 : BackpackPoolSize);
                CustomPool.Reset<VirtualContainerAdapter>(empty ? 0 : 2 * BackpackPoolSize);
                CustomPool.Reset<ItemContainerAdapter>(empty ? 0 : 2 * BackpackPoolSize);
                CustomPool.Reset<DisposableList<Item>>(empty ? 0 : 4);
                CustomPool.Reset<DisposableList<ItemData>>(empty ? 0 : 4);
                CustomPool.Reset<ContainerAdapterEnumerator>(empty ? 0 : 4);
            }
        }

        private class DisposableList<T> : List<T>, IDisposable
        {
            public static DisposableList<T> Get()
            {
                return CustomPool.Get<DisposableList<T>>();
            }

            public void Dispose()
            {
                Clear();
                var self = this;
                CustomPool.Free(ref self);
            }
        }

        #endregion

        #region String Cache

        private interface IStringCache
        {
            string Get<T>(T value);
            string Get<T>(T value, Func<T, string> createString);
            string Get(bool value);
        }

        private sealed class DefaultStringCache : IStringCache
        {
            public static readonly DefaultStringCache Instance = new();

            private static class StaticStringCache<T>
            {
                private static readonly Dictionary<T, string> _cacheByValue = new();

                public static string Get(T value)
                {
                    if (!_cacheByValue.TryGetValue(value, out var str))
                    {
                        str = value.ToString();
                        _cacheByValue[value] = str;
                    }

                    return str;
                }
            }

            private static class StaticStringCacheWithFactory<T>
            {
                private static readonly Dictionary<Func<T, string>, Dictionary<T, string>> _cacheByDelegate = new();

                public static string Get(T value, Func<T, string> createString)
                {
                    if (!_cacheByDelegate.TryGetValue(createString, out var cache))
                    {
                        cache = new Dictionary<T, string>();
                        _cacheByDelegate[createString] = cache;
                    }

                    if (!cache.TryGetValue(value, out var str))
                    {
                        str = createString(value);
                        cache[value] = str;
                    }

                    return str;
                }
            }

            private DefaultStringCache() {}

            public string Get<T>(T value)
            {
                return StaticStringCache<T>.Get(value);
            }

            public string Get(bool value)
            {
                return value ? "true" : "false";
            }

            public string Get<T>(T value, Func<T, string> createString)
            {
                return StaticStringCacheWithFactory<T>.Get(value, createString);
            }
        }

        #endregion

        #region UI Builder

        private interface IUiSerializable
        {
            void Serialize(IUiBuilder uiBuilder);
        }

        private interface IUiBuilder
        {
            IStringCache StringCache { get; }
            void Start();
            void End();
            void StartElement();
            void EndElement();
            void StartComponent();
            void EndComponent();
            void AddField<T>(string key, T value);
            void AddField(string key, string value);
            void AddXY(string key, float x, float y);
            void AddSerializable<T>(T serializable) where T : IUiSerializable;
            void AddComponents<T>(T components) where T : IUiComponentCollection;
            string ToJson();
            byte[] GetBytes();
            void AddUi(SendInfo sendInfo);
            void AddUi(BasePlayer player);
        }

        private class UiBuilder : IUiBuilder
        {
            private static NetWrite ClientRPCStart(BaseEntity entity, string funcName)
            {
                if (Net.sv.IsConnected() && entity.net != null)
                {
                    var write = Net.sv.StartWrite();
                    write.PacketID(Message.Type.RPCMessage);
                    write.EntityID(entity.net.ID);
                    write.UInt32(StringPool.Get(funcName));
                    return write;
                }
                return null;
            }

            public static readonly UiBuilder Default = new(65536);

            private enum State
            {
                Empty,
                ElementList,
                Element,
                ComponentList,
                Component,
                Complete,
            }

            public int Length { get; private set; }

            private const char Delimiter = ',';
            private const char Quote = '"';
            private const char Colon = ':';
            private const char Space = ' ';
            private const char OpenBracket = '[';
            private const char CloseBracket = ']';
            private const char OpenCurlyBrace = '{';
            private const char CloseCurlyBrace = '}';

            private const int MinCapacity = 1024;
            private const int DefaultCapacity = 4096;

            public IStringCache StringCache { get; }
            private char[] _chars;
            private byte[] _bytes;
            private State _state;
            private bool _needsDelimiter;

            public UiBuilder(int capacity, IStringCache stringCache)
            {
                if (capacity < MinCapacity)
                    throw new InvalidOperationException($"Capacity must be at least {MinCapacity}");

                Resize(capacity);
                StringCache = stringCache;
            }

            public UiBuilder(int capacity = DefaultCapacity) : this(capacity, DefaultStringCache.Instance) {}

            public void Start()
            {
                Reset();
                StartArray();
                _state = State.ElementList;
            }

            public void End()
            {
                ValidateState(State.ElementList);
                EndArray();
                _state = State.Complete;
            }

            public void StartElement()
            {
                ValidateState(State.ElementList);
                StartObject();
                _state = State.Element;
            }

            public void EndElement()
            {
                ValidateState(State.Element);
                EndObject();
                _state = State.ElementList;
            }

            public void StartComponent()
            {
                ValidateState(State.ComponentList);
                StartObject();
                _state = State.Component;
            }

            public void EndComponent()
            {
                ValidateState(State.Component);
                EndObject();
                _state = State.ComponentList;
            }

            public void AddField<T>(string key, T value)
            {
                AddKey(key);
                Append(StringCache.Get(value));
                _needsDelimiter = true;
            }

            public void AddField(string key, string value)
            {
                if (value == null)
                    return;

                AddKey(key);
                Append(Quote);
                Append(value);
                Append(Quote);
                _needsDelimiter = true;
            }

            public void AddXY(string key, float x, float y)
            {
                AddKey(key);
                Append(Quote);
                Append(StringCache.Get(x));
                Append(Space);
                Append(StringCache.Get(y));
                Append(Quote);
                _needsDelimiter = true;
            }

            public void AddSerializable<T>(T serializable) where T : IUiSerializable
            {
                serializable.Serialize(this);
            }

            public void AddComponents<T>(T components) where T : IUiComponentCollection
            {
                ValidateState(State.Element);
                AddKey("components");
                StartArray();
                _state = State.ComponentList;
                components.Serialize(this);
                EndArray();
                _state = State.Element;
            }

            public string ToJson()
            {
                ValidateState(State.Complete);
                return new string(_chars, 0, Length);
            }

            public byte[] GetBytes()
            {
                ValidateState(State.Complete);
                var bytes = new byte[Length];
                Buffer.BlockCopy(_bytes, 0, bytes, 0, Length);
                return bytes;
            }

            public void AddUi(SendInfo sendInfo)
            {
                var write = ClientRPCStart(CommunityEntity.ServerInstance, "AddUI");
                if (write != null)
                {
                    var byteCount = Encoding.UTF8.GetBytes(_chars, 0, Length, _bytes, 0);
                    write.BytesWithSize(_bytes, byteCount);
                    write.Send(sendInfo);
                }
            }

            public void AddUi(BasePlayer player)
            {
                AddUi(new SendInfo(player.Connection));
            }

            private void ValidateState(State desiredState)
            {
                if (_state != desiredState)
                    throw new InvalidOperationException($"Expected state {desiredState} but found {_state}");
            }

            private void ValidateState(State desiredState, State alternateState)
            {
                if (_state != desiredState && _state != alternateState)
                    throw new InvalidOperationException($"Expected state {desiredState} or {alternateState} but found {_state}");
            }

            private void Resize(int length)
            {
                Array.Resize(ref _chars, length);
                Array.Resize(ref _bytes, length * 2);
            }

            private void ResizeIfApproachingLength()
            {
                if (Length + 1024 > _chars.Length)
                {
                    Resize(_chars.Length * 2);
                }
            }

            private void Append(char @char)
            {
                _chars[Length++] = @char;
            }

            private void Append(string str)
            {
                for (var i = 0; i < str.Length; i++)
                {
                    _chars[Length + i] = str[i];
                }

                Length += str.Length;
            }

            private void AddDelimiter()
            {
                Append(Delimiter);
            }

            private void AddDelimiterIfNeeded()
            {
                if (_needsDelimiter)
                {
                    AddDelimiter();
                }
            }

            private void StartObject()
            {
                AddDelimiterIfNeeded();
                Append(OpenCurlyBrace);
                _needsDelimiter = false;
            }

            private void EndObject()
            {
                Append(CloseCurlyBrace);
                _needsDelimiter = true;
            }

            private void StartArray()
            {
                Append(OpenBracket);
                _needsDelimiter = false;
            }

            private void EndArray()
            {
                Append(CloseBracket);
                _needsDelimiter = true;
            }

            private void AddKey(string key)
            {
                ValidateState(State.Element, State.Component);
                ResizeIfApproachingLength();
                AddDelimiterIfNeeded();
                Append(Quote);
                Append(key);
                Append(Quote);
                Append(Colon);
            }

            private void Reset()
            {
                Length = 0;
                _state = State.Empty;
                _needsDelimiter = false;
            }
        }

        #endregion

        #region UI Layout

        private struct UiRect
        {
            public string Anchor;
            public float XMin;
            public float XMax;
            public float YMin;
            public float YMax;
        }

        private static class Layout
        {
            [Flags]
            public enum Option
            {
                AnchorBottom = 1 << 0,
                AnchorRight = 1 << 1,
                Vertical = 1 << 2,
            }

            public const string AnchorBottomLeft = "0 0";
            public const string AnchorBottomRight = "1 0";
            public const string AnchorTopLeft = "0 1";
            public const string AnchorTopRight = "1 1";

            public const string AnchorBottomCenter = "0.5 0";
            public const string AnchorTopCenter = "0.5 1";
            public const string AnchorCenterLeft = "0 0.5";
            public const string AnchorCenterRight = "1 0.5";

            public static string DetermineAnchor(Option options)
            {
                return options.HasFlag(Option.AnchorBottom)
                    ? options.HasFlag(Option.AnchorRight) ? AnchorBottomRight : AnchorBottomLeft
                    : options.HasFlag(Option.AnchorRight) ? AnchorTopRight : AnchorTopLeft;
            }
        }

        private interface ILayoutProvider {}

        private struct StatelessLayoutProvider : ILayoutProvider
        {
            public static UiRect GetRect(int index, Layout.Option options, Vector2 size, float spacing = 0, Vector2 offset = default)
            {
                var xMin = !options.HasFlag(Layout.Option.Vertical)
                    ? offset.x + index * (spacing + size.x)
                    : offset.x;

                var xMax = xMin + size.x;

                var yMin = options.HasFlag(Layout.Option.Vertical)
                    ? offset.y + index * (spacing + size.y)
                    : offset.y;

                var yMax = yMin + size.y;

                if (options.HasFlag(Layout.Option.AnchorRight))
                {
                    var temp = xMin;
                    xMin = -xMax;
                    xMax = -temp;
                }

                if (!options.HasFlag(Layout.Option.AnchorBottom))
                {
                    var temp = yMin;
                    yMin = -yMax;
                    yMax = -temp;
                }

                return new UiRect
                {
                    Anchor = Layout.DetermineAnchor(options),
                    XMin = xMin,
                    XMax = xMax,
                    YMin = yMin,
                    YMax = yMax,
                };
            }

            public Layout.Option Options;
            public Vector2 Offset;
            public Vector2 Size;
            public float Spacing;

            public UiRect this[int index] => GetRect(index, Options, Size, Spacing, Offset);

            public static StatelessLayoutProvider operator +(StatelessLayoutProvider layoutProvider, Vector2 vector)
            {
                layoutProvider.Offset += vector;
                return layoutProvider;
            }

            public static StatelessLayoutProvider operator -(StatelessLayoutProvider layoutProvider, Vector2 vector)
            {
                layoutProvider.Offset -= vector;
                return layoutProvider;
            }
        }

        private struct StatefulLayoutProvider : ILayoutProvider
        {
            public Layout.Option Options;
            public Vector2 Offset;
            public Vector2 Size;
            public float Spacing;

            public static StatefulLayoutProvider operator +(StatefulLayoutProvider layoutProvider, Vector2 vector)
            {
                layoutProvider.Offset += vector;
                return layoutProvider;
            }

            public static StatefulLayoutProvider operator -(StatefulLayoutProvider layoutProvider, Vector2 vector)
            {
                layoutProvider.Offset -= vector;
                return layoutProvider;
            }

            public UiRect Current(Vector2 size)
            {
                return StatelessLayoutProvider.GetRect(0, Options, size, Spacing, Offset);
            }

            public UiRect Current()
            {
                return Current(Size);
            }

            public UiRect Next(Vector2 size)
            {
                var position = Current(size);

                if (Options.HasFlag(Layout.Option.Vertical))
                {
                    Offset.y += size.y + Spacing;
                }
                else
                {
                    Offset.x += size.x + Spacing;
                }

                return position;
            }

            public UiRect Next(float x, float y)
            {
                return Next(new Vector2(x, y));
            }

            public UiRect Next()
            {
                return Next(Size);
            }
        }

        #endregion

        #region UI Components

        private interface IUiComponent : IUiSerializable {}

        private struct UiButtonComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.Button";

            private const string DefaultCommand = null;
            private const string DefaultClose = null;
            private const string DefaultSprite = "Assets/Content/UI/UI.Background.Tile.psd";
            private const string DefaultMaterial = "Assets/Icons/IconMaterial.mat";
            private const string DefaultColor = "1 1 1 1";
            private const Image.Type DefaultImageType = Image.Type.Simple;
            private const float DefaultFadeIn = 0;

            public string Command;
            public string Close;
            public string Sprite;
            public string Material;
            public string Color;
            public Image.Type ImageType;
            public float FadeIn;

            public void Serialize(IUiBuilder builder)
            {
                Sprite ??= DefaultSprite;
                Material ??= DefaultMaterial;
                Color ??= DefaultColor;

                if (ImageType == default)
                    ImageType = DefaultImageType;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Command != DefaultCommand)
                    builder.AddField("command", Command);

                if (Close != DefaultClose)
                    builder.AddField("close", Close);

                if (Sprite != DefaultSprite)
                    builder.AddField("sprite", Sprite);

                if (Material != DefaultMaterial)
                    builder.AddField("material", Material);

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (ImageType != DefaultImageType)
                    builder.AddField("imagetype", builder.StringCache.Get(ImageType));

                if (FadeIn != DefaultFadeIn)
                    builder.AddField("fadeIn", FadeIn);

                builder.EndComponent();
            }
        }

        private struct UiImageComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.Image";

            private const string DefaultSprite = "Assets/Content/UI/UI.Background.Tile.psd";
            private const string DefaultMaterial = "Assets/Icons/IconMaterial.mat";
            private const string DefaultColor = "1 1 1 1";
            private const Image.Type DefaultImageType = Image.Type.Simple;
            private const string DefaultPng = null;
            private const int DefaultItemId = 0;
            private const ulong DefaultSkinId = 0;
            private const float DefaultFadeIn = 0;

            public string Sprite;
            public string Material;
            public string Color;
            public Image.Type ImageType;
            public string Png;
            public int ItemId;
            public ulong SkinId;
            public float FadeIn;

            public void Serialize(IUiBuilder builder)
            {
                Sprite ??= DefaultSprite;
                Material ??= DefaultMaterial;
                Color ??= DefaultColor;

                if (ImageType == default)
                    ImageType = DefaultImageType;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Sprite != DefaultSprite)
                    builder.AddField("sprite", Sprite);

                if (Material != DefaultMaterial)
                    builder.AddField("material", Material);

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (ImageType != DefaultImageType)
                    builder.AddField("imagetype", builder.StringCache.Get(ImageType));

                if (Png != DefaultPng)
                    builder.AddField("png", Png);

                if (ItemId != DefaultItemId)
                    builder.AddField("itemid", ItemId);

                if (SkinId != DefaultSkinId)
                    builder.AddField("skinid", SkinId);

                if (FadeIn != DefaultFadeIn)
                    builder.AddField("fadeIn", FadeIn);

                builder.EndComponent();
            }
        }

        private struct UiRawImageComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.RawImage";

            private const string DefaultSprite = "Assets/Icons/rust.png";
            private const string DefaultColor = "1 1 1 1";
            private const string DefaultMaterial = null;
            private const string DefaultUrl = null;
            private const string DefaultPng = null;
            private const float DefaultFadeIn = 0;

            public string Sprite;
            public string Color;
            public string Material;
            public string Url;
            public string Png;
            public float FadeIn;

            public void Serialize(IUiBuilder builder)
            {
                Sprite ??= DefaultSprite;
                Color ??= DefaultColor;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Sprite != DefaultSprite)
                    builder.AddField("sprite", Sprite);

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (Material != DefaultMaterial)
                    builder.AddField("material", Material);

                if (Url != DefaultUrl)
                    builder.AddField("url", Url);

                if (Png != DefaultPng)
                    builder.AddField("png", Png);

                if (FadeIn != DefaultFadeIn)
                    builder.AddField("fadeIn", FadeIn);

                builder.EndComponent();
            }
        }

        private struct UiRectTransformComponent : IUiComponent
        {
            private const string Type = "RectTransform";

            public const string DefaultAnchorMin = "0.0 0.0";
            public const string DefaultAnchorMax = "1.0 1.0";
            public const string DefaultOffsetMin = "0.0 0.0";
            public const string DefaultOffsetMax = "1.0 1.0";

            public string AnchorMin;
            public string AnchorMax;
            public string OffsetMin;
            public string OffsetMax;

            public void Serialize(IUiBuilder builder)
            {
                AnchorMin ??= DefaultAnchorMin;
                AnchorMax ??= DefaultAnchorMax;
                OffsetMin ??= DefaultOffsetMin;
                OffsetMax ??= DefaultOffsetMax;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (AnchorMin != DefaultAnchorMin)
                    builder.AddField("anchormin", AnchorMin);

                if (AnchorMax != DefaultAnchorMax)
                    builder.AddField("anchormax", AnchorMax);

                if (OffsetMin != DefaultOffsetMin)
                    builder.AddField("offsetmin", OffsetMin);

                if (OffsetMax != DefaultOffsetMax)
                    builder.AddField("offsetmax", OffsetMax);

                builder.EndComponent();
            }
        }

        private struct UiTextComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.Text";

            private const string DefaultText = "Text";
            private const int DefaultFontSize = 14;
            private const string DefaultFont = "RobotoCondensed-Bold.ttf";
            private const TextAnchor DefaultTextAlign = TextAnchor.UpperLeft;
            private const string DefaultColor = "1 1 1 1";
            private const VerticalWrapMode DefaultVerticalWrapMode = VerticalWrapMode.Truncate;
            private const float DefaultFadeIn = 0;

            public string Text;
            public int FontSize;
            public string Font;
            public TextAnchor TextAlign;
            public string Color;
            public VerticalWrapMode VerticalWrapMode;
            public float FadeIn;

            public void Serialize(IUiBuilder builder)
            {
                Text ??= DefaultText;

                if (FontSize == default)
                    FontSize = DefaultFontSize;

                Font ??= DefaultFont;

                if (TextAlign == default)
                    TextAlign = DefaultTextAlign;

                Color ??= DefaultColor;

                if (VerticalWrapMode == default)
                    VerticalWrapMode = DefaultVerticalWrapMode;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Text != DefaultText)
                    builder.AddField("text", Text);

                if (FontSize != DefaultFontSize)
                    builder.AddField("fontSize", FontSize);

                if (Font != DefaultFont)
                    builder.AddField("font", Font);

                if (TextAlign != DefaultTextAlign)
                    builder.AddField("align", builder.StringCache.Get(TextAlign));

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (VerticalWrapMode != DefaultVerticalWrapMode)
                    builder.AddField("verticalOverflow", builder.StringCache.Get(VerticalWrapMode));

                if (FadeIn != DefaultFadeIn)
                    builder.AddField("fadeIn", FadeIn);

                builder.EndComponent();
            }
        }

        // Custom component for handling positions.
        private struct UiRectComponent : IUiComponent
        {
            private const string Type = "RectTransform";

            public const string DefaultAnchorMin = "0.0 0.0";

            private const string DefaultAnchor = "0 0";

            public UiRect Rect;

            public UiRectComponent(UiRect rect)
            {
                Rect = rect;
            }

            public UiRectComponent(float x, float y, string anchor = DefaultAnchor)
            {
                Rect = new UiRect
                {
                    Anchor = anchor,
                    XMin = x,
                    XMax = x,
                    YMin = y,
                    YMax = y,
                };
            }

            public void Serialize(IUiBuilder builder)
            {
                builder.StartComponent();
                builder.AddField("type", Type);

                if (Rect.Anchor != DefaultAnchorMin)
                {
                    builder.AddField("anchormin", Rect.Anchor);
                    builder.AddField("anchormax", Rect.Anchor);
                }

                builder.AddXY("offsetmin", Rect.XMin, Rect.YMin);
                builder.AddXY("offsetmax", Rect.XMax, Rect.YMax);

                builder.EndComponent();
            }
        }

        #endregion

        #region UI Elements

        private interface IUiComponentCollection : IUiSerializable {}

        private struct UiComponents<T1> : IUiComponentCollection, IEnumerable<IUiComponentCollection>
            where T1 : IUiComponent
        {
            public T1 Component1;

            public void Add(T1 item) => Component1 = item;

            public void Serialize(IUiBuilder builder)
            {
                Component1.Serialize(builder);
            }

            public IEnumerator<IUiComponentCollection> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        private struct UiComponents<T1, T2> : IUiComponentCollection, IEnumerable<IUiComponentCollection>
            where T1 : IUiComponent
            where T2 : IUiComponent
        {
            public T1 Component1;
            public T2 Component2;

            public void Add(T1 item) => Component1 = item;
            public void Add(T2 item) => Component2 = item;

            public void Serialize(IUiBuilder builder)
            {
                Component1.Serialize(builder);
                Component2.Serialize(builder);
            }

            public IEnumerator<IUiComponentCollection> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        private struct UiElement<T> : IUiSerializable
            where T : IUiComponentCollection
        {
            public string Name;
            public string Parent;
            public string DestroyName;
            public float FadeOut;
            public T Components;

            public void Serialize(IUiBuilder builder)
            {
                builder.StartElement();
                builder.AddField("name", Name);
                builder.AddField("parent", Parent);

                if (DestroyName != default)
                    builder.AddField("destroyUi", DestroyName);

                if (FadeOut != default)
                    builder.AddField("fadeOut", FadeOut);

                builder.AddComponents(Components);
                builder.EndElement();
            }
        }

        private struct UiButtonElement<TButton, TText> : IUiSerializable
            where TButton : IUiComponentCollection
            where TText : IUiComponentCollection
        {
            public string Name;
            public string Parent;
            public string DestroyName;
            public float FadeOut;
            public TButton Button;
            public TText Text;

            public void Serialize(IUiBuilder builder)
            {
                builder.AddSerializable(new UiElement<TButton>
                {
                    Parent = Parent,
                    Name = Name,
                    Components = Button,
                    DestroyName = DestroyName,
                    FadeOut = FadeOut,
                });

                builder.AddSerializable(new UiElement<TText>
                {
                    Parent = Name,
                    Components = Text,
                    FadeOut = FadeOut,
                });
            }
        }

        #endregion

        #region UI

        private static class ContainerUi
        {
            public const float BaseOffsetY = 113.5f;
            public const float BaseOffsetX = 192.5f;
            public const float HeaderWidth = 380;
            public const float HeaderHeight = 23;
            public const float PerRowOffsetY = 62;

            private const float PageButtonSpacing = 6;
            private const float PageButtonSize = HeaderHeight;

            private const string BlueButtonColor = "0.25 0.5 0.75 1";
            private const string BlueButtonTextColor = "0.75 0.85 1 1";
            private const string GreenButtonColor = "0.451 0.553 0.271 1";
            private const string GreenButtonTextColor = "0.659 0.918 0.2 1";

            private const string Name = "Backpacks.Container";
            private static readonly string LeftButtonName = $"{Name}.Left";
            private static readonly string RightButtonName = $"{Name}.Right";

            private struct PageButton
            {
                public string Name;
                public UiRect Rect;
                public string Text;
                public string Command;
                public bool IsActive;

                public string Color => IsActive ? BlueButtonColor : GreenButtonColor;
                public string TextColor => IsActive ? BlueButtonTextColor : GreenButtonTextColor;
            }

            public static void CreateContainerUi(BasePlayer player, int numPages, int activePageIndex, int capacity, Backpack backpack)
            {
                var numRows = 1 + (capacity - 1) / 6;
                var offsetY = BaseOffsetY + numRows * PerRowOffsetY;

                var builder = UiBuilder.Default;
                builder.Start();

                builder.AddSerializable(new UiElement<UiComponents<UiRectComponent>>
                {
                    Parent = "Hud.Menu",
                    Name = Name,
                    DestroyName = Name,
                    Components =
                    {
                        new UiRectComponent(BaseOffsetX, offsetY, Layout.AnchorBottomCenter),
                    },
                });

                var buttonLayoutProvider = new StatefulLayoutProvider
                {
                    Options = Layout.Option.AnchorBottom,
                    Spacing = 6,
                };

                if (backpack.CanGather)
                {
                    AddGatherModeButton(builder, ref buttonLayoutProvider, player, backpack, activePageIndex);
                }

                if (backpack.CanRetrieve)
                {
                    AddRetrieveButton(builder, ref buttonLayoutProvider, player, backpack, activePageIndex);
                }

                if (numPages > 1)
                {
                    AddPaginationUi(builder, backpack, numPages, activePageIndex);
                }

                builder.End();
                builder.AddUi(player);
            }

            public static void DestroyUi(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, Name);
            }

            private static void AddGatherModeButton(UiBuilder builder, ref StatefulLayoutProvider layoutProvider, BasePlayer player, Backpack backpack, int activePageIndex)
            {
                var gatherMode = backpack.GetGatherModeForPage(activePageIndex);

                builder.AddSerializable(new UiButtonElement<UiComponents<UiRectComponent, UiButtonComponent>, UiComponents<UiTextComponent>>
                {
                    Parent = Name,
                    Name = "Backpacks.Container.Gather",
                    Button =
                    {
                        new UiRectComponent(layoutProvider.Next(105, HeaderHeight)),
                        new UiButtonComponent
                        {
                            Command = "backpack.ui.togglegather",
                            Color = gatherMode == GatherMode.None ? GreenButtonColor : BlueButtonColor,
                        },
                    },
                    Text =
                    {
                        new UiTextComponent
                        {
                            Text = backpack.Plugin.GetMessage(player.UserIDString, gatherMode == GatherMode.All
                                ? LangEntry.UIGatherAll
                                : gatherMode == GatherMode.Existing
                                    ? LangEntry.UIGatherExisting
                                    : LangEntry.UIGatherOff),
                            Color = gatherMode == GatherMode.None ? GreenButtonTextColor : BlueButtonTextColor,
                            TextAlign = TextAnchor.MiddleCenter,
                            FontSize = 12,
                        },
                    },
                });
            }

            private static void AddRetrieveButton(UiBuilder builder, ref StatefulLayoutProvider layoutProvider, BasePlayer player, Backpack backpack, int activePageIndex)
            {
                var retrieve = backpack.IsRetrievingFromPage(activePageIndex);

                builder.AddSerializable(new UiButtonElement<UiComponents<UiRectComponent, UiButtonComponent>, UiComponents<UiTextComponent>>
                {
                    Parent = Name,
                    Name = "Backpacks.Container.Retrieve",
                    Button =
                    {
                        new UiRectComponent(layoutProvider.Next(85, HeaderHeight)),
                        new UiButtonComponent
                        {
                            Command = "backpack.ui.toggleretrieve",
                            Color = retrieve ? BlueButtonColor : GreenButtonColor,
                        },
                    },
                    Text =
                    {
                        new UiTextComponent
                        {
                            Text = backpack.Plugin.GetMessage(player.UserIDString, retrieve
                                ? LangEntry.UIRetrieveOn
                                : LangEntry.UIRetrieveOff),
                            Color = retrieve ? BlueButtonTextColor : GreenButtonTextColor,
                            TextAlign = TextAnchor.MiddleCenter,
                            FontSize = 12,
                        },
                    },
                });
            }

            private static void AddPageButton(UiBuilder builder, PageButton pageButton)
            {
                builder.AddSerializable(new UiButtonElement<UiComponents<UiRectComponent, UiButtonComponent>, UiComponents<UiTextComponent>>
                {
                    Parent = Name,
                    Name = pageButton.Name,
                    Button =
                    {
                        new UiRectComponent(pageButton.Rect),
                        new UiButtonComponent
                        {
                            Color = pageButton.Color,
                            Command = pageButton.Command,
                        },
                    },
                    Text =
                    {
                        new UiTextComponent
                        {
                            Text = pageButton.Text,
                            TextAlign = TextAnchor.MiddleCenter,
                            Color = pageButton.TextColor,
                        },
                    },
                });
            }

            private static void AddPaginationUi(UiBuilder builder, Backpack backpack, int numPages, int activePageIndex)
            {
                var containerUiOptions = backpack.Plugin._config.ContainerUi;
                var offsetY = containerUiOptions.ShowPageButtonsOnContainerBar
                    ? 0
                    : HeaderHeight + PageButtonSpacing;

                var buttonLayoutProvider = new StatelessLayoutProvider
                {
                    Options = Layout.Option.AnchorBottom | Layout.Option.AnchorRight,
                    Offset = new Vector2(-HeaderWidth, offsetY),
                    Size = new Vector2(PageButtonSize, PageButtonSize),
                    Spacing = PageButtonSpacing,
                };

                var maxPagesToShow = containerUiOptions.MaxPageButtonsToShow >= 0
                    ? containerUiOptions.MaxPageButtonsToShow
                    : int.MaxValue;

                var numPagesToShow = Mathf.Clamp(numPages, 1, maxPagesToShow);

                var pagesToShowOnLeft = (numPagesToShow - 1) / 2;
                var startPage = Math.Max(activePageIndex - pagesToShowOnLeft, 0);
                var endPage = Math.Min(startPage + numPagesToShow, numPages) - 1;

                if (endPage == numPages - 1)
                {
                    startPage = numPages - numPagesToShow;
                }

                var buttonIndex = 0;
                var showArrowButtons = numPages > numPagesToShow;

                if (showArrowButtons)
                {
                    AddPageButton(builder, new PageButton
                    {
                        Name = RightButtonName,
                        Rect = buttonLayoutProvider[buttonIndex++],
                        Text = ">",
                        Command = "backpack.next",
                    });
                }

                for (var pageIndex = endPage; pageIndex >= startPage; pageIndex--)
                {
                    var visiblePageNumber = pageIndex + 1;
                    var isActivePage = activePageIndex == pageIndex;

                    var pageButton = new PageButton
                    {
                        Name = DefaultStringCache.Instance.Get(pageIndex, n => $"{Name}.{n.ToString()}"),
                        Rect = buttonLayoutProvider[buttonIndex++],
                        IsActive = isActivePage,
                        Text = DefaultStringCache.Instance.Get(visiblePageNumber),
                        Command = isActivePage ? "" : DefaultStringCache.Instance.Get(visiblePageNumber, n => $"backpack.open {n.ToString()}"),
                    };

                    AddPageButton(builder, pageButton);

                    var arrowSize = new Vector2(PageButtonSize / 2, PageButtonSize / 2);
                    var arrowOffset = new Vector2(0, 1);

                    if (backpack.CanGather && backpack.GetGatherModeForPage(pageIndex) != GatherMode.None)
                    {
                        builder.AddSerializable(new UiElement<UiComponents<UiRectComponent, UiTextComponent>>
                        {
                            Parent = pageButton.Name,
                            Components =
                            {
                                new UiRectComponent(StatelessLayoutProvider.GetRect(0, Layout.Option.AnchorBottom | Layout.Option.AnchorRight | Layout.Option.Vertical, arrowSize, offset: arrowOffset)),
                                new UiTextComponent
                                {
                                    Text = "↓",
                                    FontSize = 10,
                                    TextAlign = TextAnchor.LowerRight,
                                    Color = pageButton.TextColor,
                                    VerticalWrapMode = VerticalWrapMode.Overflow,
                                },
                            },
                        });
                    }

                    if (backpack.CanRetrieve && backpack.IsRetrievingFromPage(pageIndex))
                    {
                        builder.AddSerializable(new UiElement<UiComponents<UiRectComponent, UiTextComponent>>
                        {
                            Parent = pageButton.Name,
                            Components =
                            {
                                new UiRectComponent(StatelessLayoutProvider.GetRect(0, Layout.Option.AnchorRight | Layout.Option.Vertical, arrowSize, offset: -arrowOffset)),
                                new UiTextComponent
                                {
                                    Text = "↑",
                                    FontSize = 10,
                                    TextAlign = TextAnchor.UpperRight,
                                    Color = pageButton.TextColor,
                                    VerticalWrapMode = VerticalWrapMode.Overflow,
                                },
                            },
                        });
                    }
                }

                if (showArrowButtons)
                {
                    AddPageButton(builder, new PageButton
                    {
                        Name = LeftButtonName,
                        Rect = buttonLayoutProvider[buttonIndex],
                        Text = "<",
                        Command = "backpack.prev",
                    });
                }
            }
        }

        private static class ButtonUi
        {
            private const string Name = "BackpacksUI";

            public static string CreateButtonUi(Configuration config)
            {
                var uiBuilder = UiBuilder.Default;

                uiBuilder.Start();
                uiBuilder.AddSerializable(new UiElement<UiComponents<UiRawImageComponent, UiRectTransformComponent>>
                {
                    Name = Name,
                    DestroyName = Name,
                    Parent = "Hud.Menu",
                    Components =
                    {
                        new UiRawImageComponent
                        {
                            Color = config.GUI.Color,
                            Sprite = "assets/content/ui/ui.background.tiletex.psd",
                        },
                        new UiRectTransformComponent
                        {
                            AnchorMin = config.GUI.GUIButtonPosition.AnchorsMin,
                            AnchorMax = config.GUI.GUIButtonPosition.AnchorsMax,
                            OffsetMin = config.GUI.GUIButtonPosition.OffsetsMin,
                            OffsetMax = config.GUI.GUIButtonPosition.OffsetsMax,
                        },
                    },
                });

                var rectTransformComponent = new UiRectTransformComponent
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1",
                };

                if (config.GUI.SkinId != 0)
                {
                    uiBuilder.AddSerializable(new UiElement<UiComponents<UiImageComponent, UiRectTransformComponent>>
                    {
                        Parent = Name,
                        Components =
                        {
                            new UiImageComponent
                            {
                                ItemId = SaddleBagItemId,
                                SkinId = config.GUI.SkinId,
                            },
                            rectTransformComponent,
                        },
                    });
                }
                else
                {
                    uiBuilder.AddSerializable(new UiElement<UiComponents<UiRawImageComponent, UiRectTransformComponent>>
                    {
                        Parent = Name,
                        Components =
                        {
                            new UiRawImageComponent
                            {
                                Url = config.GUI.Image,
                            },
                            rectTransformComponent,
                        },
                    });
                }

                uiBuilder.AddSerializable(new UiElement<UiComponents<UiButtonComponent, UiRectTransformComponent>>
                {
                    Parent = Name,
                    Components =
                    {
                        new UiButtonComponent
                        {
                            Command = "backpack.open",
                            Color = "0 0 0 0",
                        },
                        new UiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                        },
                    },
                });

                uiBuilder.End();
                return uiBuilder.ToJson();
            }

            public static void DestroyUi(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, Name);
            }
        }

        #endregion

        #region Subscriber Manager

        private class EventSubscriber
        {
            public static EventSubscriber FromSpec(Plugin plugin, Dictionary<string, object> spec)
            {
                var subscriber = new EventSubscriber { Plugin = plugin };

                GetOption(spec, nameof(OnBackpackLoaded), out subscriber.OnBackpackLoaded);
                GetOption(spec, nameof(OnBackpackItemCountChanged), out subscriber.OnBackpackItemCountChanged);
                GetOption(spec, nameof(OnBackpackGatherChanged), out subscriber.OnBackpackGatherChanged);
                GetOption(spec, nameof(OnBackpackRetrieveChanged), out subscriber.OnBackpackRetrieveChanged);

                return subscriber;
            }

            private static void GetOption<T>(Dictionary<string, object> dict, string key, out T result)
            {
                result = dict.TryGetValue(key, out var value) && value is T value1
                    ? value1
                    : default;
            }

            public Plugin Plugin { get; private set; }
            public Action<BasePlayer, int, int> OnBackpackLoaded;
            public Action<BasePlayer, int, int> OnBackpackItemCountChanged;
            public Action<BasePlayer, bool> OnBackpackGatherChanged;
            public Action<BasePlayer, bool> OnBackpackRetrieveChanged;
        }

        private class SubscriberManager
        {
            private readonly Dictionary<string, EventSubscriber> _subscribers = new();

            public void AddSubscriber(Plugin plugin, Dictionary<string, object> spec)
            {
                RemoveSubscriber(plugin);

                _subscribers[plugin.Name] = EventSubscriber.FromSpec(plugin, spec);
            }

            public void RemoveSubscriber(Plugin plugin)
            {
                _subscribers.Remove(plugin.Name);
            }

            public void BroadcastBackpackLoaded(Backpack backpack)
            {
                if (_subscribers.Count == 0 || (object)backpack.Owner == null)
                    return;

                foreach (var subscriber in _subscribers.Values)
                {
                    subscriber.OnBackpackLoaded?.Invoke(backpack.Owner, backpack.ItemCount, backpack.Capacity);
                }
            }

            public void BroadcastItemCountChanged(Backpack backpack)
            {
                if (_subscribers.Count == 0 || (object)backpack.Owner == null)
                    return;

                foreach (var subscriber in _subscribers.Values)
                {
                    subscriber.OnBackpackItemCountChanged?.Invoke(backpack.Owner, backpack.ItemCount, backpack.Capacity);
                }
            }

            public void BroadcastGatherChanged(Backpack backpack, bool isGathering)
            {
                if (_subscribers.Count == 0 || (object)backpack.Owner == null)
                    return;

                foreach (var subscriber in _subscribers.Values)
                {
                    subscriber.OnBackpackGatherChanged?.Invoke(backpack.Owner, isGathering);
                }
            }

            public void BroadcastRetrieveChanged(Backpack backpack, bool isRetrieving)
            {
                if (_subscribers.Count == 0 || (object)backpack.Owner == null)
                    return;

                foreach (var subscriber in _subscribers.Values)
                {
                    subscriber.OnBackpackRetrieveChanged?.Invoke(backpack.Owner, isRetrieving);
                }
            }
        }

        #endregion

        #region Backpack Capacity Manager

        private class CapacityManager
        {
            private class BackpackSize
            {
                public readonly int Capacity;
                public readonly string Permission;

                public BackpackSize(int capacity, string permission)
                {
                    Capacity = capacity;
                    Permission = permission;
                }
            }

            public struct CapacityInfo
            {
                public static implicit operator int(CapacityInfo capacityInfo) => capacityInfo.Current;

                public int Initial;
                public int Current;
                public int Max;

                public CapacityInfo(int capacity)
                {
                    Initial = capacity;
                    Current = capacity;
                    Max = capacity;
                }

                public CapacityInfo SetCapacity(int capacity)
                {
                    Current = Mathf.Clamp(capacity, Initial, Max);
                    return this;
                }

                public CapacityInfo AddCapacity(int amount)
                {
                    SetCapacity(Current + amount);
                    return this;
                }
            }

            private readonly Backpacks _plugin;
            private Configuration _config;
            private BackpackManager _backpackManager;
            private CapacityData _capacityData;
            private BackpackSize[] _sortedBackpackSizes;
            private readonly Dictionary<ulong, CapacityInfo> _cachedPlayerCapacityInfo = new();

            public CapacityManager(Backpacks plugin, BackpackManager backpackManager)
            {
                _plugin = plugin;
                _backpackManager = backpackManager;
            }

            public void Init(Configuration config, CapacityData capacityData)
            {
                _config = config;
                _capacityData = capacityData;

                var backpackSizeList = new List<BackpackSize>();

                if (config.BackpackSize.EnableLegacyRowPermissions)
                {
                    for (var row = MinRows; row <= MaxRows; row++)
                    {
                        var backpackSize = new BackpackSize(row * SlotsPerRow, $"{UsagePermission}.{row.ToString()}");
                        _plugin.permission.RegisterPermission(backpackSize.Permission, _plugin);
                        backpackSizeList.Add(backpackSize);
                    }
                }

                foreach (var capacity in new HashSet<int>(config.BackpackSize.PermissionSizes))
                {
                    backpackSizeList.Add(new BackpackSize(capacity, $"{SizePermission}.{capacity.ToString()}"));
                }

                backpackSizeList.Sort((a, b) => a.Capacity.CompareTo(b.Capacity));
                _sortedBackpackSizes = backpackSizeList.ToArray();

                foreach (var backpackSize in _sortedBackpackSizes)
                {
                    // The "backpacks.use.X" perms are registered all at once to make them easier to view.
                    if (backpackSize.Permission.StartsWith(UsagePermission))
                        continue;

                    _plugin.permission.RegisterPermission(backpackSize.Permission, _plugin);
                }
            }

            public void ForgetCachedCapacity(ulong userId)
            {
                _cachedPlayerCapacityInfo.Remove(userId);
            }

            public int GetCapacity(ulong userId, string userIdString)
            {
                return GetCapacityInfo(userId, userIdString).Current;
            }

            public int GetInitialCapacity(ulong userId, string userIdString)
            {
                return GetCapacityInfo(userId, userIdString).Initial;
            }

            public int GetMaxCapacity(ulong userId, string userIdString)
            {
                return GetCapacityInfo(userId, userIdString).Max;
            }

            public int SetCapacity(ulong userId, string userIdString, int amount)
            {
                if (!_config.BackpackSize.DynamicSize.Enabled)
                    throw new InvalidOperationException("Cannot set capacity because dynamic capacity is not enabled in the config");

                return UpdateCapacity(userId, DetermineCapacityInfo(userId, userIdString).SetCapacity(amount));
            }

            public int SetCapacity(BasePlayer player, int amount)
            {
                return SetCapacity(player.userID, player.UserIDString, amount);
            }

            public int AddCapacity(ulong userId, string userIdString, int amount)
            {
                if (!_config.BackpackSize.DynamicSize.Enabled)
                    throw new InvalidOperationException("Cannot add capacity because dynamic capacity is not enabled in the config");

                return UpdateCapacity(userId, DetermineCapacityInfo(userId, userIdString).AddCapacity(amount));
            }

            public int AddCapacity(BasePlayer player, int amount)
            {
                return AddCapacity(player.userID, player.UserIDString, amount);
            }

            private CapacityInfo UpdateCapacity(ulong userId, CapacityInfo capacityInfo)
            {
                _cachedPlayerCapacityInfo[userId] = capacityInfo;
                SetBonusCapacity(userId, capacityInfo);
                _backpackManager.GetBackpackIfCached(userId)?.SetCapacity(capacityInfo.Current);
                return capacityInfo;
            }

            private void SetBonusCapacity(ulong userId, CapacityInfo capacityInfo)
            {
                _capacityData.SetPlayerBonusCapacity(userId, capacityInfo.Current - capacityInfo.Initial);
                _capacityData.RemovePlayerExactCapacity(userId);
            }

            private CapacityInfo GetCapacityInfo(ulong userId, string userIdString)
            {
                if (!_cachedPlayerCapacityInfo.TryGetValue(userId, out var capacityInfo))
                {
                    capacityInfo = DetermineCapacityInfo(userId, userIdString);
                    _cachedPlayerCapacityInfo[userId] = capacityInfo;
                    // Set bonus capacity to migrate from exact capacity.
                    SetBonusCapacity(userId, capacityInfo);
                }

                return capacityInfo;
            }

            private int DetermineCapacityFromPermission(string userIdString)
            {
                for (var i = _sortedBackpackSizes.Length - 1; i >= 0; i--)
                {
                    var backpackSize = _sortedBackpackSizes[i];
                    if (_plugin.permission.UserHasPermission(userIdString, backpackSize.Permission))
                        return backpackSize.Capacity;
                }

                return _config.BackpackSize.DefaultSize;
            }

            private CapacityInfo DetermineCapacityInfo(ulong userId, string userIdString)
            {
                if (!_plugin.permission.UserHasPermission(userIdString, UsagePermission))
                    return new CapacityInfo(0);

                if (_config.BackpackSize.DynamicSize.Enabled
                    && _config.BackpackSize.DynamicSize.GetPlayerProfile(userIdString) is var (initial, max))
                {
                    initial = Math.Min(initial, max);

                    return new CapacityInfo
                    {
                        Initial = initial,
                        Current = Mathf.Clamp(DetermineCurrentCapacity(userId, initial), initial, max),
                        Max = max,
                    };
                }

                return new CapacityInfo(DetermineCapacityFromPermission(userIdString));
            }

            private int DetermineCurrentCapacity(ulong userId, int initialCapacity)
            {
                if (_capacityData == null)
                    return initialCapacity;

                if (_capacityData.GetPlayerExactCapacity(userId) is {} exactCapacity)
                    return exactCapacity;

                if (_capacityData.GetPlayerBonusCapacity(userId) is {} bonusCapacity)
                    return initialCapacity + bonusCapacity;

                return initialCapacity;
            }
        }

        #endregion

        #region Backpack Manager

        private class BackpackManager
        {
            private static string DetermineBackpackPath(ulong userId) => $"{nameof(Backpacks)}/{userId.ToString()}";

            private readonly Backpacks _plugin;

            private readonly Dictionary<ulong, Backpack> _cachedBackpacks = new();
            private readonly Dictionary<ulong, string> _backpackPathCache = new();
            private readonly Dictionary<ItemContainer, Backpack> _backpackContainers = new();
            private readonly List<DroppedItemContainer> _reusableDroppedItemContainerList = new();

            private readonly List<Backpack> _tempBackpackList = new(PoolUtils.BackpackPoolSize);

            public BackpackManager(Backpacks plugin)
            {
                _plugin = plugin;
            }

            public void HandleCapacityPermissionChangedForGroup(string groupName)
            {
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    if (!_plugin.permission.UserHasGroup(backpack.OwnerIdString, groupName))
                        continue;

                    _plugin._capacityManager.ForgetCachedCapacity(backpack.OwnerId);
                    backpack.SetFlag(Backpack.Flag.CapacityCached, false);
                }
            }

            public void HandleCapacityPermissionChangedForUser(string userIdString)
            {
                var backpack = GetBackpackIfCached(userIdString);
                if (backpack == null)
                    return;

                _plugin._capacityManager.ForgetCachedCapacity(backpack.OwnerId);
                backpack.SetFlag(Backpack.Flag.CapacityCached, false);
            }

            public void HandleRestrictionPermissionChangedForGroup(string groupName)
            {
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    if (!_plugin.permission.UserHasGroup(backpack.OwnerIdString, groupName))
                        continue;

                    backpack.SetFlag(Backpack.Flag.RestrictionsCached, false);
                }
            }

            public void HandleRestrictionPermissionChangedForUser(string userIdString)
            {
                GetBackpackIfCached(userIdString)?.SetFlag(Backpack.Flag.RestrictionsCached, false);
            }

            public void HandleGatherPermissionChangedForGroup(string groupName)
            {
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    if (!_plugin.permission.UserHasGroup(backpack.OwnerIdString, groupName))
                        continue;

                    backpack.SetFlag(Backpack.Flag.GatherCached, false);
                }
            }

            public void HandleGatherPermissionChangedForUser(string userIdString)
            {
                GetBackpackIfCached(userIdString)?.SetFlag(Backpack.Flag.GatherCached, false);
            }

            public void HandleRetrievePermissionChangedForGroup(string groupName)
            {
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    if (!_plugin.permission.UserHasGroup(backpack.OwnerIdString, groupName))
                        continue;

                    backpack.SetFlag(Backpack.Flag.RetrieveCached, false);
                }
            }

            public void HandleRetrievePermissionChangedForUser(string userIdString)
            {
                GetBackpackIfCached(userIdString)?.SetFlag(Backpack.Flag.RetrieveCached, false);
            }

            public void HandleGroupChangeForUser(string userIdString)
            {
                var backpack = GetBackpackIfCached(userIdString);
                if (backpack == null)
                    return;

                _plugin._capacityManager.ForgetCachedCapacity(backpack.OwnerId);
                backpack.SetFlag(Backpack.Flag.CapacityCached, false);
                backpack.SetFlag(Backpack.Flag.RestrictionsCached, false);
                backpack.SetFlag(Backpack.Flag.GatherCached, false);
                backpack.SetFlag(Backpack.Flag.RetrieveCached, false);
            }

            public bool IsBackpack(ItemContainer container)
            {
                return _backpackContainers.ContainsKey(container);
            }

            public bool IsBackpack(ItemContainer container, out Backpack backpack, out int pageIndex)
            {
                if (!_backpackContainers.TryGetValue(container, out backpack))
                {
                    pageIndex = 0;
                    return false;
                }

                pageIndex = backpack.GetPageIndexForContainer(container);
                if (pageIndex == -1)
                {
                    pageIndex = 0;
                    return false;
                }

                return true;
            }

            public bool HasBackpack(ulong userId)
            {
                return _cachedBackpacks.ContainsKey(userId) || HasBackpackFile(userId);
            }

            public Backpack GetBackpackIfCached(ulong userId)
            {
                return _cachedBackpacks.TryGetValue(userId, out var backpack)
                    ? backpack
                    : null;
            }

            public Backpack GetBackpack(ulong userId)
            {
                return GetBackpackIfCached(userId) ?? Load(userId);
            }

            public Backpack GetBackpackIfExists(ulong userId)
            {
                return GetBackpackIfCached(userId) ?? (HasBackpackFile(userId)
                    ? Load(userId)
                    : null);
            }

            public void RegisterContainer(ItemContainer container, Backpack backpack)
            {
                _backpackContainers[container] = backpack;
            }

            public void UnregisterContainer(ItemContainer container)
            {
                _backpackContainers.Remove(container);
            }

            public Backpack GetCachedBackpackForContainer(ItemContainer container)
            {
                return _backpackContainers.TryGetValue(container, out var backpack)
                    ? backpack
                    : null;
            }

            public Dictionary<ulong, ItemContainer> GetAllCachedContainers()
            {
                var cachedContainersByUserId = new Dictionary<ulong, ItemContainer>();

                foreach (var entry in _cachedBackpacks)
                {
                    var container = entry.Value.GetContainer();
                    if (container != null)
                        cachedContainersByUserId[entry.Key] = container;
                }

                return cachedContainersByUserId;
            }

            public DroppedItemContainer Drop(ulong userId, Vector3 position, List<DroppedItemContainer> collect = null)
            {
                var backpack = GetBackpackIfExists(userId);
                if (backpack == null)
                {
                    #if DEBUG_DROP_ON_DEATH
                    LogWarning($"[DEBUG_DROP_ON_DEATH] [Player {userId.ToString()}] Backpack not dropped because the player has no backpack in memory or on disk.");
                    #endif
                    return null;
                }

                var firstDroppedItemContainer = (DroppedItemContainer)null;
                _reusableDroppedItemContainerList.Clear();

                if (backpack.Drop(position, _reusableDroppedItemContainerList))
                {
                    firstDroppedItemContainer = _reusableDroppedItemContainerList.FirstOrDefault();
                    collect?.AddRange(_reusableDroppedItemContainerList);
                    ExposedHooks.OnBackpackDropped(userId, _reusableDroppedItemContainerList);
                    _reusableDroppedItemContainerList.Clear();
                }

                return firstDroppedItemContainer;
            }

            public bool TryOpenBackpack(BasePlayer looter, ulong backpackOwnerId)
            {
                if (backpackOwnerId == 0)
                {
                    backpackOwnerId = looter.userID;
                }

                return GetBackpack(backpackOwnerId).TryOpen(looter);
            }

            public bool TryOpenBackpackContainer(BasePlayer looter, ulong backpackOwnerId, ItemContainer container)
            {
                if (backpackOwnerId == 0)
                {
                    backpackOwnerId = looter.userID;
                }

                if (!IsBackpack(container, out var backpack, out var pageIndex) || backpack.OwnerId != backpackOwnerId)
                {
                    backpack = GetBackpack(backpackOwnerId);
                    pageIndex = -1;
                }

                return backpack.TryOpen(looter, pageIndex);
            }

            public bool TryOpenBackpackPage(BasePlayer looter, ulong backpackOwnerId, int pageIndex = -1)
            {
                if (backpackOwnerId == 0)
                {
                    backpackOwnerId = looter.userID;
                }

                return GetBackpack(backpackOwnerId).TryOpen(looter, pageIndex);
            }

            public void DeleteBackpackFile(ulong userId)
            {
                Interface.Oxide.DataFileSystem.DeleteDataFile(GetBackpackPath(userId));
            }

            public bool TryEraseForPlayer(ulong userId)
            {
                var backpack = GetBackpackIfExists(userId);
                if (backpack == null)
                    return false;

                backpack.EraseContents(force: true);
                return true;
            }

            public IEnumerator SaveAllAndKill(bool async, bool keepInUseBackpacks)
            {
                // Clear the list before usage, in case an error prevented cleanup, or in case coroutine was restarted.
                _tempBackpackList.Clear();

                // Copy the list of cached backpacks because it may be modified.
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    _tempBackpackList.Add(backpack);
                }

                foreach (var backpack in _tempBackpackList)
                {
                    var didSave = false;

                    try
                    {
                        didSave = backpack.SaveIfChanged();
                    }
                    catch (Exception ex)
                    {
                        LogError($"Error when saving player backpack {backpack.OwnerIdString}:\n{ex}");
                    }

                    // Kill the backpack to free up space, if no admins are viewing it and its owner is disconnected.
                    if (!keepInUseBackpacks || (!backpack.HasLooters && BasePlayer.FindByID(backpack.OwnerId) == null))
                    {
                        backpack.Kill();
                        _cachedBackpacks.Remove(backpack.OwnerId);
                        _backpackPathCache.Remove(backpack.OwnerId);
                        var backpackToFree = backpack;
                        CustomPool.Free(ref backpackToFree);
                    }

                    if (didSave && async)
                        yield return null;
                }

                _tempBackpackList.Clear();
            }

            public void ClearCache()
            {
                foreach (var backpack in _cachedBackpacks.Values)
                {
                    backpack.Kill();
                    var backpackToFree = backpack;
                    CustomPool.Free(ref backpackToFree);
                }

                _cachedBackpacks.Clear();
            }

            private string GetBackpackPath(ulong userId)
            {
                if (!_backpackPathCache.TryGetValue(userId, out var filepath))
                {
                    filepath = DetermineBackpackPath(userId);
                    _backpackPathCache[userId] = filepath;
                }

                return filepath;
            }

            private bool HasBackpackFile(ulong userId)
            {
                return Interface.Oxide.DataFileSystem.ExistsDatafile(GetBackpackPath(userId));
            }

            private Backpack Load(ulong userId)
            {
                #if DEBUG_BACKPACK_LIFECYCLE
                LogDebug($"Backpack::Load | {userId.ToString()}");
                #endif

                var filePath = GetBackpackPath(userId);

                Backpack backpack = null;

                var dataFile = Interface.Oxide.DataFileSystem.GetFile(filePath);
                if (dataFile.Exists())
                {
                    backpack = dataFile.ReadObject<Backpack>();
                }

                // Note: Even if the user has a backpack file, the file contents may be null in some edge cases.
                // For example, if a data file cleaner plugin writes the file content as `null`.
                backpack ??= CustomPool.Get<Backpack>();
                backpack.Setup(_plugin, userId, dataFile);
                _cachedBackpacks[userId] = backpack;

                if (backpack.IsRetrieving)
                {
                    backpack.Owner?.inventory?.containerMain?.MarkDirty();
                }

                _plugin._subscriberManager.BroadcastBackpackLoaded(backpack);

                return backpack;
            }

            private Backpack GetBackpackIfCached(string userIdString)
            {
                if (!ulong.TryParse(userIdString, out var userId))
                    return null;

                return GetBackpackIfCached(userId);
            }
        }

        #endregion

        #region Backpack Networking

        private class BackpackNetworkController
        {
            private const uint StartNetworkGroupId = 10000000;
            private static uint _nextNetworkGroupId = StartNetworkGroupId;

            public static void ResetNetworkGroupId()
            {
                _nextNetworkGroupId = StartNetworkGroupId;
            }

            public static bool IsBackpackNetworkGroup(Network.Visibility.Group group)
            {
                return group.ID >= StartNetworkGroupId && group.ID < _nextNetworkGroupId;
            }

            public static BackpackNetworkController Create()
            {
                return new BackpackNetworkController(_nextNetworkGroupId++);
            }

            public readonly Network.Visibility.Group NetworkGroup;

            private readonly List<BasePlayer> _subscribers = new(1);

            private BackpackNetworkController(uint networkGroupId)
            {
                NetworkGroup = new Network.Visibility.Group(null, networkGroupId);
            }

            public void Subscribe(BasePlayer player)
            {
                if (player.Connection == null || _subscribers.Contains(player))
                    return;

                _subscribers.Add(player);

                // Send the client a message letting them know they are subscribed to the group.
                ServerMgr.OnEnterVisibility(player.Connection, NetworkGroup);

                // Send the client a snapshot of every entity currently in the group.
                // Don't use the entity queue for this because it could be cleared which could cause updates to be missed.
                foreach (var networkable in NetworkGroup.networkables)
                {
                    (networkable.handler as BaseNetworkable).SendAsSnapshot(player.Connection);
                }

                if (!NetworkGroup.subscribers.Contains(player.Connection))
                {
                    // Register the client with the group so that entities added to it will be automatically sent to the client.
                    NetworkGroup.subscribers.Add(player.Connection);
                }

                var subscriber = player.net.subscriber;
                if (!subscriber.subscribed.Contains(NetworkGroup))
                {
                    // Register the group with the client so that ShouldNetworkTo() returns true in SendNetworkUpdate().
                    // This covers cases such as toggling a pager's silent mode.
                    subscriber.subscribed.Add(NetworkGroup);
                }
            }

            public void Unsubscribe(BasePlayer player)
            {
                if (!_subscribers.Remove(player))
                    return;

                if (player.Connection == null)
                    return;

                // Unregister the client from the group so they don't get future entity updates.
                NetworkGroup.subscribers.Remove(player.Connection);
                player.net.subscriber.subscribed.Remove(NetworkGroup);

                // Send the client a message so they kill all client-side entities in the group.
                ServerMgr.OnLeaveVisibility(player.Connection, NetworkGroup);
            }

            public void UnsubscribeAll()
            {
                for (var i = _subscribers.Count - 1; i >= 0; i--)
                {
                    Unsubscribe(_subscribers[i]);
                }
            }
        }

        #endregion

        #region Unity Components

        private class NoRagdollCollision : FacepunchBehaviour
        {
            private Collider _collider;

            private void Awake()
            {
                _collider = GetComponent<Collider>();
            }

            private void OnCollisionEnter(Collision collision)
            {
                if (collision.collider.IsOnLayer(Layer.Ragdoll))
                {
                    Physics.IgnoreCollision(_collider, collision.collider);
                }
            }
        }

        private class BackpackCloseListener : EntityComponent<StorageContainer>
        {
            public static void AddToBackpackStorage(Backpacks plugin, StorageContainer containerEntity, Backpack backpack)
            {
                var component = containerEntity.gameObject.AddComponent<BackpackCloseListener>();
                component._plugin = plugin;
                component._backpack = backpack;
            }

            private Backpacks _plugin;
            private Backpack _backpack;

            // Called via `entity.SendMessage("PlayerStoppedLooting", player)` in PlayerLoot.Clear().
            private void PlayerStoppedLooting(BasePlayer looter)
            {
                _plugin.TrackStart();
                _backpack.OnClosed(looter);
                ExposedHooks.OnBackpackClosed(looter, _backpack.OwnerId, looter.inventory.loot.containers.FirstOrDefault());
                _plugin.TrackEnd();
            }
        }

        #endregion

        #region Item Query

        private struct MutationRequest
        {
            public static MutationRequest Parse(Dictionary<string, object> raw)
            {
                var mutation = new MutationRequest();

                GetOption(raw, "ItemId", out mutation.ItemId);
                GetOption(raw, "SkinId", out mutation.SkinId);
                GetOption(raw, "DisplayName", out mutation.DisplayName);

                return mutation;
            }

            private static void GetOption<T>(Dictionary<string, object> dict, string key, out T result)
            {
                result = dict.TryGetValue(key, out var value) && value is T value1
                    ? value1
                    : default;
            }

            public int? ItemId;
            public ulong? SkinId;
            public string DisplayName;

            public bool ApplyTo(Item item)
            {
                var changed = false;

                if (ItemId.HasValue && item.info.itemid != ItemId)
                {
                    var newItemDefinition = ItemManager.FindItemDefinition(ItemId.Value);
                    if (newItemDefinition != null)
                    {
                        // Tear down item mods belonging to old item definition.
                        foreach (var itemMod in item.info.itemMods)
                        {
                            itemMod.OnRemove(item);
                        }

                        item.info = newItemDefinition;

                        // Initialize item mods using new item definition.
                        item.OnItemCreated();

                        changed = true;
                    }
                    else
                    {
                        LogError($"Unable to change {item.info.shortname} item to an instance of Item ID {ItemId.Value} because no matching ItemDefinition was found.");
                    }
                }

                if (SkinId.HasValue && item.skin != SkinId)
                {
                    item.skin = SkinId.Value;

                    var heldEntity = item.GetHeldEntity();
                    if (heldEntity != null)
                    {
                        heldEntity.skinID = SkinId.Value;
                    }

                    changed = true;
                }

                if (!string.IsNullOrEmpty(DisplayName) && !StringUtils.EqualsCaseInsensitive(DisplayName, item.name))
                {
                    item.name = DisplayName;
                    changed = true;
                }

                return changed;
            }

            public bool ApplyTo(ItemData itemData)
            {
                var changed = false;

                if (ItemId.HasValue && itemData.ID != ItemId)
                {
                    itemData.ID = ItemId.Value;
                    changed = true;
                }

                if (SkinId.HasValue && itemData.Skin != SkinId)
                {
                    itemData.Skin = SkinId.Value;
                    changed = true;
                }

                if (!string.IsNullOrEmpty(DisplayName) && !StringUtils.EqualsCaseInsensitive(DisplayName, itemData.Name))
                {
                    itemData.Name = DisplayName;
                    changed = true;
                }

                return changed;
            }
        }

        private struct ItemQuery
        {
            public static ItemQuery FromItem(Item item)
            {
                return new ItemQuery
                {
                    BlueprintId = item.blueprintTarget,
                    DataInt = item.instanceData?.dataInt ?? 0,
                    DisplayName = item.name,
                    ItemDefinition = item.info,
                    ItemId = item.info.itemid,
                    SkinId = item.skin,
                };
            }

            public static ItemQuery Parse(Dictionary<string, object> raw)
            {
                var itemQuery = new ItemQuery();

                GetOption(raw, "BlueprintId", out itemQuery.BlueprintId);
                GetOption(raw, "DisplayName", out itemQuery.DisplayName);
                GetOption(raw, "DataInt", out itemQuery.DataInt);
                GetOption(raw, "FlagsContain", out itemQuery.FlagsContain);
                GetOption(raw, "FlagsEqual", out itemQuery.FlagsEqual);
                GetOption(raw, "IgnoreItem", out itemQuery.IgnoreItem);
                GetOption(raw, "ItemDefinition", out itemQuery.ItemDefinition);
                GetOption(raw, "ItemId", out itemQuery.ItemId);
                GetOption(raw, "MinCondition", out itemQuery.MinCondition);
                GetOption(raw, "RequireEmpty", out itemQuery.RequireEmpty);
                GetOption(raw, "SkinId", out itemQuery.SkinId);

                return itemQuery;
            }

            private static void GetOption<T>(Dictionary<string, object> dict, string key, out T result)
            {
                result = dict.TryGetValue(key, out var value) && value is T value1
                    ? value1
                    : default;
            }

            public int? BlueprintId;
            public int? DataInt;
            public string DisplayName;
            public Item.Flag? FlagsContain;
            public Item.Flag? FlagsEqual;
            public Item IgnoreItem;
            public ItemDefinition ItemDefinition;
            public int? ItemId;
            public float MinCondition;
            public bool RequireEmpty;
            public ulong? SkinId;

            private int? GetItemId()
            {
                if (ItemDefinition != null)
                    return ItemDefinition?.itemid ?? ItemId;

                return ItemId;
            }

            private ItemDefinition GetItemDefinition()
            {
                if ((object)ItemDefinition == null && ItemId.HasValue)
                {
                    ItemDefinition = ItemManager.FindItemDefinition(ItemId.Value);
                }

                return ItemDefinition;
            }

            private bool HasCondition()
            {
                return GetItemDefinition()?.condition.enabled ?? false;
            }

            private float ConditionNormalized(ItemData itemData)
            {
                return itemData.Condition / itemData.MaxCondition;
            }

            private float MaxConditionNormalized(ItemData itemData)
            {
                var itemDefinition = GetItemDefinition();
                if (itemDefinition == null)
                    return 1;

                return itemData.MaxCondition / itemDefinition.condition.max;
            }

            public int GetUsableAmount(Item item)
            {
                if (IgnoreItem != null && item == IgnoreItem)
                    return 0;

                var itemId = GetItemId();
                if (itemId.HasValue && itemId != item.info.itemid)
                    return 0;

                if (SkinId.HasValue && SkinId != item.skin)
                    return 0;

                if (BlueprintId.HasValue && BlueprintId != item.blueprintTarget)
                    return 0;

                if (DataInt.HasValue && DataInt != (item.instanceData?.dataInt ?? 0))
                    return 0;

                if (FlagsContain.HasValue && !item.flags.HasFlag(FlagsContain.Value))
                    return 0;

                if (FlagsEqual.HasValue && FlagsEqual != item.flags)
                    return 0;

                if (MinCondition > 0 && HasCondition() && (item.conditionNormalized < MinCondition || item.maxConditionNormalized < MinCondition))
                    return 0;

                if (!string.IsNullOrEmpty(DisplayName) && !StringUtils.EqualsCaseInsensitive(DisplayName, item.name))
                    return 0;

                return RequireEmpty && item.contents?.itemList?.Count > 0
                    ? Math.Max(0, item.amount - 1)
                    : item.amount;
            }

            public int GetUsableAmount(ItemData itemData)
            {
                var itemId = GetItemId();
                if (itemId.HasValue && itemId != itemData.ID)
                    return 0;

                if (SkinId.HasValue && SkinId != itemData.Skin)
                    return 0;

                if (BlueprintId.HasValue && BlueprintId != itemData.BlueprintTarget)
                    return 0;

                if (DataInt.HasValue && DataInt != itemData.DataInt)
                    return 0;

                if (FlagsContain.HasValue && !itemData.Flags.HasFlag(FlagsContain.Value))
                    return 0;

                if (FlagsEqual.HasValue && FlagsEqual != itemData.Flags)
                    return 0;

                if (MinCondition > 0 && HasCondition() && (ConditionNormalized(itemData) < MinCondition || MaxConditionNormalized(itemData) < MinCondition))
                    return 0;

                if (!string.IsNullOrEmpty(DisplayName) && !StringUtils.EqualsCaseInsensitive(DisplayName, itemData.Name))
                    return 0;

                return RequireEmpty && itemData.Contents?.Count > 0
                    ? Math.Max(0, itemData.Amount - 1)
                    : itemData.Amount;
            }
        }

        #endregion

        #region Container Adapters

        private struct WipeContext
        {
            public int SlotsKept;
        }

        private interface IContainerAdapter : CustomPool.IPooled
        {
            int PageIndex { get; }
            int Capacity { get; set; }
            int ItemCount { get; }
            bool HasItems { get; }
            int PositionOf(ref ItemQuery itemQuery);
            int CountItems(ref ItemQuery itemQuery);
            int SumItems(ref ItemQuery itemQuery);
            int TakeItems(ref ItemQuery itemQuery, int amount, List<Item> collect);
            int MutateItems(ref ItemQuery itemQuery, ref MutationRequest mutationRequest);
            bool TryDepositItem(Item item);
            void ReclaimFractionForSoftcore(float fraction, List<Item> collect);
            void TakeRestrictedItems(List<Item> collect);
            void TakeAllItems(List<Item> collect, int startPosition = 0);
            void SerializeForNetwork(List<ProtoBuf.Item> saveList);
            void SerializeTo(List<ItemData> saveList, List<ItemData> itemsToReleaseToPool);
            void EraseContents(WipeRuleset ruleset, ref WipeContext wipeContext);
            void Kill();
            void FreeToPool();
        }

        private class VirtualContainerAdapter : IContainerAdapter
        {
            public int PageIndex { get; private set; }
            public int Capacity { get; set; }
            public List<ItemData> ItemDataList { get; } = new(_maxCapacityPerPage);
            public int ItemCount => ItemDataList.Count;
            public bool HasItems => ItemCount > 0;

            private Backpack _backpack;

            public VirtualContainerAdapter Setup(Backpack backpack, int pageIndex, int capacity)
            {
                #if DEBUG_POOLING
                LogDebug($"VirtualContainerAdapter::Setup | PageIndex: {pageIndex.ToString()} | Capacity: {capacity.ToString()}");
                #endif

                PageIndex = pageIndex;
                Capacity = capacity;
                _backpack = backpack;
                return this;
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"VirtualContainerAdapter::EnterPool | {CustomPool.GetStats<VirtualContainerAdapter>()}");
                #endif

                PageIndex = 0;
                Capacity = 0;
                PoolUtils.ResetItemsAndClear(ItemDataList);
                _backpack = null;
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"VirtualContainerAdapter::LeavePool | {CustomPool.GetStats<VirtualContainerAdapter>()}");
                #endif
            }

            public void SortByPosition()
            {
                ItemDataList.Sort((a, b) => a.Position.CompareTo(b.Position));
            }

            public int PositionOf(ref ItemQuery itemQuery)
            {
                SortByPosition();
                return ItemUtils.PositionOf(ItemDataList, ref itemQuery);
            }

            public int CountItems(ref ItemQuery itemQuery)
            {
                return ItemUtils.CountItems(ItemDataList, ref itemQuery);
            }

            public int SumItems(ref ItemQuery itemQuery)
            {
                return ItemUtils.SumItems(ItemDataList, ref itemQuery);
            }

            public int TakeItems(ref ItemQuery itemQuery, int amount, List<Item> collect)
            {
                var originalItemCount = ItemCount;

                var amountTaken = ItemUtils.TakeItems(ItemDataList, ref itemQuery, amount, collect);
                if (amountTaken > 0)
                {
                    _backpack.SetFlag(Backpack.Flag.Dirty, true);

                    if (ItemCount != originalItemCount)
                    {
                        _backpack.HandleItemCountChanged();
                    }
                }

                return amountTaken;
            }

            public int MutateItems(ref ItemQuery itemQuery, ref MutationRequest mutationRequest)
            {
                var mutatedItems = ItemUtils.MutateItems(ItemDataList, ref itemQuery, ref mutationRequest);
                if (mutatedItems > 0)
                {
                    _backpack.SetFlag(Backpack.Flag.Dirty, true);
                }

                return mutatedItems;
            }

            public void ReclaimFractionForSoftcore(float fraction, List<Item> collect)
            {
                // For some reason, the vanilla reclaim logic doesn't take the last item.
                if (ItemDataList.Count <= 1)
                    return;

                var numToTake = Mathf.Ceil(ItemDataList.Count * fraction);

                for (var i = 0; i < numToTake; i++)
                {
                    var indexToTake = UnityEngine.Random.Range(0, ItemDataList.Count);
                    var itemDataToTake = ItemDataList[indexToTake];
                    if (itemDataToTake.Amount > 1)
                    {
                        // Prefer taking a smaller stack if possible (vanilla behavior).
                        for (var j = 0; j < ItemDataList.Count; j++)
                        {
                            var alternateItemData = ItemDataList[j];
                            if (alternateItemData.ID != itemDataToTake.ID)
                                continue;

                            if (alternateItemData.Amount >= itemDataToTake.Amount)
                                continue;

                            itemDataToTake = alternateItemData;
                            indexToTake = j;
                        }
                    }

                    var item = itemDataToTake.ToItem();
                    if (item != null)
                    {
                        collect.Add(item);
                    }

                    RemoveItem(indexToTake);
                }
            }

            public void TakeRestrictedItems(List<Item> collect)
            {
                if (ItemDataList.Count == 0)
                    return;

                for (var i = ItemDataList.Count - 1; i >= 0; i--)
                {
                    var itemData = ItemDataList[i];
                    if (_backpack.RestrictionRuleset.AllowsItem(itemData))
                        continue;

                    var item = itemData.ToItem();
                    if (item != null)
                    {
                        collect.Add(item);
                    }

                    RemoveItem(i);
                }
            }

            public void TakeAllItems(List<Item> collect, int startPosition = 0)
            {
                SortByPosition();

                if (ItemDataList.Count == 0)
                    return;

                for (var i = 0; i < ItemDataList.Count; i++)
                {
                    var itemData = ItemDataList[i];
                    if (itemData.Position < startPosition)
                        continue;

                    var item = itemData.ToItem();
                    if (item != null)
                    {
                        collect.Add(item);
                    }

                    RemoveItem(i--);
                }
            }

            public void SerializeForNetwork(List<ProtoBuf.Item> saveList)
            {
                ItemUtils.SerializeForNetwork(ItemDataList, saveList);
            }

            public void SerializeTo(List<ItemData> saveList, List<ItemData> itemsToReleaseToPool)
            {
                foreach (var itemData in ItemDataList)
                {
                    saveList.Add(itemData);
                }
            }

            public void EraseContents(WipeRuleset ruleset, ref WipeContext wipeContext)
            {
                if (ruleset == null || ruleset.DisallowsAll)
                {
                    if (ItemDataList.Count > 0)
                    {
                        PoolUtils.ResetItemsAndClear(ItemDataList);
                        _backpack.SetFlag(Backpack.Flag.Dirty, true);
                    }
                    return;
                }

                SortByPosition();

                for (var i = 0; i < ItemDataList.Count; i++)
                {
                    var itemData = ItemDataList[i];
                    if ((ruleset.MaxSlotsToKeep < 0 || wipeContext.SlotsKept < ruleset.MaxSlotsToKeep)
                        && ruleset.AllowsItem(itemData))
                    {
                        wipeContext.SlotsKept++;
                        continue;
                    }

                    RemoveItem(i--);
                }
            }

            public void Kill()
            {
                // Intentionally not implemented because there are no actual resources to destroy.
            }

            public void FreeToPool()
            {
                var self = this;
                CustomPool.Free(ref self);
            }

            public VirtualContainerAdapter CopyItemsFrom(List<ItemData> itemDataList)
            {
                var startPosition = PageIndex * _maxCapacityPerPage;
                var endPosition = startPosition + Capacity;

                // This assumes the list has already been sorted by item position.
                foreach (var itemData in itemDataList)
                {
                    if (itemData.Position < startPosition)
                        continue;

                    if (itemData.Position >= endPosition)
                        break;

                    ItemDataList.Add(itemData);
                }

                return this;
            }

            public bool TryDepositItem(Item item)
            {
                var firstEmptyPosition = GetFirstEmptyPosition();
                if (firstEmptyPosition >= Capacity)
                {
                    // To keep things simple, simply deny the item if there are no empty slots. This is done because
                    // it's difficult to know whether the item can be stacked with an existing item without calling
                    // stacking related hooks which require a physical page and item. This results in an edge case
                    // where if all pages are full, and no physical pages can accept the item, then any full virtual
                    // page would reject the item, even if upgrading the page would allow the item. In the future, the
                    // page could be upgraded to a physical container to handle this edge case if necessary.
                    return false;
                }

                if (!_backpack.ShouldAcceptItem(item, null))
                    return false;

                var itemData = CustomPool.Get<ItemData>().Setup(item, firstEmptyPosition);
                ItemDataList.Add(itemData);

                item.RemoveFromContainer();
                item.Remove();

                _backpack.SetFlag(Backpack.Flag.Dirty, true);
                _backpack.HandleItemCountChanged();
                return true;
            }

            private int GetFirstEmptyPosition()
            {
                var nextPossiblePosition = 0;

                for (var i = 0; i < ItemDataList.Count; i++)
                {
                    var itemData = ItemDataList[i];
                    if (itemData.Position > nextPossiblePosition)
                        return i;

                    nextPossiblePosition++;
                }

                return nextPossiblePosition;
            }

            private void RemoveItem(int index)
            {
                var itemData = ItemDataList[index];
                ItemDataList.RemoveAt(index);
                CustomPool.Free(ref itemData);
                _backpack.SetFlag(Backpack.Flag.Dirty, true);
                _backpack.HandleItemCountChanged();
            }
        }

        private class ItemContainerAdapter : IContainerAdapter
        {
            public int PageIndex { get; private set; }
            public int Capacity
            {
                get => ItemContainer.capacity;
                set => ItemContainer.capacity = value;
            }
            public StorageContainer ContainerEntity;
            public ItemContainer ItemContainer { get; private set; }
            public int ItemCount => ItemContainer.itemList.Count;
            public bool HasItems => ItemCount > 0;

            private Backpack _backpack;

            private Action _onDirty;
            private Func<Item, int, bool> _canAcceptItem;
            private Action<Item, bool> _onItemAddedRemoved;

            private Backpacks _plugin => _backpack.Plugin;
            private Configuration _config => _plugin._config;

            public ItemContainerAdapter()
            {
                _onDirty = () => _backpack.MarkDirty();
                _canAcceptItem = (item, amount) =>
                {
                    // Explicitly track hook time so server owners can be informed of the cost.
                    var result = _backpack.ShouldAcceptItem(item, ItemContainer);
                    if (!result)
                    {
                        var feedbackRecipient = _backpack.DetermineFeedbackRecipientIfEligible();
                        if ((object)feedbackRecipient != null)
                        {
                            feedbackRecipient.ChatMessage(_plugin.GetMessage(feedbackRecipient.UserIDString, LangEntry.BackpackItemRejected));
                            _plugin.SendEffect(feedbackRecipient, _config.ItemRestrictions.FeedbackEffect);
                            _backpack.TimeSinceLastFeedback = 0;
                        }
                    }
                    return result;
                };
                _onItemAddedRemoved = (item, wasAdded) =>
                {
                    _backpack.HandleItemCountChanged();
                };
            }

            public ItemContainerAdapter Setup(Backpack backpack, int pageIndex, StorageContainer storageContainer)
            {
                #if DEBUG_POOLING
                LogDebug($"ItemContainerAdapter::Setup | PageIndex: {pageIndex.ToString()} | Capacity: {container.capacity.ToString()}");
                #endif
                PageIndex = pageIndex;
                ContainerEntity = storageContainer;
                ItemContainer = ContainerEntity.inventory;
                _backpack = backpack;

                return this;
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"ItemContainerAdapter::EnterPool | PageIndex: {PageIndex.ToString()} | Capacity: {Capacity.ToString()} | {CustomPool.GetStats<ItemContainerAdapter>()}");
                #endif

                PageIndex = 0;
                ContainerEntity = null;
                ItemContainer = null;
                _backpack = null;
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"ItemContainerAdapter::LeavePool | {CustomPool.GetStats<ItemContainerAdapter>()}");
                #endif
            }

            public ItemContainerAdapter AddDelegates()
            {
                // Add delegates only after filling the container initially to avoid marking the container as dirty
                // before any changes have been made, and avoids unnecessary CanBackpackAcceptItem hook calls.
                ItemContainer.onDirty += _onDirty;
                ItemContainer.canAcceptItem = _canAcceptItem;
                ItemContainer.onItemAddedRemoved += _onItemAddedRemoved;
                return this;
            }

            public void SortByPosition()
            {
                ItemContainer.itemList.Sort((a, b) => a.position.CompareTo(b.position));
            }

            public void FindItems(ref ItemQuery itemQuery, List<Item> collect)
            {
                ItemUtils.FindItems(ItemContainer.itemList, ref itemQuery, collect);
            }

            public void FindAmmo(AmmoTypes ammoType, List<Item> collect)
            {
                ItemContainer.FindAmmo(collect, ammoType);
            }

            public int PositionOf(ref ItemQuery itemQuery)
            {
                SortByPosition();
                return ItemUtils.PositionOf(ItemContainer.itemList, ref itemQuery);
            }

            public int CountItems(ref ItemQuery itemQuery)
            {
                return ItemUtils.CountItems(ItemContainer.itemList, ref itemQuery);
            }

            public int SumItems(ref ItemQuery itemQuery)
            {
                return ItemUtils.SumItems(ItemContainer.itemList, ref itemQuery);
            }

            public int TakeItems(ref ItemQuery itemQuery, int amount, List<Item> collect)
            {
                return ItemUtils.TakeItems(ItemContainer.itemList, ref itemQuery, amount, collect);
            }

            public int MutateItems(ref ItemQuery itemQuery, ref MutationRequest mutationRequest)
            {
                return ItemUtils.MutateItems(ItemContainer.itemList, ref itemQuery, ref mutationRequest);
            }

            public bool TryDepositItem(Item item)
            {
                return item.MoveToContainer(ItemContainer);
            }

            public bool TryInsertItem(Item item, ref ItemQuery itemQuery, int position)
            {
                for (var i = position; i < ItemContainer.capacity; i++)
                {
                    var existingItem = ItemContainer.GetSlot(i);
                    if (existingItem != null && itemQuery.GetUsableAmount(existingItem) <= 0)
                        continue;

                    if (item.MoveToContainer(ItemContainer, i, allowSwap: false))
                        return true;
                }

                return item.MoveToContainer(ItemContainer);
            }

            public void ReclaimFractionForSoftcore(float fraction, List<Item> collect)
            {
                var itemList = ItemContainer.itemList;

                // For some reason, the vanilla reclaim logic doesn't take the last item.
                if (itemList.Count <= 1)
                    return;

                var numToTake = Mathf.Ceil(itemList.Count * fraction);

                for (var i = 0; i < numToTake; i++)
                {
                    var indexToTake = UnityEngine.Random.Range(0, itemList.Count);
                    var itemToTake = itemList[indexToTake];
                    if (itemToTake.amount > 1)
                    {
                        // Prefer taking a smaller stack if possible (vanilla behavior).
                        foreach (var item in itemList)
                        {
                            if (item.info != itemToTake.info)
                                continue;

                            if (item.amount >= itemToTake.amount)
                                continue;

                            itemToTake = item;
                        }
                    }

                    collect.Add(itemToTake);
                    itemToTake.RemoveFromContainer();
                }
            }

            public void TakeRestrictedItems(List<Item> collect)
            {
                for (var i = ItemContainer.itemList.Count - 1; i >= 0; i--)
                {
                    var item = ItemContainer.itemList[i];
                    if (_backpack.RestrictionRuleset.AllowsItem(item))
                        continue;

                    collect.Add(item);
                    item.RemoveFromContainer();
                }
            }

            public void TakeAllItems(List<Item> collect, int startPosition = 0)
            {
                SortByPosition();

                for (var i = 0; i < ItemContainer.itemList.Count; i++)
                {
                    var item = ItemContainer.itemList[i];
                    if (item.position < startPosition)
                        continue;

                    collect.Add(item);
                    item.RemoveFromContainer();
                    i--;
                }
            }

            public void SerializeForNetwork(List<ProtoBuf.Item> saveList)
            {
                ItemUtils.SerializeForNetwork(ItemContainer.itemList, saveList);
            }

            public void SerializeTo(List<ItemData> saveList, List<ItemData> itemsToReleaseToPool)
            {
                var positionOffset = PageIndex * _maxCapacityPerPage;

                foreach (var item in ItemContainer.itemList)
                {
                    var itemData = CustomPool.Get<ItemData>().Setup(item, positionOffset);
                    saveList.Add(itemData);
                    itemsToReleaseToPool.Add(itemData);
                }
            }

            public void EraseContents(WipeRuleset ruleset, ref WipeContext wipeContext)
            {
                for (var i = ItemContainer.itemList.Count - 1; i >= 0; i--)
                {
                    var item = ItemContainer.itemList[i];
                    item.RemoveFromContainer();
                    item.Remove();
                }
            }

            public void Kill()
            {
                if (ContainerEntity == null || ContainerEntity.IsDestroyed)
                    return;

                ContainerEntity.Kill();
            }

            public void FreeToPool()
            {
                var self = this;
                CustomPool.Free(ref self);
            }

            public ItemContainerAdapter CopyItemsFrom(List<ItemData> itemDataList)
            {
                foreach (var itemData in itemDataList)
                {
                    var item = itemData.ToItem();
                    if (item == null)
                        continue;

                    if (!item.MoveToContainer(ItemContainer, item.position) && !item.MoveToContainer(ItemContainer))
                    {
                        _backpack.AddRejectedItem(item);
                    }
                }

                return this;
            }
        }

        private class ContainerAdapterEnumerator : IEnumerator<IContainerAdapter>, CustomPool.IPooled
        {
            private ContainerAdapterCollection _adapterCollection;
            private int _position = -1;

            public ContainerAdapterEnumerator Setup(ContainerAdapterCollection adapterCollection)
            {
                #if DEBUG_POOLING
                LogDebug("ContainerAdapterEnumerator::Setup");
                #endif

                _adapterCollection = adapterCollection;
                _position = -1;
                return this;
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"ContainerAdapterEnumerator::EnterPool | {CustomPool.GetStats<ContainerAdapterEnumerator>()}");
                #endif

                _adapterCollection = null;
                _position = -1;
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"ContainerAdapterEnumerator::LeavePool | {CustomPool.GetStats<ContainerAdapterEnumerator>()}");
                #endif
            }

            public bool MoveNext()
            {
                while (++_position < _adapterCollection.Count)
                {
                    if (_adapterCollection[_position] != null)
                        return true;
                }

                return false;
            }

            public void Reset()
            {
                throw new NotImplementedException();
            }

            public IContainerAdapter Current => _adapterCollection[_position];

            object IEnumerator.Current => Current;

            public void Dispose()
            {
                var self = this;
                CustomPool.Free(ref self);
            }
        }

        /// <summary>
        /// A collection of IContainerAdapters which may contain null entries.
        ///
        /// The underlying array may be enlarged but not shrunk via the Resize method.
        ///
        /// When enumerating via foreach, null entries are skipped, and enumeration stops at Count.
        /// </summary>
        private class ContainerAdapterCollection : IEnumerable<IContainerAdapter>
        {
            public int Count { get; private set; }
            private IContainerAdapter[] _containerAdapters;

            public ContainerAdapterCollection(int size)
            {
                Resize(size);
            }

            public void RemoveAt(int index)
            {
                this[index] = null;
            }

            public IContainerAdapter this[int i]
            {
                get
                {
                    if (i >= Count)
                        throw new IndexOutOfRangeException($"Index {i} was outside the bounds of the collection of size {Count}");

                    return _containerAdapters[i];
                }
                set
                {
                    if (i >= Count)
                        throw new IndexOutOfRangeException($"Index {i} was outside the bounds of the collection of size {Count}");

                    _containerAdapters[i] = value;
                }
            }

            public IEnumerator<IContainerAdapter> GetEnumerator()
            {
                return CustomPool.Get<ContainerAdapterEnumerator>().Setup(this);
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }

            public void Resize(int newSize)
            {
                if (newSize == Count)
                    return;

                if (newSize > Count)
                {
                    Array.Resize(ref _containerAdapters, newSize);
                }
                else
                {
                    for (var i = Count; i < _containerAdapters.Length; i++)
                    {
                        if (_containerAdapters[i] != null)
                            throw new InvalidOperationException($"ContainerAdapterCollection cannot be shrunk from {Count} to {newSize} because there is an existing container adapter at index {i}");
                    }
                }

                Count = newSize;
            }

            public void ResetPooledItemsAndClear()
            {
                foreach (var containerAdapter in _containerAdapters)
                {
                    containerAdapter?.FreeToPool();
                }

                Count = 0;
            }
        }

        #endregion

        #region Player Inventory Watcher

        private class InventoryWatcher : FacepunchBehaviour
        {
            public static InventoryWatcher AddToPlayer(BasePlayer player, Backpack backpack)
            {
                var component = player.gameObject.AddComponent<InventoryWatcher>();
                component._player = player;
                component._backpack = backpack;

                if (player.inventory.containerMain != null)
                    player.inventory.containerMain.onItemAddedRemoved += component._onItemAddedRemoved;

                if (player.inventory.containerBelt != null)
                    player.inventory.containerBelt.onItemAddedRemoved += component._onItemAddedRemoved;

                if (player.inventory.containerWear != null)
                    player.inventory.containerWear.onItemAddedRemoved += component._onItemAddedRemoved;

                return component;
            }

            private BasePlayer _player;
            private Backpack _backpack;

            private Action<Item, bool> _onItemAddedRemoved;
            private int _pauseGatherModeUntilFrame;

            public void DestroyImmediate() => DestroyImmediate(this);

            private InventoryWatcher()
            {
                _onItemAddedRemoved = OnItemAddedRemoved;
            }

            private bool ShouldIgnoreContainer()
            {
                var lootingContainer = _player.inventory.loot.containers.FirstOrDefault();
                if (lootingContainer == null)
                    return false;

                // Disable gather mode when looting network-limited containers, since they are controlled by other
                // plugins and are typically short term containers not intended to be simply looted.
                if (lootingContainer.entityOwner?.limitNetworking == true)
                    return true;

                // Disable gather mode when looting a backpack or child container of a backpack.
                var rootContainer = lootingContainer.parent != null
                    ? GetRootContainer(lootingContainer.parent)
                    : lootingContainer;

                if (rootContainer == null)
                    return false;

                return _backpack.Plugin._backpackManager.IsBackpack(rootContainer);
            }

            private void OnItemAddedRemoved(Item item, bool wasAdded)
            {
                if (_player.IsDestroyed
                    || _player.IsDead()
                    || _player.IsIncapacitated()
                    || _player.IsSleeping()
                    || _player.IsReceivingSnapshot
                    || ShouldIgnoreContainer())
                    return;

                if (wasAdded)
                {
                    // Don't gather items from the wearable container.
                    // We still listen to events from it in order to determine when an item is removed.
                    if (item.parent == _player.inventory.containerWear)
                        return;

                    if (_pauseGatherModeUntilFrame != 0)
                    {
                        if (_pauseGatherModeUntilFrame > Time.frameCount)
                            return;

                        _pauseGatherModeUntilFrame = 0;
                    }

                    var itemQuery = ItemQuery.FromItem(item);
                    if (HasMatchingItem(_player.inventory.containerMain.itemList, item, ref itemQuery, 24)
                        || HasMatchingItem(_player.inventory.containerBelt.itemList, item, ref itemQuery, 6))
                        return;

                    var originalPauseGatherModeUntilFrame = _pauseGatherModeUntilFrame;
                    if (_backpack.TryGatherItem(item) && originalPauseGatherModeUntilFrame != _pauseGatherModeUntilFrame)
                    {
                        // Don't pause gather mode due to gathering an item.
                        _pauseGatherModeUntilFrame = 0;
                    }
                }
                else
                {
                    _pauseGatherModeUntilFrame = Time.frameCount + 1;
                }
            }

            private bool HasMatchingItem(List<Item> itemList, Item item, ref ItemQuery itemQuery, int maxSlots)
            {
                for (var i = 0; i < itemList.Count; i++)
                {
                    var possibleItem = itemList[i];
                    if (possibleItem == item || possibleItem.position >= maxSlots)
                        continue;

                    if (itemQuery.GetUsableAmount(possibleItem) > 0)
                        return true;
                }

                return false;
            }

            private void OnDestroy()
            {
                if (_player.inventory.containerMain != null)
                {
                    _player.inventory.containerMain.onItemAddedRemoved -= _onItemAddedRemoved;
                }

                if (_player.inventory.containerBelt != null)
                {
                    _player.inventory.containerBelt.onItemAddedRemoved -= _onItemAddedRemoved;
                }

                if (_player.inventory.containerWear != null)
                {
                    _player.inventory.containerWear.onItemAddedRemoved -= _onItemAddedRemoved;
                }

                _backpack.HandleGatheringStopped();
            }
        }

        #endregion

        #region Backpack

        private enum GatherMode
        {
            // Don't rename these since the names are persisted in data files.
            None = 0,
            All,
            Existing,
        }

        [JsonObject(MemberSerialization.OptIn)]
        [JsonConverter(typeof(PoolConverter<Backpack>))]
        private class Backpack : CustomPool.IPooled
        {
            [Flags]
            public enum Flag
            {
                CapacityCached = 1 << 0,
                RestrictionsCached = 1 << 1,
                GatherCached = 1 << 2,
                RetrieveCached = 1 << 3,
                ProcessedRestrictedItems = 1 << 4,
                Dirty = 1 << 5,
            }

            private class PausableCallback : IDisposable
            {
                private Action _action;
                private bool _isPaused;
                private bool _wasCalled;

                public PausableCallback(Action action)
                {
                    _action = action;
                }

                public PausableCallback Pause()
                {
                    _isPaused = true;
                    return this;
                }

                public void Call()
                {
                    if (_isPaused)
                    {
                        _wasCalled = true;
                        return;
                    }

                    _action();
                }

                public void Dispose()
                {
                    if (_isPaused && _wasCalled)
                    {
                        _action();
                    }

                    _isPaused = false;
                    _wasCalled = false;
                }
            }

            private struct BackpackCapacity
            {
                public static int CalculatePageCapacity(int totalCapacity, int pageIndex)
                {
                    if (pageIndex < 0)
                        throw new ArgumentOutOfRangeException($"Page cannot be negative: {pageIndex}.");

                    var numPages = CalculatePageCountForCapacity(totalCapacity);
                    var lastPageIndex = numPages - 1;

                    if (pageIndex > lastPageIndex)
                        throw new ArgumentOutOfRangeException($"Page {pageIndex} cannot exceed {lastPageIndex}");

                    return pageIndex < lastPageIndex
                        ? _maxCapacityPerPage
                        : totalCapacity - _maxCapacityPerPage * lastPageIndex;
                }

                public static bool operator >(BackpackCapacity a, BackpackCapacity b) => a.Capacity > b.Capacity;
                public static bool operator <(BackpackCapacity a, BackpackCapacity b) => a.Capacity < b.Capacity;

                public static bool operator >=(BackpackCapacity a, BackpackCapacity b) => a.Capacity >= b.Capacity;
                public static bool operator <=(BackpackCapacity a, BackpackCapacity b) => a.Capacity <= b.Capacity;

                private static int CalculatePageCountForCapacity(int capacity)
                {
                    return 1 + (capacity - 1) / _maxCapacityPerPage;
                }

                public int Capacity
                {
                    get => _capacity;
                    set
                    {
                        _capacity = value;
                        PageCount = CalculatePageCountForCapacity(value);
                    }
                }
                public int PageCount { get; private set; }
                public int LastPage => PageCount - 1;
                public int LastPageCapacity => CapacityForPage(LastPage);
                public int CapacityForPage(int pageIndex) => CalculatePageCapacity(Capacity, pageIndex);
                public int ClampPage(int pageIndex) => Mathf.Clamp(pageIndex, 0, LastPage);

                private int _capacity;
            }

            private const float FeedbackThrottleSeconds = 1f;

            private static int CalculatePageIndexForItemPosition(int position)
            {
                return position / _maxCapacityPerPage;
            }

            [JsonProperty("OwnerID", Order = 0)]
            public ulong OwnerId { get; private set; }

            [JsonProperty("GatherMode", ItemConverterType = typeof(StringEnumConverter))]
            private Dictionary<int, GatherMode> GatherModeByPage = new();

            [JsonProperty("Retrieve", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int RetrieveFromPagesMask;

            [JsonProperty("Items", Order = 2)]
            private List<ItemData> ItemDataCollection = new();

            public List<Item> _rejectedItems;

            public Backpacks Plugin;
            public BackpackNetworkController NetworkController { get; private set; }
            public string OwnerIdString;
            public RealTimeSince TimeSinceLastFeedback;

            private BackpackCapacity ActualCapacity;
            private BackpackCapacity _allowedCapacity;

            private PausableCallback _itemCountChangedEvent;
            private Flag _flags;
            private RestrictionRuleset _restrictionRuleset;
            private bool _canGather;
            private bool _canRetrieve;
            private DynamicConfigFile _dataFile;
            private BasePlayer _owner;
            private ContainerAdapterCollection _containerAdapters;
            private readonly List<BasePlayer> _looters = new();
            private readonly List<BasePlayer> _uiViewers = new();
            private InventoryWatcher _inventoryWatcher;
            private float _pauseGatherModeUntilTime;
            private int _checkedAccessOnFrame;

            public bool HasLooters => _looters.Count > 0;
            public bool IsGathering => (object)_inventoryWatcher != null;
            private Configuration _config => Plugin._config;
            private BackpackManager _backpackManager => Plugin._backpackManager;
            private SubscriberManager _subscriberManager => Plugin._subscriberManager;

            public BasePlayer Owner
            {
                get
                {
                    if (_owner == null || !_owner.IsConnected)
                    {
                        foreach (var looter in _looters)
                        {
                            if (looter.userID == OwnerId)
                            {
                                _owner = looter;
                                break;
                            }
                        }

                        if (_owner == null)
                        {
                            _owner = BasePlayer.FindByID(OwnerId);
                        }
                    }

                    return _owner;
                }
            }

            public int Capacity => AllowedCapacity.Capacity;
            public int PageCount => AllowedCapacity.PageCount;

            private BackpackCapacity AllowedCapacity
            {
                get
                {
                    if (!HasFlag(Flag.CapacityCached))
                    {
                        _allowedCapacity.Capacity = Math.Max(MinContainerCapacity, Plugin._capacityManager.GetCapacity(OwnerId, OwnerIdString));
                        SetFlag(Flag.CapacityCached, true);
                    }

                    return _allowedCapacity;
                }
            }

            public RestrictionRuleset RestrictionRuleset
            {
                get
                {
                    if (!HasFlag(Flag.RestrictionsCached))
                    {
                        var restrictionRuleset = _config.ItemRestrictions.GetForPlayer(OwnerIdString);
                        if (restrictionRuleset != _restrictionRuleset)
                        {
                            // Re-evaluate existing items when the backpack is next opened.
                            SetFlag(Flag.ProcessedRestrictedItems, false);
                        }

                        _restrictionRuleset = restrictionRuleset;
                        SetFlag(Flag.RestrictionsCached, true);
                    }

                    return _restrictionRuleset;
                }
            }

            public bool CanGather
            {
                get
                {
                    if (!HasFlag(Flag.GatherCached))
                    {
                        _canGather = Plugin.permission.UserHasPermission(OwnerIdString, GatherPermission);
                        SetFlag(Flag.GatherCached, true);
                    }

                    return _canGather;
                }
            }

            public bool CanRetrieve
            {
                get
                {
                    if (Plugin.ItemRetriever == null)
                        return false;

                    if (!HasFlag(Flag.RetrieveCached))
                    {
                        _canRetrieve = Plugin.permission.UserHasPermission(OwnerIdString, RetrievePermission);
                        SetFlag(Flag.RetrieveCached, true);
                    }

                    return _canRetrieve;
                }
            }

            public int ItemCount
            {
                get
                {
                    var count = 0;

                    foreach (var containerAdapter in _containerAdapters)
                    {
                        count += containerAdapter.ItemCount;
                    }

                    return count;
                }
            }

            public bool IsRetrieving
            {
                get
                {
                    if (!CanRetrieve)
                        return false;

                    var allowedPageCount = AllowedCapacity.PageCount;

                    for (var pageIndex = 0; pageIndex < allowedPageCount; pageIndex++)
                    {
                        if (IsRetrievingFromPage(pageIndex))
                            return true;
                    }

                    return false;
                }
            }

            private bool WantsGather
            {
                get
                {
                    if (!CanGather)
                        return false;

                    var allowedPageCount = AllowedCapacity.PageCount;

                    for (var pageIndex = 0; pageIndex < allowedPageCount; pageIndex++)
                    {
                        if (GetGatherModeForPage(pageIndex) != GatherMode.None)
                            return true;
                    }

                    return false;
                }
            }

            public bool HasPreferences => IsRetrieving || WantsGather;

            public bool CanAccess
            {
                get
                {
                    var frameCount = Time.frameCount;
                    if (frameCount == _checkedAccessOnFrame)
                    {
                        // Access was already allowed this frame.
                        return true;
                    }

                    if (frameCount == -_checkedAccessOnFrame)
                    {
                        // Access was already denied this frame.
                        return false;
                    }

                    if (!Plugin.VerifyCanOpenBackpack(Owner, OwnerId, provideFeedback: false))
                    {
                        _checkedAccessOnFrame = -frameCount;
                        return false;
                    }

                    _checkedAccessOnFrame = frameCount;
                    return true;
                }
            }

            public bool HasItems => ItemCount > 0;

            public Backpack()
            {
                _itemCountChangedEvent = new PausableCallback(BroadcastItemCountChanged);
            }

            public void Setup(Backpacks plugin, ulong ownerId, DynamicConfigFile dataFile)
            {
                #if DEBUG_POOLING
                LogDebug($"Backpack::Setup | OwnerId: {ownerId.ToString()}");
                #endif

                Plugin = plugin;
                OwnerId = ownerId;
                OwnerIdString = ownerId.ToString();
                _dataFile = dataFile;

                NetworkController ??= BackpackNetworkController.Create();
                SetupItemsAndContainers();
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"Backpack::EnterPool | OwnerId: {OwnerIdString} | {CustomPool.GetStats<Backpack>()}");
                #endif

                OwnerId = 0;
                GatherModeByPage.Clear();
                RetrieveFromPagesMask = 0;

                if (ItemDataCollection != null)
                {
                    PoolUtils.ResetItemsAndClear(ItemDataCollection);
                }

                // Don't remove the NetworkController. Will reuse it for the next Backpack owner.
                NetworkController?.UnsubscribeAll();
                _itemCountChangedEvent.Dispose();
                _flags = 0;
                OwnerIdString = null;
                ActualCapacity = default;
                _allowedCapacity = default;
                _restrictionRuleset = null;
                _canGather = false;
                _canRetrieve = false;
                _dataFile = null;
                _owner = null;
                _containerAdapters?.ResetPooledItemsAndClear();
                _looters.Clear();
                _uiViewers.Clear();
                StopGathering();
                if (_rejectedItems?.Count > 0)
                {
                    foreach (var item in _rejectedItems)
                    {
                        LogError($"Found rejected item when backpack entered pool: {item.amount.ToString()} {item.info.shortname} (skin: {item.skin.ToString()})");
                        item.Remove();
                    }
                    _rejectedItems.Clear();
                }

                Plugin = null;
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"LeavePool | {CustomPool.GetStats<Backpack>()}");
                #endif
            }

            public void SetFlag(Flag flag, bool value)
            {
                if (value)
                {
                    _flags |= flag;
                }
                else
                {
                    _flags &= ~flag;
                }
            }

            public bool HasFlag(Flag flag)
            {
                return _flags.HasFlag(flag);
            }

            public void MarkDirty()
            {
                SetFlag(Flag.Dirty, true);

                if (Plugin.ItemRetriever != null)
                {
                    Owner?.inventory?.containerMain?.MarkDirty();
                }
            }

            public void SetCapacity(int amount)
            {
                _allowedCapacity.Capacity = amount;
            }

            public bool IsRetrievingFromPage(int pageIndex)
            {
                var flag = 1 << pageIndex;
                return (RetrieveFromPagesMask & flag) != 0;
            }

            public void ToggleRetrieve(BasePlayer player, int pageIndex)
            {
                var wasPreviouslyRetrieving = IsRetrieving;
                SetRetrieveFromPage(pageIndex, !IsRetrievingFromPage(pageIndex));
                MaybeCreateContainerUi(player, AllowedCapacity.PageCount, pageIndex, EnsurePage(pageIndex).Capacity);

                var isNowRetrieving = IsRetrieving;
                if (isNowRetrieving != wasPreviouslyRetrieving)
                {
                    _subscriberManager.BroadcastRetrieveChanged(this, isNowRetrieving);
                }
            }

            public GatherMode GetGatherModeForPage(int pageIndex)
            {
                return GatherModeByPage.TryGetValue(pageIndex, out var gatherMode)
                    ? gatherMode
                    : GatherMode.None;
            }

            public void ToggleGatherMode(BasePlayer player, int pageIndex)
            {
                switch (GetGatherModeForPage(pageIndex))
                {
                    case GatherMode.All:
                        SetGatherModeForPage(player, pageIndex, GatherMode.Existing);
                        break;

                    case GatherMode.Existing:
                        SetGatherModeForPage(player, pageIndex, GatherMode.None);
                        break;

                    case GatherMode.None:
                        SetGatherModeForPage(player, pageIndex, GatherMode.All);
                        break;
                }
            }

            public void HandleGatheringStopped()
            {
                _inventoryWatcher = null;
            }

            public void PauseGatherMode(float durationSeconds)
            {
                if (!IsGathering)
                    return;

                _pauseGatherModeUntilTime = Time.time + durationSeconds;
            }

            public bool TryGatherItem(Item item)
            {
                if (!CanGather)
                {
                    GatherModeByPage.Clear();
                    SetFlag(Flag.Dirty, true);
                    StopGathering();
                    return false;
                }

                // When overflowing, don't allow items to be added.
                if (ActualCapacity > AllowedCapacity)
                    return false;

                if (_pauseGatherModeUntilTime != 0)
                {
                    if (_pauseGatherModeUntilTime > Time.time)
                        return false;

                    _pauseGatherModeUntilTime = 0;
                }

                // Optimization: Don't search pages for a matching item it's not allowed.
                if (_config.ItemRestrictions.Enabled && !RestrictionRuleset.AllowsItem(item))
                    return false;

                if (!CanAccess)
                    return false;

                var itemQuery = ItemQuery.FromItem(item);
                var anyPagesWithGatherAll = false;
                var allowedPageCount = AllowedCapacity.PageCount;

                EnlargeIfNeeded();

                using (_itemCountChangedEvent.Pause())
                {
                    // Use a for loop so empty pages aren't skipped.
                    for (var i = 0; i < allowedPageCount; i++)
                    {
                        var gatherMode = GetGatherModeForPage(i);
                        if (gatherMode == GatherMode.None)
                            continue;

                        if (gatherMode == GatherMode.All)
                        {
                            anyPagesWithGatherAll = true;
                            continue;
                        }

                        var containerAdapter = _containerAdapters[i];
                        if (containerAdapter is not { HasItems: true })
                            continue;

                        var position = containerAdapter.PositionOf(ref itemQuery);
                        if (position == -1)
                            continue;

                        if (EnsureItemContainerAdapter(i).TryInsertItem(item, ref itemQuery, position))
                            return true;
                    }

                    if (anyPagesWithGatherAll)
                    {
                        // Try to add the item to a Gather:All page that has a matching stack.
                        // Use a foreach loop to skip uninitialized pages (which are empty).
                        foreach (var containerAdapter in _containerAdapters)
                        {
                            var gatherMode = GetGatherModeForPage(containerAdapter.PageIndex);
                            if (gatherMode != GatherMode.All || !containerAdapter.HasItems)
                                continue;

                            var position = containerAdapter.PositionOf(ref itemQuery);
                            if (position == -1)
                                continue;

                            if (EnsureItemContainerAdapter(containerAdapter.PageIndex)
                                .TryInsertItem(item, ref itemQuery, position))
                                return true;
                        }

                        // Try to add the item to any Gather:All page.
                        // Use a for loop so uninitialized pages aren't skipped.
                        for (var i = 0; i < allowedPageCount; i++)
                        {
                            var gatherMode = GetGatherModeForPage(i);
                            if (gatherMode != GatherMode.All)
                                continue;

                            if (EnsureItemContainerAdapter(i).TryDepositItem(item))
                                return true;
                        }
                    }
                }

                return false;
            }

            public void AddRejectedItem(Item item)
            {
                _rejectedItems ??= new List<Item>();
                _rejectedItems.Add(item);
            }

            public int GetPageIndexForContainer(ItemContainer container)
            {
                return GetAdapterForContainer(container)?.PageIndex ?? -1;
            }

            public ItemContainerAdapter EnsureItemContainerAdapter(int pageIndex)
            {
                var containerAdapter = EnsurePage(pageIndex, preferRealContainer: true);
                return containerAdapter as ItemContainerAdapter
                       ?? UpgradeToItemContainer(containerAdapter as VirtualContainerAdapter);
            }

            public int GetAllowedPageCapacityForLooter(ulong looterId, int desiredPageIndex)
            {
                return GetAllowedCapacityForLooter(looterId).CapacityForPage(desiredPageIndex);
            }

            public int DetermineInitialPageForLooter(ulong looterId, int desiredPageIndex, bool forward)
            {
                var allowedCapacity = GetAllowedCapacityForLooter(looterId);

                if (desiredPageIndex == -1)
                {
                    desiredPageIndex = forward ? 0 : allowedCapacity.LastPage;
                }

                return allowedCapacity.ClampPage(desiredPageIndex);
            }

            public int DetermineNextPageIndexForLooter(ulong looterId, int currentPageIndex, int desiredPageIndex, bool forward, bool wrapAround, bool requireContents)
            {
                var allowedCapacity = GetAllowedCapacityForLooter(looterId);

                if (desiredPageIndex >= 0)
                    return Math.Min(desiredPageIndex, allowedCapacity.LastPage);

                if (forward)
                {
                    for (var i = currentPageIndex + 1; i < allowedCapacity.PageCount; i++)
                    {
                        var containerAdapter = _containerAdapters[i];
                        if (!requireContents || (containerAdapter?.HasItems ?? false))
                            return i;
                    }

                    if (wrapAround)
                    {
                        for (var i = 0; i < currentPageIndex; i++)
                        {
                            var containerAdapter = _containerAdapters[i];
                            if (!requireContents || (containerAdapter?.HasItems ?? false))
                                return i;
                        }
                    }
                }
                else
                {
                    // Searching backward.
                    for (var i = currentPageIndex - 1; i >= 0; i--)
                    {
                        var containerAdapter = _containerAdapters[i];
                        if (!requireContents || (containerAdapter?.HasItems ?? false))
                            return i;
                    }

                    if (wrapAround)
                    {
                        for (var i = allowedCapacity.LastPage; i > currentPageIndex; i++)
                        {
                            var containerAdapter = _containerAdapters[i];
                            if (!requireContents || (containerAdapter?.HasItems ?? false))
                                return i;
                        }
                    }
                }

                return currentPageIndex;
            }

            public int CountItems(ref ItemQuery itemQuery)
            {
                var count = 0;

                foreach (var containerAdapter in _containerAdapters)
                {
                    count += containerAdapter.CountItems(ref itemQuery);
                }

                return count;
            }

            public void FindItems(ref ItemQuery itemQuery, List<Item> collect, bool forItemRetriever = false)
            {
                foreach (var containerAdapter in _containerAdapters)
                {
                    if (forItemRetriever && !IsRetrievingFromPage(containerAdapter.PageIndex))
                        continue;

                    (containerAdapter as ItemContainerAdapter)?.FindItems(ref itemQuery, collect);
                }
            }

            public void FindAmmo(AmmoTypes ammoType, List<Item> collect, bool forItemRetriever = false)
            {
                foreach (var containerAdapter in _containerAdapters)
                {
                    if (forItemRetriever && !IsRetrievingFromPage(containerAdapter.PageIndex))
                        continue;

                    (containerAdapter as ItemContainerAdapter)?.FindAmmo(ammoType, collect);
                }
            }

            public int SumItems(ref ItemQuery itemQuery, bool forItemRetriever = false)
            {
                var sum = 0;

                foreach (var containerAdapter in _containerAdapters)
                {
                    if (forItemRetriever && !IsRetrievingFromPage(containerAdapter.PageIndex))
                        continue;

                    sum += containerAdapter.SumItems(ref itemQuery);
                }

                return sum;
            }

            public int TakeItems(ref ItemQuery itemQuery, int amount, List<Item> collect, bool forItemRetriever = false)
            {
                using (_itemCountChangedEvent.Pause())
                {
                    var amountTaken = 0;

                    foreach (var containerAdapter in _containerAdapters)
                    {
                        if (forItemRetriever && !IsRetrievingFromPage(containerAdapter.PageIndex))
                            continue;

                        var amountToTake = amount - amountTaken;
                        if (amountToTake <= 0)
                            break;

                        amountTaken += containerAdapter.TakeItems(ref itemQuery, amountToTake, collect);
                    }

                    return amountTaken;
                }
            }

            public bool TryDepositItem(Item item)
            {
                // When overflowing, don't allow items to be added.
                if (ActualCapacity > AllowedCapacity)
                    return false;

                using (_itemCountChangedEvent.Pause())
                {
                    for (var i = 0; i < AllowedCapacity.PageCount; i++)
                    {
                        var containerAdapter = EnsurePage(i);
                        if (!containerAdapter.TryDepositItem(item))
                            continue;

                        return true;
                    }
                }

                return false;
            }

            public int MutateItems(ref ItemQuery itemQuery, ref MutationRequest mutationRequest)
            {
                var count = 0;

                foreach (var containerAdapter in _containerAdapters)
                {
                    count += containerAdapter.MutateItems(ref itemQuery, ref mutationRequest);
                }

                return count;
            }

            public void SerializeForNetwork(List<ProtoBuf.Item> saveList, bool forItemRetriever = false)
            {
                foreach (var containerAdapter in _containerAdapters)
                {
                    if (forItemRetriever && !IsRetrievingFromPage(containerAdapter.PageIndex))
                        continue;

                    containerAdapter.SerializeForNetwork(saveList);
                }
            }

            public IPlayer FindOwnerPlayer() => Plugin.covalence.Players.FindPlayerById(OwnerIdString);

            public bool ShouldAcceptItem(Item item, ItemContainer container)
            {
                if (_config.ItemRestrictions.Enabled && !RestrictionRuleset.AllowsItem(item))
                    return false;

                if (ExposedHooks.CanBackpackAcceptItem(OwnerId, container, item) is false)
                    return false;

                return true;
            }

            public void HandleItemCountChanged()
            {
                _itemCountChangedEvent.Call();
            }

            public ItemContainer GetContainer(bool ensureContainer = false)
            {
                if (ensureContainer)
                    return EnsureItemContainerAdapter(0).ItemContainer;

                return (EnsurePage(0) as ItemContainerAdapter)?.ItemContainer;
            }

            public bool TryOpen(BasePlayer looter, int pageIndex = -1)
            {
                if (!Plugin.VerifyCanOpenBackpack(looter, OwnerId))
                    return false;

                EnlargeIfNeeded();

                var allowedCapacity = GetAllowedCapacityForLooter(looter.userID);
                pageIndex = allowedCapacity.ClampPage(pageIndex);
                var itemContainerAdapter = EnsureItemContainerAdapter(pageIndex);

                NetworkController.Subscribe(looter);

                // Some operations are only appropriate for the owner (not for admins viewing the backpack).
                if (looter.userID == OwnerId)
                {
                    EjectRejectedItemsIfNeeded(looter);
                    EjectRestrictedItemsIfNeeded(looter);
                    ShrinkIfNeededAndEjectOverflowingItems(looter);
                    if (CanGather && GatherModeByPage.Count > 0)
                    {
                        StartGathering(looter);
                    }
                }

                if (!_looters.Contains(looter))
                {
                    _looters.Add(looter);
                }

                StartLooting(looter, itemContainerAdapter.ItemContainer, itemContainerAdapter.ContainerEntity);
                ExposedHooks.OnBackpackOpened(looter, OwnerId, itemContainerAdapter.ItemContainer);
                MaybeCreateContainerUi(looter,  allowedCapacity.PageCount, pageIndex, itemContainerAdapter.Capacity);

                return true;
            }

            public void SwitchToPage(BasePlayer looter, int pageIndex)
            {
                // In case the backpack size permissions changed while open (e.g., a backpack upgrade button).
                EnlargeIfNeeded();

                var itemContainerAdapter = EnsureItemContainerAdapter(pageIndex);
                var itemContainer = itemContainerAdapter.ItemContainer;
                var playerLoot = looter.inventory.loot;
                foreach (var container in playerLoot.containers)
                {
                    container.onDirty -= playerLoot.MarkDirty;
                }

                if (looter.userID == OwnerId)
                {
                    EjectRejectedItemsIfNeeded(looter);

                    // In case the backpack size permissions changed while open.
                    ShrinkIfNeededAndEjectOverflowingItems(looter);
                }

                playerLoot.containers.Clear();
                Interface.CallHook("OnLootEntityEnd", looter, itemContainer.entityOwner);
                Interface.CallHook("OnLootEntity", looter, itemContainer.entityOwner);
                playerLoot.AddContainer(itemContainer);
                playerLoot.SendImmediate();
                ExposedHooks.OnBackpackOpened(looter, OwnerId, itemContainer);
                MaybeCreateContainerUi(looter, GetAllowedCapacityForLooter(looter.userID).PageCount, pageIndex, itemContainerAdapter.Capacity);
            }

            public BasePlayer DetermineFeedbackRecipientIfEligible()
            {
                if (_looters.Count == 0)
                    return null;

                if (TimeSinceLastFeedback < FeedbackThrottleSeconds)
                    return null;

                // Can't know who tried to place the item if there are multiple looters.
                if (_looters.Count > 1)
                    return null;

                return _looters.FirstOrDefault();
            }

            public void OnClosed(BasePlayer looter)
            {
                _looters.Remove(looter);

                if (_uiViewers.Contains(looter))
                {
                    ContainerUi.DestroyUi(looter);
                    _uiViewers.Remove(looter);
                }

                // Clean up the subscription immediately if admin stopped looting.
                // This avoids having to clean up the admin subscriptions some other way which would add complexity.
                if (looter.userID != OwnerId)
                {
                    NetworkController?.Unsubscribe(looter);
                }
            }

            public bool Drop(Vector3 position, List<DroppedItemContainer> collect)
            {
                if (!HasItems)
                {
                    #if DEBUG_DROP_ON_DEATH
                    LogWarning($"[DEBUG_DROP_ON_DEATH] [Player {OwnerIdString}] Backpack not dropped because it is empty.");
                    #endif
                    return false;
                }

                var hookResult = ExposedHooks.CanDropBackpack(OwnerId, position);
                if (hookResult is false)
                {
                    #if DEBUG_DROP_ON_DEATH
                    LogWarning($"[DEBUG_DROP_ON_DEATH] [Player {OwnerIdString}] Backpack not dropped because another plugin blocked it via the CanDropBackpack hook.");
                    #endif
                    return false;
                }

                ForceCloseAllLooters();
                ReclaimItemsForSoftcore();

                // Check again since the items may have all been reclaimed for Softcore.
                if (!HasItems)
                {
                    #if DEBUG_DROP_ON_DEATH
                    LogWarning($"[DEBUG_DROP_ON_DEATH] [Player {OwnerIdString}] Backpack not dropped because it is empty, after reclaiming items for softcore.");
                    #endif
                    return false;
                }

                using (_itemCountChangedEvent.Pause())
                {
                    using (var itemList = DisposableList<Item>.Get())
                    {
                        foreach (var containerAdapter in _containerAdapters)
                        {
                            if (!containerAdapter.HasItems)
                                continue;

                            containerAdapter.TakeAllItems(itemList);
                            var droppedItemContainer = SpawnDroppedBackpack(position, containerAdapter.Capacity, itemList);
                            if (droppedItemContainer == null)
                                break;

                            itemList.Clear();
                            collect.Add(droppedItemContainer);
                        }

                        if (itemList.Count > 0)
                        {
                            foreach (var item in itemList)
                            {
                                item.Drop(position, UnityEngine.Random.insideUnitSphere, Quaternion.identity);
                            }
                        }
                    }
                }

                #if DEBUG_DROP_ON_DEATH
                LogWarning($"[DEBUG_DROP_ON_DEATH] [Player {OwnerIdString}] Backpack dropped.");
                #endif

                return true;
            }

            public void EraseContents(WipeRuleset wipeRuleset = null, bool force = false)
            {
                // Optimization: If no container and no stored data, don't bother with the rest of the logic.
                var originalItemCount = ItemCount;
                if (originalItemCount == 0)
                    return;

                if (!force)
                {
                    var hookResult = ExposedHooks.CanEraseBackpack(OwnerId);
                    if (hookResult is false)
                        return;
                }

                var wipeContext = new WipeContext();

                using (_itemCountChangedEvent.Pause())
                {
                    foreach (var containerAdapter in _containerAdapters)
                    {
                        containerAdapter.EraseContents(wipeRuleset, ref wipeContext);
                    }
                }

                if (ItemCount != originalItemCount)
                {
                    HandleItemCountChanged();
                }
            }

            public bool SaveIfChanged()
            {
                if (!HasFlag(Flag.Dirty))
                    return false;

                #if DEBUG_BACKPACK_LIFECYCLE
                LogDebug($"Backpack::Save | {OwnerIdString} | Frame: {Time.frameCount.ToString()}");
                #endif

                using (var itemsToReleaseToPool = DisposableList<ItemData>.Get())
                {
                    foreach (var containerAdapter in _containerAdapters)
                    {
                        containerAdapter.SerializeTo(ItemDataCollection, itemsToReleaseToPool);
                    }

                    SerializeRejectedItems(itemsToReleaseToPool);

                    _dataFile.WriteObject(this);
                    SetFlag(Flag.Dirty, false);

                    // After saving, unused ItemData instances can be pooled.
                    PoolUtils.ResetItemsAndClear(itemsToReleaseToPool);
                }

                // Clear the list, but don't reset the items to the pool, since they have been referenced in the container adapters.
                ItemDataCollection.Clear();

                return true;
            }

            public int FetchItems(BasePlayer player, ref ItemQuery itemQuery, int desiredAmount)
            {
                using var collect = DisposableList<Item>.Get();
                var amountTaken = TakeItems(ref itemQuery, desiredAmount, collect);

                if (amountTaken > 0)
                {
                    PauseGatherMode(1f);

                    foreach (var item in collect)
                    {
                        player.GiveItem(item);
                    }

                    _pauseGatherModeUntilTime = 0;
                }

                return amountTaken;
            }

            public void Kill()
            {
                #if DEBUG_BACKPACK_LIFECYCLE
                LogDebug($"Backpack::Kill | OwnerId: {OwnerIdString} | Frame: {Time.frameCount.ToString()}");
                #endif

                ForceCloseAllLooters();

                foreach (var containerAdapter in _containerAdapters)
                {
                    KillContainerAdapter(containerAdapter);
                }

                if (_rejectedItems?.Count > 0)
                {
                    foreach (var item in _rejectedItems)
                    {
                        item.Remove();
                    }

                    _rejectedItems.Clear();
                }

            }

            public string SerializeContentsAsJson()
            {
                using var itemsToReleaseToPool = DisposableList<ItemData>.Get();

                foreach (var containerAdapter in _containerAdapters)
                {
                    containerAdapter.SerializeTo(ItemDataCollection, itemsToReleaseToPool);
                }

                SerializeRejectedItems(itemsToReleaseToPool);

                var json = JsonConvert.SerializeObject(ItemDataCollection);

                // After saving, unused ItemData instances can be pooled.
                PoolUtils.ResetItemsAndClear(itemsToReleaseToPool);

                // Clear the list, but don't reset the items to the pool, since they have been referenced in the container adapters.
                ItemDataCollection.Clear();

                return json;
            }

            public void WriteContentsFromJson(string json)
            {
                var itemDataList = JsonConvert.DeserializeObject<List<ItemData>>(json);

                Kill();

                foreach (var itemData in itemDataList)
                {
                    ItemDataCollection.Add(itemData);
                }

                SetupItemsAndContainers();

                SetFlag(Flag.Dirty, true);
                SaveIfChanged();
            }

            private void CreateContainerAdapters()
            {
                var previousPageIndex = -1;

                // This assumes the collection has been sorted by item position.
                foreach (var itemData in ItemDataCollection)
                {
                    var pageIndex = CalculatePageIndexForItemPosition(itemData.Position);
                    if (pageIndex < previousPageIndex)
                        throw new InvalidOperationException("Found an item for an earlier page while setting up a virtual container. This should not happen.");

                    // Skip items for the previously created page, since creating the page would have copied all items.
                    if (pageIndex == previousPageIndex)
                        continue;

                    // Create an adapter for the page, copying all items.
                    _containerAdapters[pageIndex] = CreateVirtualContainerAdapter(pageIndex)
                        .CopyItemsFrom(ItemDataCollection);

                    previousPageIndex = pageIndex;
                }

                // Clear the list, but don't reset the items to the pool, since they have been referenced in the container adapters.
                ItemDataCollection.Clear();
            }

            private void SetupItemsAndContainers()
            {
                // Sort the items so it's easier to partition the list for multiple pages.
                ItemDataCollection.Sort((a, b) => a.Position.CompareTo(b.Position));

                // Allow the backpack to start beyond the allowed capacity.
                // Overflowing items will be handled when the backpack is opened by its owner.
                var highestUsedPosition = ItemDataCollection.LastOrDefault()?.Position ?? 0;
                ActualCapacity.Capacity = Math.Max(_allowedCapacity.Capacity, highestUsedPosition + 1);

                var pageCount = ActualCapacity.PageCount;
                if (_containerAdapters == null)
                {
                    _containerAdapters = new ContainerAdapterCollection(pageCount);
                }
                else
                {
                    _containerAdapters.Resize(pageCount);
                }

                CreateContainerAdapters();
            }

            private VirtualContainerAdapter CreateVirtualContainerAdapter(int pageIndex)
            {
                return CustomPool.Get<VirtualContainerAdapter>().Setup(this, pageIndex, ActualCapacity.CapacityForPage(pageIndex));
            }

            private ItemContainerAdapter CreateItemContainerAdapter(int pageIndex)
            {
                var container = CreateStorageContainer(ActualCapacity.CapacityForPage(pageIndex));
                return CustomPool.Get<ItemContainerAdapter>().Setup(this, pageIndex, container);
            }

            private ItemContainerAdapter UpgradeToItemContainer(VirtualContainerAdapter virtualContainerAdapter)
            {
                // Must cache the page index since it will be reset when pooled.
                var pageIndex = virtualContainerAdapter.PageIndex;
                var itemContainerAdapter = CreateItemContainerAdapter(pageIndex)
                    .CopyItemsFrom(virtualContainerAdapter.ItemDataList)
                    .AddDelegates();

                CustomPool.Free(ref virtualContainerAdapter);

                _containerAdapters[pageIndex] = itemContainerAdapter;
                return itemContainerAdapter;
            }

            private void SerializeRejectedItems(List<ItemData> itemsToReleaseToPool)
            {
                if (_rejectedItems == null || _rejectedItems.Count == 0)
                    return;

                var lastPosition = ItemDataCollection.LastOrDefault()?.Position ?? 0;

                foreach (var item in _rejectedItems)
                {
                    item.position = ++lastPosition;
                    var itemData = CustomPool.Get<ItemData>().Setup(item);
                    ItemDataCollection.Add(itemData);
                    itemsToReleaseToPool.Add(itemData);
                }
            }

            private void EjectRejectedItemsIfNeeded(BasePlayer receiver)
            {
                if (_rejectedItems == null || _rejectedItems.Count == 0)
                    return;

                foreach (var item in _rejectedItems)
                {
                    receiver.GiveItem(item);
                }

                _rejectedItems.Clear();
                BroadcastItemCountChanged();
                SetFlag(Flag.Dirty, true);

                receiver.ChatMessage(Plugin.GetMessage(receiver.UserIDString, LangEntry.BackpackItemsRejected));
            }

            private void EjectRestrictedItemsIfNeeded(BasePlayer receiver)
            {
                if (!Plugin._config.ItemRestrictions.Enabled)
                    return;

                // Optimization: Avoid processing item restrictions every time the backpack is opened.
                if (HasFlag(Flag.ProcessedRestrictedItems))
                    return;

                using (var ejectedItems = DisposableList<Item>.Get())
                {
                    using (_itemCountChangedEvent.Pause())
                    {
                        foreach (var containerAdapter in _containerAdapters)
                        {
                            containerAdapter.TakeRestrictedItems(ejectedItems);
                        }
                    }

                    if (ejectedItems.Count > 0)
                    {
                        foreach (var item in ejectedItems)
                        {
                            receiver.GiveItem(item);
                        }

                        receiver.ChatMessage(Plugin.GetMessage(receiver.UserIDString, LangEntry.BlacklistedItemsRemoved));
                    }
                }

                SetFlag(Flag.ProcessedRestrictedItems, true);
            }

            private void ShrinkIfNeededAndEjectOverflowingItems(BasePlayer overflowRecipient)
            {
                var allowedCapacity = AllowedCapacity;
                if (ActualCapacity <= allowedCapacity)
                    return;

                var allowedLastPageCapacity = allowedCapacity.LastPageCapacity;

                var itemsDroppedOrGivenToPlayer = 0;

                using (var overflowingItems = DisposableList<Item>.Get())
                {
                    var lastAllowedContainerAdapter = _containerAdapters[allowedCapacity.LastPage];
                    if (lastAllowedContainerAdapter != null)
                    {
                        lastAllowedContainerAdapter.TakeAllItems(overflowingItems, allowedLastPageCapacity);
                        lastAllowedContainerAdapter.Capacity = allowedLastPageCapacity;

                        if (allowedLastPageCapacity > 0)
                        {
                            // Try to give the items to the original page first.
                            var lastAllowedItemContainerAdapter = EnsureItemContainerAdapter(allowedCapacity.LastPage);

                            for (var i = 0; i < overflowingItems.Count; i++)
                            {
                                if (overflowingItems[i].MoveToContainer(lastAllowedItemContainerAdapter.ItemContainer))
                                {
                                    overflowingItems.RemoveAt(i--);
                                }
                            }
                        }
                    }

                    for (var i = allowedCapacity.PageCount; i < ActualCapacity.PageCount; i++)
                    {
                        var containerAdapter = _containerAdapters[i];
                        if (containerAdapter == null)
                            continue;

                        containerAdapter.TakeAllItems(overflowingItems);
                        KillContainerAdapter(containerAdapter);
                    }

                    foreach (var item in overflowingItems)
                    {
                        var wasItemAddedToBackpack = false;

                        for (var i = 0; i < allowedCapacity.PageCount; i++)
                        {
                            // Simplification: Make all potential destination containers real containers.
                            var itemContainerAdapter = EnsureItemContainerAdapter(i);
                            if (itemContainerAdapter.TryDepositItem(item))
                            {
                                wasItemAddedToBackpack = true;
                                break;
                            }
                        }

                        if (!wasItemAddedToBackpack)
                        {
                            overflowRecipient.GiveItem(item);
                            itemsDroppedOrGivenToPlayer++;
                        }
                    }
                }

                if (itemsDroppedOrGivenToPlayer > 0)
                {
                    overflowRecipient.ChatMessage(Plugin.GetMessage(overflowRecipient.UserIDString, LangEntry.BackpackOverCapacity));
                }

                ActualCapacity = AllowedCapacity;
            }

            private StorageContainer CreateStorageContainer(int capacity)
            {
                var storageContainer = SpawnStorageContainer(capacity);
                _backpackManager.RegisterContainer(storageContainer.inventory, this);
                return storageContainer;
            }

            private ItemContainerAdapter GetAdapterForContainer(ItemContainer container)
            {
                foreach (var containerAdapter in _containerAdapters)
                {
                    var itemContainerAdapter = containerAdapter as ItemContainerAdapter;
                    if (itemContainerAdapter?.ItemContainer != container)
                        continue;

                    return itemContainerAdapter;
                }

                return null;
            }

            private IContainerAdapter EnsurePage(int pageIndex, bool preferRealContainer = false)
            {
                var containerAdapter = _containerAdapters[pageIndex];
                if (containerAdapter == null)
                {
                    if (preferRealContainer)
                    {
                        containerAdapter = CreateItemContainerAdapter(pageIndex).AddDelegates();
                    }
                    else
                    {
                        containerAdapter = CreateVirtualContainerAdapter(pageIndex);
                    }

                    _containerAdapters[pageIndex] = containerAdapter;
                }

                return containerAdapter;
            }

            private BackpackCapacity GetAllowedCapacityForLooter(ulong looterId)
            {
                return looterId == OwnerId ? AllowedCapacity : ActualCapacity;
            }

            private DroppedItemContainer SpawnDroppedBackpack(Vector3 position, int capacity, List<Item> itemList)
            {
                var entity = GameManager.server.CreateEntity(DroppedBackpackPrefab, position, Quaternion.Euler(0, 90, 0));
                if (entity == null)
                {
                    LogError($"Failed to create entity: {DroppedBackpackPrefab}");
                    return null;
                }

                var droppedItemContainer = entity as DroppedItemContainer;
                if (droppedItemContainer == null)
                {
                    LogError($"Entity is not an instance of DroppedItemContainer: {DroppedBackpackPrefab}");
                    return null;
                }

                droppedItemContainer.gameObject.AddComponent<NoRagdollCollision>();

                droppedItemContainer.lootPanelName = ResizableLootPanelName;
                droppedItemContainer.playerName = $"{FindOwnerPlayer()?.Name ?? "Somebody"}'s Backpack";
                droppedItemContainer.playerSteamID = OwnerId;

                droppedItemContainer.inventory = new ItemContainer();
                droppedItemContainer.inventory.ServerInitialize(null, capacity);
                droppedItemContainer.inventory.GiveUID();
                droppedItemContainer.inventory.entityOwner = droppedItemContainer;
                droppedItemContainer.inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);

                foreach (var item in itemList)
                {
                    if (!item.MoveToContainer(droppedItemContainer.inventory))
                    {
                        item.Remove();
                    }
                }

                droppedItemContainer.Spawn();
                droppedItemContainer.ResetRemovalTime(Math.Max(Plugin._config.MinimumDespawnTime, droppedItemContainer.CalculateRemovalTime()));

                return droppedItemContainer;
            }

            private void EnlargeIfNeeded()
            {
                var allowedCapacity = AllowedCapacity;
                if (ActualCapacity >= allowedCapacity)
                    return;

                var allowedPageCount = allowedCapacity.PageCount;
                if (_containerAdapters.Count < allowedPageCount)
                {
                    _containerAdapters.Resize(allowedPageCount);
                }

                for (var i = 0; i < allowedPageCount; i++)
                {
                    var containerAdapter = _containerAdapters[i];
                    if (containerAdapter == null)
                        continue;

                    var allowedPageCapacity = allowedCapacity.CapacityForPage(i);
                    if (containerAdapter.Capacity < allowedPageCapacity)
                    {
                        containerAdapter.Capacity = allowedPageCapacity;
                    }
                }

                ActualCapacity = AllowedCapacity;
            }

            private void KillContainerAdapter(IContainerAdapter containerAdapter)
            {
                #if DEBUG_BACKPACK_LIFECYCLE
                LogDebug($"Backpack::KillContainerAdapter({containerAdapter.GetType().Name}) | OwnerId: {OwnerIdString} | PageIndex: {containerAdapter.PageIndex.ToString()} | Capacity: {containerAdapter.Capacity.ToString()} ");
                #endif

                if (containerAdapter is ItemContainerAdapter itemContainerAdapter)
                {
                    _backpackManager.UnregisterContainer(itemContainerAdapter.ItemContainer);

                }

                containerAdapter.Kill();
                _containerAdapters.RemoveAt(containerAdapter.PageIndex);
                containerAdapter.FreeToPool();
            }

            private void ForceCloseLooter(BasePlayer looter)
            {
                looter.inventory.loot.Clear();
                looter.inventory.loot.MarkDirty();
                looter.inventory.loot.SendImmediate();

                OnClosed(looter);
            }

            private void ForceCloseAllLooters()
            {
                for (var i = _looters.Count - 1; i >= 0; i--)
                {
                    ForceCloseLooter(_looters[i]);
                }
            }

            private StorageContainer SpawnStorageContainer(int capacity)
            {
                var storageEntity = GameManager.server.CreateEntity(CoffinPrefab, new Vector3(0, -500, 0));
                if (storageEntity == null)
                    return null;

                var containerEntity = storageEntity as StorageContainer;
                if (containerEntity == null)
                {
                    UnityEngine.Object.Destroy(storageEntity.gameObject);
                    return null;
                }

                containerEntity.SetFlag(BaseEntity.Flags.Disabled, true);

                var groundWatch = containerEntity.GetComponent<GroundWatch>();
                if (groundWatch != null)
                {
                    UnityEngine.Object.Destroy(groundWatch);
                    groundWatch.fails = int.MinValue;
                }

                UnityEngine.Object.Destroy(containerEntity.GetComponent<DestroyOnGroundMissing>());

                foreach (var collider in containerEntity.GetComponentsInChildren<Collider>())
                {
                    UnityEngine.Object.Destroy(collider);
                }

                containerEntity.CancelInvoke(containerEntity.DecayTick);

                BackpackCloseListener.AddToBackpackStorage(Plugin, containerEntity, this);

                containerEntity.baseProtection = Plugin._immortalProtection;
                containerEntity.panelName = ResizableLootPanelName;

                // Temporarily disable networking to prevent initially sending the entity to clients based on the positional network group.
                containerEntity._limitedNetworking = true;

                containerEntity.EnableSaving(false);
                containerEntity.Spawn();

                // Remove storage entities from the query grid to prevent any grid queries from finding them.
                BaseEntity.Query.Server.Remove(containerEntity);

                // Must change the network group after spawning,
                // or else vanilla UpdateNetworkGroup will switch it to a positional network group.
                containerEntity.net.SwitchGroup(NetworkController.NetworkGroup);

                // Re-enable networking now that the entity is in the correct network group.
                containerEntity._limitedNetworking = false;

                containerEntity.inventory.allowedContents = ItemContainer.ContentsType.Generic;
                containerEntity.inventory.capacity = capacity;

                return containerEntity;
            }

            private void ReclaimItemsForSoftcore()
            {
                var softcoreGameMode = BaseGameMode.svActiveGameMode as GameModeSoftcore;
                if ((object)softcoreGameMode == null || (object)ReclaimManager.instance == null)
                    return;

                var reclaimFraction = Plugin._config.Softcore.ReclaimFraction;
                if (reclaimFraction <= 0)
                    return;

                using var allItemsToReclaim = DisposableList<Item>.Get();

                using (_itemCountChangedEvent.Pause())
                {
                    foreach (var containerAdapter in _containerAdapters)
                    {
                        containerAdapter.ReclaimFractionForSoftcore(reclaimFraction, allItemsToReclaim);
                    }
                }

                if (allItemsToReclaim.Count > 0)
                {
                    // There's a vanilla issue where accessing the reclaim backpack will erase items in the reclaim entry above 32.
                    // So we just add new reclaim entries which can only be accessed at the terminal to avoid this issue.
                    // Additionally, reclaim entries have a max size, so we may need to create multiple.
                    while (allItemsToReclaim.Count > ReclaimEntryMaxSize)
                    {
                        using var itemsToReclaimForEntry = DisposableList<Item>.Get();
                        for (var i = 0; i < ReclaimEntryMaxSize; i++)
                        {
                            itemsToReclaimForEntry.Add(allItemsToReclaim[0]);
                            allItemsToReclaim.RemoveAt(0);
                        }
                        ReclaimManager.instance.AddPlayerReclaim(OwnerId, itemsToReclaimForEntry);
                    }

                    ReclaimManager.instance.AddPlayerReclaim(OwnerId, allItemsToReclaim);

                    Owner?.ChatMessage(Plugin.GetMessage(OwnerIdString, LangEntry.BackpackItemsReclaimed));
                }
            }

            private void SetRetrieveFromPage(int pageIndex, bool retrieve)
            {
                if (pageIndex > 31)
                    return;

                var flag = 1 << pageIndex;

                if (retrieve)
                {
                    RetrieveFromPagesMask |= flag;
                }
                else
                {
                    RetrieveFromPagesMask &= ~flag;
                }

                MarkDirty();
            }

            public void SetGatherModeForPage(BasePlayer player, int pageIndex, GatherMode gatherMode)
            {
                if (gatherMode == GatherMode.None)
                {
                    GatherModeByPage.Remove(pageIndex);
                }
                else
                {
                    GatherModeByPage[pageIndex] = gatherMode;
                }

                SetFlag(Flag.Dirty, true);

                if (GatherModeByPage.Count > 0)
                {
                    StartGathering(player);
                }
                else
                {
                    StopGathering();
                }

                if (Plugin.IsLootingBackpack(player, out var lootingBackpack, out var lootingPageIndex)
                    && lootingBackpack == this)
                {
                    MaybeCreateContainerUi(player,  AllowedCapacity.PageCount, lootingPageIndex, EnsurePage(lootingPageIndex).Capacity);
                }
            }

            private void StartGathering(BasePlayer player)
            {
                if (IsGathering)
                    return;

                _inventoryWatcher = InventoryWatcher.AddToPlayer(player, this);
                _subscriberManager.BroadcastGatherChanged(this, true);
            }

            private void StopGathering()
            {
                if (!IsGathering)
                    return;

                _inventoryWatcher.DestroyImmediate();
                _pauseGatherModeUntilTime = 0;
                _subscriberManager.BroadcastGatherChanged(this, false);
            }

            private void BroadcastItemCountChanged()
            {
                _subscriberManager.BroadcastItemCountChanged(this);
            }

            private void MaybeCreateContainerUi(BasePlayer looter, int allowedPageCount, int pageIndex, int containerCapacity)
            {
                if (!CanGather && !CanRetrieve && allowedPageCount <= 1)
                    return;

                ContainerUi.CreateContainerUi(looter, allowedPageCount, pageIndex, containerCapacity, this);

                if (!_uiViewers.Contains(looter))
                {
                    _uiViewers.Add(looter);
                }
            }
        }

        [JsonConverter(typeof(PoolConverter<EntityData>))]
        private class EntityData : CustomPool.IPooled
        {
            [JsonConverter(typeof(PoolConverter<BasicItemData>))]
            public class BasicItemData : CustomPool.IPooled
            {
                public int ItemId;

                public BasicItemData Setup(int itemId)
                {
                    ItemId = itemId;
                    return this;
                }

                public void EnterPool()
                {
                    #if DEBUG_POOLING
                    LogDebug($"EntityData.BasicItemData::EnterPool | {CustomPool.GetStats<EntityData.BasicItemData>()}");
                    #endif

                    ItemId = 0;
                }

                public void LeavePool()
                {
                    #if DEBUG_POOLING
                    LogDebug($"EntityData.BasicItemData::LeavePool | {CustomPool.GetStats<EntityData.BasicItemData>()}");
                    #endif
                }
            }

            [JsonProperty("Flags", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public BaseEntity.Flags Flags { get; private set; }

            [JsonProperty("DataInt", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int DataInt { get; private set; }

            [JsonProperty("CreatorSteamId", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong CreatorSteamId { get; private set; }

            [JsonProperty("FileContent", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string[] FileContent { get; private set; }

            [JsonProperty("PrefabId", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public uint PrefabId { get; private set; }

            [JsonProperty("PlayerName", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string PlayerName { get; private set; }

            [JsonProperty("Items", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [JsonConverter(typeof(PoolListConverter<BasicItemData>))]
            public List<BasicItemData> Items { get; private set; }

            public void Setup(BaseEntity entity)
            {
                var photoEntity = entity as PhotoEntity;
                if ((object)photoEntity != null)
                {
                    if (photoEntity.ImageCrc == 0)
                        return;

                    var fileContent = FileStorage.server.Get(photoEntity.ImageCrc, FileStorage.Type.jpg, entity.net.ID);
                    if (fileContent == null)
                        return;

                    CreatorSteamId = photoEntity.PhotographerSteamId;
                    FileContent = new[] { Convert.ToBase64String(fileContent) };
                    return;
                }

                var signContent = entity as SignContent;
                if ((object)signContent != null)
                {
                    var imageIdList = signContent.GetContentCRCs;

                    var hasContent = false;
                    foreach (var imageId in imageIdList)
                    {
                        if (imageId != 0)
                        {
                            hasContent = true;
                            break;
                        }
                    }

                    if (!hasContent)
                        return;

                    FileContent = new string[imageIdList.Length];

                    for (var i = 0; i < imageIdList.Length; i++)
                    {
                        var imageId = imageIdList[i];
                        if (imageId == 0)
                            continue;

                        var fileContent = FileStorage.server.Get(imageId, FileStorage.Type.png, entity.net.ID);
                        if (fileContent == null)
                            continue;

                        FileContent[i] = Convert.ToBase64String(fileContent);
                    }

                    return;
                }

                var paintedItemStorageEntity = entity as PaintedItemStorageEntity;
                if ((object)paintedItemStorageEntity != null)
                {
                    if (paintedItemStorageEntity._currentImageCrc == 0)
                        return;

                    var fileContent = FileStorage.server.Get(paintedItemStorageEntity._currentImageCrc, FileStorage.Type.png, entity.net.ID);
                    if (fileContent == null)
                        return;

                    FileContent = new[] { Convert.ToBase64String(fileContent) };
                    return;
                }

                var cassette = entity as Cassette;
                if ((object)cassette != null)
                {
                    DataInt = cassette.preloadedAudioId;

                    if (cassette.AudioId == 0)
                        return;

                    var fileContent = FileStorage.server.Get(cassette.AudioId, FileStorage.Type.ogg, entity.net.ID);
                    if (fileContent == null)
                        return;

                    CreatorSteamId = cassette.CreatorSteamId;
                    FileContent = new[] { Convert.ToBase64String(fileContent) };
                    return;
                }

                var pagerEntity = entity as PagerEntity;
                if ((object)pagerEntity != null)
                {
                    Flags = pagerEntity.flags;
                    DataInt = pagerEntity.GetFrequency();
                    return;
                }

                var mobileInventoryEntity = entity as MobileInventoryEntity;
                if ((object)mobileInventoryEntity != null)
                {
                    Flags = mobileInventoryEntity.flags;
                    return;
                }

                var headEntity = entity as HeadEntity;
                if ((object)headEntity != null)
                {
                    var headData = headEntity.CurrentTrophyData;
                    if (headData == null)
                        return;

                    PrefabId = headData.entitySource;
                    DataInt = headData.horseBreed;
                    CreatorSteamId = headData.playerId;
                    PlayerName = headData.playerName;

                    if (headData.clothing?.Count > 0)
                    {
                        Items ??= CustomPool.GetList<BasicItemData>();

                        foreach (var itemId in headData.clothing)
                        {
                            Items.Add(CustomPool.Get<BasicItemData>().Setup(itemId));
                        }
                    }

                    return;
                }

                LogWarning($"Unable to serialize associated entity of type {entity.GetType()}.");
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"EntityData::EnterPool | {CustomPool.GetStats<EntityData>()}");
                #endif

                Flags = 0;
                DataInt = 0;
                CreatorSteamId = 0;
                FileContent = null;
                PrefabId = 0;
                PlayerName = null;
                if (Items != null)
                {
                    PoolUtils.ResetItemsAndClear(Items);
                    var items = Items;
                    CustomPool.FreeList(ref items);
                    Items = null;
                }
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"EntityData::LeavePool | {CustomPool.GetStats<EntityData>()}");
                #endif
            }

            public void UpdateAssociatedEntity(Item item)
            {
                BaseEntity entity;

                var entityId = item.instanceData?.subEntity ?? new NetworkableId(0);
                if (entityId.Value == 0)
                {
                    var itemModSign = item.info.GetComponent<ItemModSign>();
                    if (itemModSign == null)
                        return;

                    entity = itemModSign.CreateAssociatedEntity(item);
                }
                else
                {
                    entity = BaseNetworkable.serverEntities.Find(entityId) as BaseEntity;
                    if (entity == null)
                        return;
                }

                var photoEntity = entity as PhotoEntity;
                if ((object)photoEntity != null)
                {
                    var fileContent = FileContent?.FirstOrDefault();
                    if (fileContent == null)
                        return;

                    photoEntity.SetImageData(CreatorSteamId, Convert.FromBase64String(fileContent));
                    return;
                }

                var signContent = entity as SignContent;
                if ((object)signContent != null)
                {
                    if (FileContent == null)
                        return;

                    for (uint i = 0; i < FileContent.Length && i < signContent.GetContentCRCs.Length; i++)
                    {
                        var fileContent = FileContent[i];
                        if (fileContent == null)
                            continue;

                        signContent.GetContentCRCs[i] = FileStorage.server.Store(Convert.FromBase64String(fileContent), FileStorage.Type.png, entity.net.ID, i);
                    }

                    return;
                }

                var paintedItemStorageEntity = entity as PaintedItemStorageEntity;
                if ((object)paintedItemStorageEntity != null)
                {
                    var fileContent = FileContent?.FirstOrDefault();
                    if (fileContent == null)
                        return;

                    paintedItemStorageEntity._currentImageCrc = FileStorage.server.Store(Convert.FromBase64String(fileContent), FileStorage.Type.png, entity.net.ID);
                    return;
                }

                var cassette = entity as Cassette;
                if ((object)cassette != null)
                {
                    cassette.preloadedAudioId = DataInt;

                    var fileContent = FileContent?.FirstOrDefault();
                    if (fileContent == null)
                        return;

                    var audioId = FileStorage.server.Store(Convert.FromBase64String(fileContent), FileStorage.Type.ogg, entity.net.ID);
                    cassette.SetAudioId(audioId, CreatorSteamId);
                    return;
                }

                var pagerEntity = entity as PagerEntity;
                if ((object)pagerEntity != null)
                {
                    pagerEntity.flags |= Flags;
                    pagerEntity.ChangeFrequency(DataInt);
                    return;
                }

                var mobileInventoryEntity = entity as MobileInventoryEntity;
                if ((object)mobileInventoryEntity != null)
                {
                    mobileInventoryEntity.flags |= Flags;
                    return;
                }

                var headEntity = entity as HeadEntity;
                if ((object)headEntity != null)
                {
                    headEntity.CurrentTrophyData ??= Pool.Get<ProtoBuf.HeadData>();

                    var headData = headEntity.CurrentTrophyData;
                    headData.entitySource = PrefabId;
                    headData.horseBreed = DataInt;
                    headData.playerId = CreatorSteamId;
                    headData.playerName = PlayerName;

                    if (Items?.Count > 0)
                    {
                        headData.clothing ??= Pool.GetList<int>();

                        foreach (var itemData in Items)
                        {
                            headData.clothing.Add(itemData.ItemId);
                        }
                    }

                    return;
                }
            }
        }

        [JsonConverter(typeof(PoolConverter<OwnershipData>))]
        private class OwnershipData : CustomPool.IPooled
        {
            [JsonProperty("Username")]
            public string Username;

            [JsonProperty("Reason")]
            public string Reason;

            [JsonProperty("Amount")]
            public int Amount;

            public OwnershipData Setup(string username, string reason, int amount)
            {
                Username = username;
                Reason = reason;
                Amount = amount;
                return this;
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"OwnershipData::EnterPool | {CustomPool.GetStats<OwnershipData>()}");
                #endif

                Username = null;
                Reason = null;
                Amount = 0;
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"OwnershipData::LeavePool | {CustomPool.GetStats<OwnershipData>()}");
                #endif
            }
        }

        [JsonConverter(typeof(PoolConverter<ItemData>))]
        private class ItemData : CustomPool.IPooled
        {
            [JsonProperty("ID")]
            public int ID;

            [JsonProperty("Position")]
            public int Position { get; set; } = -1;

            [JsonProperty("Amount")]
            public int Amount { get; private set; }

            [JsonProperty("IsBlueprint", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool IsBlueprint;

            [JsonProperty("BlueprintTarget", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int BlueprintTarget { get; private set; }

            [JsonProperty("Skin", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong Skin;

            [JsonProperty("Fuel", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float Fuel;

            [JsonProperty("FlameFuel", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int FlameFuel;

            [JsonProperty("Condition", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float Condition;

            [JsonProperty("MaxCondition", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float MaxCondition { get; private set; } = -1;

            [JsonProperty("Ammo", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int Ammo;

            [JsonProperty("AmmoType", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int AmmoType;

            [JsonProperty("DataInt", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int DataInt { get; private set; }

            [JsonProperty("Name", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Name;

            [JsonProperty("Text", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private string Text;

            [JsonProperty("Flags", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Item.Flag Flags { get; private set; }

            [JsonProperty("EntityData", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public EntityData EntityData { get; private set; }

            [JsonProperty("Capacity", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int Capacity { get; private set; }

            [JsonProperty("Ownership", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [JsonConverter(typeof(PoolListConverter<OwnershipData>))]
            public List<OwnershipData> Ownership { get; private set; }

            [JsonProperty("Contents", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [JsonConverter(typeof(PoolListConverter<ItemData>))]
            public List<ItemData> Contents { get; private set; }

            public ItemData Setup(Item item, int positionOffset = 0)
            {
                #if DEBUG_POOLING
                LogDebug($"ItemData::Setup | {item.amount.ToString()} {item.info.shortname}");
                #endif

                var heldEntity = item.GetHeldEntity();

                ID = item.info.itemid;
                Position = item.position + positionOffset;
                Amount = item.amount;
                IsBlueprint = item.IsBlueprint();
                BlueprintTarget = item.blueprintTarget;
                Skin = item.skin;
                Fuel = item.fuel;
                FlameFuel = heldEntity?.GetComponent<FlameThrower>()?.ammo ?? 0;
                Condition = item.condition;
                MaxCondition = item.maxCondition;
                Ammo = heldEntity?.GetComponent<BaseProjectile>()?.primaryMagazine?.contents ?? 0;
                AmmoType = heldEntity?.GetComponent<BaseProjectile>()?.primaryMagazine?.ammoType?.itemid ?? 0;
                DataInt = item.instanceData?.dataInt ?? 0;
                Name = item.name;
                Text = item.text;
                Flags = item.flags;

                var subEntityId = item.instanceData?.subEntity ?? new NetworkableId(0);
                if (subEntityId.Value != 0)
                {
                    var subEntity = BaseNetworkable.serverEntities.Find(subEntityId) as BaseEntity;
                    if (subEntity != null)
                    {
                        EntityData ??= CustomPool.Get<EntityData>();
                        EntityData.Setup(subEntity);
                    }
                }

                if (item.contents != null)
                {
                    Capacity = item.contents.capacity;
                    Contents = CustomPool.GetList<ItemData>();
                    foreach (var childItem in item.contents.itemList)
                    {
                        Contents.Add(CustomPool.Get<ItemData>().Setup(childItem));
                    }
                }

                if (item.ownershipShares?.Count > 0)
                {
                    Ownership = CustomPool.GetList<OwnershipData>();
                    foreach (var ownership in item.ownershipShares)
                    {
                        Ownership.Add(CustomPool.Get<OwnershipData>().Setup(ownership.username, ownership.reason, ownership.amount));
                    }
                }

                return this;
            }

            public void EnterPool()
            {
                #if DEBUG_POOLING
                LogDebug($"ItemData::EnterPool | {Amount.ToString()} {ItemManager.FindItemDefinition(ID)?.shortname ?? ID.ToString()} | {CustomPool.GetStats<ItemData>()}");
                #endif

                ID = 0;
                Position = 0;
                Amount = 0;
                IsBlueprint = false;
                BlueprintTarget = 0;
                Skin = 0;
                Fuel = 0;
                FlameFuel = 0;
                Condition = 0;
                MaxCondition = 0;
                Ammo = 0;
                AmmoType = 0;
                DataInt = 0;
                Name = null;
                Text = null;
                Flags = 0;
                Capacity = 0;

                if (EntityData != null)
                {
                    var entityData = EntityData;
                    CustomPool.Free(ref entityData);
                    EntityData = null;
                }

                if (Contents != null)
                {
                    PoolUtils.ResetItemsAndClear(Contents);
                    var contents = Contents;
                    CustomPool.FreeList(ref contents);
                    Contents = null;
                }

                if (Ownership != null)
                {
                    PoolUtils.ResetItemsAndClear(Ownership);
                    var ownership = Ownership;
                    CustomPool.FreeList(ref ownership);
                    Ownership = null;
                }
            }

            public void LeavePool()
            {
                #if DEBUG_POOLING
                LogDebug($"ItemData::LeavePool | {CustomPool.GetStats<ItemData>()}");
                #endif
            }

            public void Reduce(int amount)
            {
                Amount -= amount;
            }

            public Item ToItem(int amount = -1)
            {
                if (amount == -1)
                {
                    amount = Amount;
                }

                if (amount == 0)
                    return null;

                var item = ItemManager.CreateByItemID(ID, amount, Skin);
                if (item == null)
                    return null;

                item.position = Position % _maxCapacityPerPage;

                if (IsBlueprint)
                {
                    item.blueprintTarget = BlueprintTarget;
                    return item;
                }

                item.fuel = Fuel;
                item.condition = Condition;

                if (MaxCondition != -1)
                {
                    item.maxCondition = MaxCondition;
                }

                if (Name != null)
                {
                    item.name = Name;
                }

                if (amount == Amount && (Capacity > 0 || Contents?.Count > 0))
                {
                    if (item.contents == null)
                    {
                        var capacity = Math.Max(Capacity, Contents.Count);
                        if (HasItemMod(item.info, out ItemModContainerArmorSlot itemMod) && capacity > 0)
                        {
                            itemMod.CreateAtCapacity(capacity, item);
                        }
                        else
                        {
                            item.contents = new ItemContainer();
                            item.contents.ServerInitialize(item, capacity);
                            item.contents.GiveUID();
                        }
                    }
                    else
                    {
                        item.contents.capacity = Math.Max(item.contents.capacity, Contents.Count);
                    }

                    if (Contents != null)
                    {
                        foreach (var contentItem in Contents)
                        {
                            var childItem = contentItem.ToItem();
                            if (childItem == null)
                                continue;

                            if (!childItem.MoveToContainer(item.contents, childItem.position)
                                && !childItem.MoveToContainer(item.contents))
                            {
                                childItem.Remove();
                            }
                        }
                    }
                }

                if (Ownership?.Count > 0 && item.ownershipShares != null)
                {
                    foreach (var ownership in Ownership)
                    {
                        item.ownershipShares.Add(new ItemOwnershipShare
                        {
                            username = ownership.Username,
                            reason = ownership.Reason,
                            amount = ownership.Amount,
                        });
                    }
                }

                item.flags |= Flags;

                var heldEntity = item.GetHeldEntity();
                var baseProjectile = heldEntity as BaseProjectile;
                if (baseProjectile != null)
                {
                    baseProjectile.DelayedModsChanged();

                    var magazine = baseProjectile.primaryMagazine;
                    if (magazine != null && AmmoType != 0)
                    {
                        magazine.contents = Ammo;
                        magazine.ammoType = ItemManager.FindItemDefinition(AmmoType) ?? magazine.ammoType;
                    }
                }

                var flameThrower = heldEntity as FlameThrower;
                if ((object)flameThrower != null)
                {
                    flameThrower.ammo = FlameFuel;
                }

                if (DataInt > 0)
                {
                    item.instanceData = new ProtoBuf.Item.InstanceData
                    {
                        ShouldPool = false,
                        dataInt = DataInt,
                    };

                    var detonator = heldEntity as Detonator;
                    if ((object)detonator != null)
                    {
                        detonator.frequency = DataInt;
                    }
                }

                item.text = Text;

                EntityData?.UpdateAssociatedEntity(item);

                return item;
            }
        }

        #endregion

        #region Data

        [JsonObject(MemberSerialization.OptIn)]
        private abstract class BaseData
        {
            [JsonIgnore]
            protected abstract string _fileName { get; }

            [JsonIgnore]
            protected bool _dirty;

            public bool SaveIfChanged()
            {
                if (!_dirty)
                    return false;

                Interface.Oxide.DataFileSystem.WriteObject(_fileName, this);
                _dirty = false;
                return true;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class PreferencesData : BaseData
        {
            private const string FileName = nameof(Backpacks);

            public static PreferencesData Load()
            {
                var data = Interface.Oxide.DataFileSystem.ReadObject<PreferencesData>(FileName);
                if (data == null)
                {
                    data = new PreferencesData { _dirty = true };
                    data.SaveIfChanged();
                }

                return data;
            }

            protected override string _fileName => FileName;

            [JsonProperty("PlayersWithDisabledGUI")]
            private HashSet<ulong> DeprecatedPlayersWithDisabledGUI
            {
                set
                {
                    foreach (var playerId in value)
                    {
                        EnabledGuiPreference[playerId] = false;
                    }
                }
            }

            [JsonProperty("PlayerGuiPreferences")]
            private Dictionary<ulong, bool> EnabledGuiPreference = new();

            public bool? GetGuiButtonPreference(ulong userId)
            {
                return EnabledGuiPreference.TryGetValue(userId, out var guiEnabled)
                    ? guiEnabled
                    : null;
            }

            public bool ToggleGuiButtonPreference(ulong userId, bool defaultEnabled)
            {
                var enabledNow = !(GetGuiButtonPreference(userId) ?? defaultEnabled);
                EnabledGuiPreference[userId] = enabledNow;
                _dirty = true;
                return enabledNow;
            }
        }

        #endregion

        #region Capacity Data

        [JsonObject(MemberSerialization.OptIn)]
        private class CapacityData : BaseData
        {
            private static string FileName = $"{nameof(Backpacks)}Capacity";

            public static bool Exists() => Interface.Oxide.DataFileSystem.ExistsDatafile(FileName);

            public static CapacityData Load()
            {
                var data = Interface.Oxide.DataFileSystem.ReadObject<CapacityData>(FileName);
                if (data == null)
                {
                    data = new CapacityData { _dirty = true };
                    data.SaveIfChanged();
                }

                return data;
            }

            protected override string _fileName => FileName;

            [JsonProperty("PlayerCapacity")]
            private Dictionary<ulong, int> _playerCapacity = new();

            [JsonProperty("BonusCapacity")]
            private Dictionary<ulong, int> _bonusCapacity = new();

            public int? GetPlayerExactCapacity(ulong userId)
            {
                return _playerCapacity.TryGetValue(userId, out var capacity)
                    ? capacity
                    : null;
            }

            public int? GetPlayerBonusCapacity(ulong userId)
            {
                return _bonusCapacity.TryGetValue(userId, out var bonusCapacity)
                    ? bonusCapacity
                    : null;
            }

            public void SetPlayerExactCapacity(ulong userId, int capacity)
            {
                if (_playerCapacity.TryGetValue(userId, out var currentCapacity) && currentCapacity == capacity)
                    return;

                _playerCapacity[userId] = capacity;
                _dirty = true;
            }

            public void SetPlayerBonusCapacity(ulong userId, int bonusCapacity)
            {
                if (_bonusCapacity.TryGetValue(userId, out var currentBonusCapacity) && currentBonusCapacity == bonusCapacity)
                    return;

                _bonusCapacity[userId] = bonusCapacity;
                _dirty = true;
            }

            public void RemovePlayerExactCapacity(ulong userId)
            {
                if (_playerCapacity.Remove(userId))
                {
                    _dirty = true;
                }
            }

            public void Clear()
            {
                if (_playerCapacity.Count != 0)
                {
                    _playerCapacity.Clear();
                    _dirty = true;
                }

                if (_bonusCapacity.Count != 0)
                {
                    _bonusCapacity.Clear();
                    _dirty = true;
                }
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private abstract class BaseItemRuleset
        {
            [JsonIgnore]
            protected abstract string PermissionPrefix { get; }

            [JsonProperty("Name", Order = -2, DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Name;

            [JsonProperty("Allowed item categories")]
            public string[] AllowedItemCategoryNames = Array.Empty<string>();

            [JsonProperty("Disallowed item categories")]
            public string[] DisallowedItemCategoryNames = Array.Empty<string>();

            [JsonProperty("Allowed item short names")]
            public string[] AllowedItemShortNames = Array.Empty<string>();

            [JsonProperty("Disallowed item short names")]
            public string[] DisallowedItemShortNames = Array.Empty<string>();

            [JsonProperty("Allowed skin IDs")]
            public HashSet<ulong> AllowedSkinIds = new();

            [JsonProperty("Disallowed skin IDs")]
            public HashSet<ulong> DisallowedSkinIds = new();

            [JsonIgnore]
            protected ItemCategory[] _allowedItemCategories;

            [JsonIgnore]
            protected ItemCategory[] _disallowedItemCategories;

            [JsonIgnore]
            protected HashSet<int> _allowedItemIds = new();

            [JsonIgnore]
            protected HashSet<int> _disallowedItemIds = new();

            [JsonIgnore]
            public string Permission { get; protected set; }

            [JsonIgnore]
            public bool AllowsAll { get; protected set; }

            public void Init(Backpacks plugin)
            {
                if (!string.IsNullOrWhiteSpace(Name))
                {
                    Permission = $"{nameof(Backpacks)}.{PermissionPrefix}.{Name}".ToLower();
                    plugin.permission.RegisterPermission(Permission, plugin);
                }

                var errorFormat = "Invalid item category in config: {0}";
                _allowedItemCategories = ParseEnumList<ItemCategory>(AllowedItemCategoryNames, errorFormat);
                _disallowedItemCategories = ParseEnumList<ItemCategory>(DisallowedItemCategoryNames, errorFormat);

                foreach (var itemShortName in AllowedItemShortNames)
                {
                    var itemDefinition = ItemManager.FindItemDefinition(itemShortName);
                    if (itemDefinition != null)
                    {
                        _allowedItemIds.Add(itemDefinition.itemid);
                    }
                    else
                    {
                        LogError($"Invalid item short name in config: {itemShortName}");
                    }
                }

                foreach (var itemShortName in DisallowedItemShortNames)
                {
                    var itemDefinition = ItemManager.FindItemDefinition(itemShortName);
                    if (itemDefinition != null)
                    {
                        _disallowedItemIds.Add(itemDefinition.itemid);
                    }
                    else
                    {
                        LogError($"Invalid item short name in config: {itemShortName}");
                    }
                }

                if (_allowedItemCategories.Contains(ItemCategory.All)
                    && _disallowedItemCategories.Length == 0
                    && _disallowedItemIds.Count == 0
                    && DisallowedSkinIds.Count == 0)
                {
                    AllowsAll = true;
                }
            }

            public bool AllowsItem(Item item)
            {
                // Optimization: Skip all checks if all items are allowed.
                if (AllowsAll)
                    return true;

                if (DisallowedSkinIds.Contains(item.skin))
                    return false;

                if (AllowedSkinIds.Contains(item.skin))
                    return true;

                if (_disallowedItemIds.Contains(item.info.itemid))
                    return false;

                if (_allowedItemIds.Contains(item.info.itemid))
                    return true;

                if (_disallowedItemCategories.Contains(item.info.category))
                    return false;

                if (_allowedItemCategories.Contains(item.info.category))
                    return true;

                return _allowedItemCategories.Contains(ItemCategory.All);
            }

            public bool AllowsItem(ItemData itemData)
            {
                // Optimization: Skip all checks if all items are allowed.
                if (AllowsAll)
                    return true;

                if (DisallowedSkinIds.Contains(itemData.Skin))
                    return false;

                if (AllowedSkinIds.Contains(itemData.Skin))
                    return true;

                if (_disallowedItemIds.Contains(itemData.ID))
                    return false;

                if (_allowedItemIds.Contains(itemData.ID))
                    return true;

                // Optimization: Skip looking up the ItemDefinition if all categories are allowed.
                if (_allowedItemCategories.Contains(ItemCategory.All) && _disallowedItemCategories.Length == 0)
                    return true;

                var itemDefinition = ItemManager.FindItemDefinition(itemData.ID);
                if ((object)itemDefinition == null)
                    return true;

                if (_disallowedItemCategories.Contains(itemDefinition.category))
                    return false;

                if (_allowedItemCategories.Contains(itemDefinition.category))
                    return true;

                return _allowedItemCategories.Contains(ItemCategory.All);
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class RestrictionRuleset : BaseItemRuleset
        {
            private const string PartialPermissionPrefix = "restrictions";

            public static readonly string FullPermissionPrefix = $"{nameof(Backpacks)}.{PartialPermissionPrefix}".ToLower();

            public static readonly RestrictionRuleset AllowAll = new() { AllowsAll = true };

            protected override string PermissionPrefix => PartialPermissionPrefix;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class RestrictionOptions
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Enable legacy noblacklist permission")]
            public bool EnableLegacyPermission;

            [JsonProperty("Feedback effect")]
            public string FeedbackEffect = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";

            [JsonProperty("Default ruleset")]
            public RestrictionRuleset DefaultRuleset = new()
            {
                AllowedItemCategoryNames = new[] { ItemCategory.All.ToString() },
            };

            [JsonProperty("Rulesets by permission")]
            public RestrictionRuleset[] RulesetsByPermission =
            {
                new()
                {
                    Name = "allowall",
                    AllowedItemCategoryNames = new [] { ItemCategory.All.ToString() },
                },
            };

            [JsonIgnore]
            private Permission _permission;

            public void Init(Backpacks plugin)
            {
                _permission = plugin.permission;

                if (EnableLegacyPermission)
                {
                    _permission.RegisterPermission(LegacyNoBlacklistPermission, plugin);
                }

                DefaultRuleset.Init(plugin);

                foreach (var ruleset in RulesetsByPermission)
                {
                    ruleset.Init(plugin);
                }
            }

            public RestrictionRuleset GetForPlayer(string userIdString)
            {
                if (EnableLegacyPermission && _permission.UserHasPermission(userIdString, LegacyNoBlacklistPermission))
                    return RestrictionRuleset.AllowAll;

                for (var i = RulesetsByPermission.Length - 1; i >= 0; i--)
                {
                    var ruleset = RulesetsByPermission[i];
                    if (ruleset.Permission != null && _permission.UserHasPermission(userIdString, ruleset.Permission))
                        return ruleset;
                }

                return DefaultRuleset;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class WipeRuleset : BaseItemRuleset
        {
            public static readonly WipeRuleset AllowAll = new()
            {
                MaxSlotsToKeep = -1,
                AllowsAll = true,
            };

            [JsonIgnore]
            protected override string PermissionPrefix => "keeponwipe";

            [JsonProperty("Max slots to keep")]
            public int MaxSlotsToKeep;

            [JsonIgnore]
            public bool DisallowsAll
            {
                get
                {
                    if (AllowsAll)
                        return false;

                    if (MaxSlotsToKeep == 0)
                        return true;

                    return _allowedItemCategories.Length == 0
                       && _allowedItemIds.Count == 0
                       && AllowedSkinIds.Count == 0;
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class WipeOptions
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Enable legacy keeponwipe permission")]
            public bool EnableLegacyPermission;

            [JsonProperty("Default ruleset")]
            public WipeRuleset DefaultRuleset = new();

            [JsonProperty("Rulesets by permission")]
            public WipeRuleset[] RulesetsByPermission =
            {
                new()
                {
                    Name = "all",
                    MaxSlotsToKeep = -1,
                    AllowedItemCategoryNames = new [] { ItemCategory.All.ToString() },
                },
            };

            [JsonIgnore]
            private Permission _permission;

            public void Init(Backpacks plugin)
            {
                _permission = plugin.permission;

                if (EnableLegacyPermission)
                {
                    _permission.RegisterPermission(LegacyKeepOnWipePermission, plugin);
                }

                DefaultRuleset.Init(plugin);

                foreach (var ruleset in RulesetsByPermission)
                {
                    ruleset.Init(plugin);
                }
            }

            public WipeRuleset GetForPlayer(string userIdString)
            {
                if (EnableLegacyPermission && _permission.UserHasPermission(userIdString, LegacyKeepOnWipePermission))
                    return WipeRuleset.AllowAll;

                for (var i = RulesetsByPermission.Length - 1; i >= 0; i--)
                {
                    var ruleset = RulesetsByPermission[i];
                    if (ruleset.Permission != null && _permission.UserHasPermission(userIdString, ruleset.Permission))
                        return ruleset;
                }

                return DefaultRuleset;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class BackpackSizeOptions
        {
            [JsonProperty("Default size")]
            public int DefaultSize = 6;

            [JsonProperty("Max size per page")]
            public int MaxCapacityPerPage = 48;

            [JsonProperty("Enable legacy backpacks.use.1-8 row permissions")]
            public bool EnableLegacyRowPermissions;

            [JsonProperty("Permission sizes")]
            public int[] PermissionSizes = { 6, 12, 18, 24, 30, 36, 42, 48, 96, 144 };

            [JsonProperty("Dynamic Size (EXPERIMENTAL)")]
            public DynamicCapacity DynamicSize = new();
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class ContainerUiOptions
        {
            [JsonProperty("Show page buttons on container bar")]
            public bool ShowPageButtonsOnContainerBar;

            [JsonProperty("Max page buttons to show")]
            public int MaxPageButtonsToShow = 8;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class CapacityProfile
        {
            [JsonProperty("Permission suffix")]
            public string PermissionSuffix;

            [JsonProperty("Initial size")]
            public int InitialCapacity;

            [JsonProperty("Max size")]
            public int MaxCapacity;

            [JsonIgnore]
            public string Permission { get; private set; }

            public void Init(Backpacks plugin)
            {
                if (!string.IsNullOrWhiteSpace(PermissionSuffix))
                {
                    Permission = $"{CapacityProfilePermission}.{PermissionSuffix}";
                    plugin.permission.RegisterPermission(Permission, plugin);
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class CapacityResetOptions
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class DynamicCapacity
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Reset dynamic size on wipe")]
            public CapacityResetOptions CapacityResetOptions = new();

            [JsonProperty("Size profiles")]
            public CapacityProfile[] CapacityProfiles =
            {
                new()
                {
                    PermissionSuffix = "6-48",
                    InitialCapacity = 6,
                    MaxCapacity = 48,
                },
                new()
                {
                    PermissionSuffix = "6-96",
                    InitialCapacity = 6,
                    MaxCapacity = 96,
                },
                new()
                {
                    PermissionSuffix = "6-144",
                    InitialCapacity = 6,
                    MaxCapacity = 144,
                },
            };

            [JsonIgnore]
            private Permission _permission;

            public void Init(Backpacks plugin)
            {
                _permission = plugin.permission;

                if (Enabled && CapacityProfiles != null)
                {
                    foreach (var capacityRuleset in CapacityProfiles)
                    {
                        capacityRuleset.Init(plugin);
                    }
                }
            }

            public (int, int)? GetPlayerProfile(string userIdString)
            {
                if (!Enabled || CapacityProfiles is not { Length: > 0 })
                    return null;

                var initialCapacity = CapacityProfiles[0].InitialCapacity;
                var maxCapacity = CapacityProfiles[0].MaxCapacity;

                for (var i = 1; i < CapacityProfiles.Length; i++)
                {
                    var profile = CapacityProfiles[i];
                    if (profile.Permission == null || !_permission.UserHasPermission(userIdString, profile.Permission))
                        continue;

                    initialCapacity = Math.Max(initialCapacity, profile.InitialCapacity);
                    maxCapacity = Math.Max(maxCapacity, profile.MaxCapacity);
                }

                return (initialCapacity, maxCapacity);
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Backpack size")]
            public BackpackSizeOptions BackpackSize = new();

            [JsonProperty("Backpack Size (1-8 Rows)")]
            private int DeprecatedBackpackRows
            {
                set
                {
                    BackpackSize.DefaultSize = value * 6;
                    BackpackSize.EnableLegacyRowPermissions = true;
                }
            }

            [JsonProperty("Backpack Size (1-7 Rows)")]
            private int DeprecatedBackpackSize
            {
                set
                {
                    BackpackSize.DefaultSize = value * 6;
                    BackpackSize.EnableLegacyRowPermissions = true;
                }
            }

            // Backwards compatibility for 3.8+ pre-releases.
            [JsonProperty("Default Backpack Size")]
            private int DeprecatedDefaultBackpackSize { set => BackpackSize.DefaultSize = value; }

            // Backwards compatibility for 3.8+ pre-releases.
            [JsonProperty("Max Size Per Page")]
            private int DeprecatedMaxSizePerPage { set => BackpackSize.MaxCapacityPerPage = value; }

            // Backwards compatibility for 3.8+ pre-releases.
            [JsonProperty("Backpack Permission Sizes")]
            private int[] DeprecatedPermissionSizes { set => BackpackSize.PermissionSizes = value; }

            // Backwards compatibility for 3.8+ pre-releases.
            [JsonProperty("Enable Legacy Row Permissions (true/false)")]
            private bool EnableLegacyRowPermissions { set => BackpackSize.EnableLegacyRowPermissions = value; }

            [JsonProperty("Drop on Death (true/false)")]
            public bool DropOnDeath = true;

            [JsonProperty("Erase on Death (true/false)")]
            public bool EraseOnDeath = false;

            [JsonProperty("Clear Backpacks on Map-Wipe (true/false)")]
            public bool DeprecatedClearBackpacksOnWipe;

            public bool ShouldSerializeDeprecatedClearBackpacksOnWipe() => false;

            [JsonProperty("Use Blacklist (true/false)")]
            public bool DeprecatedUseDenylist;

            public bool ShouldSerializeDeprecatedUseDenylist() => false;

            [JsonProperty("Blacklisted Items (Item Shortnames)")]
            public string[] DeprecatedDenylistItemShortNames;

            public bool ShouldSerializeDeprecatedDenylistItemShortNames() => false;

            [JsonProperty("Use Whitelist (true/false)")]
            public bool DeprecatedUseAllowlist;

            public bool ShouldSerializeDeprecatedUseAllowlist() => false;

            [JsonProperty("Whitelisted Items (Item Shortnames)")]
            public string[] DeprecatedAllowedItemShortNames;

            public bool ShouldSerializeDeprecatedAllowedItemShortNames() => false;

            [JsonProperty("Minimum Despawn Time (Seconds)")]
            public float MinimumDespawnTime = 300;

            [JsonProperty("GUI Button")]
            public GUIButton GUI = new();

            [JsonProperty("Container UI")]
            public ContainerUiOptions ContainerUi = new();

            [JsonProperty("Softcore")]
            public SoftcoreOptions Softcore = new();

            [JsonProperty("Item restrictions")]
            public RestrictionOptions ItemRestrictions = new();

            [JsonProperty("Clear on wipe")]
            public WipeOptions ClearOnWipe = new();

            public class GUIButton
            {
                [JsonProperty("Enabled")]
                public bool Enabled = true;

                [JsonProperty("Enabled by default (for players with permission)")]
                public bool EnabledByDefault = true;

                [JsonProperty("Skin Id")]
                public ulong SkinId = 3050418770;

                [JsonProperty("Image")]
                public string Image = "";

                [JsonProperty("Background Color")]
                public string Color = "0.969 0.922 0.882 0.035";

                [JsonProperty("GUI Button Position")]
                public Position GUIButtonPosition = new();

                public class Position
                {
                    [JsonProperty("Anchors Min")]
                    public string AnchorsMin = "0.5 0.0";

                    [JsonProperty("Anchors Max")]
                    public string AnchorsMax = "0.5 0.0";

                    [JsonProperty("Offsets Min")]
                    public string OffsetsMin = "185 18";

                    [JsonProperty("Offsets Max")]
                    public string OffsetsMax = "245 78";
                }
            }

            public class SoftcoreOptions
            {
                [JsonProperty("Reclaim Fraction")]
                public float ReclaimFraction = 0.5f;
            }

            public void Init(Backpacks plugin)
            {
                BackpackSize.DynamicSize.Init(plugin);
                ItemRestrictions.Init(plugin);
                ClearOnWipe.Init(plugin);
            }
        }

        private Configuration GetDefaultConfig() => new();

        #region Configuration Helpers

        [JsonObject(MemberSerialization.OptIn)]
        private class BaseConfiguration
        {
            public bool UsingDefaults;

            private string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigSection(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigSection(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigSection(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                var changed = MaybeUpdateConfig(_config);

                if (_config.DeprecatedUseAllowlist || _config.DeprecatedUseDenylist)
                {
                    changed = true;

                    _config.ItemRestrictions.Enabled = true;
                    _config.ItemRestrictions.EnableLegacyPermission = true;

                    if (_config.DeprecatedUseAllowlist)
                    {
                        _config.ItemRestrictions.DefaultRuleset.AllowedItemCategoryNames = Array.Empty<string>();
                        _config.ItemRestrictions.DefaultRuleset.AllowedItemShortNames = _config.DeprecatedAllowedItemShortNames;
                    }
                    else if (_config.DeprecatedUseDenylist)
                    {
                        _config.ItemRestrictions.DefaultRuleset.DisallowedItemShortNames = _config.DeprecatedDenylistItemShortNames;
                    }
                }

                if (_config.DeprecatedClearBackpacksOnWipe)
                {
                    changed = true;

                    _config.ClearOnWipe.Enabled = true;
                    _config.ClearOnWipe.EnableLegacyPermission = true;
                }

                if (_config.GUI.Enabled)
                {
                    if (_config.GUI.Image is "https://i.imgur.com/CyF0QNV.png" or "https://i.imgur.com/T6orn2Q.png")
                    {
                        changed = true;

                        _config.GUI.SkinId = 3050418770;
                        _config.GUI.Image = "";
                    }
                }

                if (changed)
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                PrintError(e.Message);
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
                _config.UsingDefaults = true;
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private class LangEntry
        {
            public static readonly List<LangEntry> AllLangEntries = new();

            public static readonly LangEntry NoPermission = new("No Permission", "You don't have permission to use this command.");
            public static readonly LangEntry MayNotOpenBackpackInEvent = new("May Not Open Backpack In Event", "You may not open a backpack while participating in an event!");
            public static readonly LangEntry ViewBackpackSyntax = new("View Backpack Syntax", "Syntax: viewbackpack <name or id>");
            public static readonly LangEntry ViewBackpackProtected = new("View Backpack Protected", "That player's backpack is protected and cannot be accessed.");
            public static readonly LangEntry UserIDNotFound = new("User ID not Found", "Could not find player with ID '{0}'");
            public static readonly LangEntry UserNameNotFound = new("User Name not Found", "Could not find player with name '{0}'");
            public static readonly LangEntry MultiplePlayersFound = new("Multiple Players Found", "Multiple matching players found:\n{0}");
            public static readonly LangEntry BackpackItemRejected = new("Backpack Item Rejected", "That item is not allowed in the backpack.");
            public static readonly LangEntry BackpackItemsRejected = new("Backpack Items Rejected", "Your backpack rejected some items. They have been added to your inventory or dropped.");
            public static readonly LangEntry BackpackOverCapacity = new("Backpack Over Capacity", "Your backpack was over capacity. Overflowing items were added to your inventory or dropped.");
            public static readonly LangEntry BlacklistedItemsRemoved = new("Blacklisted Items Removed", "Your backpack contained blacklisted items. They have been added to your inventory or dropped.");
            public static readonly LangEntry BackpackFetchSyntax = new("Backpack Fetch Syntax", "Syntax: backpack.fetch <item short name or id> <amount>");
            public static readonly LangEntry BackpackCapacitySyntax = new("Backpack Capacity Syntax", "Syntax: {0} <player> <capacity>");
            public static readonly LangEntry DynamicCapacityNotEnabled = new("Dynamic Size Not Enabled", "Cannot change backpack size for player {0} to {1} because dynamic size is not enabled in the config.");
            public static readonly LangEntry ChangeCapacitySuccess = new("Set Backpack Size Success", "Successfully changed backpack size for player {0} to {1}");
            public static readonly LangEntry InvalidItem = new("Invalid Item", "Invalid Item Name or ID.");
            public static readonly LangEntry InvalidItemAmount = new("Invalid Item Amount", "Item amount must be an integer greater than 0.");
            public static readonly LangEntry ItemNotInBackpack = new("Item Not In Backpack", "Item \"{0}\" not found in backpack.");
            public static readonly LangEntry ItemsFetched = new("Items Fetched", "Fetched {0} \"{1}\" from backpack.");
            public static readonly LangEntry FetchFailed = new("Fetch Failed", "Couldn't fetch \"{0}\" from backpack. Inventory may be full.");
            public static readonly LangEntry ToggledBackpackGUI = new("Toggled Backpack GUI", "Toggled backpack GUI button.");
            public static readonly LangEntry BackpackItemsReclaimed = new("Backpack Items Reclaimed", "Backpack items were sent to the reclaim terminal for safe keeping.");
            public static readonly LangEntry SetGatherSyntax = new("Set Gather Syntax", "Syntax: {0} <{1}> <optional page number>");
            public static readonly LangEntry PageOutOfRange = new("Page Out Of Range", "Backpack page number must be between 1 and {0}.");
            public static readonly LangEntry SetGatherModeSuccess = new("Set Gather Mode Success", "Updated backpack gather mode for page {0} to {1}");
            public static readonly LangEntry GatherModeAll = new("Gather Mode: All", "All");
            public static readonly LangEntry GatherModeExisting = new("Gather Mode: Existing", "Existing");
            public static readonly LangEntry GatherModeOff = new("Gather Mode: Off", "Off");
            public static readonly LangEntry UIGatherAll = new("UI - Gather All", "Gather: All ↓");
            public static readonly LangEntry UIGatherExisting = new("UI - Gather Existing", "Gather: Existing ↓");
            public static readonly LangEntry UIGatherOff = new("UI - Gather Off", "Gather: Off");
            public static readonly LangEntry UIRetrieveOn = new("UI - Retrieve On", "Retrieve: On ↑");
            public static readonly LangEntry UIRetrieveOff = new("UI - Retrieve Off", "Retrieve: Off");

            public string Name;
            public string English;

            public LangEntry(string name, string english)
            {
                Name = name;
                English = english;

                AllLangEntries.Add(this);
            }
        }

        private string GetMessage(string playerId, LangEntry langEntry) =>
            lang.GetMessage(langEntry.Name, this, playerId);

        private string GetMessage(string playerId, LangEntry langEntry, object arg1) =>
            string.Format(GetMessage(playerId, langEntry), arg1);

        private string GetMessage(string playerId, LangEntry langEntry, object arg1, object arg2) =>
            string.Format(GetMessage(playerId, langEntry), arg1, arg2);

        private string GetMessage(string playerId, LangEntry langEntry, object arg1, object arg2, string arg3) =>
            string.Format(GetMessage(playerId, langEntry), arg1, arg2, arg3);

        private string GetMessage(string playerId, LangEntry langEntry, params object[] args) =>
            string.Format(GetMessage(playerId, langEntry), args);

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry) =>
            player.Reply(GetMessage(player.Id, langEntry));

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object arg1) =>
            player.Reply(GetMessage(player.Id, langEntry, arg1));

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object arg1, object arg2) =>
            player.Reply(GetMessage(player.Id, langEntry, arg1, arg2));

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object arg1, object arg2, object arg3) =>
            player.Reply(GetMessage(player.Id, langEntry, arg1, arg2, arg3));

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry, params object[] args) =>
            player.Reply(GetMessage(player.Id, langEntry, args));

        private string GetGatherModeDisplayString(BasePlayer player, GatherMode gatherMode)
        {
            switch (gatherMode)
            {
                case GatherMode.All:
                    return GetMessage(player.UserIDString, LangEntry.GatherModeAll);
                case GatherMode.Existing:
                    return GetMessage(player.UserIDString, LangEntry.GatherModeExisting);
                case GatherMode.None:
                    return GetMessage(player.UserIDString, LangEntry.GatherModeOff);
                default:
                    throw new ArgumentOutOfRangeException(nameof(gatherMode), gatherMode, null);
            }
        }

        protected override void LoadDefaultMessages()
        {
            var englishLangKeys = new Dictionary<string, string>();

            foreach (var langEntry in LangEntry.AllLangEntries)
            {
                englishLangKeys[langEntry.Name] = langEntry.English;
            }

            lang.RegisterMessages(englishLangKeys, this, "en");
        }

        #endregion
    }
}


// --- End of file: Backpacks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/barrel-points ---
// --- Original File Path: B/BarrelPoints/BarrelPoints.cs ---

﻿using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

    #region Changelogs and ToDo
    /*==============================================================================================================
    *    
    *   Scriptzyy the original creator of this plugin
    *   redBDGR the previous maintainer of this plugin
    *   
    *   V2.3.0 : Added Support for Battlepass plugin
    *    
    *    
    *==============================================================================================================*/
    #endregion

namespace Oxide.Plugins
{
    [Info("Barrel Points", "Krungh Crow", "2.3.1")]
    [Description("Gives players extra rewards for destroying barrels")]
    public class BarrelPoints : RustPlugin
    {
        [PluginReference]
        Plugin Battlepass, Economics, ServerRewards;

        #region Variables

        const ulong chaticon = 76561199090290915;
        const string prefix = "<color=yellow>[Barrel Points]</color> ";

        #endregion

        private static Dictionary<string, object> _PermissionDic()
        {
            var x = new Dictionary<string, object>
            {
                {"barrelpoints.default", 2.0},
                {"barrelpoints.vip", 5.0},
                {"barrelpoints.1stcurreny", 2.0},
                {"barrelpoints.2ndcurrency", 5.0},
                {"barrelpoints.1stcurrenyvip", 10.0},
                {"barrelpoints.2ndcurrencyvip", 15.0}
            };
            return x;
        }

        private readonly Dictionary<string, int> playerInfo = new Dictionary<string, int>();
        private readonly List<ulong> crateCache = new List<ulong>();

        private Dictionary<string, object> permissionList;

        private bool changed;
        private bool useEconomy = true;
        private bool useServerRewards;
        private bool useBattlepass;
        private bool useBattlepass1;
        private bool useBattlepass2;
        private bool useItem;
        private string Itemshortname;
        private bool resetBarrelsOnDeath = true;
        private bool sendNotificationMessage = true;
        private bool useCrates;
        private bool useBarrels = true;
        private int givePointsEvery = 1;
        private void OnServerInitialized()
        {
            LoadVariables();

            foreach (var entry in permissionList)
                permission.RegisterPermission(entry.Key, this);

            timer.Once(25f, () =>
            {
                if (useBattlepass && !Battlepass)
                {
                    PrintError("Battlepass was not found! Disabling the \"Use Battlepass\" setting");
                    useBattlepass = false;
                }

                if (useEconomy && !Economics)
                {
                    PrintError("Economics was not found! Disabling the \"Use Economics\" setting");
                    useEconomy = false;
                }

                if (useServerRewards && !ServerRewards)
                {
                    PrintError("ServerRewards was not found! Disabling the \"Use ServerRewards\" setting");
                    useServerRewards = false;
                }

                if (useItem && Itemshortname == "")
                {
                    PrintError("No item for handout was set! Disabling the \"Use Item Rewards\" setting");
                    useItem = false;
                }
            });

        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            permissionList = (Dictionary<string, object>)GetConfig("Point Settings", "Permission List barrels", _PermissionDic());
            useEconomy = Convert.ToBoolean(GetConfig("Plugins", "Use Economics", true));
            useServerRewards = Convert.ToBoolean(GetConfig("Plugins", "Use ServerRewards", false));
            useItem = Convert.ToBoolean(GetConfig("Items", "Use Item Rewards", false));
            Itemshortname = Convert.ToString(GetConfig("Items", "Item Shortname", "scrap"));
            sendNotificationMessage = Convert.ToBoolean(GetConfig("Settings", "Send Notification Message", true));
            givePointsEvery = Convert.ToInt32(GetConfig("Settings", "Give Points Every x Barrels", 1));
            resetBarrelsOnDeath = Convert.ToBoolean(GetConfig("Settings", "Reset Barrel Count on Death", true));
            useBarrels = Convert.ToBoolean(GetConfig("Settings", "Give Points For Barrels", true));
            useCrates = Convert.ToBoolean(GetConfig("Settings", "Give Points For Crates", false));
            //Battlepass
            useBattlepass = Convert.ToBoolean(GetConfig("Plugins", "Use Battlepass", false));
            useBattlepass1 = Convert.ToBoolean(GetConfig("Battlepass Settings", "Use Battlepass 1st currency", false));
            useBattlepass2 = Convert.ToBoolean(GetConfig("Battlepass Settings", "Use Battlepass 2nd currency", false));



            if (!changed)
                return;

            SaveConfig();
            changed = false;
        }

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Economy Notice (Barrel)"] = "You received <color=yellow>${0}</color> for destroying a barrel!",
                ["Economy Notice (Crate)"] = "You received <color=green>${0}</color> for looting a crate!",
                ["RP Notice (Barrel)"] = "You received <color=yellow>{0}</color> RP for destroying a barrel!",
                ["RP Notice (Crate)"] = "You received <color=green>{0}</color> RP for looting a crate!",
                ["Item Notice (Barrel)"] = "You received <color=green>{0}</color> {1} for destroying a barrel!",
                ["Item Notice (Crate)"] = "You received <color=green>{0}</color> {1} for looting a crate!",
                ["BP1 Notice (Barrel)"] = "You received <color=green>{0}</color> BP1 for destroying a barrel!",
                ["BP2 Notice (Barrel)"] = "You received <color=green>{0}</color> BP2 for looting a barrel!",
                ["BP1 Notice (Crate)"] = "You received <color=green>${0}</color> BP1 for looting a crate!",
                ["BP2 Notice (Crate)"] = "You received <color=green>${0}</color> BP2 for looting a crate!"
            }, this);
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!useBarrels || info?.Initiator == null)
                return;

            if (!entity.ShortPrefabName.StartsWith("loot-barrel") && !entity.ShortPrefabName.StartsWith("loot_barrel") && entity.ShortPrefabName != "oil_barrel" && entity.ShortPrefabName != "diesel_barrel_world")//diesel_barrel_world test
                return;

            BasePlayer player = info.InitiatorPlayer;
            if (player == null || !player.IsValid())
                return;

            string userPermission = GetPermissionName(player);
            if (userPermission == null)
                return;

            // Checking for number of barrels hit
            if (!playerInfo.ContainsKey(player.UserIDString))
                playerInfo.Add(player.UserIDString, 0);

            if (playerInfo[player.UserIDString] == givePointsEvery - 1)
            {
                // Section that gives the player their money
                if (useEconomy && Economics)
                {
                    Economics.Call("Deposit", player.userID, Convert.ToDouble(permissionList[userPermission]));
                    if (sendNotificationMessage)
                    {
                        Player.Message(player, prefix + string.Format(Msg("Economy Notice (Barrel)", player.UserIDString), permissionList[userPermission]), chaticon);
                    }
                }
                if (useServerRewards && ServerRewards)
                {
                    ServerRewards.Call("AddPoints", player.userID, Convert.ToInt32(permissionList[userPermission]));
                    if (sendNotificationMessage)
                    {
                        Player.Message(player, prefix + string.Format(Msg("RP Notice (Barrel)", player.UserIDString), permissionList[userPermission]), chaticon);
                    }
                }
                if (useItem)
                {
                    {
                        Item currency = ItemManager.CreateByName(Itemshortname, Convert.ToInt32(permissionList[userPermission]));
                        currency.MoveToContainer(player.inventory.containerMain);
                        if (sendNotificationMessage)
                        {
                            Player.Message(player, prefix + string.Format(Msg("Item Notice (Barrel)", player.UserIDString), Convert.ToInt32(permissionList[userPermission]), Itemshortname), chaticon);
                        }
                    }
                }
                if (useBattlepass == true)
                {
                    if (useBattlepass1)
                    {
                        Battlepass?.Call("AddFirstCurrency", player.userID, Convert.ToInt32(permissionList[userPermission]));
                        if (sendNotificationMessage)
                            Player.Message(player, prefix + string.Format(Msg("BP1 Notice (Barrel)", player.UserIDString), permissionList[userPermission]), chaticon);
                    }

                    if (useBattlepass2)
                    {
                        Battlepass?.Call("AddSecondCurrency", player.userID, Convert.ToInt32(permissionList[userPermission]));
                        if (sendNotificationMessage)
                            Player.Message(player, prefix + string.Format(Msg("BP2 Notice (Barrel)", player.UserIDString), permissionList[userPermission]), chaticon);
                    }
                }
                playerInfo[player.UserIDString] = 0;
            }
            else
                playerInfo[player.UserIDString]++;
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            if (!useCrates || entity == null)
                return;

            if (!entity.ShortPrefabName.Contains("crate_") 
                && entity.ShortPrefabName != "heli_crate"
                && entity.ShortPrefabName != "codelockedhackablecrate"
                && entity.ShortPrefabName != "bradley_crate")
                return;

            if (crateCache.Contains(entity.net.ID.Value))
                crateCache.Remove(entity.net.ID.Value);
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (!useCrates)
                return;

            if (!entity.ShortPrefabName.Contains("crate_") 
                && entity.ShortPrefabName != "heli_crate"
                && entity.ShortPrefabName != "codelockedhackablecrate"
                && entity.ShortPrefabName != "bradley_crate")
                return;

            if (crateCache.Contains(entity.net.ID.Value))
                return;

            crateCache.Add(entity.net.ID.Value);
            string userPermission = GetPermissionName(player);
            if (userPermission == null)
                return;

            if (useEconomy && Economics)
            {
                Economics.Call("Deposit", player.userID, Convert.ToDouble(permissionList[userPermission]));
                if (sendNotificationMessage)
                Player.Message(player, prefix + string.Format(Msg("Economy Notice (Crate)", player.UserIDString), permissionList[userPermission]), chaticon);
            }
            if (useServerRewards)
            {
                ServerRewards.Call("AddPoints", player.userID, Convert.ToInt32(permissionList[userPermission]));
                if (sendNotificationMessage)
                Player.Message(player, prefix + string.Format(Msg("RP Notice (Crate)", player.UserIDString), permissionList[userPermission]), chaticon);
            }
            if (useItem)
            {
                {
                    Item currency = ItemManager.CreateByName(Itemshortname, Convert.ToInt32(permissionList[userPermission]));
                    currency.MoveToContainer(player.inventory.containerMain);
                    if (sendNotificationMessage)
                        Player.Message(player, prefix + string.Format(Msg("Item Notice (Crate)", player.UserIDString), Convert.ToInt32(permissionList[userPermission]), Itemshortname), chaticon);
                }
            }
            if (useBattlepass == true)
            {
                if (useBattlepass1)
                {
                    Battlepass?.Call("AddFirstCurrency", player.userID, Convert.ToInt32(permissionList[userPermission]));
                    if (sendNotificationMessage)
                        Player.Message(player, prefix + string.Format(Msg("BP1 Notice (Crate)", player.UserIDString), permissionList[userPermission]), chaticon);
                }

                if (useBattlepass2)
                {
                    Battlepass?.Call("AddSecondCurrency", player.userID, Convert.ToInt32(permissionList[userPermission]));
                    if (sendNotificationMessage)
                        Player.Message(player, prefix + string.Format(Msg("BP2 Notice (Crate)", player.UserIDString), permissionList[userPermission]), chaticon);
                }
            }
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
        {
            if (!resetBarrelsOnDeath)
                return;

            if (playerInfo.ContainsKey(player.UserIDString))
                playerInfo[player.UserIDString] = 0;
        }

        private string GetPermissionName(BasePlayer player)
        {
            KeyValuePair<string, int> _perms = new KeyValuePair<string, int>(null, 0);
            Dictionary<string, int> perms = permissionList.Where(entry => permission.UserHasPermission(player.UserIDString, entry.Key))
                .ToDictionary(entry => entry.Key, entry => Convert.ToInt32(entry.Value));
            foreach (var entry in perms)
                if (Convert.ToInt32(entry.Value) > _perms.Value)
                    _perms = new KeyValuePair<string, int>(entry.Key, Convert.ToInt32(entry.Value));
            return _perms.Key;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = (Dictionary<string, object>)Config[menu];
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                changed = true;
            }
            return value;
        }

        private string Msg(string key, string id = null) => lang.GetMessage(key, this, id);
    }
}


// --- End of file: BarrelPoints.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/building-grades ---
// --- Original File Path: B/BuildingGrades/BuildingGrades.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Building Grades", "Default/Arainrr", "1.0.13")]
    [Description("Allows players to easily upgrade or downgrade an entire building")]
    public class BuildingGrades : RustPlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin Friends, Clans, NoEscape, RustTranslationAPI;

        private const string PermissionUpPrefix = "buildinggrades.up.";
        private const string PermissionDownPrefx = "buildinggrades.down.";

        private const string PermissionUse = "buildinggrades.use";
        private const string PermissionUpAll = PermissionUpPrefix + "all";
        private const string PermissionDownAll = PermissionDownPrefx + "all";
        private const string PermissionNoCost = "buildinggrades.nocost";
        private const string PermissionAdmin = "buildinggrades.admin";

        private static BuildingGrades _instance;

        private BuildingGradeAssistant _assistant = new BuildingGradeAssistant();

        private readonly Dictionary<string, HashSet<uint>> _categories = new Dictionary<string, HashSet<uint>>(StringComparer.OrdinalIgnoreCase);

        private static readonly List<BuildingGrade.Enum> ValidGrades = new List<BuildingGrade.Enum>
        {
            BuildingGrade.Enum.Twigs, BuildingGrade.Enum.Wood, BuildingGrade.Enum.Stone, BuildingGrade.Enum.Metal, BuildingGrade.Enum.TopTier
        };

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            _instance = this;
            foreach (var kvp in _configData.Permissions)
            {
                if (!permission.PermissionExists(kvp.Key, this))
                {
                    permission.RegisterPermission(kvp.Key, this);
                }
            }
            permission.RegisterPermission(PermissionUpAll, this);
            permission.RegisterPermission(PermissionDownAll, this);
            permission.RegisterPermission(PermissionNoCost, this);
            permission.RegisterPermission(PermissionAdmin, this);

            if (!permission.PermissionExists(PermissionUse, this))
            {
                permission.RegisterPermission(PermissionUse, this);
            }

            foreach (var validGrade in ValidGrades)
            {
                if (validGrade > BuildingGrade.Enum.Twigs)
                {
                    permission.RegisterPermission(PermissionUpPrefix + (int)validGrade, this);
                }

                if (validGrade < BuildingGrade.Enum.TopTier)
                {
                    permission.RegisterPermission(PermissionDownPrefx + (int)validGrade, this);
                }
            }
            cmd.AddChatCommand(_configData.Chat.UpgradeCommand, this, nameof(CmdUpgrade));
            cmd.AddChatCommand(_configData.Chat.DowngradeCommand, this, nameof(CmdDowngrade));
            cmd.AddChatCommand(_configData.Chat.UpgradeAllCommand, this, nameof(CmdUpgradeAll));
            cmd.AddChatCommand(_configData.Chat.DowngradeAllCommand, this, nameof(CmdDowngradeAll));

            if (!_configData.Global.UseRaidBlocker)
            {
                Unsubscribe(nameof(OnRaidBlock));
            }
            if (!_configData.Global.UseCombatBlocker)
            {
                Unsubscribe(nameof(OnCombatBlock));
            }
        }

        private void OnServerInitialized()
        {
            foreach (var entry in _configData.Categories)
            {
                var values = new HashSet<uint>();
                foreach (var prefab in entry.Value)
                {
                    var item = StringPool.Get(prefab);
                    if (item == 0u)
                    {
                        continue;
                    }
                    values.Add(item);
                }
                _categories.Add(entry.Key, values);
            }
        }

        private void Unload()
        {
            _assistant.Unload();
            _instance = null;
        }

        private void OnRaidBlock(BasePlayer player)
        {
            OnCombatBlock(player);
        }

        private void OnCombatBlock(BasePlayer player)
        {
            if (_assistant.IsRunning())
            {
                _assistant.BlockPlayer(player.userID);
            }
        }

        #endregion Oxide Hooks

        #region Chat Commands

        private void CmdUpgrade(BasePlayer player, string command, string[] args)
        {
            HandleCommand(player, args, true, false);
        }

        private void CmdDowngrade(BasePlayer player, string command, string[] args)
        {
            HandleCommand(player, args, false, false);
        }

        private void CmdUpgradeAll(BasePlayer player, string command, string[] args)
        {
            HandleCommand(player, args, true, true);
        }

        private void CmdDowngradeAll(BasePlayer player, string command, string[] args)
        {
            HandleCommand(player, args, false, true);
        }

        #endregion Chat Commands

        #region Methods

        private void HandleCommand(BasePlayer player, string[] args, bool isUpgrade, bool isAll)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            if (_assistant.IsRunning())
            {
                Print(player, Lang("AlreadyProcess", player.UserIDString));
                return;
            }
            if (IsPlayerBlocked(player))
            {
                return;
            }

            HashSet<uint> filter = null;
            var targetGrade = BuildingGrade.Enum.None;
            if (args.Length > 0)
            {
                if (!_categories.TryGetValue(args[0], out filter))
                {
                    if (!Enum.TryParse(args[0], true, out targetGrade) || !ValidGrades.Contains(targetGrade) || isUpgrade ? targetGrade <= BuildingGrade.Enum.Twigs : targetGrade >= BuildingGrade.Enum.TopTier)
                    {
                        Print(player, Lang("UnknownGrade", player.UserIDString));
                        return;
                    }

                    if (!HasGradePermission(player, targetGrade, isUpgrade))
                    {
                        Print(player, Lang("NotAllowed", player.UserIDString));
                        return;
                    }

                    if (args.Length > 1 && !_categories.TryGetValue(args[1], out filter))
                    {
                        Print(player, Lang("UnknownCategory", player.UserIDString, string.Join(", ", _configData.Categories.Keys)));
                        return;
                    }
                }
            }
            else
            {
                if (!_assistant.FindPlayerGrantedGrades(player, isUpgrade))
                {
                    Print(player, Lang("NotAllowed", player.UserIDString));
                    return;
                }
            }

            var permissionSettings = GetPermissionSettings(player);
            if (permissionSettings.Cooldown > 0f && !(_configData.Global.CooldownExclude && player.IsAdmin))
            {
                var timeLeft = _assistant.GetCooldownLeft(player.userID, permissionSettings.Cooldown);
                if (timeLeft > 0f)
                {
                    Print(player, Lang("OnCooldown", player.UserIDString, Mathf.CeilToInt(timeLeft)));
                    return;
                }
            }

            var targetBuildingBlock = GetBuildingBlockLookingAt(player, permissionSettings);
            if (targetBuildingBlock == null)
            {
                Print(player, Lang("NotLookingAt", player.UserIDString));
                return;
            }

            var isAdmin = permission.UserHasPermission(player.UserIDString, PermissionAdmin);
            if (!isAdmin && player.IsBuildingBlocked(targetBuildingBlock.WorldSpaceBounds()))
            {
                Print(player, Lang("BuildingBlocked", player.UserIDString));
                return;
            }
            _assistant.Run(targetBuildingBlock, player, targetGrade, filter, permissionSettings, isUpgrade, isAll, isAdmin);
        }

        private PermissionSettings GetPermissionSettings(BasePlayer player)
        {
            var priority = 0;
            PermissionSettings permissionSettings = null;
            foreach (var entry in _configData.Permissions)
            {
                if (entry.Value.Priority >= priority && permission.UserHasPermission(player.UserIDString, entry.Key))
                {
                    priority = entry.Value.Priority;
                    permissionSettings = entry.Value;
                }
            }
            return permissionSettings ?? new PermissionSettings();
        }

        private bool HasGradePermission(BasePlayer player, BuildingGrade.Enum grade, bool isUpgrade)
        {
            return isUpgrade
                    ? permission.UserHasPermission(player.UserIDString, PermissionUpAll) ||
                    permission.UserHasPermission(player.UserIDString, PermissionUpPrefix + (int)grade)
                    : permission.UserHasPermission(player.UserIDString, PermissionDownAll) ||
                    permission.UserHasPermission(player.UserIDString, PermissionDownPrefx + (int)grade);
        }

        #region AreFriends

        private bool AreFriends(ulong playerId, ulong friendId)
        {
            if (!playerId.IsSteamId())
            {
                return false;
            }
            if (playerId == friendId)
            {
                return true;
            }
            if (_configData.Global.UseTeams && SameTeam(playerId, friendId))
            {
                return true;
            }
            if (_configData.Global.UseFriends && HasFriend(playerId, friendId))
            {
                return true;
            }
            if (_configData.Global.UseClans && SameClan(playerId, friendId))
            {
                return true;
            }
            return false;
        }

        private static bool SameTeam(ulong playerId, ulong friendId)
        {
            if (!RelationshipManager.TeamsEnabled())
            {
                return false;
            }
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerId);
            if (playerTeam == null)
            {
                return false;
            }
            var friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendId);
            if (friendTeam == null)
            {
                return false;
            }
            return playerTeam == friendTeam;
        }

        private bool HasFriend(ulong playerId, ulong friendId)
        {
            if (Friends == null)
            {
                return false;
            }
            return (bool)Friends.Call("HasFriend", playerId, friendId);
        }

        private bool SameClan(ulong playerId, ulong friendId)
        {
            if (Clans == null)
            {
                return false;
            }
            //Clans
            var isMember = Clans.Call("IsClanMember", playerId.ToString(), friendId.ToString());
            if (isMember != null)
            {
                return (bool)isMember;
            }
            //Rust:IO Clans
            var playerClan = Clans.Call("GetClanOf", playerId);
            if (playerClan == null)
            {
                return false;
            }
            var friendClan = Clans.Call("GetClanOf", friendId);
            if (friendClan == null)
            {
                return false;
            }
            return (string)playerClan == (string)friendClan;
        }

        #endregion AreFriends

        #region PlayerIsBlocked

        private bool IsPlayerBlocked(BasePlayer player)
        {
            if (NoEscape == null)
            {
                return false;
            }
            if (_configData.Global.UseRaidBlocker && IsRaidBlocked(player.UserIDString))
            {
                Print(player, Lang("RaidBlocked", player.UserIDString));
                return true;
            }
            if (_configData.Global.UseCombatBlocker && IsCombatBlocked(player.UserIDString))
            {
                Print(player, Lang("CombatBlocked", player.UserIDString));
                return true;
            }
            return false;
        }

        private bool IsRaidBlocked(string playerId)
        {
            return (bool)NoEscape.Call("IsRaidBlocked", playerId);
        }

        private bool IsCombatBlocked(string playerId)
        {
            return (bool)NoEscape.Call("IsCombatBlocked", playerId);
        }

        #endregion PlayerIsBlocked

        #region RustTranslationAPI

        private string GetItemTranslationByShortName(string language, string itemShortName)
        {
            return (string)RustTranslationAPI.Call("GetItemTranslationByShortName", language, itemShortName);
        }

        private string GetItemDisplayName(string language, ItemDefinition itemDefinition)
        {
            if (RustTranslationAPI != null)
            {
                var displayName = GetItemTranslationByShortName(language, itemDefinition.shortname);
                if (!string.IsNullOrEmpty(displayName))
                {
                    return displayName;
                }
            }
            return itemDefinition.displayName.english;
        }

        #endregion RustTranslationAPI

        #endregion Methods

        #region Assistant

        private class BuildingGradeAssistant
        {
            private BuildingGrades Plugin => _instance;

            private Coroutine _changeGradeCoroutine;
            private readonly Dictionary<ulong, bool> _tempFriends = new Dictionary<ulong, bool>();
            private readonly HashSet<BuildingBlock> _allBuildingBlocks = new HashSet<BuildingBlock>();
            private readonly List<BuildingGrade.Enum> _tempGrantedGrades = new List<BuildingGrade.Enum>();

            private readonly List<Item> _collect = new List<Item>();
            private readonly Hash<int, float> _takeOutItems = new Hash<int, float>();
            private readonly Hash<ItemDefinition, int> _missingItems = new Hash<ItemDefinition, int>();

            private HashSet<ulong> _blockedPlayers = new HashSet<ulong>();
            private readonly Dictionary<ulong, float> _cooldowns = new Dictionary<ulong, float>();

            private BuildingBlock _processingBuildingBlock;
            internal bool IsRunning()
            {
                return _changeGradeCoroutine != null;
            }

            internal void Unload()
            {
                if (_changeGradeCoroutine != null)
                {
                    ServerMgr.Instance.StopCoroutine(_changeGradeCoroutine);
                }
            }

            internal void BlockPlayer(ulong playerId)
            {
                _blockedPlayers.Add(playerId);
            }

            internal bool IsProcessingBuildingBlock(BuildingBlock buildingBlock)
            {
                if (buildingBlock == null)
                {
                    return false;
                }
                return _processingBuildingBlock == buildingBlock;
            }

            internal void Run(BuildingBlock sourceEntity, BasePlayer player, BuildingGrade.Enum targetGrade, HashSet<uint> filter, PermissionSettings permissionSettings, bool isUpgrade, bool isAll, bool isAdmin)
            {
                if (IsRunning())
                {
                    return;
                }
                _changeGradeCoroutine = ServerMgr.Instance.StartCoroutine(StartChangeBuildingGrade(sourceEntity, player, targetGrade, filter, permissionSettings, isUpgrade, isAll, isAdmin));
            }

            internal float GetCooldownLeft(ulong playerId, float cooldown)
            {
                float lastUse;
                if (_cooldowns.TryGetValue(playerId, out lastUse))
                {
                    return cooldown - (Time.realtimeSinceStartup - lastUse);
                }
                return 0f;
            }

            internal bool FindPlayerGrantedGrades(BasePlayer player, bool isUpgrade)
            {
                var all = Plugin.permission.UserHasPermission(player.UserIDString, isUpgrade ? PermissionUpAll : PermissionDownAll);
                if (all)
                {
                    _tempGrantedGrades.AddRange(ValidGrades);
                    return _tempGrantedGrades.Count > 0;
                }
                foreach (var validGrade in ValidGrades)
                {
                    if (isUpgrade)
                    {
                        if (validGrade > BuildingGrade.Enum.Twigs && Plugin.permission.UserHasPermission(player.UserIDString, PermissionUpPrefix + (int)validGrade))
                        {
                            _tempGrantedGrades.Add(validGrade);
                        }
                    }
                    else
                    {
                        if (validGrade < BuildingGrade.Enum.TopTier && Plugin.permission.UserHasPermission(player.UserIDString, PermissionDownPrefx + (int)validGrade))
                        {
                            _tempGrantedGrades.Add(validGrade);
                        }
                    }
                }
                return _tempGrantedGrades.Count > 0;
            }

            private IEnumerator StartChangeBuildingGrade(BuildingBlock sourceEntity, BasePlayer player, BuildingGrade.Enum targetGrade, HashSet<uint> filter, PermissionSettings permissionSettings, bool isUpgrade, bool isAll, bool isAdmin)
            {
                _blockedPlayers.Clear();
                yield return GetAllBuildingBlocks(sourceEntity, filter, isAll);
                //if (pay) {
                //    FindUpgradeCosts(targetGrade);
                //    if (!CanAffordUpgrade(player)) {
                //        Clear();
                //        yield break;
                //    }
                //    PayForUpgrade(costs, player);
                //}

                Plugin.Print(player, Plugin.Lang(isUpgrade ? "StartUpgrade" : "StartDowngrade", player.UserIDString));
                var playerId = player.userID;
                yield return isUpgrade ? UpgradeBuildingBlocks(player, targetGrade, permissionSettings, isAdmin) : DowngradeBuildingBlocks(player, targetGrade, permissionSettings, isAdmin);

                _tempFriends.Clear();
                _allBuildingBlocks.Clear();
                _tempGrantedGrades.Clear();
                _blockedPlayers.Clear();
                _cooldowns[playerId] = Time.realtimeSinceStartup;
                _processingBuildingBlock = null;
                _changeGradeCoroutine = null;
            }

            private bool ShouldInterrupt(ulong playerId)
            {
                return _blockedPlayers.Contains(playerId);
            }

            #region Upgrade

            private IEnumerator UpgradeBuildingBlocks(BasePlayer player, BuildingGrade.Enum targetGrade, PermissionSettings permissionSettings, bool isAdmin)
            {
                var pay = permissionSettings.Pay && !Plugin.permission.UserHasPermission(player.UserIDString, PermissionNoCost);
                int current = 0, success = 0;
                var autoGrade = targetGrade == BuildingGrade.Enum.None;
                foreach (var buildingBlock in _allBuildingBlocks)
                {
                    if (buildingBlock == null || buildingBlock.IsDestroyed)
                    {
                        continue;
                    }
                    if (ShouldInterrupt(player.userID))
                    {
                        break;
                    }
                    var grade = targetGrade;
                    if (CheckBuildingGrade(buildingBlock, true, ref grade))
                    {
                        if (!autoGrade || _tempGrantedGrades.Contains(grade))
                        {
                            _processingBuildingBlock = buildingBlock;
                            if (TryUpgradeToGrade(buildingBlock, player, grade, pay, isAdmin))
                            {
                                success++;
                            }
                            _processingBuildingBlock = null;
                        }
                    }

                    if (++current % Plugin._configData.Global.PerFrame == 0)
                    {
                        yield return CoroutineEx.waitForEndOfFrame;
                    }
                }

                foreach (var item in _collect)
                {
                    _takeOutItems[item.info.itemid] += item.amount;
                    item.Remove();
                }
                foreach (var entry in _takeOutItems)
                {
                    player.Command("note.inv " + entry.Key + " " + entry.Value * -1f);
                }

                if (player != null && player.IsConnected)
                {
                    if (_missingItems.Count > 0)
                    {
                        var stringBuilder = Pool.Get<StringBuilder>();
                        stringBuilder.Clear();
                        var language = Plugin.lang.GetLanguage(player.UserIDString);
                        foreach (var entry in _missingItems)
                        {
                            stringBuilder.AppendLine(Plugin.Lang("MissingItemsFormat", player.UserIDString, Plugin.GetItemDisplayName(language, entry.Key), entry.Value));
                        }
                        var missingResources = stringBuilder.ToString();
                        stringBuilder.Clear();
                        Pool.FreeUnmanaged(ref stringBuilder);
                        Plugin.Print(player, success > 0 ? Plugin.Lang("UpgradeNotEnoughItemsSuccess", player.UserIDString, success, missingResources) : Plugin.Lang("UpgradeNotEnoughItems", player.UserIDString, missingResources));
                    }
                    else
                    {
                        Plugin.Print(player, success > 0 ? Plugin.Lang("FinishedUpgrade", player.UserIDString, success) : Plugin.Lang("NotUpgraded", player.UserIDString));
                    }
                }

                _collect.Clear();
                _takeOutItems.Clear();
                _missingItems.Clear();
            }

            private bool TryUpgradeToGrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum targetGrade, bool pay, bool isAdmin)
            {
                if (!CanUpgrade(buildingBlock, player, targetGrade, pay, isAdmin))
                {
                    return false;
                }
                var oldGrade = buildingBlock.grade;
                SetBuildingBlockGrade(buildingBlock, targetGrade);
                Interface.CallHook("OnStructureGradeUpdated", buildingBlock, player, oldGrade, targetGrade);
                return true;
            }

            private bool CanUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum targetGrade, bool pay, bool isAdmin)
            {
                if (player == null || !player.CanInteract())
                {
                    return false;
                }
                var constructionGrade = buildingBlock.blockDefinition.GetGrade(targetGrade, 0);
                if (constructionGrade == null)
                {
                    return false;
                }
                if (!isAdmin)
                {
                    if (Interface.CallHook("OnStructureUpgrade", buildingBlock, player, targetGrade, 0) != null)
                    {
                        return false;
                    }
                    if (buildingBlock.SecondsSinceAttacked < 30f)
                    {
                        return false;
                    }
                    if (!buildingBlock.CanChangeToGrade(targetGrade, 0, player))
                    {
                        return false;
                    }

                    if (!HasAccess(player, buildingBlock))
                    {
                        return false;
                    }
                }
                if (pay)
                {
                    //if (!buildingBlock.CanAffordUpgrade(targetGrade, player)) {
                    //    return false;
                    //}
                    //buildingBlock.PayForUpgrade(constructionGrade, player);
                    if (!CanAffordUpgrade(buildingBlock, constructionGrade, player, targetGrade))
                    {
                        return false;
                    }
                    PayForUpgrade(buildingBlock, constructionGrade, player);
                }
                return true;
            }

            public bool CanAffordUpgrade(BuildingBlock buildingBlock, ConstructionGrade constructionGrade, BasePlayer player, BuildingGrade.Enum grade)
            {
                var obj = Interface.CallHook("CanAffordUpgrade", player, buildingBlock, grade);
                if (obj is bool)
                {
                    return (bool)obj;
                }

                var flag = true;
                foreach (var item in constructionGrade.CostToBuild())
                {
                    var missingAmount = item.amount - player.inventory.GetAmount(item.itemid);
                    if (missingAmount > 0f)
                    {
                        flag = false;
                        _missingItems[item.itemDef] += (int)missingAmount;
                    }
                }
                return flag;
            }

            public void PayForUpgrade(BuildingBlock buildingBlock, ConstructionGrade constructionGrade, BasePlayer player)
            {
                if (Interface.CallHook("OnPayForUpgrade", player, buildingBlock, constructionGrade) != null)
                {
                    return;
                }
                foreach (var item in constructionGrade.CostToBuild())
                {
                    player.inventory.Take(_collect, item.itemid, (int)item.amount);
                    //player.Command("note.inv " + item.itemid + " " + item.amount * -1f);
                }
            }

            #endregion Upgrade

            #region Downgrade

            private IEnumerator DowngradeBuildingBlocks(BasePlayer player, BuildingGrade.Enum targetGrade, PermissionSettings permissionSettings, bool isAdmin)
            {
                int current = 0, success = 0;
                var autoGrade = targetGrade == BuildingGrade.Enum.None;
                foreach (var buildingBlock in _allBuildingBlocks)
                {
                    if (buildingBlock == null || buildingBlock.IsDestroyed)
                    {
                        continue;
                    }
                    if (ShouldInterrupt(player.userID))
                    {
                        break;
                    }
                    var grade = targetGrade;
                    if (CheckBuildingGrade(buildingBlock, false, ref grade))
                    {
                        if (!autoGrade || _tempGrantedGrades.Contains(grade))
                        {
                            _processingBuildingBlock = buildingBlock;
                            if (TryDowngradeToGrade(buildingBlock, player, grade /*, permissionSettings.Refund*/, isAdmin: isAdmin))
                            {
                                success++;
                            }
                            _processingBuildingBlock = null;
                        }
                    }
                    if (current++ % Plugin._configData.Global.PerFrame == 0)
                    {
                        yield return CoroutineEx.waitForEndOfFrame;
                    }
                }

                if (player != null && player.IsConnected)
                {
                    Plugin.Print(player, success > 0 ? Plugin.Lang("FinishedDowngrade", player.UserIDString, success) : Plugin.Lang("NotDowngraded", player.UserIDString));
                }
            }

            private bool TryDowngradeToGrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum targetGrade, bool refund = false, bool isAdmin = false)
            {
                if (!CanDowngrade(buildingBlock, player, targetGrade, refund, isAdmin))
                {
                    return false;
                }

                //if (refund)
                //{
                //    foreach (var itemAmount in buildingBlock.currentGrade.costToBuild)
                //    {
                //        var item = ItemManager.CreateByItemID(itemAmount.itemid, (int)itemAmount.amount);
                //        player.GiveItem(item);
                //    }
                //}
                var oldGrade = buildingBlock.grade;
                SetBuildingBlockGrade(buildingBlock, targetGrade);
                Interface.CallHook("OnStructureGradeUpdated", buildingBlock, player, oldGrade, targetGrade);
                return true;
            }

            private bool CanDowngrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum targetGrade, bool refund, bool isAdmin)
            {
                if (player == null || !player.CanInteract())
                {
                    return false;
                }

                var constructionGrade = buildingBlock.blockDefinition.GetGrade(targetGrade, 0);
                if (constructionGrade == null)
                {
                    return false;
                }

                if (!isAdmin)
                {
                    if (Interface.CallHook("OnStructureUpgrade", buildingBlock, player, targetGrade, 0) != null)
                    {
                        return false;
                    }
                    if (buildingBlock.SecondsSinceAttacked < 30f)
                    {
                        return false;
                    }
                    var obj = Interface.CallHook("CanChangeGrade", player, buildingBlock, targetGrade);
                    if (obj is bool)
                    {
                        return (bool)obj;
                    }
                    if (player.IsBuildingBlocked(buildingBlock.transform.position, buildingBlock.transform.rotation, buildingBlock.bounds))
                    {
                        return false;
                    }
                    if (buildingBlock.IsUpgradeBlocked())
                    {
                        return false;
                    }
                    if (!HasAccess(player, buildingBlock))
                    {
                        return false;
                    }
                }

                return true;
            }

            #endregion Downgrade

            #region Methods

            private bool HasAccess(BasePlayer player, BuildingBlock buildingBlock)
            {
                bool flag;
                if (_tempFriends.TryGetValue(buildingBlock.OwnerID, out flag))
                {
                    return flag;
                }
                var areFriends = Plugin.AreFriends(buildingBlock.OwnerID, player.userID);
                _tempFriends.Add(buildingBlock.OwnerID, areFriends);
                return areFriends;
            }

            private IEnumerator GetAllBuildingBlocks(BuildingBlock sourceEntity, HashSet<uint> filter, bool isAll)
            {
                Func<BuildingBlock, bool> func = x => filter == null || filter.Contains(x.prefabID);
                if (isAll)
                {
                    yield return GetNearbyEntities(sourceEntity, _allBuildingBlocks, Layers.Mask.Construction, func);
                }
                else
                {
                    var building = sourceEntity.GetBuilding();
                    if (building != null)
                    {
                        foreach (var buildingBlock in building.buildingBlocks)
                        {
                            if (func(buildingBlock))
                            {
                                _allBuildingBlocks.Add(buildingBlock);
                            }
                        }
                    }
                }
            }

            //#region TryPay

            //private readonly Hash<int, int> costs = new Hash<int, int>();
            //private readonly Hash<string , int> missingDictionary = new Hash<string, int>();
            //private readonly HashSet<BuildingBlock> toRemove = new HashSet<BuildingBlock>();

            //private bool TryPay(BasePlayer player, BuildingGrade.Enum targetGrade, out string missingResources) {
            //    FindUpgradeCosts(player, targetGrade);
            //    if (!CanPay(player, out missingResources)) {
            //        return false;
            //    }

            //    var collect = Pool.GetList<Item>();
            //    foreach (var entry in costs) {
            //        player.inventory.Take(collect, entry.Key, entry.Value);
            //        player.Command(string.Concat("note.inv ", entry.Key, " ", entry.Value * -1f));
            //    }
            //    foreach (var item in collect) {
            //        item.Remove();
            //    }
            //    Pool.FreeList(ref collect);
            //    missingResources = null;
            //    return true;
            //}

            //private bool CanPay(BasePlayer player, out string missingResources) {
            //    foreach (var entry in costs) {
            //        if (entry.Value <= 0) continue;
            //        var missingAmount = entry.Value - player.inventory.GetAmount(entry.Key);
            //        if (missingAmount <= 0) continue;
            //       var displayName=  ItemManager.FindItemDefinition(entry.Key)?.displayName.english;
            //       if (string.IsNullOrEmpty(displayName)) displayName = entry.Key.ToString();
            //         missingDictionary[displayName] += missingAmount;
            //    }
            //    if (missingDictionary.Count > 0) {
            //        StringBuilder stringBuilder = Pool.Get<StringBuilder>();
            //        stringBuilder.Clear();
            //        foreach (var entry in missingDictionary) {
            //            stringBuilder.AppendLine(Lang("MissingResourceFormat", player.UserIDString, entry.Key, entry.Value));
            //        }
            //        missingResources = stringBuilder.ToString();
            //        stringBuilder.Clear();
            //        missingDictionary.Clear();
            //        Pool.Free(ref stringBuilder);
            //        return false;
            //    }
            //    missingResources = null;
            //    return true;
            //}

            //private void FindUpgradeCosts(BasePlayer player, BuildingGrade.Enum targetGrade) {
            //    var autoGrade = targetGrade == BuildingGrade.Enum.None;
            //    foreach (var buildingBlock in allBuildingBlocks) {
            //        if (buildingBlock == null || buildingBlock.IsDestroyed) {
            //            toRemove.Add(buildingBlock);
            //            continue;
            //        }
            //        BuildingGrade.Enum grade = targetGrade;
            //        if (CheckBuildingGrade(buildingBlock, false, ref grade)) {
            //            if (!autoGrade || tempGrantedGrades.Contains(grade)) {
            //                if (!CanUpgrade(buildingBlock, player, grade)) {
            //                    toRemove.Add(buildingBlock);
            //                    continue;
            //                }
            //            }
            //        }
            //        var costToBuild = buildingBlock.blockDefinition.grades[(int)grade].costToBuild;
            //        foreach (var itemAmount in costToBuild) {
            //            costs[itemAmount.itemid] += (int)itemAmount.amount;
            //        }
            //    }

            //    foreach (var buildingBlock in toRemove) {
            //        allBuildingBlocks.Remove(buildingBlock);
            //    }
            //    toRemove.Clear();
            //}

            //#endregion TryPay

            #endregion Methods
        }

        #endregion Assistant

        #region Helpers

        private static BuildingBlock GetBuildingBlockLookingAt(BasePlayer player, PermissionSettings permissionSettings)
        {
            RaycastHit raycastHit;
            var flag = Physics.Raycast(player.eyes.HeadRay(), out raycastHit, permissionSettings.Distance, Layers.Mask.Construction);
            return flag ? raycastHit.GetEntity() as BuildingBlock : null;
        }

        private static bool CheckBuildingGrade(BuildingBlock buildingBlock, bool isUpgrade, ref BuildingGrade.Enum targetGrade)
        {
            if (buildingBlock.blockDefinition == null)
            {
                return false;
            }
            var grades = buildingBlock.blockDefinition.grades;
            if (grades == null)
            {
                return false;
            }

            var grade = buildingBlock.grade;
            if (IsValidGrade(grades, (int)targetGrade))
            {
                return isUpgrade ? grade < targetGrade : grade > targetGrade;
            }

            targetGrade = grade + (isUpgrade ? 1 : -1);
            return IsValidGrade(grades, (int)targetGrade);
        }

        private static bool IsValidGrade(ConstructionGrade[] grades, int targetGrade)
        {
            return targetGrade >= 0 && targetGrade < grades.Length && grades[targetGrade] != null;
        }

        private static void SetBuildingBlockGrade(BuildingBlock buildingBlock, BuildingGrade.Enum targetGrade)
        {
            buildingBlock.skinID = 0; // to avoid upgrade/downgrade to twig when using building skin
            buildingBlock.SetGrade(targetGrade);
            buildingBlock.SetHealthToMax();
            buildingBlock.StartBeingRotatable();
            buildingBlock.SendNetworkUpdate();
            buildingBlock.UpdateSkin();
            buildingBlock.ResetUpkeepTime();
            buildingBlock.UpdateSurroundingEntities();
            BuildingManager.server.GetBuilding(buildingBlock.buildingID)?.Dirty();
            if (targetGrade > BuildingGrade.Enum.Twigs)
            {
                Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + targetGrade.ToString().ToLower() + ".prefab", buildingBlock, 0u, Vector3.zero, Vector3.zero);
            }
        }

        private static IEnumerator GetNearbyEntities<T>(T sourceEntity, HashSet<T> entities, int layers, Func<T, bool> filter = null) where T : BaseEntity
        {
            var current = 0;
            var checkFrom = Pool.Get<Queue<Vector3>>();
            var nearbyEntities = Pool.Get<List<T>>();
            checkFrom.Enqueue(sourceEntity.transform.position);
            while (checkFrom.Count > 0)
            {
                nearbyEntities.Clear();
                var position = checkFrom.Dequeue();
                Vis.Entities(position, 3f, nearbyEntities, layers);
                for (var i = 0; i < nearbyEntities.Count; i++)
                {
                    var entity = nearbyEntities[i];
                    if (filter != null && !filter(entity))
                    {
                        continue;
                    }
                    if (!entities.Add(entity))
                    {
                        continue;
                    }
                    checkFrom.Enqueue(entity.transform.position);
                }
                if (++current % _instance._configData.Global.PerFrame == 0)
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                }
            }
            Pool.FreeUnmanaged(ref checkFrom);
            Pool.FreeUnmanaged(ref nearbyEntities);
        }

        #endregion Helpers

        #region API

        private bool IsProcessingBuildingBlock(BuildingBlock buildingBlock)
        {
            return _assistant.IsProcessingBuildingBlock(buildingBlock);
        }

        #endregion

        #region ConfigurationFile

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Settings")]
            public GlobalSettings Global { get; set; } = new GlobalSettings();

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings Chat { get; set; } = new ChatSettings();

            [JsonProperty(PropertyName = "Permission Settings")]
            public Dictionary<string, PermissionSettings> Permissions { get; set; } = new Dictionary<string, PermissionSettings>
            {
                [PermissionUse] = new PermissionSettings
                {
                    Priority = 0,
                    Pay = true,
                    //Refund = false,
                    Cooldown = 60,
                    Distance = 10
                }
            };

            [JsonProperty(PropertyName = "Building Block Categories", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, HashSet<string>> Categories { get; set; } = new Dictionary<string, HashSet<string>>
            {
                ["foundation"] = new HashSet<string>
                {
                    "assets/prefabs/building core/foundation/foundation.prefab",
                    "assets/prefabs/building core/foundation.steps/foundation.steps.prefab",
                    "assets/prefabs/building core/foundation.triangle/foundation.triangle.prefab"
                },
                ["wall"] = new HashSet<string>
                {
                    "assets/prefabs/building core/wall/wall.prefab",
                    "assets/prefabs/building core/wall.doorway/wall.doorway.prefab",
                    "assets/prefabs/building core/wall.frame/wall.frame.prefab",
                    "assets/prefabs/building core/wall.half/wall.half.prefab",
                    "assets/prefabs/building core/wall.low/wall.low.prefab",
                    "assets/prefabs/building core/wall.window/wall.window.prefab"
                },
                ["floor"] = new HashSet<string>
                {
                    "assets/prefabs/building core/floor/floor.prefab",
                    "assets/prefabs/building core/floor.frame/floor.frame.prefab",
                    "assets/prefabs/building core/floor.triangle/floor.triangle.prefab",
                    "assets/prefabs/building core/floor.triangle.frame/floor.triangle.frame.prefab"
                },
                ["stair"] = new HashSet<string>
                {
                    "assets/prefabs/building core/stairs.l/block.stair.lshape.prefab",
                    "assets/prefabs/building core/stairs.spiral/block.stair.spiral.prefab",
                    "assets/prefabs/building core/stairs.spiral.triangle/block.stair.spiral.triangle.prefab",
                    "assets/prefabs/building core/stairs.u/block.stair.ushape.prefab"
                },
                ["roof"] = new HashSet<string>
                {
                    "assets/prefabs/building core/roof/roof.prefab",
                    "assets/prefabs/building core/roof.triangle/roof.triangle.prefab"
                },
                ["ramp"] = new HashSet<string>
                {
                    "assets/prefabs/building core/ramp/ramp.prefab"
                }
            };
        }

        private class GlobalSettings
        {
            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams { get; set; }

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans { get; set; } = true;

            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends { get; set; } = true;

            [JsonProperty(PropertyName = "Use Raid Blocker (Need NoEscape Plugin)")]
            public bool UseRaidBlocker { get; set; }

            [JsonProperty(PropertyName = "Use Combat Blocker (Need NoEscape Plugin)")]
            public bool UseCombatBlocker { get; set; }

            [JsonProperty(PropertyName = "Cooldown Exclude Admins")]
            public bool CooldownExclude { get; set; } = true;

            [JsonProperty(PropertyName = "Upgrade/Downgrade Per Frame")]
            public int PerFrame { get; set; } = 10;
        }

        private class ChatSettings
        {
            [JsonProperty(PropertyName = "Upgrade Chat Command")]
            public string UpgradeCommand { get; set; } = "up";

            [JsonProperty(PropertyName = "Downgrade Chat Command")]
            public string DowngradeCommand { get; set; } = "down";

            [JsonProperty(PropertyName = "Upgrade All Chat Command")]
            public string UpgradeAllCommand { get; set; } = "upall";

            [JsonProperty(PropertyName = "Downgrade All Chat Command")]
            public string DowngradeAllCommand { get; set; } = "downall";

            [JsonProperty(PropertyName = "Chat Prefix")]
            public string Prefix { get; set; } = "<color=#00FFFF>[BuildingGrades]</color>: ";

            [JsonProperty(PropertyName = "Chat SteamID Icon")]
            public ulong SteamIdIcon { get; set; } = 0;
        }

        public class PermissionSettings
        {
            [JsonProperty(PropertyName = "Priority")]
            public int Priority { get; set; }

            [JsonProperty(PropertyName = "Distance")]
            public float Distance { get; set; } = 4f;

            [JsonProperty(PropertyName = "Cooldown")]
            public float Cooldown { get; set; } = 60f;

            [JsonProperty(PropertyName = "Pay")]
            public bool Pay { get; set; } = true;

            // [JsonProperty(PropertyName = "Refund")]
            // public bool Refund { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_configData);
        }

        #endregion ConfigurationFile

        #region LanguageFile

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, _configData.Chat.Prefix, _configData.Chat.SteamIdIcon);
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "<color=#FF1919>You do not have permission to use this command.</color>",
                ["UnknownGrade"] = "<color=#FF1919>Unknown grade.</color>",
                ["UnknownCategory"] = "<color=#FF1919>Unknown category.</color> Available categories: <color=#009EFF>{0}</color>",
                ["NotLookingAt"] = "<color=#FF1919>You are not looking at a building block.</color>",
                ["RaidBlocked"] = "<color=#FF1919>You may not do that while raid blocked.</color>.",
                ["CombatBlocked"] = "<color=#FF1919>You may not do that while combat blocked.</color>.",
                ["OnCooldown"] = "You must wait <color=#FF1919>{0}</color> seconds before you can use this command.",
                ["BuildingBlocked"] = "You can't use this command if you don't have the building privileges.",

                ["MissingItemsFormat"] = "* <color=#FF1919>{0}</color> x{1}",
                ["StartUpgrade"] = "Start running upgrade, please wait.",
                ["StartDowngrade"] = "Start running downgrade, please wait.",
                ["AlreadyProcess"] = "There is already a process already running, please wait.",

                ["UpgradeNotEnoughItems"] = "None of the buildings were upgraded. You are missing: \n{0}",
                ["UpgradeNotEnoughItemsSuccess"] = "<color=#FF1919>{0}</color> building blocks were upgraded. Some buildings cannot be upgraded, you are missing: \n{1}",

                ["NotUpgraded"] = "None of the buildings were upgraded.",
                ["NotDowngraded"] = "None of the buildings were downgraded.",
                ["FinishedUpgrade"] = "<color=#FF1919>{0}</color> building blocks were upgraded.",
                ["FinishedDowngrade"] = "<color=#FF1919>{0}</color> building blocks were downgraded."
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "<color=#FF1919>您没有使用该命令的权限</color>",
                ["UnknownGrade"] = "<color=#FF1919>未知的建筑等级</color>",
                ["UnknownCategory"] = "<color=#FF1919>未知的建筑类型</color> 可用的建筑类型: <color=#009EFF>{0}</color>",
                ["NotLookingAt"] = "<color=#FF1919>您需要看着一个建筑</color>",
                ["RaidBlocked"] = "<color=#FF1919>您被突袭阻止了，不能使用该命令</color>",
                ["CombatBlocked"] = "<color=#FF1919>您被战斗阻止了，不能使用该命令</color>",
                ["OnCooldown"] = "您必须等待 <color=#FF1919>{0}</color> 秒后才能使用该命令",
                ["BuildingBlocked"] = "您不能在没有领地权的地方使用该命令",

                ["MissingItemsFormat"] = "* <color=#FF1919>{0}</color> x{1}",
                ["StartUpgrade"] = "开始运行升级您的建筑，请稍等片刻",
                ["StartDowngrade"] = "开始运行降级您的建筑，请稍等片刻",
                ["AlreadyProcess"] = "已经有一个线程正在运行，请稍等片刻",

                ["UpgradeNotEnoughItems"] = "没有可以升级的建筑。您还需要: \n{0}",
                ["UpgradeNotEnoughItemsSuccess"] = "<color=#FF1919>{0}</color> 个建筑成功升级了。有些建筑无法升级，您还需要: \n{1}",

                ["NotUpgraded"] = "没有可以升级的建筑",
                ["NotDowngraded"] = "没有可以降级的建筑",
                ["FinishedUpgrade"] = "<color=#FF1919>{0}</color> 个建筑成功升级了",
                ["FinishedDowngrade"] = "<color=#FF1919>{0}</color> 个建筑成功降级了"
            }, this, "zh-CN");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "<color=#FF1919>Ви не маєте дозволу на використання цієї команди.</color>",
                ["UnknownGrade"] = "<color=#FF1919>Невідоме поліпшення.</color>",
                ["UnknownCategory"] = "<color=#FF1919>Невідома категорія.</color> Доступні категорії: <color=#009EFF>{0}</color>",
                ["NotLookingAt"] = "<color=#FF1919>Ви не дивитеся на будівельний блок.</color>",
                ["RaidBlocked"] = "<color=#FF1919>Ви не можете цього робити, поки рейд заблоковано.</color>.",
                ["CombatBlocked"] = "<color=#FF1919>Ви не можете цього робити, коли бій заблоковано.</color>.",
                ["OnCooldown"] = "Ви повинні почекати <color=#FF1919>{0}</color> секунд, перш ніж ви зможете використовувати цю команду.",
                ["BuildingBlocked"] = "Ви не можете використовувати цю команду, якщо у вас немає привілеїв будівництва.",

                ["MissingItemsFormat"] = "* <color=#FF1919>{0}</color> x{1}",
                ["StartUpgrade"] = "Почніть запуск оновлення, зачекайте.",
                ["StartDowngrade"] = "Почніть роботу з пониженням, зачекайте.",
                ["AlreadyProcess"] = "Процес уже запущений, зачекайте.",

                ["UpgradeNotEnoughItems"] = "Жодна з будівель не була модернізована. Ви пропали: \n{0}",
                ["UpgradeNotEnoughItemsSuccess"] = "<color=#FF1919>{0}</color> будівельні блоки були модернізовані. Деякі будівлі неможливо покращити, ви пропали: \n{1}",

                ["NotUpgraded"] = "Жодна з будівель не була модернізована.",
                ["NotDowngraded"] = "Жодна з будівель не була понижена.",
                ["FinishedUpgrade"] = "<color=#FF1919>{0}</color> будівельні блоки були модернізовані.",
                ["FinishedDowngrade"] = "<color=#FF1919>{0}</color> будівельні блоки були знижені."
            }, this, "uk");
        }

        #endregion LanguageFile
    }
}

// --- End of file: BuildingGrades.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/buoyant-helicopter-crates ---
// --- Original File Path: B/BuoyantHelicopterCrates/BuoyantHelicopterCrates.cs ---

using UnityEngine;
using Rust;
using System;

namespace Oxide.Plugins
{
    [Info("Buoyant Helicopter Crates", "Tacman", "1.1.2")]
    [Description("Makes helicopter crates buoyant")]
    class BuoyantHelicopterCrates : RustPlugin
    {
        #region Config
        public PluginConfig _config;

        public PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                DetectionRate = 1,
            };
        }

        public class PluginConfig
        {
            public int DetectionRate;
        }
        #endregion

        #region Oxide
        protected override void LoadDefaultConfig() => Config.WriteObject(GetDefaultConfig(), true);

        void Init()
        {
            _config = Config.ReadObject<PluginConfig>();
        }

        void OnEntitySpawned(BaseEntity entity)
        {
            if (entity == null || entity.ShortPrefabName != "heli_crate") return;

            NextTick(() =>
            {
                StorageContainer crate = entity.GetComponent<StorageContainer>();
                if (crate == null) return;

                Rigidbody rb = crate.GetComponent<Rigidbody>();
                if (rb == null) rb = crate.gameObject.AddComponent<Rigidbody>();
                rb.useGravity = true;
                rb.collisionDetectionMode = CollisionDetectionMode.Continuous;
                rb.mass = 2f;
                rb.interpolation = RigidbodyInterpolation.Interpolate;
                rb.angularVelocity = Vector3Ex.Range(-2.75f, 2.75f);
                rb.drag = 0.5f * rb.mass;

                MakeBuoyant buoyancy = crate.GetComponent<MakeBuoyant>();
                if (buoyancy == null) buoyancy = crate.gameObject.AddComponent<MakeBuoyant>();
                buoyancy.buoyancyScale = 1;
                buoyancy.detectionRate = _config?.DetectionRate ?? 1;
            });
        }
        #endregion

        #region Classes
        class MakeBuoyant : MonoBehaviour
        {
            public float buoyancyScale;
            public int detectionRate;
            private BaseEntity _entity;

            void Awake()
            {
                _entity = GetComponent<BaseEntity>();
                if (_entity == null) Destroy(this);
            }

            void FixedUpdate()
            {
                if (_entity == null)
                {
                    Destroy(this);
                    return;
                }
                if (UnityEngine.Time.frameCount % detectionRate == 0 && WaterLevel.Factor(_entity.WorldSpaceBounds().ToBounds(), true, true) > 0.65f)
                {
                    BuoyancyComponent();
                    Destroy(this);
                }
            }

            void BuoyancyComponent()
            {
                Buoyancy buoyancy = gameObject.AddComponent<Buoyancy>();
                buoyancy.buoyancyScale = buoyancyScale;
                buoyancy.rigidBody = gameObject.GetComponent<Rigidbody>();
                buoyancy.SavePointData(true);
            }
        }
        #endregion
    }
}

// --- End of file: BuoyantHelicopterCrates.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/beds-limit ---
// --- Original File Path: B/BedsLimit/BedsLimit.cs ---

using UnityEngine;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Beds Limit", "Bruno Puccio", "1.1")]
    [Description("allows the admin to limit the amount of beds that are placed per base")]
    class BedsLimit : RustPlugin
    {
        const string perm = "bedslimit.allowed";
        private ConfigData bedsConfig;

        private class ConfigData
        {
            public int radius, maxplayers;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData bedsConfig = new ConfigData
            {
                radius = 35,
                maxplayers = 3
            };
            SaveConfig(bedsConfig);
        }

        private void LoadConfigVariables() => bedsConfig = Config.ReadObject<ConfigData>();

        void SaveConfig(ConfigData bedsConfig) => Config.WriteObject(bedsConfig, true);

        private string Lang(string key, string id, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        void Init()
        {
            permission.RegisterPermission(perm, this);
            LoadConfigVariables();
        }

        private new void LoadDefaultMessages()
        {
            //English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ValidValues"] = "valid values from:   {0}   to   {1}",
                ["DontHavePermission"] = "<color=#00ffffff>[Beds Limit]</color> You do not have permission to use this command",
                ["CurrentConfig"] = "<color=#00ffffff>[Beds Limit]</color>\n\n/bedslimit maxplayers: {0} \n/bedslimit radius: {1}",
                ["ConfigChanged"] = "{0} set to {1}",
                ["CantPlaceBed"] = "you can't place a bed here, there are too many beds around",
                ["CantGiveBed"] = "you can't share that bed, max limit reached"
            }, this);
        }



        void OnEntityBuilt(Planner plan, GameObject go)
        {
            BaseNetworkable baseNet = go.GetComponent<BaseNetworkable>();
            string shortName = baseNet.ShortPrefabName;
            if (shortName.Contains("sleepingbag") || shortName.Contains("bed"))
            {
                if (FindBedsNearby(go.GetComponent<SleepingBag>()) > bedsConfig.maxplayers)
                {
                    BasePlayer baseP = plan.GetOwnerPlayer();
                    SendReply(baseP, Lang("CantPlaceBed", baseP.UserIDString));
                    

                    if (shortName.Contains("sleepingbag"))
                        timer.Once(1f, () => { baseP.inventory.GiveItem(ItemManager.CreateByItemID(1253290621)); });
                    else
                        timer.Once(1f, () => { baseP.inventory.GiveItem(ItemManager.CreateByItemID(97409)); });

                    baseNet.Kill();
                }
            }
        }

        object CanAssignBed(SleepingBag bag, BasePlayer player, ulong targetPlayerId)
        {

            if (FindBedsNearby(0, player.transform.position, targetPlayerId) > 1)
                return null;

            if (FindBedsNearby(0, player.transform.position, player.userID) > 1 && (FindBedsNearby(bag) + 1) > bedsConfig.maxplayers)
            {
                SendReply(player, Lang("CantGiveBed", player.UserIDString));
                bag.deployerUserID = player.userID;
                return true;
            }
            return null;
        }

        int FindBedsNearby(int i, Vector3 pos, ulong targetPlayerId)
        {
            
            List<SleepingBag> list = LookForBeds(pos), finalList = new List<SleepingBag>();

            foreach (SleepingBag baseEnt in list)
            {
                bool bandera = false;
                foreach (BaseEntity baseEnt2 in finalList)
                {
                    if (baseEnt.transform.position == baseEnt2.transform.position)
                        bandera = true;
                }
                if (!bandera)
                    finalList.Add(baseEnt);
            }

            foreach (BaseEntity entityFound in finalList)
            {
                if (entityFound.GetComponent<SleepingBag>().deployerUserID == targetPlayerId)
                    i++;
            }

            return i;
        }

        int FindBedsNearby(SleepingBag bag)
        {
            List<SleepingBag> list = LookForBeds(bag.transform.position), finalList = new List<SleepingBag>();

            foreach (SleepingBag baseEnt in list)
            {
                bool bandera = false;
                foreach (BaseEntity baseEnt2 in finalList)
                {
                    if (baseEnt.transform.position == baseEnt2.transform.position || baseEnt.GetComponent<SleepingBag>().deployerUserID == baseEnt2.GetComponent<SleepingBag>().deployerUserID)
                        bandera = true;
                }
                if (!bandera)
                    finalList.Add(baseEnt);
            }

            return finalList.Count;
        }

        List<SleepingBag> LookForBeds(Vector3 pos)
        {
            List<SleepingBag> list = new List<SleepingBag>();
            Vis.Entities<SleepingBag>(pos, bedsConfig.radius, list);
            Vis.Entities<SleepingBag>(pos - new Vector3(0, bedsConfig.radius / 2, 0), bedsConfig.radius, list);
            Vis.Entities<SleepingBag>(pos + new Vector3(0, bedsConfig.radius / 2, 0), bedsConfig.radius, list);
            Vis.Entities<SleepingBag>(pos - new Vector3(0, bedsConfig.radius, 0), bedsConfig.radius, list);
            Vis.Entities<SleepingBag>(pos + new Vector3(0, bedsConfig.radius, 0), bedsConfig.radius, list);
            return list;
        }


        [ChatCommand("bedslimit")]
        void VanillaCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, perm) && player.net.connection.authLevel < 2)
            {
                SendReply(player, Lang("DontHavePermission", player.UserIDString));
                return;
            }

            if (args.Length != 2)
                SendReply(player, Lang("CurrentConfig", player.UserIDString, bedsConfig.maxplayers.ToString(), bedsConfig.radius.ToString()));


            else
            {
                switch (args[0])
                {
                    case "maxplayers":
                        int beds;
                        if ((int.TryParse(args[1], out beds)) && beds >= 1 && beds <= 20)
                        {
                            bedsConfig.maxplayers = beds;
                            SaveConfig(bedsConfig);
                            SendReply(player, Lang("ConfigChanged", player.UserIDString, "maxplayers", beds.ToString()));
                        }
                        else
                            SendReply(player, Lang("ValidValues", player.UserIDString, 1, 20));
                        break;

                    case "radius":
                        int radius;
                        if ((int.TryParse(args[1], out radius)) && radius >= 5 && radius <= 100)
                        {
                            bedsConfig.radius = radius;
                            SaveConfig(bedsConfig);
                            SendReply(player, Lang("ConfigChanged", player.UserIDString, "radius", radius.ToString()));
                        }
                        else
                            SendReply(player, Lang("ValidValues", player.UserIDString, 5, 100));
                        break;

                    default:
                        SendReply(player, Lang("CurrentConfig", player.UserIDString, bedsConfig.maxplayers.ToString(), bedsConfig.radius.ToString()));
                        break;
                }
            }
        }
    }
}

// --- End of file: BedsLimit.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/building-block-gui ---
// --- Original File Path: B/BuildingBlockGUI/BuildingBlockGUI.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Building Block GUI", "Iv Misticos", "2.0.1")]
    [Description("Displays GUI to player when he enters or leaves building block without need of Planner")]
    public class BuildingBlockGUI : RustPlugin
    {
        #region Variables

        private GameObject _controller;

        private static BuildingBlockGUI _ins;
        
        #endregion
        
        #region Configuration

        private static Configuration _config;
        
        private class Configuration
        {
            [JsonProperty(PropertyName = "Use Image")]
            public bool UseImage = false;
            
            [JsonProperty(PropertyName = "Image URL")]
            public string ImageURL = "";
            
            [JsonProperty(PropertyName = "Use GameTips")]
            public bool UseGameTips = false;
            
            [JsonProperty(PropertyName = "Check Frequency")]
            public float CheckFrequency = 0.75f;
            
            [JsonProperty(PropertyName = "Background Color")]
            public string BackgroundColor = "1.0 0.0 0.0 0.15";
            
            [JsonProperty(PropertyName = "Anchor Min")]
            public string AnchorMin = "0.35 0.11";
            
            [JsonProperty(PropertyName = "Anchor Max")]
            public string AnchorMax = "0.63 0.14";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"text", "BUILDING BLOCKED" }

            }, this);
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"text", "СТРОИТЕЛЬСТВО ЗАПРЕЩЕНО" }
            }, this, "ru");
        }

        private void OnServerInitialized()
        {
            _ins = this;
            _controller = new GameObject();
            _controller.AddComponent<BuildingController>();
        }

        private void Unload()
        {
            UnityEngine.Object.Destroy(_controller);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            BuildingController.DestroyUI(player);
        }

        #endregion

        #region Helpers

        private class BuildingController : MonoBehaviour
        {
            private static List<BasePlayer> _activeUI = new List<BasePlayer>();
            
            private void OnDestroy()
            {
                for (var i = _activeUI.Count - 1; i >= 0; i--)
                {
                    DestroyUI(_activeUI[i]);
                }
            }

            private void Awake()
            {
                InvokeRepeating(nameof(OnControllerTick), _config.CheckFrequency, _config.CheckFrequency);
            }

            private void OnControllerTick()
            {
                for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var player = BasePlayer.activePlayerList[i];
                    if (player == null || player.IsNpc)
                        continue;

                    if (player.IsBuildingBlocked())
                    {
                        CreateUI(player);
                    }
                    else
                    {
                        DestroyUI(player);
                    }
                }
            }

            private static void CreateUI(BasePlayer player)
            {
                if (_activeUI.Contains(player))
                    return;
                
                if (_config.UseGameTips)
                {
                    player.SendConsoleCommand("gametip.showgametip", GetMsg("text", player.UserIDString));
                }
                else
                {
                    var container = new CuiElementContainer();
                    var background = container.Add(new CuiPanel
                    {
                        Image = {Color = _config.BackgroundColor},
                        RectTransform = {AnchorMin = _config.AnchorMin, AnchorMax = _config.AnchorMax}
                    }, "Hud", "BuildingBlockGUI.Background");

                    container.Add(_config.UseImage
                        ? new CuiElement
                        {
                            Parent = background,
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Url = _config.ImageURL,
                                    Sprite = "assets/content/textures/generic/fulltransparent.tga"
                                },
                                new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                            }
                        }
                        : new CuiElement
                        {
                            Parent = background,
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = GetMsg("text", player.UserIDString), FontSize = 15,
                                    Align = TextAnchor.MiddleCenter
                                },
                                new CuiRectTransformComponent {AnchorMin = "0.0 0.0", AnchorMax = "1.0 1.0"}
                            }
                        });

                    CuiHelper.AddUi(player, container);
                }

                _activeUI.Add(player);
            }

            public static void DestroyUI(BasePlayer player)
            {
                if (!_activeUI.Contains(player))
                    return;

                if (_config.UseGameTips) player.SendConsoleCommand("gametip.hidegametip");
                else CuiHelper.DestroyUi(player, "BuildingBlockGUI.Background");
                _activeUI.Remove(player);
            }
        }
        
        private static string GetMsg(string key, string userId = null) => _ins.lang.GetMessage(key, _ins, userId);

        #endregion
    }
}

// --- End of file: BuildingBlockGUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/barrel-events ---
// --- Original File Path: B/BarrelEvent/BarrelEvent.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Barrel Event", "Orange", "1.1.0")]
    [Description("Special actions on barrel destroying")]
    public class BarrelEvent : RustPlugin
    {
        #region Oxide Hooks

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info?.InitiatorPlayer != null)
            {
                CheckDeath(entity);
            }
        }

        #endregion

        #region Core

        private void CheckDeath(BaseEntity entity)
        {
            var name = entity.ShortPrefabName;
            
            if (!name.Contains("barrel") || name.Contains("oil"))
            {
                return;  
            }

            foreach (var value in config.events)
            {
                var random = Core.Random.Range(0, 101);
                if (random > value.chance) {continue;}

                switch (value.type)
                {
                        case "Spawn":
                            Spawn(value.range, value.param, entity.transform.position);
                            break;
                        
                        
                        case "Damage":
                            Damage(value.range, Convert.ToInt32(value.param), entity.transform.position);
                            break;
                        
                        default:
                            return;
                }
                
                if (config.single) {break;}
            }
        }
        
        private void Spawn(float range, string prefab, Vector3 position)
        {
            var entity = GameManager.server.CreateEntity(prefab, position + new Vector3(Core.Random.Range(-range, range), 0, Core.Random.Range(-range, range)));
            if (entity == null) {return;}

            var plane = entity.GetComponent<CargoPlane>();
            if (plane != null)
            {
                plane.InitDropPosition(position);
                plane.secondsToTake = config.cargoSpeed;
                plane.transform.position = new Vector3(plane.transform.position.x, config.cargoHeight, plane.transform.position.z);
                plane.TransformChanged();
            }
            
            entity.Spawn();
        }

        private void Damage(float radius, int damage, Vector3 position)
        {
            var list = new List<BaseCombatEntity>();
            Vis.Entities(position, radius, list);
            
            foreach (var entity in list)
            {
                entity.Hurt(damage);
            }
        }

        #endregion
        
        #region Configuration
        
        private static ConfigData config;
        
        private class ConfigData
        {
            [JsonProperty(PropertyName = "1. Run only 1 event at action")]
            public bool single;

            [JsonProperty(PropertyName = "2.Cargo plane speed")]
            public float cargoSpeed;

            [JsonProperty(PropertyName = "3.Cargo plane height")]
            public float cargoHeight;
            
            [JsonProperty(PropertyName = "Event list:")]
            public List<Event> events = new List<Event>();

            public class Event
            {
                [JsonProperty(PropertyName = "1. Chance")]
                public int chance;

                [JsonProperty(PropertyName = "2. Type")]
                public string type;
                
                [JsonProperty(PropertyName = "3. Parameter")]
                public string param;

                [JsonProperty(PropertyName = "4. Range")]
                public float range;
            }
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData 
            {
                single = false,
                cargoSpeed = 10,
                cargoHeight = 700f,
                events = new List<ConfigData.Event>
                {
                    new ConfigData.Event
                    {
                        type = "Spawn",
                        param = "assets/rust.ai/agents/bear/bear.prefab",
                        chance = 10,
                        range = 0f
                    },
                    new ConfigData.Event
                    {
                        type = "Spawn",
                        param = "assets/prefabs/npc/scientist/scientist.prefab",
                        chance = 10,
                        range = 0f
                    },
                    new ConfigData.Event
                    {
                        type = "Damage",
                        param = "30",
                        chance = 10,
                        range = 5f
                    }
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
        
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        
        #endregion
    }
}

// --- End of file: BarrelEvent.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/building-health ---
// --- Original File Path: B/BuildingHealth/BuildingHealth.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Building Health", "Judess69er/Orange", "1.1.3")]
    [Description("Allows you to change the maximum health of buildings")]
    public class BuildingHealth : RustPlugin
    {
        #region Vars

        private Dictionary<ulong, float> data = new Dictionary<ulong, float>();
        private List<string> changed = new List<string>();
        private static readonly string[] buildingBlocks = new string[]
        {
            "roof",
            "roof.triangle",
            "block.stair.ushape",
            "block.stair.lshape",
            "wall",
            "wall.low",
            "wall.half",
            "wall.frame",
            "wall.window",
            "wall.doorway",
            "floor",
            "floor.triangle",
            "floor.frame",
            "foundation",
            "foundation.steps",
            "foundation.triangle",
            "ramp",
            "floor.triangle.frame",
            "block.stair.spiral.triangle",
            "block.stair.spiral",
            "block.stair.lshape"
        };

        #endregion

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            Update(false);
        }

        private void Unload()
        {
            Update(true);
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            CheckEntity(go.ToBaseEntity());
        }

        #endregion

        #region Helpers

        private void Update(bool unload)
        {
            UpdateDB();
            ResetMultiplier(unload);
            ResetHP();
        }

        private void CheckEntity(BaseEntity entity)
        {
            if (entity == null) { return; }
            var name = entity.ShortPrefabName;
            if (changed.Contains(name)) { return; }

            var percent = 0;
            if (config.percents.TryGetValue(entity.ShortPrefabName, out percent) == false || percent == 0)
            {
                return;
            }

            var block = entity.GetComponent<BuildingBlock>();
            if (block == null) { return; }
            var hp = block.health / block.MaxHealth();
            block.blockDefinition.healthMultiplier = percent / 100f;
            block.health = hp * block.MaxHealth();
            changed.Add(name);
        }

        private void UpdateDB()
        {
            data.Clear();

            foreach (var block in UnityEngine.Object.FindObjectsOfType<BuildingBlock>())
            {
                var id = block.net.ID.Value;
                var hp = block.health / block.MaxHealth();
                data[id] = hp;
            }
        }

        private void ResetHP()
        {
            foreach (var block in UnityEngine.Object.FindObjectsOfType<BuildingBlock>())
            {
                var id = block.net.ID.Value;
                if (!data.ContainsKey(id)) { return; }
                block.health = data[id] * block.MaxHealth();
            }
        }

        private void ResetMultiplier(bool reset = false)
        {
            foreach (var block in UnityEngine.Object.FindObjectsOfType<BuildingBlock>())
            {
                var name = block.ShortPrefabName;
                var percent = 0;
                if (config.percents.TryGetValue(block.ShortPrefabName, out percent) == false || percent == 0)
                {
                    continue;
                }

                var multiplier = reset ? 1f : percent / 100f;
                block.blockDefinition.healthMultiplier = multiplier;
                if (!changed.Contains(name)) { changed.Add(name); }
            }
        }

        #endregion

        #region Configuration | 24.05.2020

        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Building health in percents")]
            public Dictionary<string, int> percents = new Dictionary<string, int>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }

                LoadDefaultConfig();
                return;
            }

            ValidateConfig();
            SaveConfig();
        }

        private static void ValidateConfig()
        {
            if (ConVar.Server.hostname.Contains("[DEBUG]") == true)
            {
                config = new ConfigData();
            }

            foreach (var value in buildingBlocks)
            {
                if (config.percents.ContainsKey(value) == false)
                {
                    config.percents.Add(value, 200);
                }
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: BuildingHealth.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bed-welcomer ---
// --- Original File Path: B/BedWelcomer/BedWelcomer.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Facepunch;

#region Changelogs and ToDo
/**********************************************************************
 * 
 * v1.0.1   :   Changed cfg for language message
 * v1.0.2   :   Excempt for softcore bags in bandit and outpost
 * v1.0.3   :   Added towels and beds
 * v1.0.4   :   Added check for campervans
 * 
 **********************************************************************/
#endregion

namespace Oxide.Plugins
{
    [Info("Bed Welcomer", "Krungh Crow", "1.0.4")]
    [Description("Changes the default text on bags towels beds and campervans")]

    class BedWelcomer : RustPlugin
    {
        #region LanguageAPI

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BagText"] = "Welcome to our server",
            }, this);
        }

        #endregion

        #region Hooks

        private void OnEntitySpawned(SleepingBag bag)
        {
            if (bag.niceName == "Unnamed Bag" || bag.niceName == "Unnamed Towel" || bag.niceName == "Bed" || bag is SleepingBagCamper)
            {
                bag.niceName = lang.GetMessage("BagText", this);
            }
            return;
        }

        #endregion
    }
}

// --- End of file: BedWelcomer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/beds-cooldowns ---
// --- Original File Path: B/BedsCooldowns/BedsCooldowns.cs ---

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Beds Cooldowns", "Orange", "1.1.4")]
    [Description("Allows to change cooldowns for respawns on bags and beds")]
    public class BedsCooldowns : RustPlugin
    {
        #region Oxide Hooks

        private void Init()
        {
            foreach (var value in config.list)
            {
                permission.RegisterPermission(value.perm, this);
            }
        }

        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList.ToList())
            {
                OnPlayerConnected(player);
            }
        }

        private void OnEntitySpawned(SleepingBag entity)
        {
            var settings = GetSettings(entity.OwnerID.ToString());
            SetCooldown(entity, settings);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            CheckPlayer(player);
        }

        #endregion

        #region Core

        private void CheckPlayer(BasePlayer player)
        {
            var settings = GetSettings(player.UserIDString);
            if (settings == null) {return;}
            ServerMgr.Instance.StartCoroutine(CheckBags(player.userID, settings));
        }
        
        private void SetCooldown(SleepingBag entity, SettingsEntry info)
        {
            if (info == null) {return;}

            if (entity.ShortPrefabName.Contains("bed"))
            {
                entity.secondsBetweenReuses = info.bed;
                entity.unlockTime = info.unlockTimeBed + UnityEngine.Time.realtimeSinceStartup;
            }
            else
            {
                entity.secondsBetweenReuses = info.bag;
                entity.unlockTime = info.unlockTimeBag + UnityEngine.Time.realtimeSinceStartup;
            }
            
            entity.SendNetworkUpdate();
        }

        private SettingsEntry GetSettings(string playerID)
        {
            var num = -1;
            var info = (SettingsEntry) null;

            foreach (var value in config.list)
            {
                if (permission.UserHasPermission(playerID, value.perm))
                {
                    var priority = value.priority;
                    if (priority > num)
                    {
                        num = priority;
                        info = value;
                    }
                }
            }

            return info;
        }

        private IEnumerator CheckBags(ulong playerID, SettingsEntry settings)
        {
            foreach (var entity in SleepingBag.sleepingBags)
            {
                if (entity.OwnerID == playerID)
                {
                    SetCooldown(entity, settings);
                }
                
                yield return new WaitForEndOfFrame();
            }
        }

        #endregion
        
        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "List")]
            public List<SettingsEntry> list = new List<SettingsEntry>();
        }
        
        private class SettingsEntry
        {
            [JsonProperty(PropertyName = "Permission")]
            public string perm;
            
            [JsonProperty(PropertyName = "Priority")]
            public int priority;
                
            [JsonProperty(PropertyName = "Sleeping bag cooldown")]
            public float bag;
                
            [JsonProperty(PropertyName = "Bed cooldown")]
            public float bed;

            [JsonProperty(PropertyName = "Sleeping bag unlock time")]
            public float unlockTimeBag;

            [JsonProperty(PropertyName = "Bed unlock time")]
            public float unlockTimeBed;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                list = new List<SettingsEntry>
                {
                    new SettingsEntry
                    {
                        perm = "bedscooldowns.vip1",
                        priority = 1,
                        bag = 100,
                        bed = 100,
                        unlockTimeBag = 50,
                        unlockTimeBed = 50,
                    },
                    new SettingsEntry
                    {
                        perm = "bedscooldowns.vip2",
                        priority = 2,
                        bag = 75,
                        bed = 75,
                        unlockTimeBag = 50,
                        unlockTimeBed = 50,
                    },
                    new SettingsEntry
                    {
                        perm = "bedscooldowns.vip3",
                        priority = 3,
                        bag = 0,
                        bed = 0,
                        unlockTimeBag = 50,
                        unlockTimeBed = 50,
                    }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: BedsCooldowns.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-say ---
// --- Original File Path: B/BetterSay/BetterSay.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Better Say", "LaserHydra", "3.0.1")]
    [Description("Allows customizing the output of the Rust 'say' command")]
    public class BetterSay : RustPlugin
    {
        private Configuration _config;

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission("bettersay.use", this);
            LoadConfig();
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg?.cmd?.FullName == null || arg.cmd.FullName != "global.say")
                return null;

            BasePlayer player = arg.Player();

            if (player != null && !permission.UserHasPermission(player.UserIDString, "bettersay.use"))
            {
                arg.ReplyWith(lang.GetMessage("No Permission", this, player.UserIDString));
                return true;
            }

            if (!arg.HasArgs())
            {
                arg.ReplyWith(lang.GetMessage("Syntax Reminder", this));
                return true;
            }

            string chatOutput = _config.Format
                .Replace("{Title}", $"[#{_config.TitleColor.TrimStart('#')}]{_config.Title}[/#]")
                .Replace("{Message}", $"[#{_config.MessageColor.TrimStart('#')}]{arg.FullString}[/#]");

            string consoleOutput = _config.Format
                .Replace("{Title}", _config.Title)
                .Replace("{Message}", arg.FullString);

            Server.Broadcast(chatOutput, _config.ChatIcon);
            Puts(consoleOutput);

            return true;
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "You don't have permission to use this command.",
                ["Syntax Reminder"] = "Syntax: say <message>"
            }, this);
        }

        #endregion

        #region Configuration

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        private class Configuration
        {
            [JsonProperty("Format")]
            public string Format { get; set; } = "{Title}: {Message}";

            [JsonProperty("Title")]
            public string Title { get; set; } = "Server";

            [JsonProperty("Title Color")]
            public string TitleColor { get; set; } = "cyan";

            [JsonProperty("Message Color")]
            public string MessageColor { get; set; } = "white";

            [JsonProperty("Chat Icon (SteamID64)")]
            public ulong ChatIcon { get; set; } = 0;
        }

        #endregion
    }
}


// --- End of file: BetterSay.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/building-blocker ---
// --- Original File Path: B/BuildingBlocker/BuildingBlocker.cs ---

using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using System.Reflection;
using System.Linq;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("BuildingBlocker", "Vlad-00003", "2.4.0", ResourceId = 2456)]
    [Description("Blocks building in the building privilage zone. Deactivates raids update.")]
    //Author info:
    //E-mail: Vlad-00003@mail.ru
    //Vk: vk.com/vlad_00003

    class BuildingBlocker : RustPlugin
    {		
        #region Config setup
        private string BypassPrivilege = "buildingblocker.bypass";
        private string Prefix = "[BuildingBlocker]";
        private string PrefixColor = "#FF3047";
        private bool LadderBuilding = false;
        private bool BlockBuildings = true;
        #endregion

        #region Vars
        [PluginReference]
        Plugin NoEscape;
        private static float CupRadius = 1.9f;
        //private readonly int triggerLayer = LayerMask.GetMask("Trigger");
        Collider[] colBuffer = (Collider[])typeof(Vis).GetField("colBuffer", (BindingFlags.Static | BindingFlags.NonPublic))?.GetValue(null);
        #endregion

        #region Localization
        private string BypassPrivilageCfg = "Bypass block privilage";
        private string PrefixCfg = "Chat prefix";
        private string PrefixColorCfg = "Prefix color";
        private string LadderBuildingCfg = "Allow building ladders in the privilage zone";
        private string BlockBuildingsCfg = "Block building";
        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Building blocked"] = "Building is blocked."
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Building blocked"] = "Строительство заблокировано."
            }, this, "ru");
        }
        #endregion

        #region Config Init
        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created.");
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            bool changed = false;
            if (GetConfig(BypassPrivilageCfg, ref BypassPrivilege))
                changed = true;
            if (GetConfig(PrefixCfg, ref Prefix))
                changed = true;
            if (GetConfig(PrefixColorCfg, ref PrefixColor))
                changed = true;
            if (GetConfig(LadderBuildingCfg, ref LadderBuilding))
                changed = true;
            if (GetConfig(BlockBuildingsCfg, ref BlockBuildings))
                changed = true;
            if (changed)
                SaveConfig();
            permission.RegisterPermission(BypassPrivilege, this);
        }
        #endregion

        #region Main
        object CanBuild(Planner plan, Construction prefab)
        {
            BasePlayer player = plan.GetOwnerPlayer();
            if (!player) return null;
            var result = NoEscape?.Call("CanDo", "build", player);
            if(result is string)
            {
                return null;
            }
            object Block = BuildingBlocked(plan, prefab);
            if (Block != null && (bool)Block)
            {
                SendToChat(player, GetMsg("Building blocked", player.UserIDString));
                return false;
            }
            return null;
        }
        public object BuildingBlocked(Planner plan, Construction prefab)
        {
            BasePlayer player = plan.GetOwnerPlayer();
            if (!player) return null;
            if (permission.UserHasPermission(player.UserIDString, BypassPrivilege)) return null;
            if (LadderBuilding && prefab.fullName.Contains("ladder.wooden")) return null;
            if (!BlockBuildings && !prefab.fullName.Contains("ladder.wooden")) return null;

            var pos = player.ServerPosition;
            //pos.y += player.GetHeight();
            var targetLocation = pos + (player.eyes.BodyForward() * 4f);
            //Puts($"{targetLocation} | {player.transform.position}");

            //var entities = Pool.GetList<BaseCombatEntity>();
            //Vis.Entities(targetLocation, CupRadius, entities, triggerLayer);
            //if (entities.Count > 0)
            //{
            //    foreach (var entity in entities)
            //    {
            //        var cup = entity.GetComponentInParent<BuildingPrivlidge>();
            //        if (cup == null) continue;

            //        if (cup.IsAuthed(player))
            //        {
            //            Pool.FreeList(ref entities);
            //            return true;
            //        }
            //        else
            //        {
            //            Pool.FreeList(ref entities);
            //            return false;
            //        }
            //    }
            //}
            //Pool.FreeList(ref entities);
            //return true;
            //int entities = Physics.OverlapSphereNonAlloc(targetLocation, CupRadius, colBuffer, triggerLayer);
            /*
             * Switched to IsBuildingBlocked
             */
            //int entities = Physics.OverlapSphereNonAlloc(targetLocation, CupRadius, colBuffer, Rust.Layers.Trigger);
            //BuildingPrivlidge FoundCup = null;
            //for (var i = 0; i < entities; i++)
            //{
            //    var cup = colBuffer[i].GetComponentInParent<BuildingPrivlidge>();
            //    //if (cup == null) continue;
            //    if (cup != null && cup.Dominates(FoundCup))
            //        FoundCup = cup;
            //    //if (!cup.IsAuthed(player))
            //    //{
            //    //    return true;
            //    //}
            //    //if (!cup.authorizedPlayers.Any((ProtoBuf.PlayerNameID x) => x.userid == player.userID))
            //    //{
            //    //    return true;
            //    //}
            //}
            //if (FoundCup != null && !FoundCup.authorizedPlayers.Any((ProtoBuf.PlayerNameID x) => x.userid == player.userID))
            //    return true;
            //return null;

            return player.IsBuildingBlocked(targetLocation, new Quaternion(0, 0, 0, 0), new Bounds(Vector3.zero, Vector3.zero));
        }
        #endregion

        #region Helpers
        private void SendToChat(BasePlayer Player, string Message)
        {
            PrintToChat(Player, "<color=" + PrefixColor + ">" + Prefix + "</color> " + Message);
        }
        private bool GetConfig<T>(string Key, ref T var)
        {
            if (Config[Key] != null)
            {
                var = (T)Convert.ChangeType(Config[Key], typeof(T));
                return false;
            }
            Config[Key] = var;
            return true;
        }
        #endregion
    }
}

// --- End of file: BuildingBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/block-users ---
// --- Original File Path: B/BlockUsers/BlockUsers.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("BlockUsers", "ViolationHandler", "1.0.5")]
    [Description("A system and API for managing blocked users lists")]
    internal class BlockUsers : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Blocked Users list cache time (0 to disable)")]
            public int CacheTime = 0;

            [JsonProperty("Maximum number of blocked users (0 to disable)")]
            public int MaxBlockedUsers = 30;

            // If you are editting this from the code, make sure to use '.FromMinutes()' for 1-59 minutes, and '.FromHours()' for 1+ hours.
            [JsonProperty("Cooldown for block command in seconds (00:00:00 to disable)")]
            public TimeSpan BlockDelay = TimeSpan.FromSeconds(2);

            [JsonProperty("Use permission system")]
            public bool UsePermissions = false;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Stored Data

        private readonly Dictionary<string, HashSet<string>> reverseData = new Dictionary<string, HashSet<string>>();
        private Dictionary<string, PlayerData> blockedData;

        private static readonly DateTime Epoch = new DateTime(1970, 1, 1);

        private class PlayerData
        {
            public string Name { get; set; } = string.Empty;
            public HashSet<string> BlockedUsers { get; set; } = new HashSet<string>();
            public Dictionary<string, int> Cached { get; set; } = new Dictionary<string, int>();
            public Dictionary<string, DateTime> LastCalled { get; set; } = new Dictionary<string, DateTime>();

            public bool IsCached(string playerId)
            {
                int time;
                if (!Cached.TryGetValue(playerId, out time))
                {
                    return false;
                }

                if (time >= (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds)
                {
                    return true;
                }

                Cached.Remove(playerId);
                return false;
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, blockedData);
        }

        #endregion Stored Data

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AlreadyOnBlockedList"] = "{0} is already blocked.",
                ["CannotBlockSelf"] = "You cannot block yourself.",
				["CommandBlock"] = "block",
                ["BlockedUserAdded"] = "{0} is now blocked.",
                ["BlockedUserRemoved"] = "{0} was removed from your blocked list.",
                ["BlockedList"] = "Blocked Players {0}:\n{1}.",
                ["BlockedListFull"] = "Your blocked users list is full.",
                ["NoBlockedUsers"] = "You do not have any blocked users.",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command.",
                ["NoPlayersFound"] = "No players found with name or ID '{0}'.",
                ["NotOnBlockedList"] = "{0} not found on your blocked list.",
                ["Delay"] = "Wait {0} more seconds before using the '/{1}' command.",
                ["PlayerNotFound"] = "Player '{0}' was not found",
                ["PlayersFound"] = "Multiple players were found, please specify: {0}.",
                ["PlayersOnly"] = "Command '{0}' can only be used by players.",
                ["UsageBlockedUsers"] = "Usage /{0} <add|remove|list> <player name or id> or /{0} list."
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string permUse = "blockusers.use";

        private void Init()
        {
            AddLocalizedCommand(nameof(CommandBlock));

            permission.RegisterPermission(permUse, this);

            try
            {
                blockedData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, PlayerData>>(Name);
            }
            catch
            {
                blockedData = new Dictionary<string, PlayerData>();
            }
            foreach (KeyValuePair<string, PlayerData> data in blockedData)
            {
                foreach (string blockedId in data.Value.BlockedUsers)
                {
                    AddBlockedUserReverse(data.Key, blockedId);
                }
            }
        }

        #endregion Initialization

        #region Add/Remove Blocked Users

        private bool AddBlockedUser(string playerId, string blockedId)
        {
            if (string.IsNullOrEmpty(playerId) && string.IsNullOrEmpty(blockedId))
            {
                return false;
            }


            PlayerData playerData = GetPlayerData(playerId);
            if (playerData.BlockedUsers.Count >= config.MaxBlockedUsers || !playerData.BlockedUsers.Add(blockedId))
            {
                return false;
            }

            AddBlockedUserReverse(playerId, blockedId);
            SaveData();

            Interface.Oxide.CallHook("OnBlockedUserAdded", playerId, blockedId);
            return true;
        }

        private bool AddBlockedUser(ulong playerId, ulong blockedId)
        {
            return AddBlockedUser(playerId.ToString(), blockedId.ToString());
        }


        private void AddBlockedUserReverse(string playerId, string blockedId)
        {
            HashSet<string> blockedUsers;
            if (!reverseData.TryGetValue(blockedId, out blockedUsers))
            {
                reverseData[blockedId] = blockedUsers = new HashSet<string>();
            }

            blockedUsers.Add(playerId);
        }


        private bool RemoveBlockedUser(string playerId, string blockedId)
        {
            if (string.IsNullOrEmpty(playerId) && string.IsNullOrEmpty(blockedId))
            {
                return false;
            }
            PlayerData playerData = GetPlayerData(playerId);
            if (!playerData.BlockedUsers.Remove(blockedId))
            {
                return false;
            }

            HashSet<string> blockedUsers;
            if (reverseData.TryGetValue(blockedId, out blockedUsers))
            {
                blockedUsers.Remove(playerId);
            }

            if (config.CacheTime > 0)
            {
                playerData.Cached[blockedId] = (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds + config.CacheTime;
            }

            SaveData();

            Interface.Oxide.CallHook("OnBlockedUserRemoved", playerId, blockedId);
            return true;
        }

        private bool RemoveBlockedUser(ulong playerId, ulong blockedId)
        {
            return RemoveBlockedUser(playerId.ToString(), blockedId.ToString());
        }

        #endregion Add/Remove Blocked Users

        #region Blocked Users Checks

        private bool HasBlockedUser(string playerId, string blockedUserId)
        {
            if (!string.IsNullOrEmpty(playerId) && !string.IsNullOrEmpty(blockedUserId))
            {
                return GetPlayerData(playerId).BlockedUsers.Contains(blockedUserId);
            }

            return false;
        }

        private bool HasBlockedUser(ulong playerId, ulong blockedUserId)
        {
            return HasBlockedUser(playerId.ToString(), blockedUserId.ToString());
        }

        private bool HadBlockedUser(string playerId, string blockedUserId)
        {
            if (!string.IsNullOrEmpty(playerId) && !string.IsNullOrEmpty(blockedUserId))
            {
                PlayerData playerData = GetPlayerData(playerId);
                return playerData.BlockedUsers.Contains(blockedUserId) || playerData.IsCached(blockedUserId);
            }

            return false;
        }

        private bool HadBlockedUser(ulong playerId, ulong blockedUserId)
        {
            return HadBlockedUser(playerId.ToString(), blockedUserId.ToString());
        }

        private bool AreBlockedUsers(string playerId, string blockedUserId)
        {
            if (string.IsNullOrEmpty(playerId) || string.IsNullOrEmpty(blockedUserId))
            {
                return false;
            }

            return GetPlayerData(playerId).BlockedUsers.Contains(blockedUserId) && GetPlayerData(blockedUserId).BlockedUsers.Contains(playerId);
        }

        private bool AreBlockedUsers(ulong playerId, ulong blockedUserId)
        {
            return AreBlockedUsers(playerId.ToString(), blockedUserId.ToString());
        }

        private bool WereBlockedUsers(string playerId, string blockedUserId)
        {
            if (string.IsNullOrEmpty(playerId) && string.IsNullOrEmpty(blockedUserId))
            {
                return false;
            }

            PlayerData playerData = GetPlayerData(playerId);
            PlayerData BlockedUserData = GetPlayerData(blockedUserId);
            return (playerData.BlockedUsers.Contains(blockedUserId) || playerData.IsCached(blockedUserId)) && (BlockedUserData.BlockedUsers.Contains(playerId) || BlockedUserData.IsCached(playerId));

        }

        private bool WereBlockedUsers(ulong playerId, ulong blockedUserId)
        {
            return WereBlockedUsers(playerId.ToString(), blockedUserId.ToString());
        }

        private bool IsBlockedUser(string playerId, string blockedUserId)
        {
            if (!string.IsNullOrEmpty(playerId) && !string.IsNullOrEmpty(blockedUserId))
            {
                return GetPlayerData(blockedUserId).BlockedUsers.Contains(playerId);
            }

            return false;
        }

        private bool IsBlockedUser(ulong playerId, ulong blockedUserId)
        {
            return IsBlockedUser(playerId.ToString(), blockedUserId.ToString());
        }

        private bool WasBlockedUser(string playerId, string blockedUserId)
        {
            if (string.IsNullOrEmpty(playerId) && string.IsNullOrEmpty(blockedUserId))
            {
                return false;
            }
            PlayerData playerData = GetPlayerData(blockedUserId);
            return playerData.BlockedUsers.Contains(playerId) || playerData.IsCached(playerId);
        }

        private bool WasBlockedUser(ulong playerId, ulong blockedUserId)
        {
            return WasBlockedUser(playerId.ToString(), blockedUserId.ToString());
        }

        private int GetMaxBlockedUsers()
        {
            return config.MaxBlockedUsers;
        }

        #endregion Blocked Users Checks

        #region Blocked Users Lists

        private string[] GetBlockedUsers(string playerId)
        {
            return GetPlayerData(playerId).BlockedUsers.ToArray();
        }

        private ulong[] GetBlockedUsers(ulong playerId)
        {
            return GetPlayerData(playerId.ToString()).BlockedUsers.Select(ulong.Parse).ToArray();
        }

        private string[] GetBlockedUsersList(string playerId)
        {
            PlayerData playerData = GetPlayerData(playerId);
            List<string> players = new List<string>();

            foreach (string blockedUserId in playerData.BlockedUsers)
            {
                players.Add(GetPlayerData(blockedUserId).Name);
            }

            return players.ToArray();
        }

        private string[] GetBlockedUsersList(ulong playerId)
        {
            return GetBlockedUsersList(playerId.ToString());
        }

        private string[] IsBlockedUsersOf(string playerId)
        {
            HashSet<string> blockedUsers;
            return reverseData.TryGetValue(playerId, out blockedUsers) ? blockedUsers.ToArray() : new string[0];
        }

        private ulong[] IsBlockedUsersOf(ulong playerId)
        {
            return IsBlockedUsersOf(playerId.ToString()).Select(ulong.Parse).ToArray();
        }

        #endregion Blocked Users Lists

        #region Commands

        private void CommandBlock(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                Message(player, "PlayersOnly", command);
                return;
            }

            if (config.UsePermissions && player.HasPermission("block.use"))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length <= 0 || args.Length == 1 && !args[0].Equals("list", StringComparison.OrdinalIgnoreCase))
            {
                Message(player, "UsageBlockedUsers", command);
                return;
            }
            if(config.BlockDelay > TimeSpan.Zero) {
                var timestamp = DateTime.UtcNow;
                TimeSpan time;
                DateTime span;
                PlayerData playerData = GetPlayerData(player.Id);
                if (playerData.LastCalled.TryGetValue(player.Id, out span)){
                    time = config.BlockDelay - (timestamp - span);
                    if (time >= TimeSpan.Zero) {
                        Message(player, "Delay", $"{time.Seconds+time.Milliseconds/1000.0}", command);
                        return;
                    }
                }
                playerData.LastCalled[player.Id] = timestamp;
            }

            switch (args[0].ToLower())
            {
                case "list":
                    string[] blockedList = GetBlockedUsersList(player.Id);
                    if (blockedList.Length > 0)
                    {
                        Message(player, "BlockedList", $"{blockedList.Length}/{config.MaxBlockedUsers}", string.Join(", ", blockedList));
                    }
                    else
                    {
                        Message(player, "NoBlockedUsers");
                    }

                    return;
                case "+":
                case "add":
                    IPlayer target = FindPlayer(args[1], player);
                    if (target == null)
                    {
                        return;
                    }

                    if (player.Id == target.Id)
                    {
                        Message(player, "CannotBlockSelf");
                        return;
                    }

                    PlayerData playerData = GetPlayerData(player.Id);
                    if (playerData.BlockedUsers.Count >= config.MaxBlockedUsers)
                    {
                        Message(player, "BlockedListFull");
                        return;
                    }

                    if (playerData.BlockedUsers.Contains(target.Id))
                    {
                        Message(player, "AlreadyOnBlockedList", target.Name);
                        return;
                    }

                    AddBlockedUser(player.Id, target.Id);
                    Message(player, "BlockedUserAdded", target.Name);
                    return;
                case "-":
                case "remove":
                    string blockedUser = FindBlockedUser(args[1]);
                    if (string.IsNullOrEmpty(blockedUser))
                    {
                        Message(player, "NotOnBlockedList", args[1]);
                        return;
                    }

                    bool removed = RemoveBlockedUser(player.Id, blockedUser.ToString());
                    Message(player, removed ? "BlockedUserRemoved" : "NotOnBlockedList", args[1]);
                    return;
            }
            Message(player, "UsageBlockedUsers", command);
            return;
        }

        private void SendHelpText(object obj)
        {
            IPlayer player = players.FindPlayerByObj(obj);
            if (player != null)
            {
                Message(player, "HelpText");
            }
        }

        #endregion Commands

        #region Helpers

        private string FindBlockedUser(string nameOrId)
        {
            if (!string.IsNullOrEmpty(nameOrId))
            {
                foreach (KeyValuePair<string, PlayerData> playerData in blockedData)
                {
                    if (playerData.Key.Equals(nameOrId) || playerData.Value.Name.IndexOf(nameOrId, StringComparison.OrdinalIgnoreCase) >= 0)
                    {
                        return playerData.Key;
                    }
                }
            }
            return string.Empty;
        }

        private PlayerData GetPlayerData(string playerId)
        {
            PlayerData playerData;
            if (!blockedData.TryGetValue(playerId, out playerData))
            {
                blockedData[playerId] = playerData = new PlayerData();
            }

            IPlayer player = players.FindPlayerById(playerId);
            if (player != null)
            {
                playerData.Name = player.Name;
            }

            return playerData;
        }

        private IPlayer FindPlayer(string playerNameOrId, IPlayer player)
        {
            IPlayer[] foundPlayers = players.FindPlayers(playerNameOrId).ToArray();
            if (foundPlayers.Length > 1)
            {
                Message(player, "PlayersFound", string.Join(", ", foundPlayers.Select(p => p.Name).Take(10).ToArray()).Truncate(60));
                return null;
            }

            IPlayer target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target == null)
            {
                Message(player, "NoPlayersFound", playerNameOrId);
                return null;
            }

            return target;
        }

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}

// --- End of file: BlockUsers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/backpack-slot-item ---
// --- Original File Path: B/BackpackSlotItem/BackpackSlotItem.cs ---

// MIT License
using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Backpack Slot Item", "Lorenzo", "1.0.2")]
    [Description("Modify item allowed in backpack slot")]
    class BackpackSlotItem : CovalencePlugin
    {
        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Items allowed in Backpack slot", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> ItemsForBackpackSlot = new List<string> { "diving.tank" };
        };

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion Configuration


        private Dictionary<string, BackupInfo> backupinfo = new Dictionary<string, BackupInfo>();

        private struct BackupInfo {
            public ItemDefinition.Flag flag;
            public Wearable.OccupationSlots occupationOver;
        }

        #region Hooks
        
        private void OnServerInitialized()
        {
            foreach (string  name in _config.ItemsForBackpackSlot)
            {
                ItemDefinition item = ItemManager.FindDefinitionByPartialName(name);
                ItemModWearable component = item?.GetComponent<ItemModWearable>();

                if (item != null && component !=null && name != "parachute")
                {
                    BackupInfo info;
                    if (!backupinfo.TryGetValue(name, out info))
                    {
                        info = new BackupInfo();
                        info.flag = item.flags;
                        info.occupationOver = component.targetWearable.occupationOver;

                        // update flags
                        item.flags |= ItemDefinition.Flag.Backpack | ItemDefinition.Flag.NotAllowedInBelt;
                        component.targetWearable.occupationOver = Wearable.OccupationSlots.Back;
                        backupinfo.Add(name, info);
                    }
                }
            }
        }

        private void Unload()
        {
            foreach (var KVP in backupinfo)
            {
                ItemDefinition item = ItemManager.FindDefinitionByPartialName(KVP.Key);
                ItemModWearable component = item?.GetComponent<ItemModWearable>();

                if (item != null && component!=null && KVP.Key != "parachute")
                {
                    item.flags = KVP.Value.flag;
                    component.targetWearable.occupationOver  = KVP.Value.occupationOver;
                }
            }
        }
        #endregion Hooks

    }
}

// --- End of file: BackpackSlotItem.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/block-vehicle-push ---
// --- Original File Path: B/BlockVehiclePush/BlockVehiclePush.cs ---

﻿using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Block Vehicle Push", "Clearshot", "1.1.0")]
    [Description("Block players from pushing vehicles under certain conditions")]
    class BlockVehiclePush : CovalencePlugin
    {
        private PluginConfig _config;
        private Game.Rust.Libraries.Player _rustPlayer = Interface.Oxide.GetLibrary<Game.Rust.Libraries.Player>("Player");

        private void SendChatMsg(BasePlayer pl, string msg, string prefix = null) =>
            _rustPlayer.Message(pl, msg, prefix != null ? prefix : lang.GetMessage("ChatPrefix", this, pl.UserIDString), Convert.ToUInt64(_config.chatIconID), Array.Empty<object>());

        [PluginReference]
        private Plugin Clans, Friends;

        private object OnVehiclePush(BaseVehicle vehicle, BasePlayer pl)
        {
            if (_config.requireBuildingPrivilegeToPush && pl.IsBuildingBlocked())
            {
                if (_config.chatMessage)
                    SendChatMsg(pl, lang.GetMessage("PushBlockedBuildingPriv", this, pl.UserIDString));
                return false;
            }

            foreach (BaseVehicle.MountPointInfo mountPointInfo in vehicle.allMountPoints)
            {
                BasePlayer mounted = mountPointInfo?.mountable?.GetMounted();
                if (mounted == null) continue;

                bool blocked = true;
                if (mounted.Team != null && mounted.Team.members.Contains(pl.userID))
                    blocked = false;
                else if (_config.allowClanMemberOrAllyToPush && Clans?.Call<bool>("IsMemberOrAlly", mounted.UserIDString, pl.UserIDString) == true)
                    blocked = false;
                else if (_config.allowFriendsToPush && Friends?.Call<bool>("HasFriend", mounted.userID, pl.userID) == true)
                    blocked = false;

                if (blocked)
                {
                    if (_config.chatMessage)
                        SendChatMsg(pl, string.Format(lang.GetMessage("PushBlocked", this, pl.UserIDString), mounted.displayName));
                    return false;
                }
            }
            return null;
        }

        #region Config

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ChatPrefix"] = $"<color=#00a7fe>[{Title}]</color>",
                ["PushBlocked"] = "Push has been blocked, you have no association to <color=#00a7fe>{0}</color>!",
                ["PushBlockedBuildingPriv"] = "Push has been blocked, you have no building privilege!"
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
            Config.WriteObject(_config, true);
        }

        private class PluginConfig
        {
            public string chatIconID = "0";
            public bool requireBuildingPrivilegeToPush = false;
            public bool allowClanMemberOrAllyToPush = false;
            public bool allowFriendsToPush = false;
            public bool chatMessage = true;
        }

        #endregion
    }
}


// --- End of file: BlockVehiclePush.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-chat-ninja ---
// --- Original File Path: B/BetterChatNinja/BetterChatNinja.cs ---

//#define DEBUG

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Better Chat Ninja", "misticos", "1.0.2")]
    [Description("Hide your ranks from other players and vanish like a ninja in the chat")]
    class BetterChatNinja : CovalencePlugin
    {
        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty("Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] Commands = { "ninja", "toggle" };

            [JsonProperty("Save Preferences")]
            public bool Save = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Work with Data

        private PluginData _data = new PluginData();

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _data);

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new PluginData();
        }

        private class PluginData
        {
            [JsonProperty("Hidden")]
            public HashSet<string> Hidden = new HashSet<string>();
        }

        #endregion

        [PluginReference("BetterChat")]
        private Plugin _chat = null;

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Command: Toggle: Hidden", "You have <color=#5cb85c>hidden</color> your rank in the chat" },
                { "Command: Toggle: Shown", "Your rank will be <color=#d9534f>shown</color> in the chat" }
            }, this);
        }

        private void Init()
        {
            AddCovalenceCommand(_config.Commands, nameof(CommandToggle));

            // Unsubscribe from the save hook in case saving is disabled in configuration

            if (!_config.Save)
            {
                Unsubscribe(nameof(OnServerSave));
            }
        }

        private void Loaded()
        {
            // Only load data from the datafile when it is enabled in configuration

            if (_config.Save)
            {
                LoadData();
            }

            PullDefaultGroupProperties();
        }

        private void PullDefaultGroupProperties()
        {
            // Retry in case the plugin is not loaded

            if (_chat == null || !_chat.IsLoaded)
            {
                PrintWarning("Better Chat was not found. Please, install the plugin! Will retry in 30 seconds");
                timer.Once(30f, PullDefaultGroupProperties);
                return;
            }

            // Grab properties for the default group

            _defaultGroupProperties = _chat.Call<Dictionary<string, object>>("API_GetGroupFields",
                Interface.Oxide.Config.Options.DefaultGroups.Players);

            var title = (string)_defaultGroupProperties["Title"];
            var titleSize = (int)_defaultGroupProperties["TitleSize"];
            var titleColor = (string)_defaultGroupProperties["TitleColor"];

            titleColor = titleColor.StartsWith("#") ? titleColor.Substring(1) : titleColor;

            _defaultTitleFormatted = $"[#{(titleColor)}][+{titleSize}]{title}[/+][/#]";
            _defaultTitleHidden = (bool)_defaultGroupProperties["TitleHidden"];

            _defaultUsernameColor = _defaultGroupProperties["UsernameColor"];
            _defaultUsernameSize = _defaultGroupProperties["UsernameSize"];

            _defaultMessageColor = _defaultGroupProperties["MessageColor"];
            _defaultMessageSize = _defaultGroupProperties["MessageSize"];
            
            _defaultChatFormat = _defaultGroupProperties["ChatFormat"];
            _defaultConsoleFormat = _defaultGroupProperties["ConsoleFormat"];

#if DEBUG
            Puts($"Obtained default group properties: {JsonConvert.SerializeObject(_defaultGroupProperties)}");
#endif
        }

        private void OnServerSave()
        {
            // Save the data file
            // Hook will not be called if disabled in the configuration

            SaveData();
        }

        private void CommandToggle(IPlayer player, string command, string[] args)
        {
            if (_data.Hidden.Add(player.Id))
            {
                player.Reply(GetMsg("Command: Toggle: Hidden", player.Id));
            }
            else
            {
                _data.Hidden.Remove(player.Id);
                player.Reply(GetMsg("Command: Toggle: Shown", player.Id));
            }
        }

        private Dictionary<string, object> _defaultGroupProperties = null;
        private string _defaultTitleFormatted = null;
        private bool _defaultTitleHidden = false;
        private object _defaultUsernameColor;
        private object _defaultUsernameSize;
        private object _defaultMessageColor;
        private object _defaultMessageSize;
        private object _defaultChatFormat;
        private object _defaultConsoleFormat;

        private void OnBetterChat(Dictionary<string, object> data)
        {
            // Ignore if the default group properties have not been grabbed yet

            if (_defaultGroupProperties == null)
            {
                PrintWarning("No default group properties have been obtained, make sure Better Chat has such group configured");
                return;
            }

            // Do nothing if there is no player or if the player is not "hidden"

            var target = (IPlayer)data["Player"];
            if (target == null)
            {
                PrintWarning("Player was null, contact the developer");
                return;
            }

            if (!_data.Hidden.Contains(target.Id))
            {
#if DEBUG
                Puts("Player is NOT hidden, ignoring");
#endif
                return;
            }

#if DEBUG
            Puts($"Data prior to modification: {JsonConvert.SerializeObject(data)}");
#endif

            // Only leave the default group in titles

            var titles = (List<string>)data["Titles"];

            titles.Clear();

            if (!_defaultTitleHidden)
            {
                titles.Add(_defaultTitleFormatted);
            }

            // Change primary group to the default group

            data["PrimaryGroup"] = Interface.Oxide.Config.Options.DefaultGroups.Players;

            // Update username settings to the default group's settings

            var usernameSettings = (Dictionary<string, object>)data["UsernameSettings"];

            usernameSettings["Color"] = _defaultUsernameColor;
            usernameSettings["Size"] = _defaultUsernameSize;

            // Update message settings to the default group's settings

            var messageSettings = (Dictionary<string, object>)data["MessageSettings"];

            messageSettings["Color"] = _defaultMessageColor;
            messageSettings["Size"] = _defaultMessageSize;

            // Update format settings to the default group's settings

            var formatSettings = (Dictionary<string, object>)data["FormatSettings"];

            formatSettings["Chat"] = _defaultChatFormat;
            formatSettings["Console"] = _defaultConsoleFormat;

            // for other developers:

            // i know i could replace the dictionary for the optimization purposes
            // but if any other plugin updates it
            // it will change the group settings for all other messages
            // so I cannot use my own dictionary here
            // and would rather modify an existing one

#if DEBUG
            Puts($"Data after modification: {JsonConvert.SerializeObject(data)}");
#endif
        }

        private string GetMsg(string key, string id) => lang.GetMessage(key, this, id);
    }
}

// --- End of file: BetterChatNinja.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/building-scanner ---
// --- Original File Path: B/BuildingScanner/BuildingScanner.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Building Scanner", "Orange", "1.1.0")]
    [Description("Allow players to scan bases for boxes and etc")]
    public class BuildingScanner : RustPlugin
    {
        #region Vars

        private const string permUse = "scan.use";
        private const string permNoCD = "scan.nocooldown";

        #endregion

        #region Config
        
        private ConfigData config;
        
        private class ConfigData
        {    
            [JsonProperty(PropertyName = "Usage cooldown")]
            public int useCooldown;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                useCooldown = 600
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
        
        #region Oxide Hooks

        private void Init()
        {
            OnStart();
        }

        #endregion
        
        #region Commands

        [ChatCommand("scan")]
        private void CmdScan(BasePlayer player)
        {
            if (!HasPerm(player, permUse))
            {
                message(player, "No perm", permUse);
                return;
            }

            if (!HasPerm(player, permNoCD))
            {
                DoScan(player);
                return;
            }
            
            if (cooldowns.ContainsKey(player.userID))
            {
                var left = config.useCooldown - Passed(cooldowns[player.userID]);

                if (left > 0)
                {
                    message(player, "Cooldown", left.ToString());
                    return;
                }
            }

            if (DoScan(player))
            {
                cooldowns.TryAdd(player.userID, Now());
            }
        }
        
        #endregion

        #region Language

        private Dictionary<string, string> EN = new Dictionary<string, string>
        {
            {"No perm" , "You don't have permission ({0}) to use this command!"},
            {"Result" , "<color=cyan>Inside this building:</color>{0}"},
            {"Cooldown", "Cooldown {0} seconds..."},
            {"Output", "{0} x{1}"}
        };
        
        private void message(BasePlayer player, string key, params object[] args)
        {
            player.ChatMessage(string.Format(lang.GetMessage(key, this, player.UserIDString), args));
        }

        #endregion

        #region Helpers

        private void OnStart()
        {
            permission.RegisterPermission(permNoCD, this);
            permission.RegisterPermission(permUse, this);
            lang.RegisterMessages(EN, this);
        }

        private bool HasPerm(BasePlayer p, string perm)
        {
            return p.IsAdmin || permission.UserHasPermission(p.UserIDString, perm);
        }
        
        private Dictionary<ulong, double> cooldowns = new Dictionary<ulong, double>();
        
        private double Now()
        {
            return DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        }

        private double Passed(double value)
        {
            return Convert.ToInt32(Now() - value);
        }
        
        private bool DoScan(BasePlayer p)
        {
            RaycastHit rhit;

            if (!Physics.Raycast(p.eyes.HeadRay(), out rhit, 10f, LayerMask.GetMask("Construction"))) {return false;}
            if (rhit.GetEntity() == null) {return false;}
            var entity = rhit.GetEntity();
            var privelege = entity.GetBuildingPrivilege();
            if (privelege == null) {return false;}
            var building = privelege.GetBuilding();
            if (building == null) {return false;}
            if (!building.HasDecayEntities()) {return false;}
            var result = new Dictionary<string, List<uint>>();

            foreach (var ent in building.decayEntities)
            {
                if (ent.OwnerID == 0) continue;
                if (ent is BuildingBlock) continue;

                result.TryAdd(ent.ShortPrefabName, new List<uint>());

                if (!result[ent.ShortPrefabName].Contains(ent.net.ID))
                {
                    result[ent.ShortPrefabName].Add(ent.net.ID);
                }
            }

            var res = "\n";

            foreach (var r in result)
            {
                res += string.Format(lang.GetMessage("Object", this), r.Key, r.Value.Count) + "\n";
            }

            message(p, "Result", res);

            return true;
        }

        #endregion
    }
}

// --- End of file: BuildingScanner.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/battlefield ---
// --- Original File Path: B/Battlefield/Battlefield.cs ---

﻿using System.Collections.Generic;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Timers;
using Rust;

namespace Oxide.Plugins
{
    [Info("Event Battlefield", "Reneb", "1.0.4")]
    class Battlefield : RustPlugin
    {
        ////////////////////////////////////////////////////////////
        // Setting all fields //////////////////////////////////////
        ////////////////////////////////////////////////////////////
        [PluginReference]
        Plugin EventManager;
        [PluginReference]
        Plugin ZoneManager;

        private bool useThisEvent;
        private bool EventStarted;
        private bool Changed;

        private List<BattlefieldPlayer> BattlefieldPlayers = new List<BattlefieldPlayer>();

        private Hash<BattlefieldPlayer, string> WeaponVote = new Hash<BattlefieldPlayer, string>();
        private Hash<BattlefieldPlayer, string> GroundVote = new Hash<BattlefieldPlayer, string>();
        private string currentGround;
        private string currentWeapon;

        ////////////////////////////////////////////////////////////
        // BattlefieldPlayer class to store informations ////////////
        ////////////////////////////////////////////////////////////
        class BattlefieldPlayer : MonoBehaviour
        {
            public BasePlayer player;
            public int kills;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                enabled = false;
                kills = 0;
            }
        }


        //////////////////////////////////////////////////////////////////////////////////////
        // Oxide Hooks ///////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        void Loaded()
        {
            useThisEvent = false;
            EventStarted = false;
        }
        void OnServerInitialized()
        {
            if (EventManager == null)
            {
                Puts("Event plugin doesn't exist");
                return;
            }
            LoadVariables();
            RegisterGame();
        }
        void RegisterGame()
        {
            var success = EventManager.Call("RegisterEventGame", new object[] { EventName });
            if (success == null)
            {
                Puts("Event plugin doesn't exist");
                return;
            }
        }
        void LoadDefaultConfig()
        {
            Puts("Event Battlefield: Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        void Unload()
        {
            if (useThisEvent && EventStarted)
            {
                EventManager.Call("EndEvent", new object[] { });
                var objects = GameObject.FindObjectsOfType(typeof(BattlefieldPlayer));
                if (objects != null)
                    foreach (var gameObj in objects)
                        GameObject.Destroy(gameObj);
            }
        }



        //////////////////////////////////////////////////////////////////////////////////////
        // Configurations ////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        static string EventName = "Battlefield";

        static float EventStartHealth = 100;

        static Dictionary<string, object> EventGrounds = DefaultGrounds();
        static string DefaultGround = "shortrange";
        static string DefaultWeapon = "assault";

        static string EventMessageKill = "{0} killed {2}. ({1} kills)";
        static string EventMessageOpenBroadcast = "In Battlefield, it's a free for all, the goal is to kill as many players as possible!";
        static string EventMessageErrorNotLaunched = "Battlefield isn't currently launched";
        static string EventMessageErrorNotStarted = "You need to wait for the Battlefield to be started to use this command.";
        static string EventMessageErrorVoteNotBF = "You must be in the battlefield to vote";
        static string EventMessageVoteGroundAvaible = "︻┳═一 Battlefield Grounds Avaible 一═┳︻ Votes required for an item: {0}";
        static string EventMessageVoteGroundVotes = "{0} - {1} votes";
        static string EventMessageErrorVoteNoGround = "This battlefield ground doesn't exist.";
        static string EventMessageErrorVoteAlreadyGround = "The current ground is already {0}.";
        static string EventMessageVoteGroundVoted = "You have voted for the ground: {0}.";
        static string EventMessageVoteGroundShowVotes = "┳═一 {0} has {1} votes";
        static string EventMessageVoteGroundNew = "︻┳═一 New ground is now: {0}";
        static string EventMessageVoteWeaponNew = "︻┳═一 New weapon kit is now: {0}";
        static string EventMessageVoteWeaponShowVotes = "┳═一 {0} has {1} votes";
        static string EventMessageVoteWeaponAvaible = "︻┳═一 Avaible Weapon Kits For Current Ground 一═┳︻  Votes required for an item: {0}";
        static string EventMessageVoteWeaponVotes = "{0} - {1} votes";
        static string EventMessageErrorVoteNoKit = "This weapon kits doesn't exist in this battleground.";
        static string EventMessageErrorVoteAlreadyWeapon = "The current weapon is already {0}.";
        static string EventMessageVoteWeaponVoted = "︻┳═一 You have voted for the weapon: {0}.";

        static int TokensAddKill = 1;
        static int EventVotePercent = 60;


        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        private void LoadConfigVariables()
        {
            CheckCfg<string>("Battlefield - Event - Name", ref EventName);
            CheckCfgFloat("Battlefield - Start - Health", ref EventStartHealth);

            CheckCfg<string>("Messages - Kill", ref EventMessageKill);
            CheckCfg<string>("Messages - Open Broadcast", ref EventMessageOpenBroadcast);
            CheckCfg<string>("Messages - Error - Not Selected", ref EventMessageErrorNotLaunched);
            CheckCfg<string>("Messages - Error - Not Started", ref EventMessageErrorNotStarted);
            CheckCfg<string>("Messages - Error - Not joined", ref EventMessageErrorVoteNotBF);
            CheckCfg<string>("Messages - Vote - Grounds - Show Avaible Title", ref EventMessageVoteGroundAvaible);
            CheckCfg<string>("Messages - Vote - Grounds - Show Avaible List", ref EventMessageVoteGroundVotes);
            CheckCfg<string>("Messages - Error - Vote - Ground Doesnt Exist", ref EventMessageErrorVoteNoGround);
            CheckCfg<string>("Messages - Error - Vote - Ground Already This One", ref EventMessageErrorVoteAlreadyGround);
            CheckCfg<string>("Messages - Vote - Grounds - Voted", ref EventMessageVoteGroundVoted);
            CheckCfg<string>("Messages - Vote - Grounds - Show Votes", ref EventMessageVoteGroundShowVotes);
            CheckCfg<string>("Messages - Vote - Grounds - New", ref EventMessageVoteGroundNew);
            CheckCfg<string>("Messages - Vote - Weapons - New", ref EventMessageVoteWeaponNew);
            CheckCfg<string>("Messages - Vote - Weapons - Show Votes", ref EventMessageVoteWeaponShowVotes);
            CheckCfg<string>("Messages - Vote - Weapons - Show Avaible Title", ref EventMessageVoteWeaponAvaible);
            CheckCfg<string>("Messages - Vote - Weapons - Show Avaible List", ref EventMessageVoteWeaponVotes);
            CheckCfg<string>("Messages - Vote - Weapons - Voted", ref EventMessageVoteWeaponVoted);
            CheckCfg<string>("Messages - Error - Vote - Weapon Doesnt Exist", ref EventMessageErrorVoteNoKit);
            CheckCfg<string>("Messages - Error - Vote - Weapon Already This One", ref EventMessageErrorVoteAlreadyWeapon);

            CheckCfg<Dictionary<string, object>>("Battlefield - Grounds", ref EventGrounds);

            CheckCfg<string>("Battlefield - Default Ground", ref DefaultGround);
            CheckCfg<string>("Battlefield - Default Weapon Kit", ref DefaultWeapon);
            CheckCfg<int>("Battlefield - Vote - % needed to win", ref EventVotePercent);
            
            CheckCfg<int>("Tokens - Per Kill", ref TokensAddKill);

            currentWeapon = DefaultWeapon;
            currentGround = DefaultGround;

        }
        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }
        static Dictionary<string,object> DefaultGrounds()
        {
            var grounds = new Dictionary<string, object>();

            var ground1 = new Dictionary<string, object>();
            var ground1kit = new List<string>();
            ground1kit.Add("pistols");
            ground1kit.Add("assault");
            ground1.Add("kits", ground1kit);
            ground1.Add("zone", "BattlefieldGround1");
            ground1.Add("spawnfile", "shortrangespawnfile");
                 
            var ground2 = new Dictionary<string, object>();
            var ground2kit = new List<string>();
            ground2kit.Add("sniper");
            ground2kit.Add("pistols");
            ground2.Add("kits", ground2kit);
            ground2.Add("zone", "BattlefieldGround2");
            ground2.Add("spawnfile", "longrangespawnfile");
             
            grounds.Add("shortrange", ground1);
            grounds.Add("longrange", ground2);

            return grounds;
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        object GetEventConfig(string configname)
        {
            if (!useThisEvent) return null;
            if (Config[configname] == null) return null;
            return Config[configname];
        }
         
        //////////////////////////////////////////////////////////////////////////////////////
        // Beginning Of Event Manager Hooks //////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        void OnSelectEventGamePost(string name)
        {
            if (EventName == name)
            {
                useThisEvent = true;
                currentWeapon = DefaultWeapon;
                currentGround = DefaultGround;
                ResetVotes();
                var currentbfdata = EventGrounds[currentGround] as Dictionary<string, object>;
                if (currentbfdata["spawnfile"] != null && currentbfdata["spawnfile"].ToString() != "")
                    EventManager.Call("SelectSpawnfile", new object[] { currentbfdata["spawnfile"].ToString() });
            }
            else
                useThisEvent = false;
        }
        void OnEventPlayerSpawn(BasePlayer player)
        {
            if (useThisEvent && EventStarted)
            {
                player.inventory.Strip();
                EventManager.Call("GivePlayerKit", new object[] { player, currentWeapon });
                player.health = EventStartHealth;
            }
        }
        object OnSelectSpawnFile(string name)
        {
            if (useThisEvent)
            {
                return true;
            }
            return null;
        }
        object OnSelectKit(string kitname)
        {
            if (useThisEvent)
            {
                SetWeapon(kitname);
                return true;
            }
            return null;
        }
        object OnEventOpenPost()
        {
            if (useThisEvent)
                EventManager.Call("BroadcastEvent", new object[] { EventMessageOpenBroadcast });
            return null;
        }
        object OnEventEndPost()
        {
            if (useThisEvent)
            {
                EventStarted = false;
                BattlefieldPlayers.Clear();
            }
            return null;
        }
        object OnRequestZoneName()
        {
            if(useThisEvent)
            {
                var eventgrounddata = EventGrounds[currentGround] as Dictionary<string, object>;
                return eventgrounddata["zone"].ToString();
            }
            return null;
        }
        object OnEventStartPre()
        {
            if (useThisEvent)
            {
                EventStarted = true;
            }
            return null;
        }
        object OnEventJoinPost(BasePlayer player)
        {
            if (useThisEvent)
            {
                if (player.GetComponent<BattlefieldPlayer>())
                    GameObject.Destroy(player.GetComponent<BattlefieldPlayer>());
                BattlefieldPlayers.Add(player.gameObject.AddComponent<BattlefieldPlayer>());
            }
            return null;
        }
        object OnEventLeavePost(BasePlayer player)
        {
            if (useThisEvent)
            {
                if (player.GetComponent<BattlefieldPlayer>())
                {
                    BattlefieldPlayers.Remove(player.GetComponent<BattlefieldPlayer>());
                    GameObject.Destroy(player.GetComponent<BattlefieldPlayer>());
                }
            }
            return null;
        }

        void OnEventPlayerDeath(BasePlayer victim, HitInfo hitinfo)
        {
            if (useThisEvent)
            {
                if (hitinfo.Initiator != null)
                {
                    BasePlayer attacker = hitinfo.Initiator.ToPlayer();
                    if (attacker != null)
                    {
                        if (attacker != victim)
                        {
                            AddKill(attacker, victim);
                        }
                    }
                }
            }
            return;
        }
        //////////////////////////////////////////////////////////////////////////////////////
        // End Of Event Manager Hooks ////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        void AddKill(BasePlayer player, BasePlayer victim)
        {
            if (!player.GetComponent<BattlefieldPlayer>())
                return;

            player.GetComponent<BattlefieldPlayer>().kills++;
            EventManager.Call("AddTokens", player.userID.ToString(), TokensAddKill);
            EventManager.Call("BroadcastEvent", string.Format(EventMessageKill, player.displayName, player.GetComponent<BattlefieldPlayer>().kills.ToString(), victim.displayName));
        }

        int GetGroundVotes(string groundname)
        {
            int groundvote = 0;
            foreach(KeyValuePair<BattlefieldPlayer, string> pair in GroundVote)
            {
                if (pair.Key == null) continue;
                if (pair.Value == groundname)
                    groundvote++;
            }
            return groundvote;
        }
        int GetWeaponVotes(string weaponname)
        {
            int weaponvote = 0;
            foreach (KeyValuePair<BattlefieldPlayer, string> pair in WeaponVote)
            {
                if (pair.Key == null) continue;
                if (pair.Value == weaponname)
                    weaponvote++;
            }
            return weaponvote;
        }
        int EventPlayersCount()
        {
            int plcount = 0;
            foreach (BattlefieldPlayer bfplayer in BattlefieldPlayers)
            {
                plcount++;
            }
            return plcount;
        }
        int VotePlayersNeeded() { return (int)Math.Ceiling( (decimal)(EventPlayersCount() * EventVotePercent / 100) ); }
        void ResetVotes()
        {
            GroundVote.Clear();
            WeaponVote.Clear();
        }


        bool hasAccess(BasePlayer player)
        {
            if (player.net.connection.authLevel < 1)
            {
                return false;
            }
            return true;
        }
        
        [ChatCommand("ground")]
        void cmdChatGround(BasePlayer player, string command, string[] args)
        {
            if(!useThisEvent)
            {
                SendReply(player, EventMessageErrorNotLaunched);
                return;
            }
            
            if (!EventStarted)
            {
                SendReply(player, EventMessageErrorNotStarted);
                return;
            }
            BattlefieldPlayer bfplayer = player.GetComponent<BattlefieldPlayer>();
            
            if (bfplayer == null && !hasAccess(player))
            {
                SendReply(player, EventMessageErrorVoteNotBF);
                return;
            }
            if (args.Length == 0)
            {
                SendReply(player, string.Format(EventMessageVoteGroundAvaible, VotePlayersNeeded().ToString()));
                foreach (KeyValuePair<string,object> pair in EventGrounds)
                {
                    SendReply(player, string.Format(EventMessageVoteGroundVotes, pair.Key, GetGroundVotes(pair.Key).ToString()));
                }
                return;
            }
            string voteground = args[0];
            if(!EventGrounds.ContainsKey(voteground))
            {
                SendReply(player, EventMessageErrorVoteNoGround);
                return;
            }
            if (voteground == currentGround)
            {
                SendReply(player, string.Format(EventMessageErrorVoteAlreadyGround, currentGround));
                return;
            }

            if(hasAccess(player))
            {
                SetGround(voteground);
                return;
            }

            SendReply(player, string.Format(EventMessageVoteGroundVoted, voteground));
            if (GroundVote[bfplayer] == voteground)
                return;
            GroundVote[bfplayer] = voteground;
            CheckGroundVotes();
        }
        void CheckGroundVotes()
        {
            int votesneeded = VotePlayersNeeded();
            var votes = new Hash<string, int>();
            foreach(KeyValuePair<BattlefieldPlayer, string> pair in GroundVote)
            {
                votes[pair.Value]++;
                if(votes[pair.Value] >= votesneeded)
                {
                    SetGround(pair.Value);
                    return;
                }
            }
            foreach (KeyValuePair<string, int> pair in votes)
            {
                EventManager.Call("BroadcastEvent", string.Format(EventMessageVoteGroundShowVotes, pair.Key, pair.Value.ToString()));
            }
        }
        void SetGround(string newGround)
        {
            var eventgrounddata = EventGrounds[newGround] as Dictionary<string, object>;
            if (eventgrounddata == null) { EventManager.Call("BroadcastToChat", string.Format("Error while setting new ground: {0}. data doesn't exist. WTF?", newGround)); return; }
            if (eventgrounddata["spawnfile"] == null) { EventManager.Call("BroadcastToChat", string.Format("Error while setting new ground: {0}. spawnfile isn't set", newGround)); return; }

            var newkit = currentWeapon;
            var eventgroundkits = eventgrounddata["kits"] as List<object>;
            if (!eventgroundkits.Contains(newkit))
            {
                newkit = (string)eventgroundkits[0];
            }
            if(newkit == null) { EventManager.Call("BroadcastToChat", string.Format("Error while setting new ground: {0}. no kits were found", newGround)); return; }

            object success = EventManager.Call("SelectSpawnfile", eventgrounddata["spawnfile"].ToString());
            if(success is string)
            {
                EventManager.Call("BroadcastToChat", string.Format("Error while setting new ground: {0}. {1}", newGround, success.ToString()));
                return;
            }

            EventManager.Call("BroadcastEvent", string.Format(EventMessageVoteGroundNew, newGround));
            
            var oldzone = currentGround;
            currentGround = newGround;
            Debug.Log(oldzone);
            Debug.Log(currentGround);
            SetWeapon(newkit);
            foreach (BattlefieldPlayer bfplayer in BattlefieldPlayers)
            {
                bfplayer.player.Die();
                ZoneManager?.Call("RemovePlayerFromZoneKeepinlist", oldzone, bfplayer.player);                
            }
            GroundVote.Clear();
        }
        void SetWeapon(string newWeapon)
        {
            EventManager.Call("BroadcastEvent", string.Format(EventMessageVoteWeaponNew, newWeapon));
            currentWeapon = newWeapon;
            foreach (BattlefieldPlayer bfplayer in BattlefieldPlayers)
            {
                OnEventPlayerSpawn(bfplayer.player);
            }
            WeaponVote.Clear();
        }
        void CheckWeaponVotes()
        {
            int votesneeded = VotePlayersNeeded();
            var votes = new Hash<string, int>();
            foreach (KeyValuePair<BattlefieldPlayer, string> pair in WeaponVote)
            {
                votes[pair.Value]++;
                if (votes[pair.Value] >= votesneeded)
                {
                    SetWeapon(pair.Value);
                    return;
                }
            }
            foreach (KeyValuePair<string, int> pair in votes)
            {
                EventManager.Call("BroadcastEvent", string.Format(EventMessageVoteWeaponShowVotes, pair.Key, pair.Value.ToString()));
            }
        }
        [ChatCommand("weapon")]
        void cmdChatWeapon(BasePlayer player, string command, string[] args)
        {
            if (!useThisEvent)
            {
                SendReply(player, EventMessageErrorNotLaunched);
                return;
            }
            if (!EventStarted)
            {
                SendReply(player, EventMessageErrorNotStarted);
                return;
            }
            BattlefieldPlayer bfplayer = player.GetComponent<BattlefieldPlayer>();
            if (bfplayer == null && !hasAccess(player))
            {
                SendReply(player, EventMessageErrorVoteNotBF);
                return;
            }
            var eventgrounddata = EventGrounds[currentGround] as Dictionary<string, object>;
            var eventgroundkits = eventgrounddata["kits"] as List<object>;
            if (args.Length == 0)
            {
                SendReply(player, string.Format(EventMessageVoteWeaponAvaible, VotePlayersNeeded().ToString()));
                foreach (string kitname in eventgroundkits)
                {
                    SendReply(player, string.Format(EventMessageVoteWeaponVotes, kitname, GetWeaponVotes(kitname).ToString()));
                }
                return;
            }
            string voteweap = args[0];
            
            if (!eventgroundkits.Contains(voteweap))
            {
                SendReply(player, EventMessageErrorVoteNoKit);
                return;
            }

            if(voteweap == currentWeapon)
            {
                SendReply(player, string.Format(EventMessageErrorVoteAlreadyWeapon, currentWeapon));
                return;
            }

            if (hasAccess(player))
            {
                SetWeapon(voteweap);
                return;
            }

            SendReply(player, string.Format(EventMessageVoteWeaponVoted, voteweap));
            if (WeaponVote[bfplayer] == voteweap)
                return;
            WeaponVote[bfplayer] = voteweap;
            CheckWeaponVotes();
        }
    }
}

// --- End of file: Battlefield.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/blood-bags ---
// --- Original File Path: B/BloodBags/BloodBags.cs ---

﻿using Network;
using Newtonsoft.Json;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/*
 * Rewritten from scratch and maintained to present by VisEntities
 * Originally created by Default, up to version 1.8.0
 */

namespace Oxide.Plugins
{
    [Info("Blood Bags", "VisEntities", "2.3.0")]
    [Description("Craft and use blood bags to restore health, stop bleeding, boost hydration, and more.")]
    public class BloodBags : RustPlugin
    {
        #region Fields

        private static BloodBags _plugin;
        private static Configuration _config;
        private BloodUsageListenerManager _manager;

        private List<Timer> _activeCraftingTimers = new List<Timer>();

        private const int ITEM_ID_BLOOD = 1776460938;
        private const string ITEM_SHORTNAME_BLOOD = "blood";

        private const string FX_DRINK = "assets/bundled/prefabs/fx/gestures/drink_generic.prefab";
        private const string FX_TAKE_DAMAGE = "assets/bundled/prefabs/fx/takedamage_generic.prefab";
        
        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Instant Health Increase")]
            public float InstantHealthIncrease { get; set; }

            [JsonProperty("Health Increase Over Time")]
            public float HealthIncreaseOverTime { get; set; }

            [JsonProperty("Calorie Boost")]
            public float CalorieBoost { get; set; }

            [JsonProperty("Hydration Boost")]
            public float HydrationBoost { get; set; }

            [JsonProperty("Stop Bleeding")]
            public bool StopBleeding { get; set; }

            [JsonProperty("Temperature Target")]
            public float TemperatureTarget { get; set; }

            [JsonProperty("Radiation Poisoning Reduction")]
            public float RadiationPoisoningReduction { get; set; }

            [JsonProperty("Amount To Consume")]
            public int AmountToConsume { get; set; }

            [JsonProperty("Crafting")]
            public CraftingConfig Crafting { get; set; }
        }

        private class CraftingConfig
        {
            [JsonProperty("Command")]
            public string Command { get; set; }

            [JsonProperty("Workbench Level Required")]
            public float WorkbenchLevelRequired { get; set; }

            [JsonProperty("Health Sacrifice Amount")]
            public float HealthSacrificeAmount { get; set; }

            [JsonProperty("Crafting Time Seconds")]
            public float CraftingTimeSeconds { get; set; }

            [JsonProperty("Crafting Amount")]
            public int CraftingAmount { get; set; }

            [JsonProperty("Ingredients")]
            public List<ItemInfo> Ingredients { get; set; }
        }

        public class ItemInfo
        {
            [JsonProperty("Shortname")]
            public string Shortname { get; set; }

            [JsonProperty("Amount")]
            public int Amount { get; set; }

            [JsonIgnore]
            private bool _validated;

            [JsonIgnore]
            private ItemDefinition _itemDefinition;

            [JsonIgnore]
            public ItemDefinition ItemDefinition
            {
                get
                {
                    if (!_validated)
                    {
                        ItemDefinition matchedItemDefinition = ItemManager.FindItemDefinition(Shortname);
                        if (matchedItemDefinition != null)
                            _itemDefinition = matchedItemDefinition;
                        else
                            return null;

                        _validated = true;
                    }

                    return _itemDefinition;
                }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            if (string.Compare(_config.Version, "2.1.0") < 0)
            {
                _config.Crafting.HealthSacrificeAmount = defaultConfig.Crafting.HealthSacrificeAmount;
            }

            if (string.Compare(_config.Version, "2.2.0") < 0)
            {
                _config.InstantHealthIncrease = defaultConfig.InstantHealthIncrease;
                _config.HealthIncreaseOverTime = defaultConfig.HealthIncreaseOverTime;
            }

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                InstantHealthIncrease = 20f,
                HealthIncreaseOverTime = 20f,
                CalorieBoost = 100f,
                HydrationBoost = 50f,
                StopBleeding = true,
                TemperatureTarget = 25f,
                RadiationPoisoningReduction = 25f,
                AmountToConsume = 2,
                Crafting = new CraftingConfig
                {
                    Command = "craftblood",
                    WorkbenchLevelRequired = 1,
                    HealthSacrificeAmount = 15f,
                    CraftingTimeSeconds = 10f,
                    Ingredients = new List<ItemInfo>
                    {
                        new ItemInfo
                        {
                            Shortname = "cloth",
                            Amount = 20
                        },
                        new ItemInfo
                        {
                            Shortname = "ducttape",
                            Amount = 1
                        },
                        new ItemInfo
                        {
                            Shortname = "skull.human",
                            Amount = 1
                        }
                    }
                }
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Init()
        {
            _plugin = this;
            _manager = new BloodUsageListenerManager();

            PermissionUtil.RegisterPermissions();
            cmd.AddChatCommand(_config.Crafting.Command, this, nameof(cmdCraftBloodBag));
        }

        private void Unload()
        {
            foreach (Timer timer in _activeCraftingTimers)
            {
                if (timer != null)
                    timer.Destroy();
            }

            _manager.Unload();
            _config = null;
            _plugin = null;
        }

        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (player == null || !PermissionUtil.VerifyHasPermission(player))
                return;

            bool isOldItemBloodBag = oldItem != null && oldItem.info.shortname == ITEM_SHORTNAME_BLOOD;
            bool isNewItemBloodBag = newItem != null && newItem.info.shortname == ITEM_SHORTNAME_BLOOD;

            if (isOldItemBloodBag && isNewItemBloodBag)
                return;

            if (isNewItemBloodBag)
            {
                BloodUsageListenerComponent component = _manager.GetBloodUsageListener(player);
                if (component == null)
                {
                    _manager.AddBloodUsageListener(player, newItem);
                    SendGameTip(player, lang.GetMessage(Lang.UseInstruction, this, player.UserIDString), 5f);
                }
            }
            else if (isOldItemBloodBag && !isNewItemBloodBag)
            {
                BloodUsageListenerComponent component = _manager.GetBloodUsageListener(player);
                if (component != null)
                {
                    _manager.DestroyBloodUsageListener(player);
                }
            }
        }

        #endregion Oxide Hooks

        #region Blood Usage Listener Component

        public class BloodUsageListenerManager
        {
            private Dictionary<BasePlayer, BloodUsageListenerComponent> _bloodUsageListeners = new Dictionary<BasePlayer, BloodUsageListenerComponent>();

            public bool AddBloodUsageListener(BasePlayer player, Item bloodItem)
            {
                if (_bloodUsageListeners.ContainsKey(player))
                    return false;

                BloodUsageListenerComponent component = BloodUsageListenerComponent.InstallComponent(player, this, bloodItem);
                _bloodUsageListeners[player] = component;
                return true;
            }

            public void HandleBloodUsageListenerDestroyed(BasePlayer player)
            {
                if (_bloodUsageListeners.ContainsKey(player))
                    _bloodUsageListeners.Remove(player);
            }

            public void Unload()
            {
                // Convert to an array to avoid 'InvalidOperationException' due to modifying the collection during iteration. This creates a snapshot of the collection.
                foreach (BloodUsageListenerComponent component in _bloodUsageListeners.Values.ToArray())
                {
                    if (component != null)
                        component.DestroyComponent();
                }
            }

            public void DestroyBloodUsageListener(BasePlayer player)
            {
                if (_bloodUsageListeners.TryGetValue(player, out BloodUsageListenerComponent component) && component != null)
                    component.DestroyComponent();
            }

            public BloodUsageListenerComponent GetBloodUsageListener(BasePlayer player)
            {
                if (_bloodUsageListeners.TryGetValue(player, out BloodUsageListenerComponent component))
                    return component;

                return null;
            }

            public bool BloodUsageListenerCurrentlyActive(BasePlayer player)
            {
                return _bloodUsageListeners.ContainsKey(player);
            }
        }

        public class BloodUsageListenerComponent : FacepunchBehaviour
        {
            #region Fields

            public BasePlayer Player { get; set; }

            private BloodUsageListenerManager _manager;
            private InputState _playerInput;
            private Item _bloodItem;

            private bool _useButtonPressed = false;

            #endregion Fields

            #region Component Management

            public static BloodUsageListenerComponent InstallComponent(BasePlayer player, BloodUsageListenerManager manager, Item bloodItem)
            {
                BloodUsageListenerComponent component = player.gameObject.AddComponent<BloodUsageListenerComponent>();
                component.InitializeComponent(manager, bloodItem);
                return component;
            }

            public BloodUsageListenerComponent InitializeComponent(BloodUsageListenerManager manager, Item bloodItem)
            {
                Player = GetComponent<BasePlayer>();

                _manager = manager;
                _bloodItem = bloodItem;
                _playerInput = Player.serverInput;

                return this;
            }

            public static BloodUsageListenerComponent GetComponent(BasePlayer player)
            {
                return player.gameObject.GetComponent<BloodUsageListenerComponent>();
            }

            public void DestroyComponent()
            {
                DestroyImmediate(this);
            }

            #endregion Component Management

            #region Component Lifecycle

            private void Update()
            {
                if (_bloodItem != null && _playerInput.WasJustPressed(BUTTON.USE) && !_useButtonPressed)
                {
                    int amount = GetItemAmount(ITEM_ID_BLOOD, Player.inventory.containerBelt);
                    if (amount < _config.AmountToConsume)
                    {
                        _plugin.SendReplyToPlayer(Player, Lang.NotEnoughBloodBags, _config.AmountToConsume);
                    }
                    else
                    {
                        ConsumeBlood();
                    }
                    _useButtonPressed = true;
                }
                else if (_playerInput.WasJustReleased(BUTTON.USE))
                {
                    _useButtonPressed = false;
                }
            }

            private void OnDestroy()
            {
                _manager.HandleBloodUsageListenerDestroyed(Player);
            }

            #endregion Component Lifecycle

            #region Consuming

            private void ConsumeBlood()
            {
                float healthIncrease = _config.InstantHealthIncrease;
                Player.Heal(healthIncrease);
                Player.metabolism.ApplyChange(MetabolismAttribute.Type.HealthOverTime, _config.HealthIncreaseOverTime, 1f);

                float calorieBoost = _config.CalorieBoost;
                Player.metabolism.calories.Add(calorieBoost);

                float hydrationBoost = _config.HydrationBoost;
                Player.metabolism.hydration.Add(hydrationBoost);

                if (_config.StopBleeding)
                    Player.metabolism.bleeding.value = 0f;

                float targetTemperature = _config.TemperatureTarget;
                Player.metabolism.temperature.value = Mathf.Lerp(Player.metabolism.temperature.value, targetTemperature, 0.5f);

                float radiationReduction = _config.RadiationPoisoningReduction;
                Player.metabolism.radiation_poison.Subtract(radiationReduction);

                TakeItem(Player, ITEM_ID_BLOOD, _config.AmountToConsume, Player.inventory.containerBelt);
                RunEffect(FX_DRINK, Player, boneId: 698017942);
            }

            #endregion Consuming
        }

        #endregion Blood Usage Listener Component

        #region Utility Classes

        private static class PermissionUtil
        {
            public const string USE = "bloodbags.use";

            public static void RegisterPermissions()
            {
                _plugin.permission.RegisterPermission(USE, _plugin);
            }

            public static bool VerifyHasPermission(BasePlayer player, string permissionName = USE)
            {
                return _plugin.permission.UserHasPermission(player.UserIDString, permissionName);
            }
        }

        #endregion Utility Classes

        #region Helper Functions

        private void SendGameTip(BasePlayer player, string message, float durationSeconds, params object[] args)
        {
            message = string.Format(message, args);

            player.SendConsoleCommand("gametip.showgametip", message);
            timer.Once(durationSeconds, () =>
            {
                if (player != null)
                    player.SendConsoleCommand("gametip.hidegametip");
            });
        }


        private static void RunEffect(string prefab, BaseEntity entity, uint boneId = 0, Vector3 localPosition = default(Vector3), Vector3 localDirection = default(Vector3), Connection effectRecipient = null, bool sendToAll = false)
        {
            Effect.server.Run(prefab, entity, boneId, localPosition, localDirection, effectRecipient, sendToAll);
        }

        public static int GetItemAmount(int itemId, ItemContainer container)
        {
            return container.GetAmount(itemId, true);
        }

        public static void GiveItem(BasePlayer player, int itemId, int amount, ItemContainer container)
        {
            container.GiveItem(ItemManager.CreateByItemID(itemId, amount));
            player.Command("note.inv", itemId, amount);
        }

        public static int TakeItem(BasePlayer player, int itemId, int amount, ItemContainer container)
        {
            int amountTaken = container.Take(null, itemId, amount);
            player.Command("note.inv", itemId, -amountTaken);
            return amountTaken;
        }

        #endregion Helper Functions

        #region Commands

        private void cmdCraftBloodBag(BasePlayer player, string command, string[] args)
        {
            if (!PermissionUtil.VerifyHasPermission(player))
            {
                SendReplyToPlayer(player, Lang.NoPermission);
                return;
            }

            string requiredWorkbench = $"Workbench{_config.Crafting.WorkbenchLevelRequired}";
            if (!player.HasPlayerFlag((BasePlayer.PlayerFlags)Enum.Parse(typeof(BasePlayer.PlayerFlags), requiredWorkbench, true)))
            {
                SendReplyToPlayer(player, Lang.NeedWorkbench, _config.Crafting.WorkbenchLevelRequired);
                return;
            }

            foreach (ItemInfo ingredient in _config.Crafting.Ingredients)
            {
                int amount = GetItemAmount(ingredient.ItemDefinition.itemid, player.inventory.containerMain);
                if (amount < ingredient.Amount)
                {
                    SendReplyToPlayer(player, Lang.NotEnoughIngredient, ingredient.Shortname, ingredient.Amount);
                    return;
                }
            }

            if (player.health > _config.Crafting.HealthSacrificeAmount)
            {
                player.Hurt(_config.Crafting.HealthSacrificeAmount);
            }
            else
            {
                SendReplyToPlayer(player, Lang.InsufficientHealth, _config.Crafting.HealthSacrificeAmount);
                return;
            }

            foreach (ItemInfo ingredient in _config.Crafting.Ingredients)
            {
                TakeItem(player, ingredient.ItemDefinition.itemid, ingredient.Amount, player.inventory.containerMain);
            }

            float craftingTimeLeft = _config.Crafting.CraftingTimeSeconds;
            Timer countdownTimer = timer.Repeat(1f, (int)craftingTimeLeft, () =>
            {
                if (player != null && craftingTimeLeft > 0)
                {
                    SendGameTip(player, lang.GetMessage(Lang.CraftingCountdown, this, player.UserIDString), 1f, craftingTimeLeft);
                    craftingTimeLeft--;
                }
            });

            Timer craftingTimer = timer.Once(_config.Crafting.CraftingTimeSeconds, () =>
            {
                if (player != null)
                {
                    GiveItem(player, ITEM_ID_BLOOD, _config.Crafting.CraftingAmount, player.inventory.containerMain);
                }
            });

            _activeCraftingTimers.Add(craftingTimer);
            _activeCraftingTimers.Add(countdownTimer);

            RunEffect(FX_TAKE_DAMAGE, player, boneId: 698017942);
            SendReplyToPlayer(player, Lang.CraftingStart, _config.Crafting.CraftingTimeSeconds);
        }

        #endregion Commands
        
        #region Localization

        private class Lang
        {
            public const string NoPermission = "NoPermission";
            public const string NeedWorkbench = "NeedWorkbench";
            public const string NotEnoughIngredient = "NotEnoughIngredient";
            public const string CraftingStart = "CraftingStart";
            public const string NotEnoughBloodBags = "NotEnoughBloodBags";
            public const string InsufficientHealth = "InsufficientHealth";
            public const string UseInstruction = "UseInstruction";
            public const string CraftingCountdown = "CraftingCountdown";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.NoPermission] = "You do not have permission to craft this item.",
                [Lang.NeedWorkbench] = "You need to be near a workbench level <color=#FFD700>{0}</color> to craft this item.",
                [Lang.NotEnoughIngredient] = "You do not have enough <color=#FFD700>{0}</color>. Required: <color=#FFD700>{1}</color>.",
                [Lang.CraftingStart] = "Crafting blood bag... Please wait <color=#FFD700>{0}</color> seconds.",
                [Lang.NotEnoughBloodBags] = "Not enough blood bags. Required: <color=#FFD700>{0}</color>.",
                [Lang.InsufficientHealth] = "You don't have enough health to craft a blood bag. Required health: <color=#FFD700>{0}</color>.",
                [Lang.UseInstruction] = "Press <color=#FFD700>use</color> to consume",
                [Lang.CraftingCountdown] = "Crafting blood bag, <color=#FFD700>{0}</color> seconds remaining",
            }, this, "en");
        }

        private void SendReplyToPlayer(BasePlayer player, string messageKey, params object[] args)
        {
            string message = lang.GetMessage(messageKey, this, player.UserIDString);
            if (args.Length > 0)
                message = string.Format(message, args);

            SendReply(player, message);
        }

        #endregion Localization
    }
}

// --- End of file: BloodBags.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-scarecrows ---
// --- Original File Path: B/BetterScarecrows/BetterScarecrows.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using Newtonsoft.Json;
using ProtoBuf;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Better Scarecrows", "Spiikesan", "1.5.9")]
    [Description("Fix and improve scarecrows")]
    public class BetterScarecrows : RustPlugin
    {
        const string b64ScarecrowDesign = "CAEIAwgPCBwIHQgeCB8SUggAEAEaFAgBEAEYACAAKAAwAKoGBQ0AACBBGhkIAxAFGAAgBCgAMAGiBgoNAAAAABUAAAAAGhkIABAGGAAgACgAMAKiBgoNAAAAQRUAAHBBIAASPQgBEAMaDAgFEAIYACAAKAAwABoMCBQQABgAIAAoADABGhkIAxAFGAAgBCgAMAKiBgoNAAAAABUAAAAAIAASRQgCEA8aDAgUEAAYACAAKAAwABoMCAUQARgBIAAoADABGiEIExAEGAAgACgAMASiBgoNAAAAABUAAAAA6gYFDc3MzD0gABJ6CAMQHBoZCAIQABgAIAAoADABogYKDQAAAAAVAAAAABoZCAQQABgAIAAoADACogYKDQAAAAAVAAAAABohCAEQARgAIAAoADADogYKDQAAAAAVAAAAAKoGBQ0AACBBGhkIAxAFGAAgBCgAMASiBgoNAAAAABUAAAAAIAASPAgEEB0aGQgCEAAYACAAKAAwAaIGCg0AAAAAFQAAAAAaGQgEEAEYACAAKAAwAqIGCg0AAAAAFQAAAAAgABI8CAUQHhoZCAIQARgAIAAoADABogYKDQAAAAAVAAAAABoZCAQQABgAIAAoADACogYKDQAAAAAVAAAAACAAEjwIBhAfGhkIAhAAGAAgACgAMAGiBgoNAAAAABUAAAAAGhkIBBADGAAgACgAMAKiBgoNAAAAABUAAAAAIAAYACIQQmV0dGVyIHNjYXJlY3JvdygBMAA=";

        const float SOUND_DELAY = 3f;

        static AIState _lastAIStateEnumValue = AIState.Blinded;
        static AIState _maxAIStateEnumValue = Enum.GetValues(typeof(AIState)).Cast<AIState>().Max();

        static BetterScarecrows _instance;

        enum AICustomState
        {
            UnusedState, //For compatibility with my AIManager plugin (used to create or update the content of the b64ScarecrowDesign) - Do not remove
            RoamState,
            ThrowGrenadeState,
            FleeInhuman,
            Awaken,
            // Maybe more states in the future ?
        };

        ProtoBuf.AIDesign _customDesign;

        #region Configuration

        private ScarecrowConfiguration _config;
        private ConVars _previousConVars;

        public class ConVars
        {
            [JsonProperty("OverrideConVars")]
            public bool OverrideConVars = false;

            [JsonProperty("ScarecrowPopulation")]
            public float ScarecrowPopulation = 5.0f;

            [JsonProperty("scarecrowsThrowBeancans")]
            public bool ScarecrowsThrowBeancans = true;

            [JsonProperty("scarecrowThrowBeancanGlobalDelay")]
            public float ScarecrowThrowBeancanGlobalDelay = 8.0f;
        }

        public class Sounds
        {
            [JsonProperty("Death")]
            public string Death = "assets/prefabs/npc/murderer/sound/death.prefab";
        }

        public class ScarecrowConfiguration
        {
            [JsonProperty("Health")]
            public float Health = 250.0f;

            [JsonProperty("AttackRangeMultiplier")]
            public float AttackRangeMultiplier = 0.75f;

            [JsonProperty("TargetLostRange")]
            public float TargetLostRange = 20f;

            [JsonProperty("SenseRange")]
            public float SenseRange = 15f;

            [JsonProperty("WalkSpeedFraction")]
            public float WalkSpeed = 0.3f;

            [JsonProperty("RunSpeedFraction")]
            public float RunSpeed = 1f;

            [JsonProperty("IgnoreSafeZonePlayers")]
            public bool IgnoreSafeZonePlayers = true;

            [JsonProperty("CanBradleyAPCTargetScarecrow")]
            public bool CanBradleyAPCTargetScarecrow = true;

            [JsonProperty("CanNPCTurretsTargetScarecrow")]
            public bool CanNPCTurretsTargetScarecrow = true;

            [JsonProperty("CanNPCScientistsTargetScarecrow")]
            public bool CanNPCScientistsTargetScarecrow = true;

            [JsonProperty("CanScarecrowTargetNPCScientists")]
            public bool CanScarecrowTargetNPCScientists = true;

            [JsonProperty("CanNPCBanditGuardTargetScarecrow")]
            public bool CanNPCBanditGuardTargetScarecrow = true;

            [JsonProperty("CanScarecrowTargetNPCBanditGuard")]
            public bool CanScarecrowTargetNPCBanditGuard = true;

            [JsonProperty("DisableLoot")]
            public bool DisableLoot = false;

            [JsonProperty("UseCustomAI")]
            public bool UseCustomAI = true;

            public Sounds Sounds = new Sounds();

            [JsonProperty("ConVars")]
            public ConVars ConVars = new ConVars();

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        };

        protected override void LoadDefaultConfig() => _config = new ScarecrowConfiguration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<ScarecrowConfiguration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            PrintWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Oxide hooks
        void Init()
        {
            _instance = this;
            _customDesign = ProtoBuf.AIDesign.Deserialize(Convert.FromBase64String(b64ScarecrowDesign));
            if (_lastAIStateEnumValue != _maxAIStateEnumValue)
            {
                PrintWarning($"{_maxAIStateEnumValue - _lastAIStateEnumValue} new state(s) have been added by Facepunch. An update of the AI is required !");
                computeNewDesign(_maxAIStateEnumValue - _lastAIStateEnumValue);
            }
            if (_customDesign == null)
            {
                PrintError("The custom design could not be loaded !");
                Unload();
            }
        }

        private void computeNewDesign(int offset)
        {
            //Updating availableStates.
            for (int i = 0; i < _customDesign.availableStates.Count; i++)
            {
                if (_customDesign.availableStates[i] > (int)_lastAIStateEnumValue)
                {
                    _customDesign.availableStates[i] += offset;
                }
            }
            //Updating state container
            for (int i = 0; i < _customDesign.stateContainers.Count; i++)
            {
                if (_customDesign.stateContainers[i].state > (int)_lastAIStateEnumValue)
                {
                    _customDesign.stateContainers[i].state += offset;
                }
            }
            PrintWarning("AI is updated with the new values. An update of the plugin is probably already pending from the plugin developer, but the plugin will continue to work.");
        }

        void OnServerInitialized()
        {
            updateAllScarecrows(false);

            if (_config.ConVars.OverrideConVars)
            {
                _previousConVars = new ConVars()
                {
                    OverrideConVars = true,
                    ScarecrowPopulation = ConVar.Halloween.scarecrowpopulation,
                    ScarecrowsThrowBeancans = ConVar.Halloween.scarecrows_throw_beancans,
                    ScarecrowThrowBeancanGlobalDelay = ConVar.Halloween.scarecrow_throw_beancan_global_delay
                };
                ConVar.Halloween.scarecrowpopulation = _config.ConVars.ScarecrowPopulation;
                ConVar.Halloween.scarecrows_throw_beancans = _config.ConVars.ScarecrowsThrowBeancans;
                ConVar.Halloween.scarecrow_throw_beancan_global_delay = _config.ConVars.ScarecrowThrowBeancanGlobalDelay;
            }
        }

        void Unload()
        {
            updateAllScarecrows(true);
            if (_config.ConVars.OverrideConVars && _previousConVars != null)
            {
                ConVar.Halloween.scarecrowpopulation = _previousConVars.ScarecrowPopulation;
                ConVar.Halloween.scarecrows_throw_beancans = _previousConVars.ScarecrowsThrowBeancans;
                ConVar.Halloween.scarecrow_throw_beancan_global_delay = _previousConVars.ScarecrowThrowBeancanGlobalDelay;
            }
            _instance = null;
        }

        private void OnEntitySpawned(ScarecrowNPC entity)
        {
            // The brain is hooked on the next frame.
            if (entity != null
                && !entity.IsDestroyed)
            {
                NextTick(() =>
                {
                    if (entity.Brain != null)
                    {
                        UpdateScarecrowConfiguration(entity, false);
                    }
                });
            }
        }


        private void OnEntityDeath(ScarecrowNPC entity)
        {
            Effect.server.Run(_config.Sounds.Death, entity, 0, Vector3.zero, entity.eyes.transform.forward.normalized);
        }

        private object CanBradleyApcTarget(BradleyAPC bradley, ScarecrowNPC scarecrow)
        {
            if (!_config.CanBradleyAPCTargetScarecrow)
                return false;
            return null;
        }

        private object CanBeTargeted(ScarecrowNPC scarecrow, NPCAutoTurret turret)
        {
            if (!_config.CanNPCTurretsTargetScarecrow)
                return false;
            return null;
        }

        private object OnNpcTarget(BaseEntity npc, BaseEntity entity)
        {
            // ScarecrowNPC is targeted.
            if (entity is ScarecrowNPC)
            {
                if (npc is ScientistNPC && !_config.CanNPCScientistsTargetScarecrow
                    || npc is BanditGuard && !_config.CanNPCBanditGuardTargetScarecrow)
                {
                    return true;
                }
            }
            // ScarecrowNPC is targeting.
            if (npc is ScarecrowNPC)
            {
                if (entity is ScientistNPC && !_config.CanScarecrowTargetNPCScientists
                    || entity is BanditGuard && !_config.CanScarecrowTargetNPCBanditGuard)
                {
                    return true;
                }
            }
            return null;
        }

        private object OnCorpsePopulate(ScarecrowNPC scarecrow, NPCPlayerCorpse corpse)
        {
            return _config.DisableLoot ? corpse : null;
        }

        #endregion

        #region Helpers
        static AIState GetAIState(AICustomState state) => (AIState)((int)_maxAIStateEnumValue + 1 + (int)state);

        static AICustomState GetAICustomState(AIState state) => (AICustomState)((int)state - (int)(_maxAIStateEnumValue + 1));

        static bool IsCustomState(AIState state) => state > _maxAIStateEnumValue;

        static void TraceLog(string format, [CallerLineNumber] int lineNumber = 0, [CallerMemberName] string caller = null) => _instance.Puts("(" + caller + ":" + lineNumber + ") " + format);

        public void updateAllScarecrows(bool revert)
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                ScarecrowNPC scarecrow = entity as ScarecrowNPC;
                if (scarecrow != null && !scarecrow.IsDestroyed)
                {
                    if (scarecrow.Brain != null)
                    {
                        UpdateScarecrowConfiguration(scarecrow, revert);
                    }
                    else
                    {
                        // If the scarecrow just spawned, his brain will only be there the next tick.
                        NextTick(() =>
                        {
                            if (scarecrow.Brain != null)
                            {
                                UpdateScarecrowConfiguration(scarecrow, revert);
                            }
                        });
                    }
                }
            }
        }

        private void UpdateScarecrowConfiguration(ScarecrowNPC entity, bool revert)
        {
            entity.InitializeHealth(_config.Health, _config.Health);
            entity.Brain.AttackRangeMultiplier = _config.AttackRangeMultiplier;
            entity.Brain.TargetLostRange = _config.TargetLostRange;
            entity.Brain.SenseRange = _config.SenseRange;
            entity.Brain.Senses.ignoreSafeZonePlayers = _config.IgnoreSafeZonePlayers;
            entity.Brain.Navigator.SlowSpeedFraction = _config.WalkSpeed;
            entity.Brain.Navigator.FastSpeedFraction = _config.RunSpeed;

            if (_config.UseCustomAI)
            {
                if (entity.Brain.states == null)
                    entity.Brain.AddStates();
                if (!revert)
                {
                    if (!entity.Brain.states.ContainsKey(GetAIState(AICustomState.RoamState)))
                        entity.Brain.AddState(new RoamState());
                    if (!entity.Brain.states.ContainsKey(GetAIState(AICustomState.ThrowGrenadeState)))
                        entity.Brain.AddState(new ThrowGrenadeState());
                    if (!entity.Brain.states.ContainsKey(GetAIState(AICustomState.FleeInhuman)))
                        entity.Brain.AddState(new FleeInhuman());
                    if (!entity.Brain.states.ContainsKey(GetAIState(AICustomState.Awaken)))
                        entity.Brain.AddState(new Awaken());
                    entity.Brain.states[AIState.Attack] = new AttackState();
                    entity.Brain.states[AIState.Attack].brain = entity.Brain;
                    entity.Brain.states[AIState.Attack].Reset();
                    entity.Brain.InstanceSpecificDesign = _customDesign;
                }
                else
                {
                    entity.Brain.states[AIState.Attack] = new ScarecrowBrain.AttackState();
                    entity.Brain.states[AIState.Attack].brain = entity.Brain;
                    entity.Brain.states[AIState.Attack].Reset();
                    entity.Brain.InstanceSpecificDesign = null;
                }
            }
            entity.Brain.LoadAIDesignAtIndex(entity.Brain.LoadedDesignIndex());
        }

        #endregion

        #region AI States
        public class AttackState : BaseAIBrain.BasicAIState
        {
            private IAIAttack attack;

            Chainsaw chainsaw;

            public AttackState() : base(AIState.Attack)
            {
                AgrresiveState = true;
            }

            private static Vector3 GetAimDirection(Vector3 from, Vector3 target)
            {
                return Vector3Ex.Direction2D(target, from);
            }

            private void StartAttacking(BaseEntity entity)
            {
                attack.StartAttacking(entity);
                if (chainsaw != null)
                {
                    chainsaw.ServerNPCStart();
                    chainsaw.SetFlag(BaseEntity.Flags.Busy, true, false, true);
                    chainsaw.SetFlag(BaseEntity.Flags.Reserved8, true, false, true);
                }
            }

            public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
            {
                base.StateEnter(brain, entity);
                ScarecrowNPC scarecrow = entity as ScarecrowNPC;
                attack = entity as IAIAttack;
                chainsaw = scarecrow.GetHeldEntity() as Chainsaw;
                BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
                if (baseEntity != null)
                {
                    Vector3 aimDirection = GetAimDirection(brain.Navigator.transform.position, baseEntity.transform.position);
                    brain.Navigator.SetFacingDirectionOverride(aimDirection);
                    if (attack.CanAttack(baseEntity))
                    {
                        StartAttacking(baseEntity);
                    }
                    brain.Navigator.SetDestination(baseEntity.transform.position, BaseNavigator.NavigationSpeed.Fast, 0f, 0f);
                }
            }

            public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
            {
                base.StateLeave(brain, entity);
                brain.Navigator.ClearFacingDirectionOverride();
                brain.Navigator.Stop();
                StopAttacking();
            }

            public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
            {
                base.StateThink(delta, brain, entity);
                BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
                if (attack == null)
                {
                    return StateStatus.Error;
                }
                if (baseEntity == null)
                {
                    brain.Navigator.ClearFacingDirectionOverride();
                    StopAttacking();
                    return StateStatus.Finished;
                }
                if (brain.Senses.ignoreSafeZonePlayers)
                {
                    BasePlayer basePlayer = baseEntity as BasePlayer;
                    if (basePlayer != null && basePlayer.InSafeZone())
                    {
                        return StateStatus.Error;
                    }
                }
                if (!brain.Navigator.SetDestination(baseEntity.transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f, 0f))
                {
                    return StateStatus.Error;
                }
                Vector3 aimDirection = GetAimDirection(brain.Navigator.transform.position, baseEntity.transform.position);
                brain.Navigator.SetFacingDirectionOverride(aimDirection);
                if (!attack.CanAttack(baseEntity))
                {
                    StopAttacking();
                }
                else
                {
                    StartAttacking(baseEntity);
                }
                return StateStatus.Running;
            }

            private void StopAttacking()
            {
                attack.StopAttacking();
                if (chainsaw != null)
                {
                    chainsaw.SetFlag(BaseEntity.Flags.Busy, false, false, true);
                    chainsaw.SetFlag(BaseEntity.Flags.Reserved8, false, false, true);
                }
            }
        }
        #endregion
        #region AI Custom states

        private class RoamState : BaseAIBrain.BasicAIState
        {
            private StateStatus status = StateStatus.Error;
            public RoamState() : base(GetAIState(AICustomState.RoamState))
            {
            }

            public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
            {
                Vector3 bestRoamPosition;
                base.StateEnter(brain, entity);
                status = StateStatus.Error;
                if (brain.PathFinder != null)
                {
                    if (!brain.InGroup() || brain.IsGroupLeader)
                    {
                        bestRoamPosition = brain.PathFinder.GetBestRoamPosition(brain.Navigator, brain.Navigator.transform.position, brain.Events.Memory.Position.Get(4), 20f, 100f);
                    }
                    else
                    {
                        bestRoamPosition = BasePathFinder.GetPointOnCircle(brain.Events.Memory.Position.Get(5), Core.Random.Range(2f, 7f), Core.Random.Range(0f, 359f));
                    }
                    if (brain.Navigator.SetDestination(bestRoamPosition, BaseNavigator.NavigationSpeed.Slow, 0f, 0f))
                    {
                        if (brain.InGroup() && brain.IsGroupLeader)
                        {
                            brain.SetGroupRoamRootPosition(bestRoamPosition);
                        }
                        status = StateStatus.Running;
                    }
                }
            }

            public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
            {
                base.StateLeave(brain, entity);
                brain.Navigator.Stop();
            }

            public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
            {
                base.StateThink(delta, brain, entity);
                if (status == StateStatus.Error)
                {
                    return status;
                }
                if (brain.Navigator.Moving)
                {
                    return StateStatus.Running;
                }
                return StateStatus.Finished;
            }
        }

        private class ThrowGrenadeState : BaseAIBrain.BasicAIState
        {
            bool _isThrown;
            NPCPlayer _entity = null;
            BasePlayer _target = null;
            Item _grenade = null;
            const float _MAX_DISTANCE = 5f;
            const float _THROW_TIME = 1.5f;

            public ThrowGrenadeState() : base(GetAIState(AICustomState.ThrowGrenadeState))
            {
                AgrresiveState = true;
            }

            public override bool CanEnter()
            {
                bool canEnter = false;

                if (ConVar.Halloween.scarecrows_throw_beancans && TimeSinceState() >= ConVar.Halloween.scarecrow_throw_beancan_global_delay)
                {
                    _target = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot) as BasePlayer;
                    canEnter = base.CanEnter() && _target != null && (!brain.Senses.ignoreSafeZonePlayers || !_target.InSafeZone());
                }
                return canEnter;
            }

            public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
            {
                base.StateEnter(brain, entity);
                _entity = entity as NPCPlayer;
                _grenade = _entity.inventory.containerBelt.GetSlot(1);
                if (_grenade != null)
                    _entity.UpdateActiveItem(_grenade.uid);
                _isThrown = false;
            }

            public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
            {
                base.StateThink(delta, brain, entity);
                _target = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot) as BasePlayer;
                StateStatus status = StateStatus.Error;

                if (_target != null && _grenade != null)
                {
                    float distance = Vector3.Distance(_entity.transform.position, _target.transform.position);
                    if (distance < _MAX_DISTANCE)
                    {
                        status = StateStatus.Running;
                        _entity.SetAimDirection((_target.ServerPosition - _entity.ServerPosition).normalized);

                        if (!_isThrown && TimeInState >= _THROW_TIME)
                        {
                            _entity.SignalBroadcast(BaseEntity.Signal.Throw);
                            (_grenade.GetHeldEntity() as ThrownWeapon)?.ServerThrow(_target.transform.position);
                            _isThrown = true;
                        }
                        else if (TimeInState >= _THROW_TIME + 1f)
                        {
                            status = StateStatus.Finished;
                        }
                    }
                }
                return status;
            }

            public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
            {
                base.StateLeave(brain, entity);
                if (_entity.inventory.containerBelt.GetSlot(0) != null)
                    _entity.UpdateActiveItem(_entity.inventory.containerBelt.GetSlot(0).uid);
            }
        }

        public class FleeInhuman : BaseAIBrain.BasicAIState
        {
            private float nextInterval;
            private float stopFleeDistance;

            public FleeInhuman() : base(GetAIState(AICustomState.FleeInhuman))
            {

            }

            private bool FleeFrom(BaseEntity fleeFromEntity, BaseEntity thisEntity)
            {
                Vector3 vector3;
                if (thisEntity == null || fleeFromEntity == null)
                {
                    return false;
                }
                nextInterval = UnityEngine.Random.Range(3f, 6f);
                if (!brain.PathFinder.GetBestFleePosition(brain.Navigator, brain.Senses, fleeFromEntity, brain.Events.Memory.Position.Get(4), 50f, 100f, out vector3))
                {
                    return false;
                }
                bool flag = brain.Navigator.SetDestination(vector3, BaseNavigator.NavigationSpeed.Fast, 0f, 0f);
                if (!flag)
                {
                    Stop();
                }
                return flag;
            }

            public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
            {
                base.StateEnter(brain, entity);
                BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
                if (baseEntity != null && !(baseEntity is BasePlayer))
                {
                    stopFleeDistance = UnityEngine.Random.Range(5f, 10f);
                    FleeFrom(baseEntity, entity);
                }
            }

            public override bool CanLeave()
            {
                BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
                return base.CanLeave() && (baseEntity == null || baseEntity is BasePlayer || Vector3Ex.Distance2D(brain.Navigator.transform.position, baseEntity.transform.position) >= stopFleeDistance);
            }

            public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
            {
                base.StateLeave(brain, entity);
                Stop();
            }

            public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
            {
                base.StateThink(delta, brain, entity);
                BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
                if (baseEntity == null)
                {
                    return StateStatus.Finished;
                }
                else if (baseEntity is BasePlayer && !(baseEntity is NPCPlayer))
                {
                    return StateStatus.Error;
                }
                if (Vector3Ex.Distance2D(brain.Navigator.transform.position, baseEntity.transform.position) >= stopFleeDistance)
                {
                    return StateStatus.Finished;
                }
                if (!brain.Navigator.UpdateIntervalElapsed(nextInterval) && brain.Navigator.Moving || FleeFrom(baseEntity, entity))
                {
                    return StateStatus.Running;
                }
                return StateStatus.Error;
            }

            private void Stop()
            {
                brain.Navigator.Stop();
            }
        }

        public class Awaken : BaseAIBrain.BasicAIState
        {
            BasePlayer[] players = new BasePlayer[1];

            public Awaken() : base(GetAIState(AICustomState.Awaken))
            {
            }

            public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
            {
                StateStatus status = StateStatus.Finished;
                if (Rust.Ai.AiManager.ai_dormant
                    && BaseEntity.Query.Server.GetPlayersInSphere(entity.transform.position, Rust.Ai.AiManager.ai_to_player_distance_wakeup_range, players, (p) => p.userID.IsSteamId()) == 0)
                {
                    status = StateStatus.Error;
                }
                players[0] = null;
                return status;
            }
        }

        #endregion
    }
}

// --- End of file: BetterScarecrows.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bandit-hide ---
// --- Original File Path: B/BanditHide/BanditHide.cs ---

﻿using Oxide.Core;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("BanditHide", "mangiang", "1.0.6", ResourceId = 2470)]
    [Description("Hides name when wearing specific clothes")]
    class BanditHide : RustPlugin
    {
        #region Initialization
        StoredData storedData;

        /// <summary>
        /// New bandit Name
        /// </summary>
        string changedName = "Masked bandit";

        /// <summary>
        /// Default ChangedName 
        /// </summary>
        string DefaultChangedName = "Masked bandit";

        /// <summary>
        /// Items that hide the name
        /// </summary>
        List<string> masks = new List<string> {
        "mask",
        "burlap.headwrap"};

        /// <summary>
        /// Use Logs
        /// </summary>
        bool DebugMode = false;

        /// Permission
        string perm = "";
        #endregion

        /// <summary>
        /// Store the userId and the name of masked players
        /// </summary>
        class StoredData
        {
            public Dictionary<string, string> banditNames = new Dictionary<string, string>();

            public StoredData()
            {
            }
        }


        protected override void LoadDefaultConfig() => Puts("New configuration file created.");
        private void Init() => LoadConfigValues();

        /// <summary>
        /// Load bandit who already wear a mask
        /// </summary>
        void LoadConfigValues()
        {
            #region Use Logs
            string str = Config["Debug mode"] as string;
            if (str == null)
            {
                DebugMode = false;
                Config["Debug mode"] = DebugMode.ToString();
            }
            else
            {
                DebugMode = (str.Equals("True") ? true : false);
            }
            if (DebugMode)
            {
                Puts("Debug mode enabled");
                Log("Debug mode enabled");
            }
            #endregion

            #region Bandit Names
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("BanditNames");
            if (DebugMode)
            {
                Log("Stored Data :");
                var enu = storedData.banditNames.GetEnumerator();
                while (enu.MoveNext())
                {
                    Log(enu.Current.Key + " => " + enu.Current.Value);
                }
            }
            #endregion

            #region Changed Name
            changedName = Config["Changed Name"] as string;
            if (changedName == null)
            {
                changedName = DefaultChangedName;
                Config["Changed Name"] = changedName;
            }

            if (changedName.Equals(""))
            {
                changedName = " ";
            }

            if (DebugMode)
            {
                Log("Changed Name : " + changedName);
            }
            #endregion

            #region Masks
            List<Object> tmpmasks = Config["Masks"] as List<Object>;
            if (tmpmasks == null)
            {
                masks = new List<string> { "mask", "burlap.headwrap" };
                Config["Masks"] = masks;
            }
            else
            {
                masks = new List<string>();
                foreach (Object mask in tmpmasks)
                {
                    masks.Add((string)mask);
                }
                Config["Masks"] = masks;
            }
            if (DebugMode)
            {
                foreach (string mk in masks)
                {
                    Log("Masks : " + mk);
                }
            }
            #endregion

            SaveConfig();
        }

        void OnServerInitialized()
        {
            /// Init the permission
            perm = this.Name.ToLowerInvariant() + ".use";
            /// Add permission bandithide.use
            permission.RegisterPermission(perm, this);

            LoadDefaultMessages();
        }

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Renamed"] = "You are renamed to ",
            }, this);

            // French
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Renamed"] = "Vous avez été renommé en ",
            }, this, "fr");
        }

        /// <summary>
        ///  Change back the name on respawn
        /// </summary>
        /// <param name="player"></param>
        /// <returns></returns>
        object OnPlayerRespawned(BasePlayer player)
        {
            if (player.displayName.Equals(changedName) && permission.UserHasPermission(player.UserIDString, perm))
            {
                if (DebugMode)
                {
                    Log("Enter OnPlayerRespawned");
                }
                player.displayName = storedData.banditNames[player.UserIDString];
                if (DebugMode)
                {
                    Log("Renaming " + player.displayName + " (" + player.UserIDString + ") into " + changedName);
                }
                player.ChatMessage(lang.GetMessage("Renamed", this, player.UserIDString) + player.displayName);
                storedData.banditNames.Remove(player.UserIDString);
                player.Connection.username = player.displayName;
                player.SendNetworkUpdate();
                player.SendEntityUpdate();
                Interface.Oxide.DataFileSystem.WriteObject("BanditNames", storedData);
                if (DebugMode)
                {
                    Log("New name is " + player.displayName + " (" + player.UserIDString + ")");
                }
                if (DebugMode)
                {
                    Log("Exit OnPlayerRespawned");
                }
            }
            return null;
        }

        /// <summary>
        /// Change name on wake up if wearing a mask
        /// </summary>
        /// <param name="player"></param>
        /// <returns></returns>
        object OnPlayerSleepEnded(BasePlayer player)
        {
            if (IsWearingAMask(player)
                && !storedData.banditNames.ContainsKey(player.UserIDString) && permission.UserHasPermission(player.UserIDString, perm))
            {
                if (DebugMode)
                {
                    Log("Enter OnPlayerSleepEnded");
                }
                if (!player.displayName.Equals(changedName))
                {
                    if (!storedData.banditNames.ContainsKey(player.UserIDString))
                        storedData.banditNames.Add(player.UserIDString, player.displayName);
                    if (DebugMode)
                    {
                        Log("Renaming " + player.displayName + " (" + player.UserIDString + ") into " + changedName);
                    }
                    player.displayName = changedName;
                    player.ChatMessage(lang.GetMessage("Renamed", this, player.UserIDString) + player.displayName);
                    player.Connection.username = changedName;
                    player.SendNetworkUpdate();
                    player.SendEntityUpdate();
                    Interface.Oxide.DataFileSystem.WriteObject("BanditNames", storedData);
                    if (DebugMode)
                    {
                        Log("New name is " + player.displayName + " (" + player.UserIDString + ")");
                    }
                }
                if (DebugMode)
                {
                    Log("Exit OnPlayerSleepEnded");
                }
            }

            return null;
        }

        /// <summary>
        /// Called when trying to wear an item
        /// </summary>
        /// <param name="inventory"></param>
        /// <param name="item"></param>
        /// <returns></returns>
        object CanWearItem(PlayerInventory inventory, Item item)
        {

            BasePlayer player = inventory.containerWear.GetOwnerPlayer();
            if (IsMask(item) && permission.UserHasPermission(player.UserIDString, perm))
            {
                if (DebugMode)
                {
                    Log("Enter CanWearItem");
                }
                if (!storedData.banditNames.ContainsKey(player.UserIDString))
                    storedData.banditNames.Add(player.UserIDString, player.displayName);

                if (DebugMode)
                {
                    Log("Renaming " + player.displayName + " (" + player.UserIDString + ") into " + changedName);
                }
                player.displayName = changedName;
                player.ChatMessage(lang.GetMessage("Renamed", this, player.UserIDString) + player.displayName);
                player.Connection.username = changedName;
                player.SendNetworkUpdate();
                player.SendEntityUpdate();
                Interface.Oxide.DataFileSystem.WriteObject("BanditNames", storedData);
                if (DebugMode)
                {
                    Log("New name is " + player.displayName + " (" + player.UserIDString + ")");
                }

                if (DebugMode)
                {
                    Log("Exit CanWearItem");
                }
            }

            return null;
        }

        /// <summary>
        /// Called when adding an item to a container
        /// </summary>
        /// <param name="container"></param>
        /// <param name="item"></param>
        /// <returns></returns>
        object OnItemAddedToContainer(ItemContainer container, Item item)
        {
            BasePlayer player = container.GetOwnerPlayer();
            if (player != null && permission.UserHasPermission(player.UserIDString, perm))
            {
                if (DebugMode)
                {
                    Log("Enter OnItemAddedToContainer");
                }
                // if the container is the "Wear Container"
                if (!storedData.banditNames.ContainsKey(player.UserIDString)
                    && player.inventory.containerWear == container)
                {
                    if (!player.displayName.Equals(changedName) && IsWearingAMask(player))
                    {
                        if (!storedData.banditNames.ContainsKey(player.UserIDString))
                            storedData.banditNames.Add(player.UserIDString, player.displayName);
                        if (DebugMode)
                        {
                            Log("Renaming " + player.displayName + " (" + player.UserIDString + ") into " + changedName);
                        }
                        player.displayName = changedName;
                        player.ChatMessage(lang.GetMessage("Renamed", this, player.UserIDString) + player.displayName);
                        player.Connection.username = changedName;
                        player.SendNetworkUpdate();
                        player.SendEntityUpdate();
                        Interface.Oxide.DataFileSystem.WriteObject("BanditNames", storedData);
                        if (DebugMode)
                        {
                            Log("New name is " + player.displayName + " (" + player.UserIDString + ")");
                        }
                    }
                }
                if (DebugMode)
                {
                    Log("Exit OnItemAddedToContainer");
                }
            }

            return null;
        }

        /// <summary>
        /// Called when removing an item from a container
        /// </summary>
        /// <param name="container"></param>
        /// <param name="item"></param>
        /// <returns></returns>
        object OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            BasePlayer player = container.GetOwnerPlayer();
            if (player != null && permission.UserHasPermission(player.UserIDString, perm))
            {
                if (DebugMode)
                {
                    Log("Enter OnItemRemovedFromContainer");
                }
                // if the container is the "Wear Container"
                if (storedData.banditNames.ContainsKey(player.UserIDString)
                && player.inventory.containerWear == container)
                {
                    if (player.displayName.Equals(changedName) && !IsWearingAMask(player))
                    {
                        if (DebugMode)
                        {
                            Log("Renaming " + player.displayName + " (" + player.UserIDString + ") into " + storedData.banditNames[player.UserIDString]);
                        }
                        player.displayName = storedData.banditNames[player.UserIDString];
                        player.ChatMessage(lang.GetMessage("Renamed", this, player.UserIDString) + player.displayName);
                        player.Connection.username = player.displayName;
                        player.SendNetworkUpdate();
                        player.SendEntityUpdate();
                        storedData.banditNames.Remove(player.UserIDString);
                        Interface.Oxide.DataFileSystem.WriteObject("BanditNames", storedData);
                        if (DebugMode)
                        {
                            Log("New name is " + player.displayName + " (" + player.UserIDString + ")");
                        }
                    }
                }
                if (DebugMode)
                {
                    Log("Exit OnItemRemovedFromContainer");
                }
            }
            return null;
        }

        bool IsWearingAMask(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, perm))
            {
                foreach (Item it in player.inventory.containerWear.itemList)
                {
                    if (DebugMode)
                    {
                        Log("Item : " + it.info.displayName.english);
                    }
                    foreach (string maskName in masks)
                    {
                        if (DebugMode)
                        {
                            Log("Mask : " + maskName);
                        }
                        if (it.info.name.Contains(maskName))
                        {
                            if (DebugMode)
                            {
                                Log(player.displayName + "(" + player.UserIDString + ") is wearing a " + maskName);
                            }
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        bool IsMask(Item item)
        {
            if (DebugMode)
            {
                Log("Item : " + item.info.shortname);
            }
            foreach (string maskName in masks)
            {
                if (DebugMode)
                {
                    Log("Mask : " + maskName);
                }
                if (item.info.shortname.Contains(maskName))
                {
                    if (DebugMode)
                    {
                        Log("It is a mask");
                    }
                    return true;
                }
            }
            if (DebugMode)
            {
                Log("It is not a mask");
            }
            return false;
        }

        void Log(string text)
        {
            LogToFile("logs", $"[{DateTime.Now}] {text}", this);
        }
    }
}

// --- End of file: BanditHide.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/block-structure ---
// --- Original File Path: B/BlockStructure/BlockStructure.cs ---

using System.Collections.Generic;
using UnityEngine;
using System;

namespace Oxide.Plugins
{
    [Info("BlockStructure", "Marat", "1.0.4", ResourceId = 2092)]
	[Description("Building blocks in the rocks, terrain and icebergs. Sets a limit build in height and depth in water.")]
	
    class BlockStructure : RustPlugin
    {
		void Loaded()
        {
			LoadConfiguration();
            LoadDefaultMessages();
			permission.RegisterPermission(permBS, this);
        }
		
		double HeightBlock = 20;
		double WaterBlock = -5;
		int AuthLvl = 3;
		bool ConfigChanged;
		bool usePermissions = true;
        bool BlockInHeight = true;
		bool BlockInWater = true;
		bool BlockInRock = true;
		bool BlockOnIceberg = false;
		bool BlockUnTerrain = true;
        string permBS = "blockstructure.allowed";
		
		protected override void LoadDefaultConfig() => PrintWarning("New configuration file created.");

        void LoadConfiguration()
        {
			HeightBlock = GetConfigValue("Options", "Height for block", HeightBlock);
			WaterBlock = GetConfigValue("Options", "Depth for block", WaterBlock);
			BlockInHeight = GetConfigValue("Options", "Block in Height", BlockInHeight);
			BlockInWater = GetConfigValue("Options", "Block in Water", BlockInWater);
			BlockInRock = GetConfigValue("Options", "Block In Rock", BlockInRock);
			BlockOnIceberg = GetConfigValue("Options", "Block On Iceberg", BlockOnIceberg);
			BlockUnTerrain = GetConfigValue("Options", "Block Under Terrain", BlockUnTerrain);
			usePermissions = GetConfigValue("Options", "UsePermissions", usePermissions);
			AuthLvl = GetConfigValue("Options", "Ignore Authorization Level", AuthLvl);
			
			if (!ConfigChanged) return;
            PrintWarning("Configuration file updated.");
            SaveConfig();
		}
		T GetConfigValue<T>(string category, string setting, T defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                ConfigChanged = true;
            }
            if (data.TryGetValue(setting, out value)) return (T)Convert.ChangeType(value, typeof(T));
            value = defaultValue;
            data[setting] = value;
            ConfigChanged = true;
            return (T)Convert.ChangeType(value, typeof(T));
        }
		void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
				["blockWater"] = "<size=16><color=yellow>You can not build in water deeper {0} meters</color></size>",
                ["blockHeight"] = "<size=16><color=yellow>You can not build higher {0} meters</color></size>",
				["block"] = "<size=16><color=red>You can not build here</color></size>",
				["blockIce"] = "<size=16><color=red>You can not build on iceberg</color></size>",
				["blockTerrain"] = "<size=16><color=#ffff00>You can not build under the terrain</color></size>",
            }, this, "en");
			
			lang.RegisterMessages(new Dictionary<string, string>
            {
				["blockWater"] = "<size=16><color=#ffff00>Вы не можете строить в воде глубже {0} метров</color></size>",
                ["blockHeight"] = "<size=16><color=#ffff00>Вы не можете строить выше {0} метров</color></size>",
				["block"] = "<size=16><color=#ff0000>Вы не можете строить здесь</color></size>",
				["blockIce"] = "<size=16><color=#ffff00>Вы не можете строить на айсберге</color></size>",
				["blockTerrain"] = "<size=16><color=#ffff00>Вы не можете строить под рельефом</color></size>"
            }, this, "ru");
        }
        void Block(BaseNetworkable block, BasePlayer player, bool Height, bool Water)
        {
            if (usePermissions && !IsAllowed(player.UserIDString, permBS) && player.net.connection.authLevel < AuthLvl && block && !block.IsDestroyed)
            {
                Vector3 Pos = block.transform.position;
                if (Height || Water)
                {
                    float height = TerrainMeta.HeightMap.GetHeight(Pos);
                    if (Height && Pos.y - height > HeightBlock)
                    {
                        Reply(player, Lang("blockHeight", player.UserIDString, HeightBlock));
                        block.Kill(BaseNetworkable.DestroyMode.Gib);
                        return;
                    }
                    else if (Water && height < 0 && height < WaterBlock && Pos.y < 2.8f )
                    {
                        Reply(player, Lang("blockWater", player.UserIDString, WaterBlock));
                        block.Kill(BaseNetworkable.DestroyMode.Gib);
                        return;
                    }
                }
				if (BlockInRock)
				{
				    Pos.y += 200;
                    RaycastHit[] hits = Physics.RaycastAll(Pos, Vector3.down, 199.0f);
                    Pos.y -= 200;
                    for (int i = 0; i < hits.Length; i++)
                    {
                        RaycastHit hit = hits[i];
                        if (hit.collider)
                        {
                            string ColName = hit.collider.name;
                            if ((ColName.StartsWith("rock", StringComparison.CurrentCultureIgnoreCase) || ColName.StartsWith("cliff", StringComparison.CurrentCultureIgnoreCase)) && (hit.point.y < Pos.y ? BlockInRock : hit.collider.bounds.Contains(Pos)))
                            {
							    var buildingBlock = block.GetComponent<BuildingBlock>();
                                if (buildingBlock != null)
                                {
                                    foreach (ItemAmount item in buildingBlock.blockDefinition.grades[(int)buildingBlock.grade].costToBuild)
                                    {
                                        player.inventory.GiveItem(ItemManager.CreateByItemID(item.itemid, (int)item.amount));
                                    }
                                }
								Reply(player, Lang("block", player.UserIDString));
                                block.Kill(BaseNetworkable.DestroyMode.Gib);
                                break;
						    }
                        }							
                    }
                }
				if (BlockOnIceberg)
				{
				    Pos.y += 200;
                    RaycastHit[] hits = Physics.RaycastAll(Pos, Vector3.down, 202.8f);
                    Pos.y -= 200;
                    for (int i = 0; i < hits.Length; i++)
                    {
                        RaycastHit hit = hits[i];
                        if (hit.collider)
                        {
                            string ColName = hit.collider.name;
                            if (BlockOnIceberg && ColName == "iceberg_COL")
                            {
								var buildingBlock = block.GetComponent<BuildingBlock>();
                                if (buildingBlock != null)
                                {
                                    foreach (ItemAmount item in buildingBlock.blockDefinition.grades[(int)buildingBlock.grade].costToBuild)
                                    {
                                        player.inventory.GiveItem(ItemManager.CreateByItemID(item.itemid, (int)item.amount));
                                    }
                                }
                                Reply(player, Lang("blockIce", player.UserIDString));
                                block.Kill(BaseNetworkable.DestroyMode.Gib);
                                break;
                            }
                        }							
                    }
					
                }
				if (BlockUnTerrain)
				{
				    Pos.y += 200;
                    RaycastHit[] hits = Physics.RaycastAll(Pos, Vector3.down, 199.0f);
                    Pos.y -= 200;
					bool isMining = block is MiningQuarry;
                    for (int i = 0; i < hits.Length; i++)
                    {
                        RaycastHit hit = hits[i];
                        if (hit.collider)
                        {
                            string ColName = hit.collider.name;
                            if (BlockUnTerrain && !isMining && ColName == "Terrain" && hit.point.y > Pos.y)
                            {
								var buildingBlock = block.GetComponent<BuildingBlock>();
                                if (buildingBlock != null)
                                {
                                    foreach (ItemAmount item in buildingBlock.blockDefinition.grades[(int)buildingBlock.grade].costToBuild)
                                    {
                                        player.inventory.GiveItem(ItemManager.CreateByItemID(item.itemid, (int)item.amount));
                                    }
                                }
                                Reply(player, Lang("blockTerrain", player.UserIDString));
                                block.Kill(BaseNetworkable.DestroyMode.Gib);
                                break;
                            }
                        }							
                    }
				}
            }
        }
		string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        void Reply(BasePlayer player, string message, string args = null) => PrintToChat(player, $"{message}", args);
        void OnEntityBuilt(Planner plan, GameObject obj) => Block(obj.GetComponent<BaseNetworkable>(), plan.GetOwnerPlayer(), BlockInHeight, BlockInWater);
		bool IsAllowed(string id, string perm) => permission.UserHasPermission(id, perm);
    }
}

// --- End of file: BlockStructure.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-chat-mentions ---
// --- Original File Path: B/BetterChatMentions/BetterChatMentions.cs ---

﻿// Requires: BetterChat

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Better Chat Mentions", "Death", "1.2.4")]
    [Description("Format and send alerts to mentioned players")]
    class BetterChatMentions : RustPlugin
    {
        #region Fields

        private const string PermEveryone = "betterchatmentions.everyone";
        private const string PermDisallow = "betterchatmentions.disallow";
        private const string PermExclude = "betterchatmentions.exclude";

        [PluginReference] Plugin BetterChat;

        Dictionary<ulong, double> LastAlert = new Dictionary<ulong, double>();

        #endregion

        #region Config

        ConfigFile config;

        class ConfigFile
        {
            [JsonProperty("Group Color To Use (Title/Username/Message)")]
            public string GroupColor = "Username";

            [JsonProperty("Alert to play")]
            public string Alert = "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab";

            [JsonProperty("Delay Between Alert Sounds (Seconds)")]
            public double AlertSoundDelay = 0;

            [JsonProperty("Everyone Ping Color")]
            public string EveryonePingColor = "#55aaff";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<ConfigFile>();
            Config.WriteObject(config, true);
        }

        protected override void LoadDefaultConfig() => config = new ConfigFile();

        protected override void SaveConfig() => Config.WriteObject(config, true);

        #endregion

        #region Hooks

        void Init()
        {
            permission.RegisterPermission(PermEveryone, this);
            permission.RegisterPermission(PermDisallow, this);
            permission.RegisterPermission(PermExclude, this);
        }

        Dictionary<string, object> OnBetterChat(Dictionary<string, object> data)
        {
            IPlayer player = data["Player"] as IPlayer;

            if (player.HasPermission(PermDisallow))
            {
                return null;
            }

            string text = data["Message"].ToString();

            ListHashSet<BasePlayer> soundPlayers = new ListHashSet<BasePlayer>();

            // Get all indexes of '@' within the message
            List<int> indexes = AllIndexesOf('@', text);

            // When we insert text, the index of a particular '@' character will increase
            // We track this increase in the `substringIncrease`
            int substringIncrease = 0;
            foreach (int listIndex in indexes)
            {
                int index = listIndex + substringIncrease;

                // Trim the start of the text down to the index
                string playerName = text.Substring(index);

                // Grab the next space and trim the string down to it (if applicable)
                int spaceIndex = playerName.IndexOf(' ');
                if (spaceIndex != -1)
                {
                    playerName = playerName.Substring(0, spaceIndex);
                }

                string nameOnly = playerName.TrimStart('@');

                bool pingEveryone = nameOnly.ToLower() == "everyone" && player.HasPermission(PermEveryone);

                string highlightColour = (pingEveryone) ? config.EveryonePingColor : string.Empty;
                string highlightText = nameOnly.ToLower();

                // Find the player (removing the '@' so it leaves just their name)
                if (!pingEveryone)
                {
                    BasePlayer target = FindPlayer(nameOnly);
                    if (target == null) continue;

                    if (ShouldExclude(target)) continue;

                    highlightText = target.displayName;

                    if (!soundPlayers.Contains(target))
                    {
                        soundPlayers.Add(target);
                    }

                    // Get their group colour using the BetterChat API
                    highlightColour = GetGroupColour(target);
                    if (string.IsNullOrEmpty(highlightColour)) continue;
                }

                // The text to be inserted
                string newText = $"@<color={highlightColour}>{highlightText}</color>";

                StringBuilder sb = new StringBuilder(text);
                // Remove the original name at the given index
                sb.Remove(index, playerName.Length);
                // Insert the new message in its place
                sb.Insert(index, newText);
                text = sb.ToString();

                // Increment the substringIncrease based on the number of characters we added
                // Calculated via length of the new string `newText` minus length of the old string `playerName`
                substringIncrease += newText.Length - playerName.Length;

                if (pingEveryone)
                {
                    soundPlayers = BasePlayer.activePlayerList;
                    break;
                }
            }

            foreach (var target in soundPlayers)
            {
                if (!ShouldPlaySound(target)) continue;

                PlaySound(target, config.Alert);

                RecordAlertSoundPlayed(target);
            }

            data["Message"] = text;

            return data;
        }

        #endregion

        #region Functions

        List<int> AllIndexesOf(char character, string input)
        {
            List<int> indexes = new List<int>();

            for (int i = 0; i < input.Length; i++)
            {
                if (input[i] == character)
                {
                    indexes.Add(i);
                }
            }

            return indexes;
        }

        string GetGroupColour(BasePlayer player)
        {
            // Get all the groups the given player is in
            List<JObject> groups = BetterChat.Call<List<JObject>>("API_GetUserGroups", player.IPlayer);

            // Order ascendingly by the `Priority` field
            groups = groups.OrderBy(g => (int)g["Priority"]).ToList();

            // Get the first item in the list (group w/ lowest priority)
            JObject highestGroup = groups.First();

            // Get the colour based on the config option
            string groupColour = (string)highestGroup[config.GroupColor]["Color"];
            if (string.IsNullOrEmpty(groupColour)) return string.Empty;

            // Add a # to the start of the colour so Covalence formatting is valid
            if (!groupColour.StartsWith("#")) groupColour = "#" + groupColour;

            return groupColour;
        }

        void PlaySound(BasePlayer player, string path) => Effect.server.Run(path, player, 2, Vector3.zero, new Vector3(0f, 2f, 0f));

        bool ShouldPlaySound(BasePlayer player)
        {
            if (config.AlertSoundDelay <= 0)
            {
                return true;
            }

            if (!LastAlert.ContainsKey(player.userID))
            {
                return true;
            }

            double lastTime = LastAlert[player.userID];

            return ((TimeSinceEpoch() - lastTime) > config.AlertSoundDelay);
        }

        void RecordAlertSoundPlayed(BasePlayer player)
        {
            if (config.AlertSoundDelay <= 0) return;

            if (LastAlert.ContainsKey(player.userID))
            {
                LastAlert.Remove(player.userID);
            }

            LastAlert.Add(player.userID, TimeSinceEpoch());
        }

        #endregion

        #region Helpers

        BasePlayer FindPlayer(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                return null;
            }

            return BasePlayer.activePlayerList.FirstOrDefault(x => x.displayName.ToLower().Contains(name.ToLower()));
        }

        double TimeSinceEpoch() => (DateTime.UtcNow - new DateTime(1970, 1, 1)).TotalSeconds;

        bool ShouldExclude(BasePlayer player) => permission.UserHasPermission(player.UserIDString, PermExclude);

        #endregion
    }
}


// --- End of file: BetterChatMentions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bed-share ---
// --- Original File Path: B/BedShare/BedShare.cs ---

using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Facepunch.Math;
using UnityEngine;
using System;
using Newtonsoft.Json;
using System.Linq;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
	[Info("BedShare", "ignignokt84", "0.1.0")]
	[Description("Bed sharing plugin")]
	class BedShare : RustPlugin
	{
		#region Variables

		static BedShare Instance;

		BagData data = new BagData();
		Dictionary<ulong, string> playerNameCache = new Dictionary<ulong, string>();
		Dictionary<ulong, ulong> dummyBags = new Dictionary<ulong, ulong>();

		const string PermCanUse = "bedshare.use";
		const string PermNoShare = "bedshare.noshare";
		const string PermCanSharePublic = "bedshare.public";
		const string PermCanSharePrivate = "bedshare.private";
		const string PermCanClear = "bedshare.canclear";

		const string BedPrefabName = "bed_deployed";
		
		const string UIElementPrefix = "BSUI";

		// list of PlayerUI for lookup
		List<PlayerUI> playerUIs = new List<PlayerUI>();
		// empty guid for validation
		readonly Guid EmptyGuid = new Guid(new byte[16]);

		const string GUIRespawnCommand = "BSUICmd_Respawn";

		enum Command { clear, share, sharewith, status, unshare, unsharewith };

		#endregion

		#region Lang

		// load default messages to Lang
		void LoadDefaultMessages()
		{
			var messages = new Dictionary<string, string>
			{
				{"Prefix", "<color=orange>[ BedShare ]</color> "},
				{"CannotShareOther", "You cannot {1} another player's {0}"},
				{"ShareSuccess", "This {0} is now {1}" },
				{"NotShared", "This {0} is not shared" },
				{"NoBag", "No bag or bed found" },
				{"ClearSuccess", "Successfully cleared {0} bags/beds" },
				{"NoClearPerm", "You do not have permission to clear shared beds/bags" },
				{"CommandList", "<color=cyan>Valid Commands:</color>" + System.Environment.NewLine + "{0}"},
				{"Status", "This {0} is currently {1}" },
				{"ValidateStats", "Shared bag/bed mappings validated - {0} removed" },
				{"SharedHeaderText", "Spawn in Shared Sleeping Bag" },
				{"SharedBagNameText", "{0} (public) [Shared by {1}]" },
				{"SharedBagNameTextPrivate", "{0} (private) [Shared by {1}]" },
				{"InvalidArguments", "Invalid arguments for command: {0}" },
				{"PlayersNotFound", "Unable to find player(s): {0}" }
			};
			lang.RegisterMessages(messages, this);
		}
		
		// get message from Lang
		string GetMessage(string key, string userId = null) => lang.GetMessage(key, this, userId);

		#endregion

		#region Loading/Unloading

		// on load
		void Loaded()
		{
			Instance = this;
			LoadDefaultMessages();
			// register both /bag and /bed since they're really ambiguous
			cmd.AddChatCommand("bag", this, "CommandDelegator");
			cmd.AddChatCommand("bed", this, "CommandDelegator");
			permission.RegisterPermission(PermCanUse, this);
			permission.RegisterPermission(PermNoShare, this);
			permission.RegisterPermission(PermCanSharePublic, this);
			permission.RegisterPermission(PermCanSharePrivate, this);
			permission.RegisterPermission(PermCanClear, this);
			LoadData();
		}

		// unload
		void Unload()
		{
			DestroyAllDummyBags();
			DestroyAllGUI();
			SaveData();
		}

		// server initialized
		void OnServerInitialized()
		{
			ValidateSharedBags();
		}

		// save data when server saves
		void OnServerSave()
		{
			timer.In(5f, () => SaveData());
		}

		#endregion

		#region Configuration

		// load default config
		bool LoadDefaultConfig()
		{
			data = new BagData();
			CheckConfig();
			return true;
		}

		// load data
		void LoadData()
		{
			bool dirty = false;
			Config.Settings.NullValueHandling = NullValueHandling.Include;
			try
			{
				data = Config.ReadObject<BagData>();
			}
			catch (Exception) { }
			dirty = CheckConfig();
			if (data.sharedBags == null)
				dirty |= LoadDefaultConfig();
			if (dirty)
				SaveData();
		}

		// write data container to config
		void SaveData()
		{
			Config.WriteObject(data);
		}

		// get value from config (handles type conversion)
		T GetConfig<T>(string group, string name, T value)
		{
			if (Config[group, name] == null)
			{
				Config[group, name] = value;
				SaveConfig();
			}
			return (T)Convert.ChangeType(Config[group, name], typeof(T));
		}

		// validate config
		bool CheckConfig()
		{
			bool dirty = false;
			if (data.ui == null)
			{
				data.ui = new UIConfig();
				dirty = true;
			}
			return dirty;
		}

		#endregion

		#region Command Handling

		[ConsoleCommand(GUIRespawnCommand)]
		void BSUI_Respawn(ConsoleSystem.Arg arg)
		{
			if (arg == null || !arg.HasArgs(2)) return;
			if (!CheckGUID(arg)) return;
			
			BasePlayer player = arg.Player();
			if (player == null) return;

			PlayerUI ui = FindPlayerUI(player);

			ulong bagId;
			if (!ulong.TryParse(arg.Args[1], out bagId))
			{
				PrintWarning("UI Error: Could not parse bagId for respawn");
				return;
			}
            NetworkableId id = new NetworkableId(bagId);

            if (!SleepingBag.SpawnPlayer(player, id))
			{
				BagUIInfo bag = ui.FindBagInfo(bagId);
				bag.message = "Failed to spawn at bag/bed";
				RefreshUI(ui, bagId);
				return;
			}
			ui.DestroyUI();
		}

		// validate guid
		bool CheckGUID(ConsoleSystem.Arg arg)
		{
			string msg = "Missing GUID";
			if (arg.Args != null && arg.Args[0] != null)
			{
				Guid g = new Guid(arg.Args[0]);
				if (g == EmptyGuid)
				{
					msg = "Empty GUID";
					goto end;
				}
				if (!playerUIs.Any(ui => ui.guid == g))
				{
					msg = "Invalid GUID";
					goto end;
				}
				return true;
			}
			// log guid validation failure as console warning
			// * this shouldn't get hit unless a player attempts to manually run a UI command, or the plugin breaks
			end:
			PrintWarning($"Invalid call to {arg.cmd.Name} by {arg.Player()?.displayName ?? "Unknown"}: {msg}");
			return false;
		}

		// command delegator
		void CommandDelegator(BasePlayer player, string command, string[] args)
		{
			if (!hasPermission(player, PermCanUse)) return;

			string message = "InvalidCommand";
			// assume args[0] is the command (beyond /bed)
			if (args != null && args.Length > 0)
				command = args[0];
			// shift arguments
			if (args != null)
			{
				if (args.Length > 1)
					args = args.Skip(1).ToArray();
				else
					args = new string[] { };
			}
			object[] opts = new object[] { command };
			if (Enum.IsDefined(typeof(Command), command))
			{
				Command cmd = (Command)Enum.Parse(typeof(Command), command);
				if ((!hasPermission(player, PermCanSharePublic) && (cmd == Command.share || cmd == Command.unshare)) ||
					(!hasPermission(player, PermCanSharePrivate) && (cmd == Command.sharewith || cmd == Command.unsharewith)))
				{
					return;
				}
				switch (cmd)
				{
					case Command.clear:
						if (hasPermission(player, PermCanClear))
							HandleClear(out message, out opts);
						else
							message = "NoClearPerm";
						break;
					case Command.share:
						HandleShare(player, true, null, out message, out opts);
						break;
					case Command.sharewith:
						if(args == null && args.Length == 0)
						{
							message = "InvalidArguments";
							break;
						}
						HandleShare(player, true, args, out message, out opts);
						break;
					case Command.status:
						HandleStatus(player, out message, out opts);
						break;
					case Command.unshare:
						HandleShare(player, false, null, out message, out opts);
						break;
					case Command.unsharewith:
						if (args == null && args.Length == 0)
						{
							message = "InvalidArguments";
							break;
						}
						HandleShare(player, false, args, out message, out opts);
						break;
					default:
						break;
				}
			}
			else
				ShowCommands(out message, out opts);
			if (message != null && message != "")
				SendMessage(player, message, opts);
		}

		// handle sharing/unsharing
		void HandleShare(BasePlayer player, bool share, string[] args, out string message, out object[] opts)
		{
			message = "ShareSuccess";
			opts = new object[] { "bag", share ? "shared" : "unshared" };

			bool with = args != null;
			bool all = false;
			List<ulong> players = new List<ulong>();
			List<string> names = new List<string>();
			if(with)
			{
				foreach (string s in args)
				{
					if (!share && s == "all")
					{
						all = true;
						break;
					}
					BasePlayer p = rust.FindPlayer(s);
					if (p == null)
					{
						names.Add(s);
						continue;
					}
					players.Add(p.userID);
				}
			}

			if(with && !all && (players.Count == 0 || players.Count != args.Length))
			{
				message = "PlayersNotFound";
				opts = new object[] { string.Join(", ", names.ToArray()) };
				return;
			}

			object entity;
			if (GetRaycastTarget(player, out entity) && entity is SleepingBag)
			{
				SleepingBag bag = entity as SleepingBag;
				if (bag.ShortPrefabName == BedPrefabName)
					opts[0] = "bed";
				if (bag.deployerUserID != player.userID && !isAdmin(player))
				{
					message = "CannotShareOther";
					opts[1] = "share";
					return;
				}
				else
				{
					if (share)
					{
						bag.secondsBetweenReuses = 0f;
						data.AddOrUpdateBag(bag.net.ID.Value, bag.deployerUserID, players);
						playerNameCache[player.userID] = player.displayName;
					}
					else
					{
						if (!data.RemoveOrUpdateBag(bag.net.ID.Value, players, all))
							message = "NotShared";
					}
				}
			}
			else
			{
				message = "NoBag";
				opts = new object[] { };
			}
		}

		// handle checking status of a bed/bag
		void HandleStatus(BasePlayer player, out string message, out object[] opts)
		{
			message = "Status";
			opts = new object[] { "bag", "unshared" };
			object entity;
			if (GetRaycastTarget(player, out entity) && entity is SleepingBag)
			{
				SleepingBag bag = entity as SleepingBag;
				if (bag.ShortPrefabName == BedPrefabName)
					opts[0] = "bed";
				SharedBagInfo i = data.sharedBags.FirstOrDefault(s => s.bagId == bag.net.ID.Value);
				if (i != null)
					opts[1] = "shared " + (i.isPublic ? " (public)" : " (private)");
			}
			else
			{
				message = "NoBag";
				opts = new object[] { };
			}
		}

		// handle clearing shared bag/beds
		void HandleClear(out string message, out object[] opts)
		{
			message = "ClearSuccess";
			opts = new object[] { data.sharedBags.Count };
			data.sharedBags.Clear();
			SaveData();
		}

		#endregion

		#region Hooks

		// on player death, wait for 1s then rebuild respawnInformation including shared beds/bags
		object OnPlayerDie(BasePlayer player, HitInfo hitinfo)
		{
			if (!data.HasSharedBags() || hasPermission(player, PermNoShare, false))
				return null;
			// after 1 second, send player updated respawn info
			timer.Once(1f, () => {
				using (RespawnInformation respawnInformation = Pool.Get<RespawnInformation>())
				{
					respawnInformation.spawnOptions = Pool.Get<List<RespawnInformation.SpawnOptions>>();
					SleepingBag[] sleepingBagArray = SleepingBag.FindForPlayer(player.userID, true);
					for (int i = 0; i < (int)sleepingBagArray.Length; i++)
					{
						SleepingBag sleepingBag = sleepingBagArray[i];
						if (data.sharedBags.Count(s => s.bagId == sleepingBag.net.ID.Value) > 0 || dummyBags.ContainsKey(sleepingBag.net.ID.Value))
							continue;
						RespawnInformation.SpawnOptions d = Pool.Get<RespawnInformation.SpawnOptions>();
                        d.id = new NetworkableId(sleepingBag.net.ID.Value);
						d.name = sleepingBag.niceName;
						d.type = RespawnInformation.SpawnOptions.RespawnType.SleepingBag;
						d.unlockSeconds = sleepingBag.unlockSeconds;
						respawnInformation.spawnOptions.Add(d);
					}
					respawnInformation.previousLife = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(player.userID);
					respawnInformation.fadeIn = (respawnInformation.previousLife == null ? false : respawnInformation.previousLife.timeDied > (Epoch.Current - 5));
					player.ClientRPCPlayer(null, player, "OnRespawnInformation", respawnInformation);
				}
			});
			// after 6 seconds, build/display shared bag/bed UI
			if (data.HasSharedBags())
				timer.Once(6f, () => ShowGUI(player));
			return null;
		}

		// on respawn, destroy dummy bags and gui
		object OnPlayerRespawn(BasePlayer player)
		{
			DestroyDummyBags(player);
			DestroyGUI(player);
			return null;
		}

		#endregion

		#region GUI

		// find or create a PlayerUI
		PlayerUI FindPlayerUI(BasePlayer player)
		{
			PlayerUI ui = playerUIs.FirstOrDefault(u => u.UserId == player.userID);
			if (ui == null)
				playerUIs.Add(ui = new PlayerUI(player));
			return ui;
		}

        void ShowGUI(BasePlayer player)
        {
            PlayerUI ui = FindPlayerUI(player);
            bool dirty = false;
            int counter = 0;

            foreach (SharedBagInfo entry in data.sharedBags.Where(i => i.isPublic || i.sharedWith.Contains(player.userID)))
            {
                SleepingBag[] sleepingBags = SleepingBag.FindForPlayer(entry.owner, true);
                SleepingBag sleepingBag = sleepingBags.FirstOrDefault(bag => bag.net.ID.Value == entry.bagId);

                if (sleepingBag == null)
                {
                    dirty = true; // no longer a valid shared bag
                    continue;
                }

                ulong bagId;
                if (SpawnDummyBag(sleepingBag, player, out bagId))
                {
                    string messageName = "SharedBagNameText";
                    if (!entry.isPublic)
                        messageName = "SharedBagNameTextPrivate";
                    string bagName = string.Format(GetMessage(messageName, player.UserIDString), new object[] { sleepingBag.niceName, GetPlayerName(sleepingBag.deployerUserID) });
                    CreateRespawnButton(ui, bagId, bagName, counter++);
                }
            }

            // save changes to shared mappings
            if (dirty)
                ValidateSharedBags();
        }

        void RefreshUI(PlayerUI ui, ulong bagId)
		{
			BagUIInfo bag = ui.FindBagInfo(bagId);
			if (bag == null || !ui.IsPanelOpen(bagId)) return;

			CreateRespawnButton(ui, bag.id, bag.name, bag.index);
		}

		// build respawn button
		void CreateRespawnButton(PlayerUI ui, ulong bagId, string bagName, int index)
		{
			BagUIInfo bag = new BagUIInfo()
			{
				id = bagId,
				index = index,
				name = bagName
			};
			// set up button position
			float xPosMin = data.ui.screenMarginX;
			float yPosMin = data.ui.screenMarginY + ((data.ui.verticalSpacer + data.ui.buttonHeight) * index);
			float xPosMax = xPosMin + data.ui.buttonWidth;
			float yPosMax = yPosMin + data.ui.buttonHeight;

			Vector2 buttonAnchorMin = new Vector2(xPosMin, yPosMin);
			Vector2 buttonAnchorMax = new Vector2(xPosMax, yPosMax);

			// set up icon layout
			float iconXMin = data.ui.iconPaddingX - data.ui.iconWidth;
			float iconYMin = data.ui.iconPaddingY;
			float iconXMax = data.ui.iconPanelWidth - data.ui.iconWidth;
			float iconYMax = 1f - iconYMin;

			Vector2 iconPosMin = new Vector2(iconXMin, iconYMin);
			Vector2 iconPosMax = new Vector2(iconXMax, iconYMax);

			// set up text layout
			float spawnTextYMin = data.ui.spawnTextPaddingY;

			Vector2 spawnTextPosMin = new Vector2(iconXMax, spawnTextYMin);
			Vector2 spawnTextPosMax = Vector2.one;

			float bagNameTextYMin = data.ui.bagNameTextPaddingY;

			Vector2 bagNameTextPosMin = new Vector2(iconXMax, bagNameTextYMin);
			Vector2 bagNameTextPosMax = new Vector2(1f, spawnTextYMin);

			string headerText = GetMessage("SharedHeaderText", ui.Player?.UserIDString);

			// build GUI elements

			string elementName = UIElementPrefix + bagId;
			string message = ui.Message(bagId);

			CuiElementContainer container = UI.CreateElementContainer(elementName, data.ui.buttonColor, buttonAnchorMin, buttonAnchorMax);
			UI.CreateLabel(ref container, elementName, headerText, 16, spawnTextPosMin, spawnTextPosMax, TextAnchor.MiddleLeft);
			UI.CreateLabel(ref container, elementName, bagName, 12, bagNameTextPosMin, bagNameTextPosMax, TextAnchor.UpperLeft, "RobotoCondensed-Regular.ttf");
			UI.CreateImage(ref container, elementName, data.ui.bagIcon, data.ui.bagIconColor, iconPosMin, iconPosMax);
			UI.CreateButton(ref container, elementName, new Color(1f, 1f, 1f, 0.05f), string.Empty, 1, Vector2.zero, Vector2.one, ui.BuildCommand(GUIRespawnCommand, bagId));

			ui.CreateUI(bag, container);
			if (!string.IsNullOrEmpty(message))
				OverlayMessageUI(ui, bagId, message, buttonAnchorMin, buttonAnchorMax);
		}

		// create a message overlay on a button
		void OverlayMessageUI(PlayerUI ui, ulong id, string message, Vector2 aMin, Vector2 aMax, float displayTime = 5f)
		{
			string panelName = UIElementPrefix + id + "_Message";
			CuiElementContainer container = UI.CreateElementContainer(panelName, new Color(0.7f, 0.3f, 0.3f, 0.9f), aMin, aMax, fadeIn: 0f);
			UI.CreateLabel(ref container, panelName, $"<color=white>{message}</color>", 14, Vector2.zero, Vector2.one, fadeIn: 0f);
			ui.CreateMessageUI(id, container);
			timer.In(displayTime, () => ui.DestroyMessageUI(id));
		}

		// destroy a player's GUI elements
		void DestroyGUI(BasePlayer player, bool kill = false)
		{
			if (kill)
				FindPlayerUI(player).Kill();
			else
				FindPlayerUI(player).DestroyUI();
		}

		// destroy all player GUI elements
		void DestroyAllGUI()
		{
			foreach (BasePlayer player in BasePlayer.activePlayerList)
				DestroyGUI(player, true);
		}

		#endregion

		#region Helper Procedures

		// spawn a dummy bag at location of shared bag/bed to be used as a respawn point
		bool SpawnDummyBag(SleepingBag bag, BasePlayer player, out ulong bagId)
		{
			bagId = 0;
			BaseEntity entity = GameManager.server.CreateEntity(bag.PrefabName, bag.transform.position, bag.transform.rotation, false);
			entity.limitNetworking = true;
			entity.Spawn();
			if (entity != null && entity is SleepingBag)
			{
				SleepingBag newBag = entity as SleepingBag;
				newBag.model.enabled = false;
				newBag.deployerUserID = player.userID;
				newBag.secondsBetweenReuses = 0f;
				bagId = newBag.net.ID.Value;
				dummyBags[bagId] = player.userID;
				return true;
			}
			return false;
		}
		
		// Destroy all dummy bags for a player
		void DestroyDummyBags(BasePlayer player)
		{
			ulong[] bags = dummyBags.Where(x => x.Value == player.userID).Select(pair => pair.Key).ToArray();
			if (bags == null || bags.Length == 0)
				return;
			foreach (ulong bagId in bags)
			{
                NetworkableId id = new NetworkableId(bagId);
                SleepingBag.DestroyBag(player.userID, id);
            }
        }

        // Destroy all dummy bags
        void DestroyAllDummyBags()
        {
            foreach (KeyValuePair<ulong, ulong> entry in dummyBags)
            {
                SleepingBag[] bags = SleepingBag.FindForPlayer(entry.Value, true);
                foreach (SleepingBag bag in bags)
                {
                    if (bag != null)
                        bag.Kill(BaseNetworkable.DestroyMode.None);
                }
            }
            dummyBags.Clear();
        }

        // validate shared bag list
        void ValidateSharedBags()
        {
            if (!data.HasSharedBags()) return;

            List<ulong> toRemove = new List<ulong>();

            // Check each bag in the shared bags list and remove any invalid bags
            foreach (SharedBagInfo entry in data.sharedBags)
            {
                SleepingBag[] sleepingBags = SleepingBag.FindForPlayer(entry.owner, true);
                bool valid = false;
                foreach (SleepingBag bag in sleepingBags)
                {
                    if (bag.net.ID.Value == entry.bagId)
                    {
                        valid = true;
                        break;
                    }
                }
                if (!valid)
                {
                    toRemove.Add(entry.bagId); // No longer a valid shared bag
                }
            }

            if (data.sharedBags.RemoveWhere(i => toRemove.Contains(i.bagId)) > 0)
            {
                Puts(GetMessage("Prefix") + string.Format(GetMessage("ValidateStats"), new object[] { toRemove.Count }));
                SaveData();
            }
        }

        // handle raycast from player
        bool GetRaycastTarget(BasePlayer player, out object closestEntity)
		{
			closestEntity = false;

			RaycastHit hit;
			if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 5f))
				return false;

			closestEntity = hit.GetEntity();
			return true;
		}

		// get a player name (using cache if possible)
		string GetPlayerName(ulong userID)
		{
			if (playerNameCache.ContainsKey(userID))
				return playerNameCache[userID];
			else
			{
				BasePlayer player = BasePlayer.FindByID(userID);
				if(player == null)
					player = BasePlayer.FindSleeping(userID);

				if (player != null)
				{
					playerNameCache[userID] = player.displayName;
					return player.displayName;
				}
			}
			return "unknown";
		}

		// check if player is an admin
		private static bool isAdmin(BasePlayer player)
		{
			if (player?.net?.connection == null) return true;
			return player.net.connection.authLevel > 0;
		}

		// check if player has permission or is an admin
		private bool hasPermission(BasePlayer player, string permname, bool allowAdmin = true)
		{
			return (allowAdmin && isAdmin(player)) || permission.UserHasPermission(player.UserIDString, permname);
		}

		#endregion

		#region Messaging

		// send reply to a player
		void SendMessage(BasePlayer player, string message, object[] options = null)
		{
			string msg = GetMessage(message, player.UserIDString);
			if (options != null && options.Length > 0)
				msg = String.Format(msg, options);
			SendReply(player, GetMessage("Prefix", player.UserIDString) + msg);
		}

		// show list of valid commands
		void ShowCommands(out string message, out object[] opts)
		{
			message = "CommandList";
			opts = new object[] { string.Join(", ", Enum.GetValues(typeof(Command)).Cast<Command>().Select(x => x.ToString()).ToArray()) };
		}

		#endregion

		#region Subclasses

		// config data
		class BagData
		{
			public HashSet<SharedBagInfo> sharedBags = new HashSet<SharedBagInfo>();
			public UIConfig ui;

			public void AddOrUpdateBag(ulong bagID, ulong playerID, List<ulong> players)
			{
				bool isPublic = players == null || players.Count == 0;
				SharedBagInfo i = sharedBags.FirstOrDefault(s => s.bagId == bagID);
				if (i == null)
					sharedBags.Add(i = new SharedBagInfo(bagID, playerID, isPublic));
				if (!i.isPublic && !isPublic)
					i.sharedWith.UnionWith(players);
			}
			
			public bool RemoveOrUpdateBag(ulong bagID, List<ulong> players, bool all = false)
			{
				if (sharedBags == null || sharedBags.Count == 0) return false;
				SharedBagInfo i = sharedBags.FirstOrDefault(s => s.bagId == bagID);
				if (i == null)
					return false;
				if(i.isPublic || all)
					return sharedBags.Remove(i);
				i.sharedWith.ExceptWith(players);
				if (i.sharedWith.Count == 0)
					sharedBags.Remove(i);
				return true;
			}

			public bool HasSharedBags()
			{
				return (sharedBags != null && sharedBags.Count > 0);
			}
		}

		// shared bag details
		class SharedBagInfo
		{
			public ulong bagId;
			public ulong owner;
			public bool isPublic { private set; get; } = false;
			public HashSet<ulong> sharedWith = new HashSet<ulong>();
			public SharedBagInfo(ulong bagId, ulong owner, bool isPublic)
			{
				this.bagId = bagId;
				this.owner = owner;
				this.isPublic = isPublic;
			}
		}

		// ui config
		class UIConfig
		{
			// note: any precision beyond 3 is likely visually insignificant
			public float buttonWidth = 0.25f;
			public float buttonHeight = 0.09722222222222222222222222222222f;
			public float screenMarginX = 0.025f;
			public float screenMarginY = 0.04444444444444444444444444444444f;
			public float verticalSpacer = 0.02222222222222222222222222222222f;
			public float iconWidth = 0.03854166666666666666666666666667f;
			public float iconPanelWidth = 0.21875f;
			public float iconPaddingX = 0.07083333333333333333333333333333f;
			public float iconPaddingY = 0.16190476190476190476190476190476f;
			public float spawnTextPaddingY = 0.57142857142857142857142857142857f;
			public float bagNameTextPaddingY = 0.3047619047619047619047619047619f;
			public string buttonColor = UI.FormatRGBA(new Color(0.5f, 0.4f, 0.2f, 0.9f));
			public string bagIconColor = UI.FormatRGBA(new Color(1f, 1f, 1f, 0.6f));
			public string bagIcon = "assets/icons/sleepingbag.png";
		}

		// bag ui details (for refresh)
		class BagUIInfo
		{
			public ulong id;
			public string name;
			public int index = -1;
			public string message = string.Empty;
		}

		// per-player UI manager
		class PlayerUI
		{
			// use GUID to manage console commands for the UI (to prevent players from being able to execute commands directly)
			internal Guid guid = Guid.NewGuid();
			// player reference
			BasePlayer _player;
			// player id/name container (for lookup)
			internal PlayerNameID nameId;
			// player reference delegator
			internal BasePlayer Player { get { TryResolvePlayer(); return _player; } }
			// user ID delegator
			internal ulong UserId { get { return nameId != null ? nameId.userid : 0UL; } }
			// map of panels and child element names
			Dictionary<ulong, List<string>> elements = new Dictionary<ulong, List<string>>();
			List<BagUIInfo> bags = new List<BagUIInfo>();

			// constructor
			public PlayerUI(BasePlayer player)
			{
				_player = player;
				nameId = new PlayerNameID()
				{
					userid = player.userID,
					username = player.displayName
				};
			}

			// basic player resolution
			void TryResolvePlayer()
			{
				if (_player == null && nameId != null)
					_player = BasePlayer.FindByID(nameId.userid);
			}
			// handle UI creation
			internal void CreateUI(BagUIInfo bag, CuiElementContainer container)
			{
				DestroyUI(bag.id);
				bags.Add(bag);
				UI.RenameComponents(container);
				elements[bag.id] = container.Select(e => e.Name).ToList();
				CuiHelper.AddUi(Player, container);
			}
			internal void CreateMessageUI(ulong id, CuiElementContainer container)
			{
				UI.RenameComponents(container);
				elements[id].AddRange(container.Select(e => e.Name).ToList());
				CuiHelper.AddUi(Player, container);
			}
			// destroy all UI elements
			internal void DestroyUI()
			{
				foreach (ulong bagId in elements.Keys.ToList())
					DestroyUI(bagId);
			}
			// destroy a specific UI panel
			internal void DestroyUI(ulong bagId)
			{
				List<string> children;
				if (elements.TryGetValue(bagId, out children))
					foreach (string child in children)
						CuiHelper.DestroyUi(Player, child);
				CuiHelper.DestroyUi(Player, UIElementPrefix + bagId.ToString());
				elements.Remove(bagId);
				bags.RemoveAll(b => b.id == bagId);
			}
			internal void DestroyMessageUI(ulong bagId)
			{
				string elementName = UIElementPrefix + bagId + "_Message";
				CuiHelper.DestroyUi(Player, elementName);
				if(elements.ContainsKey(bagId))
					elements[bagId].RemoveAll(e => e == elementName);
			}
			// is UI open
			public bool IsOpen => elements.Count > 0;
			// is panel open
			public bool IsPanelOpen(ulong bagId) => elements.ContainsKey(bagId);
			public List<ulong> BagIds => elements.Keys.ToList();
			public BagUIInfo FindBagInfo(ulong bagId) => bags.FirstOrDefault(b => b.id == bagId);
			public bool HasMessage(ulong bagId) => !string.IsNullOrEmpty(Message(bagId));
			public string Message(ulong bagId) => FindBagInfo(bagId)?.message ?? string.Empty;
			// destroy this
			internal void Kill()
			{
				DestroyUI();
				_player = null;
				Instance.playerUIs.Remove(this);
			}
			// build UI command by inserting GUID as first parameter
			internal string BuildCommand(params object[] command)
			{
				if (command == null || command.Length == 0) return null;
				List<string> split = command.Where(o => o != null).Select(o => o.ToString()).ToList();
				if (split.Count == 0) return null;
				split.Insert(1, guid.ToString());
				return string.Join(" ", split.ToArray());
			}
		}

		// UI build helper
		class UI
		{
			const string format = "F4";
			static string Format(float f) => f.ToString(format);
			static string Format(Vector2 v) => $"{Format(v.x)} {Format(v.y)}";
			public static string FormatRGBA(Color color) => $"{Format(color.r)} {Format(color.g)} {Format(color.b)} {Format(color.a)}";
			public static string FormatHex(Color color) => $"#{ColorUtility.ToHtmlStringRGBA(color)}";
			
			internal static string AsString(object o)
			{
				if (o is string) return (string)o;
				if (o is Color) return FormatRGBA((Color)o);
				if (o is Vector2) return Format((Vector2)o);
				if (o is float) return Format((float)o);
				return o.ToString();
			}

			public static CuiElementContainer CreateElementContainer(string panelName, object color, object aMin, object aMax, bool useCursor = true, float fadeOut = 0f, float fadeIn = 0.25f)
			{
				return CreateElementContainer(panelName, "", color, aMin, aMax, useCursor, fadeOut, fadeIn);
			}
			public static CuiElementContainer CreateElementContainer(string panelName, string background, object color, object aMin, object aMax, bool useCursor = true, float fadeOut = 0f, float fadeIn = 0.25f)
			{
				return CreateElementContainer("Overlay", panelName, background, color, aMin, aMax, useCursor, fadeOut, fadeIn);
			}
			public static CuiElementContainer CreateElementContainer(string parent, string panelName, string background, object color, object aMin, object aMax, bool useCursor = true, float fadeOut = 0f, float fadeIn = 0.25f)
			{
				return new CuiElementContainer()
				{
					{
						new CuiPanel
						{
							Image = { Color = AsString(color), Sprite = string.IsNullOrEmpty(background) ? "assets/content/ui/ui.background.tile.psd" : background, FadeIn = fadeIn },
							RectTransform = { AnchorMin = AsString(aMin), AnchorMax = AsString(aMax) },
							CursorEnabled = useCursor, FadeOut = fadeOut
						},
						new CuiElement().Parent = parent,
						panelName
					}
				};
			}
			public static void CreatePanel(ref CuiElementContainer container, string panelName, object color, object aMin, object aMax, bool cursor = false)
			{
				container.Add(new CuiPanel
				{
					Image = { Color = AsString(color), FadeIn = 0.25f },
					RectTransform = { AnchorMin = AsString(aMin), AnchorMax = AsString(aMax) },
					CursorEnabled = cursor
				},
				panelName);
			}
			public static void CreateLabel(ref CuiElementContainer container, string panelName, string text, int size, object aMin, object aMax, TextAnchor align = TextAnchor.MiddleCenter, string font = "RobotoCondensed-Bold.ttf", float fadeIn = 0.25f)
			{
				container.Add(new CuiLabel
				{
					Text = { FontSize = size, Align = align, Text = text, Font = font, FadeIn = fadeIn },
					RectTransform = { AnchorMin = AsString(aMin), AnchorMax = AsString(aMax) }
				},
				panelName);

			}
			public static void CreateButton(ref CuiElementContainer container, string panelName, object color, string text, int size, object aMin, object aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
			{
				container.Add(new CuiButton
				{
					Button = { Color = AsString(color), Command = command, FadeIn = 0.25f },
					RectTransform = { AnchorMin = AsString(aMin), AnchorMax = AsString(aMax) },
					Text = { Text = text, FontSize = size, Align = align, FadeIn = 0.25f }
				},
				panelName);
			}
			public static void CreateImage(ref CuiElementContainer container, string panelName, string png, object color, object aMin, object aMax, float fadeIn = 0.25f)
			{
				container.Add(new CuiElement
				{
					Name = CuiHelper.GetGuid(),
					Parent = panelName,
					Components =
					{
						new CuiImageComponent() {
							Sprite = png,
							Color = AsString(color),
							FadeIn = fadeIn
						},
						new CuiRectTransformComponent { AnchorMin = AsString(aMin), AnchorMax = AsString(aMax) }
					}
				});
			}
			public static void RenameComponents(CuiElementContainer container)
			{
				foreach (var element in container)
				{
					if (element.Name == "AddUI CreatedPanel")
						element.Name = CuiHelper.GetGuid();
				}
			}
		}

		#endregion
	}
}

// --- End of file: BedShare.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bgrade ---
// --- Original File Path: B/BGrade/BGrade.cs ---

using System;
using System.Linq;
using System.Collections.Generic;

using Rust;
using UnityEngine;

using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Plugins.BGradeExt;

namespace Oxide.Plugins
{
    [Info("BGrade", "Ryan / Rustoria.co", "1.1.6")]
    [Description("Auto update building blocks when placed")]
    public class BGrade : RustPlugin
    {
        #region Declaration

        public static BGrade Instance;
        private ListHashSet<string> _registeredPermissions = new ListHashSet<string>();
        private Dictionary<Vector3, int> _lastAttacked = new Dictionary<Vector3, int>();

        #endregion

        #region Config

        private bool ConfigChanged;

        // Timer settings
        private bool AllowTimer;
        private int MaxTimer;
        private int DefaultTimer;

        // Last attack settings
        private bool CheckLastAttack;
        private int UpgradeCooldown;

        // Command settings
        private List<string> ChatCommands;
        private List<string> ConsoleCommands;

        // Refund settings
        private bool RefundOnBlock;

        // Player Component settings
        private bool DestroyOnDisconnect;

        protected override void LoadDefaultConfig() => PrintWarning("Generating default configuration file...");

        private void InitConfig()
        {
            AllowTimer = GetConfig(true, "Timer Settings", "Enabled");
            DefaultTimer = GetConfig(30, "Timer Settings", "Default Timer");
            MaxTimer = GetConfig(180, "Timer Settings", "Max Timer");
            ChatCommands = GetConfig(new List<string>
            {
                "bgrade",
                "grade"
            }, "Command Settings", "Chat Commands");
            ConsoleCommands = GetConfig(new List<string>
            {
                "bgrade.up"
            }, "Command Settings", "Console Commands");
            CheckLastAttack = GetConfig(true, "Building Attack Settings", "Enabled");
            UpgradeCooldown = GetConfig(30, "Building Attack Settings", "Cooldown Time");
            RefundOnBlock = GetConfig(true, "Refund Settings", "Refund on Block");
            DestroyOnDisconnect = GetConfig(false, "Destroy Data on Player Disconnect (for high pop servers)");

            if (ConfigChanged)
            {
                PrintWarning("Updated configuration file with new/changed values.");
                SaveConfig();
            }
        }

        private T GetConfig<T>(T defaultVal, params string[] path)
        {
            var data = Config.Get(path);
            if (data != null)
            {
                return Config.ConvertValue<T>(data);
            }

            Config.Set(path.Concat(new object[] { defaultVal }).ToArray());
            ConfigChanged = true;
            return defaultVal;
        }

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Permission"] = "You don't have permission to use that command",

                ["Error.InvalidArgs"] = "Invalid arguments, please use /{0} help",
                ["Error.Resources"] = "You don't have enough resources to upgrade.",
                ["Error.InvalidTime"] = "Please enter a valid time. '<color=orange>{0}</color>' is not recognised as a number.",
                ["Error.TimerTooLong"] = "Please enter a time that is below the value of <color=orange>{0}</color>.",

                ["Notice.SetGrade"] = "Automatic upgrading is now set to grade <color=orange>{0}</color>.",
                ["Notice.SetTime"] = "The disable timer is now set to <color=orange>{0}</color>.",
                ["Notice.Disabled"] = "Automatic upgrading is now disabled.",
                ["Notice.Disabled.Auto"] = "Automatic upgrading has been automatically disabled.",
                ["Notice.Time"] = "It'll automatically disable in <color=orange>{0}</color> seconds.",

                ["Command.Help"] = "<color=orange><size=16>BGrade Command Usages</size></color>",
                ["Command.Help.0"] = "/{0} 0 - Disables BGrade",
                ["Command.Help.1"] = "/{0} 1 - Upgrades to Wood upon placement",
                ["Command.Help.2"] = "/{0} 2 - Upgrades to Stone upon placement",
                ["Command.Help.3"] = "/{0} 3 - Upgrades to Metal upon placement",
                ["Command.Help.4"] = "/{0} 4 - Upgrades to Armoured upon placement",
                ["Command.Help.T"] = "/{0} t <seconds> - Time until BGrade is disabled",

                ["Command.Settings"] = "<color=orange><size=16>Your current settings</size></color>",
                ["Command.Settings.Timer"] = "Timer: <color=orange>{0}</color> seconds",
                ["Command.Settings.Grade"] = "Grade: <color=orange>{0}</color>",

                ["Words.Disabled"] = "disabled"
            }, this);
        }

        #endregion

        #region Methods

        private void RegisterPermissions()
        {
            _registeredPermissions = new ListHashSet<string>(  );

            for (var i = 1; i < 5; i++)
            {
                RegisterPermission( Name.ToLower() + "." + i );
            }

            RegisterPermission( Name.ToLower() + "." + "nores" );
            RegisterPermission( Name.ToLower() + "." + "all" );
        }

        private void RegisterPermission( string permissionName )
        {
            if ( !_registeredPermissions.Contains( permissionName ) )
            {
                _registeredPermissions.Add( permissionName );
            }

            permission.RegisterPermission( permissionName, this );
        }

        private void RegisterCommands()
        {
            foreach (var command in ChatCommands)
            {
                cmd.AddChatCommand(command, this, BGradeCommand);
            }

            foreach (var command in ConsoleCommands)
            {
                cmd.AddConsoleCommand(command, this, nameof(BGradeUpCommand));
            }
        }

        private void DestroyAll<T>() where T : MonoBehaviour
        {
            foreach (var type in UnityEngine.Object.FindObjectsOfType<T>())
            {
                UnityEngine.Object.Destroy(type);
            }
        }

        private void DealWithHookResult(BasePlayer player, BuildingBlock buildingBlock, int hookResult, GameObject gameObject)
        {
            if (hookResult <= 0)
            {
                return;
            }

            if (RefundOnBlock)
            {
                foreach (var itemToGive in buildingBlock.BuildCost())
                {
                    player.GiveItem(ItemManager.CreateByItemID(itemToGive.itemid, (int)itemToGive.amount));
                }
            }

            gameObject.GetComponent<BaseEntity>().Kill();
        }

        private string TakeResources(BasePlayer player, int playerGrade, BuildingBlock buildingBlock, out Dictionary<int, int> items)
        {
            var itemsToTake = new Dictionary<int, int>();

            List<ItemAmount> costToBuild = null;
            foreach (var grade in buildingBlock.blockDefinition.grades)
            {
                if (grade.gradeBase.type == (BuildingGrade.Enum) playerGrade)
                {
                    costToBuild = grade.CostToBuild();
                    break;
                }
            }

            if (costToBuild == null)
            {
                PrintError($"COULDN'T FIND COST TO BUILD WITH GRADE: {playerGrade} FOR {buildingBlock.PrefabName}");
                items = itemsToTake;
                return "Error.Resources".Lang(player.UserIDString);
            }

            foreach (var itemAmount in costToBuild)
            {
                if (!itemsToTake.ContainsKey(itemAmount.itemid))
                {
                    itemsToTake.Add(itemAmount.itemid, 0);
                }

                itemsToTake[itemAmount.itemid] += (int)itemAmount.amount;
            }

            var canAfford = true;
            foreach (var itemToTake in itemsToTake)
            {
                if (!player.HasItemAmount(itemToTake.Key, itemToTake.Value))
                {
                    canAfford = false;
                }
            }

            items = itemsToTake;
            return canAfford ? null : "Error.Resources".Lang(player.UserIDString);
        }

        private void CheckLastAttacked()
        {
            foreach (var lastAttackEntry in _lastAttacked.ToList())
            {
                if (!WasAttackedRecently(lastAttackEntry.Key))
                {
                    _lastAttacked.Remove(lastAttackEntry.Key);
                }
            }
        }

        private bool WasAttackedRecently(Vector3 position)
        {
            int time;
            if (!_lastAttacked.TryGetValue(position, out time))
            {
                return false;
            }

            if (time < Facepunch.Math.Epoch.Current)
            {
                return true;
            }

            return false;
        }

        #endregion

        #region BGrade Player

        private class BGradePlayer : FacepunchBehaviour
        {
            public static Dictionary<BasePlayer, BGradePlayer> Players = new Dictionary<BasePlayer, BGradePlayer>();

            private BasePlayer _player;
            private Timer _timer;
            private int _grade;
            private int _time;

            public void Awake()
            {
                var attachedPlayer = GetComponent<BasePlayer>();
                if ( attachedPlayer == null || !attachedPlayer.IsConnected )
                {
                    return;
                }

                _player = attachedPlayer;
                Players[_player] = this;

                _time = GetTime(false);
            }

            public int GetTime(bool updateTime = true)
            {
                if (!Instance.AllowTimer)
                {
                    return 0;
                }

                if (updateTime)
                {
                    UpdateTime();
                }

                return _time != 0 ? _time : Instance.DefaultTimer;
            }

            public void UpdateTime()
            {
                if (_time <= 0)
                {
                    return;
                }

                DestroyTimer();

                SetTimer(Instance.timer.Once(_time, () =>
                {
                    _grade = 0;
                    DestroyTimer();
                    _player.ChatMessage("Notice.Disabled.Auto".Lang(_player.UserIDString));
                }));
            }

            public int GetGrade() => _grade;

            public bool IsTimerValid
            {
                get
                {
                    return _timer != null && !_timer.Destroyed;
                }
            }

            private void SetTimer(Timer timer)
            {
                _timer = timer;
            }

            public void SetGrade(int newGrade)
            {
                _grade = newGrade;
            }

            public void SetTime(int newTime)
            {
                _time = newTime;
            }

            public void DestroyTimer()
            {
                _timer?.Destroy();
                _timer = null;
            }

            public void Destroy()
            {
                Destroy(this);
            }

            public void OnDestroy()
            {
                if ( Players.ContainsKey( _player ) )
                {
                    Players.Remove( _player );
                }
            }
        }

        #endregion

        #region Hooks

        private void Init()
        {
            Instance = this;

            InitConfig();
            RegisterCommands();
            RegisterPermissions();

            if (!CheckLastAttack)
            {
                Unsubscribe(nameof(OnEntityDeath));
                Unsubscribe(nameof(OnServerSave));
            }

            if (!DestroyOnDisconnect)
            {
                Unsubscribe(nameof(OnPlayerDisconnected));
            }
        }

        private void OnServerSave()
        {
            CheckLastAttacked();
        }

        private void Unload()
        {
            Instance = null;
            DestroyAll<BGradePlayer>();
            BGradePlayer.Players.Clear();
        }

        private void OnEntityBuilt(Planner plan, GameObject gameObject)
        {
            var player = plan?.GetOwnerPlayer();
            if (player == null)
            {
                return;
            }

            if ( plan.isTypeDeployable )
            {
                return;
            }

            var buildingBlock = gameObject.GetComponent<BuildingBlock>();
            if ( buildingBlock == null )
            {
                return;
            }

            if (!player.CanBuild())
            {
                return;
            }

            if ( !player.HasAnyPermission( _registeredPermissions ) )
            {
                return;
            }

            BGradePlayer bgradePlayer;
            if ( !BGradePlayer.Players.TryGetValue( player, out bgradePlayer ) )
            {
                return;
            }

            var playerGrade = bgradePlayer.GetGrade();
            if (playerGrade == 0)
            {
                return;
            }

            if (!player.HasPluginPerm("all") && !player.HasPluginPerm(playerGrade.ToString()))
            {
                return;
            }

            var hookCall = Interface.Call("CanBGrade", player, playerGrade, buildingBlock, plan);

            if (hookCall is int)
            {
                DealWithHookResult(player, buildingBlock, (int) hookCall, gameObject);
                return;
            }

            if (playerGrade < (int) buildingBlock.grade || buildingBlock.blockDefinition.grades[playerGrade] == null)
            {
                return;
            }

            if (CheckLastAttack && WasAttackedRecently(buildingBlock.transform.position))
            {
                return;
            }

            if (Interface.Call("OnStructureUpgrade", buildingBlock, player, (BuildingGrade.Enum) playerGrade) != null)
            {
                return;
            }

            if (!player.HasPluginPerm("nores"))
            {
                Dictionary<int, int> itemsToTake;
                var resourceResponse = TakeResources(player, playerGrade, buildingBlock, out itemsToTake);
                if (!string.IsNullOrEmpty(resourceResponse))
                {
                    player.ChatMessage(resourceResponse);
                    return;
                }

                foreach (var itemToTake in itemsToTake)
                {
                    player.TakeItem(itemToTake.Key, itemToTake.Value);
                }
            }

            if (AllowTimer)
            {
                bgradePlayer.UpdateTime();
            }

            buildingBlock.SetGrade((BuildingGrade.Enum)playerGrade);
            buildingBlock.SetHealthToMax();
            buildingBlock.StartBeingRotatable();
            buildingBlock.SendNetworkUpdate();
            buildingBlock.UpdateSkin();
            buildingBlock.ResetUpkeepTime();
            buildingBlock.GetBuilding()?.Dirty();
        }

        private object OnPayForPlacement( BasePlayer player, Planner planner, Construction component )
        {
            if ( planner.isTypeDeployable )
            {
                return null;
            }

            if ( !BGradePlayer.Players.ContainsKey( player ) )
            {
                return null;
            }

            if ( !player.HasPluginPerm( "nores" ) )
            {
                return null;
            }

            var bgradePlayer = BGradePlayer.Players[player];
            if ( bgradePlayer.GetGrade() == 0 )
            {
                return null;
            }

            return false;
        }

        private void OnEntityDeath(BuildingBlock buildingBlock, HitInfo info)
        {
            var attacker = info?.InitiatorPlayer;
            if (attacker == null)
            {
                return;
            }

            if (info.damageTypes.GetMajorityDamageType() == DamageType.Explosion)
            {
                _lastAttacked[buildingBlock.transform.position] = Facepunch.Math.Epoch.Current + UpgradeCooldown;
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            BGradePlayer bgradePlayer;
            if ( !BGradePlayer.Players.TryGetValue( player, out bgradePlayer ) )
            {
                return;
            }

            bgradePlayer.Destroy();
        }

        #endregion

        #region Commands

        private void BGradeCommand(BasePlayer player, string command, string[] args)
        {
            if (!player.HasAnyPermission(_registeredPermissions))
            {
                player.ChatMessage("Permission".Lang(player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                player.ChatMessage("Error.InvalidArgs".Lang(player.UserIDString, command));
                return;
            }

            var chatMsgs = new List<string>();

            switch (args[0].ToLower())
            {
                case "0":
                    {
                        player.ChatMessage("Notice.Disabled".Lang(player.UserIDString));
                        BGradePlayer bgradePlayer;
                        if ( BGradePlayer.Players.TryGetValue( player, out bgradePlayer ) )
                        {
                            bgradePlayer.DestroyTimer();
                            bgradePlayer.SetGrade( 0 );
                        }
                        return;
                    }

                case "1":
                case "2":
                case "3":
                case "4":
                    {
                        if (!player.HasPluginPerm("all") && !player.HasPluginPerm(args[0]))
                        {
                            player.ChatMessage("Permission".Lang(player.UserIDString));
                            return;
                        }

                        var grade = Convert.ToInt32(args[0]);

                        BGradePlayer bgradePlayer;
                        if ( !BGradePlayer.Players.TryGetValue( player, out bgradePlayer ) )
                        {
                            bgradePlayer = player.gameObject.AddComponent<BGradePlayer>();
                        }

                        bgradePlayer.SetGrade(grade);
                        var time = bgradePlayer.GetTime();
                        chatMsgs.Add("Notice.SetGrade".Lang(player.UserIDString, grade));

                        if (AllowTimer && time > 0)
                        {
                            chatMsgs.Add("Notice.Time".Lang(player.UserIDString, time));
                        }

                        player.ChatMessage(string.Join("\n", chatMsgs.ToArray()));
                        return;
                    }

                case "t":
                    {
                        if ( !AllowTimer )
                        {
                            return;
                        }

                        if ( args.Length == 1 )
                        {
                            goto default;
                        }

                        int time;
                        if (!int.TryParse(args[1], out time) || time <= 0)
                        {
                            player.ChatMessage("Error.InvalidTime".Lang(player.UserIDString, args[1]));
                            return;
                        }

                        if (time > MaxTimer)
                        {
                            player.ChatMessage("Error.TimerTooLong".Lang(player.UserIDString, MaxTimer));
                            return;
                        }

                        BGradePlayer bgradePlayer;
                        if ( !BGradePlayer.Players.TryGetValue( player, out bgradePlayer ) )
                        {
                            bgradePlayer = player.gameObject.AddComponent<BGradePlayer>();
                        }

                        player.ChatMessage("Notice.SetTime".Lang(player.UserIDString, time));
                        bgradePlayer.SetTime(time);
                        return;
                    }

                case "help":
                    {
                        chatMsgs.Add("Command.Help".Lang(player.UserIDString));
                        if (AllowTimer)
                        {
                            chatMsgs.Add("Command.Help.T".Lang(player.UserIDString, command));
                            chatMsgs.Add("Command.Help.0".Lang(player.UserIDString, command));
                        }

                        for (var i = 1; i < 5; i++)
                        {
                            if (player.HasPluginPerm(i.ToString()) || player.HasPluginPerm("all"))
                                chatMsgs.Add($"Command.Help.{i}".Lang(player.UserIDString, command));
                        }

                        if (chatMsgs.Count <= 3 && !player.HasPluginPerm("all"))
                        {
                            player.ChatMessage("Permission".Lang(player.UserIDString));
                            return;
                        }

                        BGradePlayer bgradePlayer;
                        if ( BGradePlayer.Players.TryGetValue( player, out bgradePlayer ) )
                        {
                            chatMsgs.Add( "Command.Settings".Lang( player.UserIDString ) );
                            if ( AllowTimer )
                            {
                                chatMsgs.Add( "Command.Settings.Timer".Lang( player.UserIDString, bgradePlayer.GetTime( false ) ) );
                            }

                            var fetchedGrade = bgradePlayer.GetGrade();
                            chatMsgs.Add( "Command.Settings.Grade".Lang( player.UserIDString, fetchedGrade == 0 ? "Words.Disabled".Lang( player.UserIDString ) : fetchedGrade.ToString() ) );
                        }

                        player.ChatMessage(string.Join("\n", chatMsgs.ToArray()));
                        return;
                    }

                default:
                    {
                        player.ChatMessage("Error.InvalidArgs".Lang(player.UserIDString, command));
                        return;
                    }
            }
        }

        private void BGradeUpCommand(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();
            if (player == null)
            {
                return;
            }

            if (!player.HasAnyPermission(_registeredPermissions))
            {
                player.ChatMessage("Permission".Lang(player.UserIDString));
                return;
            }

            BGradePlayer bgradePlayer;
            if ( !BGradePlayer.Players.TryGetValue( player, out bgradePlayer ) )
            {
                bgradePlayer = player.gameObject.AddComponent<BGradePlayer>();
            }
            var grade = bgradePlayer.GetGrade() + 1;
            var count = 0;

            if (!player.HasPluginPerm("all"))
            {
                while (!player.HasPluginPerm(grade.ToString()))
                {
                    var newGrade = grade++;
                    if (newGrade > 4)
                    {
                        grade = 1;
                    }

                    if (count > bgradePlayer.GetGrade() + 4)
                    {
                        player.ChatMessage("Permission".Lang(player.UserIDString));
                        return;
                    }
                }
            }
            else if (grade > 4) grade = 1;

            var chatMsgs = new List<string>();
            bgradePlayer.SetGrade(grade);
            var time = bgradePlayer.GetTime();

            chatMsgs.Add("Notice.SetGrade".Lang(player.UserIDString, grade));
            if (AllowTimer && time > 0)
            {
                chatMsgs.Add("Notice.Time".Lang(player.UserIDString, time));
            }

            player.ChatMessage(string.Join("\n", chatMsgs.ToArray()));
        }

        #endregion
    }
}

namespace Oxide.Plugins.BGradeExt
{
    public static class BGradeExtensions
    {
        private static readonly Permission permission = Interface.Oxide.GetLibrary<Permission>();
        private static readonly Lang lang = Interface.Oxide.GetLibrary<Lang>();

        public static bool HasAnyPermission(this BasePlayer player, ListHashSet<string> perms)
        {
            foreach (var perm in perms)
            {
                if (!player.HasPermission(perm))
                {
                    continue;
                }

                return true;
            }

            return false;
        }

        public static bool HasPermission(this BasePlayer player, string perm)
        {
            return permission.UserHasPermission(player.UserIDString, perm);
        }

        public static bool HasPluginPerm(this BasePlayer player, string perm)
        {
            return permission.UserHasPermission(player.UserIDString, BGrade.Instance.Name.ToLower() + "." + perm);
        }

        public static string Lang(this string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, BGrade.Instance, id), args);
        }

        public static bool HasItemAmount(this BasePlayer player , int itemId , int itemAmount)
        {
            var count = 0;

            foreach (var item in player.inventory.containerMain.itemList)
            {
                if (item.info.itemid == itemId)
                {
                    count += item.amount;
                }
            }

            foreach (var item in player.inventory.containerBelt.itemList)
            {
                if (item.info.itemid == itemId)
                {
                    count += item.amount;
                }
            }

            foreach (var item in player.inventory.containerWear.itemList)
            {
                if (item.info.itemid == itemId)
                {
                    count += item.amount;
                }
            }

            return count >= itemAmount;
        }


        public static bool HasItemAmount(this BasePlayer player , int itemId , int itemAmount , out int amountGot)
        {
            var count = 0;

            foreach (var item in player.inventory.containerMain.itemList)
            {
                if (item.info.itemid == itemId)
                {
                    count += item.amount;
                }
            }

            foreach (var item in player.inventory.containerBelt.itemList)
            {
                if (item.info.itemid == itemId)
                {
                    count += item.amount;
                }
            }

            foreach (var item in player.inventory.containerWear.itemList)
            {
                if (item.info.itemid == itemId)
                {
                    count += item.amount;
                }
            }

            amountGot = count;
            return count >= itemAmount;
        }


        public static void TakeItem(this BasePlayer player, int itemId, int itemAmount)
        {
            if (player.inventory.Take(null, itemId, itemAmount) > 0)
            {
                player.SendConsoleCommand("note.inv", itemId, itemAmount * -1);
            }
        }
    }
}

// --- End of file: BGrade.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/biome-chat-prefix ---
// --- Original File Path: B/BiomeChatPrefix/BiomeChatPrefix.cs ---

/*
 * TODO
 * - Add commands
 * - Add individual player exclusions
 * - Permissions for biomes instead of a all in 1 permission 
 */

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Biome Chat Prefix", "Enforcer", "2.0.2")]
    [Description("Adds a prefix when a player is in a certain biome")]
    public class BiomeChatPrefix : RustPlugin
    {
        #region References

        [PluginReference]
        Plugin BetterChat;

        #endregion

        #region Field 

        private List<JObject> groupList = new List<JObject>(); 

        #endregion

        #region Permissions

        private const string showPerm = "biomechatprefix.show";

        #endregion

        #region Init

        private void OnServerInitialized()
        {
            permission.RegisterPermission(showPerm, this);

            if (BetterChat != null && BetterChat.IsLoaded)
            {
                Unsubscribe(nameof(OnPlayerChat));
            }
        }

        #endregion

        #region Hooks

        object OnPlayerChat(BasePlayer player, string message)
        {
            if (permission.UserHasPermission(player.UserIDString, showPerm))
            {
                string region = GetRegion(player, player.transform.position);

                if (region != "NoRegion")
                {
                    Server.Broadcast(message, region, player.userID);
                    return true;
                }
            }

            return null;
        }

        Dictionary<string, object> OnBetterChat(Dictionary<string, object> data)
        {
            var player = (data["Player"] as IPlayer).Object as BasePlayer;

            if (permission.UserHasPermission(player.UserIDString, showPerm))
            {
                var message = data["Message"].ToString();

                var region = GetRegion(player, player.transform.position);
                var format = string.Format(region + " " + message);

                data["Message"] = format;
                
            }

            return data;
        }

        #endregion

        #region Functions
        
        // Gets the Region the player is currently in
        string GetRegion(BasePlayer player, Vector3 Pos)
        {
            if (config.aridRegionSettings.enableAridRegion)
            {
                if (TerrainMeta.BiomeMap.GetBiome(Pos, 1) > 0.5f)
                {
                    if (config.aridRegionSettings.useAridRegionPrefix)
                    {
                        if (player.net.connection.authLevel == 2 && config.aridRegionSettings.aridRegionExclusions.addPrefixToAdmins || player.net.connection.authLevel == 1 && config.aridRegionSettings.aridRegionExclusions.addPrefixToModerators)
                        {
                            return $"<color={config.aridRegionSettings.aridChatPrefixColour}>{config.aridRegionSettings.aridRegionPrefix}</color>";
                        }

                        return player.net.connection.authLevel >= 1 ? "NoRegion" : $"<color={config.aridRegionSettings.aridChatPrefixColour}>{config.aridRegionSettings.aridRegionPrefix}</color>";
                    }

                }
            }

            if (config.temperateRegionSettings.enableTemperateRegion)
            {
                if (TerrainMeta.BiomeMap.GetBiome(Pos, 2) > 0.5f)
                {
                    if (config.temperateRegionSettings.useTemperateRegionPrefix)
                    {
                        if (player.net.connection.authLevel == 2 && config.temperateRegionSettings.temperateRegionExclusions.addPrefixToAdmins || player.net.connection.authLevel == 1 && config.temperateRegionSettings.temperateRegionExclusions.addPrefixToModerators)
                        {
                            return $"<color={config.temperateRegionSettings.temperateChatPrefixColour}>{config.temperateRegionSettings.TemperateRegionPrefix}</color>";
                        }
                    
                        return player.net.connection.authLevel >= 1 ? "NoRegion" : $"<color={config.temperateRegionSettings.temperateChatPrefixColour}>{config.temperateRegionSettings.TemperateRegionPrefix}</color>";
                    }
                }
            }

            if (config.tundraRegionSettings.enableTundraRegion)
            {
                if (TerrainMeta.BiomeMap.GetBiome(Pos, 4) > 0.5f)
                {
                    if (config.tundraRegionSettings.useTundraRegionPrefix)
                    {
                        if (player.net.connection.authLevel == 2 && config.tundraRegionSettings.tundraRegionExclusions.addPrefixToAdmins || player.net.connection.authLevel == 1 && config.tundraRegionSettings.tundraRegionExclusions.addPrefixToModerators)
                        {
                            return $"<color={config.tundraRegionSettings.TundraChatPrefixColour}>{config.tundraRegionSettings.TundraRegionPrefix}</color>";
                        }
                    
                        return player.net.connection.authLevel >= 1 ? "NoRegion" : $"<color={config.tundraRegionSettings.TundraChatPrefixColour}>{config.tundraRegionSettings.TundraRegionPrefix}</color>";
                    }
                }
            }

            if (config.arcticRegionSettings.enableArcticRegion)
            {
                if (TerrainMeta.BiomeMap.GetBiome(Pos, 8) > 0.5f)
                {
                    if (config.arcticRegionSettings.useArcticRegionPrefix)
                    {
                        if (player.net.connection.authLevel == 2 && config.arcticRegionSettings.arcticRegionExclusions.addPrefixToAdmins || player.net.connection.authLevel == 1 && config.arcticRegionSettings.arcticRegionExclusions.addPrefixToModerators)
                        {
                            return $"<color={config.arcticRegionSettings.arcticChatPrefixColour}>{config.arcticRegionSettings.arcticRegionPrefix}</color>";
                        }
                    
                        return player.net.connection.authLevel >= 1 ? "NoRegion" : $"<color={config.arcticRegionSettings.arcticChatPrefixColour}>{config.arcticRegionSettings.arcticRegionPrefix}</color>";
                    }
                }
            }

            return "NoRegion";
        }

        #endregion

        #region Config

        ConfigData config;
        public class ConfigData
        {
            [JsonProperty(PropertyName = "Arid (Desert) Biome")]
            public AridRegionSettings aridRegionSettings { get; set; }

            [JsonProperty(PropertyName = "Temperate (Grass) Biome")]
            public TemperateRegionSettings temperateRegionSettings { get; set; }

            [JsonProperty(PropertyName = "Tundra (Forest) Biome")]
            public TundraRegionSettings tundraRegionSettings { get; set; }

            [JsonProperty(PropertyName = "Arctic (Snow) Biome")]
            public ArcticRegionSettings arcticRegionSettings { get; set; }
        }

        public class AridRegionSettings
        {
            [JsonProperty(PropertyName = "Enable arid biome")]
            public bool enableAridRegion { get; set; }

            [JsonProperty(PropertyName = "Use arid biome chat prefix")]
            public bool useAridRegionPrefix { get; set; }

            [JsonProperty(PropertyName = "Arid biome prefix")]
            public string aridRegionPrefix { get; set; }

            [JsonProperty(PropertyName = "Arid biome prefix/name colour")]
            public string aridChatPrefixColour { get; set; }

            [JsonProperty(PropertyName = "Arid biome Exclusions")]
            public Exclusions aridRegionExclusions { get; set; }
        }

        public class TemperateRegionSettings
        {
            [JsonProperty(PropertyName = "Enable temperate biome")]
            public bool enableTemperateRegion { get; set; }

            [JsonProperty(PropertyName = "Use temperate biome chat prefix")]
            public bool useTemperateRegionPrefix { get; set; }

            [JsonProperty(PropertyName = "Temperate biome prefix")]
            public string TemperateRegionPrefix { get; set; }

            [JsonProperty(PropertyName = "Temperate biome prefix/name colour")]
            public string temperateChatPrefixColour { get; set; }

            [JsonProperty(PropertyName = "Arctic Biome Exclusions")]
            public Exclusions temperateRegionExclusions { get; set; }
        }

        public class TundraRegionSettings
        {
            [JsonProperty(PropertyName = "Enable tundra biome")]
            public bool enableTundraRegion { get; set; }

            [JsonProperty(PropertyName = "Use tundra biome chat prefix")]
            public bool useTundraRegionPrefix { get; set; }

            [JsonProperty(PropertyName = "Tundra biome prefix")]
            public string TundraRegionPrefix { get; set; }

            [JsonProperty(PropertyName = "Tundra biome prefix/name colour")]
            public string TundraChatPrefixColour { get; set; }

            [JsonProperty(PropertyName = "Tundra Biome Exclusions")]
            public Exclusions tundraRegionExclusions { get; set; }
        }

        public class ArcticRegionSettings
        {
            [JsonProperty(PropertyName = "Enable arctic biome")]
            public bool enableArcticRegion { get; set; }

            [JsonProperty(PropertyName = "Use arctic biome chat prefix")]
            public bool useArcticRegionPrefix { get; set; }

            [JsonProperty(PropertyName = "Arctic biome prefix")]
            public string arcticRegionPrefix { get; set; }

            [JsonProperty(PropertyName = "Arctic biome prefix/name colour")]
            public string arcticChatPrefixColour { get; set; }

            [JsonProperty(PropertyName = "Arctic Biome Exclusions")]
            public Exclusions arcticRegionExclusions { get; set; }
        }

        public class Exclusions
        {
            [JsonProperty(PropertyName = "Add prefix to admins")]
            public bool addPrefixToAdmins { get; set; }

            [JsonProperty(PropertyName = "Add prefix to moderators")]
            public bool addPrefixToModerators { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError($"{Name}.json is corrupted! Recreating a new configuration");
                LoadDefaultConfig();
                return;
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData()
            {
                aridRegionSettings = new AridRegionSettings()
                {
                    enableAridRegion = true,
                    useAridRegionPrefix = true,
                    aridRegionPrefix = "[Desert]",
                    aridChatPrefixColour = "#D38D4B",

                    aridRegionExclusions = new Exclusions()
                    {
                        addPrefixToAdmins = true,
                        addPrefixToModerators = true,
                    }
                },

                temperateRegionSettings = new TemperateRegionSettings()
                {
                    enableTemperateRegion = true,
                    useTemperateRegionPrefix = true,
                    TemperateRegionPrefix = "[Grass]",
                    temperateChatPrefixColour = "#348C31",

                    temperateRegionExclusions = new Exclusions()
                    {
                        addPrefixToAdmins = true,
                        addPrefixToModerators = true,
                    }
                },

                tundraRegionSettings = new TundraRegionSettings()
                {
                    enableTundraRegion = true,
                    useTundraRegionPrefix = true,
                    TundraRegionPrefix = "[Forest]",
                    TundraChatPrefixColour = "#014421",

                    tundraRegionExclusions = new Exclusions()
                    {
                        addPrefixToAdmins = true,
                        addPrefixToModerators = true,
                    }
                },

                arcticRegionSettings = new ArcticRegionSettings()
                {
                    enableArcticRegion = true,
                    useArcticRegionPrefix = true,
                    arcticRegionPrefix = "[Snow]",
                    arcticChatPrefixColour = "white",

                    arcticRegionExclusions = new Exclusions()
                    {
                        addPrefixToAdmins = true,
                        addPrefixToModerators = true,
                    }
                }
            };

            PrintWarning("Creating a new configuration file!");
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
    }
}

// --- End of file: BiomeChatPrefix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/barricades ---
// --- Original File Path: B/Barricades/Barricades.cs ---

using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Rust;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Barricades", "Xianith / redBDGR", "0.0.3", ResourceId = 2460)]
    [Description("Legacy wooden barricade made out of double stacked sign posts. Can be picked up.")]
    class Barricades : RustPlugin
    {
        static Barricades bCades = null;
        Dictionary<BasePlayer, BaseEntity> barricaders = new Dictionary<BasePlayer, BaseEntity>();
        Dictionary<string, BarricadeGui> BarricadeGUIinfo = new Dictionary<string, BarricadeGui>();

        class BarricadeGui { public string panel; public BaseEntity entity; }

        #region Config
        public bConfig Settings { get; private set; }
        public class bConfig
        {
            [JsonProperty(PropertyName = "Initial Health of a placed Barricade")]
            public int Health { get; set; }

            [JsonProperty(PropertyName = "Can be picked up")]
            public bool CanBePicked { get; set; }

            public static bConfig DefaultConfig() {
                return new bConfig
                {
                    Health = 50,
                    CanBePicked = true
                };
            }
        }

        protected override void LoadConfig() {
            base.LoadConfig();
            Settings = Config.ReadObject<bConfig>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig() { Settings = bConfig.DefaultConfig(); }
        protected override void SaveConfig() { Config.WriteObject(Settings); }
        #endregion

        void Unload() {
            foreach (BasePlayer player in BasePlayer.activePlayerList) {
                DestroyBarrUi(player);
            }
        }

        void Init() {
            bCades = this;
            permission.RegisterPermission("barricades.add", this);

            var Entity = UnityEngine.Object.FindObjectsOfType<BaseEntity>().ToList();

            foreach (BaseEntity e in Entity)
            {
                if (e.name.Contains("sign.post.town") && e.skinID == 1510599461) { e.Kill(); }
                // h?.Kill();
            }

        }

        void OnPlayerInput(BasePlayer player, InputState input) {
            if (Settings.CanBePicked == false) return;
            if (!input.IsDown(BUTTON.USE)) return;
            if (!barricaders.ContainsKey(player)) return;

            BaseEntity entity = barricaders[player];
            if (!entity || entity == null || !entity.IsValid()) {
                barricaders.Remove(player);
                return;
            }

            timer.Once(0.001f, () => {
                entity.Kill();
                DestroyBarrUi(player);
                createBarricade(player);
                return;
            });
        }

        void OnEntitySpawned(BaseNetworkable entityn) {
            BaseEntity parent = entityn as BaseEntity;

            if (parent.ShortPrefabName != "sign.post.town") return;
            if (parent.skinID != 1510599461) return;

            parent.gameObject.AddComponent<BarricadeRadius>();

            var ownerID = parent.OwnerID;

            BasePlayer player = BasePlayer.FindByID(ownerID);

            var ent = GameManager.server.CreateEntity("assets/prefabs/deployable/signs/sign.post.town.prefab", new Vector3(0, -1.05f, 0), Quaternion.Euler(0, 0, 0));

            ent.SetParent(parent);

            parent.SetFlag(BaseEntity.Flags.Busy, true);
            ent.SetFlag(BaseEntity.Flags.Busy, true);

            parent.GetComponent<BaseCombatEntity>().health = Settings.Health;
            ent.GetComponent<BaseCombatEntity>().startHealth = Settings.Health;

            ent.UpdateNetworkGroup();
            ent.SendNetworkUpdateImmediate();
            ent.Spawn();

            // decay(ent);
        }

        void decay(BaseEntity ent) {

        }

        class BarricadeRadius : MonoBehaviour {
            BaseEntity entity;
            public bool isEnabled;

            private void Awake() {
                entity = GetComponent<BaseEntity>();
                var collider = entity.gameObject.AddComponent<SphereCollider>();
                collider.gameObject.layer = (int)Layer.Reserved1;
                collider.radius = 1.5f;
                // collider.material = "assets/content/properties/materialconfig/dunes blended.asset";
                collider.isTrigger = true;
                isEnabled = true;
            }

            private void OnTriggerEnter(Collider col) {
                var player = col.GetComponent<BasePlayer>();
                if (player == null) return;
                if (!player.IsValid()) return;

                if (bCades.barricaders.ContainsKey(player))
                    bCades.barricaders.Remove(player);
                bCades.CreateBarrUi(player, entity);
                bCades.barricaders.Add(player, entity);
            }

            private void OnTriggerExit(Collider col) {
                var player = col.GetComponent<BasePlayer>();
                if (player == null) return;
                if (!player.IsValid()) return;

                if (bCades.barricaders.ContainsKey(player))
                    bCades.barricaders.Remove(player);
                bCades.DestroyBarrUi(player);

            }
        }

        void CreateBarrUi(BasePlayer player, BaseEntity entity) {
            if (Settings.CanBePicked == false) return;
            if (BarricadeGUIinfo.ContainsKey(player.UserIDString)) {
                CuiHelper.DestroyUi(player, BarricadeGUIinfo[player.UserIDString].panel);
                BarricadeGUIinfo.Remove(player.UserIDString);
            }

            var elements = new CuiElementContainer();
            var rpanel = elements.Add(new CuiPanel {
                Image = { Color = "0.1 0.1 0.1 0", FadeIn = 1.0f },
                RectTransform = { AnchorMin = "0.4 0.4", AnchorMax = "0.59 0.5" },
            }, "Hud");
            elements.Add(new CuiLabel {
                Text = { Text = "<size=35>⇧</size>\n" + lang.GetMessage("pickup", this), Color = "0.8 0.8 0.8 1", FontSize = 14, Align = TextAnchor.MiddleCenter, FadeIn = 1f },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, rpanel);
            CuiHelper.AddUi(player, elements);
            BarricadeGUIinfo.Add(player.UserIDString, new BarricadeGui() { panel = rpanel, entity = entity });
        }

        void DestroyBarrUi(BasePlayer player) {
            if (BarricadeGUIinfo.ContainsKey(player.UserIDString))
            {
                CuiHelper.DestroyUi(player, BarricadeGUIinfo[player.UserIDString].panel);
                BarricadeGUIinfo.Remove(player.UserIDString);
            }
        }

        void createBarricade(BasePlayer player) {
            Item newItem = ItemManager.Create(ItemManager.FindItemDefinition("sign.post.town"), 1, 0uL);
            newItem.name = lang.GetMessage("name", this);
            newItem.skin = 1510599461;

            if (!newItem.MoveToContainer(player.inventory.containerBelt))
                newItem.Drop(player.inventory.containerBelt.dropPosition, player.inventory.containerBelt.dropVelocity);
        }

        #region Commands
        [ConsoleCommand("barricade.add")] //Used to add barricade to belt if you have the barricades.user permission
        void cmdBarricadeAdd(ConsoleSystem.Arg arg) {
            BasePlayer player = arg.Player();
            if (permission.UserHasPermission(player.UserIDString, "barricades.use")) {
                createBarricade(player);
                SendReply(player, string.Format(lang.GetMessage("title", this) + lang.GetMessage("added", this)));
            }
            else
                SendReply(player, string.Format(lang.GetMessage("title", this) + lang.GetMessage("noperms", this)));
            return;
        }

        [ConsoleCommand("barricade.buy")] //Used as the command to buy a barricade in conjunction with a plugin like GUI Shop. Is run through the server and can not be used in game.
        void cmdBarricadeBuy(ConsoleSystem.Arg arg) {
            if (arg.Player()) return;
            if (!arg.HasArgs(1)) { Puts(lang.GetMessage("args", this)); return; }
                var targetPlayer = arg.GetPlayerOrSleeper(1);
                if (!targetPlayer) return;
                createBarricade(targetPlayer);
                Puts(lang.GetMessage("buy", this, targetPlayer.displayName));
            return;
        }
        #endregion

        #region LangAPI
        void LoadDefaultMessages() {
            lang.RegisterMessages(new Dictionary<string, string>() {
                {"title", "<color=orange>Barricades</color> : "},
                {"name", "Wooden Barricade"},
                {"noperms", "You do not have permission to add a barricade to your inventory!"},
                {"added", "1x Barricade added to inventory!"},
                {"pickup", "PICK UP"},
                {"args", "Missing arguments!"},
                {"buy", "{0} recieved a barricade!"}
            }, this);
        }
        #endregion
    }
} 

// --- End of file: Barricades.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/breakable-cctv ---
// --- Original File Path: B/BreakableCCTV/BreakableCCTV.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Breakable CCTV", "Clearshot", "1.1.0")]
    [Description("Shoot monument CCTV cameras to temporarily disable them")]
    class BreakableCCTV : CovalencePlugin
    {
        private PluginConfig _config;
        private Game.Rust.Libraries.Player _rustPlayer = Interface.Oxide.GetLibrary<Game.Rust.Libraries.Player>("Player");
        private Dictionary<string, int> _cctvHealth = new Dictionary<string, int>();

        private void SendChatMsg(BasePlayer pl, string msg, string prefix = null) =>
            _rustPlayer.Message(pl, msg, prefix != null ? prefix : lang.GetMessage("ChatPrefix", this, pl.UserIDString), Convert.ToUInt64(_config.chatIconID), Array.Empty<object>());

        private void OnServerInitialized()
        {
            bool added = false;
            foreach (var cctv in UnityEngine.Object.FindObjectsOfType<CCTV_RC>().OrderBy(x => x.GetIdentifier()))
            {
                string id = cctv.GetIdentifier();
                string netID = cctv.net.ID.ToString();
                if (id.Contains(netID))
                {
                    id = id.Replace(netID, "");
                }

                if (cctv != null && cctv.isStatic && cctv.OwnerID == 0 && !_config.cctvConfig.ContainsKey(id))
                {
                    Puts("Adding missing CCTVConfig: " + id);
                    _config.cctvConfig.Add(id, new CCTVConfig());
                    added = true;
                }
            }

            if (added)
                Config.WriteObject(_config);
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || !(entity is CCTV_RC) || info == null || info.InitiatorPlayer == null) return null;
            CCTV_RC cctv = entity as CCTV_RC;
            if (cctv == null || !cctv.isStatic || cctv.OwnerID != 0 || cctv.limitNetworking) return null;

            string cctvID = cctv.GetIdentifier(), cctvIDModified = cctvID;
            string netID = cctv.net.ID.ToString();
            if (cctvIDModified.Contains(netID))
            {
                cctvIDModified = cctvIDModified.Replace(netID, "");
            }

            CCTVConfig cctvCfg;
            if (!_config.cctvConfig.TryGetValue(cctvIDModified, out cctvCfg)) return null;
            if (!cctvCfg.enabled) return null;

            BasePlayer pl = info.InitiatorPlayer;
            int dmg = UnityEngine.Random.Range(_config.damagePerHitMin, _config.damagePerHitMax);
            int health = _cctvHealth[cctvID] = Math.Max((_cctvHealth.ContainsKey(cctvID) ? _cctvHealth[cctvID] : cctvCfg.health) - dmg, 0);
            string msg = string.Format(lang.GetMessage("CameraHealth", this, pl.UserIDString), health);

            if (health < 1)
            {
                cctv.limitNetworking = true;
                Effect.server.Run(_config.destroyEffect, cctv.transform.position);

                float respawnTime = cctvCfg.respawnTime > 0 ? cctvCfg.respawnTime : _config.globalRespawnTime;
                timer.Once(respawnTime, () => {
                    if (cctv != null)
                    {
                        cctv.limitNetworking = false;
                        _cctvHealth.Remove(cctvID);
                        Effect.server.Run(_config.restoreEffect, cctv.transform.position);
                    }
                });

                msg = string.Format(lang.GetMessage("CameraDisabled", this, pl.UserIDString), respawnTime);
            }

            SendChatMsg(pl, msg);
            return null;
        }

        private void Unload()
        {
            foreach (var cctv in UnityEngine.Object.FindObjectsOfType<CCTV_RC>())
            {
                if (cctv != null && cctv.isStatic && cctv.OwnerID == 0 && cctv.limitNetworking)
                {
                    cctv.limitNetworking = false;
                }
            }
        }

        #region Config

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ChatPrefix"] = "<color=#00a7fe>[Breakable CCTV]</color>",
                ["CameraHealth"] = "Camera HP: <color=#cb3f2a>{0}</color>",
                ["CameraDisabled"] = "Camera disabled for <color=#87b33a>{0}s</color>"
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
        }

        private class PluginConfig
        {
            public string chatIconID = "0";
            public int globalRespawnTime = 60;
            public int damagePerHitMin = 10;
            public int damagePerHitMax = 30;
            public string destroyEffect = "assets/bundled/prefabs/fx/item_break.prefab";
            public string restoreEffect = "assets/bundled/prefabs/fx/build/promote_toptier.prefab";
            public Dictionary<string, CCTVConfig> cctvConfig = new Dictionary<string, CCTVConfig>();
        }

        private class CCTVConfig
        {
            public bool enabled = true;
            public int health = 100;
            public int respawnTime = 0;
        }

        #endregion
    }
}


// --- End of file: BreakableCCTV.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/blind-death ---
// --- Original File Path: B/BlindDeath/BlindDeath.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Oxide.Plugins
{

    [Info("Blind Death", "UNKNOWN", "0.0.1")]
    [Description("Hide Killer DeathScreen")]
    public class BlindDeath : RustPlugin
    {
        string BlindContainer = "UI_Blind";

        private void OnEntityDeath(BasePlayer player)
        {
            timer.Once(0.2f, () =>
            {
                if (player == null || player.IsConnected == false || player.IsAlive()) return;

                BlindUI(player);
            });
        }
        private void OnPlayerRespawn(BasePlayer player)
        {
            timer.Once(_config.UI_DestoryTime, () =>
            {
                CuiHelper.DestroyUi(player, BlindContainer);
            });
        }

        private void BlindUI(BasePlayer player)
        {
            var score = new CuiElementContainer();

            CuiHelper.DestroyUi(player, BlindContainer);

            score.Add(new CuiPanel
            {
                Image =
                {
                    Color = _config.UI_Color
                },
                RectTransform =
                {
                    AnchorMin = _config.UI_AnchorMin,
                    AnchorMax = _config.UI_AnchorMax
                },
                
                CursorEnabled = false

            }, "Overlay", BlindContainer);

            CuiHelper.AddUi(player, score);
        }
        void Unload()
        {
            foreach (var players in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(players, BlindContainer);
            }
        }

        #region Config
        private Configuration _config;
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class Configuration
        {
            [JsonProperty("UI DestoryTime")]
            public float UI_DestoryTime { get; set; } = 5.0f;
            [JsonProperty("UI AnchorMin")]
            public string UI_AnchorMin { get; set; } = "0.313 0.861";

            [JsonProperty("UI AnchorMax")]
            public string UI_AnchorMax { get; set; } = "0.703 1";
            [JsonProperty("UI Color")]
            public string UI_Color { get; set; } = "0 0 0 1";
        }
        #endregion
    }
}


// --- End of file: BlindDeath.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bradley-control ---
// --- Original File Path: B/BradleyControl/BradleyControl.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using UnityEngine;
using Pool = Facepunch.Pool;
using Random = UnityEngine.Random;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("BradleyControl", "Dana", "1.1.0")]
    [Description("Inject your armored beast with steroids and level it up with the intelligence and strength it deserves.")]
    public class BradleyControl : RustPlugin
    {
        #region Fields

        private static BradleyControl _instance;
        private static Configuration _config;

        private HashSet<FireBall> _bradleyFireBalls = new HashSet<FireBall>();
        private HashSet<HelicopterDebris> _bradleyDebris = new HashSet<HelicopterDebris>();
        private HashSet<LockedByEntCrate> _bradleyCrates = new HashSet<LockedByEntCrate>();
        private HashSet<BradleyAPC> _spawnedBradleys = new HashSet<BradleyAPC>();

        private const string FIRE_BALL_PREFAB = "assets/bundled/prefabs/oilfireballsmall.prefab";
        private const string BRADLEY_CRATE_PREFAB = "assets/prefabs/npc/m2bradley/bradley_crate.prefab";
        private const string BRADLEY_DEBRIS_PREFAB = "assets/prefabs/npc/m2bradley/servergibs_bradley.prefab";

        private Vector3 _lastCrashSitePosition;

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Health")]
            public HealthSettings Health { get; set; }

            [JsonProperty("Loot")]
            public LootSettings Loot { get; set; }

            [JsonProperty("Flame")]
            public FireBallSettings Flame { get; set; }

            [JsonProperty("Debris")]
            public DebrisSettings Debris { get; set; }

            [JsonProperty("Movement")]
            public MovementSettings Movement { get; set; }

            [JsonProperty("Targeting")]
            public TargetingSettings Targeting { get; set; }

            [JsonProperty("Coax Turret")]
            public CoaxTurretSettings CoaxTurret { get; set; }

            [JsonProperty("Cannon")]
            public CannonSettings Cannon { get; set; }
        }

        private class HealthSettings
        {
            [JsonProperty("Starting Health")]
            public float StartingHealth { get; set; }

            [JsonProperty("Maximum Health")]
            public float MaximumHealth { get; set; }
        }

        private class LootSettings
        {
            [JsonProperty("Maximum Crates To Drop")]
            public int MaximumCratesToDrop { get; set; }
        }
        
        private class DebrisSettings
        {
            [JsonProperty("Drop On Destruction")]
            public bool DropOnDestruction { get; set; }

            [JsonProperty("Harvestable Hit Points")]
            public float HarvestableHitPoints { get; set; }

            [JsonProperty("Harvest Cooldown")]
            public float HarvestCooldown { get; set; }
        }

        private class FireBallSettings
        {
            [JsonProperty("Set Crates On Fire")]
            public bool SetCratesOnFire { get; set; }

            [JsonProperty("Minimum Life Time")]
            public float MinimumLifeTime { get; set; }

            [JsonProperty("Maximum Life Time")]
            public float MaximumLifeTime { get; set; }

            [JsonProperty("Spread Chance")]
            public int SpreadChance { get; set; }

            [JsonProperty("Spread At Lifetime Percent")]
            public int SpreadAtLifetimePercent { get; set; }

            [JsonProperty("Damage Per Second")]
            public float DamagePerSecond { get; set; }

            [JsonProperty("Damage Rate")]
            public float DamageRate { get; set; }

            [JsonProperty("Water Required To Extinguish")]
            public int WaterRequiredToExtinguish { get; set; }
        }

        private class MovementSettings
        {
            [JsonProperty("Maximum Speed")]
            public float MaximumSpeed { get; set; }

            [JsonProperty("Spin Speed")]
            public float SpinSpeed { get; set; }

            [JsonProperty("Brake Force")]
            public float BrakeForce { get; set; }
        }

        private class TargetingSettings
        {
            [JsonProperty("Engagement Range")]
            public float EngagementRange { get; set; }

            [JsonProperty("Target Search Range")]
            public float TargetSearchRange { get; set; }

            [JsonProperty("Memory Duration")]
            public float MemoryDuration { get; set; }
        }

        private class CoaxTurretSettings
        {
            [JsonProperty("Time Between Bursts")]
            public float TimeBetweenBursts { get; set; }

            [JsonProperty("Maximum Shots Per Burst")]
            public int MaximumShotsPerBurst { get; set; }

            [JsonProperty("Bullet Damage")]
            public float BulletDamage { get; set; }
        }

        private class CannonSettings
        {
            [JsonProperty("Recoil Intensity")]
            public float RecoilIntensity { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Detected changes in configuration! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Configuration update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                Health = new HealthSettings
                {
                    StartingHealth = 1000f,
                    MaximumHealth = 1000f
                },
                Loot = new LootSettings
                {
                    MaximumCratesToDrop = 3
                },
                Debris = new DebrisSettings
                {
                    DropOnDestruction = true,
                    HarvestableHitPoints = 500f,
                    HarvestCooldown = 480f
                },
                Flame = new FireBallSettings
                {
                    SetCratesOnFire = true,
                    MinimumLifeTime = 20f,
                    MaximumLifeTime = 40f,
                    SpreadChance = 50,
                    SpreadAtLifetimePercent = 50,
                    DamagePerSecond = 2f,
                    DamageRate = 0.5f,
                    WaterRequiredToExtinguish = 200,
                },
                Movement = new MovementSettings
                {
                    MaximumSpeed = 2000f,
                    BrakeForce = 100f,
                    SpinSpeed = 2000f,
                },
                Targeting = new TargetingSettings
                {
                    EngagementRange = 100f,
                    TargetSearchRange = 100f,
                    MemoryDuration = 20f,
                },
                CoaxTurret = new CoaxTurretSettings
                {
                    TimeBetweenBursts = 0.06667f,
                    MaximumShotsPerBurst = 10,
                    BulletDamage = 15f,
                },
                Cannon = new CannonSettings
                {
                    RecoilIntensity = 200f,
                }
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Init()
        {
            _instance = this;
        }

        private void OnServerInitialized()
        {
            foreach (BaseNetworkable entity in BaseNetworkable.serverEntities)
            {
                BradleyAPC bradley = entity as BradleyAPC;
                if (bradley == null)
                    continue;

                InitializeBradley(bradley);
                _spawnedBradleys.Add(bradley);
            }
        }

        private void Unload()
        {
            _spawnedBradleys.Clear();
            _instance = null;
            _config = null;
        }

        private void OnBradleyApcInitialize(BradleyAPC bradley)
        {
            InitializeBradley(bradley);
            _spawnedBradleys.Add(bradley);
        }
        
        private void OnEntityDeath(BradleyAPC bradley, HitInfo info)
        {
            _lastCrashSitePosition = bradley.transform.position;

            NextTick(() =>
            {
                CaptureAfterExplosionEntities(_lastCrashSitePosition);
                InitializeDebris();
                InitializeCrates();

                _spawnedBradleys.Remove(bradley);
            });
        }

        #endregion Oxide Hooks

        #region Functions
        
        private void CaptureAfterExplosionEntities(Vector3 position)
        {
            List<BaseEntity> nearbyEntities = Pool.GetList<BaseEntity>();
            Vis.Entities(position, 15f, nearbyEntities, LayerMask.GetMask("Ragdoll", "Default"), QueryTriggerInteraction.Ignore);

            if (nearbyEntities.Count != 0)
            {
                foreach (BaseEntity capturedEntity in nearbyEntities)
                {
                    LockedByEntCrate crate = capturedEntity as LockedByEntCrate;
                    if (crate != null && crate.PrefabName == BRADLEY_CRATE_PREFAB)
                    {
                        _bradleyCrates.Add(crate);

                        FireBall fireBall = FindChildByType<FireBall>(crate);
                        if (fireBall != null)
                            fireBall.Extinguish();
                    }

                    HelicopterDebris debris = capturedEntity as HelicopterDebris;
                    if (debris != null && debris.PrefabName == BRADLEY_DEBRIS_PREFAB)
                        _bradleyDebris.Add(debris);
                }
            }

            Pool.FreeList(ref nearbyEntities);
        }

        private void InitializeBradley(BradleyAPC bradley)
        {
            bradley.InitializeHealth(_config.Health.StartingHealth, _config.Health.MaximumHealth);          
            bradley.maxCratesToSpawn = _config.Loot.MaximumCratesToDrop;
            
            bradley.moveForceMax = _config.Movement.MaximumSpeed;
            bradley.brakeForce = _config.Movement.BrakeForce;
            bradley.turnForce = _config.Movement.SpinSpeed;

            bradley.viewDistance = _config.Targeting.EngagementRange;
            bradley.searchRange = _config.Targeting.TargetSearchRange;
            bradley.memoryDuration = _config.Targeting.MemoryDuration;

            bradley.coaxFireRate = _config.CoaxTurret.TimeBetweenBursts;
            bradley.coaxBurstLength = _config.CoaxTurret.MaximumShotsPerBurst;
            bradley.bulletDamage = _config.CoaxTurret.BulletDamage;

            bradley.recoilScale = _config.Cannon.RecoilIntensity;
        }

        private void InitializeDebris()
        {
            if (!_config.Debris.DropOnDestruction)
            {
                foreach (HelicopterDebris debris in _bradleyDebris)
                    if (debris != null)
                        debris.Kill();
            }
            else
            {
                foreach (HelicopterDebris debris in _bradleyDebris)
                {
                    if (debris != null)
                    {
                        debris.tooHotUntil = Time.realtimeSinceStartup + _config.Debris.HarvestCooldown;
                        debris.health = _config.Debris.HarvestableHitPoints;
                    }
                }
            }
        }

        private void InitializeCrates()
        {
            if (_config.Flame.SetCratesOnFire)
            {
                foreach (LockedByEntCrate crate in _bradleyCrates)
                {
                    if (crate != null)
                    {
                        FireBall fireBall = SpawnFireBall(crate);
                        InitializeFireBall(fireBall, crate);
                        _bradleyFireBalls.Add(fireBall);
                    }
                }
            }
        }

        private void InitializeFireBall(FireBall fireBall, LockedByEntCrate crate)
        {
            fireBall.SetParent(crate, true, true);
            fireBall.Spawn();
            fireBall.GetComponent<Rigidbody>().isKinematic = true;
            fireBall.GetComponent<Collider>().enabled = false;

            fireBall.tickRate = _config.Flame.DamageRate;
            fireBall.lifeTimeMin = _config.Flame.MinimumLifeTime;
            fireBall.lifeTimeMax = _config.Flame.MaximumLifeTime;
            fireBall.damagePerSecond = _config.Flame.DamagePerSecond;
            fireBall.waterToExtinguish = _config.Flame.WaterRequiredToExtinguish;
            fireBall.generation = (_config.Flame.SpreadChance == 0) ? 9f : (1f - (_config.Flame.SpreadChance / 100f)) / 0.1f;

            fireBall.Think();
            crate.SendMessage("SetLockingEnt", fireBall.gameObject, SendMessageOptions.DontRequireReceiver);

            Collider fireBallCollider = fireBall.GetComponent<Collider>();
            foreach (HelicopterDebris debris in _bradleyDebris)
            {
                Collider debrisCollider = debris.GetCollider();
                if (fireBallCollider != null && debrisCollider != null)
                    Physics.IgnoreCollision(fireBallCollider, debrisCollider, true);
            }

            float lifeTime = Random.Range(fireBall.lifeTimeMax, fireBall.lifeTimeMin);
            fireBall.Invoke(() => fireBall.Extinguish(), lifeTime);

            float spreadDelay = lifeTime * (_config.Flame.SpreadAtLifetimePercent / 100f);
            fireBall.Invoke(() => fireBall.TryToSpread(), spreadDelay);
        }

        private FireBall SpawnFireBall(LockedByEntCrate crate)
        {
            FireBall fireBall = GameManager.server.CreateEntity(FIRE_BALL_PREFAB, crate.transform.position) as FireBall;
            if (!fireBall)
                return null;

            return fireBall;
        }


        #endregion Functions

        #region Helper Functions

        private static T FindChildByType<T>(BaseEntity parentEntity, string prefabName = null) where T : BaseEntity
        {
            T result = null;
            foreach (BaseEntity childEntity in parentEntity.children)
            {
                T specificChild = childEntity as T;
                if (specificChild != null)
                {
                    if (prefabName == null || childEntity.PrefabName == prefabName)
                    {
                        result = specificChild;
                        break;
                    }
                }
            }

            return result;
        }

        #endregion Helper Functions
    }
}


// --- End of file: BradleyControl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-chat-toggle ---
// --- Original File Path: B/BetterChatToggle/BetterChatToggle.cs ---

﻿using System.Collections.Generic;
using Oxide.Core;
using System.Linq;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Better Chat Toggle", "Ryan", "1.0.0")]
    [Description("Easily toggle chat tags and formatting for Better Chat")]
    public class BetterChatToggle : CovalencePlugin
    {
        #region Declaration

        private const string UsePerm = "betterchattoggle.use";
        private bool ConfigChanged;

        private Dictionary<string, bool> TagData;

        private List<string> Tags;
        private List<string> Commands;

        #endregion

        #region Configuration

        protected override void LoadDefaultConfig() => PrintWarning("Generating default configuration file...");